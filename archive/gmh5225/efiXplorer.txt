Project Path: arc_gmh5225_efiXplorer_mhbmpbzj

Source Tree:

```txt
arc_gmh5225_efiXplorer_mhbmpbzj
├── LICENSE
├── README.md
├── build.py
├── cmake
│   └── FindIdaSdk.cmake
├── efiXloader
│   ├── 3rd
│   │   └── uefitool
│   │       ├── LICENSE.md
│   │       ├── README.md
│   │       ├── UEFIExtract
│   │       │   ├── CMakeLists.txt
│   │       │   ├── ffsdumper.cpp
│   │       │   ├── ffsdumper.h
│   │       │   ├── uefidump.cpp
│   │       │   ├── uefidump.h
│   │       │   └── uefiextract_main.cpp
│   │       ├── UEFIFind
│   │       │   ├── CMakeLists.txt
│   │       │   ├── uefifind.cpp
│   │       │   ├── uefifind.h
│   │       │   └── uefifind_main.cpp
│   │       ├── UEFITool
│   │       │   ├── Info.plist
│   │       │   ├── ffsfinder.cpp
│   │       │   ├── ffsfinder.h
│   │       │   ├── gotoaddressdialog.h
│   │       │   ├── gotoaddressdialog.ui
│   │       │   ├── gotobasedialog.h
│   │       │   ├── gotobasedialog.ui
│   │       │   ├── guidlineedit.cpp
│   │       │   ├── guidlineedit.h
│   │       │   ├── hexspinbox.cpp
│   │       │   ├── hexspinbox.h
│   │       │   ├── hexviewdialog.cpp
│   │       │   ├── hexviewdialog.h
│   │       │   ├── hexviewdialog.ui
│   │       │   ├── icons
│   │       │   │   ├── uefitool.icns
│   │       │   │   ├── uefitool.ico
│   │       │   │   ├── uefitool_128x128.png
│   │       │   │   ├── uefitool_16x16.png
│   │       │   │   ├── uefitool_256x256.png
│   │       │   │   ├── uefitool_32x32.png
│   │       │   │   ├── uefitool_48x48.png
│   │       │   │   ├── uefitool_512x512.png
│   │       │   │   └── uefitool_64x64.png
│   │       │   ├── qhexedit2
│   │       │   │   ├── chunks.cpp
│   │       │   │   ├── chunks.h
│   │       │   │   ├── commands.cpp
│   │       │   │   ├── commands.h
│   │       │   │   ├── license.txt
│   │       │   │   ├── qhexedit.cpp
│   │       │   │   └── qhexedit.h
│   │       │   ├── searchdialog.cpp
│   │       │   ├── searchdialog.h
│   │       │   ├── searchdialog.ui
│   │       │   ├── uefitool.cpp
│   │       │   ├── uefitool.desktop
│   │       │   ├── uefitool.h
│   │       │   ├── uefitool.pro
│   │       │   ├── uefitool.qrc
│   │       │   ├── uefitool.rc
│   │       │   ├── uefitool.ui
│   │       │   └── uefitool_main.cpp
│   │       ├── common
│   │       │   ├── LZMA
│   │       │   │   ├── LzmaCompress.c
│   │       │   │   ├── LzmaCompress.h
│   │       │   │   ├── LzmaDecompress.c
│   │       │   │   ├── LzmaDecompress.h
│   │       │   │   ├── SDK
│   │       │   │   │   └── C
│   │       │   │   │       ├── 7zVersion.h
│   │       │   │   │       ├── Bra.h
│   │       │   │   │       ├── Bra86.c
│   │       │   │   │       ├── CpuArch.h
│   │       │   │   │       ├── LzFind.c
│   │       │   │   │       ├── LzFind.h
│   │       │   │   │       ├── LzHash.h
│   │       │   │   │       ├── LzmaDec.c
│   │       │   │   │       ├── LzmaDec.h
│   │       │   │   │       ├── LzmaEnc.c
│   │       │   │   │       ├── LzmaEnc.h
│   │       │   │   │       └── Types.h
│   │       │   │   └── UefiLzma.h
│   │       │   ├── Tiano
│   │       │   │   ├── EfiTianoCompress.c
│   │       │   │   ├── EfiTianoCompress.h
│   │       │   │   ├── EfiTianoCompressLegacy.c
│   │       │   │   ├── EfiTianoDecompress.c
│   │       │   │   └── EfiTianoDecompress.h
│   │       │   ├── basetypes.h
│   │       │   ├── bootguard.h
│   │       │   ├── bstrlib
│   │       │   │   ├── LICENSE
│   │       │   │   ├── bstrlib.c
│   │       │   │   ├── bstrlib.h
│   │       │   │   ├── bstrwrap.cpp
│   │       │   │   └── bstrwrap.h
│   │       │   ├── descriptor.cpp
│   │       │   ├── descriptor.h
│   │       │   ├── ffs.cpp
│   │       │   ├── ffs.h
│   │       │   ├── ffsbuilder.cpp
│   │       │   ├── ffsbuilder.h
│   │       │   ├── ffsops.cpp
│   │       │   ├── ffsops.h
│   │       │   ├── ffsparser.cpp
│   │       │   ├── ffsparser.h
│   │       │   ├── ffsreport.cpp
│   │       │   ├── ffsreport.h
│   │       │   ├── ffsutils.cpp
│   │       │   ├── ffsutils.h
│   │       │   ├── filesystem.h
│   │       │   ├── fit.h
│   │       │   ├── gbe.h
│   │       │   ├── guiddatabase.cpp
│   │       │   ├── guiddatabase.h
│   │       │   ├── guids.csv
│   │       │   ├── me.h
│   │       │   ├── meparser.cpp
│   │       │   ├── meparser.h
│   │       │   ├── nvram.cpp
│   │       │   ├── nvram.h
│   │       │   ├── nvramparser.cpp
│   │       │   ├── nvramparser.h
│   │       │   ├── parsingdata.h
│   │       │   ├── peimage.cpp
│   │       │   ├── peimage.h
│   │       │   ├── sha256.c
│   │       │   ├── sha256.h
│   │       │   ├── treeitem.cpp
│   │       │   ├── treeitem.h
│   │       │   ├── treemodel.cpp
│   │       │   ├── treemodel.h
│   │       │   ├── types.cpp
│   │       │   ├── types.h
│   │       │   ├── ubytearray.h
│   │       │   ├── ustring.cpp
│   │       │   ├── ustring.h
│   │       │   ├── utility.cpp
│   │       │   ├── utility.h
│   │       │   └── zlib
│   │       │       ├── adler32.c
│   │       │       ├── compress.c
│   │       │       ├── crc32.c
│   │       │       ├── crc32.h
│   │       │       ├── deflate.c
│   │       │       ├── deflate.h
│   │       │       ├── gzclose.c
│   │       │       ├── gzguts.h
│   │       │       ├── gzlib.c
│   │       │       ├── gzread.c
│   │       │       ├── gzwrite.c
│   │       │       ├── infback.c
│   │       │       ├── inffast.c
│   │       │       ├── inffast.h
│   │       │       ├── inffixed.h
│   │       │       ├── inflate.c
│   │       │       ├── inflate.h
│   │       │       ├── inftrees.c
│   │       │       ├── inftrees.h
│   │       │       ├── trees.c
│   │       │       ├── trees.h
│   │       │       ├── uncompr.c
│   │       │       ├── zconf.h
│   │       │       ├── zlib.h
│   │       │       ├── zutil.c
│   │       │       └── zutil.h
│   │       ├── unixbuild.sh
│   │       └── version.h
│   ├── CMakeLists.txt
│   ├── efiLoader.cpp
│   ├── efiLoader.h
│   ├── ida_core.h
│   ├── pe.cpp
│   ├── pe.h
│   ├── pe_ida.h
│   ├── pe_manager.cpp
│   ├── pe_manager.h
│   ├── uefitool.cpp
│   ├── uefitool.h
│   ├── utils.cpp
│   └── utils.h
├── efiXplorer
│   ├── 3rd
│   │   └── nlohmann_json
│   │       └── json.hpp
│   ├── CMakeLists.txt
│   ├── efiAnalysis.cpp
│   ├── efiAnalysis.h
│   ├── efiDeps.cpp
│   ├── efiDeps.h
│   ├── efiGlobal.cpp
│   ├── efiGlobal.h
│   ├── efiHexRays.cpp
│   ├── efiHexRays.h
│   ├── efiSmmUtils.cpp
│   ├── efiSmmUtils.h
│   ├── efiUi.cpp
│   ├── efiUi.h
│   ├── efiUtils.cpp
│   ├── efiUtils.h
│   ├── efiXplorer.cpp
│   ├── efiXplorer.h
│   └── tables
│       ├── efi_pei_tables.h
│       ├── efi_services.h
│       └── efi_system_tables.h
├── guids
│   └── guids.json
└── pics
    ├── efXplorer_new_6.gif
    ├── efXplorer_new_7.gif
    ├── efiXplorer_logo.png
    ├── efiXplorer_new_1.gif
    ├── efiXplorer_new_2.gif
    ├── efiXplorer_new_3.gif
    ├── efiXplorer_new_4.gif
    ├── efiXplorer_new_5.gif
    ├── graph.png
    ├── hexrays_logo.svg
    ├── jetbrains_logo.png
    ├── loader_1.gif
    ├── loader_2.gif
    ├── loader_3.gif
    ├── loader_4.gif
    ├── loader_5.gif
    ├── loader_6.gif
    └── loader_7.gif

```

`LICENSE`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.

```

`README.md`:

```md
[![License: GPL v3](https://img.shields.io/badge/License-GPL%20v3-blue.svg)](http://www.gnu.org/licenses/gpl-3.0)
[![efiXplorer CI](https://github.com/binarly-io/efiXplorer/actions/workflows/ci-build.yml/badge.svg)](https://github.com/binarly-io/efiXplorer/actions)

<p align="center">
  <img alt="efiXlorer Logo" src="pics/efiXplorer_logo.png" width="20%">
</p>

**efiXplorer** - IDA plugin for UEFI firmware analysis and reverse engineering automation

__Supported versions of Hex-Rays products:__ everytime we focus on last versions of IDA and Decompiler because we try to use most recent features from new SDK releases. That means we tested only on recent versions of Hex-Rays products and do not guarantee stable work on previous generations.

__Why not IDApython:__ all code developed in C++ because it's a more stable and performant way to support a complex plugin and get full power of most recent SDK's features.

__Supported Platforms:__ Windows, Linux and OSX.

## [efiXplorer core features](https://github.com/binarly-io/efiXplorer/wiki/efiXplorer-features)

## [efiXloader description](https://github.com/binarly-io/efiXplorer/wiki/efiXloader)

## [Build instructions and Installation](https://github.com/binarly-io/efiXplorer/wiki/Build-instruction-and-installation)

## Publications

* [efiXplorer: Hunting for UEFI Firmware Vulnerabilities at Scale with Automated Static Analysis](https://i.blackhat.com/eu-20/Wednesday/eu-20-Labunets-efiXplorer-Hunting-For-UEFI-Firmware-Vulnerabilities-At-Scale-With-Automated-Static-Analysis.pdf)
* [Static analysis-based recovery of service function calls in UEFI firmware](https://www.youtube.com/watch?v=rK0tmVa19ME)
* [How efiXplorer helping to solve challenges in reverse engineering of UEFI firmware](https://www.youtube.com/watch?v=FFGQJBmRkLw)

## References

* https://github.com/LongSoft/UEFITool
* https://github.com/yeggor/UEFI_RETool
* https://github.com/gdbinit/EFISwissKnife
* https://github.com/snare/ida-efiutils
* https://github.com/al3xtjames/ghidra-firmware-utils
* https://github.com/DSecurity/efiSeek
* https://github.com/p-state/ida-efitools2
* https://github.com/zznop/bn-uefi-helper

## Thank you for support

<p align="center">
  <img alt="HexRays Logo" src="pics/hexrays_logo.svg" width="40%">
  <img alt="JetBrains Logo" src="https://www.jetbrains.com/company/brand/img/jetbrains_logo.png" width="14%">
</p>

```

`build.py`:

```py
#!/usr/bin/env python3

import os
import subprocess

import click


@click.group()
def cli():
    pass


@click.command()
@click.option(
    "--batch",
    "batch",
    type=bool,
    default=False,
    help="set to True if the plugin will be used in batch mode",
)
@click.option(
    "--hexrays_sdk",
    "hexrays_sdk",
    type=str,
    default=str(),
    help="path to hexrays_sdk directory",
)
@click.argument("idasdk")
def build_plugin(idasdk: str, hexrays_sdk: str, batch: bool):
    """Build efiXplorer plugin"""

    os.chdir("efiXplorer")

    if not os.path.isdir("build"):
        os.mkdir("build")

    os.chdir("build")

    command = ["cmake", "..", f"-DIdaSdk_ROOT_DIR={idasdk}"]
    if batch:
        command.append("-DBATCH=1")
    if hexrays_sdk:
        print("[INFO] HexRays analysis will be enabled")
        command.append(f"-DHexRaysSdk_ROOT_DIR={hexrays_sdk}")
    print(command)
    subprocess.call(command)
    subprocess.call(["cmake", "--build", ".", "--config", "Release"])


@click.command()
@click.argument("idasdk")
def build_loader(idasdk: str):
    """Build efiXloader"""

    os.chdir("efiXloader")

    if not os.path.isdir("build"):
        os.mkdir("build")

    os.chdir("build")

    command = ["cmake", "..", f"-DIdaSdk_ROOT_DIR={idasdk}"]
    subprocess.call(command)
    subprocess.call(["cmake", "--build", ".", "--config", "Release"])


cli.add_command(build_plugin)
cli.add_command(build_loader)


if __name__ == "__main__":
    cli()

```

`cmake/FindIdaSdk.cmake`:

```cmake
# Copyright 2011-2021 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may not
# use this file except in compliance with the License. You may obtain a copy of
# the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations under
# the License.

# FindIdaSdk
# ----------
#
# Locates and configures the IDA Pro SDK. Supports version 7.0 or higher.
#
# Use this module by invoking find_package with the form:
#
# find_package(IdaSdk [REQUIRED]  # Fail with an error if IDA SDK is not found )
#
# Defines the following variables:
#
# IdaSdk_INCLUDE_DIRS - Include directories for the IDA Pro SDK. IdaSdk_PLATFORM
# - IDA SDK platform, one of __LINUX__, __NT__ or __MAC__.
#
# This module reads hints about search locations from variables:
#
# IdaSdk_ROOT_DIR  - Preferred installation prefix
#
# Example (this assumes Windows):
#
# find_package(IdaSdk REQUIRED)
#
# # Builds targets plugin.dll and plugin64.dll add_ida_plugin(plugin
# myplugin.cc) # Builds target plugin64.dll add_ida_plugin(plugin NOEA32
# myplugin.cc) # Builds target plugin.dll add_ida_plugin(plugin NOEA64
# myplugin.cc)
#
# Builds targets ldr.dll and ldr64.dll add_ida_loader(ldr myloader.cc)
#
# For platform-agnostic build files, the variables _so, and _so64 are available
# (and map to .dll, .so, .dylib as necessary):
#
# add_ida_plugin(plugin myplugin.cc) target_link_libraries(plugin${_so} ssl)
# target_link_libraries(plugin${_so64} ssl)
#
# To avoid the duplication above, these functions, which mimic the built-in
# ones, are also defined:
#
# add_ida_library(<name> NOEA64|NOEA64 ...) <=> add_libary()
# ida_target_link_libraries(...)            <=> target_link_libraries()
# ida_target_include_directories(...)       <=> target_include_directories()
# set_ida_target_properties(...)            <=> set_target_properties()
# ida_install(...)                          <=> install()

include(CMakeParseArguments)
include(FindPackageHandleStandardArgs)

find_path(
  IdaSdk_DIR
  NAMES include/pro.h
  HINTS ${IdaSdk_ROOT_DIR} ENV IDASDK_ROOT
  PATHS ${CMAKE_CURRENT_LIST_DIR}/../third_party/idasdk
  PATH_SUFFIXES idasdk
  DOC "Location of the IDA SDK"
  NO_DEFAULT_PATH)
set(IdaSdk_INCLUDE_DIRS ${IdaSdk_DIR}/include)

find_package_handle_standard_args(
  IdaSdk
  FOUND_VAR IdaSdk_FOUND
  REQUIRED_VARS IdaSdk_DIR IdaSdk_INCLUDE_DIRS
  FAIL_MESSAGE "IDA SDK not found, try setting IdaSdk_ROOT_DIR")

# Define some platform specific variables for later use.
set(_so ${CMAKE_SHARED_LIBRARY_SUFFIX})
set(_so64 64${CMAKE_SHARED_LIBRARY_SUFFIX}) # An additional "64"
# _plx, _plx64, _llx, _llx64 are kept to stay compatible with older
# CMakeLists.txt files.
set(_plx ${CMAKE_SHARED_LIBRARY_SUFFIX})
set(_plx64 64${CMAKE_SHARED_LIBRARY_SUFFIX}) # An additional "64"
set(_llx ${CMAKE_SHARED_LIBRARY_SUFFIX})
set(_llx64 64${CMAKE_SHARED_LIBRARY_SUFFIX}) # An additional "64"
if(APPLE)
  set(IdaSdk_PLATFORM __MAC__)
elseif(UNIX)
  set(IdaSdk_PLATFORM __LINUX__)
elseif(WIN32)
  set(IdaSdk_PLATFORM __NT__)
else()
  message(FATAL_ERROR "Unsupported system type: ${CMAKE_SYSTEM_NAME}")
endif()

function(_ida_common_target_settings t ea64)
  if(ea64) # Support for 64-bit addresses.
    target_compile_definitions(${t} PUBLIC __EA64__)
  endif()
  # Add the necessary __IDP__ define and allow to use "dangerous" and standard
  # file functions.
  target_compile_definitions(
    ${t} PUBLIC ${IdaSdk_PLATFORM} __X64__ __IDP__ USE_DANGEROUS_FUNCTIONS
                USE_STANDARD_FILE_FUNCTIONS)
  target_include_directories(${t} PUBLIC ${IdaSdk_INCLUDE_DIRS})
endfunction()

function(_ida_plugin name ea64 link_script) # ARGN contains sources
  if(ea64)
    set(t ${name}${_so64})
  else()
    set(t ${name}${_so})
  endif()

  # Define a module with the specified sources.
  add_library(${t} MODULE ${ARGN})
  _ida_common_target_settings(${t} ${ea64})

  set_target_properties(${t} PROPERTIES PREFIX "" SUFFIX "")
  if(UNIX)
    target_compile_options(${t} PUBLIC ${_ida_compile_options})
    if(APPLE)
      target_link_libraries(${t} ${_ida_compile_options} -Wl,-flat_namespace
                            -Wl,-undefined,warning -Wl,-exported_symbol,_PLUGIN)
    else()
      # Always use the linker script needed for IDA.
      target_link_libraries(${t} ${_ida_compile_options} -Wl,--version-script
                            ${IdaSdk_DIR}/${link_script})
    endif()

    # For qrefcnt_obj_t in ida.hpp
    # TODO(cblichmann): This belongs in an interface library instead.
    target_compile_options(${t} PUBLIC -Wno-non-virtual-dtor -Wno-varargs)
  elseif(WIN32)
    if(ea64)
      target_link_libraries(${t} ${IdaSdk_DIR}/lib/x64_win_vc_64/ida.lib)
    else()
      target_link_libraries(${t} ${IdaSdk_DIR}/lib/x64_win_vc_32/ida.lib)
    endif()
  endif()
endfunction()

function(_ida_loader name ea64 link_script)
  if(ea64)
    set(t ${name}${_so64})
  else()
    set(t ${name}${_so})
  endif()

  # Define a module with the specified sources.
  add_library(${t} MODULE ${ARGN})
  _ida_common_target_settings(${t} ${ea64})

  set_target_properties(${t} PROPERTIES PREFIX "" SUFFIX "")
  if(UNIX)
    target_compile_options(${t} PUBLIC ${_ida_compile_options})
    if(APPLE)
      target_link_libraries(${t} ${_ida_compile_options} -Wl,-flat_namespace
                            -Wl,-undefined,warning -Wl,-exported_symbol,_LDSC)
    else()
      # Always use the linker script needed for IDA.
      target_link_libraries(${t} ${_ida_compile_options} -Wl,--version-script
                            ${IdaSdk_DIR}/${link_script})
    endif()

    # For qrefcnt_obj_t in ida.hpp
    # TODO(cblichmann): This belongs in an interface library instead.
    target_compile_options(${t} PUBLIC -Wno-non-virtual-dtor -Wno-varargs)
  elseif(WIN32)
    if(ea64)
      target_link_libraries(${t} ${IdaSdk_DIR}/lib/x64_win_vc_64/ida.lib)
    else()
      target_link_libraries(${t} ${IdaSdk_DIR}/lib/x64_win_vc_32/ida.lib)
    endif()
    target_link_options(${t} PUBLIC "/EXPORT:LDSC")
  endif()
endfunction()

macro(_ida_check_bitness)
  if(opt_NOEA32 AND opt_NOEA64)
    message(FATAL_ERROR "NOEA32 and NOEA64 cannot be used at the same time")
  endif()
endmacro()

function(_ida_library name ea64)
  if(ea64)
    set(t ${name}_ea64)
  else()
    set(t ${name}_ea32)
  endif()

  # Define the actual library.
  add_library(${t} ${ARGN})
  _ida_common_target_settings(${t} ${ea64})
endfunction()

function(add_ida_library name)
  cmake_parse_arguments(PARSE_ARGV 1 opt "NOEA32;NOEA64" "" "")
  _ida_check_bitness(opt_NOEA32 opt_NOEA64)

  if(NOT DEFINED (opt_NOEA32))
    _ida_library(${name} FALSE ${opt_UNPARSED_ARGUMENTS})
  endif()
  if(NOT DEFINED (opt_NOEA64))
    _ida_library(${name} TRUE ${opt_UNPARSED_ARGUMENTS})
  endif()
endfunction()

function(add_ida_plugin name)
  cmake_parse_arguments(PARSE_ARGV 1 opt "NOEA32;NOEA64" "" "")
  _ida_check_bitness(opt_NOEA32 opt_NOEA64)

  if(NOT opt_NOEA32)
    _ida_plugin(${name} FALSE plugins/exports.def ${opt_UNPARSED_ARGUMENTS})
  endif()
  if(NOT opt_NOEA64)
    _ida_plugin(${name} TRUE plugins/exports.def ${opt_UNPARSED_ARGUMENTS})
  endif()
endfunction()

function(add_ida_loader name)
  cmake_parse_arguments(PARSE_ARGV 1 opt "NOEA32;NOEA64" "" "")
  _ida_check_bitness(opt_NOEA32 opt_NOEA64)

  if(NOT opt_NOEA32)
    _ida_loader(${name} FALSE ldr/exports.def ${opt_UNPARSED_ARGUMENTS})
  endif()
  if(NOT opt_NOEA64)
    _ida_loader(${name} TRUE ldr/exports.def ${opt_UNPARSED_ARGUMENTS})
  endif()
endfunction()

function(ida_target_link_libraries name)
  foreach(item IN LISTS ARGN)
    if(TARGET ${item}_ea32 OR TARGET ${item}_ea64)
      if(TARGET ${item}_ea32)
        list(APPEND args32 ${item}_ea32)
      endif()
      if(TARGET ${item}_ea64)
        list(APPEND args64 ${item}_ea64)
      endif()
    else()
      list(APPEND args ${item})
    endif()
  endforeach()
  foreach(target ${name}${_so} ${name}_ea32)
    if(TARGET ${target})
      target_link_libraries(${target} ${args32} ${args})
      set(added TRUE)
    endif()
  endforeach()
  foreach(target ${name}${_so64} ${name}_ea64)
    if(TARGET ${target})
      target_link_libraries(${target} ${args64} ${args})
      set(added TRUE)
    endif()
  endforeach()
  if(NOT added)
    message(FATAL_ERROR "No such target: ${name}")
  endif()
endfunction()

function(ida_target_include_directories name)
  foreach(target ${name}${_so} ${name}${_so64} ${name}_ea32 ${name}_ea64)
    if(TARGET ${target})
      target_include_directories(${target} ${ARGN})
      set(added TRUE)
    endif()
  endforeach()
  if(NOT added)
    message(FATAL_ERROR "No such target: ${name}")
  endif()
endfunction()

function(set_ida_target_properties name)
  foreach(target ${name}${_so} ${name}${_so64} ${name}_ea32 ${name}_ea64)
    if(TARGET ${target})
      set_target_properties(${target} ${ARGN})
      set(added TRUE)
    endif()
  endforeach()
  if(NOT added)
    message(FATAL_ERROR "No such target: ${name}")
  endif()
endfunction()

function(ida_install)
  foreach(item IN LISTS ARGN)
    if(TARGET ${item}${_so} OR TARGET ${item}${_so64})
      if(TARGET ${item}${_so})
        list(APPEND args ${item}${_so})
      endif()
      if(TARGET ${item}${_so64})
        list(APPEND args ${item}${_so64})
      endif()
    else()
      list(APPEND args ${item})
    endif()
  endforeach()
  install(${args})
endfunction()

```

`efiXloader/3rd/uefitool/LICENSE.md`:

```md
Copyright (c) 2015, Nikolaj Schlej
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

```

`efiXloader/3rd/uefitool/README.md`:

```md
# UEFITool

UEFITool is a viewer and editor of firmware images conforming to UEFI Platform Interface (PI) Specifications.

![UEFITool icon](https://raw.githubusercontent.com/LongSoft/UEFITool/new_engine/UEFITool/icons/uefitool_64x64.png "UEFITool icon")  
[![Build Status](https://travis-ci.org/LongSoft/UEFITool.svg?branch=master)](https://travis-ci.org/LongSoft/UEFITool) [![Scan Status](https://scan.coverity.com/projects/17209/badge.svg?flat=1)](https://scan.coverity.com/projects/17209)


## Very Brief Introduction to UEFI

Unified Extensible Firmware Interface or UEFI is a post-BIOS firmware specification originally written by Intel for Itanium architecture and than adapted for X86 systems.  
The first EFI-compatible x86 firmwares were used on Apple Macintosh systems in 2006 and PC motherboard vendors started putting UEFI-compatible firmwares on their boards in 2011.  
In 2015 there are numerous systems using UEFI-compatible firmware including PCs, Macs, Tablets and Smartphones on x86, x86-64 and ARM architectures.  
More information on UEFI is available on [UEFI Forum official site](http://www.uefi.org/faq) and in [Wikipedia](http://en.wikipedia.org/wiki/Unified_Extensible_Firmware_Interface).  
  
## Very Brief Introduction to UEFITool

UEFITool is a cross-platform open source application written in C++/Qt, that parses UEFI-compatible firmware image into a tree structure, verifies image's integrity and provides a GUI to manipulate image's elements.  
Project development started in the middle of 2013 because of the lack of cross-platform open source utilities for tinkering with UEFI images.  

In the beginning of 2015 the major refactoring round was started to make the program compatible with newer UEFI features including FFSv3 volumes and fixed image elements. 
It's in development right now with the following features still missing:
* Editor part, i.e image reconstruction routines
* Console UI

The missing parts are in development and the version with a new engine will be made as soon as image reconstruction works again.

## Derived projects

There are some other projects that use UEFITool's engine:
* UEFIExtract, which uses ffsParser to parse supplied firmware image into a tree structure and dumps the parsed structure recursively on the FS. Jethro Beekman's [tree](https://github.com/jethrogb/uefireverse) utility can be used to work with the extracted tree.
* UEFIFind, which uses ffsParser to find image elements containing a specified pattern. It was developed for [UBU](http://www.win-raid.com/t154f16-Tool-Guide-News-quot-UEFI-BIOS-Updater-quot-UBU.html) project.
* [OZMTool](https://github.com/tuxuser/UEFITool/tree/OZM/OZMTool), which uses UEFITool's engine to perform various "hackintosh"-related firmware modifications.

## Alternatives

Right now there are some alternatives to UEFITool that you could find useful too:
* **[Fiano](https://github.com/linuxboot/fiano)** by Google and Facebook. Go-based cross-platform open source toolset for modifying UEFI firmware images.
* **[PhoenixTool](http://forums.mydigitallife.info/threads/13194-Tool-to-Insert-Replace-SLIC-in-Phoenix-Insyde-Dell-EFI-BIOSes)** by [AndyP](http://forums.mydigitallife.info/members/39295-andyp). Windows-only freeware GUI application written in C#. Used mostly for SLIC-related modifications, but it not limited to this task. Requires Microsoft .NET 3.5 to work properly. Supports unpacking firmware images from various vendor-specific formats like encrypted HP update files and Dell installers.  
* **[uefi-firmware-parser](https://github.com/theopolis/uefi-firmware-parser)** by [Teddy Reed](https://github.com/theopolis). Cross-platform open source console application written in Python. Very tinker-friendly due to use of Python. Can be used in scripts to automate firmware patching.
* **[Chipsec](https://github.com/chipsec/chipsec)** by Intel. Cross-platform partially open source console application written in Python and C. Can be used to test Intel-based platforms for various security-related misconfigurations, but also has NVRAM parser and other components aimed to firmware modification.
* **MMTool** by AMI. Windows-only proprietary application available to AMI clients. Works only with Aptio4- and AptioV-based firmware images, but has some interesting features including OptionROM replacement and microcode update. Must be licensed from AMI.
* **H2OEZE** by Insyde. Windows-only proprietary application available to Insyde clients. Works only with InsydeH2O-based firmware images. Must be licensed from Insyde.
* **SCT BIOS Editor** by Phoenix. Windows-only proprietary application available to Phoenix clients. Works only with Phoenix SCT-based firmware images. Must be licensed from Phoenix.

## Installation

You can either use [pre-built binaries for Windows and macOS](https://github.com/LongSoft/UEFITool/releases) or build a binary yourself.  
* To build a binary that uses Qt library (UEFITool) you need a C++ compiler and an instance of [Qt5](https://www.qt.io) library. Install both of them, get the sources, generate makefiles using qmake (`qmake UEFITool.pro`) and use your system's make command on that generated files (i.e. `nmake release`, `make release` and so on).
* To build a binary that doesn't use Qt (UEFIExtract, UEFIFind), you need a C++ compiler and [CMAKE](https://cmake.org) utility to generate a makefile for your OS and build environment. Install both of them, get the sources, generate makefiles using cmake (`cmake UEFIExtract`) and use your system's make command on that generated files (i.e. `nmake release`, `make release` and so on).

## Known issues

* Some vendor-specific firmware update files can be opened incorrectly or can't be opened at all. This includes encrypted HP update files, Dell HDR and EXE files, some InsydeFlash FD files and so on. Enabling support for such files will require massive amount of reverse-engineering which is almost pointless because the updated image can be obtained from BIOS chip where it's already decrypted and unpacked.
* Intel Firmware Interface Table (FIT) editing is not supported right now. FIT contains pointers to various image components that must be loaded before executing the first CPU instruction from the BIOS chip. Those components include CPU microcode updates, binaries and settings used by BIOS Guard and Boot Guard technologies and some other stuff. More information on FIT can be obtained [here](http://downloadmirror.intel.com/18931/eng/Intel%20TXT%20LAB%20Handout.pdf).
* Builder code is still not ready.

```

`efiXloader/3rd/uefitool/UEFIExtract/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.0)

PROJECT(UEFIExtract)

SET(PROJECT_SOURCES
 uefiextract_main.cpp
 ffsdumper.cpp
 uefidump.cpp
 ../common/guiddatabase.cpp
 ../common/types.cpp
 ../common/descriptor.cpp
 ../common/ffs.cpp
 ../common/nvram.cpp
 ../common/nvramparser.cpp
 ../common/meparser.cpp
 ../common/ffsparser.cpp
 ../common/ffsreport.cpp
 ../common/peimage.cpp
 ../common/treeitem.cpp
 ../common/treemodel.cpp
 ../common/utility.cpp
 ../common/LZMA/LzmaDecompress.c
 ../common/LZMA/SDK/C/Bra86.c
 ../common/LZMA/SDK/C/LzmaDec.c
 ../common/Tiano/EfiTianoDecompress.c
 ../common/ustring.cpp
 ../common/sha256.c
 ../common/bstrlib/bstrlib.c
 ../common/bstrlib/bstrwrap.cpp
 ../common/zlib/adler32.c
 ../common/zlib/compress.c
 ../common/zlib/crc32.c
 ../common/zlib/deflate.c
 ../common/zlib/gzclose.c
 ../common/zlib/gzlib.c
 ../common/zlib/gzread.c
 ../common/zlib/gzwrite.c
 ../common/zlib/inflate.c
 ../common/zlib/infback.c
 ../common/zlib/inftrees.c
 ../common/zlib/inffast.c
 ../common/zlib/trees.c
 ../common/zlib/uncompr.c
 ../common/zlib/zutil.c
)

SET(PROJECT_HEADERS
 ffsdumper.h
 uefidump.h
 ../common/guiddatabase.h
 ../common/basetypes.h
 ../common/descriptor.h
 ../common/gbe.h
 ../common/me.h
 ../common/ffs.h
 ../common/nvram.h
 ../common/nvramparser.h
 ../common/ffsparser.h
 ../common/ffsreport.h
 ../common/peimage.h
 ../common/types.h
 ../common/treeitem.h
 ../common/treemodel.h
 ../common/utility.h
 ../common/LZMA/LzmaDecompress.h
 ../common/Tiano/EfiTianoDecompress.h
 ../common/ubytearray.h
 ../common/ustring.h
 ../common/bootguard.h
 ../common/sha256.h
 ../common/filesystem.h
 ../common/bstrlib/bstrlib.h
 ../common/bstrlib/bstrwrap.h
 ../common/zlib/zconf.h
 ../common/zlib/zlib.h
 ../common/zlib/crc32.h
 ../common/zlib/deflate.h
 ../common/zlib/gzguts.h
 ../common/zlib/inffast.h
 ../common/zlib/inffixed.h
 ../common/zlib/inflate.h
 ../common/zlib/inftrees.h
 ../common/zlib/trees.h
 ../common/zlib/zutil.h
 ../version.h
)

ADD_DEFINITIONS(-DU_ENABLE_NVRAM_PARSING_SUPPORT -DU_ENABLE_ME_PARSING_SUPPORT  -DU_ENABLE_FIT_PARSING_SUPPORT -DU_ENABLE_GUID_DATABASE_SUPPORT)

ADD_EXECUTABLE(UEFIExtract ${PROJECT_SOURCES} ${PROJECT_HEADERS})

```

`efiXloader/3rd/uefitool/UEFIExtract/ffsdumper.cpp`:

```cpp
/* ffsdumper.cpp

Copyright (c) 2015, Nikolaj Schlej. All rights reserved.
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

*/

#include "ffsdumper.h"

#include <fstream>

USTATUS FfsDumper::dump(const UModelIndex & root, const UString & path, const DumpMode dumpMode, const UINT8 sectionType, const UString & guid)
{
    dumped = false;
    counterHeader = counterBody = counterRaw = counterInfo = 0;
    fileList.clear();

    if (changeDirectory(path))
        return U_DIR_ALREADY_EXIST;

    currentPath = path;

    USTATUS result = recursiveDump(root, path, dumpMode, sectionType, guid);
    if (result) {
        return result;
    } else if (!dumped) {
        removeDirectory(path);
        return U_ITEM_NOT_FOUND;
    }

    return U_SUCCESS;
}

USTATUS FfsDumper::recursiveDump(const UModelIndex & index, const UString & path, const DumpMode dumpMode, const UINT8 sectionType, const UString & guid)
{
    if (!index.isValid())
        return U_INVALID_PARAMETER;

    if (guid.isEmpty() ||
        (model->subtype(index) == EFI_SECTION_FREEFORM_SUBTYPE_GUID &&
            guidToUString(readUnaligned((const EFI_GUID*)(model->header(index).constData() + sizeof(EFI_COMMON_SECTION_HEADER)))) == guid) ||
        guidToUString(readUnaligned((const EFI_GUID*)model->header(index).constData())) == guid ||
        guidToUString(readUnaligned((const EFI_GUID*)model->header(model->findParentOfType(index, Types::File)).constData())) == guid) {

        if (!changeDirectory(path) && !makeDirectory(path))
            return U_DIR_CREATE;

        if (currentPath != path) {
            counterHeader = counterBody = counterRaw = counterInfo = 0;
            currentPath = path;
        }

        if (fileList.count(index) == 0
            && (dumpMode == DUMP_ALL || model->rowCount(index) == 0)
            && (sectionType == IgnoreSectionType || model->subtype(index) == sectionType)) {

            if ((dumpMode == DUMP_ALL || dumpMode == DUMP_CURRENT || dumpMode == DUMP_HEADER)
                && !model->header(index).isEmpty()) {
                fileList.insert(index);

                UString filename;
                if (counterHeader == 0)
                    filename = usprintf("%s/header.bin", path.toLocal8Bit());
                else
                    filename = usprintf("%s/header_%d.bin", path.toLocal8Bit(), counterHeader);
                counterHeader++;

                std::ofstream file(filename.toLocal8Bit(), std::ofstream::binary);
                if (!file)
                    return U_FILE_OPEN;

                const UByteArray &data = model->header(index);
                file.write(data.constData(), data.size());

                dumped = true;
            }

            if ((dumpMode == DUMP_ALL || dumpMode == DUMP_CURRENT || dumpMode == DUMP_BODY)
                && !model->body(index).isEmpty()) {
                fileList.insert(index);
                UString filename;
                if (counterBody == 0)
                    filename = usprintf("%s/body.bin", path.toLocal8Bit());
                else
                    filename = usprintf("%s/body_%d.bin", path.toLocal8Bit(), counterBody);
                counterBody++;

                std::ofstream file(filename.toLocal8Bit(), std::ofstream::binary);
                if (!file)
                    return U_FILE_OPEN;

                const UByteArray &data = model->body(index);
                file.write(data.constData(), data.size());

                dumped = true;
            }

            if (dumpMode == DUMP_FILE) {
                UModelIndex fileIndex = index;
                if (model->type(fileIndex) != Types::File) {
                    fileIndex = model->findParentOfType(index, Types::File);
                    if (!fileIndex.isValid())
                        fileIndex = index;
                }

                // We may select parent file during ffs extraction.
                if (fileList.count(fileIndex) == 0) {
                    fileList.insert(fileIndex);

                    UString filename;
                    if (counterRaw == 0)
                        filename = usprintf("%s/file.ffs", path.toLocal8Bit());
                    else
                        filename = usprintf("%s/file_%d.ffs", path.toLocal8Bit(), counterRaw);
                    counterRaw++;

                    std::ofstream file(filename.toLocal8Bit(), std::ofstream::binary);
                    if (!file)
                        return U_FILE_OPEN;

                    const UByteArray &headerData = model->header(fileIndex);
                    const UByteArray &bodyData = model->body(fileIndex);
                    const UByteArray &tailData = model->tail(fileIndex);

                    file.write(headerData.constData(), headerData.size());
                    file.write(bodyData.constData(), bodyData.size());
                    file.write(tailData.constData(), tailData.size());

                    dumped = true;
                }
            }
        }

        // Always dump info unless explicitly prohibited
        if ((dumpMode == DUMP_ALL || dumpMode == DUMP_CURRENT || dumpMode == DUMP_INFO)
            && (sectionType == IgnoreSectionType || model->subtype(index) == sectionType)) {
            UString info = usprintf("Type: %s\nSubtype: %s\n%s%s\n",
                itemTypeToUString(model->type(index)).toLocal8Bit(),
                itemSubtypeToUString(model->type(index), model->subtype(index)).toLocal8Bit(),
                (model->text(index).isEmpty() ? UString("") :
                    usprintf("Text: %s\n", model->text(index).toLocal8Bit())).toLocal8Bit(),
                model->info(index).toLocal8Bit());

            UString filename;
            if (counterInfo == 0)
                filename = usprintf("%s/info.txt", path.toLocal8Bit());
            else
                filename = usprintf("%s/info_%d.txt", path.toLocal8Bit(), counterInfo);
            counterInfo++;

            std::ofstream file(filename.toLocal8Bit());
            if (!file)
                return U_FILE_OPEN;

            file << info.toLocal8Bit();

            dumped = true;
        }
    }

    USTATUS result;

    for (int i = 0; i < model->rowCount(index); i++) {
        UModelIndex childIndex = index.child(i, 0);
        bool useText = FALSE;
        if (model->type(childIndex) != Types::Volume)
            useText = !model->text(childIndex).isEmpty();

        UString childPath = path;
        if (dumpMode == DUMP_ALL || dumpMode == DUMP_CURRENT) {
            if (!changeDirectory(path) && !makeDirectory(path))
                return U_DIR_CREATE;

            childPath = usprintf("%s/%d %s", path.toLocal8Bit(), i,
                (useText ? model->text(childIndex) : model->name(childIndex)).toLocal8Bit());
        }
        result = recursiveDump(childIndex, childPath, dumpMode, sectionType, guid);
        if (result)
            return result;
    }

    return U_SUCCESS;
}

```

`efiXloader/3rd/uefitool/UEFIExtract/ffsdumper.h`:

```h
/* ffsdumper.h

Copyright (c) 2015, Nikolaj Schlej. All rights reserved.
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

*/

#ifndef FFSDUMPER_H
#define FFSDUMPER_H

#include <set>

#include "../common/basetypes.h"
#include "../common/ustring.h"
#include "../common/treemodel.h"
#include "../common/ffs.h"
#include "../common/filesystem.h"
#include "../common/utility.h"

class FfsDumper
{
public:
    enum DumpMode {
        DUMP_CURRENT,
        DUMP_ALL,
        DUMP_BODY,
        DUMP_HEADER,
        DUMP_INFO,
        DUMP_FILE
    };

    static const UINT8 IgnoreSectionType = 0xFF;

    explicit FfsDumper(TreeModel * treeModel) : model(treeModel), dumped(false), 
        counterHeader(0), counterBody(0), counterRaw(0), counterInfo(0) {}
    ~FfsDumper() {};

    USTATUS dump(const UModelIndex & root, const UString & path, const DumpMode dumpMode = DUMP_CURRENT, const UINT8 sectionType = IgnoreSectionType, const UString & guid = UString());

private:
    USTATUS recursiveDump(const UModelIndex & root, const UString & path, const DumpMode dumpMode, const UINT8 sectionType, const UString & guid);
    TreeModel* model;
    UString currentPath;
    bool dumped;
    int counterHeader, counterBody, counterRaw, counterInfo;
    std::set<UModelIndex> fileList;
};
#endif // FFSDUMPER_H

```

`efiXloader/3rd/uefitool/UEFIExtract/uefidump.cpp`:

```cpp
/* ffsdumper.cpp

Copyright (c) 2018, LongSoft. All rights reserved.
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

*/

#include "uefidump.h"
#include "../common/ffs.h"
#include "../common/utility.h"
#include "../common/filesystem.h"
#include <iostream>
#include <fstream>
#include <sstream>
#include <iomanip>

USTATUS UEFIDumper::dump(const UByteArray & buffer, const UString & inPath, const UString & guid)
{
    UString path = UString(inPath) + UString(".dump");
    UString reportPath = UString(inPath) + UString(".report.txt");

    if (initialized) {
        // Check if called with a different buffer as before
        if (buffer != currentBuffer) {
            // Reinitalize if so
            initialized = false;
        }
    }

    if (!initialized) {
        // Fill currentBuffer
        currentBuffer = buffer;

        // Parse FFS structure
        USTATUS result = ffsParser.parse(buffer);
        if (result)
            return result;
        // Show ffsParser messages
        std::vector<std::pair<UString, UModelIndex> > messages = ffsParser.getMessages();
        for (size_t i = 0; i < messages.size(); i++) {
            std::cout << messages[i].first << std::endl;
        }

        // Show FIT table
        std::vector<std::pair<std::vector<UString>, UModelIndex > > fitTable = ffsParser.getFitTable();
        if (fitTable.size()) {
            std::cout << "-------------------------------------------------------------------------" << std::endl;
            std::cout << "     Address       |   Size    |  Ver  | CS  |         Type / Info         " << std::endl;
            std::cout << "-------------------------------------------------------------------------" << std::endl;
            for (size_t i = 0; i < fitTable.size(); i++) {
                std::cout << fitTable[i].first[0].toLocal8Bit() << " | "
                    << fitTable[i].first[1].toLocal8Bit() << " | "
                    << fitTable[i].first[2].toLocal8Bit() << " | "
                    << fitTable[i].first[3].toLocal8Bit() << " | "
                    << fitTable[i].first[4].toLocal8Bit() << " | "
                    << fitTable[i].first[5].toLocal8Bit() << std::endl;
            }
        }

        // Create ffsReport
        FfsReport ffsReport(&model);
        std::vector<UString> report = ffsReport.generate();
        if (report.size()) {
            std::ofstream ofs;
            ofs.open(reportPath, std::ofstream::out);
            for (size_t i = 0; i < report.size(); i++) {
                ofs << report[i].toLocal8Bit() << std::endl;
            }
            ofs.close();
        }
        
        initialized = true;
    }
    
    // Check for dump directory existence
    if (isExistOnFs(path))
        return U_DIR_ALREADY_EXIST;

    // Create dump directory and cd to it
    if (!makeDirectory(path))
        return U_DIR_CREATE;

    if (!changeDirectory(path))
        return U_DIR_CHANGE;
    
    dumped = false;
    USTATUS result = recursiveDump(model.index(0,0));
    if (result)
        return result;
    else if (!dumped)
        return U_ITEM_NOT_FOUND;

    return U_SUCCESS;
}

USTATUS UEFIDumper::recursiveDump(const UModelIndex & index)
{
    if (!index.isValid())
        return U_INVALID_PARAMETER;

    //UByteArray itemHeader = model.header(index);
    //UByteArray fileHeader = model.header(model.findParentOfType(index, Types::File));

    //if (guid.length() == 0 ||
    //    (itemHeader.size() >= sizeof (EFI_GUID) && guidToUString(*(const EFI_GUID*)itemHeader.constData()) == guid) ||
    //    (fileHeader.size() >= sizeof(EFI_GUID) && guidToUString(*(const EFI_GUID*)fileHeader.constData()) == guid)) {

        // Construct file name
        UString orgName = uniqueItemName(index);
        UString name = orgName;
        bool nameFound = false;
        for (int i = 1; i < 1000; ++i) {
            if (!isExistOnFs(name + UString("_info.txt"))) {
                nameFound = true;
                break;
            }
            name = orgName + UString("_") + usprintf("%03d", i);
        }

        if (!nameFound)
            return U_INVALID_PARAMETER; //TODO: replace with proper errorCode

        // Add header and body only for leaf sections
        if (model.rowCount(index) == 0) {
            // Header
            UByteArray data = model.header(index);
            if (!data.isEmpty()) {
                std::ofstream file;
                UString str = name + UString("_header.bin");
                file.open(str.toLocal8Bit(), std::ios::out | std::ios::binary);
                file.write(data.constData(), data.size());
                file.close();
            }

            // Body
            data = model.body(index);
            if (!data.isEmpty()) {
                std::ofstream file;
                UString str = name + UString("_body.bin");
                file.open(str.toLocal8Bit(), std::ios::out | std::ios::binary);
                file.write(data.constData(), data.size());
                file.close();
            }
        }
        // Info
        UString info = "Type: " + itemTypeToUString(model.type(index)) + "\n" +
            "Subtype: " + itemSubtypeToUString(model.type(index), model.subtype(index)) + "\n";
        if (model.text(index).length() > 0)
            info += "Text: " + model.text(index) + "\n";
        info += model.info(index) + "\n";

        std::ofstream file;
        UString str = name + UString("_info.txt");
        file.open(str.toLocal8Bit(), std::ios::out);
        file.write(info.toLocal8Bit(), info.length());
        file.close();

        dumped = true;
    //}
    
    // Process child items
    USTATUS result;
    for (int i = 0; i < model.rowCount(index); i++) {
        result = recursiveDump(index.child(i, 0));
        if (result)
            return result;
    }

    return U_SUCCESS;
}

```

`efiXloader/3rd/uefitool/UEFIExtract/uefidump.h`:

```h
/* uefidump.h

Copyright (c) 2018, LongSoft. All rights reserved.
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

*/

#ifndef UEFIDUMP_H
#define UEFIDUMP_H

#include "../common/basetypes.h"
#include "../common/ustring.h"
#include "../common/treemodel.h"
#include "../common/ffsparser.h"
#include "../common/ffsreport.h"

class UEFIDumper
{
public:
    explicit UEFIDumper() : model(), ffsParser(&model), ffsReport(&model), currentBuffer(), initialized(false), dumped(false) {}
    ~UEFIDumper() {}

    USTATUS dump(const UByteArray & buffer, const UString & path, const UString & guid = UString());

private:
    USTATUS recursiveDump(const UModelIndex & root);

    TreeModel model;
    FfsParser ffsParser;
    FfsReport ffsReport;
    
    UByteArray currentBuffer;
    bool initialized;
    bool dumped;
};

#endif

```

`efiXloader/3rd/uefitool/UEFIExtract/uefiextract_main.cpp`:

```cpp
/* uefiextract_main.cpp
Copyright (c) 2018, LongSoft. All rights reserved.
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php
THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
*/

#include <iostream>
#include <fstream>
#include <cstring>
#include <cstdlib>

#include "../version.h"
#include "../common/basetypes.h"
#include "../common/ustring.h"
#include "../common/filesystem.h"
#include "../common/ffsparser.h"
#include "../common/ffsreport.h"
#include "../common/guiddatabase.h"
#include "ffsdumper.h"
#include "uefidump.h"

enum ReadType {
    READ_INPUT,
    READ_OUTPUT,
    READ_MODE,
    READ_SECTION
};

int main(int argc, char *argv[])
{
    initGuidDatabase("guids.csv");

    if (argc > 1) {
        // Check that input file exists
        USTATUS result;
        UByteArray buffer;
        UString path = getAbsPath(argv[1]);
        result = readFileIntoBuffer(path, buffer);
        if (result)
            return result;

        // Hack to support legacy UEFIDump mode.
        if (argc == 3 && !std::strcmp(argv[2], "unpack")) {
            UEFIDumper uefidumper;
            return (uefidumper.dump(buffer, UString(argv[1])) != U_SUCCESS);
        }

        // Create model and ffsParser
        TreeModel model;
        FfsParser ffsParser(&model);
        // Parse input buffer
        result = ffsParser.parse(buffer);
        if (result)
            return result;

        // Show ffsParser's messages
        std::vector<std::pair<UString, UModelIndex> > messages = ffsParser.getMessages();
        for (size_t i = 0; i < messages.size(); i++) {
            std::cout << messages[i].first.toLocal8Bit() << std::endl;
        }

        // Get last VTF
        std::vector<std::pair<std::vector<UString>, UModelIndex > > fitTable = ffsParser.getFitTable();
        if (fitTable.size()) {
            std::cout << "---------------------------------------------------------------------------" << std::endl;
            std::cout << "     Address      |   Size    |  Ver  | CS  |          Type / Info          " << std::endl;
            std::cout << "---------------------------------------------------------------------------" << std::endl;
            for (size_t i = 0; i < fitTable.size(); i++) {
                std::cout << fitTable[i].first[0].toLocal8Bit() << " | "
                    << fitTable[i].first[1].toLocal8Bit() << " | "
                    << fitTable[i].first[2].toLocal8Bit() << " | "
                    << fitTable[i].first[3].toLocal8Bit() << " | "
                    << fitTable[i].first[4].toLocal8Bit() << " | "
                    << fitTable[i].first[5].toLocal8Bit() << std::endl;
            }
        }


        // Create ffsDumper
        FfsDumper ffsDumper(&model);

        // Dump only leaf elements, no report
        if (argc == 3 && !std::strcmp(argv[2], "dump")) {
            return (ffsDumper.dump(model.index(0, 0), path + UString(".dump")) != U_SUCCESS);
        }
        else if (argc > 3 ||
            (argc == 3 && std::strcmp(argv[2], "all") != 0 && std::strcmp(argv[2], "report") != 0)) { // Dump specific files, without report
            std::vector<UString> inputs, outputs;
            std::vector<FfsDumper::DumpMode> modes;
            std::vector<UINT8> sectionTypes;
            ReadType readType = READ_INPUT;
            for (int i = 2; i < argc; i++) {
                const char *arg = argv[i];
                if (!std::strcmp(arg, "-i")) {
                    readType = READ_INPUT;
                    continue;
                } else if (!std::strcmp(arg, "-o")) {
                    readType = READ_OUTPUT;
                    continue;
                } else if (!std::strcmp(arg, "-m")) {
                    readType = READ_MODE;
                    continue;
                } else if (!std::strcmp(arg, "-t")) {
                    readType = READ_SECTION;
                    continue;
                }

                if (readType == READ_INPUT) {
                    inputs.push_back(arg);
                } else if (readType == READ_OUTPUT) {
                    outputs.push_back(getAbsPath(arg));
                } else if (readType == READ_MODE) {
                    if (!std::strcmp(arg, "all"))
                        modes.push_back(FfsDumper::DUMP_ALL);
                    else if (!std::strcmp(arg, "body"))
                        modes.push_back(FfsDumper::DUMP_BODY);
                    else if (!std::strcmp(arg, "header"))
                        modes.push_back(FfsDumper::DUMP_HEADER);
                    else if (!std::strcmp(arg, "info"))
                        modes.push_back(FfsDumper::DUMP_INFO);
                    else if (!std::strcmp(arg, "file"))
                        modes.push_back(FfsDumper::DUMP_FILE);
                    else
                        return U_INVALID_PARAMETER;
                } else if (readType == READ_SECTION) {
                    char *converted = const_cast<char *>(arg);
                    UINT8 sectionType = (UINT8)std::strtol(arg, &converted, 16);
                    if (converted == arg)
                        return U_INVALID_PARAMETER;
                    sectionTypes.push_back(sectionType);
                }
            }
            if (inputs.empty() || (!outputs.empty() && inputs.size() != outputs.size()) ||
                (!modes.empty() && inputs.size() != modes.size()) ||
                (!sectionTypes.empty() && inputs.size() != sectionTypes.size()))
                return U_INVALID_PARAMETER;

            USTATUS lastError = U_SUCCESS;
            for (size_t i = 0; i < inputs.size(); i++) {
                UString outPath = outputs.empty() ? path + UString(".dump") : outputs[i];
                FfsDumper::DumpMode mode = modes.empty() ? FfsDumper::DUMP_ALL : modes[i];
                UINT8 type = sectionTypes.empty() ? FfsDumper::IgnoreSectionType : sectionTypes[i];
                result = ffsDumper.dump(model.index(0, 0), outPath, mode, type, inputs[i]);
                if (result) {
                    std::cout << "Guid " << inputs[i].toLocal8Bit() << " failed with " << result << " code!" << std::endl;
                    lastError = result;
                }
            }

            return lastError;
        }

        // Create ffsReport
        FfsReport ffsReport(&model);
        std::vector<UString> report = ffsReport.generate();
        if (report.size()) {
            std::ofstream file;
            file.open((path + UString(".report.txt")).toLocal8Bit());
            for (size_t i = 0; i < report.size(); i++)
                file << report[i].toLocal8Bit() << '\n';
        }

        // Dump all non-leaf elements, with report, default
        if (argc == 2) {
            return (ffsDumper.dump(model.index(0, 0), path + UString(".dump")) != U_SUCCESS);
        }
        else if (argc == 3 && !std::strcmp(argv[2], "all")) { // Dump every element with report
            return (ffsDumper.dump(model.index(0, 0), path + UString(".dump"), FfsDumper::DUMP_ALL) != U_SUCCESS);
        }
        else if (argc == 3 && !std::strcmp(argv[2], "report")) { // Skip dumping
            return 0;
        }
    }
    // If parameters are different, show version and usage information
    std::cout << "UEFIExtract " PROGRAM_VERSION << std::endl << std::endl
        << "Usage: UEFIExtract imagefile        - generate report and dump only leaf tree items into .dump folder." << std::endl
        << "       UEFIExtract imagefile all    - generate report and dump all tree items." << std::endl
        << "       UEFIExtract imagefile unpack - generate report and dump all tree items in one dir." << std::endl
        << "       UEFIExtract imagefile dump   - only generate dump, no report needed." << std::endl
        << "       UEFIExtract imagefile report - only generate report, no dump needed." << std::endl
        << "       UEFIExtract imagefile GUID_1 ... [ -o FILE_1 ... ] [ -m MODE_1 ... ] [ -t TYPE_1 ... ] -" << std::endl
        << "         Dump only FFS file(s) with specific GUID(s), without report." << std::endl
        << "         Type is section type or FF to ignore. Mode is one of: all, body, header, info, file." << std::endl
        << "Return value is a bit mask where 0 at position N means that file with GUID_N was found and unpacked, 1 otherwise." << std::endl;
    return 1;
}

```

`efiXloader/3rd/uefitool/UEFIFind/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.0)

PROJECT(UEFIFind)

SET(PROJECT_SOURCES
 uefifind_main.cpp
 uefifind.cpp
 ../common/guiddatabase.cpp
 ../common/types.cpp
 ../common/descriptor.cpp
 ../common/ffs.cpp
 ../common/nvram.cpp
 ../common/nvramparser.cpp
 ../common/ffsparser.cpp
 ../common/ffsreport.cpp
 ../common/ffsutils.cpp
 ../common/peimage.cpp
 ../common/treeitem.cpp
 ../common/treemodel.cpp
 ../common/utility.cpp
 ../common/LZMA/LzmaDecompress.c
 ../common/LZMA/SDK/C/Bra86.c
 ../common/LZMA/SDK/C/LzmaDec.c
 ../common/Tiano/EfiTianoDecompress.c
 ../common/ustring.cpp
 ../common/sha256.c
 ../common/bstrlib/bstrlib.c
 ../common/bstrlib/bstrwrap.cpp
 ../common/zlib/adler32.c
 ../common/zlib/compress.c
 ../common/zlib/crc32.c
 ../common/zlib/deflate.c
 ../common/zlib/gzclose.c
 ../common/zlib/gzlib.c
 ../common/zlib/gzread.c
 ../common/zlib/gzwrite.c
 ../common/zlib/inflate.c
 ../common/zlib/infback.c
 ../common/zlib/inftrees.c
 ../common/zlib/inffast.c
 ../common/zlib/trees.c
 ../common/zlib/uncompr.c
 ../common/zlib/zutil.c
)

SET(PROJECT_HEADERS
 uefifind.h
 ../common/guiddatabase.h
 ../common/basetypes.h
 ../common/descriptor.h
 ../common/gbe.h
 ../common/me.h
 ../common/ffs.h
 ../common/nvram.h
 ../common/nvramparser.h
 ../common/ffsparser.h
 ../common/ffsreport.h
 ../common/ffsutils.h
 ../common/peimage.h
 ../common/types.h
 ../common/treeitem.h
 ../common/treemodel.h
 ../common/utility.h
 ../common/LZMA/LzmaDecompress.h
 ../common/Tiano/EfiTianoDecompress.h
 ../common/ubytearray.h
 ../common/ustring.h
 ../common/bootguard.h
 ../common/sha256.h
 ../common/filesystem.h
 ../common/bstrlib/bstrlib.h
 ../common/bstrlib/bstrwrap.h
 ../common/zlib/zconf.h
 ../common/zlib/zlib.h
 ../common/zlib/crc32.h
 ../common/zlib/deflate.h
 ../common/zlib/gzguts.h
 ../common/zlib/inffast.h
 ../common/zlib/inffixed.h
 ../common/zlib/inflate.h
 ../common/zlib/inftrees.h
 ../common/zlib/trees.h
 ../common/zlib/zutil.h
 ../version.h
)

ADD_DEFINITIONS(-DU_ENABLE_NVRAM_PARSING_SUPPORT -DU_ENABLE_FIT_PARSING_SUPPORT -DU_ENABLE_GUID_DATABASE_SUPPORT)

ADD_EXECUTABLE(UEFIFind ${PROJECT_SOURCES} ${PROJECT_HEADERS})

```

`efiXloader/3rd/uefitool/UEFIFind/uefifind.cpp`:

```cpp
/* uefifind.cpp

Copyright (c) 2016, Nikolaj Schlej. All rights reserved.
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

*/

#include "uefifind.h"
#include "../common/ffsutils.h"

#include <fstream>

UEFIFind::UEFIFind()
{
    model = new TreeModel();
    ffsParser = new FfsParser(model);
    initDone = false;
}

UEFIFind::~UEFIFind()
{
    delete ffsParser;
    delete model;
    model = NULL;
}

USTATUS UEFIFind::init(const UString & path)
{
    USTATUS result;
    UByteArray buffer;
    result = readFileIntoBuffer(path, buffer);
    if (result)
        return result;

    result = ffsParser->parse(buffer);
    if (result)
        return result;

    initDone = true;
    return U_SUCCESS;
}

USTATUS UEFIFind::find(const UINT8 mode, const bool count, const UString & hexPattern, UString & result)
{
    UModelIndex root = model->index(0, 0);
    std::set<std::pair<UModelIndex, UModelIndex> > files;

    result.clear();

    USTATUS returned = FfsUtils::findFileRecursive(model, root, hexPattern, mode, files);
    if (returned)
        return returned;
    
    if (count) {
        if (!files.empty())
            result += usprintf("%d\n", files.size());
        return U_SUCCESS;
    }

    for (std::set<std::pair<UModelIndex, UModelIndex> >::const_iterator citer = files.begin(); citer != files.end(); ++citer) {
        UByteArray data(16, '\x00');
        std::pair<UModelIndex, UModelIndex> indexes = *citer;
        if (!model->hasEmptyHeader(indexes.first))
            data = model->header(indexes.first).left(16);
        result += guidToUString(readUnaligned((const EFI_GUID*)data.constData()));

        // Special case of freeform subtype GUID files
        if (indexes.second.isValid() && model->subtype(indexes.second) == EFI_SECTION_FREEFORM_SUBTYPE_GUID) {
            data = model->header(indexes.second);
            result += UString(" ") + (guidToUString(readUnaligned((const EFI_GUID*)(data.constData() + sizeof(EFI_COMMON_SECTION_HEADER)))));
        }
        
        result += UString("\n");
    }
    return U_SUCCESS;
}

```

`efiXloader/3rd/uefitool/UEFIFind/uefifind.h`:

```h
/* uefifind.h

Copyright (c) 2015, Nikolaj Schlej. All rights reserved.
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

*/

#ifndef UEFIFIND_H
#define UEFIFIND_H

#include <iterator>
#include <set>

#include "../common/basetypes.h"
#include "../common/ustring.h"
#include "../common/filesystem.h"
#include "../common/ffsparser.h"
#include "../common/ffs.h"
#include "../common/utility.h"

class UEFIFind
{
public:
    explicit UEFIFind();
    ~UEFIFind();

    USTATUS init(const UString & path);
    USTATUS find(const UINT8 mode, const bool count, const UString & hexPattern, UString & result);

private:
    FfsParser* ffsParser;
    TreeModel* model;
    bool initDone;
};

#endif // UEFIFIND_H

```

`efiXloader/3rd/uefitool/UEFIFind/uefifind_main.cpp`:

```cpp
/* uefifind_main.cpp

Copyright (c) 2018, LongSoft. All rights reserved.
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

*/
#include <iostream>
#include <fstream>
#include <string>
#include <vector>

#include "../version.h"
#include "../common/guiddatabase.h"
#include "uefifind.h"

int main(int argc, char *argv[])
{
    UEFIFind w;
    USTATUS result;

    initGuidDatabase("guids.csv");

    if (argc == 5) {
        UString inputArg = argv[1];
        UString modeArg = argv[2];
        UString subModeArg = argv[3];
        UString patternArg = argv[4];

        // Get search mode
        UINT8 mode;
        if (modeArg == UString("header"))
            mode = SEARCH_MODE_HEADER;
        else if (modeArg == UString("body"))
            mode = SEARCH_MODE_BODY;
        else if (modeArg == UString("all"))
            mode = SEARCH_MODE_ALL;
        else
            return U_INVALID_PARAMETER;

        // Get result type
        bool count;
        if (subModeArg == UString("list"))
            count = false;
        else if (subModeArg == UString("count"))
            count = true;
        else
            return U_INVALID_PARAMETER;

        // Parse input file
        result = w.init(inputArg);
        if (result)
            return result;

        // Go find the supplied pattern
        UString found;
        result = w.find(mode, count, patternArg, found);
        if (result)
            return result;

        // Nothing is found
        if (found.isEmpty())
            return U_ITEM_NOT_FOUND;

        // Print result
        std::cout << found.toLocal8Bit();
        return U_SUCCESS;
    }
    else if (argc == 4) {
        UString inputArg = argv[1];
        UString modeArg = argv[2];
        UString patternArg = argv[3];

        // Get search mode
        if (modeArg != UString("file"))
            return U_INVALID_PARAMETER;

        // Open patterns file
        if (!isExistOnFs(patternArg))
            return U_FILE_OPEN;

        std::ifstream patternsFile(patternArg.toLocal8Bit());
        if (!patternsFile)
            return U_FILE_OPEN;

        // Parse input file
        result = w.init(inputArg);
        if (result)
            return result;

        // Perform searches
        bool somethingFound = false;
        while (!patternsFile.eof()) {
            std::string line;
            std::getline(patternsFile, line);
            // Use sharp symbol as commentary
            if (line.size() == 0 || line[0] == '#')
                continue;

            // Split the read line
            std::vector<UString> list;
            std::string::size_type prev = 0, curr = 0;
            while ((curr = line.find(' ', curr)) != std::string::npos) {
                std::string substring( line.substr(prev, curr-prev) );
                list.push_back(UString(substring.c_str()));
                prev = ++curr;
            }
            list.push_back(UString(line.substr(prev, curr-prev).c_str()));

            if (list.size() < 3) {
                std::cout << line << std::endl << "skipped, too few arguments" << std::endl << std::endl;
                continue;
            }
            // Get search mode
            UINT8 mode;
            if (list.at(0) == UString("header"))
                mode = SEARCH_MODE_HEADER;
            else if (list.at(0) == UString("body"))
                mode = SEARCH_MODE_BODY;
            else if (list.at(0) == UString("all"))
                mode = SEARCH_MODE_ALL;
            else {
                std::cout << line << std::endl << "skipped, invalid search mode" << std::endl << std::endl;
                continue;
            }

            // Get result type
            bool count;
            if (list.at(1) == UString("list"))
                count = false;
            else if (list.at(1) == UString("count"))
                count = true;
            else {
                std::cout << line << std::endl << "skipped, invalid result type" << std::endl << std::endl;
                continue;
            }

            // Go find the supplied pattern
            UString found;
            result = w.find(mode, count, list.at(2), found);
            if (result) {
                std::cout << line << std::endl << "skipped, find failed with error " << (UINT32)result << std::endl << std::endl;
                continue;
            }

            if (found.isEmpty()) {
                // Nothing is found
                std::cout << line << std::endl << "nothing found" << std::endl << std::endl;
            }
            else {
                // Print result
                std::cout << line << std::endl << found.toLocal8Bit() << std::endl;
                somethingFound = true;
            }
        }

        // Nothing is found
        if (!somethingFound)
            return U_ITEM_NOT_FOUND;

        return U_SUCCESS;
    }
    else {
        std::cout << "UEFIFind " PROGRAM_VERSION << std::endl << std::endl <<
            "Usage: UEFIFind imagefile {header | body | all} {list | count} pattern" << std::endl <<
            "    or UEFIFind imagefile file patternsfile" << std::endl;
        return U_INVALID_PARAMETER;
    }
}

```

`efiXloader/3rd/uefitool/UEFITool/Info.plist`:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>NSPrincipalClass</key>
    <string>NSApplication</string>
    <key>CFBundleIconFile</key>
    <string>uefitool</string>
    <key>CFBundlePackageType</key>
    <string>APPL</string>
    <key>CFBundleGetInfoString</key>
    <string>UEFITool NE</string>
    <key>CFBundleSignature</key>
    <string>????</string>
    <key>CFBundleExecutable</key>
    <string>UEFITool</string>
    <key>CFBundleIdentifier</key>
    <string>org.longsoft.UEFITool</string>
    <key>CFBundleDocumentTypes</key>
    <array>
        <dict>
            <key>CFBundleTypeExtensions</key>
            <array>
                <string>*</string>
            </array>
            <key>CFBundleTypeRole</key>
            <string>Viewer</string>
            <key>LSHandlerRank</key>
            <string>None</string>
        </dict>
    </array>
</dict>
</plist>

```

`efiXloader/3rd/uefitool/UEFITool/ffsfinder.cpp`:

```cpp
/* fssfinder.cpp

Copyright (c) 2015, Nikolaj Schlej. All rights reserved.
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

*/

#include "ffsfinder.h"

USTATUS FfsFinder::findHexPattern(const UModelIndex & index, const UByteArray & hexPattern, const UINT8 mode)
{
    //TODO: use FfsUtils.

    if (!index.isValid())
        return U_SUCCESS;

    if (hexPattern.isEmpty())
        return U_INVALID_PARAMETER;

    // Check for "all substrings" pattern
    if (hexPattern.count('.') == hexPattern.length())
        return U_SUCCESS;

    bool hasChildren = (model->rowCount(index) > 0);
    for (int i = 0; i < model->rowCount(index); i++) {
        findHexPattern(index.child(i, index.column()), hexPattern, mode);
    }

    UByteArray data;
    if (hasChildren) {
        if (mode == SEARCH_MODE_HEADER)
            data = model->header(index);
        else if (mode == SEARCH_MODE_ALL)
            data = model->header(index) + model->body(index);
    }
    else {
        if (mode == SEARCH_MODE_HEADER)
            data = model->header(index);
        else if (mode == SEARCH_MODE_BODY)
            data = model->body(index);
        else
            data = model->header(index) + model->body(index);
    }

    UString hexBody = UString(data.toHex());
    QRegExp regexp = QRegExp(UString(hexPattern), Qt::CaseInsensitive);
    INT32 offset = regexp.indexIn(hexBody);
    while (offset >= 0) {
        if (offset % 2 == 0) {
            // For patterns that cross header|body boundary, skip patterns entirely located in body, since
            // children search above has already found them.
            if (!(hasChildren && mode == SEARCH_MODE_ALL && offset/2 >= model->header(index).size())) {
                msg(UString("Hex pattern \"") + UString(hexPattern)
                    + UString("\" found as \"") + hexBody.mid(offset, hexPattern.length()).toUpper()
                    + UString("\" in ") + model->name(model->parent(index))
                    + UString("/") + model->name(index)
                    + usprintf(" at %s-offset %02Xh", mode == SEARCH_MODE_BODY ? "body" : "header", offset / 2),
                    index);
            }
        }
        offset = regexp.indexIn(hexBody, offset + 1);
    }

    return U_SUCCESS;
}

USTATUS FfsFinder::findGuidPattern(const UModelIndex & index, const UByteArray & guidPattern, const UINT8 mode)
{
    if (guidPattern.isEmpty())
        return U_INVALID_PARAMETER;

    if (!index.isValid())
        return U_SUCCESS;

    bool hasChildren = (model->rowCount(index) > 0);
    for (int i = 0; i < model->rowCount(index); i++) {
        findGuidPattern(index.child(i, index.column()), guidPattern, mode);
    }

    UByteArray data;
    if (hasChildren) {
        if (mode != SEARCH_MODE_BODY)
            data = model->header(index);
    }
    else {
        if (mode == SEARCH_MODE_HEADER)
            data.append(model->header(index));
        else if (mode == SEARCH_MODE_BODY)
            data.append(model->body(index));
        else
            data.append(model->header(index)).append(model->body(index));
    }

    UString hexBody = UString(data.toHex());
    QList<UByteArray> list = guidPattern.split('-');
    if (list.count() != 5)
        return U_INVALID_PARAMETER;

    UByteArray hexPattern;
    // Reverse first GUID block
    hexPattern.append(list.at(0).mid(6, 2));
    hexPattern.append(list.at(0).mid(4, 2));
    hexPattern.append(list.at(0).mid(2, 2));
    hexPattern.append(list.at(0).mid(0, 2));
    // Reverse second GUID block
    hexPattern.append(list.at(1).mid(2, 2));
    hexPattern.append(list.at(1).mid(0, 2));
    // Reverse third GUID block
    hexPattern.append(list.at(2).mid(2, 2));
    hexPattern.append(list.at(2).mid(0, 2));
    // Append fourth and fifth GUID blocks as is
    hexPattern.append(list.at(3)).append(list.at(4));

    // Check for "all substrings" pattern
    if (hexPattern.count('.') == hexPattern.length())
        return U_SUCCESS;

    QRegExp regexp(UString(hexPattern), Qt::CaseInsensitive);
    INT32 offset = regexp.indexIn(hexBody);
    while (offset >= 0) {
        if (offset % 2 == 0) {
            msg(UString("GUID pattern \"") + UString(guidPattern)
                + UString("\" found as \"") + hexBody.mid(offset, hexPattern.length()).toUpper()
                + UString("\" in ") + model->name(model->parent(index))
                + UString("/") + model->name(index)
                + usprintf(" at %s-offset %02Xh", mode == SEARCH_MODE_BODY ? "body" : "header", offset / 2),
                index);
        }
        offset = regexp.indexIn(hexBody, offset + 1);
    }

    return U_SUCCESS;
}

USTATUS FfsFinder::findTextPattern(const UModelIndex & index, const UString & pattern, const UINT8 mode, const bool unicode, const Qt::CaseSensitivity caseSensitive)
{
    if (pattern.isEmpty())
        return U_INVALID_PARAMETER;

    if (!index.isValid())
        return U_SUCCESS;

    bool hasChildren = (model->rowCount(index) > 0);
    for (int i = 0; i < model->rowCount(index); i++) {
        findTextPattern(index.child(i, index.column()), pattern, mode, unicode, caseSensitive);
    }

    UByteArray body;
    if (hasChildren) {
        if (mode != SEARCH_MODE_BODY)
            body = model->header(index);
    }
    else {
        if (mode == SEARCH_MODE_HEADER)
            body.append(model->header(index));
        else if (mode == SEARCH_MODE_BODY)
            body.append(model->body(index));
        else
            body.append(model->header(index)).append(model->body(index));
    }

    UString data;
    if (unicode)
        data = UString::fromUtf16((const ushort*)body.constData(), body.length() / 2);
    else
        data = UString::fromLatin1((const char*)body.constData(), body.length());

    int offset = -1;
    while ((offset = data.indexOf(pattern, offset + 1, caseSensitive)) >= 0) {

        msg((unicode ? UString("Unicode") : UString("ASCII")) + UString(" text \"") + UString(pattern)
            + UString("\" in ") + model->name(model->parent(index))
            + UString("/") + model->name(index)
            + usprintf(" at %s-offset %02Xh", mode == SEARCH_MODE_BODY ? "body" : "header", (unicode ? offset * 2 : offset)),
            index);
    }

    return U_SUCCESS;
}

```

`efiXloader/3rd/uefitool/UEFITool/ffsfinder.h`:

```h
/* fssfinder.h

Copyright (c) 2015, Nikolaj Schlej. All rights reserved.
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

*/

#ifndef FFSFINDER_H
#define FFSFINDER_H

#include <vector>
#include <QRegExp>

#include "../common/ubytearray.h"
#include "../common/ustring.h"
#include "../common/basetypes.h"
#include "../common/treemodel.h"

class FfsFinder
{
public:
    FfsFinder(const TreeModel * treeModel) : model(treeModel) {}
    ~FfsFinder() {}

    std::vector<std::pair<UString, UModelIndex> > getMessages() const { return messagesVector; }
    void clearMessages() { messagesVector.clear(); }

    USTATUS findHexPattern(const UModelIndex & index, const UByteArray & hexPattern, const UINT8 mode);
    USTATUS findGuidPattern(const UModelIndex & index, const UByteArray & guidPattern, const UINT8 mode);
    USTATUS findTextPattern(const UModelIndex & index, const UString & pattern, const UINT8 mode, const bool unicode, const Qt::CaseSensitivity caseSensitive);

private:
    const TreeModel* model;
    std::vector<std::pair<UString, UModelIndex> > messagesVector;

    void msg(const UString & message, const UModelIndex &index = UModelIndex()) {
        messagesVector.push_back(std::pair<UString, UModelIndex>(message, index));
    }
};

#endif // FFSFINDER_H

```

`efiXloader/3rd/uefitool/UEFITool/gotoaddressdialog.h`:

```h
#ifndef GOTOADDRESSDIALOG_H
#define GOTOADDRESSDIALOG_H

#include <QObject>
#include <QDialog>
#include "ui_gotoaddressdialog.h"
class GoToAddressDialog : public QDialog
{
    Q_OBJECT

public:
    GoToAddressDialog(QWidget* parent = NULL) :
        QDialog(parent, Qt::WindowTitleHint | Qt::WindowSystemMenuHint | Qt::WindowCloseButtonHint),
        ui(new Ui::GoToAddressDialog) {
        ui->setupUi(this);
    }

    ~GoToAddressDialog() { delete ui; }

    Ui::GoToAddressDialog* ui;
};

#endif // GOTOADDRESSDIALOG_H

```

`efiXloader/3rd/uefitool/UEFITool/gotoaddressdialog.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>GoToAddressDialog</class>
 <widget class="QDialog" name="GoToAddressDialog">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>270</width>
    <height>86</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Select item at address</string>
  </property>
  <property name="modal">
   <bool>false</bool>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <property name="spacing">
    <number>5</number>
   </property>
   <property name="leftMargin">
    <number>5</number>
   </property>
   <property name="topMargin">
    <number>5</number>
   </property>
   <property name="rightMargin">
    <number>5</number>
   </property>
   <property name="bottomMargin">
    <number>5</number>
   </property>
   <item>
    <widget class="QGroupBox" name="groupBox">
     <property name="title">
      <string/>
     </property>
     <layout class="QHBoxLayout" name="horizontalLayout">
      <property name="spacing">
       <number>5</number>
      </property>
      <property name="leftMargin">
       <number>5</number>
      </property>
      <property name="topMargin">
       <number>5</number>
      </property>
      <property name="rightMargin">
       <number>5</number>
      </property>
      <property name="bottomMargin">
       <number>5</number>
      </property>
      <item>
       <widget class="QLabel" name="label">
        <property name="text">
         <string>Select item at address:</string>
        </property>
       </widget>
      </item>
      <item>
       <widget class="HexSpinBox" name="hexSpinBox">
        <property name="sizePolicy">
         <sizepolicy hsizetype="Expanding" vsizetype="Fixed">
          <horstretch>0</horstretch>
          <verstretch>0</verstretch>
         </sizepolicy>
        </property>
       </widget>
      </item>
     </layout>
    </widget>
   </item>
   <item>
    <widget class="QDialogButtonBox" name="buttonBox">
     <property name="orientation">
      <enum>Qt::Horizontal</enum>
     </property>
     <property name="standardButtons">
      <set>QDialogButtonBox::Cancel|QDialogButtonBox::Ok</set>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <customwidgets>
  <customwidget>
   <class>HexSpinBox</class>
   <extends>QSpinBox</extends>
   <header>hexspinbox.h</header>
  </customwidget>
 </customwidgets>
 <tabstops>
  <tabstop>buttonBox</tabstop>
 </tabstops>
 <resources/>
 <connections>
  <connection>
   <sender>buttonBox</sender>
   <signal>accepted()</signal>
   <receiver>GoToAddressDialog</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>182</x>
     <y>185</y>
    </hint>
    <hint type="destinationlabel">
     <x>157</x>
     <y>194</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>buttonBox</sender>
   <signal>rejected()</signal>
   <receiver>GoToAddressDialog</receiver>
   <slot>reject()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>182</x>
     <y>185</y>
    </hint>
    <hint type="destinationlabel">
     <x>286</x>
     <y>194</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`efiXloader/3rd/uefitool/UEFITool/gotobasedialog.h`:

```h
#ifndef GOTOBASEDIALOG_H
#define GOTOBASEDIALOG_H

#include <QObject>
#include <QDialog>
#include "ui_gotobasedialog.h"
class GoToBaseDialog : public QDialog
{
    Q_OBJECT

public:
    GoToBaseDialog(QWidget* parent = NULL):
        QDialog(parent, Qt::WindowTitleHint | Qt::WindowSystemMenuHint | Qt::WindowCloseButtonHint),
        ui(new Ui::GoToBaseDialog) {
        ui->setupUi(this);
    }

    ~GoToBaseDialog() {delete ui;}

    Ui::GoToBaseDialog* ui;
};

#endif // GOTOBASEDIALOG_H

```

`efiXloader/3rd/uefitool/UEFITool/gotobasedialog.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>GoToBaseDialog</class>
 <widget class="QDialog" name="GoToBaseDialog">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>270</width>
    <height>86</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Select item at base</string>
  </property>
  <property name="modal">
   <bool>false</bool>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <property name="spacing">
    <number>5</number>
   </property>
   <property name="leftMargin">
    <number>5</number>
   </property>
   <property name="topMargin">
    <number>5</number>
   </property>
   <property name="rightMargin">
    <number>5</number>
   </property>
   <property name="bottomMargin">
    <number>5</number>
   </property>
   <item>
    <widget class="QGroupBox" name="groupBox">
     <property name="title">
      <string/>
     </property>
     <layout class="QHBoxLayout" name="horizontalLayout">
      <property name="spacing">
       <number>5</number>
      </property>
      <property name="leftMargin">
       <number>5</number>
      </property>
      <property name="topMargin">
       <number>5</number>
      </property>
      <property name="rightMargin">
       <number>5</number>
      </property>
      <property name="bottomMargin">
       <number>5</number>
      </property>
      <item>
       <widget class="QLabel" name="label">
        <property name="text">
         <string>Select item at base:</string>
        </property>
       </widget>
      </item>
      <item>
       <widget class="HexSpinBox" name="hexSpinBox">
        <property name="sizePolicy">
         <sizepolicy hsizetype="Expanding" vsizetype="Fixed">
          <horstretch>0</horstretch>
          <verstretch>0</verstretch>
         </sizepolicy>
        </property>
       </widget>
      </item>
     </layout>
    </widget>
   </item>
   <item>
    <widget class="QDialogButtonBox" name="buttonBox">
     <property name="orientation">
      <enum>Qt::Horizontal</enum>
     </property>
     <property name="standardButtons">
      <set>QDialogButtonBox::Cancel|QDialogButtonBox::Ok</set>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <customwidgets>
  <customwidget>
   <class>HexSpinBox</class>
   <extends>QSpinBox</extends>
   <header>hexspinbox.h</header>
  </customwidget>
 </customwidgets>
 <tabstops>
  <tabstop>buttonBox</tabstop>
 </tabstops>
 <resources/>
 <connections>
  <connection>
   <sender>buttonBox</sender>
   <signal>accepted()</signal>
   <receiver>GoToBaseDialog</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>182</x>
     <y>185</y>
    </hint>
    <hint type="destinationlabel">
     <x>157</x>
     <y>194</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>buttonBox</sender>
   <signal>rejected()</signal>
   <receiver>GoToBaseDialog</receiver>
   <slot>reject()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>182</x>
     <y>185</y>
    </hint>
    <hint type="destinationlabel">
     <x>286</x>
     <y>194</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`efiXloader/3rd/uefitool/UEFITool/guidlineedit.cpp`:

```cpp
/* guidlineedit.cpp

  Copyright (c) 2014, Nikolaj Schlej. All rights reserved.
  This program and the accompanying materials
  are licensed and made available under the terms and conditions of the BSD License
  which accompanies this distribution.  The full text of the license may be found at
  http://opensource.org/licenses/bsd-license.php

  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

  */

#include "guidlineedit.h"

GuidLineEdit::GuidLineEdit(QWidget * parent)
    :QLineEdit(parent)
{
}

GuidLineEdit::GuidLineEdit(const QString & contents, QWidget * parent)
    :QLineEdit(contents, parent)
{
}

GuidLineEdit::~GuidLineEdit()
{
}

void GuidLineEdit::keyPressEvent(QKeyEvent * event)
{
    if (event == QKeySequence::Delete || event->key() == Qt::Key_Backspace)
    {
        int pos = cursorPosition();
        if (event->key() == Qt::Key_Backspace && pos > 0) {
            cursorBackward(false);
            pos = cursorPosition();
        }
        
        QString txt = text();
        QString selected = selectedText();

        if (!selected.isEmpty()) {
            pos = QLineEdit::selectionStart();
            for (int i = pos; i < pos + selected.count(); i++)
                if (txt[i] != QChar('-'))
                    txt[i] = QChar('.');
        }
        else 
            txt[pos] = QChar('.');

        setCursorPosition(0);
        insert(txt);
        setCursorPosition(pos);

        return;
    }

    // Call original event handler
    QLineEdit::keyPressEvent(event);
}
```

`efiXloader/3rd/uefitool/UEFITool/guidlineedit.h`:

```h
/* guidlineedit.h

  Copyright (c) 2014, Nikolaj Schlej. All rights reserved.
  This program and the accompanying materials
  are licensed and made available under the terms and conditions of the BSD License
  which accompanies this distribution.  The full text of the license may be found at
  http://opensource.org/licenses/bsd-license.php

  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

  */

#ifndef GUIDLINEEDIT_H
#define GUIDLINEEDIT_H

#include <QLineEdit>
#include <QKeyEvent>
#include <QKeySequence>
#include <QString>

#include "../common/basetypes.h"

class GuidLineEdit : public QLineEdit
{
public:
    GuidLineEdit(QWidget * parent = 0);
    GuidLineEdit(const QString & contents, QWidget * parent = 0);
    ~GuidLineEdit();

protected:
    void keyPressEvent(QKeyEvent * event);

};

#endif // GUIDLINEEDIT_H

```

`efiXloader/3rd/uefitool/UEFITool/hexspinbox.cpp`:

```cpp
/* hexspinbox.cpp

  Copyright (c) 2016, Nikolaj Schlej. All rights reserved.
  This program and the accompanying materials
  are licensed and made available under the terms and conditions of the BSD License
  which accompanies this distribution.  The full text of the license may be found at
  http://opensource.org/licenses/bsd-license.php

  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

  */

#include "hexspinbox.h"
#include <QDebug>

HexSpinBox::HexSpinBox(QWidget *parent) :
QSpinBox(parent), validator(QRegExp("0x([0-9a-fA-F]){1,8}"))
{
    this->setRange(INT_MIN, INT_MAX);
    this->setPrefix("0x");
}

QValidator::State HexSpinBox::validate(QString &text, int &pos) const
{
    return validator.validate(text, pos);
}

QString HexSpinBox::textFromValue(int val) const
{
    return QString::number((uint)val, 16).toUpper();
}

int HexSpinBox::valueFromText(const QString &text) const
{
    return (int)text.toUInt(NULL, 16);
}

```

`efiXloader/3rd/uefitool/UEFITool/hexspinbox.h`:

```h
/* hexspinbox.h

  Copyright (c) 2016, Nikolaj Schlej. All rights reserved.
  This program and the accompanying materials
  are licensed and made available under the terms and conditions of the BSD License
  which accompanies this distribution.  The full text of the license may be found at
  http://opensource.org/licenses/bsd-license.php

  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

  */

#ifndef HEXSPINBOX_H
#define HEXSPINBOX_H

#include <QSpinBox>
#include <QRegExpValidator>

class HexSpinBox : public QSpinBox
{
    Q_OBJECT

public:
    HexSpinBox(QWidget *parent = 0);

protected:
    QValidator::State validate(QString &text, int &pos) const;
    int valueFromText(const QString &text) const;
    QString textFromValue(int value) const;

private:
    QRegExpValidator validator;
};

#endif // HEXSPINBOX_H

```

`efiXloader/3rd/uefitool/UEFITool/hexviewdialog.cpp`:

```cpp
/* hexviewdialog.cpp

  Copyright (c) 2016, Nikolaj Schlej. All rights reserved.
  This program and the accompanying materials
  are licensed and made available under the terms and conditions of the BSD License
  which accompanies this distribution.  The full text of the license may be found at
  http://opensource.org/licenses/bsd-license.php

  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

  */

#include "hexviewdialog.h"

HexViewDialog::HexViewDialog(QWidget *parent) :
QDialog(parent, Qt::WindowTitleHint | Qt::WindowSystemMenuHint | Qt::WindowCloseButtonHint),
ui(new Ui::HexViewDialog),
hexView(NULL)
{
    // Create UI
    ui->setupUi(this);
    hexView = new QHexEdit(this);
    hexView->setReadOnly(true);
    hexView->setUpperCase(true);
    ui->layout->addWidget(hexView);
}

HexViewDialog::~HexViewDialog()
{
    delete hexView;
    delete ui;
}

void HexViewDialog::setFont(const QFont &font)
{
    hexView->setFont(font);
}

void HexViewDialog::setItem(const UModelIndex & index, bool bodyOnly)
{
    const TreeModel * model = (const TreeModel*)index.model();
    
    // Set dialog title
    UString itemName = model->name(index);
    UString itemText = model->text(index);
    setWindowTitle(UString("Hex view: ") + (itemText.isEmpty() ? itemName : itemName + " | " + itemText));
    
    // Set hex data
    QByteArray hexdata;
    if (bodyOnly) hexdata = model->body(index);
    else hexdata = model->header(index) + model->body(index) + model->tail(index);
    hexView->setData(hexdata);
}
```

`efiXloader/3rd/uefitool/UEFITool/hexviewdialog.h`:

```h
/* hexviewdialog.h

  Copyright (c) 2016, Nikolaj Schlej. All rights reserved.
  This program and the accompanying materials
  are licensed and made available under the terms and conditions of the BSD License
  which accompanies this distribution.  The full text of the license may be found at
  http://opensource.org/licenses/bsd-license.php

  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

  */

#ifndef HEXVIEWDIALOG_H
#define HEXVIEWDIALOG_H

#include <QDialog>
#include "../common/treemodel.h"
#include "qhexedit2/qhexedit.h"
#include "ui_hexviewdialog.h"

class HexViewDialog : public QDialog
{
    Q_OBJECT

public:
    HexViewDialog(QWidget *parent = 0);
    ~HexViewDialog();
    Ui::HexViewDialog* ui;

    void setItem(const UModelIndex & index, bool bodyOnly);
    void setFont(const QFont &font);

private:
    QHexEdit * hexView;
};

#endif // HEXVIEWDIALOG_H

```

`efiXloader/3rd/uefitool/UEFITool/hexviewdialog.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>HexViewDialog</class>
 <widget class="QDialog" name="HexViewDialog">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>640</width>
    <height>480</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string/>
  </property>
  <layout class="QVBoxLayout" name="layout">
   <property name="spacing">
    <number>0</number>
   </property>
   <property name="leftMargin">
    <number>5</number>
   </property>
   <property name="topMargin">
    <number>5</number>
   </property>
   <property name="rightMargin">
    <number>5</number>
   </property>
   <property name="bottomMargin">
    <number>5</number>
   </property>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`efiXloader/3rd/uefitool/UEFITool/qhexedit2/chunks.cpp`:

```cpp
#include "chunks.h"
#include <limits.h>

#define NORMAL 0
#define HIGHLIGHTED 1

#define BUFFER_SIZE 0x10000
#define CHUNK_SIZE 0x1000
#define READ_CHUNK_MASK Q_INT64_C(0xfffffffffffff000)

// ***************************************** Constructors and file settings

Chunks::Chunks(QObject *parent): QObject(parent)
{
    QBuffer *buf = new QBuffer(this);
    setIODevice(*buf);
}

Chunks::Chunks(QIODevice &ioDevice, QObject *parent): QObject(parent)
{
    setIODevice(ioDevice);
}

bool Chunks::setIODevice(QIODevice &ioDevice)
{
    _ioDevice = &ioDevice;
    bool ok = _ioDevice->open(QIODevice::ReadOnly);
    if (ok)   // Try to open IODevice
    {
        _size = _ioDevice->size();
        _ioDevice->close();
    }
    else                                        // Fallback is an empty buffer
    {
        QBuffer *buf = new QBuffer(this);
        _ioDevice = buf;
        _size = 0;
    }
    _chunks.clear();
    _pos = 0;
    return ok;
}


// ***************************************** Getting data out of Chunks

QByteArray Chunks::data(qint64 pos, qint64 maxSize, QByteArray *highlighted)
{
    qint64 ioDelta = 0;
    int chunkIdx = 0;

    Chunk chunk;
    QByteArray buffer;

    // Do some checks and some arrangements
    if (highlighted)
        highlighted->clear();

    if (pos >= _size)
        return buffer;

    if (maxSize < 0)
        maxSize = _size;
    else
        if ((pos + maxSize) > _size)
            maxSize = _size - pos;

    _ioDevice->open(QIODevice::ReadOnly);

    while (maxSize > 0)
    {
        chunk.absPos = LLONG_MAX;
        bool chunksLoopOngoing = true;
        while ((chunkIdx < _chunks.count()) && chunksLoopOngoing)
        {
            // In this section, we track changes before our required data and
            // we take the editdet data, if availible. ioDelta is a difference
            // counter to justify the read pointer to the original data, if
            // data in between was deleted or inserted.

            chunk = _chunks[chunkIdx];
            if (chunk.absPos > pos)
                chunksLoopOngoing = false;
            else
            {
                chunkIdx += 1;
                qint64 count;
                qint64 chunkOfs = pos - chunk.absPos;
                if (maxSize > ((qint64)chunk.data.size() - chunkOfs))
                {
                    count = (qint64)chunk.data.size() - chunkOfs;
                    ioDelta += CHUNK_SIZE - chunk.data.size();
                }
                else
                    count = maxSize;
                if (count > 0)
                {
                    buffer += chunk.data.mid(chunkOfs, (int)count);
                    maxSize -= count;
                    pos += count;
                    if (highlighted)
                        *highlighted += chunk.dataChanged.mid(chunkOfs, (int)count);
                }
            }
        }

        if ((maxSize > 0) && (pos < chunk.absPos))
        {
            // In this section, we read data from the original source. This only will
            // happen, whe no copied data is available

            qint64 byteCount;
            QByteArray readBuffer;
            if ((chunk.absPos - pos) > maxSize)
                byteCount = maxSize;
            else
                byteCount = chunk.absPos - pos;

            maxSize -= byteCount;
            _ioDevice->seek(pos + ioDelta);
            readBuffer = _ioDevice->read(byteCount);
            buffer += readBuffer;
            if (highlighted)
                *highlighted += QByteArray(readBuffer.size(), NORMAL);
            pos += readBuffer.size();
        }
    }
    _ioDevice->close();
    return buffer;
}

bool Chunks::write(QIODevice &iODevice, qint64 pos, qint64 count)
{
    if (count == -1)
        count = _size;
    bool ok = iODevice.open(QIODevice::WriteOnly);
    if (ok)
    {
        for (qint64 idx=pos; idx < count; idx += BUFFER_SIZE)
        {
            QByteArray ba = data(idx, BUFFER_SIZE);
            iODevice.write(ba);
        }
        iODevice.close();
    }
    return ok;
}


// ***************************************** Set and get highlighting infos

void Chunks::setDataChanged(qint64 pos, bool dataChanged)
{
    if ((pos < 0) || (pos >= _size))
        return;
    int chunkIdx = getChunkIndex(pos);
    qint64 posInBa = pos - _chunks[chunkIdx].absPos;
    _chunks[chunkIdx].dataChanged[(int)posInBa] = char(dataChanged);
}

bool Chunks::dataChanged(qint64 pos)
{
    QByteArray highlighted;
    data(pos, 1, &highlighted);
    return bool(highlighted.at(0));
}


// ***************************************** Search API

qint64 Chunks::indexOf(const QByteArray &ba, qint64 from)
{
    qint64 result = -1;
    QByteArray buffer;

    for (qint64 pos=from; (pos < _size) && (result < 0); pos += BUFFER_SIZE)
    {
        buffer = data(pos, BUFFER_SIZE + ba.size() - 1);
        int findPos = buffer.indexOf(ba);
        if (findPos >= 0)
            result = pos + (qint64)findPos;
    }
    return result;
}

qint64 Chunks::lastIndexOf(const QByteArray &ba, qint64 from)
{
    qint64 result = -1;
    QByteArray buffer;

    for (qint64 pos=from; (pos > 0) && (result < 0); pos -= BUFFER_SIZE)
    {
        qint64 sPos = pos - BUFFER_SIZE - (qint64)ba.size() + 1;
        if (sPos < 0)
            sPos = 0;
        buffer = data(sPos, pos - sPos);
        int findPos = buffer.lastIndexOf(ba);
        if (findPos >= 0)
            result = sPos + (qint64)findPos;
    }
    return result;
}


// ***************************************** Char manipulations

bool Chunks::insert(qint64 pos, char b)
{
    if ((pos < 0) || (pos > _size))
        return false;
    int chunkIdx;
    if (pos == _size)
        chunkIdx = getChunkIndex(pos-1);
    else
        chunkIdx = getChunkIndex(pos);
    qint64 posInBa = pos - _chunks[chunkIdx].absPos;
    _chunks[chunkIdx].data.insert(posInBa, b);
    _chunks[chunkIdx].dataChanged.insert(posInBa, char(1));
    for (int idx=chunkIdx+1; idx < _chunks.size(); idx++)
        _chunks[idx].absPos += 1;
    _size += 1;
    _pos = pos;
    return true;
}

bool Chunks::overwrite(qint64 pos, char b)
{
    if ((pos < 0) || (pos >= _size))
        return false;
    int chunkIdx = getChunkIndex(pos);
    qint64 posInBa = pos - _chunks[chunkIdx].absPos;
    _chunks[chunkIdx].data[(int)posInBa] = b;
    _chunks[chunkIdx].dataChanged[(int)posInBa] = char(1);
    _pos = pos;
    return true;
}

bool Chunks::removeAt(qint64 pos)
{
    if ((pos < 0) || (pos >= _size))
        return false;
    int chunkIdx = getChunkIndex(pos);
    qint64 posInBa = pos - _chunks[chunkIdx].absPos;
    _chunks[chunkIdx].data.remove(posInBa, 1);
    _chunks[chunkIdx].dataChanged.remove(posInBa, 1);
    for (int idx=chunkIdx+1; idx < _chunks.size(); idx++)
        _chunks[idx].absPos -= 1;
    _size -= 1;
    _pos = pos;
    return true;
}


// ***************************************** Utility functions

char Chunks::operator[](qint64 pos)
{
    return data(pos, 1)[0];
}

qint64 Chunks::pos()
{
    return _pos;
}

qint64 Chunks::size()
{
    return _size;
}

int Chunks::getChunkIndex(qint64 absPos)
{
    // This routine checks, if there is already a copied chunk available. If os, it
    // returns a reference to it. If there is no copied chunk available, original
    // data will be copied into a new chunk.

    int foundIdx = -1;
    int insertIdx = 0;
    qint64 ioDelta = 0;


    for (int idx=0; idx < _chunks.size(); idx++)
    {
        Chunk chunk = _chunks[idx];
        if ((absPos >= chunk.absPos) && (absPos < (chunk.absPos + chunk.data.size())))
        {
            foundIdx = idx;
            break;
        }
        if (absPos < chunk.absPos)
        {
            insertIdx = idx;
            break;
        }
        ioDelta += chunk.data.size() - CHUNK_SIZE;
        insertIdx = idx + 1;
    }

    if (foundIdx == -1)
    {
        Chunk newChunk;
        qint64 readAbsPos = absPos - ioDelta;
        qint64 readPos = (readAbsPos & READ_CHUNK_MASK);
        _ioDevice->open(QIODevice::ReadOnly);
        _ioDevice->seek(readPos);
        newChunk.data = _ioDevice->read(CHUNK_SIZE);
        _ioDevice->close();
        newChunk.absPos = absPos - (readAbsPos - readPos);
        newChunk.dataChanged = QByteArray(newChunk.data.size(), char(0));
        _chunks.insert(insertIdx, newChunk);
        foundIdx = insertIdx;
    }
    return foundIdx;
}


#ifdef MODUL_TEST
int Chunks::chunkSize()
{
    return _chunks.size();
}

#endif

```

`efiXloader/3rd/uefitool/UEFITool/qhexedit2/chunks.h`:

```h
#ifndef CHUNKS_H
#define CHUNKS_H

/** \cond docNever */

/*! The Chunks class is the storage backend for QHexEdit.
 *
 * When QHexEdit loads data, Chunks access them using a QIODevice interface. When the app uses
 * a QByteArray interface, QBuffer is used to provide again a QIODevice like interface. No data
 * will be changed, therefore Chunks opens the QIODevice in QIODevice::ReadOnly mode. After every
 * access Chunks closes the QIODevice, that's why external applications can overwrite files while
 * QHexEdit shows them.
 *
 * When the the user starts to edit the data, Chunks creates a local copy of a chunk of data (4
 * kilobytes) and notes all changes there. Parallel to that chunk, there is a second chunk,
 * which keep track of which bytes are changed and which not.
 *
 */

#include <QtCore>

struct Chunk
{
    QByteArray data;
    QByteArray dataChanged;
    qint64 absPos;
};

class Chunks: public QObject
{
Q_OBJECT
public:
    // Constructors and file settings
    Chunks(QObject *parent);
    Chunks(QIODevice &ioDevice, QObject *parent);
    bool setIODevice(QIODevice &ioDevice);

    // Getting data out of Chunks
    QByteArray data(qint64 pos=0, qint64 count=-1, QByteArray *highlighted=0);
    bool write(QIODevice &iODevice, qint64 pos=0, qint64 count=-1);

    // Set and get highlighting infos
    void setDataChanged(qint64 pos, bool dataChanged);
    bool dataChanged(qint64 pos);

    // Search API
    qint64 indexOf(const QByteArray &ba, qint64 from);
    qint64 lastIndexOf(const QByteArray &ba, qint64 from);

    // Char manipulations
    bool insert(qint64 pos, char b);
    bool overwrite(qint64 pos, char b);
    bool removeAt(qint64 pos);

    // Utility functions
    char operator[](qint64 pos);
    qint64 pos();
    qint64 size();


private:
    int getChunkIndex(qint64 absPos);

    QIODevice * _ioDevice;
    qint64 _pos;
    qint64 _size;
    QList<Chunk> _chunks;

#ifdef MODUL_TEST
public:
    int chunkSize();
#endif
};

/** \endcond docNever */

#endif // CHUNKS_H

```

`efiXloader/3rd/uefitool/UEFITool/qhexedit2/commands.cpp`:

```cpp
#include "commands.h"
#include <QUndoCommand>


// Helper class to store single byte commands
class CharCommand : public QUndoCommand
{
public:
    enum CCmd {insert, removeAt, overwrite};

    CharCommand(Chunks * chunks, CCmd cmd, qint64 charPos, char newChar,
                       QUndoCommand *parent=0);

    void undo();
    void redo();
    bool mergeWith(const QUndoCommand *command);
    int id() const { return 1234; }

private:
    Chunks * _chunks;
    qint64 _charPos;
    bool _wasChanged;
    char _newChar;
    char _oldChar;
    CCmd _cmd;
};

CharCommand::CharCommand(Chunks * chunks, CCmd cmd, qint64 charPos, char newChar, QUndoCommand *parent)
    : QUndoCommand(parent)
{
    _chunks = chunks;
    _charPos = charPos;
    _newChar = newChar;
    _cmd = cmd;
	_wasChanged = false;
	_oldChar = ' ';
}

bool CharCommand::mergeWith(const QUndoCommand *command)
{
    const CharCommand *nextCommand = static_cast<const CharCommand *>(command);
    bool result = false;

    if (_cmd != CharCommand::removeAt)
    {
        if (nextCommand->_cmd == overwrite)
            if (nextCommand->_charPos == _charPos)
            {
                _newChar = nextCommand->_newChar;
                result = true;
            }
    }
    return result;
}

void CharCommand::undo()
{
    switch (_cmd)
    {
        case insert:
            _chunks->removeAt(_charPos);
            break;
        case overwrite:
            _chunks->overwrite(_charPos, _oldChar);
            _chunks->setDataChanged(_charPos, _wasChanged);
            break;
        case removeAt:
            _chunks->insert(_charPos, _oldChar);
            _chunks->setDataChanged(_charPos, _wasChanged);
            break;
    }
}

void CharCommand::redo()
{
    switch (_cmd)
    {
        case insert:
            _chunks->insert(_charPos, _newChar);
            break;
        case overwrite:
            _oldChar = (*_chunks)[_charPos];
            _wasChanged = _chunks->dataChanged(_charPos);
            _chunks->overwrite(_charPos, _newChar);
            break;
        case removeAt:
            _oldChar = (*_chunks)[_charPos];
            _wasChanged = _chunks->dataChanged(_charPos);
            _chunks->removeAt(_charPos);
            break;
    }
}

UndoStack::UndoStack(Chunks * chunks, QObject * parent)
    : QUndoStack(parent)
{
    _chunks = chunks;
    _parent = parent;
}

void UndoStack::insert(qint64 pos, char c)
{
    if ((pos >= 0) && (pos <= _chunks->size()))
    {
        QUndoCommand *cc = new CharCommand(_chunks, CharCommand::insert, pos, c);
        this->push(cc);
    }
}

void UndoStack::insert(qint64 pos, const QByteArray &ba)
{
    if ((pos >= 0) && (pos <= _chunks->size()))
    {
        QString txt = QString(tr("Inserting %1 bytes")).arg(ba.size());
        beginMacro(txt);
        for (int idx=0; idx < ba.size(); idx++)
        {
            QUndoCommand *cc = new CharCommand(_chunks, CharCommand::insert, pos + idx, ba.at(idx));
            this->push(cc);
        }
        endMacro();
    }
}

void UndoStack::removeAt(qint64 pos, qint64 len)
{
    if ((pos >= 0) && (pos < _chunks->size()))
    {
        if (len==1)
        {
            QUndoCommand *cc = new CharCommand(_chunks, CharCommand::removeAt, pos, char(0));
            this->push(cc);
        }
        else
        {
            QString txt = QString(tr("Delete %1 chars")).arg(len);
            beginMacro(txt);
            for (qint64 cnt=0; cnt<len; cnt++)
            {
                QUndoCommand *cc = new CharCommand(_chunks, CharCommand::removeAt, pos, char(0));
                push(cc);
            }
            endMacro();
        }
    }
}

void UndoStack::overwrite(qint64 pos, char c)
{
    if ((pos >= 0) && (pos < _chunks->size()))
    {
        QUndoCommand *cc = new CharCommand(_chunks, CharCommand::overwrite, pos, c);
        this->push(cc);
    }
}

void UndoStack::overwrite(qint64 pos, int len, const QByteArray &ba)
{
    if ((pos >= 0) && (pos < _chunks->size()))
    {
        QString txt = QString(tr("Overwrite %1 chars")).arg(len);
        beginMacro(txt);
        removeAt(pos, len);
        insert(pos, ba);
        endMacro();
    }
}

```

`efiXloader/3rd/uefitool/UEFITool/qhexedit2/commands.h`:

```h
#ifndef COMMANDS_H
#define COMMANDS_H

/** \cond docNever */

#include <QUndoStack>

#include "chunks.h"

/*! CharCommand is a class to provid undo/redo functionality in QHexEdit.
A QUndoCommand represents a single editing action on a document. CharCommand
is responsable for manipulations on single chars. It can insert. overwrite and
remove characters. A manipulation stores allways two actions
1. redo (or do) action
2. undo action.

CharCommand also supports command compression via mergeWidht(). This allows
the user to execute a undo command contation e.g. 3 steps in a single command.
If you for example insert a new byt "34" this means for the editor doing 3
steps: insert a "00", overwrite it with "03" and the overwrite it with "34". These
3 steps are combined into a single step, insert a "34".

The byte array oriented commands are just put into a set of single byte commands,
which are pooled together with the macroBegin() and macroEnd() functionality of
Qt's QUndoStack.
*/

class UndoStack : public QUndoStack
{
    Q_OBJECT

public:
    UndoStack(Chunks *chunks, QObject * parent=0);
    void insert(qint64 pos, char c);
    void insert(qint64 pos, const QByteArray &ba);
    void removeAt(qint64 pos, qint64 len=1);
    void overwrite(qint64 pos, char c);
    void overwrite(qint64 pos, int len, const QByteArray &ba);

private:
    Chunks * _chunks;
    QObject * _parent;
};

/** \endcond docNever */

#endif // COMMANDS_H

```

`efiXloader/3rd/uefitool/UEFITool/qhexedit2/license.txt`:

```txt
                  GNU LESSER GENERAL PUBLIC LICENSE
                       Version 2.1, February 1999

 Copyright (C) 1991, 1999 Free Software Foundation, Inc.
 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

[This is the first released version of the Lesser GPL.  It also counts
 as the successor of the GNU Library Public License, version 2, hence
 the version number 2.1.]

                            Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
Licenses are intended to guarantee your freedom to share and change
free software--to make sure the software is free for all its users.

  This license, the Lesser General Public License, applies to some
specially designated software packages--typically libraries--of the
Free Software Foundation and other authors who decide to use it.  You
can use it too, but we suggest you first think carefully about whether
this license or the ordinary General Public License is the better
strategy to use in any particular case, based on the explanations below.

  When we speak of free software, we are referring to freedom of use,
not price.  Our General Public Licenses are designed to make sure that
you have the freedom to distribute copies of free software (and charge
for this service if you wish); that you receive source code or can get
it if you want it; that you can change the software and use pieces of
it in new free programs; and that you are informed that you can do
these things.

  To protect your rights, we need to make restrictions that forbid
distributors to deny you these rights or to ask you to surrender these
rights.  These restrictions translate to certain responsibilities for
you if you distribute copies of the library or if you modify it.

  For example, if you distribute copies of the library, whether gratis
or for a fee, you must give the recipients all the rights that we gave
you.  You must make sure that they, too, receive or can get the source
code.  If you link other code with the library, you must provide
complete object files to the recipients, so that they can relink them
with the library after making changes to the library and recompiling
it.  And you must show them these terms so they know their rights.

  We protect your rights with a two-step method: (1) we copyright the
library, and (2) we offer you this license, which gives you legal
permission to copy, distribute and/or modify the library.

  To protect each distributor, we want to make it very clear that
there is no warranty for the free library.  Also, if the library is
modified by someone else and passed on, the recipients should know
that what they have is not the original version, so that the original
author's reputation will not be affected by problems that might be
introduced by others.

  Finally, software patents pose a constant threat to the existence of
any free program.  We wish to make sure that a company cannot
effectively restrict the users of a free program by obtaining a
restrictive license from a patent holder.  Therefore, we insist that
any patent license obtained for a version of the library must be
consistent with the full freedom of use specified in this license.

  Most GNU software, including some libraries, is covered by the
ordinary GNU General Public License.  This license, the GNU Lesser
General Public License, applies to certain designated libraries, and
is quite different from the ordinary General Public License.  We use
this license for certain libraries in order to permit linking those
libraries into non-free programs.

  When a program is linked with a library, whether statically or using
a shared library, the combination of the two is legally speaking a
combined work, a derivative of the original library.  The ordinary
General Public License therefore permits such linking only if the
entire combination fits its criteria of freedom.  The Lesser General
Public License permits more lax criteria for linking other code with
the library.

  We call this license the "Lesser" General Public License because it
does Less to protect the user's freedom than the ordinary General
Public License.  It also provides other free software developers Less
of an advantage over competing non-free programs.  These disadvantages
are the reason we use the ordinary General Public License for many
libraries.  However, the Lesser license provides advantages in certain
special circumstances.

  For example, on rare occasions, there may be a special need to
encourage the widest possible use of a certain library, so that it becomes
a de-facto standard.  To achieve this, non-free programs must be
allowed to use the library.  A more frequent case is that a free
library does the same job as widely used non-free libraries.  In this
case, there is little to gain by limiting the free library to free
software only, so we use the Lesser General Public License.

  In other cases, permission to use a particular library in non-free
programs enables a greater number of people to use a large body of
free software.  For example, permission to use the GNU C Library in
non-free programs enables many more people to use the whole GNU
operating system, as well as its variant, the GNU/Linux operating
system.

  Although the Lesser General Public License is Less protective of the
users' freedom, it does ensure that the user of a program that is
linked with the Library has the freedom and the wherewithal to run
that program using a modified version of the Library.

  The precise terms and conditions for copying, distribution and
modification follow.  Pay close attention to the difference between a
"work based on the library" and a "work that uses the library".  The
former contains code derived from the library, whereas the latter must
be combined with the library in order to run.

                  GNU LESSER GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License Agreement applies to any software library or other
program which contains a notice placed by the copyright holder or
other authorized party saying it may be distributed under the terms of
this Lesser General Public License (also called "this License").
Each licensee is addressed as "you".

  A "library" means a collection of software functions and/or data
prepared so as to be conveniently linked with application programs
(which use some of those functions and data) to form executables.

  The "Library", below, refers to any such software library or work
which has been distributed under these terms.  A "work based on the
Library" means either the Library or any derivative work under
copyright law: that is to say, a work containing the Library or a
portion of it, either verbatim or with modifications and/or translated
straightforwardly into another language.  (Hereinafter, translation is
included without limitation in the term "modification".)

  "Source code" for a work means the preferred form of the work for
making modifications to it.  For a library, complete source code means
all the source code for all modules it contains, plus any associated
interface definition files, plus the scripts used to control compilation
and installation of the library.

  Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running a program using the Library is not restricted, and output from
such a program is covered only if its contents constitute a work based
on the Library (independent of the use of the Library in a tool for
writing it).  Whether that is true depends on what the Library does
and what the program that uses the Library does.

  1. You may copy and distribute verbatim copies of the Library's
complete source code as you receive it, in any medium, provided that
you conspicuously and appropriately publish on each copy an
appropriate copyright notice and disclaimer of warranty; keep intact
all the notices that refer to this License and to the absence of any
warranty; and distribute a copy of this License along with the
Library.

  You may charge a fee for the physical act of transferring a copy,
and you may at your option offer warranty protection in exchange for a
fee.

  2. You may modify your copy or copies of the Library or any portion
of it, thus forming a work based on the Library, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) The modified work must itself be a software library.

    b) You must cause the files modified to carry prominent notices
    stating that you changed the files and the date of any change.

    c) You must cause the whole of the work to be licensed at no
    charge to all third parties under the terms of this License.

    d) If a facility in the modified Library refers to a function or a
    table of data to be supplied by an application program that uses
    the facility, other than as an argument passed when the facility
    is invoked, then you must make a good faith effort to ensure that,
    in the event an application does not supply such function or
    table, the facility still operates, and performs whatever part of
    its purpose remains meaningful.

    (For example, a function in a library to compute square roots has
    a purpose that is entirely well-defined independent of the
    application.  Therefore, Subsection 2d requires that any
    application-supplied function or table used by this function must
    be optional: if the application does not supply it, the square
    root function must still compute square roots.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Library,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Library, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote
it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Library.

In addition, mere aggregation of another work not based on the Library
with the Library (or with a work based on the Library) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may opt to apply the terms of the ordinary GNU General Public
License instead of this License to a given copy of the Library.  To do
this, you must alter all the notices that refer to this License, so
that they refer to the ordinary GNU General Public License, version 2,
instead of to this License.  (If a newer version than version 2 of the
ordinary GNU General Public License has appeared, then you can specify
that version instead if you wish.)  Do not make any other change in
these notices.

  Once this change is made in a given copy, it is irreversible for
that copy, so the ordinary GNU General Public License applies to all
subsequent copies and derivative works made from that copy.

  This option is useful when you wish to copy part of the code of
the Library into a program that is not a library.

  4. You may copy and distribute the Library (or a portion or
derivative of it, under Section 2) in object code or executable form
under the terms of Sections 1 and 2 above provided that you accompany
it with the complete corresponding machine-readable source code, which
must be distributed under the terms of Sections 1 and 2 above on a
medium customarily used for software interchange.

  If distribution of object code is made by offering access to copy
from a designated place, then offering equivalent access to copy the
source code from the same place satisfies the requirement to
distribute the source code, even though third parties are not
compelled to copy the source along with the object code.

  5. A program that contains no derivative of any portion of the
Library, but is designed to work with the Library by being compiled or
linked with it, is called a "work that uses the Library".  Such a
work, in isolation, is not a derivative work of the Library, and
therefore falls outside the scope of this License.

  However, linking a "work that uses the Library" with the Library
creates an executable that is a derivative of the Library (because it
contains portions of the Library), rather than a "work that uses the
library".  The executable is therefore covered by this License.
Section 6 states terms for distribution of such executables.

  When a "work that uses the Library" uses material from a header file
that is part of the Library, the object code for the work may be a
derivative work of the Library even though the source code is not.
Whether this is true is especially significant if the work can be
linked without the Library, or if the work is itself a library.  The
threshold for this to be true is not precisely defined by law.

  If such an object file uses only numerical parameters, data
structure layouts and accessors, and small macros and small inline
functions (ten lines or less in length), then the use of the object
file is unrestricted, regardless of whether it is legally a derivative
work.  (Executables containing this object code plus portions of the
Library will still fall under Section 6.)

  Otherwise, if the work is a derivative of the Library, you may
distribute the object code for the work under the terms of Section 6.
Any executables containing that work also fall under Section 6,
whether or not they are linked directly with the Library itself.

  6. As an exception to the Sections above, you may also combine or
link a "work that uses the Library" with the Library to produce a
work containing portions of the Library, and distribute that work
under terms of your choice, provided that the terms permit
modification of the work for the customer's own use and reverse
engineering for debugging such modifications.

  You must give prominent notice with each copy of the work that the
Library is used in it and that the Library and its use are covered by
this License.  You must supply a copy of this License.  If the work
during execution displays copyright notices, you must include the
copyright notice for the Library among them, as well as a reference
directing the user to the copy of this License.  Also, you must do one
of these things:

    a) Accompany the work with the complete corresponding
    machine-readable source code for the Library including whatever
    changes were used in the work (which must be distributed under
    Sections 1 and 2 above); and, if the work is an executable linked
    with the Library, with the complete machine-readable "work that
    uses the Library", as object code and/or source code, so that the
    user can modify the Library and then relink to produce a modified
    executable containing the modified Library.  (It is understood
    that the user who changes the contents of definitions files in the
    Library will not necessarily be able to recompile the application
    to use the modified definitions.)

    b) Use a suitable shared library mechanism for linking with the
    Library.  A suitable mechanism is one that (1) uses at run time a
    copy of the library already present on the user's computer system,
    rather than copying library functions into the executable, and (2)
    will operate properly with a modified version of the library, if
    the user installs one, as long as the modified version is
    interface-compatible with the version that the work was made with.

    c) Accompany the work with a written offer, valid for at
    least three years, to give the same user the materials
    specified in Subsection 6a, above, for a charge no more
    than the cost of performing this distribution.

    d) If distribution of the work is made by offering access to copy
    from a designated place, offer equivalent access to copy the above
    specified materials from the same place.

    e) Verify that the user has already received a copy of these
    materials or that you have already sent this user a copy.

  For an executable, the required form of the "work that uses the
Library" must include any data and utility programs needed for
reproducing the executable from it.  However, as a special exception,
the materials to be distributed need not include anything that is
normally distributed (in either source or binary form) with the major
components (compiler, kernel, and so on) of the operating system on
which the executable runs, unless that component itself accompanies
the executable.

  It may happen that this requirement contradicts the license
restrictions of other proprietary libraries that do not normally
accompany the operating system.  Such a contradiction means you cannot
use both them and the Library together in an executable that you
distribute.

  7. You may place library facilities that are a work based on the
Library side-by-side in a single library together with other library
facilities not covered by this License, and distribute such a combined
library, provided that the separate distribution of the work based on
the Library and of the other library facilities is otherwise
permitted, and provided that you do these two things:

    a) Accompany the combined library with a copy of the same work
    based on the Library, uncombined with any other library
    facilities.  This must be distributed under the terms of the
    Sections above.

    b) Give prominent notice with the combined library of the fact
    that part of it is a work based on the Library, and explaining
    where to find the accompanying uncombined form of the same work.

  8. You may not copy, modify, sublicense, link with, or distribute
the Library except as expressly provided under this License.  Any
attempt otherwise to copy, modify, sublicense, link with, or
distribute the Library is void, and will automatically terminate your
rights under this License.  However, parties who have received copies,
or rights, from you under this License will not have their licenses
terminated so long as such parties remain in full compliance.

  9. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Library or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Library (or any work based on the
Library), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Library or works based on it.

  10. Each time you redistribute the Library (or any work based on the
Library), the recipient automatically receives a license from the
original licensor to copy, distribute, link with or modify the Library
subject to these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties with
this License.

  11. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Library at all.  For example, if a patent
license would not permit royalty-free redistribution of the Library by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Library.

If any portion of this section is held invalid or unenforceable under any
particular circumstance, the balance of the section is intended to apply,
and the section as a whole is intended to apply in other circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  12. If the distribution and/or use of the Library is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Library under this License may add
an explicit geographical distribution limitation excluding those countries,
so that distribution is permitted only in or among countries not thus
excluded.  In such case, this License incorporates the limitation as if
written in the body of this License.

  13. The Free Software Foundation may publish revised and/or new
versions of the Lesser General Public License from time to time.
Such new versions will be similar in spirit to the present version,
but may differ in detail to address new problems or concerns.

Each version is given a distinguishing version number.  If the Library
specifies a version number of this License which applies to it and
"any later version", you have the option of following the terms and
conditions either of that version or of any later version published by
the Free Software Foundation.  If the Library does not specify a
license version number, you may choose any version ever published by
the Free Software Foundation.

  14. If you wish to incorporate parts of the Library into other free
programs whose distribution conditions are incompatible with these,
write to the author to ask for permission.  For software which is
copyrighted by the Free Software Foundation, write to the Free
Software Foundation; we sometimes make exceptions for this.  Our
decision will be guided by the two goals of preserving the free status
of all derivatives of our free software and of promoting the sharing
and reuse of software generally.

                            NO WARRANTY

  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
DAMAGES.

                     END OF TERMS AND CONDITIONS

           How to Apply These Terms to Your New Libraries

  If you develop a new library, and you want it to be of the greatest
possible use to the public, we recommend making it free software that
everyone can redistribute and change.  You can do so by permitting
redistribution under these terms (or, alternatively, under the terms of the
ordinary General Public License).

  To apply these terms, attach the following notices to the library.  It is
safest to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least the
"copyright" line and a pointer to where the full notice is found.

    <one line to give the library's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA

Also add information on how to contact you by electronic and paper mail.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the library, if
necessary.  Here is a sample; alter the names:

  Yoyodyne, Inc., hereby disclaims all copyright interest in the
  library `Frob' (a library for tweaking knobs) written by James Random Hacker.

  <signature of Ty Coon>, 1 April 1990
  Ty Coon, President of Vice

That's all there is to it!
```

`efiXloader/3rd/uefitool/UEFITool/qhexedit2/qhexedit.cpp`:

```cpp
#include <QApplication>
#include <QClipboard>
#include <QKeyEvent>
#include <QPainter>
#include <QScrollBar>

#include "qhexedit.h"
#include <algorithm>


// ********************************************************************** Constructor, destructor

QHexEdit::QHexEdit(QWidget *parent) : QAbstractScrollArea(parent)
{
    _addressArea = true;
    _addressWidth = 4;
    _asciiArea = true;
    _overwriteMode = true;
    _highlighting = true;
    _readOnly = false;
    _cursorPosition = 0;
    _lastEventSize = 0;
    _hexCharsInLine = 47;
    _bytesPerLine = 16;
    _editAreaIsAscii = false;

    _chunks = new Chunks(this);
    _undoStack = new UndoStack(_chunks, this);
#ifdef Q_OS_WIN32
    setFont(QFont("Courier", 10));
#else
    setFont(QFont("Monospace", 10));
#endif
    setAddressAreaColor(this->palette().alternateBase().color());
    setHighlightingColor(QColor(0xff, 0xff, 0x99, 0xff));
    setSelectionColor(this->palette().highlight().color());

    connect(&_cursorTimer, SIGNAL(timeout()), this, SLOT(updateCursor()));
    connect(verticalScrollBar(), SIGNAL(valueChanged(int)), this, SLOT(adjust()));
    connect(horizontalScrollBar(), SIGNAL(valueChanged(int)), this, SLOT(adjust()));
    connect(_undoStack, SIGNAL(indexChanged(int)), this, SLOT(dataChangedPrivate(int)));

    _cursorTimer.setInterval(500);
    _cursorTimer.start();

    setAddressWidth(4);
    setAddressArea(true);
    setAsciiArea(true);
    setOverwriteMode(true);
    setHighlighting(true);
    setReadOnly(false);

    init();

}

QHexEdit::~QHexEdit()
{
}

// ********************************************************************** Properties

void QHexEdit::setAddressArea(bool addressArea)
{
    _addressArea = addressArea;
    adjust();
    setCursorPosition(_cursorPosition);
    viewport()->update();
}

bool QHexEdit::addressArea()
{
    return _addressArea;
}

void QHexEdit::setAddressAreaColor(const QColor &color)
{
    _addressAreaColor = color;
    viewport()->update();
}

QColor QHexEdit::addressAreaColor()
{
    return _addressAreaColor;
}

void QHexEdit::setAddressOffset(qint64 addressOffset)
{
    _addressOffset = addressOffset;
    adjust();
    setCursorPosition(_cursorPosition);
    viewport()->update();
}

qint64 QHexEdit::addressOffset()
{
    return _addressOffset;
}

void QHexEdit::setAddressWidth(int addressWidth)
{
    _addressWidth = addressWidth;
    adjust();
    setCursorPosition(_cursorPosition);
    viewport()->update();
}

int QHexEdit::addressWidth()
{
    qint64 size = _chunks->size();
    int n = 1;
    if (size > Q_INT64_C(0x100000000)){ n += 8; size /= Q_INT64_C(0x100000000);}
    if (size > 0x10000){ n += 4; size /= 0x10000;}
    if (size > 0x100){ n += 2; size /= 0x100;}
    if (size > 0x10){ n += 1; }

    if (n > _addressWidth)
        return n;
    else
        return _addressWidth;
}

void QHexEdit::setAsciiArea(bool asciiArea)
{
    if (!asciiArea)
        _editAreaIsAscii = false;
    _asciiArea = asciiArea;		      
    adjust();
    setCursorPosition(_cursorPosition);
    viewport()->update();		      
}

bool QHexEdit::asciiArea()
{
    return _asciiArea;
}

void QHexEdit::setBytesPerLine(int count)
{
    _bytesPerLine = count;
    _hexCharsInLine = count * 3 - 1;

    adjust();
    setCursorPosition(_cursorPosition);
    viewport()->update();
}

int QHexEdit::bytesPerLine()
{
    return _bytesPerLine;
}

void QHexEdit::setCursorPosition(qint64 position)
{
    // 1. delete old cursor
    _blink = false;
    viewport()->update(_cursorRect);

    // 2. Check, if cursor in range?
    if (position > (_chunks->size() * 2 - 1))
        position = _chunks->size() * 2  - (_overwriteMode ? 1 : 0);

    if (position < 0)
        position = 0;

    // 3. Calc new position of cursor
    _bPosCurrent = position / 2;
    _pxCursorY = (int)((position / 2 - _bPosFirst) / _bytesPerLine + 1) * _pxCharHeight;
    int x = (position % (2 * _bytesPerLine));
    if (_editAreaIsAscii)
    {
        _pxCursorX = x / 2 * _pxCharWidth + _pxPosAsciiX;
        _cursorPosition = position & 0xFFFFFFFFFFFFFFFE;
    } else {
        _pxCursorX = (((x / 2) * 3) + (x % 2)) * _pxCharWidth + _pxPosHexX;
        _cursorPosition = position;
    }

    if (_overwriteMode)
        _cursorRect = QRect(_pxCursorX - horizontalScrollBar()->value(), _pxCursorY + _pxCursorWidth, _pxCharWidth, _pxCursorWidth);
    else
        _cursorRect = QRect(_pxCursorX - horizontalScrollBar()->value(), _pxCursorY - _pxCharHeight + 4, _pxCursorWidth, _pxCharHeight);

    // 4. Immediately draw new cursor
    _blink = true;
    viewport()->update(_cursorRect);
    emit currentAddressChanged(_bPosCurrent);
}

qint64 QHexEdit::cursorPosition(QPoint pos)
{
    // Calc cursor position depending on a graphical position
    qint64 result = -1;
    int posX = pos.x() + horizontalScrollBar()->value();
    int posY = pos.y() - 3;
    if ((posX >= _pxPosHexX) && (posX < (_pxPosHexX + (1 + _hexCharsInLine) * _pxCharWidth)))
    {
        _editAreaIsAscii = false;
        int x = (posX - _pxPosHexX) / _pxCharWidth;
        x = (x / 3) * 2 + x % 3;
        int y = (posY / _pxCharHeight) * 2 * _bytesPerLine;
        result = _bPosFirst * 2 + x + y;
    } else
        if (_asciiArea && (posX >= _pxPosAsciiX) && (posX < (_pxPosAsciiX + (1 + _bytesPerLine) * _pxCharWidth)))
        {
            _editAreaIsAscii = true;
            int x = 2 * (posX - _pxPosAsciiX) / _pxCharWidth;
            int y = (posY / _pxCharHeight) * 2 * _bytesPerLine;
            result = _bPosFirst * 2 + x + y;
        }
    return result;
}

qint64 QHexEdit::cursorPosition()
{
    return _cursorPosition;
}

void QHexEdit::setData(const QByteArray &ba)
{
    _data = ba;
    _bData.setData(_data);
    setData(_bData);
}

QByteArray QHexEdit::data()
{
    return _chunks->data(0, -1);
}

void QHexEdit::setHighlighting(bool highlighting)
{
    _highlighting = highlighting;
    viewport()->update();
}

bool QHexEdit::highlighting()
{
    return _highlighting;
}

void QHexEdit::setHighlightingColor(const QColor &color)
{
    _brushHighlighted = QBrush(color);
    _penHighlighted = QPen(viewport()->palette().color(QPalette::WindowText));
    viewport()->update();
}

QColor QHexEdit::highlightingColor()
{
    return _brushHighlighted.color();
}

void QHexEdit::setOverwriteMode(bool overwriteMode)
{
    _overwriteMode = overwriteMode;
    emit overwriteModeChanged(overwriteMode);
}

bool QHexEdit::overwriteMode()
{
    return _overwriteMode;
}

void QHexEdit::setSelectionColor(const QColor &color)
{
    _brushSelection = QBrush(color);
    _penSelection = QPen(Qt::white);
    viewport()->update();
}

QColor QHexEdit::selectionColor()
{
    return _brushSelection.color();
}

bool QHexEdit::isReadOnly()
{
    return _readOnly;
}

void QHexEdit::setReadOnly(bool readOnly)
{
    _readOnly = readOnly;
}

bool QHexEdit::isUpperCase()
{
    return _upperCase;
}

void QHexEdit::setUpperCase(bool upperCase)
{
    _upperCase = upperCase;
}

// ********************************************************************** Access to data of qhexedit
bool QHexEdit::setData(QIODevice &iODevice)
{
    bool ok = _chunks->setIODevice(iODevice);
    init();
    dataChangedPrivate();
    return ok;
}

QByteArray QHexEdit::dataAt(qint64 pos, qint64 count)
{
    return _chunks->data(pos, count);
}

bool QHexEdit::write(QIODevice &iODevice, qint64 pos, qint64 count)
{
    return _chunks->write(iODevice, pos, count);
}

// ********************************************************************** Char handling
void QHexEdit::insert(qint64 index, char ch)
{
    _undoStack->insert(index, ch);
    refresh();
}

void QHexEdit::remove(qint64 index, qint64 len)
{
    _undoStack->removeAt(index, len);
    refresh();
}

void QHexEdit::replace(qint64 index, char ch)
{
    _undoStack->overwrite(index, ch);
    refresh();
}

// ********************************************************************** ByteArray handling
void QHexEdit::insert(qint64 pos, const QByteArray &ba)
{
    _undoStack->insert(pos, ba);
    refresh();
}

void QHexEdit::replace(qint64 pos, qint64 len, const QByteArray &ba)
{
    _undoStack->overwrite(pos, (int)len, ba);
    refresh();
}

// ********************************************************************** Utility functions
void QHexEdit::ensureVisible()
{
    if (_cursorPosition < (_bPosFirst * 2))
        verticalScrollBar()->setValue((int)(_cursorPosition / 2 / _bytesPerLine));
    if (_cursorPosition > ((_bPosFirst + (_rowsShown - 1)*_bytesPerLine) * 2))
        verticalScrollBar()->setValue((int)(_cursorPosition / 2 / _bytesPerLine) - _rowsShown + 1);
    if (_pxCursorX < horizontalScrollBar()->value())
        horizontalScrollBar()->setValue(_pxCursorX);
    if ((_pxCursorX + _pxCharWidth) > (horizontalScrollBar()->value() + viewport()->width()))
        horizontalScrollBar()->setValue(_pxCursorX + _pxCharWidth - viewport()->width());
    viewport()->update();
}

qint64 QHexEdit::indexOf(const QByteArray &ba, qint64 from)
{
    qint64 pos = _chunks->indexOf(ba, from);
    if (pos > -1)
    {
        qint64 curPos = pos*2;
        setCursorPosition(curPos + ba.length()*2);
        resetSelection(curPos);
        setSelection(curPos + ba.length()*2);
        ensureVisible();
    }
    return pos;
}

bool QHexEdit::isModified()
{
    return _modified;
}

qint64 QHexEdit::lastIndexOf(const QByteArray &ba, qint64 from)
{
    qint64 pos = _chunks->lastIndexOf(ba, from);
    if (pos > -1)
    {
        qint64 curPos = pos*2;
        setCursorPosition(curPos - 1);
        resetSelection(curPos);
        setSelection(curPos + ba.length()*2);
        ensureVisible();
    }
    return pos;
}

void QHexEdit::redo()
{
    _undoStack->redo();
    setCursorPosition(_chunks->pos()*(_editAreaIsAscii ? 1 : 2));
    refresh();
}

QString QHexEdit::selectionToReadableString()
{
    QByteArray ba = _chunks->data(getSelectionBegin(), getSelectionEnd() - getSelectionBegin());
    return toReadable(ba);
}

void QHexEdit::setFont(const QFont &font)
{
    QWidget::setFont(font);
    _pxCharWidth = fontMetrics().width(QLatin1Char('2'));
    _pxCharHeight = fontMetrics().height();
    _pxGapAdr = _pxCharWidth / 2;
    _pxGapAdrHex = _pxCharWidth;
    _pxGapHexAscii = 2 * _pxCharWidth;
    _pxCursorWidth = _pxCharHeight / 7;
    _pxSelectionSub = _pxCharHeight / 5;
    viewport()->update();
}

QString QHexEdit::toReadableString()
{
    QByteArray ba = _chunks->data();
    return toReadable(ba);
}

void QHexEdit::undo()
{
    _undoStack->undo();
    setCursorPosition(_chunks->pos()*(_editAreaIsAscii ? 1 : 2));
    refresh();
}

// ********************************************************************** Handle events
void QHexEdit::keyPressEvent(QKeyEvent *event)
{
    // Cursor movements
    if (event->matches(QKeySequence::MoveToNextChar))
    {
        qint64 pos = _cursorPosition + 1;
        if (_editAreaIsAscii)
            pos += 1;
        setCursorPosition(pos);
        resetSelection(pos);
    }
    if (event->matches(QKeySequence::MoveToPreviousChar))
    {
        qint64 pos = _cursorPosition - 1;
        if (_editAreaIsAscii)
            pos -= 1;
        setCursorPosition(pos);
        resetSelection(pos);
    }
    if (event->matches(QKeySequence::MoveToEndOfLine))
    {
        qint64 pos = _cursorPosition - (_cursorPosition % (2 * _bytesPerLine)) + (2 * _bytesPerLine) - 1;
        setCursorPosition(pos);
        resetSelection(_cursorPosition);
    }
    if (event->matches(QKeySequence::MoveToStartOfLine))
    {
        qint64 pos = _cursorPosition - (_cursorPosition % (2 * _bytesPerLine));
        setCursorPosition(pos);
        resetSelection(_cursorPosition);
    }
    if (event->matches(QKeySequence::MoveToPreviousLine))
    {
        setCursorPosition(_cursorPosition - (2 * _bytesPerLine));
        resetSelection(_cursorPosition);
    }
    if (event->matches(QKeySequence::MoveToNextLine))
    {
        setCursorPosition(_cursorPosition + (2 * _bytesPerLine));
        resetSelection(_cursorPosition);
    }
    if (event->matches(QKeySequence::MoveToNextPage))
    {
        setCursorPosition(_cursorPosition + (((_rowsShown - 1) * 2 * _bytesPerLine)));
        resetSelection(_cursorPosition);
    }
    if (event->matches(QKeySequence::MoveToPreviousPage))
    {
        setCursorPosition(_cursorPosition - (((_rowsShown - 1) * 2 * _bytesPerLine)));
        resetSelection(_cursorPosition);
    }
    if (event->matches(QKeySequence::MoveToEndOfDocument))
    {
        setCursorPosition(_chunks->size() * 2 );
        resetSelection(_cursorPosition);
    }
    if (event->matches(QKeySequence::MoveToStartOfDocument))
    {
        setCursorPosition(0);
        resetSelection(_cursorPosition);
    }

    // Select commands
    if (event->matches(QKeySequence::SelectAll))
    {
        resetSelection(0);
        setSelection(2 * _chunks->size() + 1);
    }
    if (event->matches(QKeySequence::SelectNextChar))
    {
        qint64 pos = _cursorPosition + 1;
        if (_editAreaIsAscii)
            pos += 1;
        setCursorPosition(pos);
        setSelection(pos);
    }
    if (event->matches(QKeySequence::SelectPreviousChar))
    {
        qint64 pos = _cursorPosition - 1;
        if (_editAreaIsAscii)
            pos -= 1;
        setSelection(pos);
        setCursorPosition(pos);
    }
    if (event->matches(QKeySequence::SelectEndOfLine))
    {
        qint64 pos = _cursorPosition - (_cursorPosition % (2 * _bytesPerLine)) + (2 * _bytesPerLine) - 1;
        setCursorPosition(pos);
        setSelection(pos);
    }
    if (event->matches(QKeySequence::SelectStartOfLine))
    {
        qint64 pos = _cursorPosition - (_cursorPosition % (2 * _bytesPerLine));
        setCursorPosition(pos);
        setSelection(pos);
    }
    if (event->matches(QKeySequence::SelectPreviousLine))
    {
        qint64 pos = _cursorPosition - (2 * _bytesPerLine);
        setCursorPosition(pos);
        setSelection(pos);
    }
    if (event->matches(QKeySequence::SelectNextLine))
    {
        qint64 pos = _cursorPosition + (2 * _bytesPerLine);
        setCursorPosition(pos);
        setSelection(pos);
    }
    if (event->matches(QKeySequence::SelectNextPage))
    {
        qint64 pos = _cursorPosition + (((viewport()->height() / _pxCharHeight) - 1) * 2 * _bytesPerLine);
        setCursorPosition(pos);
        setSelection(pos);
    }
    if (event->matches(QKeySequence::SelectPreviousPage))
    {
        qint64 pos = _cursorPosition - (((viewport()->height() / _pxCharHeight) - 1) * 2 * _bytesPerLine);
        setCursorPosition(pos);
        setSelection(pos);
    }
    if (event->matches(QKeySequence::SelectEndOfDocument))
    {
        qint64 pos = _chunks->size() * 2;
        setCursorPosition(pos);
        setSelection(pos);
    }
    if (event->matches(QKeySequence::SelectStartOfDocument))
    {
        qint64 pos = 0;
        setCursorPosition(pos);
        setSelection(pos);
    }

    // Edit Commands
    if (!_readOnly)
    {
        /* Cut */
        if (event->matches(QKeySequence::Cut))
        {
            QByteArray ba = _chunks->data(getSelectionBegin(), getSelectionEnd() - getSelectionBegin()).toHex();
            for (qint64 idx = 32; idx < ba.size(); idx +=33)
                ba.insert(idx, "\n");
            QClipboard *clipboard = QApplication::clipboard();
            clipboard->setText(ba);
            if (_overwriteMode)
            {
                qint64 len = getSelectionEnd() - getSelectionBegin();
                replace(getSelectionBegin(), (int)len, QByteArray((int)len, char(0)));
            }
            else
            {
                remove(getSelectionBegin(), getSelectionEnd() - getSelectionBegin());
            }
            setCursorPosition(2 * getSelectionBegin());
            resetSelection(2 * getSelectionBegin());
        } else

        /* Paste */
        if (event->matches(QKeySequence::Paste))
        {
            QClipboard *clipboard = QApplication::clipboard();
            QByteArray ba = QByteArray().fromHex(clipboard->text().toLatin1());
            if (_overwriteMode)
            {
                ba = ba.left(std::min<qint64>(ba.size(), (_chunks->size() - _bPosCurrent)));
                replace(_bPosCurrent, ba.size(), ba);
            }
            else
                insert(_bPosCurrent, ba);
            setCursorPosition(_cursorPosition + 2 * ba.size());
            resetSelection(getSelectionBegin());
        } else

        /* Delete char */
        if (event->matches(QKeySequence::Delete))
        {
            if (getSelectionBegin() != getSelectionEnd())
            {
                _bPosCurrent = getSelectionBegin();
                if (_overwriteMode)
                {
                    QByteArray ba = QByteArray(getSelectionEnd() - getSelectionBegin(), char(0));
                    replace(_bPosCurrent, ba.size(), ba);
                }
                else
                {
                    remove(_bPosCurrent, getSelectionEnd() - getSelectionBegin());
                }
            }
            else
            {
                if (_overwriteMode)
                    replace(_bPosCurrent, char(0));
                else
                    remove(_bPosCurrent, 1);
            }
            setCursorPosition(2 * _bPosCurrent);
            resetSelection(2 * _bPosCurrent);
        } else

        /* Backspace */
        if ((event->key() == Qt::Key_Backspace) && (event->modifiers() == Qt::NoModifier))
        {
            if (getSelectionBegin() != getSelectionEnd())
            {
                _bPosCurrent = getSelectionBegin();
                setCursorPosition(2 * _bPosCurrent);
                if (_overwriteMode)
                {
                    QByteArray ba = QByteArray(getSelectionEnd() - getSelectionBegin(), char(0));
                    replace(_bPosCurrent, ba.size(), ba);
                }
                else
                {
                    remove(_bPosCurrent, getSelectionEnd() - getSelectionBegin());
                }
                resetSelection(2 * _bPosCurrent);
            }
            else
            {
                bool behindLastByte = false;
                if ((_cursorPosition / 2) == _chunks->size())
                    behindLastByte = true;

                _bPosCurrent -= 1;
                if (_overwriteMode)
                    replace(_bPosCurrent, char(0));
                else
                    remove(_bPosCurrent, 1);

                if (!behindLastByte)
                    _bPosCurrent -= 1;

                setCursorPosition(2 * _bPosCurrent);
                resetSelection(2 * _bPosCurrent);
            }
        } else

        /* undo */
        if (event->matches(QKeySequence::Undo))
        {
            undo();
        } else

        /* redo */
        if (event->matches(QKeySequence::Redo))
        {
            redo();
        } else

        if ((QApplication::keyboardModifiers() == Qt::NoModifier) ||
            (QApplication::keyboardModifiers() == Qt::KeypadModifier) ||
            (QApplication::keyboardModifiers() == Qt::ShiftModifier) ||
            (QApplication::keyboardModifiers() == (Qt::AltModifier | Qt::ControlModifier)) ||
            (QApplication::keyboardModifiers() == Qt::GroupSwitchModifier))
        {
            /* Hex and ascii input */
            int key;
            if (_editAreaIsAscii)
                key = (uchar)event->text()[0].toLatin1();
            else
                key = int(event->text()[0].toLower().toLatin1());

            if ((((key >= '0' && key <= '9') || (key >= 'a' && key <= 'f')) && _editAreaIsAscii == false)
                || (key >= ' ' && _editAreaIsAscii))
            {
                if (getSelectionBegin() != getSelectionEnd())
                {
                    if (_overwriteMode)
                    {
                        qint64 len = getSelectionEnd() - getSelectionBegin();
                        replace(getSelectionBegin(), (int)len, QByteArray((int)len, char(0)));
                    } else
                    {
                        remove(getSelectionBegin(), getSelectionEnd() - getSelectionBegin());
                        _bPosCurrent = getSelectionBegin();
                    }
                    setCursorPosition(2 * _bPosCurrent);
                    resetSelection(2 * _bPosCurrent);
                }

                // If insert mode, then insert a byte
                if (_overwriteMode == false)
                    if ((_cursorPosition % 2) == 0)
                        insert(_bPosCurrent, char(0));

                // Change content
                if (_chunks->size() > 0)
                {
                    char ch = key;
                    if (!_editAreaIsAscii){
                        QByteArray hexValue = _chunks->data(_bPosCurrent, 1).toHex();
                        if ((_cursorPosition % 2) == 0)
                            hexValue[0] = key;
                        else
                            hexValue[1] = key;
                        ch = QByteArray().fromHex(hexValue)[0];
                    }
                    replace(_bPosCurrent, ch);
                    if (_editAreaIsAscii)
                        setCursorPosition(_cursorPosition + 2);
                    else
                        setCursorPosition(_cursorPosition + 1);
                    resetSelection(_cursorPosition);
                }
            }
        }
    }

    /* Copy */
    if (event->matches(QKeySequence::Copy))
    {
        QByteArray ba = _chunks->data(getSelectionBegin(), getSelectionEnd() - getSelectionBegin()).toHex();
        for (qint64 idx = 32; idx < ba.size(); idx += 33)
            ba.insert(idx, "\n");
		if(_upperCase)
			ba = ba.toUpper();
        QClipboard *clipboard = QApplication::clipboard();
        clipboard->setText(ba);
    }

    // Switch between insert/overwrite mode
    if ((event->key() == Qt::Key_Insert) && (event->modifiers() == Qt::NoModifier))
    {
        setOverwriteMode(!overwriteMode());
        setCursorPosition(_cursorPosition);
    }

    // switch from hex to ascii edit
    if (event->key() == Qt::Key_Tab && !_editAreaIsAscii){
        _editAreaIsAscii = true;
        setCursorPosition(_cursorPosition);
    }

    // switch from ascii to hex edit
    if (event->key() == Qt::Key_Backtab  && _editAreaIsAscii){
        _editAreaIsAscii = false;
        setCursorPosition(_cursorPosition);
    }

    refresh();
}

void QHexEdit::mouseMoveEvent(QMouseEvent * event)
{
    _blink = false;
    viewport()->update();
    qint64 actPos = cursorPosition(event->pos());
    if (actPos >= 0)
    {
        setCursorPosition(actPos);
        setSelection(actPos);
    }
}

void QHexEdit::mousePressEvent(QMouseEvent * event)
{
    _blink = false;
    viewport()->update();
    qint64 cPos = cursorPosition(event->pos());
    if (cPos >= 0)
    {
        resetSelection(cPos);
        setCursorPosition(cPos);
    }
}

void QHexEdit::paintEvent(QPaintEvent *event)
{
    QPainter painter(viewport());
    int pxOfsX = horizontalScrollBar()->value();

    if (event->rect() != _cursorRect)
    {
        int pxPosStartY = _pxCharHeight;

        // draw some patterns if needed
        painter.fillRect(event->rect(), viewport()->palette().color(QPalette::Base));
        if (_addressArea)
            painter.fillRect(QRect(-pxOfsX, event->rect().top(), _pxPosHexX - _pxGapAdrHex/2, height()), _addressAreaColor);
        if (_asciiArea)
        {
            int linePos = _pxPosAsciiX - (_pxGapHexAscii / 2);
            painter.setPen(Qt::gray);
            painter.drawLine(linePos - pxOfsX, event->rect().top(), linePos - pxOfsX, height());
        }

        painter.setPen(viewport()->palette().color(QPalette::WindowText));

        // paint address area
        if (_addressArea)
        {
            QString address;
            for (int row=0, pxPosY = _pxCharHeight; row <= (_dataShown.size()/_bytesPerLine); row++, pxPosY +=_pxCharHeight)
            {
                address = QString("%1").arg(_bPosFirst + row*_bytesPerLine + _addressOffset, _addrDigits, 16, QChar('0'));
                // upper or lower case
                if (_upperCase)
                    address = address.toUpper();

                painter.drawText(_pxPosAdrX - pxOfsX, pxPosY, address);
            }
        }

        // paint hex and ascii area
        QPen colStandard = QPen(viewport()->palette().color(QPalette::WindowText));

        painter.setBackgroundMode(Qt::TransparentMode);

        for (int row = 0, pxPosY = pxPosStartY; row <= _rowsShown; row++, pxPosY +=_pxCharHeight)
        {
            QByteArray hex;
            int pxPosX = _pxPosHexX  - pxOfsX;
            int pxPosAsciiX2 = _pxPosAsciiX  - pxOfsX;
            qint64 bPosLine = (qint64)row * _bytesPerLine;
            for (int colIdx = 0; ((bPosLine + colIdx) < _dataShown.size() && (colIdx < _bytesPerLine)); colIdx++)
            {
                QColor c = viewport()->palette().color(QPalette::Base);
                painter.setPen(colStandard);

                qint64 posBa = _bPosFirst + bPosLine + colIdx;
                if ((getSelectionBegin() <= posBa) && (getSelectionEnd() > posBa))
                {
                    c = _brushSelection.color();
                    painter.setPen(_penSelection);
                }
                else
                {
                    if (_highlighting)
                        if (_markedShown.at((int)(posBa - _bPosFirst)))
                        {
                            c = _brushHighlighted.color();
                            painter.setPen(_penHighlighted);
                        }
                }

                // render hex value
                QRect r;
                if (colIdx == 0)
                    r.setRect(pxPosX, pxPosY - _pxCharHeight + _pxSelectionSub, 2*_pxCharWidth, _pxCharHeight);
                else
                    r.setRect(pxPosX - _pxCharWidth, pxPosY - _pxCharHeight + _pxSelectionSub, 3*_pxCharWidth, _pxCharHeight);
                painter.fillRect(r, c);
                hex = _hexDataShown.mid((bPosLine + colIdx) * 2, 2);

                // upper or lower case
                if (_upperCase)
                    hex = hex.toUpper();

                painter.drawText(pxPosX, pxPosY, hex);
                pxPosX += 3*_pxCharWidth;

                // render ascii value
                if (_asciiArea)
                {
                    int ch = (uchar)_dataShown.at(bPosLine + colIdx);
                    if ( ch < 0x20 )
                        ch = '.';
                    r.setRect(pxPosAsciiX2, pxPosY - _pxCharHeight + _pxSelectionSub, _pxCharWidth, _pxCharHeight);
                    painter.fillRect(r, c);
                    painter.drawText(pxPosAsciiX2, pxPosY, QChar(ch));
                    pxPosAsciiX2 += _pxCharWidth;
                }
            }
        }
        painter.setBackgroundMode(Qt::TransparentMode);
        painter.setPen(viewport()->palette().color(QPalette::WindowText));
    }

    // paint cursor
    if (_blink && !_readOnly && hasFocus())
        painter.fillRect(_cursorRect, this->palette().color(QPalette::WindowText));
    else
        painter.drawRect(QRect(_pxCursorX - pxOfsX, _pxCursorY - _pxCharHeight + 2, _pxCharWidth, _pxCharHeight - 1));

    // emit event, if size has changed
    if (_lastEventSize != _chunks->size())
    {
        _lastEventSize = _chunks->size();
        emit currentSizeChanged(_lastEventSize);
    }
}

void QHexEdit::resizeEvent(QResizeEvent *)
{
    adjust();
}

bool QHexEdit::focusNextPrevChild(bool next)
{
    if (_addressArea)
    {
        if ((next && _editAreaIsAscii) || (!next && !_editAreaIsAscii))
            return QWidget::focusNextPrevChild(next);
        else
            return false;
    }
    else
    {
        return QWidget::focusNextPrevChild(next);
    }
}

// ********************************************************************** Handle selections
void QHexEdit::resetSelection()
{
    _bSelectionBegin = _bSelectionInit;
    _bSelectionEnd = _bSelectionInit;
}

void QHexEdit::resetSelection(qint64 pos)
{
    pos = pos / 2 ;
    if (pos < 0)
        pos = 0;
    if (pos > _chunks->size())
        pos = _chunks->size();

    _bSelectionInit = pos;
    _bSelectionBegin = pos;
    _bSelectionEnd = pos;
}

void QHexEdit::setSelection(qint64 pos)
{
    pos = pos / 2;
    if (pos < 0)
        pos = 0;
    if (pos > _chunks->size())
        pos = _chunks->size();

    if (pos >= _bSelectionInit)
    {
        _bSelectionEnd = pos;
        _bSelectionBegin = _bSelectionInit;
    }
    else
    {
        _bSelectionBegin = pos;
        _bSelectionEnd = _bSelectionInit;
    }
}

int QHexEdit::getSelectionBegin()
{
    return _bSelectionBegin;
}

int QHexEdit::getSelectionEnd()
{
    return _bSelectionEnd;
}

// ********************************************************************** Private utility functions
void QHexEdit::init()
{
    _undoStack->clear();
    setAddressOffset(0);
    resetSelection(0);
    setCursorPosition(0);
    verticalScrollBar()->setValue(0);
    _modified = false;
}

void QHexEdit::adjust()
{
    // recalc Graphics
    if (_addressArea)
    {
        _addrDigits = addressWidth();
        _pxPosHexX = _pxGapAdr + _addrDigits*_pxCharWidth + _pxGapAdrHex;
    }
    else
        _pxPosHexX = _pxGapAdrHex;
    _pxPosAdrX = _pxGapAdr;
    _pxPosAsciiX = _pxPosHexX + _hexCharsInLine * _pxCharWidth + _pxGapHexAscii;

    // set horizontalScrollBar()
    int pxWidth = _pxPosAsciiX;
    if (_asciiArea)
        pxWidth += _bytesPerLine*_pxCharWidth;
    horizontalScrollBar()->setRange(0, pxWidth - viewport()->width());
    horizontalScrollBar()->setPageStep(viewport()->width());

    // set verticalScrollbar()
    _rowsShown = ((viewport()->height()-4)/_pxCharHeight);
    int lineCount = (int)(_chunks->size() / (qint64)_bytesPerLine) + 1;
    verticalScrollBar()->setRange(0, lineCount - _rowsShown);
    verticalScrollBar()->setPageStep(_rowsShown);

    int value = verticalScrollBar()->value();
    _bPosFirst = (qint64)value * _bytesPerLine;
    _bPosLast = _bPosFirst + ((qint64)_rowsShown * _bytesPerLine) - 1;
    if (_bPosLast >= _chunks->size())
        _bPosLast = _chunks->size() - 1;
    readBuffers();
    setCursorPosition(_cursorPosition);
}

void QHexEdit::dataChangedPrivate(int)
{
    _modified = _undoStack->index() != 0;
    adjust();
    emit dataChanged();
}

void QHexEdit::refresh()
{
    ensureVisible();
    readBuffers();
}

void QHexEdit::readBuffers()
{
    _dataShown = _chunks->data(_bPosFirst, _bPosLast - _bPosFirst + _bytesPerLine + 1, &_markedShown);
    _hexDataShown = QByteArray(_dataShown.toHex());
}

QString QHexEdit::toReadable(const QByteArray &ba)
{
    QString result;

    for (int i=0; i < ba.size(); i += 16)
    {
        QString addrStr = QString("%1").arg(_addressOffset + i, addressWidth(), 16, QChar('0'));
        QString hexStr;
        QString ascStr;
        for (int j=0; j<16; j++)
        {
            if ((i + j) < ba.size())
            {
                hexStr.append(" ").append(ba.mid(i+j, 1).toHex());
                char ch = ba[i + j];
                if ((ch < 0x20) || (ch > 0x7e))
                        ch = '.';
                ascStr.append(QChar(ch));
            }
        }
        result += addrStr + " " + QString("%1").arg(hexStr, -48) + "  " + QString("%1").arg(ascStr, -17) + "\n";
    }
    return result;
}

void QHexEdit::updateCursor()
{
    if (_blink)
        _blink = false;
    else
        _blink = true;
    viewport()->update(_cursorRect);
}

```

`efiXloader/3rd/uefitool/UEFITool/qhexedit2/qhexedit.h`:

```h
#ifndef QHEXEDIT_H
#define QHEXEDIT_H

#include <QAbstractScrollArea>
#include <QPen>
#include <QBrush>

#include "chunks.h"
#include "commands.h"

#ifdef QHEXEDIT_EXPORTS
#define QHEXEDIT_API Q_DECL_EXPORT
#elif QHEXEDIT_IMPORTS
#define QHEXEDIT_API Q_DECL_IMPORT
#else
#define QHEXEDIT_API
#endif

/** \mainpage
QHexEdit is a binary editor widget for Qt.

\version Version 0.8.2
\image html qhexedit.png
*/


/** QHexEdit is a hex editor widget written in C++ for the Qt (Qt4, Qt5) framework.
It is a simple editor for binary data, just like QPlainTextEdit is for text
data. There are sip configuration files included, so it is easy to create
bindings for PyQt and you can use this widget also in python 2 and 3.

QHexEdit takes the data of a QByteArray (setData()) and shows it. You can use
the mouse or the keyboard to navigate inside the widget. If you hit the keys
(0..9, a..f) you will change the data. Changed data is highlighted and can be
accessed via data().

Normaly QHexEdit works in the overwrite Mode. You can set overwriteMode(false)
and insert data. In this case the size of data() increases. It is also possible
to delete bytes (del or backspace), here the size of data decreases.

You can select data with keyboard hits or mouse movements. The copy-key will
copy the selected data into the clipboard. The cut-key copies also but delets
it afterwards. In overwrite mode, the paste function overwrites the content of
the (does not change the length) data. In insert mode, clipboard data will be
inserted. The clipboard content is expected in ASCII Hex notation. Unknown
characters will be ignored.

QHexEdit comes with undo/redo functionality. All changes can be undone, by
pressing the undo-key (usually ctr-z). They can also be redone afterwards.
The undo/redo framework is cleared, when setData() sets up a new
content for the editor. You can search data inside the content with indexOf()
and lastIndexOf(). The replace() function is to change located subdata. This
'replaced' data can also be undone by the undo/redo framework.

QHexEdit is based on QIODevice, that's why QHexEdit can handle big amounts of
data. The size of edited data can be more then two gigabytes without any
restrictions.
*/
class QHEXEDIT_API QHexEdit : public QAbstractScrollArea
{
    Q_OBJECT

    /*! Property address area switch the address area on or off. Set addressArea true
    (show it), false (hide it).
    */
    Q_PROPERTY(bool addressArea READ addressArea WRITE setAddressArea)

    /*! Property address area color sets (setAddressAreaColor()) the backgorund
    color of address areas. You can also read the color (addressaAreaColor()).
    */
    Q_PROPERTY(QColor addressAreaColor READ addressAreaColor WRITE setAddressAreaColor)

    /*! Property addressOffset is added to the Numbers of the Address Area.
    A offset in the address area (left side) is sometimes usefull, whe you show
    only a segment of a complete memory picture. With setAddressOffset() you set
    this property - with addressOffset() you get the current value.
    */
    Q_PROPERTY(qint64 addressOffset READ addressOffset WRITE setAddressOffset)

    /*! Set and get the minimum width of the address area, width in characters.
    */
    Q_PROPERTY(int addressWidth READ addressWidth WRITE setAddressWidth)

    /*! Switch the ascii area on (true, show it) or off (false, hide it).
    */
    Q_PROPERTY(bool asciiArea READ asciiArea WRITE setAsciiArea)

    /*! Set and get bytes number per line.*/
    Q_PROPERTY(int bytesPerLine READ bytesPerLine WRITE setBytesPerLine)

    /*! Porperty cursorPosition sets or gets the position of the editor cursor
    in QHexEdit. Every byte in data has to cursor positions: the lower and upper
    Nibble. Maximum cursor position is factor two of data.size().
    */
    Q_PROPERTY(qint64 cursorPosition READ cursorPosition WRITE setCursorPosition)

    /*! Property data holds the content of QHexEdit. Call setData() to set the
    content of QHexEdit, data() returns the actual content. When calling setData()
    with a QByteArray as argument, QHexEdit creates a internal copy of the data
    If you want to edit big files please use setData(), based on QIODevice.
    */
    Q_PROPERTY(QByteArray data READ data WRITE setData NOTIFY dataChanged)

    /*! Switch the highlighting feature on or of: true (show it), false (hide it).
    */
    Q_PROPERTY(bool highlighting READ highlighting WRITE setHighlighting)

    /*! Property highlighting color sets (setHighlightingColor()) the backgorund
    color of highlighted text areas. You can also read the color
    (highlightingColor()).
    */
    Q_PROPERTY(QColor highlightingColor READ highlightingColor WRITE setHighlightingColor)

    /*! Porperty overwrite mode sets (setOverwriteMode()) or gets (overwriteMode()) the mode
    in which the editor works. In overwrite mode the user will overwrite existing data. The
    size of data will be constant. In insert mode the size will grow, when inserting
    new data.
    */
    Q_PROPERTY(bool overwriteMode READ overwriteMode WRITE setOverwriteMode)

    /*! Property selection color sets (setSelectionColor()) the backgorund
    color of selected text areas. You can also read the color
    (selectionColor()).
    */
    Q_PROPERTY(QColor selectionColor READ selectionColor WRITE setSelectionColor)

    /*! Property readOnly sets (setReadOnly()) or gets (isReadOnly) the mode
    in which the editor works. In readonly mode the the user can only navigate
    through the data and select data; modifying is not possible. This
    property's default is false.
    */
    Q_PROPERTY(bool readOnly READ isReadOnly WRITE setReadOnly)

    /*! Property upperCase sets (setUpperCase()) or gets (isUpperCase) the case of hex
    data. Default is lowercase.
    */
    Q_PROPERTY(bool upperCase READ isUpperCase WRITE setUpperCase)

    /*! Set the font of the widget. Please use fixed width fonts like Mono or Courier.*/
    Q_PROPERTY(QFont font READ font WRITE setFont)

public:
    /*! Creates an instance of QHexEdit.
    \param parent Parent widget of QHexEdit.
    */
    QHexEdit(QWidget *parent=0);

    // Access to data of qhexedit

    /*! Sets the data of QHexEdit. The QIODevice will be opend just before reading
    and closed immediately afterwards. This is to allow other programs to rewrite
    the file while editing it.
    */
    bool setData(QIODevice &iODevice);

    /*! Gives back the data as a QByteArray starting at position \param pos and
    delivering \param count bytes.
    */
    QByteArray dataAt(qint64 pos, qint64 count=-1);

    /*! Gives back the data into a \param iODevice starting at position \param pos
    and delivering \param count bytes.
    */
    bool write(QIODevice &iODevice, qint64 pos=0, qint64 count=-1);


    // Char handling

    /*! Inserts a char.
    \param pos Index position, where to insert
    \param ch Char, which is to insert
    The char will be inserted and size of data grows.
    */
    void insert(qint64 pos, char ch);

    /*! Removes len bytes from the content.
    \param pos Index position, where to remove
    \param len Amount of bytes to remove
    */
    void remove(qint64 pos, qint64 len=1);

    /*! Replaces a char.
    \param pos Index position, where to overwrite
    \param ch Char, which is to insert
    The char will be overwritten and size remains constant.
    */
    void replace(qint64 pos, char ch);


    // ByteArray handling

    /*! Inserts a byte array.
    \param pos Index position, where to insert
    \param ba QByteArray, which is to insert
    The QByteArray will be inserted and size of data grows.
    */
    void insert(qint64 pos, const QByteArray &ba);

    /*! Replaces \param len bytes with a byte array \param ba
    \param pos Index position, where to overwrite
    \param ba QByteArray, which is inserted
    \param len count of bytes to overwrite
    The data is overwritten and size of data may change.
    */
    void replace(qint64 pos, qint64 len, const QByteArray &ba);


    // Utility functioins
    /*! Calc cursor position from graphics position
     * \param point from where the cursor position should be calculated
     * \return Cursor postioin
     */
    qint64 cursorPosition(QPoint point);

    /*! Ensure the cursor to be visble
     */
    void ensureVisible();

    /*! Find first occurence of ba in QHexEdit data
     * \param ba Data to find
     * \param from Point where the search starts
     * \return pos if fond, else -1
     */
    qint64 indexOf(const QByteArray &ba, qint64 from);

    /*! Returns if any changes where done on document
     * \return true when document is modified else false
     */
    bool isModified();

    /*! Find last occurence of ba in QHexEdit data
     * \param ba Data to find
     * \param from Point where the search starts
     * \return pos if fond, else -1
     */
    qint64 lastIndexOf(const QByteArray &ba, qint64 from);

    /*! Gives back a formatted image of the selected content of QHexEdit
    */
    QString selectionToReadableString();

    /*! Set Font of QHexEdit
     * \param font
     */
    void setFont(const QFont &font);

    /*! Gives back a formatted image of the content of QHexEdit
    */
    QString toReadableString();


public slots:
    /*! Redoes the last operation. If there is no operation to redo, i.e.
      there is no redo step in the undo/redo history, nothing happens.
      */
    void redo();

    /*! Undoes the last operation. If there is no operation to undo, i.e.
      there is no undo step in the undo/redo history, nothing happens.
      */
    void undo();

signals:

    /*! Contains the address, where the cursor is located. */
    void currentAddressChanged(qint64 address);

    /*! Contains the size of the data to edit. */
    void currentSizeChanged(qint64 size);

    /*! The signal is emitted every time, the data is changed. */
    void dataChanged();

    /*! The signal is emitted every time, the overwrite mode is changed. */
    void overwriteModeChanged(bool state);


/*! \cond docNever */
public:
    ~QHexEdit();

    // Properties
    bool addressArea();
    void setAddressArea(bool addressArea);

    QColor addressAreaColor();
    void setAddressAreaColor(const QColor &color);

    qint64 addressOffset();
    void setAddressOffset(qint64 addressArea);

    int addressWidth();
    void setAddressWidth(int addressWidth);

    bool asciiArea();
    void setAsciiArea(bool asciiArea);

    int bytesPerLine();
    void setBytesPerLine(int count);

    qint64 cursorPosition();
    void setCursorPosition(qint64 position);

    QByteArray data();
    void setData(const QByteArray &ba);

    bool highlighting();
    void setHighlighting(bool mode);

    QColor highlightingColor();
    void setHighlightingColor(const QColor &color);

    bool overwriteMode();
    void setOverwriteMode(bool overwriteMode);

    bool isReadOnly();
    void setReadOnly(bool readOnly);

    bool isUpperCase();
    void setUpperCase(bool upperCase);

    QColor selectionColor();
    void setSelectionColor(const QColor &color);

protected:
    // Handle events
    void keyPressEvent(QKeyEvent *event);
    void mouseMoveEvent(QMouseEvent * event);
    void mousePressEvent(QMouseEvent * event);
    void paintEvent(QPaintEvent *event);
    void resizeEvent(QResizeEvent *);
    virtual bool focusNextPrevChild(bool next);
private:
    // Handle selections
    void resetSelection(qint64 pos);            // set selectionStart and selectionEnd to pos
    void resetSelection();                      // set selectionEnd to selectionStart
    void setSelection(qint64 pos);              // set min (if below init) or max (if greater init)
    int getSelectionBegin();
    int getSelectionEnd();

    // Private utility functions
    void init();
    void readBuffers();
    QString toReadable(const QByteArray &ba);

private slots:
    void adjust();                              // recalc pixel positions
    void dataChangedPrivate(int idx=0);        // emit dataChanged() signal
    void refresh();                             // ensureVisible() and readBuffers()
    void updateCursor();                        // update blinking cursor

private:
    // Name convention: pixel positions start with _px
    int _pxCharWidth, _pxCharHeight;            // char dimensions (dpendend on font)
    int _pxPosHexX;                             // X-Pos of HeaxArea
    int _pxPosAdrX;                             // X-Pos of Address Area
    int _pxPosAsciiX;                           // X-Pos of Ascii Area
    int _pxGapAdr;                              // gap left from AddressArea
    int _pxGapAdrHex;                           // gap between AddressArea and HexAerea
    int _pxGapHexAscii;                         // gap between HexArea and AsciiArea
    int _pxCursorWidth;                         // cursor width
    int _pxSelectionSub;                        // offset selection rect
    int _pxCursorX;                             // current cursor pos
    int _pxCursorY;                             // current cursor pos

    // Name convention: absolute byte positions in chunks start with _b
    qint64 _bSelectionBegin;                    // first position of Selection
    qint64 _bSelectionEnd;                      // end of Selection
    qint64 _bSelectionInit;                     // memory position of Selection
    qint64 _bPosFirst;                          // position of first byte shown
    qint64 _bPosLast;                           // position of last byte shown
    qint64 _bPosCurrent;                        // current position

    // variables to store the property values
    bool _addressArea;                          // left area of QHexEdit
    QColor _addressAreaColor;
    int _addressWidth;
    bool _asciiArea;
    qint64 _addressOffset;
    int _bytesPerLine;
    int _hexCharsInLine;
    bool _highlighting;
    bool _overwriteMode;
    QBrush _brushSelection;
    QPen _penSelection;
    QBrush _brushHighlighted;
    QPen _penHighlighted;
    bool _readOnly;
    bool _upperCase;

    // other variables
    bool _editAreaIsAscii;                      // flag about the ascii mode edited
    int _addrDigits;                            // real no of addressdigits, may be > addressWidth
    bool _blink;                                // help get cursor blinking
    QBuffer _bData;                             // buffer, when setup with QByteArray
    Chunks *_chunks;                            // IODevice based access to data
    QTimer _cursorTimer;                        // for blinking cursor
    qint64 _cursorPosition;                     // absolute position of cursor, 1 Byte == 2 tics
    QRect _cursorRect;                          // physical dimensions of cursor
    QByteArray _data;                           // QHexEdit's data, when setup with QByteArray
    QByteArray _dataShown;                      // data in the current View
    QByteArray _hexDataShown;                   // data in view, transformed to hex
    qint64 _lastEventSize;                      // size, which was emitted last time
    QByteArray _markedShown;                    // marked data in view
    bool _modified;                             // Is any data in editor modified?
    int _rowsShown;                             // lines of text shown
    UndoStack * _undoStack;                     // Stack to store edit actions for undo/redo
    /*! \endcond docNever */
};

#endif // QHEXEDIT_H

```

`efiXloader/3rd/uefitool/UEFITool/searchdialog.cpp`:

```cpp
/* searchdialog.cpp

  Copyright (c) 2014, Nikolaj Schlej. All rights reserved.
  This program and the accompanying materials
  are licensed and made available under the terms and conditions of the BSD License
  which accompanies this distribution.  The full text of the license may be found at
  http://opensource.org/licenses/bsd-license.php

  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

  */

#include "searchdialog.h"

SearchDialog::SearchDialog(QWidget *parent) :
QDialog(parent, Qt::WindowTitleHint | Qt::WindowSystemMenuHint | Qt::WindowCloseButtonHint),
ui(new Ui::SearchDialog),
hexValidator(QRegExp("([0-9a-fA-F\\. ])*")),
guidValidator(QRegExp("[0-9a-fA-F\\.]{8}-[0-9a-fA-F\\.]{4}-[0-9a-fA-F\\.]{4}-[0-9a-fA-F\\.]{4}-[0-9a-fA-F\\.]{12}"))
{
    // Create UI
    ui->setupUi(this);
    ui->hexEdit->setValidator(&hexValidator);
    ui->guidEdit->setValidator(&guidValidator);

    // Connect
    connect(ui->tabWidget, SIGNAL(currentChanged(int)), this, SLOT(setEditFocus(int)));

    // Set initial focus
    setEditFocus(ui->tabWidget->currentIndex());
}

SearchDialog::~SearchDialog()
{
    delete ui;
}

void SearchDialog::setEditFocus(int index)
{
    if (index == 0) // Hex pattern
        ui->hexEdit->setFocus();
    else if (index == 1) { // GUID
        ui->guidEdit->setFocus();
        ui->guidEdit->setCursorPosition(0);
    }
    else if (index == 2) // Text
        ui->textEdit->setFocus();
}
```

`efiXloader/3rd/uefitool/UEFITool/searchdialog.h`:

```h
/* searchdialog.h

  Copyright (c) 2014, Nikolaj Schlej. All rights reserved.
  This program and the accompanying materials
  are licensed and made available under the terms and conditions of the BSD License
  which accompanies this distribution.  The full text of the license may be found at
  http://opensource.org/licenses/bsd-license.php

  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

  */

#ifndef SEARCHDIALOG_H
#define SEARCHDIALOG_H

#include <QDialog>
#include <QRegExpValidator>
#include "ui_searchdialog.h"

class SearchDialog : public QDialog
{
    Q_OBJECT

public:
    SearchDialog(QWidget *parent = 0);
    ~SearchDialog();
    Ui::SearchDialog* ui;

private slots:
    void setEditFocus(int index);

private:
    QRegExpValidator hexValidator;
    QRegExpValidator guidValidator;
};

#endif // SEARCHDIALOG_H

```

`efiXloader/3rd/uefitool/UEFITool/searchdialog.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>SearchDialog</class>
 <widget class="QDialog" name="SearchDialog">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>400</width>
    <height>218</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Search</string>
  </property>
  <property name="modal">
   <bool>false</bool>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <widget class="QTabWidget" name="tabWidget">
     <property name="currentIndex">
      <number>0</number>
     </property>
     <widget class="QWidget" name="hexTab">
      <attribute name="title">
       <string>Hex pattern</string>
      </attribute>
      <layout class="QGridLayout" name="gridLayout_2">
       <item row="0" column="0">
        <widget class="QLabel" name="hexLabel">
         <property name="text">
          <string>Hex pattern:</string>
         </property>
        </widget>
       </item>
       <item row="0" column="1">
        <widget class="QLineEdit" name="hexEdit">
         <property name="inputMask">
          <string/>
         </property>
        </widget>
       </item>
       <item row="1" column="0" colspan="2">
        <widget class="QGroupBox" name="hexGroupBox">
         <property name="title">
          <string>Search scope</string>
         </property>
         <layout class="QVBoxLayout" name="verticalLayout_3">
          <item>
           <widget class="QRadioButton" name="hexScopeFullRadioButton">
            <property name="text">
             <string>Header and body</string>
            </property>
            <property name="checked">
             <bool>true</bool>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QRadioButton" name="hexScopeHeaderRadioButton">
            <property name="text">
             <string>Header only</string>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QRadioButton" name="hexScopeBodyRadioButton">
            <property name="text">
             <string>Body only</string>
            </property>
           </widget>
          </item>
         </layout>
        </widget>
       </item>
      </layout>
     </widget>
     <widget class="QWidget" name="guidTab">
      <attribute name="title">
       <string>GUID</string>
      </attribute>
      <layout class="QGridLayout" name="gridLayout">
       <item row="0" column="0">
        <widget class="QLabel" name="guidLabel">
         <property name="text">
          <string>GUID:</string>
         </property>
        </widget>
       </item>
       <item row="0" column="1">
        <widget class="GuidLineEdit" name="guidEdit">
         <property name="inputMask">
          <string>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</string>
         </property>
         <property name="text">
          <string>........-....-....-....-............</string>
         </property>
        </widget>
       </item>
       <item row="1" column="0" colspan="2">
        <widget class="QGroupBox" name="guidGroupBox">
         <property name="title">
          <string>Search scope</string>
         </property>
         <layout class="QVBoxLayout" name="verticalLayout_5">
          <item>
           <widget class="QRadioButton" name="guidScopeFullRadioButton">
            <property name="text">
             <string>Header and body</string>
            </property>
            <property name="checked">
             <bool>false</bool>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QRadioButton" name="guidScopeHeaderRadioButton">
            <property name="text">
             <string>Header only</string>
            </property>
            <property name="checked">
             <bool>true</bool>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QRadioButton" name="guidScopeBodyRadioButton">
            <property name="text">
             <string>Body only</string>
            </property>
           </widget>
          </item>
         </layout>
        </widget>
       </item>
      </layout>
     </widget>
     <widget class="QWidget" name="textTab">
      <attribute name="title">
       <string>Text</string>
      </attribute>
      <layout class="QGridLayout" name="gridLayout_3">
       <item row="0" column="0">
        <widget class="QLabel" name="textLabel">
         <property name="sizePolicy">
          <sizepolicy hsizetype="Fixed" vsizetype="Preferred">
           <horstretch>0</horstretch>
           <verstretch>0</verstretch>
          </sizepolicy>
         </property>
         <property name="text">
          <string>Text:</string>
         </property>
        </widget>
       </item>
       <item row="0" column="1" colspan="2">
        <widget class="QLineEdit" name="textEdit">
         <property name="sizePolicy">
          <sizepolicy hsizetype="Expanding" vsizetype="Fixed">
           <horstretch>0</horstretch>
           <verstretch>0</verstretch>
          </sizepolicy>
         </property>
        </widget>
       </item>
       <item row="1" column="0" colspan="2">
        <widget class="QGroupBox" name="hexGroupBox_2">
         <property name="title">
          <string>Search scope</string>
         </property>
         <layout class="QVBoxLayout" name="verticalLayout_4">
          <item>
           <widget class="QRadioButton" name="textScopeFullRadioButton">
            <property name="text">
             <string>Header and body</string>
            </property>
            <property name="checked">
             <bool>true</bool>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QRadioButton" name="textScopeHeaderRadioButton">
            <property name="text">
             <string>Header only</string>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QRadioButton" name="textScopeBodyRadioButton">
            <property name="text">
             <string>Body only</string>
            </property>
           </widget>
          </item>
         </layout>
        </widget>
       </item>
       <item row="1" column="2">
        <widget class="QGroupBox" name="textGroupBox">
         <property name="title">
          <string>Text search options</string>
         </property>
         <layout class="QVBoxLayout" name="verticalLayout_2">
          <item>
           <widget class="QCheckBox" name="textUnicodeCheckBox">
            <property name="text">
             <string>Unicode</string>
            </property>
            <property name="checked">
             <bool>true</bool>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QCheckBox" name="textCaseSensitiveCheckBox">
            <property name="text">
             <string>Case sensitive</string>
            </property>
           </widget>
          </item>
         </layout>
        </widget>
       </item>
      </layout>
     </widget>
    </widget>
   </item>
   <item>
    <widget class="QDialogButtonBox" name="buttonBox">
     <property name="orientation">
      <enum>Qt::Horizontal</enum>
     </property>
     <property name="standardButtons">
      <set>QDialogButtonBox::Cancel|QDialogButtonBox::Ok</set>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <customwidgets>
  <customwidget>
   <class>GuidLineEdit</class>
   <extends>QLineEdit</extends>
   <header>guidlineedit.h</header>
  </customwidget>
 </customwidgets>
 <tabstops>
  <tabstop>tabWidget</tabstop>
  <tabstop>hexEdit</tabstop>
  <tabstop>hexScopeFullRadioButton</tabstop>
  <tabstop>hexScopeHeaderRadioButton</tabstop>
  <tabstop>hexScopeBodyRadioButton</tabstop>
  <tabstop>buttonBox</tabstop>
  <tabstop>textEdit</tabstop>
  <tabstop>textUnicodeCheckBox</tabstop>
  <tabstop>textCaseSensitiveCheckBox</tabstop>
 </tabstops>
 <resources/>
 <connections>
  <connection>
   <sender>buttonBox</sender>
   <signal>accepted()</signal>
   <receiver>SearchDialog</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>182</x>
     <y>185</y>
    </hint>
    <hint type="destinationlabel">
     <x>157</x>
     <y>194</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>buttonBox</sender>
   <signal>rejected()</signal>
   <receiver>SearchDialog</receiver>
   <slot>reject()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>182</x>
     <y>185</y>
    </hint>
    <hint type="destinationlabel">
     <x>286</x>
     <y>194</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`efiXloader/3rd/uefitool/UEFITool/uefitool.cpp`:

```cpp
/* uefitool.cpp

  Copyright (c) 2016, Nikolaj Schlej. All rights reserved.
  This program and the accompanying materials
  are licensed and made available under the terms and conditions of the BSD License
  which accompanies this distribution.  The full text of the license may be found at
  http://opensource.org/licenses/bsd-license.php

  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

  */

#include "../version.h"
#include "uefitool.h"
#include "ui_uefitool.h"

UEFITool::UEFITool(QWidget *parent) :
QMainWindow(parent),
ui(new Ui::UEFITool),
version(tr(PROGRAM_VERSION)),
markingEnabled(true)
{
    clipboard = QApplication::clipboard();

    // Create UI
    ui->setupUi(this);
    searchDialog = new SearchDialog(this);
    hexViewDialog = new HexViewDialog(this);
    goToAddressDialog = new GoToAddressDialog(this);
    goToBaseDialog = new GoToBaseDialog(this);
    model = NULL;
    ffsParser = NULL;
    ffsFinder = NULL;
    ffsOps = NULL;
    ffsBuilder = NULL;
    ffsReport = NULL;

    // Connect signals to slots
    connect(ui->actionOpenImageFile, SIGNAL(triggered()), this, SLOT(openImageFile()));
    connect(ui->actionOpenImageFileInNewWindow, SIGNAL(triggered()), this, SLOT(openImageFileInNewWindow()));
    connect(ui->actionSaveImageFile, SIGNAL(triggered()), this, SLOT(saveImageFile()));
    connect(ui->actionSearch, SIGNAL(triggered()), this, SLOT(search()));
    connect(ui->actionHexView, SIGNAL(triggered()), this, SLOT(hexView()));
    connect(ui->actionBodyHexView, SIGNAL(triggered()), this, SLOT(bodyHexView()));
    connect(ui->actionExtract, SIGNAL(triggered()), this, SLOT(extractAsIs()));
    connect(ui->actionExtractBody, SIGNAL(triggered()), this, SLOT(extractBody()));
    connect(ui->actionExtractBodyUncompressed, SIGNAL(triggered()), this, SLOT(extractBodyUncompressed()));
    connect(ui->actionInsertInto, SIGNAL(triggered()), this, SLOT(insertInto()));
    connect(ui->actionInsertBefore, SIGNAL(triggered()), this, SLOT(insertBefore()));
    connect(ui->actionInsertAfter, SIGNAL(triggered()), this, SLOT(insertAfter()));
    connect(ui->actionReplace, SIGNAL(triggered()), this, SLOT(replaceAsIs()));
    connect(ui->actionReplaceBody, SIGNAL(triggered()), this, SLOT(replaceBody()));
    connect(ui->actionRemove, SIGNAL(triggered()), this, SLOT(remove()));
    connect(ui->actionRebuild, SIGNAL(triggered()), this, SLOT(rebuild()));
    connect(ui->actionMessagesCopy, SIGNAL(triggered()), this, SLOT(copyMessage()));
    connect(ui->actionMessagesCopyAll, SIGNAL(triggered()), this, SLOT(copyAllMessages()));
    connect(ui->actionMessagesClear, SIGNAL(triggered()), this, SLOT(clearMessages()));
    connect(ui->actionAbout, SIGNAL(triggered()), this, SLOT(about()));
    connect(ui->actionAboutQt, SIGNAL(triggered()), this, SLOT(aboutQt()));
    connect(ui->actionQuit, SIGNAL(triggered()), this, SLOT(exit()));
    connect(ui->actionGoToData, SIGNAL(triggered()), this, SLOT(goToData()));
    connect(ui->actionGoToBase, SIGNAL(triggered()), this, SLOT(goToBase()));
    connect(ui->actionGoToAddress, SIGNAL(triggered()), this, SLOT(goToAddress()));
    connect(ui->actionLoadGuidDatabase, SIGNAL(triggered()), this, SLOT(loadGuidDatabase()));
    connect(ui->actionUnloadGuidDatabase, SIGNAL(triggered()), this, SLOT(unloadGuidDatabase()));
    connect(ui->actionLoadDefaultGuidDatabase, SIGNAL(triggered()), this, SLOT(loadDefaultGuidDatabase()));
    connect(ui->actionExportDiscoveredGuids, SIGNAL(triggered()), this, SLOT(exportDiscoveredGuids()));
    connect(ui->actionGenerateReport, SIGNAL(triggered()), this, SLOT(generateReport()));
    connect(ui->actionToggleBootGuardMarking, SIGNAL(toggled(bool)), this, SLOT(toggleBootGuardMarking(bool)));
    connect(QCoreApplication::instance(), SIGNAL(aboutToQuit()), this, SLOT(writeSettings()));

    // Enable Drag-and-Drop actions
    setAcceptDrops(true);

    // Disable Builder tab, doesn't work right now
    ui->messagesTabWidget->setTabEnabled(TAB_BUILDER, false);

    // Set current directory
    currentDir = ".";

    // Load built-in GUID database
    initGuidDatabase(":/guids.csv");

    // Initialize non-persistent data
    init();

    // Read stored settings
    readSettings();
}

UEFITool::~UEFITool()
{
    delete ffsBuilder;
    delete ffsOps;
    delete ffsFinder;
    delete ffsParser;
    delete ffsReport;
    delete model;
    delete hexViewDialog;
    delete searchDialog;
    delete ui;
}

void UEFITool::init()
{
    // Clear components
    ui->parserMessagesListWidget->clear();
    ui->finderMessagesListWidget->clear();
    ui->fitTableWidget->clear();
    ui->fitTableWidget->setRowCount(0);
    ui->fitTableWidget->setColumnCount(0);
    ui->infoEdit->clear();
    ui->securityEdit->clear();
    ui->messagesTabWidget->setTabEnabled(TAB_FIT, false);
    ui->messagesTabWidget->setTabEnabled(TAB_SECURITY, false);
    ui->messagesTabWidget->setTabEnabled(TAB_SEARCH, false);
    ui->messagesTabWidget->setTabEnabled(TAB_BUILDER, false);

    // Set window title
    setWindowTitle(tr("UEFITool %1").arg(version));

    // Disable menus
    ui->actionSearch->setEnabled(false);
    ui->actionGoToBase->setEnabled(false);
    ui->actionGoToAddress->setEnabled(false);
    ui->menuCapsuleActions->setEnabled(false);
    ui->menuImageActions->setEnabled(false);
    ui->menuRegionActions->setEnabled(false);
    ui->menuPaddingActions->setEnabled(false);
    ui->menuVolumeActions->setEnabled(false);
    ui->menuFileActions->setEnabled(false);
    ui->menuSectionActions->setEnabled(false);
    ui->menuStoreActions->setEnabled(false);
    ui->menuEntryActions->setEnabled(false);
    ui->menuMessageActions->setEnabled(false);

    // Create new model ...
    delete model;
    model = new TreeModel();
    ui->structureTreeView->setModel(model);
    // ... and ffsParser
    delete ffsParser;
    ffsParser = new FfsParser(model);

    // Set proper marking state
    model->setMarkingEnabled(markingEnabled);
    ui->actionToggleBootGuardMarking->setChecked(markingEnabled);

    // Connect
    connect(ui->structureTreeView->selectionModel(), SIGNAL(currentChanged(const QModelIndex &, const QModelIndex &)),
        this, SLOT(populateUi(const QModelIndex &)));
    connect(ui->structureTreeView->selectionModel(), SIGNAL(selectionChanged(const QItemSelection &, const QItemSelection &)),
        this, SLOT(populateUi(const QItemSelection &)));
    connect(ui->parserMessagesListWidget,  SIGNAL(itemDoubleClicked(QListWidgetItem*)), this, SLOT(scrollTreeView(QListWidgetItem*)));
    connect(ui->parserMessagesListWidget,  SIGNAL(itemEntered(QListWidgetItem*)),       this, SLOT(enableMessagesCopyActions(QListWidgetItem*)));
    connect(ui->finderMessagesListWidget,  SIGNAL(itemDoubleClicked(QListWidgetItem*)), this, SLOT(scrollTreeView(QListWidgetItem*)));
    connect(ui->finderMessagesListWidget,  SIGNAL(itemEntered(QListWidgetItem*)),       this, SLOT(enableMessagesCopyActions(QListWidgetItem*)));
    connect(ui->builderMessagesListWidget, SIGNAL(itemDoubleClicked(QListWidgetItem*)), this, SLOT(scrollTreeView(QListWidgetItem*)));
    connect(ui->builderMessagesListWidget, SIGNAL(itemEntered(QListWidgetItem*)),       this, SLOT(enableMessagesCopyActions(QListWidgetItem*)));
    connect(ui->fitTableWidget, SIGNAL(itemDoubleClicked(QTableWidgetItem*)), this, SLOT(scrollTreeView(QTableWidgetItem*)));
    connect(ui->messagesTabWidget, SIGNAL(currentChanged(int)), this, SLOT(currentTabChanged(int)));

    // allow enter/return pressing to scroll tree view
    ui->parserMessagesListWidget->installEventFilter(this);
    ui->finderMessagesListWidget->installEventFilter(this);
    ui->builderMessagesListWidget->installEventFilter(this);
}

void UEFITool::populateUi(const QItemSelection &selected)
{
    if (selected.isEmpty()) {
        return;
    }

    populateUi(selected.indexes().at(0));
}

void UEFITool::populateUi(const QModelIndex &current)
{
    // Check sanity
    if (!current.isValid()) {
        return;
    }

    UINT8 type = model->type(current);
    UINT8 subtype = model->subtype(current);

    // Set info text
    ui->infoEdit->setPlainText(model->info(current));

    // Enable menus
    ui->menuCapsuleActions->setEnabled(type == Types::Capsule);
    ui->menuImageActions->setEnabled(type == Types::Image);
    ui->menuRegionActions->setEnabled(type == Types::Region);
    ui->menuPaddingActions->setEnabled(type == Types::Padding);
    ui->menuVolumeActions->setEnabled(type == Types::Volume);
    ui->menuFileActions->setEnabled(type == Types::File);
    ui->menuSectionActions->setEnabled(type == Types::Section);
    ui->menuEntryActions->setEnabled(type == Types::Microcode
        || type == Types::SlicData
        || type == Types::NvarEntry
        || type == Types::VssEntry
        || type == Types::FsysEntry
        || type == Types::EvsaEntry
        || type == Types::FlashMapEntry
        || type == Types::IfwiHeader
        || type == Types::IfwiPartition
        || type == Types::FptPartition
        || type == Types::FptEntry
        || type == Types::BpdtPartition
        || type == Types::BpdtEntry
        || type == Types::CpdPartition
        || type == Types::CpdEntry
        || type == Types::CpdExtension
        || type == Types::CpdSpiEntry
        );
    ui->menuStoreActions->setEnabled(type == Types::VssStore
        || type == Types::Vss2Store
        || type == Types::FdcStore
        || type == Types::FsysStore
        || type == Types::EvsaStore
        || type == Types::FtwStore
        || type == Types::FlashMapStore
        || type == Types::CmdbStore
        || type == Types::FptStore
        || type == Types::BpdtStore
        || type == Types::CpdStore
        );

    // Enable actions
    ui->actionHexView->setDisabled(model->hasEmptyHeader(current) && model->hasEmptyBody(current) && model->hasEmptyTail(current));
    ui->actionBodyHexView->setDisabled(model->hasEmptyBody(current));
    ui->actionExtract->setDisabled(model->hasEmptyHeader(current) && model->hasEmptyBody(current) && model->hasEmptyTail(current));
    ui->actionGoToData->setEnabled(type == Types::NvarEntry && subtype == Subtypes::LinkNvarEntry);

    // Disable rebuild for now
    //ui->actionRebuild->setDisabled(type == Types::Region && subtype == Subtypes::DescriptorRegion);
    //ui->actionReplace->setDisabled(type == Types::Region && subtype == Subtypes::DescriptorRegion);

    //ui->actionRebuild->setEnabled(type == Types::Volume || type == Types::File || type == Types::Section);
    ui->actionExtractBody->setDisabled(model->hasEmptyBody(current));
    ui->actionExtractBodyUncompressed->setEnabled(enableExtractBodyUncompressed(current));
    //ui->actionRemove->setEnabled(type == Types::Volume || type == Types::File || type == Types::Section);
    //ui->actionInsertInto->setEnabled((type == Types::Volume && subtype != Subtypes::UnknownVolume) ||
    //    (type == Types::File && subtype != EFI_FV_FILETYPE_ALL && subtype != EFI_FV_FILETYPE_RAW && subtype != EFI_FV_FILETYPE_PAD) ||
    //    (type == Types::Section && (subtype == EFI_SECTION_COMPRESSION || subtype == EFI_SECTION_GUID_DEFINED || subtype == EFI_SECTION_DISPOSABLE)));
    //ui->actionInsertBefore->setEnabled(type == Types::File || type == Types::Section);
    //ui->actionInsertAfter->setEnabled(type == Types::File || type == Types::Section);
    //ui->actionReplace->setEnabled((type == Types::Region && subtype != Subtypes::DescriptorRegion) || type == Types::Volume || type == Types::File || type == Types::Section);
    //ui->actionReplaceBody->setEnabled(type == Types::Volume || type == Types::File || type == Types::Section);

    ui->menuMessageActions->setEnabled(false);
}

bool UEFITool::enableExtractBodyUncompressed(const QModelIndex &current)
{
    // TODO: rewrite based on model->compressed()
    U_UNUSED_PARAMETER(current);
    return false;
}

void UEFITool::search()
{
    if (searchDialog->exec() != QDialog::Accepted)
        return;

    QModelIndex rootIndex = model->index(0, 0);

    int index = searchDialog->ui->tabWidget->currentIndex();
    if (index == 0) { // Hex pattern
        searchDialog->ui->hexEdit->setFocus();
        QByteArray pattern = searchDialog->ui->hexEdit->text().toLatin1().replace(" ", "");
        if (pattern.isEmpty())
            return;
        UINT8 mode;
        if (searchDialog->ui->hexScopeHeaderRadioButton->isChecked())
            mode = SEARCH_MODE_HEADER;
        else if (searchDialog->ui->hexScopeBodyRadioButton->isChecked())
            mode = SEARCH_MODE_BODY;
        else
            mode = SEARCH_MODE_ALL;
        ffsFinder->findHexPattern(rootIndex, pattern, mode);
        showFinderMessages();
    }
    else if (index == 1) { // GUID
        searchDialog->ui->guidEdit->setFocus();
        searchDialog->ui->guidEdit->setCursorPosition(0);
        QByteArray pattern = searchDialog->ui->guidEdit->text().toLatin1();
        if (pattern.isEmpty())
            return;
        UINT8 mode;
        if (searchDialog->ui->guidScopeHeaderRadioButton->isChecked())
            mode = SEARCH_MODE_HEADER;
        else if (searchDialog->ui->guidScopeBodyRadioButton->isChecked())
            mode = SEARCH_MODE_BODY;
        else
            mode = SEARCH_MODE_ALL;
        ffsFinder->findGuidPattern(rootIndex, pattern, mode);
        showFinderMessages();
    }
    else if (index == 2) { // Text string
        searchDialog->ui->textEdit->setFocus();
        QString pattern = searchDialog->ui->textEdit->text();
        if (pattern.isEmpty())
            return;
        UINT8 mode;
        if (searchDialog->ui->textScopeHeaderRadioButton->isChecked())
            mode = SEARCH_MODE_HEADER;
        else if (searchDialog->ui->textScopeBodyRadioButton->isChecked())
            mode = SEARCH_MODE_BODY;
        else
            mode = SEARCH_MODE_ALL;
        ffsFinder->findTextPattern(rootIndex, pattern, mode, searchDialog->ui->textUnicodeCheckBox->isChecked(),
            (Qt::CaseSensitivity) searchDialog->ui->textCaseSensitiveCheckBox->isChecked());
        showFinderMessages();
    }
}

void UEFITool::hexView()
{
    QModelIndex index = ui->structureTreeView->selectionModel()->currentIndex();
    if (!index.isValid())
        return;

    hexViewDialog->setItem(index, false);
    hexViewDialog->exec();
}

void UEFITool::bodyHexView()
{
    QModelIndex index = ui->structureTreeView->selectionModel()->currentIndex();
    if (!index.isValid())
        return;

    hexViewDialog->setItem(index, true);
    hexViewDialog->exec();
}

void UEFITool::goToBase()
{
    goToBaseDialog->ui->hexSpinBox->setFocus();
    goToBaseDialog->ui->hexSpinBox->selectAll();
    if (goToBaseDialog->exec() != QDialog::Accepted)
        return;

    UINT32 offset = (UINT32)goToBaseDialog->ui->hexSpinBox->value();
    QModelIndex index = model->findByBase(offset);
    if (index.isValid()) {
        ui->structureTreeView->scrollTo(index, QAbstractItemView::PositionAtCenter);
        ui->structureTreeView->selectionModel()->select(index, QItemSelectionModel::Select | QItemSelectionModel::Rows | QItemSelectionModel::Clear);
    }
}

void UEFITool::goToAddress()
{
    goToAddressDialog->ui->hexSpinBox->setFocus();
    goToAddressDialog->ui->hexSpinBox->selectAll();
    if (goToAddressDialog->exec() != QDialog::Accepted)
        return;

    UINT32 address = (UINT32)goToAddressDialog->ui->hexSpinBox->value();
    QModelIndex index = model->findByBase(address - (UINT32)ffsParser->getAddressDiff());
    if (index.isValid()) {
        ui->structureTreeView->scrollTo(index, QAbstractItemView::PositionAtCenter);
        ui->structureTreeView->selectionModel()->select(index, QItemSelectionModel::Select | QItemSelectionModel::Rows | QItemSelectionModel::Clear);
    }
}

void UEFITool::goToData()
{
    QModelIndex index = ui->structureTreeView->selectionModel()->currentIndex();
    if (!index.isValid() || model->type(index) != Types::NvarEntry || model->subtype(index) != Subtypes::LinkNvarEntry)
        return;

    // Get parent
    QModelIndex parent = model->parent(index);

    for (int i = index.row(); i < model->rowCount(parent); i++) {
        if (model->hasEmptyParsingData(index))
            continue;

        UByteArray rdata = model->parsingData(index);
        const NVAR_ENTRY_PARSING_DATA* pdata = (const NVAR_ENTRY_PARSING_DATA*)rdata.constData();
        UINT32 lastVariableFlag = pdata->emptyByte ? 0xFFFFFF : 0;
        UINT32 offset = model->offset(index);
        if (pdata->next == lastVariableFlag) {
            ui->structureTreeView->scrollTo(index, QAbstractItemView::PositionAtCenter);
            ui->structureTreeView->selectionModel()->select(index, QItemSelectionModel::Select | QItemSelectionModel::Rows | QItemSelectionModel::Clear);
        }

        for (int j = i + 1; j < model->rowCount(parent); j++) {
            QModelIndex currentIndex = parent.child(j, 0);
            if (model->hasEmptyParsingData(currentIndex))
                continue;

            if (model->offset(currentIndex) == offset + pdata->next) {
                index = currentIndex;
                break;
            }
        }
    }
}

void UEFITool::insert(const UINT8 mode)
{
    U_UNUSED_PARAMETER(mode);
}

void UEFITool::insertInto()
{
    insert(CREATE_MODE_PREPEND);
}

void UEFITool::insertBefore()
{
    insert(CREATE_MODE_BEFORE);
}

void UEFITool::insertAfter()
{
    insert(CREATE_MODE_AFTER);
}

void UEFITool::replaceAsIs()
{
    replace(REPLACE_MODE_AS_IS);
}

void UEFITool::replaceBody()
{
    replace(REPLACE_MODE_BODY);
}

void UEFITool::replace(const UINT8 mode)
{
    U_UNUSED_PARAMETER(mode);

}

void UEFITool::extractAsIs()
{
    extract(EXTRACT_MODE_AS_IS);
}

void UEFITool::extractBody()
{
    extract(EXTRACT_MODE_BODY);
}

void UEFITool::extractBodyUncompressed()
{
    extract(EXTRACT_MODE_BODY_UNCOMPRESSED);
}

void UEFITool::extract(const UINT8 mode)
{
    QModelIndex index = ui->structureTreeView->selectionModel()->currentIndex();
    if (!index.isValid())
        return;

    QByteArray extracted;
    QString name;
    USTATUS result = ffsOps->extract(index, name, extracted, mode);
    if (result) {
        QMessageBox::critical(this, tr("Extraction failed"), errorCodeToUString(result), QMessageBox::Ok);
        return;
    }

    name = QDir::toNativeSeparators(currentDir + QDir::separator() + name);

    //ui->statusBar->showMessage(name);

    UINT8 type = model->type(index);
    UINT8 subtype = model->subtype(index);
    QString path;
    if (mode == EXTRACT_MODE_AS_IS) {
        switch (type) {
        case Types::Capsule:        path = QFileDialog::getSaveFileName(this, tr("Save capsule to file"),          name + ".cap",  tr("Capsule files (*.cap *.bin);;All files (*)"));          break;
        case Types::Image:          path = QFileDialog::getSaveFileName(this, tr("Save image to file"),            name + ".rom",  tr("Image files (*.rom *.bin);;All files (*)"));            break;
        case Types::Region:         path = QFileDialog::getSaveFileName(this, tr("Save region to file"),           name + ".rgn",  tr("Region files (*.rgn *.bin);;All files (*)"));           break;
        case Types::Padding:        path = QFileDialog::getSaveFileName(this, tr("Save padding to file"),          name + ".pad",  tr("Padding files (*.pad *.bin);;All files (*)"));          break;
        case Types::Volume:         path = QFileDialog::getSaveFileName(this, tr("Save volume to file"),           name + ".vol",  tr("Volume files (*.vol *.bin);;All files (*)"));           break;
        case Types::File:           path = QFileDialog::getSaveFileName(this, tr("Save FFS file to file"),         name + ".ffs",  tr("FFS files (*.ffs *.bin);;All files (*)"));              break;
        case Types::Section:        path = QFileDialog::getSaveFileName(this, tr("Save section to file"),          name + ".sct",  tr("Section files (*.sct *.bin);;All files (*)"));          break;
        case Types::NvarEntry:      path = QFileDialog::getSaveFileName(this, tr("Save NVAR entry to file"),       name + ".nvar", tr("NVAR entry files (*.nvar *.bin);;All files (*)"));      break;
        case Types::VssEntry:       path = QFileDialog::getSaveFileName(this, tr("Save VSS entry to file"),        name + ".vss",  tr("VSS entry files (*.vss *.bin);;All files (*)"));        break;
        case Types::FsysEntry:      path = QFileDialog::getSaveFileName(this, tr("Save Fsys entry to file"),       name + ".fse",  tr("Fsys entry files (*.fse *.bin);;All files (*)"));       break;
        case Types::EvsaEntry:      path = QFileDialog::getSaveFileName(this, tr("Save EVSA entry to file"),       name + ".evse", tr("EVSA entry files (*.evse *.bin);;All files (*)"));      break;
        case Types::FlashMapEntry:  path = QFileDialog::getSaveFileName(this, tr("Save FlashMap entry to file"),   name + ".fme",  tr("FlashMap entry files (*.fme *.bin);;All files (*)"));   break;
        case Types::VssStore:       path = QFileDialog::getSaveFileName(this, tr("Save VSS store to file"),        name + ".vss",  tr("VSS store files (*.vss *.bin);;All files (*)"));        break;
        case Types::Vss2Store:      path = QFileDialog::getSaveFileName(this, tr("Save VSS2 store to file"),       name + ".vss2", tr("VSS2 store files (*.vss2 *.bin);;All files (*)"));      break;
        case Types::FdcStore:       path = QFileDialog::getSaveFileName(this, tr("Save FDC store to file"),        name + ".fdc",  tr("FDC store files (*.fdc *.bin);;All files (*)"));        break;
        case Types::FsysStore:      path = QFileDialog::getSaveFileName(this, tr("Save Fsys store to file"),       name + ".fsys", tr("Fsys store files (*.fsys *.bin);;All files (*)"));      break;
        case Types::EvsaStore:      path = QFileDialog::getSaveFileName(this, tr("Save EVSA store to file"),       name + ".evsa", tr("EVSA store files (*.evsa *.bin);;All files (*)"));      break;
        case Types::FtwStore:       path = QFileDialog::getSaveFileName(this, tr("Save FTW store to file"),        name + ".ftw",  tr("FTW store files (*.ftw *.bin);;All files (*)"));        break;
        case Types::FlashMapStore:  path = QFileDialog::getSaveFileName(this, tr("Save FlashMap store to file"),   name + ".fmap", tr("FlashMap store files (*.fmap *.bin);;All files (*)"));  break;
        case Types::CmdbStore:      path = QFileDialog::getSaveFileName(this, tr("Save CMDB store to file"),       name + ".cmdb", tr("CMDB store files (*.cmdb *.bin);;All files (*)"));      break;
        case Types::Microcode:      path = QFileDialog::getSaveFileName(this, tr("Save microcode binary to file"), name + ".ucd",  tr("Microcode binary files (*.ucd *.bin);;All files (*)")); break;
        case Types::SlicData:
            if (subtype == Subtypes::PubkeySlicData) path = QFileDialog::getSaveFileName(this, tr("Save SLIC pubkey to file"), name + ".spk", tr("SLIC pubkey files (*.spk *.bin);;All files (*)"));
            else                                     path = QFileDialog::getSaveFileName(this, tr("Save SLIC marker to file"), name + ".smk", tr("SLIC marker files (*.smk *.bin);;All files (*)"));
            break;
        default:                    path = QFileDialog::getSaveFileName(this, tr("Save object to file"), name + ".bin", tr("Binary files (*.bin);;All files (*)"));
        }
    }
    else if (mode == EXTRACT_MODE_BODY || mode == EXTRACT_MODE_BODY_UNCOMPRESSED) {
        switch (type) {
        case Types::Capsule:                         path = QFileDialog::getSaveFileName(this, tr("Save capsule body to image file"), name + ".rom", tr("Image files (*.rom *.bin);;All files (*)"));       break;
        case Types::Volume:                          path = QFileDialog::getSaveFileName(this, tr("Save volume body to file"),        name + ".vbd", tr("Volume body files (*.vbd *.bin);;All files (*)")); break;
        case Types::File:
            if (subtype    == EFI_FV_FILETYPE_ALL
                || subtype == EFI_FV_FILETYPE_RAW)   path = QFileDialog::getSaveFileName(this, tr("Save FFS file body to raw file"),  name + ".raw", tr("Raw files (*.raw *.bin);;All files (*)"));
            else                                     path = QFileDialog::getSaveFileName(this, tr("Save FFS file body to file"),      name + ".fbd", tr("FFS file body files (*.fbd *.bin);;All files (*)"));
            break;
        case Types::Section:
            if (subtype    == EFI_SECTION_COMPRESSION
                || subtype == EFI_SECTION_GUID_DEFINED
                || subtype == EFI_SECTION_DISPOSABLE)              path = QFileDialog::getSaveFileName(this, tr("Save encapsulation section body to FFS body file"), name + ".fbd", tr("FFS file body files (*.fbd *.bin);;All files (*)"));
            else if (subtype == EFI_SECTION_FIRMWARE_VOLUME_IMAGE) path = QFileDialog::getSaveFileName(this, tr("Save section body to volume file"),                 name + ".vol", tr("Volume files (*.vol *.bin);;All files (*)"));
            else if (subtype == EFI_SECTION_RAW)                   path = QFileDialog::getSaveFileName(this, tr("Save section body to raw file"),                    name + ".raw", tr("Raw files (*.raw *.bin);;All files (*)"));
            else if (subtype == EFI_SECTION_PE32
                || subtype == EFI_SECTION_TE
                || subtype == EFI_SECTION_PIC)                     path = QFileDialog::getSaveFileName(this, tr("Save section body to EFI executable file"),         name + ".efi", tr("EFI executable files (*.efi *.bin);;All files (*)"));
            else                                                   path = QFileDialog::getSaveFileName(this, tr("Save section body to file"),                        name + ".bin", tr("Binary files (*.bin);;All files (*)"));
           break;
        case Types::NvarEntry:
        case Types::VssEntry:
        case Types::EvsaEntry:
        case Types::FlashMapEntry:
        case Types::FsysEntry:                       path = QFileDialog::getSaveFileName(this, tr("Save entry body to file"),       name + ".bin", tr("Binary files (*.bin);;All files (*)")); break;
        case Types::VssStore:
        case Types::Vss2Store:
        case Types::FtwStore:
        case Types::FdcStore:
        case Types::FsysStore:
        case Types::FlashMapStore:
        case Types::CmdbStore:                       path = QFileDialog::getSaveFileName(this, tr("Save store body to file"),       name + ".bin", tr("Binary files (*.bin);;All files (*)")); break;
        case Types::Microcode:                       path = QFileDialog::getSaveFileName(this, tr("Save microcode body to file"),   name + ".ucb", tr("Microcode body files (*.ucb *.bin);;All files (*)")); break;
        case Types::SlicData:
            if (subtype == Subtypes::PubkeySlicData) path = QFileDialog::getSaveFileName(this, tr("Save SLIC pubkey body to file"), name + ".spb", tr("SLIC pubkey body files (*.spb *.bin);;All files (*)"));
            else                                     path = QFileDialog::getSaveFileName(this, tr("Save SLIC marker body to file"), name + ".smb", tr("SLIC marker body files (*.smb *.bin);;All files (*)"));
            break;
        default:                                     path = QFileDialog::getSaveFileName(this, tr("Save object to file"),           name + ".bin", tr("Binary files (*.bin);;All files (*)"));
        }
    }
    else                                             path = QFileDialog::getSaveFileName(this, tr("Save object to file"),           name + ".bin", tr("Binary files (*.bin);;All files (*)"));

    if (path.trimmed().isEmpty())
        return;

    QFile outputFile;
    outputFile.setFileName(path);
    if (!outputFile.open(QFile::WriteOnly)) {
        QMessageBox::critical(this, tr("Extraction failed"), tr("Can't open output file for rewriting"), QMessageBox::Ok);
        return;
    }
    outputFile.resize(0);
    outputFile.write(extracted);
    outputFile.close();
}

void UEFITool::rebuild()
{

}

void UEFITool::remove()
{

}

void UEFITool::about()
{
    QMessageBox::about(this, tr("About UEFITool"), tr(
        "Copyright (c) 2019, Nikolaj Schlej.<br>"
        "Program icon made by <a href=https://www.behance.net/alzhidkov>Alexander Zhidkov</a>.<br>"
        "The program uses QHexEdit2 library made by <a href=https://github.com/Simsys/>Simsys</a>.<br>"
        "Qt-less engine is using Bstrlib made by <a href=https://github.com/websnarf/>Paul Hsieh</a>.<br><br>"
        "The program is dedicated to <b>RevoGirl</b>. Rest in peace, young genius.<br><br>"
        "The program and the accompanying materials are licensed and made available under the terms and conditions of the BSD License.<br>"
        "The full text of the license may be found at <a href=http://opensource.org/licenses/bsd-license.php>OpenSource.org</a>.<br><br>"
        "<b>THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN \"AS IS\" BASIS, "
        "WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, "
        "EITHER EXPRESS OR IMPLIED.</b>"));
}

void UEFITool::aboutQt()
{
    QMessageBox::aboutQt(this, tr("About Qt"));
}

void UEFITool::exit()
{
    QCoreApplication::exit(0);
}

void UEFITool::saveImageFile()
{

}

void UEFITool::openImageFile()
{
    QString path = QFileDialog::getOpenFileName(this, tr("Open BIOS image file"), currentDir, tr("BIOS image files (*.rom *.bin *.cap *scap *.bio *.fd *.wph *.dec);;All files (*)"));
    openImageFile(path);
}

void UEFITool::openImageFileInNewWindow()
{
    QString path = QFileDialog::getOpenFileName(this, tr("Open BIOS image file in new window"), currentDir, tr("BIOS image files (*.rom *.bin *.cap *scap *.bio *.fd *.wph *.dec);;All files (*)"));
    if (path.trimmed().isEmpty())
        return;
    QProcess::startDetached(currentProgramPath, QStringList(path));
}

void UEFITool::openImageFile(QString path)
{
    if (path.trimmed().isEmpty())
        return;

    QFileInfo fileInfo = QFileInfo(path);

    if (!fileInfo.exists()) {
        ui->statusBar->showMessage(tr("Please select existing file"));
        return;
    }

    QFile inputFile;
    inputFile.setFileName(path);

    if (!inputFile.open(QFile::ReadOnly)) {
        QMessageBox::critical(this, tr("Image parsing failed"), tr("Can't open input file for reading"), QMessageBox::Ok);
        return;
    }

    QByteArray buffer = inputFile.readAll();
    inputFile.close();

    init();
    setWindowTitle(tr("UEFITool %1 - %2").arg(version).arg(fileInfo.fileName()));

    // Parse the image
    USTATUS result = ffsParser->parse(buffer);
    showParserMessages();
    if (result) {
        QMessageBox::critical(this, tr("Image parsing failed"), errorCodeToUString(result), QMessageBox::Ok);
        return;
    }
    else
        ui->statusBar->showMessage(tr("Opened: %1").arg(fileInfo.fileName()));

    // Enable or disable FIT tab
    showFitTable();

    // Enable or disable Security tab
    showSecurityInfo();

    // Enable search ...
    delete ffsFinder;
    ffsFinder = new FfsFinder(model);
    ui->actionSearch->setEnabled(true);
    // ... and other operations
    delete ffsOps;
    ffsOps = new FfsOperations(model);
    // ... and reports
    delete ffsReport;
    ffsReport = new FfsReport(model);

    // Enable goToBase and goToAddress
    ui->actionGoToBase->setEnabled(true);
    if (ffsParser->getAddressDiff() <= 0xFFFFFFFFUL)
        ui->actionGoToAddress->setEnabled(true);

    // Enable generateReport
    ui->actionGenerateReport->setEnabled(true);

    // Enable saving GUIDs
    ui->actionExportDiscoveredGuids->setEnabled(true);

    // Set current directory
    currentDir = fileInfo.absolutePath();

    // Set current path
    currentPath = path;
}

void UEFITool::enableMessagesCopyActions(QListWidgetItem* item)
{
    ui->menuMessageActions->setEnabled(item != NULL);
    ui->actionMessagesCopy->setEnabled(item != NULL);
    ui->actionMessagesCopyAll->setEnabled(item != NULL);
    ui->actionMessagesClear->setEnabled(item != NULL);
}

void UEFITool::copyMessage()
{
    clipboard->clear();
    if (ui->messagesTabWidget->currentIndex() == TAB_PARSER) // Parser tab
        clipboard->setText(ui->parserMessagesListWidget->currentItem()->text());
    else if (ui->messagesTabWidget->currentIndex() == TAB_SEARCH) // Search tab
        clipboard->setText(ui->finderMessagesListWidget->currentItem()->text());
    else if (ui->messagesTabWidget->currentIndex() == TAB_BUILDER) // Builder tab
        clipboard->setText(ui->builderMessagesListWidget->currentItem()->text());
}

void UEFITool::copyAllMessages()
{
    QString text;
    clipboard->clear();
    if (ui->messagesTabWidget->currentIndex() == TAB_PARSER) { // Parser tab
        for (INT32 i = 0; i < ui->parserMessagesListWidget->count(); i++)
            text.append(ui->parserMessagesListWidget->item(i)->text()).append("\n");
        clipboard->setText(text);
    }
    else if (ui->messagesTabWidget->currentIndex() == TAB_SEARCH) {  // Search tab
        for (INT32 i = 0; i < ui->finderMessagesListWidget->count(); i++)
            text.append(ui->finderMessagesListWidget->item(i)->text()).append("\n");
        clipboard->setText(text);
    }
    else if (ui->messagesTabWidget->currentIndex() == TAB_BUILDER) {  // Builder tab
        for (INT32 i = 0; i < ui->builderMessagesListWidget->count(); i++)
            text.append(ui->builderMessagesListWidget->item(i)->text()).append("\n");
        clipboard->setText(text);
    }
}

void UEFITool::clearMessages()
{
    if (ui->messagesTabWidget->currentIndex() == TAB_PARSER) { // Parser tab
        if (ffsParser) ffsParser->clearMessages();
        ui->parserMessagesListWidget->clear();
    }
    else if (ui->messagesTabWidget->currentIndex() == TAB_SEARCH) {  // Search tab
        if (ffsFinder) ffsFinder->clearMessages();
        ui->finderMessagesListWidget->clear();
    }
    else if (ui->messagesTabWidget->currentIndex() == TAB_BUILDER) {  // Builder tab
        if (ffsBuilder) ffsBuilder->clearMessages();
        ui->builderMessagesListWidget->clear();
    }

    ui->menuMessageActions->setEnabled(false);
    ui->actionMessagesCopy->setEnabled(false);
    ui->actionMessagesCopyAll->setEnabled(false);
    ui->actionMessagesClear->setEnabled(false);
}

void UEFITool::toggleBootGuardMarking(bool enabled)
{
    model->setMarkingEnabled(enabled);
    markingEnabled = enabled;
}

/* emit double click signal of QListWidget on enter/return key pressed */
bool UEFITool::eventFilter(QObject* obj, QEvent* event)
{
    if (event->type() == QEvent::KeyPress) {
        QKeyEvent* key = static_cast<QKeyEvent*>(event);

        if (key->key() == Qt::Key_Enter || key->key() == Qt::Key_Return) {
            QListWidget* list = qobject_cast<QListWidget*>(obj);

            if (list != NULL && list->currentItem() != NULL)
                emit list->itemDoubleClicked(list->currentItem());
        }
    }

    return QObject::eventFilter(obj, event);
}

void UEFITool::dragEnterEvent(QDragEnterEvent* event)
{
    if (event->mimeData()->hasFormat("text/uri-list"))
        event->acceptProposedAction();
}

void UEFITool::dropEvent(QDropEvent* event)
{
    QString path = event->mimeData()->urls().at(0).toLocalFile();
    openImageFile(path);
}

void UEFITool::showParserMessages()
{
    ui->parserMessagesListWidget->clear();
    if (!ffsParser)
        return;

    std::vector<std::pair<QString, QModelIndex> > messages = ffsParser->getMessages();
    std::pair<QString, QModelIndex> msg;
    foreach (msg, messages) {
        QListWidgetItem* item = new QListWidgetItem(msg.first, NULL, 0);
        item->setData(Qt::UserRole, QByteArray((const char*)&msg.second, sizeof(msg.second)));
        ui->parserMessagesListWidget->addItem(item);
    }

    ui->messagesTabWidget->setCurrentIndex(TAB_PARSER);
    ui->parserMessagesListWidget->scrollToBottom();
}

void UEFITool::showFinderMessages()
{
    ui->finderMessagesListWidget->clear();
    if (!ffsParser)
        return;

    std::vector<std::pair<QString, QModelIndex> > messages = ffsFinder->getMessages();
    std::pair<QString, QModelIndex> msg;
    foreach (msg, messages) {
        QListWidgetItem* item = new QListWidgetItem(msg.first, NULL, 0);
        item->setData(Qt::UserRole, QByteArray((const char*)&msg.second, sizeof(msg.second)));;
        ui->finderMessagesListWidget->addItem(item);
    }

    ui->messagesTabWidget->setTabEnabled(TAB_SEARCH, true);
    ui->messagesTabWidget->setCurrentIndex(TAB_SEARCH);
    ui->finderMessagesListWidget->scrollToBottom();
}

void UEFITool::showBuilderMessages()
{
    ui->builderMessagesListWidget->clear();
    if (!ffsBuilder)
        return;

    std::vector<std::pair<QString, QModelIndex> > messages = ffsBuilder->getMessages();
    std::pair<QString, QModelIndex> msg;
    foreach (msg, messages) {
        QListWidgetItem* item = new QListWidgetItem(msg.first, NULL, 0);
        item->setData(Qt::UserRole, QByteArray((const char*)&msg.second, sizeof(msg.second)));
        ui->builderMessagesListWidget->addItem(item);
    }

    ui->messagesTabWidget->setTabEnabled(TAB_BUILDER, true);
    ui->messagesTabWidget->setCurrentIndex(TAB_BUILDER);
    ui->builderMessagesListWidget->scrollToBottom();
}

void UEFITool::scrollTreeView(QListWidgetItem* item)
{
    QByteArray second = item->data(Qt::UserRole).toByteArray();
    QModelIndex *index = (QModelIndex *)second.data();
    if (index && index->isValid()) {
        ui->structureTreeView->scrollTo(*index, QAbstractItemView::PositionAtCenter);
        ui->structureTreeView->selectionModel()->select(*index, QItemSelectionModel::Select | QItemSelectionModel::Rows | QItemSelectionModel::Clear);
    }
}

void UEFITool::scrollTreeView(QTableWidgetItem* item)
{
    QByteArray second = item->data(Qt::UserRole).toByteArray();
    QModelIndex *index = (QModelIndex *)second.data();
    if (index && index->isValid()) {
        ui->structureTreeView->scrollTo(*index, QAbstractItemView::PositionAtCenter);
        ui->structureTreeView->selectionModel()->select(*index, QItemSelectionModel::Select | QItemSelectionModel::Rows | QItemSelectionModel::Clear);
    }
}

void UEFITool::contextMenuEvent(QContextMenuEvent* event)
{
    // The checks involving underMouse do not work well enough on macOS, and result in right-click sometimes
    // not showing any context menu at all. Most likely it is a bug in Qt, which does not affect other systems.
    // For this reason we reimplement this manually.
    if (ui->parserMessagesListWidget->rect().contains(ui->parserMessagesListWidget->mapFromGlobal(event->globalPos())) ||
        ui->finderMessagesListWidget->rect().contains(ui->finderMessagesListWidget->mapFromGlobal(event->globalPos())) ||
        ui->builderMessagesListWidget->rect().contains(ui->builderMessagesListWidget->mapFromGlobal(event->globalPos()))) {
        ui->menuMessageActions->exec(event->globalPos());
        return;
    }


    if (!ui->structureTreeView->rect().contains(ui->structureTreeView->mapFromGlobal(event->globalPos())))
        return;

    QPoint pt = event->pos();
    QModelIndex index = ui->structureTreeView->indexAt(ui->structureTreeView->viewport()->mapFrom(this, pt));
    if (!index.isValid()) {
        return;
    }

    switch (model->type(index))
    {
    case Types::Capsule:        ui->menuCapsuleActions->exec(event->globalPos());      break;
    case Types::Image:          ui->menuImageActions->exec(event->globalPos());        break;
    case Types::Region:         ui->menuRegionActions->exec(event->globalPos());       break;
    case Types::Padding:        ui->menuPaddingActions->exec(event->globalPos());      break;
    case Types::Volume:         ui->menuVolumeActions->exec(event->globalPos());       break;
    case Types::File:           ui->menuFileActions->exec(event->globalPos());         break;
    case Types::Section:        ui->menuSectionActions->exec(event->globalPos());      break;
    case Types::VssStore:
    case Types::Vss2Store:
    case Types::FdcStore:
    case Types::FsysStore:
    case Types::EvsaStore:
    case Types::FtwStore:
    case Types::FlashMapStore:
    case Types::CmdbStore:
    case Types::FptStore:
    case Types::CpdStore:
    case Types::BpdtStore:      ui->menuStoreActions->exec(event->globalPos());        break;
    case Types::FreeSpace:      break; // No menu needed for FreeSpace item
    default:                    ui->menuEntryActions->exec(event->globalPos());        break;
    }
}

void UEFITool::readSettings()
{
    QSettings settings(this);
    restoreGeometry(settings.value("mainWindow/geometry").toByteArray());
    restoreState(settings.value("mainWindow/windowState").toByteArray());
    QList<int> horList, vertList;
    horList.append(settings.value("mainWindow/treeWidth", 600).toInt());
    horList.append(settings.value("mainWindow/infoWidth", 180).toInt());
    vertList.append(settings.value("mainWindow/treeHeight", 400).toInt());
    vertList.append(settings.value("mainWindow/messageHeight", 180).toInt());
    ui->infoSplitter->setSizes(horList);
    ui->messagesSplitter->setSizes(vertList);
    ui->structureTreeView->setColumnWidth(0, settings.value("tree/columnWidth0", ui->structureTreeView->columnWidth(0)).toInt());
    ui->structureTreeView->setColumnWidth(1, settings.value("tree/columnWidth1", ui->structureTreeView->columnWidth(1)).toInt());
    ui->structureTreeView->setColumnWidth(2, settings.value("tree/columnWidth2", ui->structureTreeView->columnWidth(2)).toInt());
    ui->structureTreeView->setColumnWidth(3, settings.value("tree/columnWidth3", ui->structureTreeView->columnWidth(3)).toInt());
    markingEnabled = settings.value("tree/markingEnabled", true).toBool();
    ui->actionToggleBootGuardMarking->setChecked(markingEnabled);

    // Set monospace font for some controls
    QString fontName;
    int fontSize;
#if defined Q_OS_OSX
    fontName = settings.value("mainWindow/fontName", QString("Menlo")).toString();
    fontSize = settings.value("mainWindow/fontSize", 10).toInt();
#elif defined Q_OS_WIN
    fontName = settings.value("mainWindow/fontName", QString("Consolas")).toString();
    fontSize = settings.value("mainWindow/fontSize", 9).toInt();
#else
    fontName = settings.value("mainWindow/fontName", QString("Courier New")).toString();
    fontSize = settings.value("mainWindow/fontSize", 10).toInt();
#endif
    currentFont = QFont(fontName, fontSize);
    ui->infoEdit->setFont(currentFont);
    ui->parserMessagesListWidget->setFont(currentFont);
    ui->finderMessagesListWidget->setFont(currentFont);
    ui->builderMessagesListWidget->setFont(currentFont);
    ui->fitTableWidget->setFont(currentFont);
    ui->securityEdit->setFont(currentFont);
    ui->structureTreeView->setFont(currentFont);
    searchDialog->ui->guidEdit->setFont(currentFont);
    searchDialog->ui->hexEdit->setFont(currentFont);
    hexViewDialog->setFont(currentFont);
    goToAddressDialog->ui->hexSpinBox->setFont(currentFont);
    goToBaseDialog->ui->hexSpinBox->setFont(currentFont);
}

void UEFITool::writeSettings()
{
    QSettings settings(this);
    settings.setValue("mainWindow/geometry", saveGeometry());
    settings.setValue("mainWindow/windowState", saveState());
    settings.setValue("mainWindow/treeWidth", ui->structureGroupBox->width());
    settings.setValue("mainWindow/infoWidth", ui->infoGroupBox->width());
    settings.setValue("mainWindow/treeHeight", ui->structureGroupBox->height());
    settings.setValue("mainWindow/messageHeight", ui->messagesTabWidget->height());
    settings.setValue("tree/columnWidth0", ui->structureTreeView->columnWidth(0));
    settings.setValue("tree/columnWidth1", ui->structureTreeView->columnWidth(1));
    settings.setValue("tree/columnWidth2", ui->structureTreeView->columnWidth(2));
    settings.setValue("tree/columnWidth3", ui->structureTreeView->columnWidth(3));
    settings.setValue("tree/markingEnabled", markingEnabled);
    settings.setValue("mainWindow/fontName", currentFont.family());
    settings.setValue("mainWindow/fontSize", currentFont.pointSize());
}

void UEFITool::showFitTable()
{
    std::vector<std::pair<std::vector<UString>, UModelIndex> > fitTable = ffsParser->getFitTable();
    if (fitTable.empty()) {
        // Disable FIT tab
        ui->messagesTabWidget->setTabEnabled(TAB_FIT, false);
        return;
    }

    // Enable FIT tab
    ui->messagesTabWidget->setTabEnabled(TAB_FIT, true);

    // Set up the FIT table
    ui->fitTableWidget->clear();
    ui->fitTableWidget->setRowCount((int)fitTable.size());
    ui->fitTableWidget->setColumnCount(6);
    ui->fitTableWidget->setHorizontalHeaderLabels(QStringList() << tr("Address") << tr("Size") << tr("Version") << tr("Checksum") << tr("Type") << tr("Information"));
    ui->fitTableWidget->setEditTriggers(QAbstractItemView::NoEditTriggers);
    ui->fitTableWidget->setSelectionBehavior(QAbstractItemView::SelectRows);
    ui->fitTableWidget->setSelectionMode(QAbstractItemView::SingleSelection);
    ui->fitTableWidget->horizontalHeader()->setStretchLastSection(true);

    // Add all data to the table widget
    for (size_t i = 0; i < fitTable.size(); i++) {
        for (UINT8 j = 0; j < 6; j++) {
            QTableWidgetItem* item = new QTableWidgetItem(fitTable[i].first[j]);
            item->setData(Qt::UserRole, QByteArray((const char*)&fitTable[i].second, sizeof(fitTable[i].second)));
            ui->fitTableWidget->setItem((int)i, j, item);
        }
    }

    ui->fitTableWidget->resizeColumnsToContents();
    ui->fitTableWidget->resizeRowsToContents();
    ui->messagesTabWidget->setCurrentIndex(TAB_FIT);
}

void UEFITool::showSecurityInfo()
{
    // Get security info
    UString secInfo = ffsParser->getSecurityInfo();
    if (secInfo.isEmpty()) {
        ui->messagesTabWidget->setTabEnabled(TAB_SECURITY, false);
        return;
    }

    ui->messagesTabWidget->setTabEnabled(TAB_SECURITY, true);
    ui->securityEdit->setPlainText(secInfo);
    ui->messagesTabWidget->setCurrentIndex(TAB_SECURITY);
}

void UEFITool::currentTabChanged(int index)
{
    U_UNUSED_PARAMETER(index);

    ui->menuMessageActions->setEnabled(false);
    ui->actionMessagesCopy->setEnabled(false);
    ui->actionMessagesCopyAll->setEnabled(false);
    ui->actionMessagesClear->setEnabled(false);
}

void UEFITool::loadGuidDatabase()
{
    QString path = QFileDialog::getOpenFileName(this, tr("Select GUID database file to load"), currentDir, tr("Comma-separated values files (*.csv);;All files (*)"));
    if (!path.isEmpty()) {
        initGuidDatabase(path);
        if (!currentPath.isEmpty() && QMessageBox::Yes == QMessageBox::information(this, tr("New GUID database loaded"), tr("Apply new GUID database on the opened file?\nUnsaved changes and tree position will be lost."), QMessageBox::Yes, QMessageBox::No))
            openImageFile(currentPath);
    }
}

void UEFITool::unloadGuidDatabase()
{
    initGuidDatabase();
    if (!currentPath.isEmpty() && QMessageBox::Yes == QMessageBox::information(this, tr("GUID database unloaded"), tr("Apply changes on the opened file?\nUnsaved changes and tree position will be lost."), QMessageBox::Yes, QMessageBox::No))
       openImageFile(currentPath);
}

void UEFITool::loadDefaultGuidDatabase()
{
    initGuidDatabase(":/guids.csv");
    if (!currentPath.isEmpty() && QMessageBox::Yes == QMessageBox::information(this, tr("Default GUID database loaded"), tr("Apply default GUID database on the opened file?\nUnsaved changes and tree position will be lost."), QMessageBox::Yes, QMessageBox::No))
        openImageFile(currentPath);
}

void UEFITool::exportDiscoveredGuids()
{
    GuidDatabase db = guidDatabaseFromTreeRecursive(model, model->index(0, 0));
    if (!db.empty()) {
        QString path = QFileDialog::getSaveFileName(this, tr("Save parsed GUIDs to database"), currentPath + ".guids.csv", tr("Comma-separated values files (*.csv);;All files (*)"));
        if (!path.isEmpty())
            guidDatabaseExportToFile(path, db);
    }
}

void UEFITool::generateReport()
{
    QString path = QFileDialog::getSaveFileName(this, tr("Save report to text file"), currentPath + ".report.txt", tr("Text files (*.txt);;All files (*)"));
    if (!path.isEmpty()) {
        std::vector<QString> report = ffsReport->generate();
        if (report.size()) {
            QFile file;
            file.setFileName(path);
            if (file.open(QFile::Text | QFile::WriteOnly)) {
                for (size_t i = 0; i < report.size(); i++) {
                    file.write(report[i].toLatin1().append('\n'));
                }
                file.close();
            }
        }
    }
}

```

`efiXloader/3rd/uefitool/UEFITool/uefitool.desktop`:

```desktop
[Desktop Entry]
Type=Application
Version=1.0
Name=UEFITool
Comment=UEFI firmware image viewer and editor
Path=/usr/bin
Exec=uefitool
Icon=uefitool
Terminal=false
Categories=Development;System;Utility;HardwareSettings;Electronics;Engineering;
Keywords=BIOS;

```

`efiXloader/3rd/uefitool/UEFITool/uefitool.h`:

```h
/* uefitool.h

  Copyright (c) 2014, Nikolaj Schlej. All rights reserved.
  This program and the accompanying materials
  are licensed and made available under the terms and conditions of the BSD License
  which accompanies this distribution.  The full text of the license may be found at
  http://opensource.org/licenses/bsd-license.php

  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

  */

#ifndef UEFITOOL_H
#define UEFITOOL_H

#include <QMainWindow>
#include <QByteArray>
#include <QClipboard>
#include <QDragEnterEvent>
#include <QDropEvent>
#include <QFile>
#include <QFileDialog>
#include <QFileInfo>
#include <QFont>
#include <QListWidget>
#include <QMenu>
#include <QMessageBox>
#include <QMimeData>
#include <QPlainTextEdit>
#include <QProcess>
#include <QSettings>
#include <QSplitter>
#include <QString>
#include <QTableWidget>
#include <QTreeView>
#include <QUrl>

#include "../common/basetypes.h"
#include "../common/utility.h"
#include "../common/ffs.h"
#include "../common/ffsparser.h"
#include "../common/ffsops.h"
#include "../common/ffsbuilder.h"
#include "../common/ffsreport.h"
#include "../common/guiddatabase.h"

#include "searchdialog.h"
#include "gotobasedialog.h"
#include "gotoaddressdialog.h"
#include "hexviewdialog.h"
#include "ffsfinder.h"

namespace Ui {
    class UEFITool;
}

class UEFITool : public QMainWindow
{
    Q_OBJECT

public:
    explicit UEFITool(QWidget *parent = 0);
    ~UEFITool();

    void openImageFile(QString path);
    void setProgramPath(QString path) { currentProgramPath = path; }

private slots:
    void init();
    void populateUi(const QItemSelection &selected);
    void populateUi(const QModelIndex &current);
    void scrollTreeView(QListWidgetItem* item); // For messages
    void scrollTreeView(QTableWidgetItem* item); // For FIT table entries

    void openImageFile();
    void openImageFileInNewWindow();
    void saveImageFile();

    void search();
    void goToBase();
    void goToAddress();

    void hexView();
    void bodyHexView();
    void goToData();

    void extract(const UINT8 mode);
    void extractAsIs();
    void extractBody();
    void extractBodyUncompressed();

    void insert(const UINT8 mode);
    void insertInto();
    void insertBefore();
    void insertAfter();

    void replace(const UINT8 mode);
    void replaceAsIs();
    void replaceBody();

    void rebuild();

    void remove();

    void copyMessage();
    void copyAllMessages();
    void enableMessagesCopyActions(QListWidgetItem* item);
    void clearMessages();

    void toggleBootGuardMarking(bool enabled);

    void about();
    void aboutQt();

    void exit();
    void writeSettings();

    void loadGuidDatabase();
    void unloadGuidDatabase();
    void loadDefaultGuidDatabase();
    void exportDiscoveredGuids();
    void generateReport();

    void currentTabChanged(int index);

private:
    Ui::UEFITool* ui;
    TreeModel* model;
    FfsParser* ffsParser;
    FfsFinder* ffsFinder;
    FfsReport* ffsReport;
    FfsOperations* ffsOps;
    FfsBuilder* ffsBuilder;
    SearchDialog* searchDialog;
    HexViewDialog* hexViewDialog;
    GoToBaseDialog* goToBaseDialog;
    GoToAddressDialog* goToAddressDialog;
    QClipboard* clipboard;
    QString currentDir;
    QString currentPath;
    QString currentProgramPath;
    QFont currentFont;
    const QString version;
    bool markingEnabled;

    bool enableExtractBodyUncompressed(const QModelIndex &current);

    bool eventFilter(QObject* obj, QEvent* event);
    void dragEnterEvent(QDragEnterEvent* event);
    void dropEvent(QDropEvent* event);
    void contextMenuEvent(QContextMenuEvent* event);
    void readSettings();
    void showParserMessages();
    void showFinderMessages();
    void showFitTable();
    void showSecurityInfo();
    void showBuilderMessages();

    enum {
        TAB_PARSER,
        TAB_FIT,
        TAB_SECURITY,
        TAB_SEARCH,
        TAB_BUILDER
    };
};

#endif // UEFITOOL_H

```

`efiXloader/3rd/uefitool/UEFITool/uefitool.pro`:

```pro
QT += core gui
greaterThan(QT_MAJOR_VERSION, 4): QT += widgets

TARGET = UEFITool
TEMPLATE = app
DEFINES += "U_ENABLE_FIT_PARSING_SUPPORT"
DEFINES += "U_ENABLE_NVRAM_PARSING_SUPPORT"
DEFINES += "U_ENABLE_ME_PARSING_SUPPORT"
DEFINES += "U_ENABLE_GUID_DATABASE_SUPPORT"

HEADERS += uefitool.h \
 searchdialog.h \
 hexviewdialog.h \
 gotobasedialog.h \
 gotoaddressdialog.h \
 guidlineedit.h \
 ffsfinder.h \
 hexspinbox.h \
 ../common/guiddatabase.h \
 ../common/nvram.h \
 ../common/nvramparser.h \
 ../common/meparser.h \
 ../common/ffsops.h \
 ../common/basetypes.h \
 ../common/descriptor.h \
 ../common/gbe.h \
 ../common/me.h \
 ../common/ffs.h \
 ../common/fit.h \
 ../common/peimage.h \
 ../common/types.h \
 ../common/utility.h \
 ../common/parsingdata.h \
 ../common/ffsbuilder.h \
 ../common/ffsparser.h \
 ../common/ffsreport.h \
 ../common/treeitem.h \
 ../common/ffsutils.h \
 ../common/treemodel.h \
 ../common/LZMA/LzmaCompress.h \
 ../common/LZMA/LzmaDecompress.h \
 ../common/Tiano/EfiTianoDecompress.h \
 ../common/Tiano/EfiTianoCompress.h \
 ../common/ustring.h \
 ../common/ubytearray.h \
 ../common/bootguard.h \
 ../common/sha256.h \
 ../common/zlib/zconf.h \
 ../common/zlib/zlib.h \
 ../common/zlib/crc32.h \
 ../common/zlib/deflate.h \
 ../common/zlib/gzguts.h \
 ../common/zlib/inffast.h \
 ../common/zlib/inffixed.h \
 ../common/zlib/inflate.h \
 ../common/zlib/inftrees.h \
 ../common/zlib/trees.h \
 ../common/zlib/zutil.h \
 ../version.h \
 qhexedit2/qhexedit.h \
 qhexedit2/chunks.h \
 qhexedit2/commands.h

SOURCES += uefitool_main.cpp \
 uefitool.cpp \
 searchdialog.cpp \
 hexviewdialog.cpp \
 guidlineedit.cpp \
 ffsfinder.cpp \
 hexspinbox.cpp \
 ../common/guiddatabase.cpp \
 ../common/nvram.cpp \
 ../common/nvramparser.cpp \
 ../common/meparser.cpp \
 ../common/ffsops.cpp \
 ../common/types.cpp \
 ../common/descriptor.cpp \
 ../common/ffs.cpp \
 ../common/peimage.cpp \
 ../common/utility.cpp \
 ../common/ffsbuilder.cpp \
 ../common/ffsparser.cpp \
 ../common/ffsreport.cpp \
 ../common/ffsutils.cpp \
 ../common/treeitem.cpp \
 ../common/treemodel.cpp \
 ../common/LZMA/LzmaCompress.c \
 ../common/LZMA/LzmaDecompress.c \
 ../common/LZMA/SDK/C/Bra86.c \
 ../common/LZMA/SDK/C/LzFind.c \
 ../common/LZMA/SDK/C/LzmaDec.c \
 ../common/LZMA/SDK/C/LzmaEnc.c \
 ../common/Tiano/EfiTianoDecompress.c \
 ../common/Tiano/EfiTianoCompress.c \
 ../common/Tiano/EfiTianoCompressLegacy.c \
 ../common/ustring.cpp \
 ../common/sha256.c \
 ../common/zlib/adler32.c \
 ../common/zlib/compress.c \
 ../common/zlib/crc32.c \
 ../common/zlib/deflate.c \
 ../common/zlib/gzclose.c \
 ../common/zlib/gzlib.c \
 ../common/zlib/gzread.c \
 ../common/zlib/gzwrite.c \
 ../common/zlib/inflate.c \
 ../common/zlib/infback.c \
 ../common/zlib/inftrees.c \
 ../common/zlib/inffast.c \
 ../common/zlib/trees.c \
 ../common/zlib/uncompr.c \
 ../common/zlib/zutil.c \
 qhexedit2/qhexedit.cpp \
 qhexedit2/chunks.cpp \
 qhexedit2/commands.cpp

FORMS += uefitool.ui \
 searchdialog.ui \
 hexviewdialog.ui \
 gotobasedialog.ui \
 gotoaddressdialog.ui

RESOURCES += uefitool.qrc
RC_FILE = uefitool.rc
ICON = icons/uefitool.icns
ICONFILE.files = icons/uefitool.icns
ICONFILE.path = Contents/Resources
QMAKE_BUNDLE_DATA += ICONFILE
QMAKE_INFO_PLIST = Info.plist

```

`efiXloader/3rd/uefitool/UEFITool/uefitool.qrc`:

```qrc
<!DOCTYPE RCC><RCC version="1.0">
<qresource>
    <file alias="guids.csv">../common/guids.csv</file>
</qresource>
</RCC>
```

`efiXloader/3rd/uefitool/UEFITool/uefitool.rc`:

```rc
IDI_ICON1 ICON DISCARDABLE "icons/uefitool.ico"

```

`efiXloader/3rd/uefitool/UEFITool/uefitool.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>UEFITool</class>
 <widget class="QMainWindow" name="UEFITool">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>851</width>
    <height>586</height>
   </rect>
  </property>
  <property name="sizePolicy">
   <sizepolicy hsizetype="Expanding" vsizetype="Expanding">
    <horstretch>0</horstretch>
    <verstretch>0</verstretch>
   </sizepolicy>
  </property>
  <property name="acceptDrops">
   <bool>true</bool>
  </property>
  <property name="windowTitle">
   <string>UEFITool</string>
  </property>
  <widget class="QWidget" name="centralWidget">
   <property name="sizePolicy">
    <sizepolicy hsizetype="Expanding" vsizetype="Expanding">
     <horstretch>0</horstretch>
     <verstretch>0</verstretch>
    </sizepolicy>
   </property>
   <layout class="QHBoxLayout" name="horizontalLayout_1">
    <property name="spacing">
     <number>0</number>
    </property>
    <property name="leftMargin">
     <number>5</number>
    </property>
    <property name="topMargin">
     <number>5</number>
    </property>
    <property name="rightMargin">
     <number>5</number>
    </property>
    <property name="bottomMargin">
     <number>5</number>
    </property>
    <item>
     <widget class="QSplitter" name="messagesSplitter">
      <property name="orientation">
       <enum>Qt::Vertical</enum>
      </property>
      <widget class="QSplitter" name="infoSplitter">
       <property name="orientation">
        <enum>Qt::Horizontal</enum>
       </property>
       <widget class="QGroupBox" name="structureGroupBox">
        <property name="title">
         <string>Structure</string>
        </property>
        <layout class="QHBoxLayout" name="horizontalLayout_2">
         <property name="spacing">
          <number>0</number>
         </property>
         <property name="leftMargin">
          <number>5</number>
         </property>
         <property name="topMargin">
          <number>5</number>
         </property>
         <property name="rightMargin">
          <number>5</number>
         </property>
         <property name="bottomMargin">
          <number>5</number>
         </property>
         <item>
          <widget class="QTreeView" name="structureTreeView">
           <property name="sizePolicy">
            <sizepolicy hsizetype="Expanding" vsizetype="Expanding">
             <horstretch>0</horstretch>
             <verstretch>0</verstretch>
            </sizepolicy>
           </property>
           <property name="indentation">
            <number>10</number>
           </property>
           <property name="headerHidden">
            <bool>false</bool>
           </property>
           <attribute name="headerCascadingSectionResizes">
            <bool>true</bool>
           </attribute>
           <attribute name="headerDefaultSectionSize">
            <number>200</number>
           </attribute>
           <attribute name="headerStretchLastSection">
            <bool>true</bool>
           </attribute>
          </widget>
         </item>
        </layout>
       </widget>
       <widget class="QGroupBox" name="infoGroupBox">
        <property name="title">
         <string>Information</string>
        </property>
        <layout class="QHBoxLayout" name="horizontalLayout_3">
         <property name="spacing">
          <number>0</number>
         </property>
         <property name="leftMargin">
          <number>5</number>
         </property>
         <property name="topMargin">
          <number>5</number>
         </property>
         <property name="rightMargin">
          <number>5</number>
         </property>
         <property name="bottomMargin">
          <number>5</number>
         </property>
         <item>
          <widget class="QPlainTextEdit" name="infoEdit">
           <property name="acceptDrops">
            <bool>false</bool>
           </property>
           <property name="undoRedoEnabled">
            <bool>false</bool>
           </property>
           <property name="readOnly">
            <bool>true</bool>
           </property>
          </widget>
         </item>
        </layout>
       </widget>
      </widget>
      <widget class="QTabWidget" name="messagesTabWidget">
       <property name="enabled">
        <bool>true</bool>
       </property>
       <property name="currentIndex">
        <number>0</number>
       </property>
       <widget class="QWidget" name="parserTab">
        <attribute name="title">
         <string>Parser</string>
        </attribute>
        <layout class="QHBoxLayout" name="horizontalLayout_4">
         <property name="spacing">
          <number>0</number>
         </property>
         <property name="leftMargin">
          <number>5</number>
         </property>
         <property name="topMargin">
          <number>5</number>
         </property>
         <property name="rightMargin">
          <number>5</number>
         </property>
         <property name="bottomMargin">
          <number>5</number>
         </property>
         <item>
          <widget class="QListWidget" name="parserMessagesListWidget">
           <property name="mouseTracking">
            <bool>true</bool>
           </property>
          </widget>
         </item>
        </layout>
       </widget>
       <widget class="QWidget" name="fitTab">
        <attribute name="title">
         <string>FIT</string>
        </attribute>
        <layout class="QHBoxLayout" name="horizontalLayout_5">
         <property name="spacing">
          <number>0</number>
         </property>
         <property name="leftMargin">
          <number>5</number>
         </property>
         <property name="topMargin">
          <number>5</number>
         </property>
         <property name="rightMargin">
          <number>5</number>
         </property>
         <property name="bottomMargin">
          <number>5</number>
         </property>
         <item>
          <widget class="QSplitter" name="splitter">
           <property name="orientation">
            <enum>Qt::Horizontal</enum>
           </property>
           <widget class="QTableWidget" name="fitTableWidget"/>
          </widget>
         </item>
        </layout>
       </widget>
       <widget class="QWidget" name="securityTab">
        <property name="enabled">
         <bool>true</bool>
        </property>
        <attribute name="title">
         <string>Security</string>
        </attribute>
        <layout class="QHBoxLayout" name="horizontalLayout">
         <property name="spacing">
          <number>0</number>
         </property>
         <property name="leftMargin">
          <number>5</number>
         </property>
         <property name="topMargin">
          <number>5</number>
         </property>
         <property name="rightMargin">
          <number>5</number>
         </property>
         <property name="bottomMargin">
          <number>5</number>
         </property>
         <item>
          <widget class="QPlainTextEdit" name="securityEdit">
           <property name="acceptDrops">
            <bool>false</bool>
           </property>
           <property name="undoRedoEnabled">
            <bool>false</bool>
           </property>
           <property name="readOnly">
            <bool>true</bool>
           </property>
          </widget>
         </item>
        </layout>
       </widget>
       <widget class="QWidget" name="finderTab">
        <attribute name="title">
         <string>Search</string>
        </attribute>
        <layout class="QHBoxLayout" name="horizontalLayout_6">
         <property name="spacing">
          <number>0</number>
         </property>
         <property name="leftMargin">
          <number>5</number>
         </property>
         <property name="topMargin">
          <number>5</number>
         </property>
         <property name="rightMargin">
          <number>5</number>
         </property>
         <property name="bottomMargin">
          <number>5</number>
         </property>
         <item>
          <widget class="QListWidget" name="finderMessagesListWidget">
           <property name="mouseTracking">
            <bool>true</bool>
           </property>
          </widget>
         </item>
        </layout>
       </widget>
       <widget class="QWidget" name="builderTab">
        <attribute name="title">
         <string>Builder</string>
        </attribute>
        <layout class="QHBoxLayout" name="horizontalLayout_7">
         <property name="spacing">
          <number>0</number>
         </property>
         <property name="leftMargin">
          <number>5</number>
         </property>
         <property name="topMargin">
          <number>5</number>
         </property>
         <property name="rightMargin">
          <number>5</number>
         </property>
         <property name="bottomMargin">
          <number>5</number>
         </property>
         <item>
          <widget class="QListWidget" name="builderMessagesListWidget">
           <property name="mouseTracking">
            <bool>true</bool>
           </property>
          </widget>
         </item>
        </layout>
       </widget>
      </widget>
     </widget>
    </item>
   </layout>
  </widget>
  <widget class="QStatusBar" name="statusBar"/>
  <widget class="QMenuBar" name="menuBar">
   <property name="geometry">
    <rect>
     <x>0</x>
     <y>0</y>
     <width>851</width>
     <height>31</height>
    </rect>
   </property>
   <widget class="QMenu" name="menuFile">
    <property name="title">
     <string>&amp;File</string>
    </property>
    <addaction name="actionOpenImageFile"/>
    <addaction name="actionOpenImageFileInNewWindow"/>
    <addaction name="actionSaveImageFile"/>
    <addaction name="separator"/>
    <addaction name="actionGenerateReport"/>
    <addaction name="separator"/>
    <addaction name="actionLoadGuidDatabase"/>
    <addaction name="actionLoadDefaultGuidDatabase"/>
    <addaction name="actionUnloadGuidDatabase"/>
    <addaction name="actionExportDiscoveredGuids"/>
    <addaction name="separator"/>
    <addaction name="actionQuit"/>
   </widget>
   <widget class="QMenu" name="menuHelp">
    <property name="title">
     <string>H&amp;elp</string>
    </property>
    <addaction name="actionAbout"/>
    <addaction name="actionAboutQt"/>
   </widget>
   <widget class="QMenu" name="menuAction">
    <property name="title">
     <string>&amp;Action</string>
    </property>
    <widget class="QMenu" name="menuCapsuleActions">
     <property name="enabled">
      <bool>false</bool>
     </property>
     <property name="title">
      <string>&amp;Capsule</string>
     </property>
     <addaction name="actionHexView"/>
     <addaction name="actionBodyHexView"/>
     <addaction name="separator"/>
     <addaction name="actionExtract"/>
     <addaction name="actionExtractBody"/>
    </widget>
    <widget class="QMenu" name="menuImageActions">
     <property name="enabled">
      <bool>false</bool>
     </property>
     <property name="title">
      <string>&amp;Image</string>
     </property>
     <addaction name="actionHexView"/>
     <addaction name="separator"/>
     <addaction name="actionExtract"/>
    </widget>
    <widget class="QMenu" name="menuRegionActions">
     <property name="enabled">
      <bool>false</bool>
     </property>
     <property name="title">
      <string>&amp;Region</string>
     </property>
     <addaction name="actionHexView"/>
     <addaction name="separator"/>
     <addaction name="actionExtract"/>
     <addaction name="separator"/>
     <addaction name="actionRebuild"/>
     <addaction name="separator"/>
     <addaction name="actionReplace"/>
    </widget>
    <widget class="QMenu" name="menuPaddingActions">
     <property name="enabled">
      <bool>false</bool>
     </property>
     <property name="title">
      <string>&amp;Padding</string>
     </property>
     <addaction name="actionHexView"/>
     <addaction name="separator"/>
     <addaction name="actionExtract"/>
    </widget>
    <widget class="QMenu" name="menuVolumeActions">
     <property name="enabled">
      <bool>false</bool>
     </property>
     <property name="title">
      <string>&amp;Volume</string>
     </property>
     <addaction name="actionHexView"/>
     <addaction name="actionBodyHexView"/>
     <addaction name="separator"/>
     <addaction name="actionExtract"/>
     <addaction name="actionExtractBody"/>
     <addaction name="separator"/>
     <addaction name="actionRebuild"/>
     <addaction name="separator"/>
     <addaction name="actionInsertInto"/>
     <addaction name="separator"/>
     <addaction name="actionReplace"/>
     <addaction name="actionReplaceBody"/>
    </widget>
    <widget class="QMenu" name="menuFileActions">
     <property name="enabled">
      <bool>false</bool>
     </property>
     <property name="title">
      <string>&amp;File</string>
     </property>
     <addaction name="actionHexView"/>
     <addaction name="actionBodyHexView"/>
     <addaction name="separator"/>
     <addaction name="actionExtract"/>
     <addaction name="actionExtractBody"/>
     <addaction name="separator"/>
     <addaction name="actionRebuild"/>
     <addaction name="separator"/>
     <addaction name="actionInsertInto"/>
     <addaction name="actionInsertBefore"/>
     <addaction name="actionInsertAfter"/>
     <addaction name="separator"/>
     <addaction name="actionReplace"/>
     <addaction name="actionReplaceBody"/>
     <addaction name="separator"/>
     <addaction name="actionRemove"/>
    </widget>
    <widget class="QMenu" name="menuSectionActions">
     <property name="enabled">
      <bool>false</bool>
     </property>
     <property name="title">
      <string>&amp;Section</string>
     </property>
     <addaction name="actionHexView"/>
     <addaction name="actionBodyHexView"/>
     <addaction name="separator"/>
     <addaction name="actionExtract"/>
     <addaction name="actionExtractBody"/>
     <addaction name="actionExtractBodyUncompressed"/>
     <addaction name="separator"/>
     <addaction name="actionRebuild"/>
     <addaction name="separator"/>
     <addaction name="actionInsertInto"/>
     <addaction name="actionInsertBefore"/>
     <addaction name="actionInsertAfter"/>
     <addaction name="separator"/>
     <addaction name="actionReplace"/>
     <addaction name="actionReplaceBody"/>
     <addaction name="separator"/>
     <addaction name="actionRemove"/>
    </widget>
    <widget class="QMenu" name="menuMessageActions">
     <property name="enabled">
      <bool>false</bool>
     </property>
     <property name="title">
      <string>&amp;Messages</string>
     </property>
     <addaction name="actionMessagesCopy"/>
     <addaction name="actionMessagesCopyAll"/>
     <addaction name="separator"/>
     <addaction name="actionMessagesClear"/>
    </widget>
    <widget class="QMenu" name="menuEntryActions">
     <property name="enabled">
      <bool>false</bool>
     </property>
     <property name="title">
      <string>&amp;Entry</string>
     </property>
     <addaction name="actionHexView"/>
     <addaction name="actionBodyHexView"/>
     <addaction name="separator"/>
     <addaction name="actionGoToData"/>
     <addaction name="separator"/>
     <addaction name="actionExtract"/>
     <addaction name="actionExtractBody"/>
     <addaction name="separator"/>
     <addaction name="actionInsertBefore"/>
     <addaction name="actionInsertAfter"/>
     <addaction name="separator"/>
     <addaction name="actionRebuild"/>
     <addaction name="separator"/>
     <addaction name="actionReplace"/>
     <addaction name="actionReplaceBody"/>
     <addaction name="separator"/>
     <addaction name="actionRemove"/>
    </widget>
    <widget class="QMenu" name="menuStoreActions">
     <property name="enabled">
      <bool>false</bool>
     </property>
     <property name="title">
      <string>S&amp;tore</string>
     </property>
     <addaction name="actionHexView"/>
     <addaction name="actionBodyHexView"/>
     <addaction name="separator"/>
     <addaction name="actionExtract"/>
     <addaction name="actionExtractBody"/>
     <addaction name="separator"/>
     <addaction name="actionInsertInto"/>
     <addaction name="actionInsertBefore"/>
     <addaction name="actionInsertAfter"/>
     <addaction name="separator"/>
     <addaction name="actionRebuild"/>
     <addaction name="separator"/>
     <addaction name="actionReplace"/>
     <addaction name="actionReplaceBody"/>
    </widget>
    <addaction name="actionGoToBase"/>
    <addaction name="actionGoToAddress"/>
    <addaction name="actionSearch"/>
    <addaction name="separator"/>
    <addaction name="menuCapsuleActions"/>
    <addaction name="menuImageActions"/>
    <addaction name="menuRegionActions"/>
    <addaction name="menuPaddingActions"/>
    <addaction name="menuVolumeActions"/>
    <addaction name="menuFileActions"/>
    <addaction name="menuSectionActions"/>
    <addaction name="separator"/>
    <addaction name="menuStoreActions"/>
    <addaction name="menuEntryActions"/>
    <addaction name="separator"/>
    <addaction name="menuMessageActions"/>
   </widget>
   <widget class="QMenu" name="menuView">
    <property name="title">
     <string>&amp;View</string>
    </property>
    <addaction name="actionToggleBootGuardMarking"/>
   </widget>
   <addaction name="menuFile"/>
   <addaction name="menuAction"/>
   <addaction name="menuView"/>
   <addaction name="menuHelp"/>
  </widget>
  <action name="actionInsertAfter">
   <property name="enabled">
    <bool>false</bool>
   </property>
   <property name="text">
    <string>Insert &amp;after...</string>
   </property>
   <property name="toolTip">
    <string>Insert an object from file after selected object</string>
   </property>
   <property name="shortcut">
    <string>Ctrl+Shift+I</string>
   </property>
  </action>
  <action name="actionInsertBefore">
   <property name="enabled">
    <bool>false</bool>
   </property>
   <property name="text">
    <string>Insert b&amp;efore...</string>
   </property>
   <property name="toolTip">
    <string>Insert object from file before selected object</string>
   </property>
   <property name="shortcut">
    <string>Ctrl+Alt+I</string>
   </property>
  </action>
  <action name="actionReplace">
   <property name="enabled">
    <bool>false</bool>
   </property>
   <property name="text">
    <string>Rep&amp;lace as is...</string>
   </property>
   <property name="toolTip">
    <string>Replace selected object as is with an object from file</string>
   </property>
   <property name="shortcut">
    <string>Ctrl+R</string>
   </property>
  </action>
  <action name="actionExtract">
   <property name="enabled">
    <bool>false</bool>
   </property>
   <property name="text">
    <string>E&amp;xtract as is...</string>
   </property>
   <property name="toolTip">
    <string>Extract selected object as is to file</string>
   </property>
   <property name="shortcut">
    <string>Ctrl+E</string>
   </property>
  </action>
  <action name="actionExtractBody">
   <property name="enabled">
    <bool>false</bool>
   </property>
   <property name="text">
    <string>Extract &amp;body...</string>
   </property>
   <property name="toolTip">
    <string>Extract body of selected object to file</string>
   </property>
   <property name="shortcut">
    <string>Ctrl+Shift+E</string>
   </property>
  </action>
  <action name="actionRemove">
   <property name="enabled">
    <bool>false</bool>
   </property>
   <property name="text">
    <string>Re&amp;move</string>
   </property>
   <property name="toolTip">
    <string>Remove selected object</string>
   </property>
   <property name="shortcut">
    <string>Ctrl+Del</string>
   </property>
  </action>
  <action name="actionOpenImageFile">
   <property name="text">
    <string>&amp;Open image file...</string>
   </property>
   <property name="toolTip">
    <string>Open image file</string>
   </property>
   <property name="shortcut">
    <string>Ctrl+O</string>
   </property>
  </action>
  <action name="actionInsertInto">
   <property name="enabled">
    <bool>false</bool>
   </property>
   <property name="text">
    <string>Insert &amp;into...</string>
   </property>
   <property name="toolTip">
    <string>Insert object from file into selected object</string>
   </property>
   <property name="shortcut">
    <string>Ctrl+I</string>
   </property>
  </action>
  <action name="actionSaveImageFile">
   <property name="enabled">
    <bool>false</bool>
   </property>
   <property name="text">
    <string>&amp;Save image file...</string>
   </property>
   <property name="toolTip">
    <string>Save modified image file</string>
   </property>
   <property name="shortcut">
    <string>Ctrl+S</string>
   </property>
  </action>
  <action name="actionRebuild">
   <property name="enabled">
    <bool>false</bool>
   </property>
   <property name="text">
    <string>&amp;Rebuild</string>
   </property>
   <property name="toolTip">
    <string>Rebuild selected object</string>
   </property>
   <property name="shortcut">
    <string>Ctrl+Space</string>
   </property>
  </action>
  <action name="actionAbout">
   <property name="text">
    <string>&amp;About UEFITool</string>
   </property>
   <property name="shortcut">
    <string>F1</string>
   </property>
   <property name="menuRole">
    <enum>QAction::AboutRole</enum>
   </property>
  </action>
  <action name="actionAboutQt">
   <property name="text">
    <string>About &amp;Qt</string>
   </property>
   <property name="shortcut">
    <string>Shift+F1</string>
   </property>
   <property name="menuRole">
    <enum>QAction::AboutQtRole</enum>
   </property>
  </action>
  <action name="actionQuit">
   <property name="text">
    <string>&amp;Quit</string>
   </property>
   <property name="shortcut">
    <string>Alt+X</string>
   </property>
   <property name="menuRole">
    <enum>QAction::QuitRole</enum>
   </property>
  </action>
  <action name="actionSearch">
   <property name="enabled">
    <bool>false</bool>
   </property>
   <property name="text">
    <string>Searc&amp;h...</string>
   </property>
   <property name="shortcut">
    <string>Ctrl+F</string>
   </property>
  </action>
  <action name="actionMessagesClear">
   <property name="enabled">
    <bool>false</bool>
   </property>
   <property name="text">
    <string>Clea&amp;r</string>
   </property>
   <property name="toolTip">
    <string>Clear messages</string>
   </property>
   <property name="shortcut">
    <string>Ctrl+Backspace</string>
   </property>
  </action>
  <action name="actionReplaceBody">
   <property name="enabled">
    <bool>false</bool>
   </property>
   <property name="text">
    <string>Replace b&amp;ody...</string>
   </property>
   <property name="toolTip">
    <string>Replace body of selected object with a data from file</string>
   </property>
   <property name="shortcut">
    <string>Ctrl+Shift+R</string>
   </property>
  </action>
  <action name="actionMessagesCopy">
   <property name="enabled">
    <bool>false</bool>
   </property>
   <property name="text">
    <string>&amp;Copy</string>
   </property>
   <property name="shortcut">
    <string>Ctrl+Shift+C</string>
   </property>
  </action>
  <action name="actionMessagesCopyAll">
   <property name="enabled">
    <bool>false</bool>
   </property>
   <property name="text">
    <string>Copy &amp;all</string>
   </property>
   <property name="shortcut">
    <string>Ctrl+Alt+C</string>
   </property>
  </action>
  <action name="actionOpenImageFileInNewWindow">
   <property name="text">
    <string>O&amp;pen image file in new window...</string>
   </property>
   <property name="shortcut">
    <string>Ctrl+Shift+O</string>
   </property>
  </action>
  <action name="actionExtractBodyUncompressed">
   <property name="enabled">
    <bool>false</bool>
   </property>
   <property name="text">
    <string>Extract body &amp;uncompressed...</string>
   </property>
   <property name="toolTip">
    <string>Uncompress and extract body of selected object to file</string>
   </property>
   <property name="shortcut">
    <string>Ctrl+Alt+E</string>
   </property>
  </action>
  <action name="actionGoToData">
   <property name="enabled">
    <bool>false</bool>
   </property>
   <property name="text">
    <string>Go &amp;to data</string>
   </property>
   <property name="shortcut">
    <string>Ctrl+T</string>
   </property>
  </action>
  <action name="actionHexView">
   <property name="enabled">
    <bool>false</bool>
   </property>
   <property name="text">
    <string>Hex &amp;view...</string>
   </property>
   <property name="shortcut">
    <string>Ctrl+D</string>
   </property>
  </action>
  <action name="actionGoToBase">
   <property name="enabled">
    <bool>false</bool>
   </property>
   <property name="text">
    <string>&amp;Select item at base...</string>
   </property>
   <property name="shortcut">
    <string>Ctrl+G</string>
   </property>
  </action>
  <action name="actionBodyHexView">
   <property name="enabled">
    <bool>false</bool>
   </property>
   <property name="text">
    <string>Body hex vie&amp;w...</string>
   </property>
   <property name="shortcut">
    <string>Ctrl+Shift+D</string>
   </property>
  </action>
  <action name="actionLoadGuidDatabase">
   <property name="text">
    <string>Load &amp;GUID database...</string>
   </property>
   <property name="shortcut">
    <string>Ctrl+Alt+G</string>
   </property>
  </action>
  <action name="actionGoToAddress">
   <property name="enabled">
    <bool>false</bool>
   </property>
   <property name="text">
    <string>Select item at &amp;address...</string>
   </property>
   <property name="shortcut">
    <string>Ctrl+Shift+G</string>
   </property>
  </action>
  <action name="actionToggleBootGuardMarking">
   <property name="checkable">
    <bool>true</bool>
   </property>
   <property name="checked">
    <bool>true</bool>
   </property>
   <property name="text">
    <string>BootGuard &amp;markings</string>
   </property>
   <property name="shortcut">
    <string>Ctrl+Shift+B</string>
   </property>
  </action>
  <action name="actionGenerateReport">
   <property name="enabled">
    <bool>false</bool>
   </property>
   <property name="text">
    <string>Generate &amp;report...</string>
   </property>
   <property name="toolTip">
    <string>Generate report</string>
   </property>
   <property name="shortcut">
    <string>Ctrl+Alt+R</string>
   </property>
  </action>
  <action name="actionUnloadGuidDatabase">
   <property name="text">
    <string>&amp;Unload GUID database</string>
   </property>
   <property name="shortcut">
    <string>Ctrl+Alt+U</string>
   </property>
  </action>
  <action name="actionLoadDefaultGuidDatabase">
   <property name="text">
    <string>Load &amp;default GUID database</string>
   </property>
   <property name="shortcut">
    <string>Ctrl+Alt+D</string>
   </property>
  </action>
  <action name="actionExportDiscoveredGuids">
   <property name="enabled">
    <bool>false</bool>
   </property>
   <property name="text">
    <string>&amp;Export discovered GUIDs...</string>
   </property>
   <property name="shortcut">
    <string>Ctrl+Alt+E</string>
   </property>
  </action>
 </widget>
 <layoutdefault spacing="6" margin="11"/>
 <resources/>
 <connections/>
</ui>

```

`efiXloader/3rd/uefitool/UEFITool/uefitool_main.cpp`:

```cpp
/* uefitool_main.cpp

  Copyright (c) 2018, LongSoft. All rights reserved.
  This program and the accompanying materials
  are licensed and made available under the terms and conditions of the BSD License
  which accompanies this distribution.  The full text of the license may be found at
  http://opensource.org/licenses/bsd-license.php

  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

  */

#include <QApplication>
#include <QString>
#include "uefitool.h"

class UEFIToolApplication : public QApplication
{
    UEFITool* tool;

public:
    UEFIToolApplication(int &argc, char **argv)
        : QApplication(argc, argv)
    {
        setOrganizationName("LongSoft");
        setOrganizationDomain("longsoft.org");
        setApplicationName("UEFITool NE");
        
        tool = new UEFITool();
    }
    
    virtual ~UEFIToolApplication() {
        delete tool;
    }
    
    virtual bool event(QEvent *event)
    {
        if (event->type() == QEvent::FileOpen) {
            QFileOpenEvent *openEvent = static_cast<QFileOpenEvent *>(event);
            tool->openImageFile(openEvent->file());
        }

        return QApplication::event(event);
    }
    
    int startup()
    {
        tool->setProgramPath(arguments().at(0));
        if (arguments().length() > 1)
            tool->openImageFile(arguments().at(1));
        tool->show();
        
        return exec();
    }
};

int main(int argc, char *argv[])
{
    UEFIToolApplication a(argc, argv);
    return a.startup();
}

```

`efiXloader/3rd/uefitool/common/LZMA/LzmaCompress.c`:

```c
/* LZMA Compress Implementation

Copyright (c) 2012, Nikolaj Schlej. All rights reserved.
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHWARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

*/

#include "LzmaCompress.h"
#include "SDK/C/7zVersion.h"
#include "SDK/C/LzmaEnc.h"

#include <stdlib.h>

#define LZMA_HEADER_SIZE (LZMA_PROPS_SIZE + 8)

static void * AllocForLzma(void *p, size_t size) { (void)p; return malloc(size); }
static void FreeForLzma(void *p, void *address) { (void)p; free(address); }
static ISzAlloc SzAllocForLzma = { &AllocForLzma, &FreeForLzma };

SRes OnProgress(void *p, UInt64 inSize, UInt64 outSize)
{
    (void)p; (void)inSize; (void)outSize;
    return SZ_OK;
}

static ICompressProgress g_ProgressCallback = { &OnProgress };

STATIC
UINT64
EFIAPI
RShiftU64 (
    UINT64 Operand,
    UINT32 Count
)
{
    return Operand >> Count;
}

VOID
SetEncodedSizeOfBuf(
    UINT64 EncodedSize,
    UINT8* EncodedData
)
{
    INT32   Index;

    EncodedData[LZMA_PROPS_SIZE] = EncodedSize & 0xFF;
    for (Index = LZMA_PROPS_SIZE + 1; Index <= LZMA_PROPS_SIZE + 7; Index++)
    {
        EncodedSize = RShiftU64(EncodedSize, 8);
        EncodedData[Index] = EncodedSize & 0xFF;
    }
}

USTATUS
EFIAPI
LzmaCompress (
    CONST UINT8  *Source,
    UINT32       SourceSize,
    UINT8        *Destination,
    UINT32       *DestinationSize,
    UINT32       DictionarySize
)
{
    SRes              LzmaResult;
    CLzmaEncProps     props;
    SizeT propsSize = LZMA_PROPS_SIZE;
    SizeT destLen = SourceSize + SourceSize / 3 + 128;

    if (*DestinationSize < (UINT32)destLen)
    {
        *DestinationSize = (UINT32)destLen;
        return EFI_BUFFER_TOO_SMALL;
    }

    LzmaEncProps_Init(&props);
    props.dictSize = DictionarySize;
    props.level = 9;
    props.fb = 273;

    LzmaResult = LzmaEncode(
        (Byte*)((UINT8*)Destination + LZMA_HEADER_SIZE),
        &destLen,
        Source,
        (SizeT)SourceSize,
        &props,
        (UINT8*)Destination,
        &propsSize,
        props.writeEndMark,
        &g_ProgressCallback,
        &SzAllocForLzma,
        &SzAllocForLzma);

    *DestinationSize = (UINT32)(destLen + LZMA_HEADER_SIZE);

    SetEncodedSizeOfBuf(SourceSize, Destination);

    if (LzmaResult == SZ_OK) {
        return EFI_SUCCESS;
    }
    else {
        return EFI_INVALID_PARAMETER;
    }
}

```

`efiXloader/3rd/uefitool/common/LZMA/LzmaCompress.h`:

```h
/* LZMA Compress Header

  Copyright (c) 2014, Nikolaj Schlej. All rights reserved.
  This program and the accompanying materials
  are licensed and made available under the terms and conditions of the BSD License
  which accompanies this distribution.  The full text of the license may be found at
  http://opensource.org/licenses/bsd-license.php

  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
  WITHWARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

  */

#ifndef LZMACOMPRESS_H
#define LZMACOMPRESS_H

#include "SDK/C/Types.h"
#include "../basetypes.h"

#ifdef __cplusplus
extern "C" {
#endif

#define DEFAULT_LZMA_DICTIONARY_SIZE 0x800000
#define _LZMA_SIZE_OPT

    USTATUS
        EFIAPI
        LzmaCompress (
            const UINT8  *Source,
            UINT32       SourceSize,
            UINT8        *Destination,
            UINT32       *DestinationSize,
            UINT32        DictionarySize
        );

#ifdef __cplusplus
}
#endif

#endif // LZMACOMPRESS_H

```

`efiXloader/3rd/uefitool/common/LZMA/LzmaDecompress.c`:

```c
/* LZMA Decompress Implementation

Copyright (c) 2009 - 2010, Intel Corporation. All rights reserved.
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHWARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

*/

#include "LzmaDecompress.h"
#include "SDK/C/Types.h"
#include "SDK/C/7zVersion.h"

#include <stdlib.h>

UINT64
EFIAPI
LShiftU64 (
    UINT64 Operand,
    UINT32 Count
    )
{
    return Operand << Count;
}

static void * AllocForLzma(void *p, size_t size) { (void)p; return malloc(size); }
static void FreeForLzma(void *p, void *address) { (void)p; free(address); }
static ISzAlloc SzAllocForLzma = { &AllocForLzma, &FreeForLzma };

/*
Get the size of the uncompressed buffer by parsing EncodeData header.

@param EncodedData  Pointer to the compressed data.

@return The size of the uncompressed buffer.
*/
UINT64
GetDecodedSizeOfBuf (
    UINT8 *EncodedData
    )
{
    UINT64 DecodedSize;
    INT32  Index;

    // Parse header
    DecodedSize = 0;
    for (Index = LZMA_PROPS_SIZE + 7; Index >= LZMA_PROPS_SIZE; Index--)
        DecodedSize = LShiftU64(DecodedSize, 8) + EncodedData[Index];

    return DecodedSize;
}

//
// LZMA functions and data as defined local LzmaDecompressLibInternal.h
//

/*
Given a Lzma compressed source buffer, this function retrieves the size of
the uncompressed buffer and the size of the scratch buffer required
to decompress the compressed source buffer.

Retrieves the size of the uncompressed buffer and the temporary scratch buffer
required to decompress the buffer specified by Source and SourceSize.
The size of the uncompressed buffer is returned DestinationSize,
the size of the scratch buffer is returned ScratchSize, and RETURN_SUCCESS is returned.
This function does not have scratch buffer available to perform a thorough
checking of the validity of the source data. It just retrieves the "Original Size"
field from the LZMA_HEADER_SIZE beginning bytes of the source data and output it as DestinationSize.
And ScratchSize is specific to the decompression implementation.

If SourceSize is less than LZMA_HEADER_SIZE, then ASSERT().

@param  Source          The source buffer containing the compressed data.
@param  SourceSize      The size, bytes, of the source buffer.
@param  DestinationSize A pointer to the size, bytes, of the uncompressed buffer
that will be generated when the compressed buffer specified
by Source and SourceSize is decompressed.

@retval  EFI_SUCCESS The size of the uncompressed data was returned
DestinationSize and the size of the scratch
buffer was returned ScratchSize.

*/
USTATUS
EFIAPI
LzmaGetInfo (
    CONST VOID  *Source,
    UINT32       SourceSize,
    UINT32       *DestinationSize
    )
{
    UINT64 DecodedSize;
    ASSERT(SourceSize >= LZMA_HEADER_SIZE);
    (void)SourceSize;

    DecodedSize = GetDecodedSizeOfBuf((UINT8*)Source);

    if (DecodedSize <= UINT32_MAX) {
        *DestinationSize = (UINT32)DecodedSize;
        return U_SUCCESS;
    }
    else {
        return U_INVALID_PARAMETER;
    }
}

/*
Decompresses a Lzma compressed source buffer.

Extracts decompressed data to its original form.
If the compressed source data specified by Source is successfully decompressed
into Destination, then RETURN_SUCCESS is returned.  If the compressed source data
specified by Source is not a valid compressed data format,
then RETURN_INVALID_PARAMETER is returned.

@param  Source      The source buffer containing the compressed data.
@param  SourceSize  The size of source buffer.
@param  Destination The destination buffer to store the decompressed data

@retval  EFI_SUCCESS Decompression completed successfully, and
the uncompressed buffer is returned Destination.
@retval  EFI_INVALID_PARAMETER
The source buffer specified by Source is corrupted
(not a valid compressed format).
*/
USTATUS
EFIAPI
LzmaDecompress (
    CONST VOID  *Source,
    UINT32      SourceSize,
    VOID        *Destination
    )
{
    SRes              LzmaResult;
    ELzmaStatus       Status;
    SizeT             DecodedBufSize;
    SizeT             EncodedDataSize;

    DecodedBufSize = (SizeT)GetDecodedSizeOfBuf((UINT8*)Source);
    EncodedDataSize = (SizeT)(SourceSize - LZMA_HEADER_SIZE);

    LzmaResult = LzmaDecode(
        (Byte*)Destination,
        &DecodedBufSize,
        (Byte*)((UINT8*)Source + LZMA_HEADER_SIZE),
        &EncodedDataSize,
        (CONST Byte*) Source,
        LZMA_PROPS_SIZE,
        LZMA_FINISH_END,
        &Status,
        &SzAllocForLzma
        );

    if (LzmaResult == SZ_OK) {
        return U_SUCCESS;
    }
    else {
        return U_INVALID_PARAMETER;
    }
}

```

`efiXloader/3rd/uefitool/common/LZMA/LzmaDecompress.h`:

```h
/* LZMA Decompress Header

  Copyright (c) 2009 - 2010, Intel Corporation. All rights reserved.
  This program and the accompanying materials
  are licensed and made available under the terms and conditions of the BSD License
  which accompanies this distribution.  The full text of the license may be found at
  http://opensource.org/licenses/bsd-license.php

  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
  WITHWARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

  */

#ifndef LZMADECOMPRESS_H
#define LZMADECOMPRESS_H

#include "../basetypes.h"
#include "SDK/C/LzmaDec.h"
#include "SDK/C/Bra.h"

#ifdef __cplusplus
extern "C" {
#endif

#define LZMA_HEADER_SIZE (LZMA_PROPS_SIZE + 8)

    /*
      Given a Lzma compressed source buffer, this function retrieves the size of
      the uncompressed buffer and the size of the scratch buffer required
      to decompress the compressed source buffer.

      Retrieves the size of the uncompressed buffer and the temporary scratch buffer
      required to decompress the buffer specified by Source and SourceSize.
      The size of the uncompressed buffer is returned DestinationSize,
      the size of the scratch buffer is returned ScratchSize, and RETURN_SUCCESS is returned.
      This function does not have scratch buffer available to perform a thorough
      checking of the validity of the source data. It just retrieves the "Original Size"
      field from the LZMA_HEADER_SIZE beginning bytes of the source data and output it as DestinationSize.
      And ScratchSize is specific to the decompression implementation.

      If SourceSize is less than LZMA_HEADER_SIZE, then ASSERT().

      @param  Source          The source buffer containing the compressed data.
      @param  SourceSize      The size, bytes, of the source buffer.
      @param  DestinationSize A pointer to the size, bytes, of the uncompressed buffer
      that will be generated when the compressed buffer specified
      by Source and SourceSize is decompressed.

      @retval  EFI_SUCCESS The size of the uncompressed data was returned
      DestinationSize and the size of the scratch
      buffer was returned ScratchSize.

      */
    USTATUS
        EFIAPI
        LzmaGetInfo (
            CONST VOID  *Source,
            UINT32       SourceSize,
            UINT32       *DestinationSize
        );

    /*
      Decompresses a Lzma compressed source buffer.

      Extracts decompressed data to its original form.
      If the compressed source data specified by Source is successfully decompressed
      into Destination, then RETURN_SUCCESS is returned.  If the compressed source data
      specified by Source is not a valid compressed data format,
      then RETURN_INVALID_PARAMETER is returned.

      @param  Source      The source buffer containing the compressed data.
      @param  SourceSize  The size of source buffer.
      @param  Destination The destination buffer to store the decompressed data

      @retval  EFI_SUCCESS Decompression completed successfully, and
      the uncompressed buffer is returned Destination.
      @retval  EFI_INVALID_PARAMETER
      The source buffer specified by Source is corrupted
      (not a valid compressed format).
      */
    USTATUS
        EFIAPI
        LzmaDecompress (
            CONST VOID  *Source,
            UINT32        SourceSize,
            VOID         *Destination
        );

#ifdef __cplusplus
}
#endif

#endif // LZMADECOMPRESS_H

```

`efiXloader/3rd/uefitool/common/LZMA/SDK/C/7zVersion.h`:

```h
#define MY_VER_MAJOR 9
#define MY_VER_MINOR 20
#define MY_VER_BUILD 0
#define MY_VERSION "9.20"
#define MY_DATE "2010-11-18"
#define MY_COPYRIGHT ": Igor Pavlov : Public domain"
#define MY_VERSION_COPYRIGHT_DATE MY_VERSION " " MY_COPYRIGHT " : " MY_DATE

```

`efiXloader/3rd/uefitool/common/LZMA/SDK/C/Bra.h`:

```h
/* Bra.h -- Branch converters for executables
2009-02-07 : Igor Pavlov : Public domain */

#ifndef __BRA_H
#define __BRA_H

#include "Types.h"

#ifdef __cplusplus
extern "C" {
#endif

/*
These functions convert relative addresses to absolute addresses
in CALL instructions to increase the compression ratio.
  
  In:
    data     - data buffer
    size     - size of data
    ip       - current virtual Instruction Pinter (IP) value
    state    - state variable for x86 converter
    encoding - 0 (for decoding), 1 (for encoding)
  
  Out:
    state    - state variable for x86 converter

  Returns:
    The number of processed bytes. If you call these functions with multiple calls,
    you must start next call with first byte after block of processed bytes.
  
  Type   Endian  Alignment  LookAhead
  
  x86    little      1          4
  ARMT   little      2          2
  ARM    little      4          0
  PPC     big        4          0
  SPARC   big        4          0
  IA64   little     16          0

  size must be >= Alignment + LookAhead, if it's not last block.
  If (size < Alignment + LookAhead), converter returns 0.

  Example:

    UInt32 ip = 0;
    for ()
    {
      ; size must be >= Alignment + LookAhead, if it's not last block
      SizeT processed = Convert(data, size, ip, 1);
      data += processed;
      size -= processed;
      ip += processed;
    }
*/

#define x86_Convert_Init(state) { state = 0; }
SizeT x86_Convert(Byte *data, SizeT size, UInt32 ip, UInt32 *state, int encoding);
SizeT ARM_Convert(Byte *data, SizeT size, UInt32 ip, int encoding);
SizeT ARMT_Convert(Byte *data, SizeT size, UInt32 ip, int encoding);
SizeT PPC_Convert(Byte *data, SizeT size, UInt32 ip, int encoding);
SizeT SPARC_Convert(Byte *data, SizeT size, UInt32 ip, int encoding);
SizeT IA64_Convert(Byte *data, SizeT size, UInt32 ip, int encoding);

#ifdef __cplusplus
}
#endif

#endif

```

`efiXloader/3rd/uefitool/common/LZMA/SDK/C/Bra86.c`:

```c
/* Bra86.c -- Converter for x86 code (BCJ)
2008-10-04 : Igor Pavlov : Public domain */

#include "Bra.h"

#define Test86MSByte(b) ((b) == 0 || (b) == 0xFF)

const Byte kMaskToAllowedStatus[8] = {1, 1, 1, 0, 1, 0, 0, 0};
const Byte kMaskToBitNumber[8] = {0, 1, 2, 2, 3, 3, 3, 3};

SizeT x86_Convert(Byte *data, SizeT size, UInt32 ip, UInt32 *state, int encoding)
{
  SizeT bufferPos = 0, prevPosT;
  UInt32 prevMask = *state & 0x7;
  if (size < 5)
    return 0;
  ip += 5;
  prevPosT = (SizeT)0 - 1;

  for (;;)
  {
    Byte *p = data + bufferPos;
    Byte *limit = data + size - 4;
    for (; p < limit; p++)
      if ((*p & 0xFE) == 0xE8)
        break;
    bufferPos = (SizeT)(p - data);
    if (p >= limit)
      break;
    prevPosT = bufferPos - prevPosT;
    if (prevPosT > 3)
      prevMask = 0;
    else
    {
      prevMask = (prevMask << ((int)prevPosT - 1)) & 0x7;
      if (prevMask != 0)
      {
        Byte b = p[4 - kMaskToBitNumber[prevMask]];
        if (!kMaskToAllowedStatus[prevMask] || Test86MSByte(b))
        {
          prevPosT = bufferPos;
          prevMask = ((prevMask << 1) & 0x7) | 1;
          bufferPos++;
          continue;
        }
      }
    }
    prevPosT = bufferPos;

    if (Test86MSByte(p[4]))
    {
      UInt32 src = ((UInt32)p[4] << 24) | ((UInt32)p[3] << 16) | ((UInt32)p[2] << 8) | ((UInt32)p[1]);
      UInt32 dest;
      for (;;)
      {
        Byte b;
        int index;
        if (encoding)
          dest = (ip + (UInt32)bufferPos) + src;
        else
          dest = src - (ip + (UInt32)bufferPos);
        if (prevMask == 0)
          break;
        index = kMaskToBitNumber[prevMask] * 8;
        b = (Byte)(dest >> (24 - index));
        if (!Test86MSByte(b))
          break;
        src = dest ^ ((1 << (32 - index)) - 1);
      }
      p[4] = (Byte)(~(((dest >> 24) & 1) - 1));
      p[3] = (Byte)(dest >> 16);
      p[2] = (Byte)(dest >> 8);
      p[1] = (Byte)dest;
      bufferPos += 5;
    }
    else
    {
      prevMask = ((prevMask << 1) & 0x7) | 1;
      bufferPos++;
    }
  }
  prevPosT = bufferPos - prevPosT;
  *state = ((prevPosT > 3) ? 0 : ((prevMask << ((int)prevPosT - 1)) & 0x7));
  return bufferPos;
}

```

`efiXloader/3rd/uefitool/common/LZMA/SDK/C/CpuArch.h`:

```h
/* CpuArch.h -- CPU specific code
2010-10-26: Igor Pavlov : Public domain */

#ifndef __CPU_ARCH_H
#define __CPU_ARCH_H

#include "Types.h"

EXTERN_C_BEGIN

/*
MY_CPU_LE means that CPU is LITTLE ENDIAN.
If MY_CPU_LE is not defined, we don't know about that property of platform (it can be LITTLE ENDIAN).

MY_CPU_LE_UNALIGN means that CPU is LITTLE ENDIAN and CPU supports unaligned memory accesses.
If MY_CPU_LE_UNALIGN is not defined, we don't know about these properties of platform.
*/

#if defined(_M_X64) || defined(_M_AMD64) || defined(__x86_64__)
#define MY_CPU_AMD64
#endif

#if defined(MY_CPU_AMD64) || defined(_M_IA64)
#define MY_CPU_64BIT
#endif

#if defined(_M_IX86) || defined(__i386__)
#define MY_CPU_X86
#endif

#if defined(MY_CPU_X86) || defined(MY_CPU_AMD64)
#define MY_CPU_X86_OR_AMD64
#endif

#if defined(MY_CPU_X86) || defined(_M_ARM)
#define MY_CPU_32BIT
#endif

#if defined(_WIN32) && defined(_M_ARM)
#define MY_CPU_ARM_LE
#endif

#if defined(_WIN32) && defined(_M_IA64)
#define MY_CPU_IA64_LE
#endif

#if defined(MY_CPU_X86_OR_AMD64)
#define MY_CPU_LE_UNALIGN
#endif

#if defined(MY_CPU_X86_OR_AMD64) || defined(MY_CPU_ARM_LE)  || defined(MY_CPU_IA64_LE) || defined(__ARMEL__) || defined(__MIPSEL__) || defined(__LITTLE_ENDIAN__)
#define MY_CPU_LE
#endif

#if defined(__BIG_ENDIAN__)
#define MY_CPU_BE
#endif

#if defined(MY_CPU_LE) && defined(MY_CPU_BE)
Stop_Compiling_Bad_Endian
#endif

#ifdef MY_CPU_LE_UNALIGN

#define GetUi16(p) (*(const UInt16 *)(p))
#define GetUi32(p) (*(const UInt32 *)(p))
#define GetUi64(p) (*(const UInt64 *)(p))
#define SetUi16(p, d) *(UInt16 *)(p) = (d);
#define SetUi32(p, d) *(UInt32 *)(p) = (d);
#define SetUi64(p, d) *(UInt64 *)(p) = (d);

#else

#define GetUi16(p) (((const Byte *)(p))[0] | ((UInt16)((const Byte *)(p))[1] << 8))

#define GetUi32(p) ( \
             ((const Byte *)(p))[0]        | \
    ((UInt32)((const Byte *)(p))[1] <<  8) | \
    ((UInt32)((const Byte *)(p))[2] << 16) | \
    ((UInt32)((const Byte *)(p))[3] << 24))

#define GetUi64(p) (GetUi32(p) | ((UInt64)GetUi32(((const Byte *)(p)) + 4) << 32))

#define SetUi16(p, d) { UInt32 _x_ = (d); \
    ((Byte *)(p))[0] = (Byte)_x_; \
    ((Byte *)(p))[1] = (Byte)(_x_ >> 8); }

#define SetUi32(p, d) { UInt32 _x_ = (d); \
    ((Byte *)(p))[0] = (Byte)_x_; \
    ((Byte *)(p))[1] = (Byte)(_x_ >> 8); \
    ((Byte *)(p))[2] = (Byte)(_x_ >> 16); \
    ((Byte *)(p))[3] = (Byte)(_x_ >> 24); }

#define SetUi64(p, d) { UInt64 _x64_ = (d); \
    SetUi32(p, (UInt32)_x64_); \
    SetUi32(((Byte *)(p)) + 4, (UInt32)(_x64_ >> 32)); }

#endif

#if defined(MY_CPU_LE_UNALIGN) && defined(_WIN64) && (_MSC_VER >= 1300)

#pragma intrinsic(_byteswap_ulong)
#pragma intrinsic(_byteswap_uint64)
#define GetBe32(p) _byteswap_ulong(*(const UInt32 *)(const Byte *)(p))
#define GetBe64(p) _byteswap_uint64(*(const UInt64 *)(const Byte *)(p))

#else

#define GetBe32(p) ( \
    ((UInt32)((const Byte *)(p))[0] << 24) | \
    ((UInt32)((const Byte *)(p))[1] << 16) | \
    ((UInt32)((const Byte *)(p))[2] <<  8) | \
             ((const Byte *)(p))[3] )

#define GetBe64(p) (((UInt64)GetBe32(p) << 32) | GetBe32(((const Byte *)(p)) + 4))

#endif

#define GetBe16(p) (((UInt16)((const Byte *)(p))[0] << 8) | ((const Byte *)(p))[1])


#ifdef MY_CPU_X86_OR_AMD64

typedef struct
{
  UInt32 maxFunc;
  UInt32 vendor[3];
  UInt32 ver;
  UInt32 b;
  UInt32 c;
  UInt32 d;
} Cx86cpuid;

enum
{
  CPU_FIRM_INTEL,
  CPU_FIRM_AMD,
  CPU_FIRM_VIA
};

Bool x86cpuid_CheckAndRead(Cx86cpuid *p);
int x86cpuid_GetFirm(const Cx86cpuid *p);

#define x86cpuid_GetFamily(p) (((p)->ver >> 8) & 0xFF00F)
#define x86cpuid_GetModel(p) (((p)->ver >> 4) & 0xF00F)
#define x86cpuid_GetStepping(p) ((p)->ver & 0xF)

Bool CPU_Is_InOrder();
Bool CPU_Is_Aes_Supported();

#endif

EXTERN_C_END

#endif

```

`efiXloader/3rd/uefitool/common/LZMA/SDK/C/LzFind.c`:

```c
/* LzFind.c -- Match finder for LZ algorithms
2009-04-22 : Igor Pavlov : Public domain */

#include <string.h>

#include "LzFind.h"
#include "LzHash.h"

#define kEmptyHashValue 0
#define kMaxValForNormalize ((UInt32)0xFFFFFFFF)
#define kNormalizeStepMin (1 << 10) /* it must be power of 2 */
#define kNormalizeMask (~(kNormalizeStepMin - 1))
#define kMaxHistorySize ((UInt32)3 << 30)

#define kStartMaxLen 3

static void LzInWindow_Free(CMatchFinder *p, ISzAlloc *alloc)
{
    if (!p->directInput)
    {
        alloc->Free(alloc, p->bufferBase);
        p->bufferBase = 0;
    }
}

/* keepSizeBefore + keepSizeAfter + keepSizeReserv must be < 4G) */

static int LzInWindow_Create(CMatchFinder *p, UInt32 keepSizeReserv, ISzAlloc *alloc)
{
    UInt32 blockSize = p->keepSizeBefore + p->keepSizeAfter + keepSizeReserv;
    if (p->directInput)
    {
        p->blockSize = blockSize;
        return 1;
    }
    if (p->bufferBase == 0 || p->blockSize != blockSize)
    {
        LzInWindow_Free(p, alloc);
        p->blockSize = blockSize;
        p->bufferBase = (Byte *)alloc->Alloc(alloc, (size_t)blockSize);
    }
    return (p->bufferBase != 0);
}

Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p) { return p->buffer; }
Byte MatchFinder_GetIndexByte(CMatchFinder *p, Int32 index) { return p->buffer[index]; }

UInt32 MatchFinder_GetNumAvailableBytes(CMatchFinder *p) { return p->streamPos - p->pos; }

void MatchFinder_ReduceOffsets(CMatchFinder *p, UInt32 subValue)
{
    p->posLimit -= subValue;
    p->pos -= subValue;
    p->streamPos -= subValue;
}

static void MatchFinder_ReadBlock(CMatchFinder *p)
{
    if (p->streamEndWasReached || p->result != SZ_OK)
        return;
    if (p->directInput)
    {
        UInt32 curSize = 0xFFFFFFFF - p->streamPos;
        if (curSize > p->directInputRem)
            curSize = (UInt32)p->directInputRem;
        p->directInputRem -= curSize;
        p->streamPos += curSize;
        if (p->directInputRem == 0)
            p->streamEndWasReached = 1;
        return;
    }
    for (;;)
    {
        Byte *dest = p->buffer + (p->streamPos - p->pos);
        size_t size = (p->bufferBase + p->blockSize - dest);
        if (size == 0)
            return;
        p->result = p->stream->Read(p->stream, dest, &size);
        if (p->result != SZ_OK)
            return;
        if (size == 0)
        {
            p->streamEndWasReached = 1;
            return;
        }
        p->streamPos += (UInt32)size;
        if (p->streamPos - p->pos > p->keepSizeAfter)
            return;
    }
}

void MatchFinder_MoveBlock(CMatchFinder *p)
{
    memmove(p->bufferBase,
        p->buffer - p->keepSizeBefore,
        (size_t)(p->streamPos - p->pos + p->keepSizeBefore));
    p->buffer = p->bufferBase + p->keepSizeBefore;
}

int MatchFinder_NeedMove(CMatchFinder *p)
{
    if (p->directInput)
        return 0;
    /* if (p->streamEndWasReached) return 0; */
    return ((size_t)(p->bufferBase + p->blockSize - p->buffer) <= p->keepSizeAfter);
}

void MatchFinder_ReadIfRequired(CMatchFinder *p)
{
    if (p->streamEndWasReached)
        return;
    if (p->keepSizeAfter >= p->streamPos - p->pos)
        MatchFinder_ReadBlock(p);
}

static void MatchFinder_CheckAndMoveAndRead(CMatchFinder *p)
{
    if (MatchFinder_NeedMove(p))
        MatchFinder_MoveBlock(p);
    MatchFinder_ReadBlock(p);
}

static void MatchFinder_SetDefaultSettings(CMatchFinder *p)
{
    p->cutValue = 32;
    p->btMode = 1;
    p->numHashBytes = 4;
    p->bigHash = 0;
}

#define kCrcPoly 0xEDB88320

void MatchFinder_Construct(CMatchFinder *p)
{
    UInt32 i;
    p->bufferBase = 0;
    p->directInput = 0;
    p->hash = 0;
    MatchFinder_SetDefaultSettings(p);

    for (i = 0; i < 256; i++)
    {
        UInt32 r = i;
        int j;
        for (j = 0; j < 8; j++)
            r = (r >> 1) ^ (kCrcPoly & ~((r & 1) - 1));
        p->crc[i] = r;
    }
}

static void MatchFinder_FreeThisClassMemory(CMatchFinder *p, ISzAlloc *alloc)
{
    alloc->Free(alloc, p->hash);
    p->hash = 0;
}

void MatchFinder_Free(CMatchFinder *p, ISzAlloc *alloc)
{
    MatchFinder_FreeThisClassMemory(p, alloc);
    LzInWindow_Free(p, alloc);
}

static CLzRef* AllocRefs(UInt32 num, ISzAlloc *alloc)
{
    size_t sizeInBytes = (size_t)num * sizeof(CLzRef);
    if (sizeInBytes / sizeof(CLzRef) != num)
        return 0;
    return (CLzRef *)alloc->Alloc(alloc, sizeInBytes);
}

int MatchFinder_Create(CMatchFinder *p, UInt32 historySize,
    UInt32 keepAddBufferBefore, UInt32 matchMaxLen, UInt32 keepAddBufferAfter,
    ISzAlloc *alloc)
{
    UInt32 sizeReserv;
    if (historySize > kMaxHistorySize)
    {
        MatchFinder_Free(p, alloc);
        return 0;
    }
    sizeReserv = historySize >> 1;
    if (historySize > ((UInt32)2 << 30))
        sizeReserv = historySize >> 2;
    sizeReserv += (keepAddBufferBefore + matchMaxLen + keepAddBufferAfter) / 2 + (1 << 19);

    p->keepSizeBefore = historySize + keepAddBufferBefore + 1;
    p->keepSizeAfter = matchMaxLen + keepAddBufferAfter;
    /* we need one additional byte, since we use MoveBlock after pos++ and before dictionary using */
    if (LzInWindow_Create(p, sizeReserv, alloc))
    {
        UInt32 newCyclicBufferSize = historySize + 1;
        UInt32 hs;
        p->matchMaxLen = matchMaxLen;
        {
            p->fixedHashSize = 0;
            if (p->numHashBytes == 2)
                hs = (1 << 16) - 1;
            else
            {
                hs = historySize - 1;
                hs |= (hs >> 1);
                hs |= (hs >> 2);
                hs |= (hs >> 4);
                hs |= (hs >> 8);
                hs >>= 1;
                hs |= 0xFFFF; /* don't change it! It's required for Deflate */
                if (hs > (1 << 24))
                {
                    if (p->numHashBytes == 3)
                        hs = (1 << 24) - 1;
                    else
                        hs >>= 1;
                }
            }
            p->hashMask = hs;
            hs++;
            if (p->numHashBytes > 2) p->fixedHashSize += kHash2Size;
            if (p->numHashBytes > 3) p->fixedHashSize += kHash3Size;
            if (p->numHashBytes > 4) p->fixedHashSize += kHash4Size;
            hs += p->fixedHashSize;
        }

    {
        UInt32 prevSize = p->hashSizeSum + p->numSons;
        UInt32 newSize;
        p->historySize = historySize;
        p->hashSizeSum = hs;
        p->cyclicBufferSize = newCyclicBufferSize;
        p->numSons = (p->btMode ? newCyclicBufferSize * 2 : newCyclicBufferSize);
        newSize = p->hashSizeSum + p->numSons;
        if (p->hash != 0 && prevSize == newSize)
            return 1;
        MatchFinder_FreeThisClassMemory(p, alloc);
        p->hash = AllocRefs(newSize, alloc);
        if (p->hash != 0)
        {
            p->son = p->hash + p->hashSizeSum;
            return 1;
        }
    }
    }
    MatchFinder_Free(p, alloc);
    return 0;
}

static void MatchFinder_SetLimits(CMatchFinder *p)
{
    UInt32 limit = kMaxValForNormalize - p->pos;
    UInt32 limit2 = p->cyclicBufferSize - p->cyclicBufferPos;
    if (limit2 < limit)
        limit = limit2;
    limit2 = p->streamPos - p->pos;
    if (limit2 <= p->keepSizeAfter)
    {
        if (limit2 > 0)
            limit2 = 1;
    }
    else
        limit2 -= p->keepSizeAfter;
    if (limit2 < limit)
        limit = limit2;
    {
        UInt32 lenLimit = p->streamPos - p->pos;
        if (lenLimit > p->matchMaxLen)
            lenLimit = p->matchMaxLen;
        p->lenLimit = lenLimit;
    }
    p->posLimit = p->pos + limit;
}

void MatchFinder_Init(CMatchFinder *p)
{
    UInt32 i;
    for (i = 0; i < p->hashSizeSum; i++)
        p->hash[i] = kEmptyHashValue;
    p->cyclicBufferPos = 0;
    p->buffer = p->bufferBase;
    p->pos = p->streamPos = p->cyclicBufferSize;
    p->result = SZ_OK;
    p->streamEndWasReached = 0;
    MatchFinder_ReadBlock(p);
    MatchFinder_SetLimits(p);
}

static UInt32 MatchFinder_GetSubValue(CMatchFinder *p)
{
    return (p->pos - p->historySize - 1) & kNormalizeMask;
}

void MatchFinder_Normalize3(UInt32 subValue, CLzRef *items, UInt32 numItems)
{
    UInt32 i;
    for (i = 0; i < numItems; i++)
    {
        UInt32 value = items[i];
        if (value <= subValue)
            value = kEmptyHashValue;
        else
            value -= subValue;
        items[i] = value;
    }
}

static void MatchFinder_Normalize(CMatchFinder *p)
{
    UInt32 subValue = MatchFinder_GetSubValue(p);
    MatchFinder_Normalize3(subValue, p->hash, p->hashSizeSum + p->numSons);
    MatchFinder_ReduceOffsets(p, subValue);
}

static void MatchFinder_CheckLimits(CMatchFinder *p)
{
    if (p->pos == kMaxValForNormalize)
        MatchFinder_Normalize(p);
    if (!p->streamEndWasReached && p->keepSizeAfter == p->streamPos - p->pos)
        MatchFinder_CheckAndMoveAndRead(p);
    if (p->cyclicBufferPos == p->cyclicBufferSize)
        p->cyclicBufferPos = 0;
    MatchFinder_SetLimits(p);
}

static UInt32 * Hc_GetMatchesSpec(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue,
    UInt32 *distances, UInt32 maxLen)
{
    son[_cyclicBufferPos] = curMatch;
    for (;;)
    {
        UInt32 delta = pos - curMatch;
        if (cutValue-- == 0 || delta >= _cyclicBufferSize)
            return distances;
        {
            const Byte *pb = cur - delta;
            curMatch = son[_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)];
            if (pb[maxLen] == cur[maxLen] && *pb == *cur)
            {
                UInt32 len = 0;
                while (++len != lenLimit)
                    if (pb[len] != cur[len])
                        break;
                if (maxLen < len)
                {
                    *distances++ = maxLen = len;
                    *distances++ = delta - 1;
                    if (len == lenLimit)
                        return distances;
                }
            }
        }
    }
}

UInt32 * GetMatchesSpec1(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue,
    UInt32 *distances, UInt32 maxLen)
{
    CLzRef *ptr0 = son + (_cyclicBufferPos << 1) + 1;
    CLzRef *ptr1 = son + (_cyclicBufferPos << 1);
    UInt32 len0 = 0, len1 = 0;
    for (;;)
    {
        UInt32 delta = pos - curMatch;
        if (cutValue-- == 0 || delta >= _cyclicBufferSize)
        {
            *ptr0 = *ptr1 = kEmptyHashValue;
            return distances;
        }
    {
        CLzRef *pair = son + ((_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)) << 1);
        const Byte *pb = cur - delta;
        UInt32 len = (len0 < len1 ? len0 : len1);
        if (pb[len] == cur[len])
        {
            if (++len != lenLimit && pb[len] == cur[len])
                while (++len != lenLimit)
                    if (pb[len] != cur[len])
                        break;
            if (maxLen < len)
            {
                *distances++ = maxLen = len;
                *distances++ = delta - 1;
                if (len == lenLimit)
                {
                    *ptr1 = pair[0];
                    *ptr0 = pair[1];
                    return distances;
                }
            }
        }
        if (pb[len] < cur[len])
        {
            *ptr1 = curMatch;
            ptr1 = pair + 1;
            curMatch = *ptr1;
            len1 = len;
        }
        else
        {
            *ptr0 = curMatch;
            ptr0 = pair;
            curMatch = *ptr0;
            len0 = len;
        }
    }
    }
}

static void SkipMatchesSpec(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue)
{
    CLzRef *ptr0 = son + (_cyclicBufferPos << 1) + 1;
    CLzRef *ptr1 = son + (_cyclicBufferPos << 1);
    UInt32 len0 = 0, len1 = 0;
    for (;;)
    {
        UInt32 delta = pos - curMatch;
        if (cutValue-- == 0 || delta >= _cyclicBufferSize)
        {
            *ptr0 = *ptr1 = kEmptyHashValue;
            return;
        }
    {
        CLzRef *pair = son + ((_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)) << 1);
        const Byte *pb = cur - delta;
        UInt32 len = (len0 < len1 ? len0 : len1);
        if (pb[len] == cur[len])
        {
            while (++len != lenLimit)
                if (pb[len] != cur[len])
                    break;
            {
                if (len == lenLimit)
                {
                    *ptr1 = pair[0];
                    *ptr0 = pair[1];
                    return;
                }
            }
        }
        if (pb[len] < cur[len])
        {
            *ptr1 = curMatch;
            ptr1 = pair + 1;
            curMatch = *ptr1;
            len1 = len;
        }
        else
        {
            *ptr0 = curMatch;
            ptr0 = pair;
            curMatch = *ptr0;
            len0 = len;
        }
    }
    }
}

#define MOVE_POS \
  ++p->cyclicBufferPos; \
  p->buffer++; \
  if (++p->pos == p->posLimit) MatchFinder_CheckLimits(p);

#define MOVE_POS_RET MOVE_POS return offset;

static void MatchFinder_MovePos(CMatchFinder *p) { MOVE_POS; }

#define GET_MATCHES_HEADER2(minLen, ret_op) \
  UInt32 lenLimit; UInt32 hashValue; const Byte *cur; UInt32 curMatch; \
  lenLimit = p->lenLimit; { if (lenLimit < minLen) { MatchFinder_MovePos(p); ret_op; }} \
  cur = p->buffer;

#define GET_MATCHES_HEADER(minLen) GET_MATCHES_HEADER2(minLen, return 0)
#define SKIP_HEADER(minLen)        GET_MATCHES_HEADER2(minLen, continue)

#define MF_PARAMS(p) p->pos, p->buffer, p->son, p->cyclicBufferPos, p->cyclicBufferSize, p->cutValue

#define GET_MATCHES_FOOTER(offset, maxLen) \
  offset = (UInt32)(GetMatchesSpec1(lenLimit, curMatch, MF_PARAMS(p), \
  distances + offset, maxLen) - distances); MOVE_POS_RET;

#define SKIP_FOOTER \
  SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p)); MOVE_POS;

static UInt32 Bt2_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
{
    UInt32 offset;
    GET_MATCHES_HEADER(2)
        HASH2_CALC;
    curMatch = p->hash[hashValue];
    p->hash[hashValue] = p->pos;
    offset = 0;
    GET_MATCHES_FOOTER(offset, 1)
}

UInt32 Bt3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
{
    UInt32 offset;
    GET_MATCHES_HEADER(3)
        HASH_ZIP_CALC;
    curMatch = p->hash[hashValue];
    p->hash[hashValue] = p->pos;
    offset = 0;
    GET_MATCHES_FOOTER(offset, 2)
}

static UInt32 Bt3_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
{
    UInt32 hash2Value, delta2, maxLen, offset;
    GET_MATCHES_HEADER(3)

        HASH3_CALC;

    delta2 = p->pos - p->hash[hash2Value];
    curMatch = p->hash[kFix3HashSize + hashValue];

    p->hash[hash2Value] =
        p->hash[kFix3HashSize + hashValue] = p->pos;

    maxLen = 2;
    offset = 0;
    if (delta2 < p->cyclicBufferSize && *(cur - delta2) == *cur)
    {
        for (; maxLen != lenLimit; maxLen++)
            if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
                break;
        distances[0] = maxLen;
        distances[1] = delta2 - 1;
        offset = 2;
        if (maxLen == lenLimit)
        {
            SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p));
            MOVE_POS_RET;
        }
    }
    GET_MATCHES_FOOTER(offset, maxLen)
}

static UInt32 Bt4_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
{
    UInt32 hash2Value, hash3Value, delta2, delta3, maxLen, offset;
    GET_MATCHES_HEADER(4)

        HASH4_CALC;

    delta2 = p->pos - p->hash[hash2Value];
    delta3 = p->pos - p->hash[kFix3HashSize + hash3Value];
    curMatch = p->hash[kFix4HashSize + hashValue];

    p->hash[hash2Value] =
        p->hash[kFix3HashSize + hash3Value] =
        p->hash[kFix4HashSize + hashValue] = p->pos;

    maxLen = 1;
    offset = 0;
    if (delta2 < p->cyclicBufferSize && *(cur - delta2) == *cur)
    {
        distances[0] = maxLen = 2;
        distances[1] = delta2 - 1;
        offset = 2;
    }
    if (delta2 != delta3 && delta3 < p->cyclicBufferSize && *(cur - delta3) == *cur)
    {
        maxLen = 3;
        distances[offset + 1] = delta3 - 1;
        offset += 2;
        delta2 = delta3;
    }
    if (offset != 0)
    {
        for (; maxLen != lenLimit; maxLen++)
            if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
                break;
        distances[offset - 2] = maxLen;
        if (maxLen == lenLimit)
        {
            SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p));
            MOVE_POS_RET;
        }
    }
    if (maxLen < 3)
        maxLen = 3;
    GET_MATCHES_FOOTER(offset, maxLen)
}

static UInt32 Hc4_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
{
    UInt32 hash2Value, hash3Value, delta2, delta3, maxLen, offset;
    GET_MATCHES_HEADER(4)

        HASH4_CALC;

    delta2 = p->pos - p->hash[hash2Value];
    delta3 = p->pos - p->hash[kFix3HashSize + hash3Value];
    curMatch = p->hash[kFix4HashSize + hashValue];

    p->hash[hash2Value] =
        p->hash[kFix3HashSize + hash3Value] =
        p->hash[kFix4HashSize + hashValue] = p->pos;

    maxLen = 1;
    offset = 0;
    if (delta2 < p->cyclicBufferSize && *(cur - delta2) == *cur)
    {
        distances[0] = maxLen = 2;
        distances[1] = delta2 - 1;
        offset = 2;
    }
    if (delta2 != delta3 && delta3 < p->cyclicBufferSize && *(cur - delta3) == *cur)
    {
        maxLen = 3;
        distances[offset + 1] = delta3 - 1;
        offset += 2;
        delta2 = delta3;
    }
    if (offset != 0)
    {
        for (; maxLen != lenLimit; maxLen++)
            if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
                break;
        distances[offset - 2] = maxLen;
        if (maxLen == lenLimit)
        {
            p->son[p->cyclicBufferPos] = curMatch;
            MOVE_POS_RET;
        }
    }
    if (maxLen < 3)
        maxLen = 3;
    offset = (UInt32)(Hc_GetMatchesSpec(lenLimit, curMatch, MF_PARAMS(p),
        distances + offset, maxLen) - (distances));
    MOVE_POS_RET
}

UInt32 Hc3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
{
    UInt32 offset;
    GET_MATCHES_HEADER(3)
        HASH_ZIP_CALC;
    curMatch = p->hash[hashValue];
    p->hash[hashValue] = p->pos;
    offset = (UInt32)(Hc_GetMatchesSpec(lenLimit, curMatch, MF_PARAMS(p),
        distances, 2) - (distances));
    MOVE_POS_RET
}

static void Bt2_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
{
    do
    {
        SKIP_HEADER(2)
            HASH2_CALC;
        curMatch = p->hash[hashValue];
        p->hash[hashValue] = p->pos;
        SKIP_FOOTER
    } while (--num != 0);
}

void Bt3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
{
    do
    {
        SKIP_HEADER(3)
            HASH_ZIP_CALC;
        curMatch = p->hash[hashValue];
        p->hash[hashValue] = p->pos;
        SKIP_FOOTER
    } while (--num != 0);
}

static void Bt3_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
{
    do
    {
        UInt32 hash2Value;
        SKIP_HEADER(3)
            HASH3_CALC;
        curMatch = p->hash[kFix3HashSize + hashValue];
        p->hash[hash2Value] =
            p->hash[kFix3HashSize + hashValue] = p->pos;
        SKIP_FOOTER
    } while (--num != 0);
}

static void Bt4_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
{
    do
    {
        UInt32 hash2Value, hash3Value;
        SKIP_HEADER(4)
            HASH4_CALC;
        curMatch = p->hash[kFix4HashSize + hashValue];
        p->hash[hash2Value] =
            p->hash[kFix3HashSize + hash3Value] = p->pos;
        p->hash[kFix4HashSize + hashValue] = p->pos;
        SKIP_FOOTER
    } while (--num != 0);
}

static void Hc4_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
{
    do
    {
        UInt32 hash2Value, hash3Value;
        SKIP_HEADER(4)
            HASH4_CALC;
        curMatch = p->hash[kFix4HashSize + hashValue];
        p->hash[hash2Value] =
            p->hash[kFix3HashSize + hash3Value] =
            p->hash[kFix4HashSize + hashValue] = p->pos;
        p->son[p->cyclicBufferPos] = curMatch;
        MOVE_POS
    } while (--num != 0);
}

void Hc3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
{
    do
    {
        SKIP_HEADER(3)
            HASH_ZIP_CALC;
        curMatch = p->hash[hashValue];
        p->hash[hashValue] = p->pos;
        p->son[p->cyclicBufferPos] = curMatch;
        MOVE_POS
    } while (--num != 0);
}

void MatchFinder_CreateVTable(CMatchFinder *p, IMatchFinder *vTable)
{
    vTable->Init = (Mf_Init_Func)MatchFinder_Init;
    vTable->GetIndexByte = (Mf_GetIndexByte_Func)MatchFinder_GetIndexByte;
    vTable->GetNumAvailableBytes = (Mf_GetNumAvailableBytes_Func)MatchFinder_GetNumAvailableBytes;
    vTable->GetPointerToCurrentPos = (Mf_GetPointerToCurrentPos_Func)MatchFinder_GetPointerToCurrentPos;
    if (!p->btMode)
    {
        vTable->GetMatches = (Mf_GetMatches_Func)Hc4_MatchFinder_GetMatches;
        vTable->Skip = (Mf_Skip_Func)Hc4_MatchFinder_Skip;
    }
    else if (p->numHashBytes == 2)
    {
        vTable->GetMatches = (Mf_GetMatches_Func)Bt2_MatchFinder_GetMatches;
        vTable->Skip = (Mf_Skip_Func)Bt2_MatchFinder_Skip;
    }
    else if (p->numHashBytes == 3)
    {
        vTable->GetMatches = (Mf_GetMatches_Func)Bt3_MatchFinder_GetMatches;
        vTable->Skip = (Mf_Skip_Func)Bt3_MatchFinder_Skip;
    }
    else
    {
        vTable->GetMatches = (Mf_GetMatches_Func)Bt4_MatchFinder_GetMatches;
        vTable->Skip = (Mf_Skip_Func)Bt4_MatchFinder_Skip;
    }
}
```

`efiXloader/3rd/uefitool/common/LZMA/SDK/C/LzFind.h`:

```h
/* LzFind.h -- Match finder for LZ algorithms
2009-04-22 : Igor Pavlov : Public domain */

#ifndef __LZ_FIND_H
#define __LZ_FIND_H

#include "Types.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef UInt32 CLzRef;

typedef struct _CMatchFinder
{
  Byte *buffer;
  UInt32 pos;
  UInt32 posLimit;
  UInt32 streamPos;
  UInt32 lenLimit;

  UInt32 cyclicBufferPos;
  UInt32 cyclicBufferSize; /* it must be = (historySize + 1) */

  UInt32 matchMaxLen;
  CLzRef *hash;
  CLzRef *son;
  UInt32 hashMask;
  UInt32 cutValue;

  Byte *bufferBase;
  ISeqInStream *stream;
  int streamEndWasReached;

  UInt32 blockSize;
  UInt32 keepSizeBefore;
  UInt32 keepSizeAfter;

  UInt32 numHashBytes;
  int directInput;
  size_t directInputRem;
  int btMode;
  int bigHash;
  UInt32 historySize;
  UInt32 fixedHashSize;
  UInt32 hashSizeSum;
  UInt32 numSons;
  SRes result;
  UInt32 crc[256];
} CMatchFinder;

#define Inline_MatchFinder_GetPointerToCurrentPos(p) ((p)->buffer)
#define Inline_MatchFinder_GetIndexByte(p, index) ((p)->buffer[(Int32)(index)])

#define Inline_MatchFinder_GetNumAvailableBytes(p) ((p)->streamPos - (p)->pos)

int MatchFinder_NeedMove(CMatchFinder *p);
Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p);
void MatchFinder_MoveBlock(CMatchFinder *p);
void MatchFinder_ReadIfRequired(CMatchFinder *p);

void MatchFinder_Construct(CMatchFinder *p);

/* Conditions:
     historySize <= 3 GB
     keepAddBufferBefore + matchMaxLen + keepAddBufferAfter < 511MB
*/
int MatchFinder_Create(CMatchFinder *p, UInt32 historySize,
    UInt32 keepAddBufferBefore, UInt32 matchMaxLen, UInt32 keepAddBufferAfter,
    ISzAlloc *alloc);
void MatchFinder_Free(CMatchFinder *p, ISzAlloc *alloc);
void MatchFinder_Normalize3(UInt32 subValue, CLzRef *items, UInt32 numItems);
void MatchFinder_ReduceOffsets(CMatchFinder *p, UInt32 subValue);

UInt32 * GetMatchesSpec1(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *buffer, CLzRef *son,
    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 _cutValue,
    UInt32 *distances, UInt32 maxLen);

/*
Conditions:
  Mf_GetNumAvailableBytes_Func must be called before each Mf_GetMatchLen_Func.
  Mf_GetPointerToCurrentPos_Func's result must be used only before any other function
*/

typedef void (*Mf_Init_Func)(void *object);
typedef Byte (*Mf_GetIndexByte_Func)(void *object, Int32 index);
typedef UInt32 (*Mf_GetNumAvailableBytes_Func)(void *object);
typedef const Byte * (*Mf_GetPointerToCurrentPos_Func)(void *object);
typedef UInt32 (*Mf_GetMatches_Func)(void *object, UInt32 *distances);
typedef void (*Mf_Skip_Func)(void *object, UInt32);

typedef struct _IMatchFinder
{
  Mf_Init_Func Init;
  Mf_GetIndexByte_Func GetIndexByte;
  Mf_GetNumAvailableBytes_Func GetNumAvailableBytes;
  Mf_GetPointerToCurrentPos_Func GetPointerToCurrentPos;
  Mf_GetMatches_Func GetMatches;
  Mf_Skip_Func Skip;
} IMatchFinder;

void MatchFinder_CreateVTable(CMatchFinder *p, IMatchFinder *vTable);

void MatchFinder_Init(CMatchFinder *p);
UInt32 Bt3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances);
UInt32 Hc3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances);
void Bt3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num);
void Hc3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num);

#ifdef __cplusplus
}
#endif

#endif

```

`efiXloader/3rd/uefitool/common/LZMA/SDK/C/LzHash.h`:

```h
/* LzHash.h -- HASH functions for LZ algorithms
2009-02-07 : Igor Pavlov : Public domain */

#ifndef __LZ_HASH_H
#define __LZ_HASH_H

#define kHash2Size (1 << 10)
#define kHash3Size (1 << 16)
#define kHash4Size (1 << 20)

#define kFix3HashSize (kHash2Size)
#define kFix4HashSize (kHash2Size + kHash3Size)
#define kFix5HashSize (kHash2Size + kHash3Size + kHash4Size)

#define HASH2_CALC hashValue = cur[0] | ((UInt32)cur[1] << 8);

#define HASH3_CALC { \
  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
  hash2Value = temp & (kHash2Size - 1); \
  hashValue = (temp ^ ((UInt32)cur[2] << 8)) & p->hashMask; }

#define HASH4_CALC { \
  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
  hash2Value = temp & (kHash2Size - 1); \
  hash3Value = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); \
  hashValue = (temp ^ ((UInt32)cur[2] << 8) ^ (p->crc[cur[3]] << 5)) & p->hashMask; }

#define HASH5_CALC { \
  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
  hash2Value = temp & (kHash2Size - 1); \
  hash3Value = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); \
  hash4Value = (temp ^ ((UInt32)cur[2] << 8) ^ (p->crc[cur[3]] << 5)); \
  hashValue = (hash4Value ^ (p->crc[cur[4]] << 3)) & p->hashMask; \
  hash4Value &= (kHash4Size - 1); }

/* #define HASH_ZIP_CALC hashValue = ((cur[0] | ((UInt32)cur[1] << 8)) ^ p->crc[cur[2]]) & 0xFFFF; */
#define HASH_ZIP_CALC hashValue = ((cur[2] | ((UInt32)cur[0] << 8)) ^ p->crc[cur[1]]) & 0xFFFF;


#define MT_HASH2_CALC \
  hash2Value = (p->crc[cur[0]] ^ cur[1]) & (kHash2Size - 1);

#define MT_HASH3_CALC { \
  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
  hash2Value = temp & (kHash2Size - 1); \
  hash3Value = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); }

#define MT_HASH4_CALC { \
  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
  hash2Value = temp & (kHash2Size - 1); \
  hash3Value = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); \
  hash4Value = (temp ^ ((UInt32)cur[2] << 8) ^ (p->crc[cur[3]] << 5)) & (kHash4Size - 1); }

#endif

```

`efiXloader/3rd/uefitool/common/LZMA/SDK/C/LzmaDec.c`:

```c
/* LzmaDec.c -- LZMA Decoder
2009-09-20 : Igor Pavlov : Public domain*/

#include "LzmaDec.h"

#include <string.h>

#define kNumTopBits 24
#define kTopValue ((UInt32)1 << kNumTopBits)

#define kNumBitModelTotalBits 11
#define kBitModelTotal (1 << kNumBitModelTotalBits)
#define kNumMoveBits 5

#define RC_INIT_SIZE 5

#define NORMALIZE if (range < kTopValue) { range <<= 8; code = (code << 8) | (*buf++); }

#define IF_BIT_0(p) ttt = *(p); NORMALIZE; bound = (range >> kNumBitModelTotalBits) * ttt; if (code < bound)
#define UPDATE_0(p) range = bound; *(p) = (CLzmaProb)(ttt + ((kBitModelTotal - ttt) >> kNumMoveBits));
#define UPDATE_1(p) range -= bound; code -= bound; *(p) = (CLzmaProb)(ttt - (ttt >> kNumMoveBits));
#define GET_BIT2(p, i, A0, A1) IF_BIT_0(p) \
    { UPDATE_0(p); i = (i + i); A0; } else \
    { UPDATE_1(p); i = (i + i) + 1; A1; }
#define GET_BIT(p, i) GET_BIT2(p, i, ; , ;)

#define TREE_GET_BIT(probs, i) { GET_BIT((probs + i), i); }
#define TREE_DECODE(probs, limit, i) \
    { i = 1; do { TREE_GET_BIT(probs, i); } while (i < limit); i -= limit; }

/* #define _LZMA_SIZE_OPT */

#ifdef _LZMA_SIZE_OPT
#define TREE_6_DECODE(probs, i) TREE_DECODE(probs, (1 << 6), i)
#else
#define TREE_6_DECODE(probs, i) \
    { i = 1; \
  TREE_GET_BIT(probs, i); \
  TREE_GET_BIT(probs, i); \
  TREE_GET_BIT(probs, i); \
  TREE_GET_BIT(probs, i); \
  TREE_GET_BIT(probs, i); \
  TREE_GET_BIT(probs, i); \
  i -= 0x40; }
#endif

#define NORMALIZE_CHECK if (range < kTopValue) { if (buf >= bufLimit) return DUMMY_ERROR; range <<= 8; code = (code << 8) | (*buf++); }

#define IF_BIT_0_CHECK(p) ttt = *(p); NORMALIZE_CHECK; bound = (range >> kNumBitModelTotalBits) * ttt; if (code < bound)
#define UPDATE_0_CHECK range = bound;
#define UPDATE_1_CHECK range -= bound; code -= bound;
#define GET_BIT2_CHECK(p, i, A0, A1) IF_BIT_0_CHECK(p) \
    { UPDATE_0_CHECK; i = (i + i); A0; } else \
    { UPDATE_1_CHECK; i = (i + i) + 1; A1; }
#define GET_BIT_CHECK(p, i) GET_BIT2_CHECK(p, i, ; , ;)
#define TREE_DECODE_CHECK(probs, limit, i) \
    { i = 1; do { GET_BIT_CHECK(probs + i, i) } while (i < limit); i -= limit; }

#define kNumPosBitsMax 4
#define kNumPosStatesMax (1 << kNumPosBitsMax)

#define kLenNumLowBits 3
#define kLenNumLowSymbols (1 << kLenNumLowBits)
#define kLenNumMidBits 3
#define kLenNumMidSymbols (1 << kLenNumMidBits)
#define kLenNumHighBits 8
#define kLenNumHighSymbols (1 << kLenNumHighBits)

#define LenChoice 0
#define LenChoice2 (LenChoice + 1)
#define LenLow (LenChoice2 + 1)
#define LenMid (LenLow + (kNumPosStatesMax << kLenNumLowBits))
#define LenHigh (LenMid + (kNumPosStatesMax << kLenNumMidBits))
#define kNumLenProbs (LenHigh + kLenNumHighSymbols)

#define kNumStates 12
#define kNumLitStates 7

#define kStartPosModelIndex 4
#define kEndPosModelIndex 14
#define kNumFullDistances (1 << (kEndPosModelIndex >> 1))

#define kNumPosSlotBits 6
#define kNumLenToPosStates 4

#define kNumAlignBits 4
#define kAlignTableSize (1 << kNumAlignBits)

#define kMatchMinLen 2
#define kMatchSpecLenStart (kMatchMinLen + kLenNumLowSymbols + kLenNumMidSymbols + kLenNumHighSymbols)

#define IsMatch 0
#define IsRep (IsMatch + (kNumStates << kNumPosBitsMax))
#define IsRepG0 (IsRep + kNumStates)
#define IsRepG1 (IsRepG0 + kNumStates)
#define IsRepG2 (IsRepG1 + kNumStates)
#define IsRep0Long (IsRepG2 + kNumStates)
#define PosSlot (IsRep0Long + (kNumStates << kNumPosBitsMax))
#define SpecPos (PosSlot + (kNumLenToPosStates << kNumPosSlotBits))
#define Align (SpecPos + kNumFullDistances - kEndPosModelIndex)
#define LenCoder (Align + kAlignTableSize)
#define RepLenCoder (LenCoder + kNumLenProbs)
#define Literal (RepLenCoder + kNumLenProbs)

#define LZMA_BASE_SIZE 1846
#define LZMA_LIT_SIZE 768

#define LzmaProps_GetNumProbs(p) ((UInt32)LZMA_BASE_SIZE + (LZMA_LIT_SIZE << ((p)->lc + (p)->lp)))

#if Literal != LZMA_BASE_SIZE
StopCompilingDueBUG
#endif

#define LZMA_DIC_MIN (1 << 12)

/* First LZMA-symbol is always decoded.
And it decodes new LZMA-symbols while (buf < bufLimit), but "buf" is with last normalization
Out:
Result:
SZ_OK - OK
SZ_ERROR_DATA - Error
p->remainLen:
< kMatchSpecLenStart : normal remain
= kMatchSpecLenStart : finished
= kMatchSpecLenStart + 1 : Flush marker
= kMatchSpecLenStart + 2 : State Init Marker
*/

static int MY_FAST_CALL LzmaDec_DecodeReal(CLzmaDec *p, SizeT limit, const Byte *bufLimit)
{
    CLzmaProb *probs = p->probs;

    unsigned state = p->state;
    UInt32 rep0 = p->reps[0], rep1 = p->reps[1], rep2 = p->reps[2], rep3 = p->reps[3];
    unsigned pbMask = ((unsigned)1 << (p->prop.pb)) - 1;
    unsigned lpMask = ((unsigned)1 << (p->prop.lp)) - 1;
    unsigned lc = p->prop.lc;

    Byte *dic = p->dic;
    SizeT dicBufSize = p->dicBufSize;
    SizeT dicPos = p->dicPos;

    UInt32 processedPos = p->processedPos;
    UInt32 checkDicSize = p->checkDicSize;
    unsigned len = 0;

    const Byte *buf = p->buf;
    UInt32 range = p->range;
    UInt32 code = p->code;

    do
    {
        CLzmaProb *prob;
        UInt32 bound;
        unsigned ttt;
        unsigned posState = processedPos & pbMask;

        prob = probs + IsMatch + (state << kNumPosBitsMax) + posState;
        IF_BIT_0(prob)
        {
            unsigned symbol;
            UPDATE_0(prob);
            prob = probs + Literal;
            if (checkDicSize != 0 || processedPos != 0)
                prob += (LZMA_LIT_SIZE * (((processedPos & lpMask) << lc) +
                (dic[(dicPos == 0 ? dicBufSize : dicPos) - 1] >> (8 - lc))));

            if (state < kNumLitStates)
            {
                state -= (state < 4) ? state : 3;
                symbol = 1;
                do { GET_BIT(prob + symbol, symbol) } while (symbol < 0x100);
            }
            else
            {
                unsigned matchByte = p->dic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];
                unsigned offs = 0x100;
                state -= (state < 10) ? 3 : 6;
                symbol = 1;
                do
                {
                    unsigned bit;
                    CLzmaProb *probLit;
                    matchByte <<= 1;
                    bit = (matchByte & offs);
                    probLit = prob + offs + bit + symbol;
                    GET_BIT2(probLit, symbol, offs &= ~bit, offs &= bit)
                } while (symbol < 0x100);
            }
            dic[dicPos++] = (Byte)symbol;
            processedPos++;
            continue;
        }
else
{
    UPDATE_1(prob);
    prob = probs + IsRep + state;
    IF_BIT_0(prob)
    {
        UPDATE_0(prob);
        state += kNumStates;
        prob = probs + LenCoder;
    }
else
{
    UPDATE_1(prob);
    if (checkDicSize == 0 && processedPos == 0)
        return SZ_ERROR_DATA;
    prob = probs + IsRepG0 + state;
    IF_BIT_0(prob)
    {
        UPDATE_0(prob);
        prob = probs + IsRep0Long + (state << kNumPosBitsMax) + posState;
        IF_BIT_0(prob)
        {
            UPDATE_0(prob);
            dic[dicPos] = dic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];
            dicPos++;
            processedPos++;
            state = state < kNumLitStates ? 9 : 11;
            continue;
        }
        UPDATE_1(prob);
    }
    else
    {
        UInt32 distance;
        UPDATE_1(prob);
        prob = probs + IsRepG1 + state;
        IF_BIT_0(prob)
        {
            UPDATE_0(prob);
            distance = rep1;
        }
          else
          {
              UPDATE_1(prob);
              prob = probs + IsRepG2 + state;
              IF_BIT_0(prob)
              {
                  UPDATE_0(prob);
                  distance = rep2;
              }
            else
            {
                UPDATE_1(prob);
                distance = rep3;
                rep3 = rep2;
            }
            rep2 = rep1;
          }
          rep1 = rep0;
          rep0 = distance;
    }
    state = state < kNumLitStates ? 8 : 11;
    prob = probs + RepLenCoder;
}
      {
          unsigned limit, offset;
          CLzmaProb *probLen = prob + LenChoice;
          IF_BIT_0(probLen)
          {
              UPDATE_0(probLen);
              probLen = prob + LenLow + (posState << kLenNumLowBits);
              offset = 0;
              limit = (1 << kLenNumLowBits);
          }
        else
        {
            UPDATE_1(probLen);
            probLen = prob + LenChoice2;
            IF_BIT_0(probLen)
            {
                UPDATE_0(probLen);
                probLen = prob + LenMid + (posState << kLenNumMidBits);
                offset = kLenNumLowSymbols;
                limit = (1 << kLenNumMidBits);
            }
          else
          {
              UPDATE_1(probLen);
              probLen = prob + LenHigh;
              offset = kLenNumLowSymbols + kLenNumMidSymbols;
              limit = (1 << kLenNumHighBits);
          }
        }
        TREE_DECODE(probLen, limit, len);
        len += offset;
      }

if (state >= kNumStates)
{
    UInt32 distance;
    prob = probs + PosSlot +
        ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) << kNumPosSlotBits);
    TREE_6_DECODE(prob, distance);
    if (distance >= kStartPosModelIndex)
    {
        unsigned posSlot = (unsigned)distance;
        int numDirectBits = (int)(((distance >> 1) - 1));
        distance = (2 | (distance & 1));
        if (posSlot < kEndPosModelIndex)
        {
            distance <<= numDirectBits;
            prob = probs + SpecPos + distance - posSlot - 1;
            {
                UInt32 mask = 1;
                unsigned i = 1;
                do
                {
                    GET_BIT2(prob + i, i, ;, distance |= mask);
                    mask <<= 1;
                } while (--numDirectBits != 0);
            }
        }
        else
        {
            numDirectBits -= kNumAlignBits;
            do
            {
                NORMALIZE
                    range >>= 1;

                {
                    UInt32 t;
                    code -= range;
                    t = (0 - ((UInt32)code >> 31)); /* (UInt32)((Int32)code >> 31) */
                    distance = (distance << 1) + (t + 1);
                    code += range & t;
                }
                /*
                distance <<= 1;
                if (code >= range)
                {
                code -= range;
                distance |= 1;
                }
                */
            } while (--numDirectBits != 0);
            prob = probs + Align;
            distance <<= kNumAlignBits;
            {
                unsigned i = 1;
                GET_BIT2(prob + i, i, ;, distance |= 1);
                GET_BIT2(prob + i, i, ;, distance |= 2);
                GET_BIT2(prob + i, i, ;, distance |= 4);
                GET_BIT2(prob + i, i, ;, distance |= 8);
            }
            if (distance == (UInt32)0xFFFFFFFF)
            {
                len += kMatchSpecLenStart;
                state -= kNumStates;
                break;
            }
        }
    }
    rep3 = rep2;
    rep2 = rep1;
    rep1 = rep0;
    rep0 = distance + 1;
    if (checkDicSize == 0)
    {
        if (distance >= processedPos)
            return SZ_ERROR_DATA;
    }
    else if (distance >= checkDicSize)
        return SZ_ERROR_DATA;
    state = (state < kNumStates + kNumLitStates) ? kNumLitStates : kNumLitStates + 3;
}

len += kMatchMinLen;

if (limit == dicPos)
return SZ_ERROR_DATA;
{
    SizeT rem = limit - dicPos;
    unsigned curLen = ((rem < len) ? (unsigned)rem : len);
    SizeT pos = (dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0);

    processedPos += curLen;

    len -= curLen;
    if (pos + curLen <= dicBufSize)
    {
        Byte *dest = dic + dicPos;
        ptrdiff_t src = (ptrdiff_t)pos - (ptrdiff_t)dicPos;
        const Byte *lim = dest + curLen;
        dicPos += curLen;
        do
            *(dest) = (Byte)*(dest + src);
        while (++dest != lim);
    }
    else
    {
        do
        {
            dic[dicPos++] = dic[pos];
            if (++pos == dicBufSize)
                pos = 0;
        } while (--curLen != 0);
    }
}
}
    } while (dicPos < limit && buf < bufLimit);
    NORMALIZE;
    p->buf = buf;
    p->range = range;
    p->code = code;
    p->remainLen = len;
    p->dicPos = dicPos;
    p->processedPos = processedPos;
    p->reps[0] = rep0;
    p->reps[1] = rep1;
    p->reps[2] = rep2;
    p->reps[3] = rep3;
    p->state = state;

    return SZ_OK;
}

static void MY_FAST_CALL LzmaDec_WriteRem(CLzmaDec *p, SizeT limit)
{
    if (p->remainLen != 0 && p->remainLen < kMatchSpecLenStart)
    {
        Byte *dic = p->dic;
        SizeT dicPos = p->dicPos;
        SizeT dicBufSize = p->dicBufSize;
        unsigned len = p->remainLen;
        UInt32 rep0 = p->reps[0];
        if (limit - dicPos < len)
            len = (unsigned)(limit - dicPos);

        if (p->checkDicSize == 0 && p->prop.dicSize - p->processedPos <= len)
            p->checkDicSize = p->prop.dicSize;

        p->processedPos += len;
        p->remainLen -= len;
        while (len-- != 0)
        {
            dic[dicPos] = dic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];
            dicPos++;
        }
        p->dicPos = dicPos;
    }
}

static int MY_FAST_CALL LzmaDec_DecodeReal2(CLzmaDec *p, SizeT limit, const Byte *bufLimit)
{
    do
    {
        SizeT limit2 = limit;
        if (p->checkDicSize == 0)
        {
            UInt32 rem = p->prop.dicSize - p->processedPos;
            if (limit - p->dicPos > rem)
                limit2 = p->dicPos + rem;
        }
        RINOK(LzmaDec_DecodeReal(p, limit2, bufLimit));
        if (p->processedPos >= p->prop.dicSize)
            p->checkDicSize = p->prop.dicSize;
        LzmaDec_WriteRem(p, limit);
    } while (p->dicPos < limit && p->buf < bufLimit && p->remainLen < kMatchSpecLenStart);

    if (p->remainLen > kMatchSpecLenStart)
    {
        p->remainLen = kMatchSpecLenStart;
    }
    return 0;
}

typedef enum
{
    DUMMY_ERROR, /* unexpected end of input stream */
    DUMMY_LIT,
    DUMMY_MATCH,
    DUMMY_REP
} ELzmaDummy;

static ELzmaDummy LzmaDec_TryDummy(const CLzmaDec *p, const Byte *buf, SizeT inSize)
{
    UInt32 range = p->range;
    UInt32 code = p->code;
    const Byte *bufLimit = buf + inSize;
    CLzmaProb *probs = p->probs;
    unsigned state = p->state;
    ELzmaDummy res;

    {
        CLzmaProb *prob;
        UInt32 bound;
        unsigned ttt;
        unsigned posState = (p->processedPos) & ((1 << p->prop.pb) - 1);

        prob = probs + IsMatch + (state << kNumPosBitsMax) + posState;
        IF_BIT_0_CHECK(prob)
        {
            UPDATE_0_CHECK

                /* if (bufLimit - buf >= 7) return DUMMY_LIT; */

                prob = probs + Literal;
            if (p->checkDicSize != 0 || p->processedPos != 0)
                prob += (LZMA_LIT_SIZE *
                ((((p->processedPos) & ((1 << (p->prop.lp)) - 1)) << p->prop.lc) +
                (p->dic[(p->dicPos == 0 ? p->dicBufSize : p->dicPos) - 1] >> (8 - p->prop.lc))));

            if (state < kNumLitStates)
            {
                unsigned symbol = 1;
                do { GET_BIT_CHECK(prob + symbol, symbol) } while (symbol < 0x100);
            }
            else
            {
                unsigned matchByte = p->dic[p->dicPos - p->reps[0] +
                    ((p->dicPos < p->reps[0]) ? p->dicBufSize : 0)];
                unsigned offs = 0x100;
                unsigned symbol = 1;
                do
                {
                    unsigned bit;
                    CLzmaProb *probLit;
                    matchByte <<= 1;
                    bit = (matchByte & offs);
                    probLit = prob + offs + bit + symbol;
                    GET_BIT2_CHECK(probLit, symbol, offs &= ~bit, offs &= bit)
                } while (symbol < 0x100);
            }
            res = DUMMY_LIT;
        }
else
{
    unsigned len;
    UPDATE_1_CHECK;

    prob = probs + IsRep + state;
    IF_BIT_0_CHECK(prob)
    {
        UPDATE_0_CHECK;
        state = 0;
        prob = probs + LenCoder;
        res = DUMMY_MATCH;
    }
else
{
    UPDATE_1_CHECK;
    res = DUMMY_REP;
    prob = probs + IsRepG0 + state;
    IF_BIT_0_CHECK(prob)
    {
        UPDATE_0_CHECK;
        prob = probs + IsRep0Long + (state << kNumPosBitsMax) + posState;
        IF_BIT_0_CHECK(prob)
        {
            UPDATE_0_CHECK;
            NORMALIZE_CHECK;
            return DUMMY_REP;
        }
          else
          {
              UPDATE_1_CHECK;
          }
    }
        else
        {
            UPDATE_1_CHECK;
            prob = probs + IsRepG1 + state;
            IF_BIT_0_CHECK(prob)
            {
                UPDATE_0_CHECK;
            }
          else
          {
              UPDATE_1_CHECK;
              prob = probs + IsRepG2 + state;
              IF_BIT_0_CHECK(prob)
              {
                  UPDATE_0_CHECK;
              }
            else
            {
                UPDATE_1_CHECK;
            }
          }
        }
        state = kNumStates;
        prob = probs + RepLenCoder;
}
      {
          unsigned limit, offset;
          CLzmaProb *probLen = prob + LenChoice;
          IF_BIT_0_CHECK(probLen)
          {
              UPDATE_0_CHECK;
              probLen = prob + LenLow + (posState << kLenNumLowBits);
              offset = 0;
              limit = 1 << kLenNumLowBits;
          }
        else
        {
            UPDATE_1_CHECK;
            probLen = prob + LenChoice2;
            IF_BIT_0_CHECK(probLen)
            {
                UPDATE_0_CHECK;
                probLen = prob + LenMid + (posState << kLenNumMidBits);
                offset = kLenNumLowSymbols;
                limit = 1 << kLenNumMidBits;
            }
          else
          {
              UPDATE_1_CHECK;
              probLen = prob + LenHigh;
              offset = kLenNumLowSymbols + kLenNumMidSymbols;
              limit = 1 << kLenNumHighBits;
          }
        }
        TREE_DECODE_CHECK(probLen, limit, len);
        len += offset;
      }

if (state < 4)
{
    unsigned posSlot;
    prob = probs + PosSlot +
        ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) <<
        kNumPosSlotBits);
    TREE_DECODE_CHECK(prob, 1 << kNumPosSlotBits, posSlot);
    if (posSlot >= kStartPosModelIndex)
    {
        int numDirectBits = ((posSlot >> 1) - 1);

        /* if (bufLimit - buf >= 8) return DUMMY_MATCH; */

        if (posSlot < kEndPosModelIndex)
        {
            prob = probs + SpecPos + ((2 | (posSlot & 1)) << numDirectBits) - posSlot - 1;
        }
        else
        {
            numDirectBits -= kNumAlignBits;
            do
            {
                NORMALIZE_CHECK
                    range >>= 1;
                code -= range & (((code - range) >> 31) - 1);
                /* if (code >= range) code -= range; */
            } while (--numDirectBits != 0);
            prob = probs + Align;
            numDirectBits = kNumAlignBits;
        }
          {
              unsigned i = 1;
              do
              {
                  GET_BIT_CHECK(prob + i, i);
              } while (--numDirectBits != 0);
          }
    }
}
}
    }
    NORMALIZE_CHECK;
    return res;
}

static void LzmaDec_InitRc(CLzmaDec *p, const Byte *data)
{
    p->code = ((UInt32)data[1] << 24) | ((UInt32)data[2] << 16) | ((UInt32)data[3] << 8) | ((UInt32)data[4]);
    p->range = 0xFFFFFFFF;
    p->needFlush = 0;
}

void LzmaDec_InitDicAndState(CLzmaDec *p, Bool initDic, Bool initState)
{
    p->needFlush = 1;
    p->remainLen = 0;
    p->tempBufSize = 0;

    if (initDic)
    {
        p->processedPos = 0;
        p->checkDicSize = 0;
        p->needInitState = 1;
    }
    if (initState)
        p->needInitState = 1;
}

void LzmaDec_Init(CLzmaDec *p)
{
    p->dicPos = 0;
    LzmaDec_InitDicAndState(p, True, True);
}

static void LzmaDec_InitStateReal(CLzmaDec *p)
{
    UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE << (p->prop.lc + p->prop.lp));
    UInt32 i;
    CLzmaProb *probs = p->probs;
    for (i = 0; i < numProbs; i++)
        probs[i] = kBitModelTotal >> 1;
    p->reps[0] = p->reps[1] = p->reps[2] = p->reps[3] = 1;
    p->state = 0;
    p->needInitState = 0;
}

SRes LzmaDec_DecodeToDic(CLzmaDec *p, SizeT dicLimit, const Byte *src, SizeT *srcLen,
    ELzmaFinishMode finishMode, ELzmaStatus *status)
{
    SizeT inSize = *srcLen;
    (*srcLen) = 0;
    LzmaDec_WriteRem(p, dicLimit);

    *status = LZMA_STATUS_NOT_SPECIFIED;

    while (p->remainLen != kMatchSpecLenStart)
    {
        int checkEndMarkNow;

        if (p->needFlush != 0)
        {
            for (; inSize > 0 && p->tempBufSize < RC_INIT_SIZE; (*srcLen)++, inSize--)
                p->tempBuf[p->tempBufSize++] = *src++;
            if (p->tempBufSize < RC_INIT_SIZE)
            {
                *status = LZMA_STATUS_NEEDS_MORE_INPUT;
                return SZ_OK;
            }
            if (p->tempBuf[0] != 0)
                return SZ_ERROR_DATA;

            LzmaDec_InitRc(p, p->tempBuf);
            p->tempBufSize = 0;
        }

        checkEndMarkNow = 0;
        if (p->dicPos >= dicLimit)
        {
            if (p->remainLen == 0 && p->code == 0)
            {
                *status = LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK;
                return SZ_OK;
            }
            if (finishMode == LZMA_FINISH_ANY)
            {
                *status = LZMA_STATUS_NOT_FINISHED;
                return SZ_OK;
            }
            if (p->remainLen != 0)
            {
                *status = LZMA_STATUS_NOT_FINISHED;
                return SZ_ERROR_DATA;
            }
            checkEndMarkNow = 1;
        }

        if (p->needInitState)
            LzmaDec_InitStateReal(p);

        if (p->tempBufSize == 0)
        {
            SizeT processed;
            const Byte *bufLimit;
            if (inSize < LZMA_REQUIRED_INPUT_MAX || checkEndMarkNow)
            {
                int dummyRes = LzmaDec_TryDummy(p, src, inSize);
                if (dummyRes == DUMMY_ERROR)
                {
                    memcpy(p->tempBuf, src, inSize);
                    p->tempBufSize = (unsigned)inSize;
                    (*srcLen) += inSize;
                    *status = LZMA_STATUS_NEEDS_MORE_INPUT;
                    return SZ_OK;
                }
                if (checkEndMarkNow && dummyRes != DUMMY_MATCH)
                {
                    *status = LZMA_STATUS_NOT_FINISHED;
                    return SZ_ERROR_DATA;
                }
                bufLimit = src;
            }
            else
                bufLimit = src + inSize - LZMA_REQUIRED_INPUT_MAX;
            p->buf = src;
            if (LzmaDec_DecodeReal2(p, dicLimit, bufLimit) != 0)
                return SZ_ERROR_DATA;
            processed = (SizeT)(p->buf - src);
            (*srcLen) += processed;
            src += processed;
            inSize -= processed;
        }
        else
        {
            unsigned rem = p->tempBufSize, lookAhead = 0;
            while (rem < LZMA_REQUIRED_INPUT_MAX && lookAhead < inSize)
                p->tempBuf[rem++] = src[lookAhead++];
            p->tempBufSize = rem;
            if (rem < LZMA_REQUIRED_INPUT_MAX || checkEndMarkNow)
            {
                int dummyRes = LzmaDec_TryDummy(p, p->tempBuf, rem);
                if (dummyRes == DUMMY_ERROR)
                {
                    (*srcLen) += lookAhead;
                    *status = LZMA_STATUS_NEEDS_MORE_INPUT;
                    return SZ_OK;
                }
                if (checkEndMarkNow && dummyRes != DUMMY_MATCH)
                {
                    *status = LZMA_STATUS_NOT_FINISHED;
                    return SZ_ERROR_DATA;
                }
            }
            p->buf = p->tempBuf;
            if (LzmaDec_DecodeReal2(p, dicLimit, p->buf) != 0)
                return SZ_ERROR_DATA;
            lookAhead -= (rem - (unsigned)(p->buf - p->tempBuf));
            (*srcLen) += lookAhead;
            src += lookAhead;
            inSize -= lookAhead;
            p->tempBufSize = 0;
        }
    }
    if (p->code == 0)
        *status = LZMA_STATUS_FINISHED_WITH_MARK;
    return (p->code == 0) ? SZ_OK : SZ_ERROR_DATA;
}

SRes LzmaDec_DecodeToBuf(CLzmaDec *p, Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status)
{
    SizeT outSize = *destLen;
    SizeT inSize = *srcLen;
    *srcLen = *destLen = 0;
    for (;;)
    {
        SizeT inSizeCur = inSize, outSizeCur, dicPos;
        ELzmaFinishMode curFinishMode;
        SRes res;
        if (p->dicPos == p->dicBufSize)
            p->dicPos = 0;
        dicPos = p->dicPos;
        if (outSize > p->dicBufSize - dicPos)
        {
            outSizeCur = p->dicBufSize;
            curFinishMode = LZMA_FINISH_ANY;
        }
        else
        {
            outSizeCur = dicPos + outSize;
            curFinishMode = finishMode;
        }

        res = LzmaDec_DecodeToDic(p, outSizeCur, src, &inSizeCur, curFinishMode, status);
        src += inSizeCur;
        inSize -= inSizeCur;
        *srcLen += inSizeCur;
        outSizeCur = p->dicPos - dicPos;
        memcpy(dest, p->dic + dicPos, outSizeCur);
        dest += outSizeCur;
        outSize -= outSizeCur;
        *destLen += outSizeCur;
        if (res != 0)
            return res;
        if (outSizeCur == 0 || outSize == 0)
            return SZ_OK;
    }
}

void LzmaDec_FreeProbs(CLzmaDec *p, ISzAlloc *alloc)
{
    alloc->Free(alloc, p->probs);
    p->probs = 0;
}

static void LzmaDec_FreeDict(CLzmaDec *p, ISzAlloc *alloc)
{
    alloc->Free(alloc, p->dic);
    p->dic = 0;
}

void LzmaDec_Free(CLzmaDec *p, ISzAlloc *alloc)
{
    LzmaDec_FreeProbs(p, alloc);
    LzmaDec_FreeDict(p, alloc);
}

SRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size)
{
    UInt32 dicSize;
    Byte d;

    if (size < LZMA_PROPS_SIZE)
        return SZ_ERROR_UNSUPPORTED;
    else
        dicSize = data[1] | ((UInt32)data[2] << 8) | ((UInt32)data[3] << 16) | ((UInt32)data[4] << 24);

    if (dicSize < LZMA_DIC_MIN)
        dicSize = LZMA_DIC_MIN;
    p->dicSize = dicSize;

    d = data[0];
    if (d >= (9 * 5 * 5))
        return SZ_ERROR_UNSUPPORTED;

    p->lc = d % 9;
    d /= 9;
    p->pb = d / 5;
    p->lp = d % 5;

    return SZ_OK;
}

static SRes LzmaDec_AllocateProbs2(CLzmaDec *p, const CLzmaProps *propNew, ISzAlloc *alloc)
{
    UInt32 numProbs = LzmaProps_GetNumProbs(propNew);
    if (p->probs == 0 || numProbs != p->numProbs)
    {
        LzmaDec_FreeProbs(p, alloc);
        p->probs = (CLzmaProb *)alloc->Alloc(alloc, numProbs * sizeof(CLzmaProb));
        p->numProbs = numProbs;
        if (p->probs == 0)
            return SZ_ERROR_MEM;
    }
    return SZ_OK;
}

SRes LzmaDec_AllocateProbs(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc)
{
    CLzmaProps propNew;
    RINOK(LzmaProps_Decode(&propNew, props, propsSize));
    RINOK(LzmaDec_AllocateProbs2(p, &propNew, alloc));
    p->prop = propNew;
    return SZ_OK;
}

SRes LzmaDec_Allocate(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc)
{
    CLzmaProps propNew;
    SizeT dicBufSize;
    RINOK(LzmaProps_Decode(&propNew, props, propsSize));
    RINOK(LzmaDec_AllocateProbs2(p, &propNew, alloc));
    dicBufSize = propNew.dicSize;
    if (p->dic == 0 || dicBufSize != p->dicBufSize)
    {
        LzmaDec_FreeDict(p, alloc);
        p->dic = (Byte *)alloc->Alloc(alloc, dicBufSize);
        if (p->dic == 0)
        {
            LzmaDec_FreeProbs(p, alloc);
            return SZ_ERROR_MEM;
        }
    }
    p->dicBufSize = dicBufSize;
    p->prop = propNew;
    return SZ_OK;
}

SRes LzmaDecode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen,
    const Byte *propData, unsigned propSize, ELzmaFinishMode finishMode,
    ELzmaStatus *status, ISzAlloc *alloc)
{
    CLzmaDec p;
    SRes res;
    SizeT inSize = *srcLen;
    SizeT outSize = *destLen;
    *srcLen = *destLen = 0;
    if (inSize < RC_INIT_SIZE)
        return SZ_ERROR_INPUT_EOF;

    LzmaDec_Construct(&p);
    res = LzmaDec_AllocateProbs(&p, propData, propSize, alloc);
    if (res != 0)
        return res;
    p.dic = dest;
    p.dicBufSize = outSize;

    LzmaDec_Init(&p);

    *srcLen = inSize;
    res = LzmaDec_DecodeToDic(&p, outSize, src, srcLen, finishMode, status);

    if (res == SZ_OK && *status == LZMA_STATUS_NEEDS_MORE_INPUT)
        res = SZ_ERROR_INPUT_EOF;

    (*destLen) = p.dicPos;
    LzmaDec_FreeProbs(&p, alloc);
    return res;
}
```

`efiXloader/3rd/uefitool/common/LZMA/SDK/C/LzmaDec.h`:

```h
/* LzmaDec.h -- LZMA Decoder
2009-02-07 : Igor Pavlov : Public domain */

#ifndef __LZMA_DEC_H
#define __LZMA_DEC_H

#include "Types.h"

#ifdef __cplusplus
extern "C" {
#endif

/* #define _LZMA_PROB32 */
/* _LZMA_PROB32 can increase the speed on some CPUs,
   but memory usage for CLzmaDec::probs will be doubled in that case */

#ifdef _LZMA_PROB32
#define CLzmaProb UInt32
#else
#define CLzmaProb UInt16
#endif


/* ---------- LZMA Properties ---------- */

#define LZMA_PROPS_SIZE 5

typedef struct _CLzmaProps
{
  unsigned lc, lp, pb;
  UInt32 dicSize;
} CLzmaProps;

/* LzmaProps_Decode - decodes properties
Returns:
  SZ_OK
  SZ_ERROR_UNSUPPORTED - Unsupported properties
*/

SRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size);


/* ---------- LZMA Decoder state ---------- */

/* LZMA_REQUIRED_INPUT_MAX = number of required input bytes for worst case.
   Num bits = log2((2^11 / 31) ^ 22) + 26 < 134 + 26 = 160; */

#define LZMA_REQUIRED_INPUT_MAX 20

typedef struct
{
  CLzmaProps prop;
  CLzmaProb *probs;
  Byte *dic;
  const Byte *buf;
  UInt32 range, code;
  SizeT dicPos;
  SizeT dicBufSize;
  UInt32 processedPos;
  UInt32 checkDicSize;
  unsigned state;
  UInt32 reps[4];
  unsigned remainLen;
  int needFlush;
  int needInitState;
  UInt32 numProbs;
  unsigned tempBufSize;
  Byte tempBuf[LZMA_REQUIRED_INPUT_MAX];
} CLzmaDec;

#define LzmaDec_Construct(p) { (p)->dic = 0; (p)->probs = 0; }

void LzmaDec_Init(CLzmaDec *p);

/* There are two types of LZMA streams:
     0) Stream with end mark. That end mark adds about 6 bytes to compressed size.
     1) Stream without end mark. You must know exact uncompressed size to decompress such stream. */

typedef enum
{
  LZMA_FINISH_ANY,   /* finish at any point */
  LZMA_FINISH_END    /* block must be finished at the end */
} ELzmaFinishMode;

/* ELzmaFinishMode has meaning only if the decoding reaches output limit !!!

   You must use LZMA_FINISH_END, when you know that current output buffer
   covers last bytes of block. In other cases you must use LZMA_FINISH_ANY.

   If LZMA decoder sees end marker before reaching output limit, it returns SZ_OK,
   and output value of destLen will be less than output buffer size limit.
   You can check status result also.

   You can use multiple checks to test data integrity after full decompression:
     1) Check Result and "status" variable.
     2) Check that output(destLen) = uncompressedSize, if you know real uncompressedSize.
     3) Check that output(srcLen) = compressedSize, if you know real compressedSize.
        You must use correct finish mode in that case. */

typedef enum
{
  LZMA_STATUS_NOT_SPECIFIED,               /* use main error code instead */
  LZMA_STATUS_FINISHED_WITH_MARK,          /* stream was finished with end mark. */
  LZMA_STATUS_NOT_FINISHED,                /* stream was not finished */
  LZMA_STATUS_NEEDS_MORE_INPUT,            /* you must provide more input bytes */
  LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK  /* there is probability that stream was finished without end mark */
} ELzmaStatus;

/* ELzmaStatus is used only as output value for function call */


/* ---------- Interfaces ---------- */

/* There are 3 levels of interfaces:
     1) Dictionary Interface
     2) Buffer Interface
     3) One Call Interface
   You can select any of these interfaces, but don't mix functions from different
   groups for same object. */


/* There are two variants to allocate state for Dictionary Interface:
     1) LzmaDec_Allocate / LzmaDec_Free
     2) LzmaDec_AllocateProbs / LzmaDec_FreeProbs
   You can use variant 2, if you set dictionary buffer manually.
   For Buffer Interface you must always use variant 1.

LzmaDec_Allocate* can return:
  SZ_OK
  SZ_ERROR_MEM         - Memory allocation error
  SZ_ERROR_UNSUPPORTED - Unsupported properties
*/
   
SRes LzmaDec_AllocateProbs(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc);
void LzmaDec_FreeProbs(CLzmaDec *p, ISzAlloc *alloc);

SRes LzmaDec_Allocate(CLzmaDec *state, const Byte *prop, unsigned propsSize, ISzAlloc *alloc);
void LzmaDec_Free(CLzmaDec *state, ISzAlloc *alloc);

/* ---------- Dictionary Interface ---------- */

/* You can use it, if you want to eliminate the overhead for data copying from
   dictionary to some other external buffer.
   You must work with CLzmaDec variables directly in this interface.

   STEPS:
     LzmaDec_Constr()
     LzmaDec_Allocate()
     for (each new stream)
     {
       LzmaDec_Init()
       while (it needs more decompression)
       {
         LzmaDec_DecodeToDic()
         use data from CLzmaDec::dic and update CLzmaDec::dicPos
       }
     }
     LzmaDec_Free()
*/

/* LzmaDec_DecodeToDic
   
   The decoding to internal dictionary buffer (CLzmaDec::dic).
   You must manually update CLzmaDec::dicPos, if it reaches CLzmaDec::dicBufSize !!!

finishMode:
  It has meaning only if the decoding reaches output limit (dicLimit).
  LZMA_FINISH_ANY - Decode just dicLimit bytes.
  LZMA_FINISH_END - Stream must be finished after dicLimit.

Returns:
  SZ_OK
    status:
      LZMA_STATUS_FINISHED_WITH_MARK
      LZMA_STATUS_NOT_FINISHED
      LZMA_STATUS_NEEDS_MORE_INPUT
      LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK
  SZ_ERROR_DATA - Data error
*/

SRes LzmaDec_DecodeToDic(CLzmaDec *p, SizeT dicLimit,
    const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);


/* ---------- Buffer Interface ---------- */

/* It's zlib-like interface.
   See LzmaDec_DecodeToDic description for information about STEPS and return results,
   but you must use LzmaDec_DecodeToBuf instead of LzmaDec_DecodeToDic and you don't need
   to work with CLzmaDec variables manually.

finishMode:
  It has meaning only if the decoding reaches output limit (*destLen).
  LZMA_FINISH_ANY - Decode just destLen bytes.
  LZMA_FINISH_END - Stream must be finished after (*destLen).
*/

SRes LzmaDec_DecodeToBuf(CLzmaDec *p, Byte *dest, SizeT *destLen,
    const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);


/* ---------- One Call Interface ---------- */

/* LzmaDecode

finishMode:
  It has meaning only if the decoding reaches output limit (*destLen).
  LZMA_FINISH_ANY - Decode just destLen bytes.
  LZMA_FINISH_END - Stream must be finished after (*destLen).

Returns:
  SZ_OK
    status:
      LZMA_STATUS_FINISHED_WITH_MARK
      LZMA_STATUS_NOT_FINISHED
      LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK
  SZ_ERROR_DATA - Data error
  SZ_ERROR_MEM  - Memory allocation error
  SZ_ERROR_UNSUPPORTED - Unsupported properties
  SZ_ERROR_INPUT_EOF - It needs more bytes in input buffer (src).
*/

SRes LzmaDecode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen,
    const Byte *propData, unsigned propSize, ELzmaFinishMode finishMode,
    ELzmaStatus *status, ISzAlloc *alloc);

#ifdef __cplusplus
}
#endif

#endif

```

`efiXloader/3rd/uefitool/common/LZMA/SDK/C/LzmaEnc.c`:

```c
/* LzmaEnc.c -- LZMA Encoder
2010-04-16 : Igor Pavlov : Public domain*/

#include <string.h>

/* #define SHOW_STAT */
/* #define SHOW_STAT2 */

#if defined(SHOW_STAT) || defined(SHOW_STAT2)
#include <stdio.h>
#endif

#include "LzmaEnc.h"

#include "LzFind.h"
#ifndef _7ZIP_ST
#include "LzFindMt.h"
#endif

#ifdef SHOW_STAT
static int ttt = 0;
#endif

#define kBlockSizeMax ((1 << LZMA_NUM_BLOCK_SIZE_BITS) - 1)

#define kBlockSize (9 << 10)
#define kUnpackBlockSize (1 << 18)
#define kMatchArraySize (1 << 21)
#define kMatchRecordMaxSize ((LZMA_MATCH_LEN_MAX * 2 + 3) * LZMA_MATCH_LEN_MAX)

#define kNumMaxDirectBits (31)

#define kNumTopBits 24
#define kTopValue ((UInt32)1 << kNumTopBits)

#define kNumBitModelTotalBits 11
#define kBitModelTotal (1 << kNumBitModelTotalBits)
#define kNumMoveBits 5
#define kProbInitValue (kBitModelTotal >> 1)

#define kNumMoveReducingBits 4
#define kNumBitPriceShiftBits 4
#define kBitPrice (1 << kNumBitPriceShiftBits)

void LzmaEncProps_Init(CLzmaEncProps *p)
{
    p->level = 5;
    p->dictSize = p->mc = 0;
    p->lc = p->lp = p->pb = p->algo = p->fb = p->btMode = p->numHashBytes = p->numThreads = -1;
    p->writeEndMark = 0;
}

void LzmaEncProps_Normalize(CLzmaEncProps *p)
{
    int level = p->level;
    if (level < 0) level = 5;
    p->level = level;
    if (p->dictSize == 0) p->dictSize = (level <= 5 ? (1 << (level * 2 + 14)) : (level == 6 ? (1 << 25) : (1 << 26)));
    if (p->lc < 0) p->lc = 3;
    if (p->lp < 0) p->lp = 0;
    if (p->pb < 0) p->pb = 2;
    if (p->algo < 0) p->algo = (level < 5 ? 0 : 1);
    if (p->fb < 0) p->fb = (level < 7 ? 32 : 64);
    if (p->btMode < 0) p->btMode = (p->algo == 0 ? 0 : 1);
    if (p->numHashBytes < 0) p->numHashBytes = 4;
    if (p->mc == 0)  p->mc = (16 + (p->fb >> 1)) >> (p->btMode ? 0 : 1);
    if (p->numThreads < 0)
        p->numThreads =
#ifndef _7ZIP_ST
        ((p->btMode && p->algo) ? 2 : 1);
#else
        1;
#endif
}

UInt32 LzmaEncProps_GetDictSize(const CLzmaEncProps *props2)
{
    CLzmaEncProps props = *props2;
    LzmaEncProps_Normalize(&props);
    return props.dictSize;
}

/* #define LZMA_LOG_BSR */
/* Define it for Intel's CPU */

#ifdef LZMA_LOG_BSR

#define kDicLogSizeMaxCompress 30

#define BSR2_RET(pos, res) { unsigned long i; _BitScanReverse(&i, (pos)); res = (i + i) + ((pos >> (i - 1)) & 1); }

UInt32 GetPosSlot1(UInt32 pos)
{
    UInt32 res;
    BSR2_RET(pos, res);
    return res;
}
#define GetPosSlot2(pos, res) { BSR2_RET(pos, res); }
#define GetPosSlot(pos, res) { if (pos < 2) res = pos; else BSR2_RET(pos, res); }

#else

#define kNumLogBits (9 + (int)sizeof(size_t) / 2)
#define kDicLogSizeMaxCompress ((kNumLogBits - 1) * 2 + 7)

void LzmaEnc_FastPosInit(Byte *g_FastPos)
{
    int c = 2, slotFast;
    g_FastPos[0] = 0;
    g_FastPos[1] = 1;

    for (slotFast = 2; slotFast < kNumLogBits * 2; slotFast++)
    {
        UInt32 k = (1 << ((slotFast >> 1) - 1));
        UInt32 j;
        for (j = 0; j < k; j++, c++)
            g_FastPos[c] = (Byte)slotFast;
    }
}

#define BSR2_RET(pos, res) { UInt32 i = 6 + ((kNumLogBits - 1) & \
  (0 - (((((UInt32)1 << (kNumLogBits + 6)) - 1) - pos) >> 31))); \
  res = p->g_FastPos[pos >> i] + (i * 2); }
/*
#define BSR2_RET(pos, res) { res = (pos < (1 << (kNumLogBits + 6))) ? \
  p->g_FastPos[pos >> 6] + 12 : \
  p->g_FastPos[pos >> (6 + kNumLogBits - 1)] + (6 + (kNumLogBits - 1)) * 2; }
  */

#define GetPosSlot1(pos) p->g_FastPos[pos]
#define GetPosSlot2(pos, res) { BSR2_RET(pos, res); }
#define GetPosSlot(pos, res) { if (pos < kNumFullDistances) res = p->g_FastPos[pos]; else BSR2_RET(pos, res); }

#endif

#define LZMA_NUM_REPS 4

typedef unsigned CState;

typedef struct
{
    UInt32 price;

    CState state;
    int prev1IsChar;
    int prev2;

    UInt32 posPrev2;
    UInt32 backPrev2;

    UInt32 posPrev;
    UInt32 backPrev;
    UInt32 backs[LZMA_NUM_REPS];
} COptimal;

#define kNumOpts (1 << 12)

#define kNumLenToPosStates 4
#define kNumPosSlotBits 6
#define kDicLogSizeM0
#define kDicLogSizeMax 32
#define kDistTableSizeMax (kDicLogSizeMax * 2)

#define kNumAlignBits 4
#define kAlignTableSize (1 << kNumAlignBits)
#define kAlignMask (kAlignTableSize - 1)

#define kStartPosModelIndex 4
#define kEndPosModelIndex 14
#define kNumPosModels (kEndPosModelIndex - kStartPosModelIndex)

#define kNumFullDistances (1 << (kEndPosModelIndex >> 1))

#ifdef _LZMA_PROB32
#define CLzmaProb UInt32
#else
#define CLzmaProb UInt16
#endif

#define LZMA_PB_MAX 4
#define LZMA_LC_MAX 8
#define LZMA_LP_MAX 4

#define LZMA_NUM_PB_STATES_MAX (1 << LZMA_PB_MAX)

#define kLenNumLowBits 3
#define kLenNumLowSymbols (1 << kLenNumLowBits)
#define kLenNumMidBits 3
#define kLenNumMidSymbols (1 << kLenNumMidBits)
#define kLenNumHighBits 8
#define kLenNumHighSymbols (1 << kLenNumHighBits)

#define kLenNumSymbolsTotal (kLenNumLowSymbols + kLenNumMidSymbols + kLenNumHighSymbols)

#define LZMA_MATCH_LEN_MIN 2
#define LZMA_MATCH_LEN_MAX (LZMA_MATCH_LEN_MIN + kLenNumSymbolsTotal - 1)

#define kNumStates 12

typedef struct
{
    CLzmaProb choice;
    CLzmaProb choice2;
    CLzmaProb low[LZMA_NUM_PB_STATES_MAX << kLenNumLowBits];
    CLzmaProb mid[LZMA_NUM_PB_STATES_MAX << kLenNumMidBits];
    CLzmaProb high[kLenNumHighSymbols];
} CLenEnc;

typedef struct
{
    CLenEnc p;
    UInt32 prices[LZMA_NUM_PB_STATES_MAX][kLenNumSymbolsTotal];
    UInt32 tableSize;
    UInt32 counters[LZMA_NUM_PB_STATES_MAX];
} CLenPriceEnc;

typedef struct
{
    UInt32 range;
    Byte cache;
    UInt64 low;
    UInt64 cacheSize;
    Byte *buf;
    Byte *bufLim;
    Byte *bufBase;
    ISeqOutStream *outStream;
    UInt64 processed;
    SRes res;
} CRangeEnc;

typedef struct
{
    CLzmaProb *litProbs;

    CLzmaProb isMatch[kNumStates][LZMA_NUM_PB_STATES_MAX];
    CLzmaProb isRep[kNumStates];
    CLzmaProb isRepG0[kNumStates];
    CLzmaProb isRepG1[kNumStates];
    CLzmaProb isRepG2[kNumStates];
    CLzmaProb isRep0Long[kNumStates][LZMA_NUM_PB_STATES_MAX];

    CLzmaProb posSlotEncoder[kNumLenToPosStates][1 << kNumPosSlotBits];
    CLzmaProb posEncoders[kNumFullDistances - kEndPosModelIndex];
    CLzmaProb posAlignEncoder[1 << kNumAlignBits];

    CLenPriceEnc lenEnc;
    CLenPriceEnc repLenEnc;

    UInt32 reps[LZMA_NUM_REPS];
    UInt32 state;
} CSaveState;

typedef struct
{
    IMatchFinder matchFinder;
    void *matchFinderObj;

#ifndef _7ZIP_ST
    Bool mtMode;
    CMatchFinderMt matchFinderMt;
#endif

    CMatchFinder matchFinderBase;

#ifndef _7ZIP_ST
    Byte pad[128];
#endif

    UInt32 optimumEndIndex;
    UInt32 optimumCurrentIndex;

    UInt32 longestMatchLength;
    UInt32 numPairs;
    UInt32 numAvail;
    COptimal opt[kNumOpts];

#ifndef LZMA_LOG_BSR
    Byte g_FastPos[1 << kNumLogBits];
#endif

    UInt32 ProbPrices[kBitModelTotal >> kNumMoveReducingBits];
    UInt32 matches[LZMA_MATCH_LEN_MAX * 2 + 2 + 1];
    UInt32 numFastBytes;
    UInt32 additionalOffset;
    UInt32 reps[LZMA_NUM_REPS];
    UInt32 state;

    UInt32 posSlotPrices[kNumLenToPosStates][kDistTableSizeMax];
    UInt32 distancesPrices[kNumLenToPosStates][kNumFullDistances];
    UInt32 alignPrices[kAlignTableSize];
    UInt32 alignPriceCount;

    UInt32 distTableSize;

    unsigned lc, lp, pb;
    unsigned lpMask, pbMask;

    CLzmaProb *litProbs;

    CLzmaProb isMatch[kNumStates][LZMA_NUM_PB_STATES_MAX];
    CLzmaProb isRep[kNumStates];
    CLzmaProb isRepG0[kNumStates];
    CLzmaProb isRepG1[kNumStates];
    CLzmaProb isRepG2[kNumStates];
    CLzmaProb isRep0Long[kNumStates][LZMA_NUM_PB_STATES_MAX];

    CLzmaProb posSlotEncoder[kNumLenToPosStates][1 << kNumPosSlotBits];
    CLzmaProb posEncoders[kNumFullDistances - kEndPosModelIndex];
    CLzmaProb posAlignEncoder[1 << kNumAlignBits];

    CLenPriceEnc lenEnc;
    CLenPriceEnc repLenEnc;

    unsigned lclp;

    Bool fastMode;

    CRangeEnc rc;

    Bool writeEndMark;
    UInt64 nowPos64;
    UInt32 matchPriceCount;
    Bool finished;
    Bool multiThread;

    SRes result;
    UInt32 dictSize;
    UInt32 matchFinderCycles;

    int needInit;

    CSaveState saveState;
} CLzmaEnc;

void LzmaEnc_SaveState(CLzmaEncHandle pp)
{
    CLzmaEnc *p = (CLzmaEnc *)pp;
    CSaveState *dest = &p->saveState;
    int i;
    dest->lenEnc = p->lenEnc;
    dest->repLenEnc = p->repLenEnc;
    dest->state = p->state;

    for (i = 0; i < kNumStates; i++)
    {
        memcpy(dest->isMatch[i], p->isMatch[i], sizeof(p->isMatch[i]));
        memcpy(dest->isRep0Long[i], p->isRep0Long[i], sizeof(p->isRep0Long[i]));
    }
    for (i = 0; i < kNumLenToPosStates; i++)
        memcpy(dest->posSlotEncoder[i], p->posSlotEncoder[i], sizeof(p->posSlotEncoder[i]));
    memcpy(dest->isRep, p->isRep, sizeof(p->isRep));
    memcpy(dest->isRepG0, p->isRepG0, sizeof(p->isRepG0));
    memcpy(dest->isRepG1, p->isRepG1, sizeof(p->isRepG1));
    memcpy(dest->isRepG2, p->isRepG2, sizeof(p->isRepG2));
    memcpy(dest->posEncoders, p->posEncoders, sizeof(p->posEncoders));
    memcpy(dest->posAlignEncoder, p->posAlignEncoder, sizeof(p->posAlignEncoder));
    memcpy(dest->reps, p->reps, sizeof(p->reps));
    memcpy(dest->litProbs, p->litProbs, (0x300 << p->lclp) * sizeof(CLzmaProb));
}

void LzmaEnc_RestoreState(CLzmaEncHandle pp)
{
    CLzmaEnc *dest = (CLzmaEnc *)pp;
    const CSaveState *p = &dest->saveState;
    int i;
    dest->lenEnc = p->lenEnc;
    dest->repLenEnc = p->repLenEnc;
    dest->state = p->state;

    for (i = 0; i < kNumStates; i++)
    {
        memcpy(dest->isMatch[i], p->isMatch[i], sizeof(p->isMatch[i]));
        memcpy(dest->isRep0Long[i], p->isRep0Long[i], sizeof(p->isRep0Long[i]));
    }
    for (i = 0; i < kNumLenToPosStates; i++)
        memcpy(dest->posSlotEncoder[i], p->posSlotEncoder[i], sizeof(p->posSlotEncoder[i]));
    memcpy(dest->isRep, p->isRep, sizeof(p->isRep));
    memcpy(dest->isRepG0, p->isRepG0, sizeof(p->isRepG0));
    memcpy(dest->isRepG1, p->isRepG1, sizeof(p->isRepG1));
    memcpy(dest->isRepG2, p->isRepG2, sizeof(p->isRepG2));
    memcpy(dest->posEncoders, p->posEncoders, sizeof(p->posEncoders));
    memcpy(dest->posAlignEncoder, p->posAlignEncoder, sizeof(p->posAlignEncoder));
    memcpy(dest->reps, p->reps, sizeof(p->reps));
    memcpy(dest->litProbs, p->litProbs, (0x300 << dest->lclp) * sizeof(CLzmaProb));
}

SRes LzmaEnc_SetProps(CLzmaEncHandle pp, const CLzmaEncProps *props2)
{
    CLzmaEnc *p = (CLzmaEnc *)pp;
    CLzmaEncProps props = *props2;
    LzmaEncProps_Normalize(&props);

    if (props.lc > LZMA_LC_MAX || props.lp > LZMA_LP_MAX || props.pb > LZMA_PB_MAX ||
        props.dictSize > ((UInt32)1 << kDicLogSizeMaxCompress) || props.dictSize > ((UInt32)1 << 30))
        return SZ_ERROR_PARAM;
    p->dictSize = props.dictSize;
    p->matchFinderCycles = props.mc;
    {
        unsigned fb = props.fb;
        if (fb < 5)
            fb = 5;
        if (fb > LZMA_MATCH_LEN_MAX)
            fb = LZMA_MATCH_LEN_MAX;
        p->numFastBytes = fb;
    }
    p->lc = props.lc;
    p->lp = props.lp;
    p->pb = props.pb;
    p->fastMode = (props.algo == 0);
    p->matchFinderBase.btMode = props.btMode;
    {
        UInt32 numHashBytes = 4;
        if (props.btMode)
        {
            if (props.numHashBytes < 2)
                numHashBytes = 2;
            else if (props.numHashBytes < 4)
                numHashBytes = props.numHashBytes;
        }
        p->matchFinderBase.numHashBytes = numHashBytes;
    }

    p->matchFinderBase.cutValue = props.mc;

    p->writeEndMark = props.writeEndMark;

#ifndef _7ZIP_ST
    /*
    if (newMultiThread != _multiThread)
    {
    ReleaseMatchFinder();
    _multiThread = newMultiThread;
    }
    */
    p->multiThread = (props.numThreads > 1);
#endif

    return SZ_OK;
}

static const int kLiteralNextStates[kNumStates] = { 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 4, 5 };
static const int kMatchNextStates[kNumStates] = { 7, 7, 7, 7, 7, 7, 7, 10, 10, 10, 10, 10 };
static const int kRepNextStates[kNumStates] = { 8, 8, 8, 8, 8, 8, 8, 11, 11, 11, 11, 11 };
static const int kShortRepNextStates[kNumStates] = { 9, 9, 9, 9, 9, 9, 9, 11, 11, 11, 11, 11 };

#define IsCharState(s) ((s) < 7)

#define GetLenToPosState(len) (((len) < kNumLenToPosStates + 1) ? (len) - 2 : kNumLenToPosStates - 1)

#define kInfinityPrice (1 << 30)

static void RangeEnc_Construct(CRangeEnc *p)
{
    p->outStream = 0;
    p->bufBase = 0;
}

#define RangeEnc_GetProcessed(p) ((p)->processed + ((p)->buf - (p)->bufBase) + (p)->cacheSize)

#define RC_BUF_SIZE (1 << 16)
static int RangeEnc_Alloc(CRangeEnc *p, ISzAlloc *alloc)
{
    if (p->bufBase == 0)
    {
        p->bufBase = (Byte *)alloc->Alloc(alloc, RC_BUF_SIZE);
        if (p->bufBase == 0)
            return 0;
        p->bufLim = p->bufBase + RC_BUF_SIZE;
    }
    return 1;
}

static void RangeEnc_Free(CRangeEnc *p, ISzAlloc *alloc)
{
    alloc->Free(alloc, p->bufBase);
    p->bufBase = 0;
}

static void RangeEnc_Init(CRangeEnc *p)
{
    /* Stream.Init(); */
    p->low = 0;
    p->range = 0xFFFFFFFF;
    p->cacheSize = 1;
    p->cache = 0;

    p->buf = p->bufBase;

    p->processed = 0;
    p->res = SZ_OK;
}

static void RangeEnc_FlushStream(CRangeEnc *p)
{
    size_t num;
    if (p->res != SZ_OK)
        return;
    num = p->buf - p->bufBase;
    if (num != p->outStream->Write(p->outStream, p->bufBase, num))
        p->res = SZ_ERROR_WRITE;
    p->processed += num;
    p->buf = p->bufBase;
}

static void MY_FAST_CALL RangeEnc_ShiftLow(CRangeEnc *p)
{
    if ((UInt32)p->low < (UInt32)0xFF000000 || (int)(p->low >> 32) != 0)
    {
        Byte temp = p->cache;
        do
        {
            Byte *buf = p->buf;
            *buf++ = (Byte)(temp + (Byte)(p->low >> 32));
            p->buf = buf;
            if (buf == p->bufLim)
                RangeEnc_FlushStream(p);
            temp = 0xFF;
        } while (--p->cacheSize != 0);
        p->cache = (Byte)((UInt32)p->low >> 24);
    }
    p->cacheSize++;
    p->low = (UInt32)p->low << 8;
}

static void RangeEnc_FlushData(CRangeEnc *p)
{
    int i;
    for (i = 0; i < 5; i++)
        RangeEnc_ShiftLow(p);
}

static void RangeEnc_EncodeDirectBits(CRangeEnc *p, UInt32 value, int numBits)
{
    do
    {
        p->range >>= 1;
        p->low += p->range & (0 - ((value >> --numBits) & 1));
        if (p->range < kTopValue)
        {
            p->range <<= 8;
            RangeEnc_ShiftLow(p);
        }
    } while (numBits != 0);
}

static void RangeEnc_EncodeBit(CRangeEnc *p, CLzmaProb *prob, UInt32 symbol)
{
    UInt32 ttt = *prob;
    UInt32 newBound = (p->range >> kNumBitModelTotalBits) * ttt;
    if (symbol == 0)
    {
        p->range = newBound;
        ttt += (kBitModelTotal - ttt) >> kNumMoveBits;
    }
    else
    {
        p->low += newBound;
        p->range -= newBound;
        ttt -= ttt >> kNumMoveBits;
    }
    *prob = (CLzmaProb)ttt;
    if (p->range < kTopValue)
    {
        p->range <<= 8;
        RangeEnc_ShiftLow(p);
    }
}

static void LitEnc_Encode(CRangeEnc *p, CLzmaProb *probs, UInt32 symbol)
{
    symbol |= 0x100;
    do
    {
        RangeEnc_EncodeBit(p, probs + (symbol >> 8), (symbol >> 7) & 1);
        symbol <<= 1;
    } while (symbol < 0x10000);
}

static void LitEnc_EncodeMatched(CRangeEnc *p, CLzmaProb *probs, UInt32 symbol, UInt32 matchByte)
{
    UInt32 offs = 0x100;
    symbol |= 0x100;
    do
    {
        matchByte <<= 1;
        RangeEnc_EncodeBit(p, probs + (offs + (matchByte & offs) + (symbol >> 8)), (symbol >> 7) & 1);
        symbol <<= 1;
        offs &= ~(matchByte ^ symbol);
    } while (symbol < 0x10000);
}

void LzmaEnc_InitPriceTables(UInt32 *ProbPrices)
{
    UInt32 i;
    for (i = (1 << kNumMoveReducingBits) / 2; i < kBitModelTotal; i += (1 << kNumMoveReducingBits))
    {
        const int kCyclesBits = kNumBitPriceShiftBits;
        UInt32 w = i;
        UInt32 bitCount = 0;
        int j;
        for (j = 0; j < kCyclesBits; j++)
        {
            w = w * w;
            bitCount <<= 1;
            while (w >= ((UInt32)1 << 16))
            {
                w >>= 1;
                bitCount++;
            }
        }
        ProbPrices[i >> kNumMoveReducingBits] = ((kNumBitModelTotalBits << kCyclesBits) - 15 - bitCount);
    }
}

#define GET_PRICE(prob, symbol) \
  p->ProbPrices[((prob) ^ (((-(int)(symbol))) & (kBitModelTotal - 1))) >> kNumMoveReducingBits];

#define GET_PRICEa(prob, symbol) \
  ProbPrices[((prob) ^ ((-((int)(symbol))) & (kBitModelTotal - 1))) >> kNumMoveReducingBits];

#define GET_PRICE_0(prob) p->ProbPrices[(prob) >> kNumMoveReducingBits]
#define GET_PRICE_1(prob) p->ProbPrices[((prob) ^ (kBitModelTotal - 1)) >> kNumMoveReducingBits]

#define GET_PRICE_0a(prob) ProbPrices[(prob) >> kNumMoveReducingBits]
#define GET_PRICE_1a(prob) ProbPrices[((prob) ^ (kBitModelTotal - 1)) >> kNumMoveReducingBits]

static UInt32 LitEnc_GetPrice(const CLzmaProb *probs, UInt32 symbol, UInt32 *ProbPrices)
{
    UInt32 price = 0;
    symbol |= 0x100;
    do
    {
        price += GET_PRICEa(probs[symbol >> 8], (symbol >> 7) & 1);
        symbol <<= 1;
    } while (symbol < 0x10000);
    return price;
}

static UInt32 LitEnc_GetPriceMatched(const CLzmaProb *probs, UInt32 symbol, UInt32 matchByte, UInt32 *ProbPrices)
{
    UInt32 price = 0;
    UInt32 offs = 0x100;
    symbol |= 0x100;
    do
    {
        matchByte <<= 1;
        price += GET_PRICEa(probs[offs + (matchByte & offs) + (symbol >> 8)], (symbol >> 7) & 1);
        symbol <<= 1;
        offs &= ~(matchByte ^ symbol);
    } while (symbol < 0x10000);
    return price;
}

static void RcTree_Encode(CRangeEnc *rc, CLzmaProb *probs, int numBitLevels, UInt32 symbol)
{
    UInt32 m = 1;
    int i;
    for (i = numBitLevels; i != 0;)
    {
        UInt32 bit;
        i--;
        bit = (symbol >> i) & 1;
        RangeEnc_EncodeBit(rc, probs + m, bit);
        m = (m << 1) | bit;
    }
}

static void RcTree_ReverseEncode(CRangeEnc *rc, CLzmaProb *probs, int numBitLevels, UInt32 symbol)
{
    UInt32 m = 1;
    int i;
    for (i = 0; i < numBitLevels; i++)
    {
        UInt32 bit = symbol & 1;
        RangeEnc_EncodeBit(rc, probs + m, bit);
        m = (m << 1) | bit;
        symbol >>= 1;
    }
}

static UInt32 RcTree_GetPrice(const CLzmaProb *probs, int numBitLevels, UInt32 symbol, UInt32 *ProbPrices)
{
    UInt32 price = 0;
    symbol |= (1 << numBitLevels);
    while (symbol != 1)
    {
        price += GET_PRICEa(probs[symbol >> 1], symbol & 1);
        symbol >>= 1;
    }
    return price;
}

static UInt32 RcTree_ReverseGetPrice(const CLzmaProb *probs, int numBitLevels, UInt32 symbol, UInt32 *ProbPrices)
{
    UInt32 price = 0;
    UInt32 m = 1;
    int i;
    for (i = numBitLevels; i != 0; i--)
    {
        UInt32 bit = symbol & 1;
        symbol >>= 1;
        price += GET_PRICEa(probs[m], bit);
        m = (m << 1) | bit;
    }
    return price;
}

static void LenEnc_Init(CLenEnc *p)
{
    unsigned i;
    p->choice = p->choice2 = kProbInitValue;
    for (i = 0; i < (LZMA_NUM_PB_STATES_MAX << kLenNumLowBits); i++)
        p->low[i] = kProbInitValue;
    for (i = 0; i < (LZMA_NUM_PB_STATES_MAX << kLenNumMidBits); i++)
        p->mid[i] = kProbInitValue;
    for (i = 0; i < kLenNumHighSymbols; i++)
        p->high[i] = kProbInitValue;
}

static void LenEnc_Encode(CLenEnc *p, CRangeEnc *rc, UInt32 symbol, UInt32 posState)
{
    if (symbol < kLenNumLowSymbols)
    {
        RangeEnc_EncodeBit(rc, &p->choice, 0);
        RcTree_Encode(rc, p->low + (posState << kLenNumLowBits), kLenNumLowBits, symbol);
    }
    else
    {
        RangeEnc_EncodeBit(rc, &p->choice, 1);
        if (symbol < kLenNumLowSymbols + kLenNumMidSymbols)
        {
            RangeEnc_EncodeBit(rc, &p->choice2, 0);
            RcTree_Encode(rc, p->mid + (posState << kLenNumMidBits), kLenNumMidBits, symbol - kLenNumLowSymbols);
        }
        else
        {
            RangeEnc_EncodeBit(rc, &p->choice2, 1);
            RcTree_Encode(rc, p->high, kLenNumHighBits, symbol - kLenNumLowSymbols - kLenNumMidSymbols);
        }
    }
}

static void LenEnc_SetPrices(CLenEnc *p, UInt32 posState, UInt32 numSymbols, UInt32 *prices, UInt32 *ProbPrices)
{
    UInt32 a0 = GET_PRICE_0a(p->choice);
    UInt32 a1 = GET_PRICE_1a(p->choice);
    UInt32 b0 = a1 + GET_PRICE_0a(p->choice2);
    UInt32 b1 = a1 + GET_PRICE_1a(p->choice2);
    UInt32 i = 0;
    for (i = 0; i < kLenNumLowSymbols; i++)
    {
        if (i >= numSymbols)
            return;
        prices[i] = a0 + RcTree_GetPrice(p->low + (posState << kLenNumLowBits), kLenNumLowBits, i, ProbPrices);
    }
    for (; i < kLenNumLowSymbols + kLenNumMidSymbols; i++)
    {
        if (i >= numSymbols)
            return;
        prices[i] = b0 + RcTree_GetPrice(p->mid + (posState << kLenNumMidBits), kLenNumMidBits, i - kLenNumLowSymbols, ProbPrices);
    }
    for (; i < numSymbols; i++)
        prices[i] = b1 + RcTree_GetPrice(p->high, kLenNumHighBits, i - kLenNumLowSymbols - kLenNumMidSymbols, ProbPrices);
}

static void MY_FAST_CALL LenPriceEnc_UpdateTable(CLenPriceEnc *p, UInt32 posState, UInt32 *ProbPrices)
{
    LenEnc_SetPrices(&p->p, posState, p->tableSize, p->prices[posState], ProbPrices);
    p->counters[posState] = p->tableSize;
}

static void LenPriceEnc_UpdateTables(CLenPriceEnc *p, UInt32 numPosStates, UInt32 *ProbPrices)
{
    UInt32 posState;
    for (posState = 0; posState < numPosStates; posState++)
        LenPriceEnc_UpdateTable(p, posState, ProbPrices);
}

static void LenEnc_Encode2(CLenPriceEnc *p, CRangeEnc *rc, UInt32 symbol, UInt32 posState, Bool updatePrice, UInt32 *ProbPrices)
{
    LenEnc_Encode(&p->p, rc, symbol, posState);
    if (updatePrice)
        if (--p->counters[posState] == 0)
            LenPriceEnc_UpdateTable(p, posState, ProbPrices);
}

static void MovePos(CLzmaEnc *p, UInt32 num)
{
#ifdef SHOW_STAT
    ttt += num;
    printf("\n MovePos %d", num);
#endif
    if (num != 0)
    {
        p->additionalOffset += num;
        p->matchFinder.Skip(p->matchFinderObj, num);
    }
}

static UInt32 ReadMatchDistances(CLzmaEnc *p, UInt32 *numDistancePairsRes)
{
    UInt32 lenRes = 0, numPairs;
    p->numAvail = p->matchFinder.GetNumAvailableBytes(p->matchFinderObj);
    numPairs = p->matchFinder.GetMatches(p->matchFinderObj, p->matches);
#ifdef SHOW_STAT
    printf("\n i = %d numPairs = %d    ", ttt, numPairs / 2);
    ttt++;
    {
        UInt32 i;
        for (i = 0; i < numPairs; i += 2)
            printf("%2d %6d   | ", p->matches[i], p->matches[i + 1]);
    }
#endif
    if (numPairs > 0)
    {
        lenRes = p->matches[numPairs - 2];
        if (lenRes == p->numFastBytes)
        {
            const Byte *pby = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
            UInt32 distance = p->matches[numPairs - 1] + 1;
            UInt32 numAvail = p->numAvail;
            if (numAvail > LZMA_MATCH_LEN_MAX)
                numAvail = LZMA_MATCH_LEN_MAX;
            {
                const Byte *pby2 = pby - distance;
                for (; lenRes < numAvail && pby[lenRes] == pby2[lenRes]; lenRes++);
            }
        }
    }
    p->additionalOffset++;
    *numDistancePairsRes = numPairs;
    return lenRes;
}

#define MakeAsChar(p) (p)->backPrev = (UInt32)(-1); (p)->prev1IsChar = False;
#define MakeAsShortRep(p) (p)->backPrev = 0; (p)->prev1IsChar = False;
#define IsShortRep(p) ((p)->backPrev == 0)

static UInt32 GetRepLen1Price(CLzmaEnc *p, UInt32 state, UInt32 posState)
{
    return
        GET_PRICE_0(p->isRepG0[state]) +
        GET_PRICE_0(p->isRep0Long[state][posState]);
}

static UInt32 GetPureRepPrice(CLzmaEnc *p, UInt32 repIndex, UInt32 state, UInt32 posState)
{
    UInt32 price;
    if (repIndex == 0)
    {
        price = GET_PRICE_0(p->isRepG0[state]);
        price += GET_PRICE_1(p->isRep0Long[state][posState]);
    }
    else
    {
        price = GET_PRICE_1(p->isRepG0[state]);
        if (repIndex == 1)
            price += GET_PRICE_0(p->isRepG1[state]);
        else
        {
            price += GET_PRICE_1(p->isRepG1[state]);
            price += GET_PRICE(p->isRepG2[state], repIndex - 2);
        }
    }
    return price;
}

static UInt32 GetRepPrice(CLzmaEnc *p, UInt32 repIndex, UInt32 len, UInt32 state, UInt32 posState)
{
    return p->repLenEnc.prices[posState][len - LZMA_MATCH_LEN_MIN] +
        GetPureRepPrice(p, repIndex, state, posState);
}

static UInt32 Backward(CLzmaEnc *p, UInt32 *backRes, UInt32 cur)
{
    UInt32 posMem = p->opt[cur].posPrev;
    UInt32 backMem = p->opt[cur].backPrev;
    p->optimumEndIndex = cur;
    do
    {
        if (p->opt[cur].prev1IsChar)
        {
            MakeAsChar(&p->opt[posMem])
                p->opt[posMem].posPrev = posMem - 1;
            if (p->opt[cur].prev2)
            {
                p->opt[posMem - 1].prev1IsChar = False;
                p->opt[posMem - 1].posPrev = p->opt[cur].posPrev2;
                p->opt[posMem - 1].backPrev = p->opt[cur].backPrev2;
            }
        }
    {
        UInt32 posPrev = posMem;
        UInt32 backCur = backMem;

        backMem = p->opt[posPrev].backPrev;
        posMem = p->opt[posPrev].posPrev;

        p->opt[posPrev].backPrev = backCur;
        p->opt[posPrev].posPrev = cur;
        cur = posPrev;
    }
    } while (cur != 0);
    *backRes = p->opt[0].backPrev;
    p->optimumCurrentIndex = p->opt[0].posPrev;
    return p->optimumCurrentIndex;
}

#define LIT_PROBS(pos, prevByte) (p->litProbs + ((((pos) & p->lpMask) << p->lc) + ((prevByte) >> (8 - p->lc))) * 0x300)

static UInt32 GetOptimum(CLzmaEnc *p, UInt32 position, UInt32 *backRes)
{
    UInt32 numAvail, mainLen, numPairs, repMaxIndex, i, posState, lenEnd, len, cur;
    UInt32 matchPrice, repMatchPrice, normalMatchPrice;
    UInt32 reps[LZMA_NUM_REPS], repLens[LZMA_NUM_REPS];
    UInt32 *matches;
    const Byte *data;
    Byte curByte, matchByte;
    if (p->optimumEndIndex != p->optimumCurrentIndex)
    {
        const COptimal *opt = &p->opt[p->optimumCurrentIndex];
        UInt32 lenRes = opt->posPrev - p->optimumCurrentIndex;
        *backRes = opt->backPrev;
        p->optimumCurrentIndex = opt->posPrev;
        return lenRes;
    }
    p->optimumCurrentIndex = p->optimumEndIndex = 0;

    if (p->additionalOffset == 0)
        mainLen = ReadMatchDistances(p, &numPairs);
    else
    {
        mainLen = p->longestMatchLength;
        numPairs = p->numPairs;
    }

    numAvail = p->numAvail;
    if (numAvail < 2)
    {
        *backRes = (UInt32)(-1);
        return 1;
    }
    if (numAvail > LZMA_MATCH_LEN_MAX)
        numAvail = LZMA_MATCH_LEN_MAX;

    data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
    repMaxIndex = 0;
    for (i = 0; i < LZMA_NUM_REPS; i++)
    {
        UInt32 lenTest;
        const Byte *data2;
        reps[i] = p->reps[i];
        data2 = data - (reps[i] + 1);
        if (data[0] != data2[0] || data[1] != data2[1])
        {
            repLens[i] = 0;
            continue;
        }
        for (lenTest = 2; lenTest < numAvail && data[lenTest] == data2[lenTest]; lenTest++);
        repLens[i] = lenTest;
        if (lenTest > repLens[repMaxIndex])
            repMaxIndex = i;
    }
    if (repLens[repMaxIndex] >= p->numFastBytes)
    {
        UInt32 lenRes;
        *backRes = repMaxIndex;
        lenRes = repLens[repMaxIndex];
        MovePos(p, lenRes - 1);
        return lenRes;
    }

    matches = p->matches;
    if (mainLen >= p->numFastBytes)
    {
        *backRes = matches[numPairs - 1] + LZMA_NUM_REPS;
        MovePos(p, mainLen - 1);
        return mainLen;
    }
    curByte = *data;
    matchByte = *(data - (reps[0] + 1));

    if (mainLen < 2 && curByte != matchByte && repLens[repMaxIndex] < 2)
    {
        *backRes = (UInt32)-1;
        return 1;
    }

    p->opt[0].state = (CState)p->state;

    posState = (position & p->pbMask);

    {
        const CLzmaProb *probs = LIT_PROBS(position, *(data - 1));
        p->opt[1].price = GET_PRICE_0(p->isMatch[p->state][posState]) +
            (!IsCharState(p->state) ?
            LitEnc_GetPriceMatched(probs, curByte, matchByte, p->ProbPrices) :
            LitEnc_GetPrice(probs, curByte, p->ProbPrices));
    }

    MakeAsChar(&p->opt[1]);

    matchPrice = GET_PRICE_1(p->isMatch[p->state][posState]);
    repMatchPrice = matchPrice + GET_PRICE_1(p->isRep[p->state]);

    if (matchByte == curByte)
    {
        UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(p, p->state, posState);
        if (shortRepPrice < p->opt[1].price)
        {
            p->opt[1].price = shortRepPrice;
            MakeAsShortRep(&p->opt[1]);
        }
    }
    lenEnd = ((mainLen >= repLens[repMaxIndex]) ? mainLen : repLens[repMaxIndex]);

    if (lenEnd < 2)
    {
        *backRes = p->opt[1].backPrev;
        return 1;
    }

    p->opt[1].posPrev = 0;
    for (i = 0; i < LZMA_NUM_REPS; i++)
        p->opt[0].backs[i] = reps[i];

    len = lenEnd;
    do
        p->opt[len--].price = kInfinityPrice;
    while (len >= 2);

    for (i = 0; i < LZMA_NUM_REPS; i++)
    {
        UInt32 repLen = repLens[i];
        UInt32 price;
        if (repLen < 2)
            continue;
        price = repMatchPrice + GetPureRepPrice(p, i, p->state, posState);
        do
        {
            UInt32 curAndLenPrice = price + p->repLenEnc.prices[posState][repLen - 2];
            COptimal *opt = &p->opt[repLen];
            if (curAndLenPrice < opt->price)
            {
                opt->price = curAndLenPrice;
                opt->posPrev = 0;
                opt->backPrev = i;
                opt->prev1IsChar = False;
            }
        } while (--repLen >= 2);
    }

    normalMatchPrice = matchPrice + GET_PRICE_0(p->isRep[p->state]);

    len = ((repLens[0] >= 2) ? repLens[0] + 1 : 2);
    if (len <= mainLen)
    {
        UInt32 offs = 0;
        while (len > matches[offs])
            offs += 2;
        for (;; len++)
        {
            COptimal *opt;
            UInt32 distance = matches[offs + 1];

            UInt32 curAndLenPrice = normalMatchPrice + p->lenEnc.prices[posState][len - LZMA_MATCH_LEN_MIN];
            UInt32 lenToPosState = GetLenToPosState(len);
            if (distance < kNumFullDistances)
                curAndLenPrice += p->distancesPrices[lenToPosState][distance];
            else
            {
                UInt32 slot;
                GetPosSlot2(distance, slot);
                curAndLenPrice += p->alignPrices[distance & kAlignMask] + p->posSlotPrices[lenToPosState][slot];
            }
            opt = &p->opt[len];
            if (curAndLenPrice < opt->price)
            {
                opt->price = curAndLenPrice;
                opt->posPrev = 0;
                opt->backPrev = distance + LZMA_NUM_REPS;
                opt->prev1IsChar = False;
            }
            if (len == matches[offs])
            {
                offs += 2;
                if (offs == numPairs)
                    break;
            }
        }
    }

    cur = 0;

#ifdef SHOW_STAT2
    if (position >= 0)
    {
        unsigned i;
        printf("\n pos = %4X", position);
        for (i = cur; i <= lenEnd; i++)
            printf("\nprice[%4X] = %d", position - cur + i, p->opt[i].price);
    }
#endif

    for (;;)
    {
        UInt32 numAvailFull, newLen, numPairs, posPrev, state, posState, startLen;
        UInt32 curPrice, curAnd1Price, matchPrice, repMatchPrice;
        Bool nextIsChar;
        Byte curByte, matchByte;
        const Byte *data;
        COptimal *curOpt;
        COptimal *nextOpt;

        cur++;
        if (cur == lenEnd)
            return Backward(p, backRes, cur);

        newLen = ReadMatchDistances(p, &numPairs);
        if (newLen >= p->numFastBytes)
        {
            p->numPairs = numPairs;
            p->longestMatchLength = newLen;
            return Backward(p, backRes, cur);
        }
        position++;
        curOpt = &p->opt[cur];
        posPrev = curOpt->posPrev;
        if (curOpt->prev1IsChar)
        {
            posPrev--;
            if (curOpt->prev2)
            {
                state = p->opt[curOpt->posPrev2].state;
                if (curOpt->backPrev2 < LZMA_NUM_REPS)
                    state = kRepNextStates[state];
                else
                    state = kMatchNextStates[state];
            }
            else
                state = p->opt[posPrev].state;
            state = kLiteralNextStates[state];
        }
        else
            state = p->opt[posPrev].state;
        if (posPrev == cur - 1)
        {
            if (IsShortRep(curOpt))
                state = kShortRepNextStates[state];
            else
                state = kLiteralNextStates[state];
        }
        else
        {
            UInt32 pos;
            const COptimal *prevOpt;
            if (curOpt->prev1IsChar && curOpt->prev2)
            {
                posPrev = curOpt->posPrev2;
                pos = curOpt->backPrev2;
                state = kRepNextStates[state];
            }
            else
            {
                pos = curOpt->backPrev;
                if (pos < LZMA_NUM_REPS)
                    state = kRepNextStates[state];
                else
                    state = kMatchNextStates[state];
            }
            prevOpt = &p->opt[posPrev];
            if (pos < LZMA_NUM_REPS)
            {
                UInt32 i;
                reps[0] = prevOpt->backs[pos];
                for (i = 1; i <= pos; i++)
                    reps[i] = prevOpt->backs[i - 1];
                for (; i < LZMA_NUM_REPS; i++)
                    reps[i] = prevOpt->backs[i];
            }
            else
            {
                UInt32 i;
                reps[0] = (pos - LZMA_NUM_REPS);
                for (i = 1; i < LZMA_NUM_REPS; i++)
                    reps[i] = prevOpt->backs[i - 1];
            }
        }
        curOpt->state = (CState)state;

        curOpt->backs[0] = reps[0];
        curOpt->backs[1] = reps[1];
        curOpt->backs[2] = reps[2];
        curOpt->backs[3] = reps[3];

        curPrice = curOpt->price;
        nextIsChar = False;
        data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
        curByte = *data;
        matchByte = *(data - (reps[0] + 1));

        posState = (position & p->pbMask);

        curAnd1Price = curPrice + GET_PRICE_0(p->isMatch[state][posState]);
        {
            const CLzmaProb *probs = LIT_PROBS(position, *(data - 1));
            curAnd1Price +=
                (!IsCharState(state) ?
                LitEnc_GetPriceMatched(probs, curByte, matchByte, p->ProbPrices) :
                LitEnc_GetPrice(probs, curByte, p->ProbPrices));
        }

        nextOpt = &p->opt[cur + 1];

        if (curAnd1Price < nextOpt->price)
        {
            nextOpt->price = curAnd1Price;
            nextOpt->posPrev = cur;
            MakeAsChar(nextOpt);
            nextIsChar = True;
        }

        matchPrice = curPrice + GET_PRICE_1(p->isMatch[state][posState]);
        repMatchPrice = matchPrice + GET_PRICE_1(p->isRep[state]);

        if (matchByte == curByte && !(nextOpt->posPrev < cur && nextOpt->backPrev == 0))
        {
            UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(p, state, posState);
            if (shortRepPrice <= nextOpt->price)
            {
                nextOpt->price = shortRepPrice;
                nextOpt->posPrev = cur;
                MakeAsShortRep(nextOpt);
                nextIsChar = True;
            }
        }
        numAvailFull = p->numAvail;
        {
            UInt32 temp = kNumOpts - 1 - cur;
            if (temp < numAvailFull)
                numAvailFull = temp;
        }

        if (numAvailFull < 2)
            continue;
        numAvail = (numAvailFull <= p->numFastBytes ? numAvailFull : p->numFastBytes);

        if (!nextIsChar && matchByte != curByte) /* speed optimization */
        {
            /* try Literal + rep0 */
            UInt32 temp;
            UInt32 lenTest2;
            const Byte *data2 = data - (reps[0] + 1);
            UInt32 limit = p->numFastBytes + 1;
            if (limit > numAvailFull)
                limit = numAvailFull;

            for (temp = 1; temp < limit && data[temp] == data2[temp]; temp++);
            lenTest2 = temp - 1;
            if (lenTest2 >= 2)
            {
                UInt32 state2 = kLiteralNextStates[state];
                UInt32 posStateNext = (position + 1) & p->pbMask;
                UInt32 nextRepMatchPrice = curAnd1Price +
                    GET_PRICE_1(p->isMatch[state2][posStateNext]) +
                    GET_PRICE_1(p->isRep[state2]);
                /* for (; lenTest2 >= 2; lenTest2--) */
                {
                    UInt32 curAndLenPrice;
                    COptimal *opt;
                    UInt32 offset = cur + 1 + lenTest2;
                    while (lenEnd < offset)
                        p->opt[++lenEnd].price = kInfinityPrice;
                    curAndLenPrice = nextRepMatchPrice + GetRepPrice(p, 0, lenTest2, state2, posStateNext);
                    opt = &p->opt[offset];
                    if (curAndLenPrice < opt->price)
                    {
                        opt->price = curAndLenPrice;
                        opt->posPrev = cur + 1;
                        opt->backPrev = 0;
                        opt->prev1IsChar = True;
                        opt->prev2 = False;
                    }
                }
            }
        }

        startLen = 2; /* speed optimization */
        {
            UInt32 repIndex;
            for (repIndex = 0; repIndex < LZMA_NUM_REPS; repIndex++)
            {
                UInt32 lenTest;
                UInt32 lenTestTemp;
                UInt32 price;
                const Byte *data2 = data - (reps[repIndex] + 1);
                if (data[0] != data2[0] || data[1] != data2[1])
                    continue;
                for (lenTest = 2; lenTest < numAvail && data[lenTest] == data2[lenTest]; lenTest++);
                while (lenEnd < cur + lenTest)
                    p->opt[++lenEnd].price = kInfinityPrice;
                lenTestTemp = lenTest;
                price = repMatchPrice + GetPureRepPrice(p, repIndex, state, posState);
                do
                {
                    UInt32 curAndLenPrice = price + p->repLenEnc.prices[posState][lenTest - 2];
                    COptimal *opt = &p->opt[cur + lenTest];
                    if (curAndLenPrice < opt->price)
                    {
                        opt->price = curAndLenPrice;
                        opt->posPrev = cur;
                        opt->backPrev = repIndex;
                        opt->prev1IsChar = False;
                    }
                } while (--lenTest >= 2);
                lenTest = lenTestTemp;

                if (repIndex == 0)
                    startLen = lenTest + 1;

                /* if (_maxMode) */
                {
                    UInt32 lenTest2 = lenTest + 1;
                    UInt32 limit = lenTest2 + p->numFastBytes;
                    UInt32 nextRepMatchPrice;
                    if (limit > numAvailFull)
                        limit = numAvailFull;
                    for (; lenTest2 < limit && data[lenTest2] == data2[lenTest2]; lenTest2++);
                    lenTest2 -= lenTest + 1;
                    if (lenTest2 >= 2)
                    {
                        UInt32 state2 = kRepNextStates[state];
                        UInt32 posStateNext = (position + lenTest) & p->pbMask;
                        UInt32 curAndLenCharPrice =
                            price + p->repLenEnc.prices[posState][lenTest - 2] +
                            GET_PRICE_0(p->isMatch[state2][posStateNext]) +
                            LitEnc_GetPriceMatched(LIT_PROBS(position + lenTest, data[lenTest - 1]),
                            data[lenTest], data2[lenTest], p->ProbPrices);
                        state2 = kLiteralNextStates[state2];
                        posStateNext = (position + lenTest + 1) & p->pbMask;
                        nextRepMatchPrice = curAndLenCharPrice +
                            GET_PRICE_1(p->isMatch[state2][posStateNext]) +
                            GET_PRICE_1(p->isRep[state2]);

                        /* for (; lenTest2 >= 2; lenTest2--) */
                        {
                            UInt32 curAndLenPrice;
                            COptimal *opt;
                            UInt32 offset = cur + lenTest + 1 + lenTest2;
                            while (lenEnd < offset)
                                p->opt[++lenEnd].price = kInfinityPrice;
                            curAndLenPrice = nextRepMatchPrice + GetRepPrice(p, 0, lenTest2, state2, posStateNext);
                            opt = &p->opt[offset];
                            if (curAndLenPrice < opt->price)
                            {
                                opt->price = curAndLenPrice;
                                opt->posPrev = cur + lenTest + 1;
                                opt->backPrev = 0;
                                opt->prev1IsChar = True;
                                opt->prev2 = True;
                                opt->posPrev2 = cur;
                                opt->backPrev2 = repIndex;
                            }
                        }
                    }
                }
            }
        }
        /* for (UInt32 lenTest = 2; lenTest <= newLen; lenTest++) */
        if (newLen > numAvail)
        {
            newLen = numAvail;
            for (numPairs = 0; newLen > matches[numPairs]; numPairs += 2);
            matches[numPairs] = newLen;
            numPairs += 2;
        }
        if (newLen >= startLen)
        {
            UInt32 normalMatchPrice = matchPrice + GET_PRICE_0(p->isRep[state]);
            UInt32 offs, curBack, posSlot;
            UInt32 lenTest;
            while (lenEnd < cur + newLen)
                p->opt[++lenEnd].price = kInfinityPrice;

            offs = 0;
            while (startLen > matches[offs])
                offs += 2;
            curBack = matches[offs + 1];
            GetPosSlot2(curBack, posSlot);
            for (lenTest = /*2*/ startLen;; lenTest++)
            {
                UInt32 curAndLenPrice = normalMatchPrice + p->lenEnc.prices[posState][lenTest - LZMA_MATCH_LEN_MIN];
                UInt32 lenToPosState = GetLenToPosState(lenTest);
                COptimal *opt;
                if (curBack < kNumFullDistances)
                    curAndLenPrice += p->distancesPrices[lenToPosState][curBack];
                else
                    curAndLenPrice += p->posSlotPrices[lenToPosState][posSlot] + p->alignPrices[curBack & kAlignMask];

                opt = &p->opt[cur + lenTest];
                if (curAndLenPrice < opt->price)
                {
                    opt->price = curAndLenPrice;
                    opt->posPrev = cur;
                    opt->backPrev = curBack + LZMA_NUM_REPS;
                    opt->prev1IsChar = False;
                }

                if (/*_maxMode && */lenTest == matches[offs])
                {
                    /* Try Match + Literal + Rep0 */
                    const Byte *data2 = data - (curBack + 1);
                    UInt32 lenTest2 = lenTest + 1;
                    UInt32 limit = lenTest2 + p->numFastBytes;
                    UInt32 nextRepMatchPrice;
                    if (limit > numAvailFull)
                        limit = numAvailFull;
                    for (; lenTest2 < limit && data[lenTest2] == data2[lenTest2]; lenTest2++);
                    lenTest2 -= lenTest + 1;
                    if (lenTest2 >= 2)
                    {
                        UInt32 state2 = kMatchNextStates[state];
                        UInt32 posStateNext = (position + lenTest) & p->pbMask;
                        UInt32 curAndLenCharPrice = curAndLenPrice +
                            GET_PRICE_0(p->isMatch[state2][posStateNext]) +
                            LitEnc_GetPriceMatched(LIT_PROBS(position + lenTest, data[lenTest - 1]),
                            data[lenTest], data2[lenTest], p->ProbPrices);
                        state2 = kLiteralNextStates[state2];
                        posStateNext = (posStateNext + 1) & p->pbMask;
                        nextRepMatchPrice = curAndLenCharPrice +
                            GET_PRICE_1(p->isMatch[state2][posStateNext]) +
                            GET_PRICE_1(p->isRep[state2]);

                        /* for (; lenTest2 >= 2; lenTest2--) */
                        {
                            UInt32 offset = cur + lenTest + 1 + lenTest2;
                            UInt32 curAndLenPrice;
                            COptimal *opt;
                            while (lenEnd < offset)
                                p->opt[++lenEnd].price = kInfinityPrice;
                            curAndLenPrice = nextRepMatchPrice + GetRepPrice(p, 0, lenTest2, state2, posStateNext);
                            opt = &p->opt[offset];
                            if (curAndLenPrice < opt->price)
                            {
                                opt->price = curAndLenPrice;
                                opt->posPrev = cur + lenTest + 1;
                                opt->backPrev = 0;
                                opt->prev1IsChar = True;
                                opt->prev2 = True;
                                opt->posPrev2 = cur;
                                opt->backPrev2 = curBack + LZMA_NUM_REPS;
                            }
                        }
                    }
                    offs += 2;
                    if (offs == numPairs)
                        break;
                    curBack = matches[offs + 1];
                    if (curBack >= kNumFullDistances)
                        GetPosSlot2(curBack, posSlot);
                }
            }
        }
    }
}

#define ChangePair(smallDist, bigDist) (((bigDist) >> 7) > (smallDist))

static UInt32 GetOptimumFast(CLzmaEnc *p, UInt32 *backRes)
{
    UInt32 numAvail, mainLen, mainDist, numPairs, repIndex, repLen, i;
    const Byte *data;
    const UInt32 *matches;

    if (p->additionalOffset == 0)
        mainLen = ReadMatchDistances(p, &numPairs);
    else
    {
        mainLen = p->longestMatchLength;
        numPairs = p->numPairs;
    }

    numAvail = p->numAvail;
    *backRes = (UInt32)-1;
    if (numAvail < 2)
        return 1;
    if (numAvail > LZMA_MATCH_LEN_MAX)
        numAvail = LZMA_MATCH_LEN_MAX;
    data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;

    repLen = repIndex = 0;
    for (i = 0; i < LZMA_NUM_REPS; i++)
    {
        UInt32 len;
        const Byte *data2 = data - (p->reps[i] + 1);
        if (data[0] != data2[0] || data[1] != data2[1])
            continue;
        for (len = 2; len < numAvail && data[len] == data2[len]; len++);
        if (len >= p->numFastBytes)
        {
            *backRes = i;
            MovePos(p, len - 1);
            return len;
        }
        if (len > repLen)
        {
            repIndex = i;
            repLen = len;
        }
    }

    matches = p->matches;
    if (mainLen >= p->numFastBytes)
    {
        *backRes = matches[numPairs - 1] + LZMA_NUM_REPS;
        MovePos(p, mainLen - 1);
        return mainLen;
    }

    mainDist = 0; /* for GCC */
    if (mainLen >= 2)
    {
        mainDist = matches[numPairs - 1];
        while (numPairs > 2 && mainLen == matches[numPairs - 4] + 1)
        {
            if (!ChangePair(matches[numPairs - 3], mainDist))
                break;
            numPairs -= 2;
            mainLen = matches[numPairs - 2];
            mainDist = matches[numPairs - 1];
        }
        if (mainLen == 2 && mainDist >= 0x80)
            mainLen = 1;
    }

    if (repLen >= 2 && (
        (repLen + 1 >= mainLen) ||
        (repLen + 2 >= mainLen && mainDist >= (1 << 9)) ||
        (repLen + 3 >= mainLen && mainDist >= (1 << 15))))
    {
        *backRes = repIndex;
        MovePos(p, repLen - 1);
        return repLen;
    }

    if (mainLen < 2 || numAvail <= 2)
        return 1;

    p->longestMatchLength = ReadMatchDistances(p, &p->numPairs);
    if (p->longestMatchLength >= 2)
    {
        UInt32 newDistance = matches[p->numPairs - 1];
        if ((p->longestMatchLength >= mainLen && newDistance < mainDist) ||
            (p->longestMatchLength == mainLen + 1 && !ChangePair(mainDist, newDistance)) ||
            (p->longestMatchLength > mainLen + 1) ||
            (p->longestMatchLength + 1 >= mainLen && mainLen >= 3 && ChangePair(newDistance, mainDist)))
            return 1;
    }

    data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
    for (i = 0; i < LZMA_NUM_REPS; i++)
    {
        UInt32 len, limit;
        const Byte *data2 = data - (p->reps[i] + 1);
        if (data[0] != data2[0] || data[1] != data2[1])
            continue;
        limit = mainLen - 1;
        for (len = 2; len < limit && data[len] == data2[len]; len++);
        if (len >= limit)
            return 1;
    }
    *backRes = mainDist + LZMA_NUM_REPS;
    MovePos(p, mainLen - 2);
    return mainLen;
}

static void WriteEndMarker(CLzmaEnc *p, UInt32 posState)
{
    UInt32 len;
    RangeEnc_EncodeBit(&p->rc, &p->isMatch[p->state][posState], 1);
    RangeEnc_EncodeBit(&p->rc, &p->isRep[p->state], 0);
    p->state = kMatchNextStates[p->state];
    len = LZMA_MATCH_LEN_MIN;
    LenEnc_Encode2(&p->lenEnc, &p->rc, len - LZMA_MATCH_LEN_MIN, posState, !p->fastMode, p->ProbPrices);
    RcTree_Encode(&p->rc, p->posSlotEncoder[GetLenToPosState(len)], kNumPosSlotBits, (1 << kNumPosSlotBits) - 1);
    RangeEnc_EncodeDirectBits(&p->rc, (((UInt32)1 << 30) - 1) >> kNumAlignBits, 30 - kNumAlignBits);
    RcTree_ReverseEncode(&p->rc, p->posAlignEncoder, kNumAlignBits, kAlignMask);
}

static SRes CheckErrors(CLzmaEnc *p)
{
    if (p->result != SZ_OK)
        return p->result;
    if (p->rc.res != SZ_OK)
        p->result = SZ_ERROR_WRITE;
    if (p->matchFinderBase.result != SZ_OK)
        p->result = SZ_ERROR_READ;
    if (p->result != SZ_OK)
        p->finished = True;
    return p->result;
}

static SRes Flush(CLzmaEnc *p, UInt32 nowPos)
{
    /* ReleaseMFStream(); */
    p->finished = True;
    if (p->writeEndMark)
        WriteEndMarker(p, nowPos & p->pbMask);
    RangeEnc_FlushData(&p->rc);
    RangeEnc_FlushStream(&p->rc);
    return CheckErrors(p);
}

static void FillAlignPrices(CLzmaEnc *p)
{
    UInt32 i;
    for (i = 0; i < kAlignTableSize; i++)
        p->alignPrices[i] = RcTree_ReverseGetPrice(p->posAlignEncoder, kNumAlignBits, i, p->ProbPrices);
    p->alignPriceCount = 0;
}

static void FillDistancesPrices(CLzmaEnc *p)
{
    UInt32 tempPrices[kNumFullDistances];
    UInt32 i, lenToPosState;
    for (i = kStartPosModelIndex; i < kNumFullDistances; i++)
    {
        UInt32 posSlot = GetPosSlot1(i);
        UInt32 footerBits = ((posSlot >> 1) - 1);
        UInt32 base = ((2 | (posSlot & 1)) << footerBits);
        tempPrices[i] = RcTree_ReverseGetPrice(p->posEncoders + base - posSlot - 1, footerBits, i - base, p->ProbPrices);
    }

    for (lenToPosState = 0; lenToPosState < kNumLenToPosStates; lenToPosState++)
    {
        UInt32 posSlot;
        const CLzmaProb *encoder = p->posSlotEncoder[lenToPosState];
        UInt32 *posSlotPrices = p->posSlotPrices[lenToPosState];
        for (posSlot = 0; posSlot < p->distTableSize; posSlot++)
            posSlotPrices[posSlot] = RcTree_GetPrice(encoder, kNumPosSlotBits, posSlot, p->ProbPrices);
        for (posSlot = kEndPosModelIndex; posSlot < p->distTableSize; posSlot++)
            posSlotPrices[posSlot] += ((((posSlot >> 1) - 1) - kNumAlignBits) << kNumBitPriceShiftBits);

        {
            UInt32 *distancesPrices = p->distancesPrices[lenToPosState];
            UInt32 i;
            for (i = 0; i < kStartPosModelIndex; i++)
                distancesPrices[i] = posSlotPrices[i];
            for (; i < kNumFullDistances; i++)
                distancesPrices[i] = posSlotPrices[GetPosSlot1(i)] + tempPrices[i];
        }
    }
    p->matchPriceCount = 0;
}

void LzmaEnc_Construct(CLzmaEnc *p)
{
    RangeEnc_Construct(&p->rc);
    MatchFinder_Construct(&p->matchFinderBase);
#ifndef _7ZIP_ST
    MatchFinderMt_Construct(&p->matchFinderMt);
    p->matchFinderMt.MatchFinder = &p->matchFinderBase;
#endif

    {
        CLzmaEncProps props;
        LzmaEncProps_Init(&props);
        LzmaEnc_SetProps(p, &props);
    }

#ifndef LZMA_LOG_BSR
    LzmaEnc_FastPosInit(p->g_FastPos);
#endif

    LzmaEnc_InitPriceTables(p->ProbPrices);
    p->litProbs = 0;
    p->saveState.litProbs = 0;
}

CLzmaEncHandle LzmaEnc_Create(ISzAlloc *alloc)
{
    void *p;
    p = alloc->Alloc(alloc, sizeof(CLzmaEnc));
    if (p != 0)
        LzmaEnc_Construct((CLzmaEnc *)p);
    return p;
}

void LzmaEnc_FreeLits(CLzmaEnc *p, ISzAlloc *alloc)
{
    alloc->Free(alloc, p->litProbs);
    alloc->Free(alloc, p->saveState.litProbs);
    p->litProbs = 0;
    p->saveState.litProbs = 0;
}

void LzmaEnc_Destruct(CLzmaEnc *p, ISzAlloc *alloc, ISzAlloc *allocBig)
{
#ifndef _7ZIP_ST
    MatchFinderMt_Destruct(&p->matchFinderMt, allocBig);
#endif
    MatchFinder_Free(&p->matchFinderBase, allocBig);
    LzmaEnc_FreeLits(p, alloc);
    RangeEnc_Free(&p->rc, alloc);
}

void LzmaEnc_Destroy(CLzmaEncHandle p, ISzAlloc *alloc, ISzAlloc *allocBig)
{
    LzmaEnc_Destruct((CLzmaEnc *)p, alloc, allocBig);
    alloc->Free(alloc, p);
}

static SRes LzmaEnc_CodeOneBlock(CLzmaEnc *p, Bool useLimits, UInt32 maxPackSize, UInt32 maxUnpackSize)
{
    UInt32 nowPos32, startPos32;
    if (p->needInit)
    {
        p->matchFinder.Init(p->matchFinderObj);
        p->needInit = 0;
    }

    if (p->finished)
        return p->result;
    RINOK(CheckErrors(p));

    nowPos32 = (UInt32)p->nowPos64;
    startPos32 = nowPos32;

    if (p->nowPos64 == 0)
    {
        UInt32 numPairs;
        Byte curByte;
        if (p->matchFinder.GetNumAvailableBytes(p->matchFinderObj) == 0)
            return Flush(p, nowPos32);
        ReadMatchDistances(p, &numPairs);
        RangeEnc_EncodeBit(&p->rc, &p->isMatch[p->state][0], 0);
        p->state = kLiteralNextStates[p->state];
        curByte = p->matchFinder.GetIndexByte(p->matchFinderObj, 0 - p->additionalOffset);
        LitEnc_Encode(&p->rc, p->litProbs, curByte);
        p->additionalOffset--;
        nowPos32++;
    }

    if (p->matchFinder.GetNumAvailableBytes(p->matchFinderObj) != 0)
        for (;;)
        {
        UInt32 pos, len, posState;

        if (p->fastMode)
            len = GetOptimumFast(p, &pos);
        else
            len = GetOptimum(p, nowPos32, &pos);

#ifdef SHOW_STAT2
        printf("\n pos = %4X,   len = %d   pos = %d", nowPos32, len, pos);
#endif

        posState = nowPos32 & p->pbMask;
        if (len == 1 && pos == (UInt32)-1)
        {
            Byte curByte;
            CLzmaProb *probs;
            const Byte *data;

            RangeEnc_EncodeBit(&p->rc, &p->isMatch[p->state][posState], 0);
            data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - p->additionalOffset;
            curByte = *data;
            probs = LIT_PROBS(nowPos32, *(data - 1));
            if (IsCharState(p->state))
                LitEnc_Encode(&p->rc, probs, curByte);
            else
                LitEnc_EncodeMatched(&p->rc, probs, curByte, *(data - p->reps[0] - 1));
            p->state = kLiteralNextStates[p->state];
        }
        else
        {
            RangeEnc_EncodeBit(&p->rc, &p->isMatch[p->state][posState], 1);
            if (pos < LZMA_NUM_REPS)
            {
                RangeEnc_EncodeBit(&p->rc, &p->isRep[p->state], 1);
                if (pos == 0)
                {
                    RangeEnc_EncodeBit(&p->rc, &p->isRepG0[p->state], 0);
                    RangeEnc_EncodeBit(&p->rc, &p->isRep0Long[p->state][posState], ((len == 1) ? 0 : 1));
                }
                else
                {
                    UInt32 distance = p->reps[pos];
                    RangeEnc_EncodeBit(&p->rc, &p->isRepG0[p->state], 1);
                    if (pos == 1)
                        RangeEnc_EncodeBit(&p->rc, &p->isRepG1[p->state], 0);
                    else
                    {
                        RangeEnc_EncodeBit(&p->rc, &p->isRepG1[p->state], 1);
                        RangeEnc_EncodeBit(&p->rc, &p->isRepG2[p->state], pos - 2);
                        if (pos == 3)
                            p->reps[3] = p->reps[2];
                        p->reps[2] = p->reps[1];
                    }
                    p->reps[1] = p->reps[0];
                    p->reps[0] = distance;
                }
                if (len == 1)
                    p->state = kShortRepNextStates[p->state];
                else
                {
                    LenEnc_Encode2(&p->repLenEnc, &p->rc, len - LZMA_MATCH_LEN_MIN, posState, !p->fastMode, p->ProbPrices);
                    p->state = kRepNextStates[p->state];
                }
            }
            else
            {
                UInt32 posSlot;
                RangeEnc_EncodeBit(&p->rc, &p->isRep[p->state], 0);
                p->state = kMatchNextStates[p->state];
                LenEnc_Encode2(&p->lenEnc, &p->rc, len - LZMA_MATCH_LEN_MIN, posState, !p->fastMode, p->ProbPrices);
                pos -= LZMA_NUM_REPS;
                GetPosSlot(pos, posSlot);
                RcTree_Encode(&p->rc, p->posSlotEncoder[GetLenToPosState(len)], kNumPosSlotBits, posSlot);

                if (posSlot >= kStartPosModelIndex)
                {
                    UInt32 footerBits = ((posSlot >> 1) - 1);
                    UInt32 base = ((2 | (posSlot & 1)) << footerBits);
                    UInt32 posReduced = pos - base;

                    if (posSlot < kEndPosModelIndex)
                        RcTree_ReverseEncode(&p->rc, p->posEncoders + base - posSlot - 1, footerBits, posReduced);
                    else
                    {
                        RangeEnc_EncodeDirectBits(&p->rc, posReduced >> kNumAlignBits, footerBits - kNumAlignBits);
                        RcTree_ReverseEncode(&p->rc, p->posAlignEncoder, kNumAlignBits, posReduced & kAlignMask);
                        p->alignPriceCount++;
                    }
                }
                p->reps[3] = p->reps[2];
                p->reps[2] = p->reps[1];
                p->reps[1] = p->reps[0];
                p->reps[0] = pos;
                p->matchPriceCount++;
            }
        }
        p->additionalOffset -= len;
        nowPos32 += len;
        if (p->additionalOffset == 0)
        {
            UInt32 processed;
            if (!p->fastMode)
            {
                if (p->matchPriceCount >= (1 << 7))
                    FillDistancesPrices(p);
                if (p->alignPriceCount >= kAlignTableSize)
                    FillAlignPrices(p);
            }
            if (p->matchFinder.GetNumAvailableBytes(p->matchFinderObj) == 0)
                break;
            processed = nowPos32 - startPos32;
            if (useLimits)
            {
                if (processed + kNumOpts + 300 >= maxUnpackSize ||
                    RangeEnc_GetProcessed(&p->rc) + kNumOpts * 2 >= maxPackSize)
                    break;
            }
            else if (processed >= (1 << 15))
            {
                p->nowPos64 += nowPos32 - startPos32;
                return CheckErrors(p);
            }
        }
        }
    p->nowPos64 += nowPos32 - startPos32;
    return Flush(p, nowPos32);
}

#define kBigHashDicLimit ((UInt32)1 << 24)

static SRes LzmaEnc_Alloc(CLzmaEnc *p, UInt32 keepWindowSize, ISzAlloc *alloc, ISzAlloc *allocBig)
{
    UInt32 beforeSize = kNumOpts;
    if (!RangeEnc_Alloc(&p->rc, alloc))
        return SZ_ERROR_MEM;

#ifndef _7ZIP_ST
    {
        Bool btMode = (p->matchFinderBase.btMode != 0);
        p->mtMode = (p->multiThread && !p->fastMode && btMode);
    }
#endif

    {
        unsigned lclp = p->lc + p->lp;
        if (p->litProbs == 0 || p->saveState.litProbs == 0 || p->lclp != lclp)
        {
            LzmaEnc_FreeLits(p, alloc);
            p->litProbs = (CLzmaProb *)alloc->Alloc(alloc, (0x300 << lclp) * sizeof(CLzmaProb));
            p->saveState.litProbs = (CLzmaProb *)alloc->Alloc(alloc, (0x300 << lclp) * sizeof(CLzmaProb));
            if (p->litProbs == 0 || p->saveState.litProbs == 0)
            {
                LzmaEnc_FreeLits(p, alloc);
                return SZ_ERROR_MEM;
            }
            p->lclp = lclp;
        }
    }

    p->matchFinderBase.bigHash = (p->dictSize > kBigHashDicLimit);

    if (beforeSize + p->dictSize < keepWindowSize)
        beforeSize = keepWindowSize - p->dictSize;

#ifndef _7ZIP_ST
    if (p->mtMode)
    {
        RINOK(MatchFinderMt_Create(&p->matchFinderMt, p->dictSize, beforeSize, p->numFastBytes, LZMA_MATCH_LEN_MAX, allocBig));
        p->matchFinderObj = &p->matchFinderMt;
        MatchFinderMt_CreateVTable(&p->matchFinderMt, &p->matchFinder);
    }
    else
#endif
    {
        if (!MatchFinder_Create(&p->matchFinderBase, p->dictSize, beforeSize, p->numFastBytes, LZMA_MATCH_LEN_MAX, allocBig))
            return SZ_ERROR_MEM;
        p->matchFinderObj = &p->matchFinderBase;
        MatchFinder_CreateVTable(&p->matchFinderBase, &p->matchFinder);
    }
    return SZ_OK;
}

void LzmaEnc_Init(CLzmaEnc *p)
{
    UInt32 i;
    p->state = 0;
    for (i = 0; i < LZMA_NUM_REPS; i++)
        p->reps[i] = 0;

    RangeEnc_Init(&p->rc);

    for (i = 0; i < kNumStates; i++)
    {
        UInt32 j;
        for (j = 0; j < LZMA_NUM_PB_STATES_MAX; j++)
        {
            p->isMatch[i][j] = kProbInitValue;
            p->isRep0Long[i][j] = kProbInitValue;
        }
        p->isRep[i] = kProbInitValue;
        p->isRepG0[i] = kProbInitValue;
        p->isRepG1[i] = kProbInitValue;
        p->isRepG2[i] = kProbInitValue;
    }

  {
      UInt32 num = 0x300 << (p->lp + p->lc);
      for (i = 0; i < num; i++)
          p->litProbs[i] = kProbInitValue;
  }

  {
      for (i = 0; i < kNumLenToPosStates; i++)
      {
          CLzmaProb *probs = p->posSlotEncoder[i];
          UInt32 j;
          for (j = 0; j < (1 << kNumPosSlotBits); j++)
              probs[j] = kProbInitValue;
      }
  }
  {
      for (i = 0; i < kNumFullDistances - kEndPosModelIndex; i++)
          p->posEncoders[i] = kProbInitValue;
  }

    LenEnc_Init(&p->lenEnc.p);
    LenEnc_Init(&p->repLenEnc.p);

    for (i = 0; i < (1 << kNumAlignBits); i++)
        p->posAlignEncoder[i] = kProbInitValue;

    p->optimumEndIndex = 0;
    p->optimumCurrentIndex = 0;
    p->additionalOffset = 0;

    p->pbMask = (1 << p->pb) - 1;
    p->lpMask = (1 << p->lp) - 1;
}

void LzmaEnc_InitPrices(CLzmaEnc *p)
{
    if (!p->fastMode)
    {
        FillDistancesPrices(p);
        FillAlignPrices(p);
    }

    p->lenEnc.tableSize =
        p->repLenEnc.tableSize =
        p->numFastBytes + 1 - LZMA_MATCH_LEN_MIN;
    LenPriceEnc_UpdateTables(&p->lenEnc, 1 << p->pb, p->ProbPrices);
    LenPriceEnc_UpdateTables(&p->repLenEnc, 1 << p->pb, p->ProbPrices);
}

static SRes LzmaEnc_AllocAndInit(CLzmaEnc *p, UInt32 keepWindowSize, ISzAlloc *alloc, ISzAlloc *allocBig)
{
    UInt32 i;
    for (i = 0; i < (UInt32)kDicLogSizeMaxCompress; i++)
        if (p->dictSize <= ((UInt32)1 << i))
            break;
    p->distTableSize = i * 2;

    p->finished = False;
    p->result = SZ_OK;
    RINOK(LzmaEnc_Alloc(p, keepWindowSize, alloc, allocBig));
    LzmaEnc_Init(p);
    LzmaEnc_InitPrices(p);
    p->nowPos64 = 0;
    return SZ_OK;
}

static SRes LzmaEnc_Prepare(CLzmaEncHandle pp, ISeqOutStream *outStream, ISeqInStream *inStream,
    ISzAlloc *alloc, ISzAlloc *allocBig)
{
    CLzmaEnc *p = (CLzmaEnc *)pp;
    p->matchFinderBase.stream = inStream;
    p->needInit = 1;
    p->rc.outStream = outStream;
    return LzmaEnc_AllocAndInit(p, 0, alloc, allocBig);
}

SRes LzmaEnc_PrepareForLzma2(CLzmaEncHandle pp,
    ISeqInStream *inStream, UInt32 keepWindowSize,
    ISzAlloc *alloc, ISzAlloc *allocBig)
{
    CLzmaEnc *p = (CLzmaEnc *)pp;
    p->matchFinderBase.stream = inStream;
    p->needInit = 1;
    return LzmaEnc_AllocAndInit(p, keepWindowSize, alloc, allocBig);
}

static void LzmaEnc_SetInputBuf(CLzmaEnc *p, const Byte *src, SizeT srcLen)
{
    p->matchFinderBase.directInput = 1;
    p->matchFinderBase.bufferBase = (Byte *)src;
    p->matchFinderBase.directInputRem = srcLen;
}

SRes LzmaEnc_MemPrepare(CLzmaEncHandle pp, const Byte *src, SizeT srcLen,
    UInt32 keepWindowSize, ISzAlloc *alloc, ISzAlloc *allocBig)
{
    CLzmaEnc *p = (CLzmaEnc *)pp;
    LzmaEnc_SetInputBuf(p, src, srcLen);
    p->needInit = 1;

    return LzmaEnc_AllocAndInit(p, keepWindowSize, alloc, allocBig);
}

void LzmaEnc_Finish(CLzmaEncHandle pp)
{
#ifndef _7ZIP_ST
    CLzmaEnc *p = (CLzmaEnc *)pp;
    if (p->mtMode)
        MatchFinderMt_ReleaseStream(&p->matchFinderMt);
#else
    (void)pp;
#endif
}

typedef struct
{
    ISeqOutStream funcTable;
    Byte *data;
    SizeT rem;
    Bool overflow;
} CSeqOutStreamBuf;

static size_t MyWrite(void *pp, const void *data, size_t size)
{
    CSeqOutStreamBuf *p = (CSeqOutStreamBuf *)pp;
    if (p->rem < size)
    {
        size = p->rem;
        p->overflow = True;
    }
    memcpy(p->data, data, size);
    p->rem -= size;
    p->data += size;
    return size;
}

UInt32 LzmaEnc_GetNumAvailableBytes(CLzmaEncHandle pp)
{
    const CLzmaEnc *p = (CLzmaEnc *)pp;
    return p->matchFinder.GetNumAvailableBytes(p->matchFinderObj);
}

const Byte *LzmaEnc_GetCurBuf(CLzmaEncHandle pp)
{
    const CLzmaEnc *p = (CLzmaEnc *)pp;
    return p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - p->additionalOffset;
}

SRes LzmaEnc_CodeOneMemBlock(CLzmaEncHandle pp, Bool reInit,
    Byte *dest, size_t *destLen, UInt32 desiredPackSize, UInt32 *unpackSize)
{
    CLzmaEnc *p = (CLzmaEnc *)pp;
    UInt64 nowPos64;
    SRes res;
    CSeqOutStreamBuf outStream;

    outStream.funcTable.Write = MyWrite;
    outStream.data = dest;
    outStream.rem = *destLen;
    outStream.overflow = False;

    p->writeEndMark = False;
    p->finished = False;
    p->result = SZ_OK;

    if (reInit)
        LzmaEnc_Init(p);
    LzmaEnc_InitPrices(p);
    nowPos64 = p->nowPos64;
    RangeEnc_Init(&p->rc);
    p->rc.outStream = &outStream.funcTable;

    res = LzmaEnc_CodeOneBlock(p, True, desiredPackSize, *unpackSize);

    *unpackSize = (UInt32)(p->nowPos64 - nowPos64);
    *destLen -= outStream.rem;
    if (outStream.overflow)
        return SZ_ERROR_OUTPUT_EOF;

    return res;
}

static SRes LzmaEnc_Encode2(CLzmaEnc *p, ICompressProgress *progress)
{
    SRes res = SZ_OK;

#ifndef _7ZIP_ST
    Byte allocaDummy[0x300];
    int i = 0;
    for (i = 0; i < 16; i++)
        allocaDummy[i] = (Byte)i;
#endif

    for (;;)
    {
        res = LzmaEnc_CodeOneBlock(p, False, 0, 0);
        if (res != SZ_OK || p->finished != 0)
            break;
        if (progress != 0)
        {
            res = progress->Progress(progress, p->nowPos64, RangeEnc_GetProcessed(&p->rc));
            if (res != SZ_OK)
            {
                res = SZ_ERROR_PROGRESS;
                break;
            }
        }
    }
    LzmaEnc_Finish(p);
    return res;
}

SRes LzmaEnc_Encode(CLzmaEncHandle pp, ISeqOutStream *outStream, ISeqInStream *inStream, ICompressProgress *progress,
    ISzAlloc *alloc, ISzAlloc *allocBig)
{
    RINOK(LzmaEnc_Prepare(pp, outStream, inStream, alloc, allocBig));
    return LzmaEnc_Encode2((CLzmaEnc *)pp, progress);
}

SRes LzmaEnc_WriteProperties(CLzmaEncHandle pp, Byte *props, SizeT *size)
{
    CLzmaEnc *p = (CLzmaEnc *)pp;
    int i;
    UInt32 dictSize = p->dictSize;
    if (*size < LZMA_PROPS_SIZE)
        return SZ_ERROR_PARAM;
    *size = LZMA_PROPS_SIZE;
    props[0] = (Byte)((p->pb * 5 + p->lp) * 9 + p->lc);

    for (i = 11; i <= 30; i++)
    {
        if (dictSize <= ((UInt32)2 << i))
        {
            dictSize = (2 << i);
            break;
        }
        if (dictSize <= ((UInt32)3 << i))
        {
            dictSize = (3 << i);
            break;
        }
    }

    for (i = 0; i < 4; i++)
        props[1 + i] = (Byte)(dictSize >> (8 * i));
    return SZ_OK;
}

SRes LzmaEnc_MemEncode(CLzmaEncHandle pp, Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
    int writeEndMark, ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig)
{
    SRes res;
    CLzmaEnc *p = (CLzmaEnc *)pp;

    CSeqOutStreamBuf outStream;

    LzmaEnc_SetInputBuf(p, src, srcLen);

    outStream.funcTable.Write = MyWrite;
    outStream.data = dest;
    outStream.rem = *destLen;
    outStream.overflow = False;

    p->writeEndMark = writeEndMark;

    p->rc.outStream = &outStream.funcTable;
    res = LzmaEnc_MemPrepare(pp, src, srcLen, 0, alloc, allocBig);
    if (res == SZ_OK)
        res = LzmaEnc_Encode2(p, progress);

    *destLen -= outStream.rem;
    if (outStream.overflow)
        return SZ_ERROR_OUTPUT_EOF;
    return res;
}

SRes LzmaEncode(Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
    const CLzmaEncProps *props, Byte *propsEncoded, SizeT *propsSize, int writeEndMark,
    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig)
{
    CLzmaEnc *p = (CLzmaEnc *)LzmaEnc_Create(alloc);
    SRes res;
    if (p == 0)
        return SZ_ERROR_MEM;

    res = LzmaEnc_SetProps(p, props);
    if (res == SZ_OK)
    {
        res = LzmaEnc_WriteProperties(p, propsEncoded, propsSize);
        if (res == SZ_OK)
            res = LzmaEnc_MemEncode(p, dest, destLen, src, srcLen,
            writeEndMark, progress, alloc, allocBig);
    }

    LzmaEnc_Destroy(p, alloc, allocBig);
    return res;
}

```

`efiXloader/3rd/uefitool/common/LZMA/SDK/C/LzmaEnc.h`:

```h
/*  LzmaEnc.h -- LZMA Encoder
2009-02-07 : Igor Pavlov : Public domain */

#ifndef __LZMA_ENC_H
#define __LZMA_ENC_H

#include "Types.h"

#ifdef __cplusplus
extern "C" {
#endif

#define LZMA_PROPS_SIZE 5

typedef struct _CLzmaEncProps
{
  int level;       /*  0 <= level <= 9 */
  UInt32 dictSize; /* (1 << 12) <= dictSize <= (1 << 27) for 32-bit version
                      (1 << 12) <= dictSize <= (1 << 30) for 64-bit version
                       default = (1 << 24) */
  int lc;          /* 0 <= lc <= 8, default = 3 */
  int lp;          /* 0 <= lp <= 4, default = 0 */
  int pb;          /* 0 <= pb <= 4, default = 2 */
  int algo;        /* 0 - fast, 1 - normal, default = 1 */
  int fb;          /* 5 <= fb <= 273, default = 32 */
  int btMode;      /* 0 - hashChain Mode, 1 - binTree mode - normal, default = 1 */
  int numHashBytes; /* 2, 3 or 4, default = 4 */
  UInt32 mc;        /* 1 <= mc <= (1 << 30), default = 32 */
  unsigned writeEndMark;  /* 0 - do not write EOPM, 1 - write EOPM, default = 0 */
  int numThreads;  /* 1 or 2, default = 2 */
} CLzmaEncProps;

void LzmaEncProps_Init(CLzmaEncProps *p);
void LzmaEncProps_Normalize(CLzmaEncProps *p);
UInt32 LzmaEncProps_GetDictSize(const CLzmaEncProps *props2);


/* ---------- CLzmaEncHandle Interface ---------- */

/* LzmaEnc_* functions can return the following exit codes:
Returns:
  SZ_OK           - OK
  SZ_ERROR_MEM    - Memory allocation error
  SZ_ERROR_PARAM  - Incorrect paramater in props
  SZ_ERROR_WRITE  - Write callback error.
  SZ_ERROR_PROGRESS - some break from progress callback
  SZ_ERROR_THREAD - errors in multithreading functions (only for Mt version)
*/

typedef void * CLzmaEncHandle;

CLzmaEncHandle LzmaEnc_Create(ISzAlloc *alloc);
void LzmaEnc_Destroy(CLzmaEncHandle p, ISzAlloc *alloc, ISzAlloc *allocBig);
SRes LzmaEnc_SetProps(CLzmaEncHandle p, const CLzmaEncProps *props);
SRes LzmaEnc_WriteProperties(CLzmaEncHandle p, Byte *properties, SizeT *size);
SRes LzmaEnc_Encode(CLzmaEncHandle p, ISeqOutStream *outStream, ISeqInStream *inStream,
    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
SRes LzmaEnc_MemEncode(CLzmaEncHandle p, Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
    int writeEndMark, ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);

/* ---------- One Call Interface ---------- */

/* LzmaEncode
Return code:
  SZ_OK               - OK
  SZ_ERROR_MEM        - Memory allocation error
  SZ_ERROR_PARAM      - Incorrect paramater
  SZ_ERROR_OUTPUT_EOF - output buffer overflow
  SZ_ERROR_THREAD     - errors in multithreading functions (only for Mt version)
*/

SRes LzmaEncode(Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
    const CLzmaEncProps *props, Byte *propsEncoded, SizeT *propsSize, int writeEndMark,
    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);

#ifdef __cplusplus
}
#endif

#endif

```

`efiXloader/3rd/uefitool/common/LZMA/SDK/C/Types.h`:

```h
/* Types.h -- Basic types
2010-10-09 : Igor Pavlov : Public domain */

#ifndef __7Z_TYPES_H
#define __7Z_TYPES_H

#include "../../UefiLzma.h"

#include <stddef.h>

#ifdef _WIN32
#include <windows.h>
#endif

#ifndef EXTERN_C_BEGIN
#ifdef __cplusplus
#define EXTERN_C_BEGIN extern "C" {
#define EXTERN_C_END }
#else
#define EXTERN_C_BEGIN
#define EXTERN_C_END
#endif
#endif

EXTERN_C_BEGIN

#define SZ_OK 0

#define SZ_ERROR_DATA 1
#define SZ_ERROR_MEM 2
#define SZ_ERROR_CRC 3
#define SZ_ERROR_UNSUPPORTED 4
#define SZ_ERROR_PARAM 5
#define SZ_ERROR_INPUT_EOF 6
#define SZ_ERROR_OUTPUT_EOF 7
#define SZ_ERROR_READ 8
#define SZ_ERROR_WRITE 9
#define SZ_ERROR_PROGRESS 10
#define SZ_ERROR_FAIL 11
#define SZ_ERROR_THREAD 12

#define SZ_ERROR_ARCHIVE 16
#define SZ_ERROR_NO_ARCHIVE 17

typedef int SRes;

#ifdef _WIN32
typedef DWORD WRes;
#else
typedef int WRes;
#endif

#ifndef RINOK
#define RINOK(x) { int __result__ = (x); if (__result__ != 0) return __result__; }
#endif

typedef unsigned char Byte;
typedef short Int16;
typedef unsigned short UInt16;

#ifdef _LZMA_UINT32_IS_ULONG
typedef long Int32;
typedef unsigned long UInt32;
#else
typedef int Int32;
typedef unsigned int UInt32;
#endif

#ifdef _SZ_NO_INT_64

/* define _SZ_NO_INT_64, if your compiler doesn't support 64-bit integers.
   NOTES: Some code will work incorrectly in that case! */

typedef long Int64;
typedef unsigned long UInt64;

#else

#if defined(_MSC_VER) || defined(__BORLANDC__)
typedef __int64 Int64;
typedef unsigned __int64 UInt64;
#define UINT64_CONST(n) n
#else
typedef long long int Int64;
typedef unsigned long long int UInt64;
#define UINT64_CONST(n) n ## ULL
#endif

#endif

#ifdef _LZMA_NO_SYSTEM_SIZE_T
typedef UInt32 SizeT;
#else
typedef size_t SizeT;
#endif

typedef int Bool;
#define True 1
#define False 0


#ifdef _WIN32
#define MY_STD_CALL __stdcall
#else
#define MY_STD_CALL
#endif

#ifdef _MSC_VER

#if _MSC_VER >= 1300
#define MY_NO_INLINE __declspec(noinline)
#else
#define MY_NO_INLINE
#endif

#define MY_CDECL __cdecl
#define MY_FAST_CALL __fastcall

#else

#define MY_CDECL
#define MY_FAST_CALL

#endif


/* The following interfaces use first parameter as pointer to structure */

typedef struct
{
  Byte (*Read)(void *p); /* reads one byte, returns 0 in case of EOF or error */
} IByteIn;

typedef struct
{
  void (*Write)(void *p, Byte b);
} IByteOut;

typedef struct
{
  SRes (*Read)(void *p, void *buf, size_t *size);
    /* if (input(*size) != 0 && output(*size) == 0) means end_of_stream.
       (output(*size) < input(*size)) is allowed */
} ISeqInStream;

/* it can return SZ_ERROR_INPUT_EOF */
SRes SeqInStream_Read(ISeqInStream *stream, void *buf, size_t size);
SRes SeqInStream_Read2(ISeqInStream *stream, void *buf, size_t size, SRes errorType);
SRes SeqInStream_ReadByte(ISeqInStream *stream, Byte *buf);

typedef struct
{
  size_t (*Write)(void *p, const void *buf, size_t size);
    /* Returns: result - the number of actually written bytes.
       (result < size) means error */
} ISeqOutStream;

typedef enum
{
  SZ_SEEK_SET = 0,
  SZ_SEEK_CUR = 1,
  SZ_SEEK_END = 2
} ESzSeek;

typedef struct
{
  SRes (*Read)(void *p, void *buf, size_t *size);  /* same as ISeqInStream::Read */
  SRes (*Seek)(void *p, Int64 *pos, ESzSeek origin);
} ISeekInStream;

typedef struct
{
  SRes (*Look)(void *p, const void **buf, size_t *size);
    /* if (input(*size) != 0 && output(*size) == 0) means end_of_stream.
       (output(*size) > input(*size)) is not allowed
       (output(*size) < input(*size)) is allowed */
  SRes (*Skip)(void *p, size_t offset);
    /* offset must be <= output(*size) of Look */

  SRes (*Read)(void *p, void *buf, size_t *size);
    /* reads directly (without buffer). It's same as ISeqInStream::Read */
  SRes (*Seek)(void *p, Int64 *pos, ESzSeek origin);
} ILookInStream;

SRes LookInStream_LookRead(ILookInStream *stream, void *buf, size_t *size);
SRes LookInStream_SeekTo(ILookInStream *stream, UInt64 offset);

/* reads via ILookInStream::Read */
SRes LookInStream_Read2(ILookInStream *stream, void *buf, size_t size, SRes errorType);
SRes LookInStream_Read(ILookInStream *stream, void *buf, size_t size);

#define LookToRead_BUF_SIZE (1 << 14)

typedef struct
{
  ILookInStream s;
  ISeekInStream *realStream;
  size_t pos;
  size_t size;
  Byte buf[LookToRead_BUF_SIZE];
} CLookToRead;

void LookToRead_CreateVTable(CLookToRead *p, int lookahead);
void LookToRead_Init(CLookToRead *p);

typedef struct
{
  ISeqInStream s;
  ILookInStream *realStream;
} CSecToLook;

void SecToLook_CreateVTable(CSecToLook *p);

typedef struct
{
  ISeqInStream s;
  ILookInStream *realStream;
} CSecToRead;

void SecToRead_CreateVTable(CSecToRead *p);

typedef struct
{
  SRes (*Progress)(void *p, UInt64 inSize, UInt64 outSize);
    /* Returns: result. (result != SZ_OK) means break.
       Value (UInt64)(Int64)-1 for size means unknown value. */
} ICompressProgress;

typedef struct
{
  void *(*Alloc)(void *p, size_t size);
  void (*Free)(void *p, void *address); /* address can be 0 */
} ISzAlloc;

#define IAlloc_Alloc(p, size) (p)->Alloc((p), size)
#define IAlloc_Free(p, a) (p)->Free((p), a)

#ifdef _WIN32

#define CHAR_PATH_SEPARATOR '\\'
#define WCHAR_PATH_SEPARATOR L'\\'
#define STRING_PATH_SEPARATOR "\\"
#define WSTRING_PATH_SEPARATOR L"\\"

#else

#define CHAR_PATH_SEPARATOR '/'
#define WCHAR_PATH_SEPARATOR L'/'
#define STRING_PATH_SEPARATOR "/"
#define WSTRING_PATH_SEPARATOR L"/"

#endif

EXTERN_C_END

#endif

```

`efiXloader/3rd/uefitool/common/LZMA/UefiLzma.h`:

```h
/* LZMA UEFI header file

  Copyright (c) 2009, Intel Corporation. All rights reserved.
  This program and the accompanying materials
  are licensed and made available under the terms and conditions of the BSD License
  which accompanies this distribution.  The full text of the license may be found at
  http://opensource.org/licenses/bsd-license.php

  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
  WITHWARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

*/

#ifndef __UEFILZMA_H__
#define __UEFILZMA_H__

#include "../basetypes.h"

#ifdef _WIN32
#undef _WIN32
#endif

#ifdef _WIN64
#undef _WIN64
#endif

#define _LZMA_SIZE_OPT
#define _7ZIP_ST

#endif // __UEFILZMA_H__


```

`efiXloader/3rd/uefitool/common/Tiano/EfiTianoCompress.c`:

```c
/** @file
Compression routine. The compression algorithm is a mixture of LZ77 and Huffman 
coding. LZ77 transforms the source data into a sequence of Original Characters 
and Pointers to repeated strings. This sequence is further divided into Blocks 
and Huffman codings are applied to each Block.

Copyright (c) 2014, Nikolaj Schlej
Copyright (c) 2006 - 2014, Intel Corporation. All rights reserved.<BR>
This program and the accompanying materials                          
are licensed and made available under the terms and conditions of the BSD License         
which accompanies this distribution.  The full text of the license may be found at        
http://opensource.org/licenses/bsd-license.php                                            
                                                                                          
THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,                     
WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.             

**/

#include "EfiTianoCompress.h"


//
// Macro Definitions
//

#undef UINT8_MAX
typedef INT16             NODE;
#define UINT8_MAX         0xff
#define UINT8_BIT         8
#define THRESHOLD         3
#define INIT_CRC          0
#define WNDBIT            13
#define WNDSIZ            (1U << WNDBIT)
#define MAXMATCH          256
#define PERC_FLAG         0x8000U
#define CODE_BIT          16
#define NIL               0
#define MAX_HASH_VAL      (3 * WNDSIZ + (WNDSIZ / 512 + 1) * UINT8_MAX)
#define HASH(p, c)        ((p) + ((c) << (WNDBIT - 9)) + WNDSIZ * 2)
#define CRCPOLY           0xA001
#define UPDATE_CRC(c)     mCrc = mCrcTable[(mCrc ^ (c)) & 0xFF] ^ (mCrc >> UINT8_BIT)

//
// C: the Char&Len Set; P: the Position Set; T: the exTra Set
//

#define NC                (UINT8_MAX + MAXMATCH + 2 - THRESHOLD)
#define CBIT              9
#define NP                (WNDBIT + 1)
//#define PBIT              4
UINT8 gPBIT = 4;
#define NT                (CODE_BIT + 3)
#define TBIT              5
#if NT > NP
  #define                 NPT NT
#else
  #define                 NPT NP
#endif

//
// Function Prototypes
//

STATIC
VOID 
PutDword(
  IN UINT32 Data
  );

STATIC
EFI_STATUS 
AllocateMemory (VOID);

STATIC
VOID
FreeMemory (VOID);

STATIC 
VOID 
InitSlide (VOID);

STATIC 
NODE 
Child (
  IN NODE q, 
  IN UINT8 c
  );

STATIC 
VOID 
MakeChild (
  IN NODE q, 
  IN UINT8 c, 
  IN NODE r
  );
  
STATIC 
VOID 
Split (
  IN NODE Old
  );

STATIC 
VOID 
InsertNode (VOID);
  
STATIC 
VOID 
DeleteNode (VOID);

STATIC 
VOID 
GetNextMatch (VOID);
  
STATIC 
EFI_STATUS 
Encode (VOID);

STATIC 
VOID 
CountTFreq (VOID);

STATIC 
VOID 
WritePTLen (
  IN INT32 n, 
  IN INT32 nbit, 
  IN INT32 Special
  );

STATIC 
VOID 
WriteCLen (VOID);
  
STATIC 
VOID 
EncodeC (
  IN INT32 c
  );

STATIC 
VOID 
EncodeP (
  IN UINT32 p
  );

STATIC 
VOID 
SendBlock (VOID);
  
STATIC 
VOID 
Output (
  IN UINT32 c, 
  IN UINT32 p
  );

STATIC 
VOID 
HufEncodeStart (VOID);
  
STATIC 
VOID 
HufEncodeEnd (VOID);
  
STATIC 
VOID 
MakeCrcTable (VOID);
  
STATIC 
VOID 
PutBits (
  IN INT32 n, 
  IN UINT32 x
  );
  
STATIC 
INT32 
FreadCrc (
  OUT UINT8 *p, 
  IN  INT32 n
  );
  
STATIC 
VOID 
InitPutBits (VOID);
  
STATIC 
VOID 
CountLen (
  IN INT32 i
  );

STATIC 
VOID 
MakeLen (
  IN INT32 Root
  );
  
STATIC 
VOID 
DownHeap (
  IN INT32 i
  );

STATIC 
VOID 
MakeCode (
  IN  INT32 n, 
  IN  UINT8 Len[], 
  OUT UINT16 Code[]
  );
  
STATIC 
INT32 
MakeTree (
  IN  INT32   NParm, 
  IN  UINT16  FreqParm[], 
  OUT UINT8   LenParm[], 
  OUT UINT16  CodeParm[]
  );


//
//  Global Variables
//

STATIC UINT8  *mSrc, *mDst, *mSrcUpperLimit, *mDstUpperLimit;

STATIC UINT8  *mLevel, *mText, *mChildCount, *mBuf, mCLen[NC], mPTLen[NPT], *mLen;
STATIC INT16  mHeap[NC + 1];
STATIC INT32  mRemainder, mMatchLen, mBitCount, mHeapSize, mN;
STATIC UINT32 mBufSiz = 0, mOutputPos, mOutputMask, mSubBitBuf, mCrc;
STATIC UINT32 mCompSize, mOrigSize;

STATIC UINT16 *mFreq, *mSortPtr, mLenCnt[17], mLeft[2 * NC - 1], mRight[2 * NC - 1],
              mCrcTable[UINT8_MAX + 1], mCFreq[2 * NC - 1],mCCode[NC],
              mPFreq[2 * NP - 1], mPTCode[NPT], mTFreq[2 * NT - 1];

STATIC NODE   mPos, mMatchPos, mAvail, *mPosition, *mParent, *mPrev, *mNext = NULL;


//
// functions
//

EFI_STATUS
EfiCompress (
  IN      CONST VOID   *SrcBuffer,
  IN      UINT32  SrcSize,
  IN      VOID   *DstBuffer,
  IN OUT  UINT32  *DstSize
  )
/*++

Routine Description:

  The main compression routine.

Arguments:

  SrcBuffer   - The buffer storing the source data
  SrcSize     - The size of source data
  DstBuffer   - The buffer to store the compressed data
  DstSize     - On input, the size of DstBuffer; On output,
                the size of the actual compressed data.

Returns:

  EFI_BUFFER_TOO_SMALL  - The DstBuffer is too small. In this case,
                DstSize contains the size needed.
  EFI_SUCCESS           - Compression is successful.

--*/
{
  EFI_STATUS Status = EFI_SUCCESS;
  
  //
  // Initializations
  //
  mBufSiz = 0;
  mBuf = NULL;
  mText       = NULL;
  mLevel      = NULL;
  mChildCount = NULL;
  mPosition   = NULL;
  mParent     = NULL;
  mPrev       = NULL;
  mNext       = NULL;
  gPBIT = 4;
  
  mSrc = (UINT8*)SrcBuffer;
  mSrcUpperLimit = mSrc + SrcSize;
  mDst = DstBuffer;
  mDstUpperLimit = mDst + *DstSize;

  PutDword(0L);
  PutDword(0L);
  
  MakeCrcTable ();

  mOrigSize = mCompSize = 0;
  mCrc = INIT_CRC;
  
  //
  // Compress it
  //
  
  Status = Encode();
  if (EFI_ERROR (Status)) {
    return EFI_OUT_OF_RESOURCES;
  }
  
  //
  // Null terminate the compressed data
  //
  if (mDst < mDstUpperLimit) {
    *mDst++ = 0;
  }
  
  //
  // Fill in compressed size and original size
  //
  mDst = DstBuffer;
  PutDword(mCompSize+1);
  PutDword(mOrigSize);

  //
  // Return
  //
  
  if (mCompSize + 1 + 8 > *DstSize) {
    *DstSize = mCompSize + 1 + 8;
    return EFI_BUFFER_TOO_SMALL;
  } else {
    *DstSize = mCompSize + 1 + 8;
    return EFI_SUCCESS;
  }

}

EFI_STATUS
TianoCompress(
IN      CONST VOID   *SrcBuffer,
IN      UINT32  SrcSize,
IN      VOID   *DstBuffer,
IN OUT  UINT32  *DstSize
)
/*++

Routine Description:

The main compression routine.

Arguments:

SrcBuffer   - The buffer storing the source data
SrcSize     - The size of source data
DstBuffer   - The buffer to store the compressed data
DstSize     - On input, the size of DstBuffer; On output,
the size of the actual compressed data.

Returns:

EFI_BUFFER_TOO_SMALL  - The DstBuffer is too small. In this case,
DstSize contains the size needed.
EFI_SUCCESS           - Compression is successful.

--*/
{
    EFI_STATUS Status = EFI_SUCCESS;

    //
    // Initializations
    //
    mBufSiz = 0;
    mBuf = NULL;
    mText = NULL;
    mLevel = NULL;
    mChildCount = NULL;
    mPosition = NULL;
    mParent = NULL;
    mPrev = NULL;
    mNext = NULL;
    gPBIT = 5;

    mSrc = (UINT8*)SrcBuffer;
    mSrcUpperLimit = mSrc + SrcSize;
    mDst = DstBuffer;
    mDstUpperLimit = mDst + *DstSize;

    PutDword(0L);
    PutDword(0L);

    MakeCrcTable();

    mOrigSize = mCompSize = 0;
    mCrc = INIT_CRC;

    //
    // Compress it
    //

    Status = Encode();
    if (EFI_ERROR(Status)) {
        return EFI_OUT_OF_RESOURCES;
    }

    //
    // Null terminate the compressed data
    //
    if (mDst < mDstUpperLimit) {
        *mDst++ = 0;
    }

    //
    // Fill in compressed size and original size
    //
    mDst = DstBuffer;
    PutDword(mCompSize + 1);
    PutDword(mOrigSize);

    //
    // Return
    //

    if (mCompSize + 1 + 8 > *DstSize) {
        *DstSize = mCompSize + 1 + 8;
        return EFI_BUFFER_TOO_SMALL;
    }
    else {
        *DstSize = mCompSize + 1 + 8;
        return EFI_SUCCESS;
    }

}

STATIC 
VOID 
PutDword(
  IN UINT32 Data
  )
/*++

Routine Description:

  Put a dword to output stream
  
Arguments:

  Data    - the dword to put
  
Returns: (VOID)
  
--*/
{
  if (mDst < mDstUpperLimit) {
    *mDst++ = (UINT8)(((UINT8)(Data        )) & 0xff);
  }

  if (mDst < mDstUpperLimit) {
    *mDst++ = (UINT8)(((UINT8)(Data >> 0x08)) & 0xff);
  }

  if (mDst < mDstUpperLimit) {
    *mDst++ = (UINT8)(((UINT8)(Data >> 0x10)) & 0xff);
  }

  if (mDst < mDstUpperLimit) {
    *mDst++ = (UINT8)(((UINT8)(Data >> 0x18)) & 0xff);
  }
}

STATIC
EFI_STATUS
AllocateMemory ()
/*++

Routine Description:

  Allocate memory spaces for data structures used in compression process
  
Argements: (VOID)

Returns:

  EFI_SUCCESS           - Memory is allocated successfully
  EFI_OUT_OF_RESOURCES  - Allocation fails

--*/
{
  UINT32      i;
  
  mText       = malloc (WNDSIZ * 2 + MAXMATCH);
  if (!mText) return EFI_OUT_OF_RESOURCES;
  for (i = 0 ; i < WNDSIZ * 2 + MAXMATCH; i ++) {
    mText[i] = 0;
  }

  mLevel            = malloc((WNDSIZ + UINT8_MAX + 1) * sizeof(*mLevel));
  if (!mLevel)        return EFI_OUT_OF_RESOURCES;
  mChildCount       = malloc((WNDSIZ + UINT8_MAX + 1) * sizeof(*mChildCount));
  if (!mChildCount)   return EFI_OUT_OF_RESOURCES;
  mPosition         = malloc((WNDSIZ + UINT8_MAX + 1) * sizeof(*mPosition));
  if (!mPosition)     return EFI_OUT_OF_RESOURCES;
  mParent           = malloc(WNDSIZ * 2 * sizeof(*mParent));
  if (!mParent)       return EFI_OUT_OF_RESOURCES;
  mPrev             = malloc(WNDSIZ * 2 * sizeof(*mPrev));
  if (!mPrev)         return EFI_OUT_OF_RESOURCES;
  mNext             = malloc((MAX_HASH_VAL + 1) * sizeof(*mNext));
  if (!mNext)         return EFI_OUT_OF_RESOURCES;

  mBufSiz = 16 * 1024U;
  while ((mBuf = malloc(mBufSiz)) == NULL) {
    mBufSiz = (mBufSiz / 10U) * 9U;
    if (mBufSiz < 4 * 1024U) {
      return EFI_OUT_OF_RESOURCES;
    }
  }
  mBuf[0] = 0;
  
  return EFI_SUCCESS;
}

VOID
FreeMemory ()
/*++

Routine Description:

  Called when compression is completed to free memory previously allocated.
  
Arguments: (VOID)

Returns: (VOID)

--*/
{
    free (mText);
    free (mLevel);
    free (mChildCount);
    free (mPosition);
    free (mParent);
    free (mPrev);
    free (mNext);
    free (mBuf);
}


STATIC 
VOID 
InitSlide ()
/*++

Routine Description:

  Initialize String Info Log data structures
  
Arguments: (VOID)

Returns: (VOID)

--*/
{
  NODE i;

  for (i = WNDSIZ; i <= (NODE)(WNDSIZ + UINT8_MAX); i++) {
    mLevel[i] = 1;
    mPosition[i] = NIL;  /* sentinel */
  }
  for (i = WNDSIZ; i < (NODE)(WNDSIZ * 2); i++) {
    mParent[i] = NIL;
  }  
  mAvail = 1;
  for (i = 1; i < (NODE)(WNDSIZ - 1); i++) {
    mNext[i] = (NODE)(i + 1);
  }
  
  mNext[WNDSIZ - 1] = NIL;
  for (i = WNDSIZ * 2; i <= (NODE)MAX_HASH_VAL; i++) {
    mNext[i] = NIL;
  }  
}


STATIC 
NODE 
Child (
  IN NODE q, 
  IN UINT8 c
  )
/*++

Routine Description:

  Find child node given the parent node and the edge character
  
Arguments:

  q       - the parent node
  c       - the edge character
  
Returns:

  The child node (NIL if not found)  
  
--*/
{
  NODE r;
  
  r = mNext[HASH(q, c)];
  mParent[NIL] = q;  /* sentinel */
  while (mParent[r] != q) {
    r = mNext[r];
  }
  
  return r;
}

STATIC 
VOID 
MakeChild (
  IN NODE q, 
  IN UINT8 c, 
  IN NODE r
  )
/*++

Routine Description:

  Create a new child for a given parent node.
  
Arguments:

  q       - the parent node
  c       - the edge character
  r       - the child node
  
Returns: (VOID)

--*/
{
  NODE h, t;
  
  h = (NODE)HASH(q, c);
  t = mNext[h];
  mNext[h] = r;
  mNext[r] = t;
  mPrev[t] = r;
  mPrev[r] = h;
  mParent[r] = q;
  mChildCount[q]++;
}

STATIC 
VOID 
Split (
  NODE Old
  )
/*++

Routine Description:

  Split a node.
  
Arguments:

  Old     - the node to split
  
Returns: (VOID)

--*/
{
  NODE New, t;

  New = mAvail;
  mAvail = mNext[New];
  mChildCount[New] = 0;
  t = mPrev[Old];
  mPrev[New] = t;
  mNext[t] = New;
  t = mNext[Old];
  mNext[New] = t;
  mPrev[t] = New;
  mParent[New] = mParent[Old];
  mLevel[New] = (UINT8)mMatchLen;
  mPosition[New] = mPos;
  MakeChild(New, mText[mMatchPos + mMatchLen], Old);
  MakeChild(New, mText[mPos + mMatchLen], mPos);
}

STATIC 
VOID 
InsertNode ()
/*++

Routine Description:

  Insert string info for current position into the String Info Log
  
Arguments: (VOID)

Returns: (VOID)

--*/
{
  NODE q, r, j, t;
  UINT8 c, *t1, *t2;

  if (mMatchLen >= 4) {
    
    //
    // We have just got a long match, the target tree
    // can be located by MatchPos + 1. Travese the tree
    // from bottom up to get to a proper starting point.
    // The usage of PERC_FLAG ensures proper node deletion
    // in DeleteNode() later.
    //
    
    mMatchLen--;
    r = (INT16)((mMatchPos + 1) | WNDSIZ);
    while ((q = mParent[r]) == NIL) {
      r = mNext[r];
    }
    while (mLevel[q] >= mMatchLen) {
      r = q;  q = mParent[q];
    }
    t = q;
    while (mPosition[t] < 0) {
      mPosition[t] = mPos;
      t = mParent[t];
    }
    if (t < (NODE)WNDSIZ) {
      mPosition[t] = (NODE)(mPos | PERC_FLAG);
    }    
  } else {
    
    //
    // Locate the target tree
    //
    
    q = (INT16)(mText[mPos] + WNDSIZ);
    c = mText[mPos + 1];
    if ((r = Child(q, c)) == NIL) {
      MakeChild(q, c, mPos);
      mMatchLen = 1;
      return;
    }
    mMatchLen = 2;
  }
  
  //
  // Traverse down the tree to find a match.
  // Update Position value along the route.
  // Node split or creation is involved.
  //
  
  for ( ; ; ) {
    if (r >= (NODE)WNDSIZ) {
      j = MAXMATCH;
      mMatchPos = r;
    } else {
      j = mLevel[r];
      mMatchPos = (NODE)(mPosition[r] & ~PERC_FLAG);
    }
    if (mMatchPos >= mPos) {
      mMatchPos -= WNDSIZ;
    }    
    t1 = &mText[mPos + mMatchLen];
    t2 = &mText[mMatchPos + mMatchLen];
    while (mMatchLen < j) {
      if (*t1 != *t2) {
        Split(r);
        return;
      }
      mMatchLen++;
      t1++;
      t2++;
    }
    if (mMatchLen >= MAXMATCH) {
      break;
    }
    mPosition[r] = mPos;
    q = r;
    if ((r = Child(q, *t1)) == NIL) {
      MakeChild(q, *t1, mPos);
      return;
    }
    mMatchLen++;
  }
  t = mPrev[r];
  mPrev[mPos] = t;
  mNext[t] = mPos;
  t = mNext[r];
  mNext[mPos] = t;
  mPrev[t] = mPos;
  mParent[mPos] = q;
  mParent[r] = NIL;
  
  //
  // Special usage of 'next'
  //
  mNext[r] = mPos;
  
}

STATIC 
VOID 
DeleteNode ()
/*++

Routine Description:

  Delete outdated string info. (The Usage of PERC_FLAG
  ensures a clean deletion)
  
Arguments: (VOID)

Returns: (VOID)

--*/
{
  NODE q, r, s, t, u;

  if (mParent[mPos] == NIL) {
    return;
  }
  
  r = mPrev[mPos];
  s = mNext[mPos];
  mNext[r] = s;
  mPrev[s] = r;
  r = mParent[mPos];
  mParent[mPos] = NIL;
  if (r >= (NODE)WNDSIZ || --mChildCount[r] > 1) {
    return;
  }
  t = (NODE)(mPosition[r] & ~PERC_FLAG);
  if (t >= mPos) {
    t -= WNDSIZ;
  }
  s = t;
  q = mParent[r];
  while ((u = mPosition[q]) & PERC_FLAG) {
    u &= ~PERC_FLAG;
    if (u >= mPos) {
      u -= WNDSIZ;
    }
    if (u > s) {
      s = u;
    }
    mPosition[q] = (INT16)(s | WNDSIZ);
    q = mParent[q];
  }
  if (q < (NODE)WNDSIZ) {
    if (u >= mPos) {
      u -= WNDSIZ;
    }
    if (u > s) {
      s = u;
    }
    mPosition[q] = (INT16)(s | WNDSIZ | PERC_FLAG);
  }
  s = Child(r, mText[t + mLevel[r]]);
  t = mPrev[s];
  u = mNext[s];
  mNext[t] = u;
  mPrev[u] = t;
  t = mPrev[r];
  mNext[t] = s;
  mPrev[s] = t;
  t = mNext[r];
  mPrev[t] = s;
  mNext[s] = t;
  mParent[s] = mParent[r];
  mParent[r] = NIL;
  mNext[r] = mAvail;
  mAvail = r;
}

STATIC 
VOID 
GetNextMatch ()
/*++

Routine Description:

  Advance the current position (read in new data if needed).
  Delete outdated string info. Find a match string for current position.

Arguments: (VOID)

Returns: (VOID)

--*/
{
  INT32 n;

  mRemainder--;
  if (++mPos == WNDSIZ * 2) {
    memmove(&mText[0], &mText[WNDSIZ], WNDSIZ + MAXMATCH);
    n = FreadCrc(&mText[WNDSIZ + MAXMATCH], WNDSIZ);
    mRemainder += n;
    mPos = WNDSIZ;
  }
  DeleteNode();
  InsertNode();
}

STATIC
EFI_STATUS
Encode ()
/*++

Routine Description:

  The main controlling routine for compression process.

Arguments: (VOID)

Returns:
  
  EFI_SUCCESS           - The compression is successful
  EFI_OUT_0F_RESOURCES  - Not enough memory for compression process

--*/
{
  EFI_STATUS  Status;
  INT32       LastMatchLen;
  NODE        LastMatchPos;

  Status = AllocateMemory();
  if (EFI_ERROR(Status)) {
    FreeMemory();
    return Status;
  }

  InitSlide();
  
  HufEncodeStart();

  mRemainder = FreadCrc(&mText[WNDSIZ], WNDSIZ + MAXMATCH);
  
  mMatchLen = 0;
  mPos = WNDSIZ;
  InsertNode();
  if (mMatchLen > mRemainder) {
    mMatchLen = mRemainder;
  }
  while (mRemainder > 0) {
    LastMatchLen = mMatchLen;
    LastMatchPos = mMatchPos;
    GetNextMatch();
    if (mMatchLen > mRemainder) {
      mMatchLen = mRemainder;
    }
    
    if (mMatchLen > LastMatchLen || LastMatchLen < THRESHOLD) {
      
      //
      // Not enough benefits are gained by outputting a pointer,
      // so just output the original character
      //
      
      Output(mText[mPos - 1], 0);
    } else {
      
      //
      // Outputting a pointer is beneficial enough, do it.
      //
      
      Output(LastMatchLen + (UINT8_MAX + 1 - THRESHOLD),
             (mPos - LastMatchPos - 2) & (WNDSIZ - 1));
      while (--LastMatchLen > 0) {
        GetNextMatch();
      }
      if (mMatchLen > mRemainder) {
        mMatchLen = mRemainder;
      }
    }
  }
  
  HufEncodeEnd();
  FreeMemory();
  return EFI_SUCCESS;
}

STATIC 
VOID 
CountTFreq ()
/*++

Routine Description:

  Count the frequencies for the Extra Set
  
Arguments: (VOID)

Returns: (VOID)

--*/
{
  INT32 i, k, n, Count;

  for (i = 0; i < NT; i++) {
    mTFreq[i] = 0;
  }
  n = NC;
  while (n > 0 && mCLen[n - 1] == 0) {
    n--;
  }
  i = 0;
  while (i < n) {
    k = mCLen[i++];
    if (k == 0) {
      Count = 1;
      while (i < n && mCLen[i] == 0) {
        i++;
        Count++;
      }
      if (Count <= 2) {
        mTFreq[0] = (UINT16)(mTFreq[0] + Count);
      } else if (Count <= 18) {
        mTFreq[1]++;
      } else if (Count == 19) {
        mTFreq[0]++;
        mTFreq[1]++;
      } else {
        mTFreq[2]++;
      }
    } else {
      mTFreq[k + 2]++;
    }
  }
}

STATIC 
VOID 
WritePTLen (
  IN INT32 n, 
  IN INT32 nbit, 
  IN INT32 Special
  )
/*++

Routine Description:

  Outputs the code length array for the Extra Set or the Position Set.
  
Arguments:

  n       - the number of symbols
  nbit    - the number of bits needed to represent 'n'
  Special - the special symbol that needs to be take care of
  
Returns: (VOID)

--*/
{
  INT32 i, k;

  while (n > 0 && mPTLen[n - 1] == 0) {
    n--;
  }
  PutBits(nbit, n);
  i = 0;
  while (i < n) {
    k = mPTLen[i++];
    if (k <= 6) {
      PutBits(3, k);
    } else {
      PutBits(k - 3, (1U << (k - 3)) - 2);
    }
    if (i == Special) {
      while (i < 6 && mPTLen[i] == 0) {
        i++;
      }
      PutBits(2, (i - 3) & 3);
    }
  }
}

STATIC 
VOID 
WriteCLen ()
/*++

Routine Description:

  Outputs the code length array for Char&Length Set
  
Arguments: (VOID)

Returns: (VOID)

--*/
{
  INT32 i, k, n, Count;

  n = NC;
  while (n > 0 && mCLen[n - 1] == 0) {
    n--;
  }
  PutBits(CBIT, n);
  i = 0;
  while (i < n) {
    k = mCLen[i++];
    if (k == 0) {
      Count = 1;
      while (i < n && mCLen[i] == 0) {
        i++;
        Count++;
      }
      if (Count <= 2) {
        for (k = 0; k < Count; k++) {
          PutBits(mPTLen[0], mPTCode[0]);
        }
      } else if (Count <= 18) {
        PutBits(mPTLen[1], mPTCode[1]);
        PutBits(4, Count - 3);
      } else if (Count == 19) {
        PutBits(mPTLen[0], mPTCode[0]);
        PutBits(mPTLen[1], mPTCode[1]);
        PutBits(4, 15);
      } else {
        PutBits(mPTLen[2], mPTCode[2]);
        PutBits(CBIT, Count - 20);
      }
    } else {
      PutBits(mPTLen[k + 2], mPTCode[k + 2]);
    }
  }
}

STATIC 
VOID 
EncodeC (
  IN INT32 c
  )
{
  PutBits(mCLen[c], mCCode[c]);
}

STATIC 
VOID 
EncodeP (
  IN UINT32 p
  )
{
  UINT32 c, q;

  c = 0;
  q = p;
  while (q) {
    q >>= 1;
    c++;
  }
  PutBits(mPTLen[c], mPTCode[c]);
  if (c > 1) {
    PutBits(c - 1, p & (0xFFFFU >> (17 - c)));
  }
}

STATIC 
VOID 
SendBlock ()
/*++

Routine Description:

  Huffman code the block and output it.
  
Argument: (VOID)

Returns: (VOID)

--*/
{
  UINT32 i, k, Flags, Root, Pos, Size;
  Flags = 0;

  Root = MakeTree(NC, mCFreq, mCLen, mCCode);
  Size = mCFreq[Root];
  PutBits(16, Size);
  if (Root >= NC) {
    CountTFreq();
    Root = MakeTree(NT, mTFreq, mPTLen, mPTCode);
    if (Root >= NT) {
      WritePTLen(NT, TBIT, 3);
    } else {
      PutBits(TBIT, 0);
      PutBits(TBIT, Root);
    }
    WriteCLen();
  } else {
    PutBits(TBIT, 0);
    PutBits(TBIT, 0);
    PutBits(CBIT, 0);
    PutBits(CBIT, Root);
  }
  Root = MakeTree(NP, mPFreq, mPTLen, mPTCode);
  if (Root >= NP) {
    WritePTLen(NP, gPBIT, -1);
  } else {
    PutBits(gPBIT, 0);
    PutBits(gPBIT, Root);
  }
  Pos = 0;
  for (i = 0; i < Size; i++) {
    if (i % UINT8_BIT == 0) {
      Flags = mBuf[Pos++];
    } else {
      Flags <<= 1;
    }
    if (Flags & (1U << (UINT8_BIT - 1))) {
      EncodeC(mBuf[Pos++] + (1U << UINT8_BIT));
      k = mBuf[Pos++] << UINT8_BIT;
      k += mBuf[Pos++];
      EncodeP(k);
    } else {
      EncodeC(mBuf[Pos++]);
    }
  }
  for (i = 0; i < NC; i++) {
    mCFreq[i] = 0;
  }
  for (i = 0; i < NP; i++) {
    mPFreq[i] = 0;
  }
}


STATIC 
VOID 
Output (
  IN UINT32 c, 
  IN UINT32 p
  )
/*++

Routine Description:

  Outputs an Original Character or a Pointer

Arguments:

  c     - The original character or the 'String Length' element of a Pointer
  p     - The 'Position' field of a Pointer

Returns: (VOID)

--*/
{
  STATIC UINT32 CPos;

  if ((mOutputMask >>= 1) == 0) {
    mOutputMask = 1U << (UINT8_BIT - 1);
    if (mOutputPos >= mBufSiz - 3 * UINT8_BIT) {
      SendBlock();
      mOutputPos = 0;
    }
    CPos = mOutputPos++;  
    mBuf[CPos] = 0;
  }
  mBuf[mOutputPos++] = (UINT8) c;
  mCFreq[c]++;
  if (c >= (1U << UINT8_BIT)) {
    mBuf[CPos] |= mOutputMask;
    mBuf[mOutputPos++] = (UINT8)(p >> UINT8_BIT);
    mBuf[mOutputPos++] = (UINT8) p;
    c = 0;
    while (p) {
      p >>= 1;
      c++;
    }
    mPFreq[c]++;
  }
}

STATIC
VOID
HufEncodeStart ()
{
  INT32 i;

  for (i = 0; i < NC; i++) {
    mCFreq[i] = 0;
  }
  for (i = 0; i < NP; i++) {
    mPFreq[i] = 0;
  }
  mOutputPos = mOutputMask = 0;
  InitPutBits();
  return;
}

STATIC 
VOID 
HufEncodeEnd ()
{
  SendBlock();
  
  //
  // Flush remaining bits
  //
  PutBits(UINT8_BIT - 1, 0);
  
  return;
}


STATIC 
VOID 
MakeCrcTable ()
{
  UINT32 i, j, r;

  for (i = 0; i <= UINT8_MAX; i++) {
    r = i;
    for (j = 0; j < UINT8_BIT; j++) {
      if (r & 1) {
        r = (r >> 1) ^ CRCPOLY;
      } else {
        r >>= 1;
      }
    }
    mCrcTable[i] = (UINT16)r;    
  }
}

STATIC 
VOID 
PutBits (
  IN INT32 n, 
  IN UINT32 x
  )
/*++

Routine Description:

  Outputs rightmost n bits of x

Argments:

  n   - the rightmost n bits of the data is used
  x   - the data 

Returns: (VOID)

--*/
{
  UINT8 Temp;  
  
  if (n < mBitCount) {
    mSubBitBuf |= x << (mBitCount -= n);
  } else {
      
    Temp = (UINT8)(mSubBitBuf | (x >> (n -= mBitCount)));
    if (mDst < mDstUpperLimit) {
      *mDst++ = Temp;
    }
    mCompSize++;

    if (n < UINT8_BIT) {
      mSubBitBuf = x << (mBitCount = UINT8_BIT - n);
    } else {
        
      Temp = (UINT8)(x >> (n - UINT8_BIT));
      if (mDst < mDstUpperLimit) {
        *mDst++ = Temp;
      }
      mCompSize++;
      
      mSubBitBuf = x << (mBitCount = 2 * UINT8_BIT - n);
    }
  }
}

STATIC 
INT32 
FreadCrc (
  OUT UINT8 *p, 
  IN  INT32 n
  )
/*++

Routine Description:

  Read in source data
  
Arguments:

  p   - the buffer to hold the data
  n   - number of bytes to read

Returns:

  number of bytes actually read
  
--*/
{
  INT32 i;

  for (i = 0; mSrc < mSrcUpperLimit && i < n; i++) {
    *p++ = *mSrc++;
  }
  n = i;

  p -= n;
  mOrigSize += n;
  while (--i >= 0) {
    UPDATE_CRC(*p++);
  }
  return n;
}


STATIC 
VOID 
InitPutBits ()
{
  mBitCount = UINT8_BIT;  
  mSubBitBuf = 0;
}

STATIC 
VOID 
CountLen (
  IN INT32 i
  )
/*++

Routine Description:

  Count the number of each code length for a Huffman tree.
  
Arguments:

  i   - the top node
  
Returns: (VOID)

--*/
{
  STATIC INT32 Depth = 0;

  if (i < mN) {
    mLenCnt[(Depth < 16) ? Depth : 16]++;
  } else {
    Depth++;
    CountLen(mLeft [i]);
    CountLen(mRight[i]);
    Depth--;
  }
}

STATIC 
VOID 
MakeLen (
  IN INT32 Root
  )
/*++

Routine Description:

  Create code length array for a Huffman tree
  
Arguments:

  Root   - the root of the tree

--*/
{
  INT32 i, k;
  UINT32 Cum;

  for (i = 0; i <= 16; i++) {
    mLenCnt[i] = 0;
  }
  CountLen(Root);
  
  //
  // Adjust the length count array so that
  // no code will be generated longer than its designated length
  //
  
  Cum = 0;
  for (i = 16; i > 0; i--) {
    Cum += mLenCnt[i] << (16 - i);
  }
  while (Cum != (1U << 16)) {
    mLenCnt[16]--;
    for (i = 15; i > 0; i--) {
      if (mLenCnt[i] != 0) {
        mLenCnt[i]--;
        mLenCnt[i+1] += 2;
        break;
      }
    }
    Cum--;
  }
  for (i = 16; i > 0; i--) {
    k = mLenCnt[i];
    while (--k >= 0) {
      mLen[*mSortPtr++] = (UINT8)i;
    }
  }
}

STATIC 
VOID 
DownHeap (
  IN INT32 i
  )
{
  INT32 j, k;

  //
  // priority queue: send i-th entry down heap
  //
  
  k = mHeap[i];
  while ((j = 2 * i) <= mHeapSize) {
    if (j < mHeapSize && mFreq[mHeap[j]] > mFreq[mHeap[j + 1]]) {
      j++;
    }
    if (mFreq[k] <= mFreq[mHeap[j]]) {
      break;
    }
    mHeap[i] = mHeap[j];
    i = j;
  }
  mHeap[i] = (INT16)k;
}

STATIC 
VOID 
MakeCode (
  IN  INT32 n, 
  IN  UINT8 Len[], 
  OUT UINT16 Code[]
  )
/*++

Routine Description:

  Assign code to each symbol based on the code length array
  
Arguments:

  n     - number of symbols
  Len   - the code length array
  Code  - stores codes for each symbol

Returns: (VOID)

--*/
{
  INT32    i;
  UINT16   Start[18];

  Start[1] = 0;
  for (i = 1; i <= 16; i++) {
    Start[i + 1] = (UINT16)((Start[i] + mLenCnt[i]) << 1);
  }
  for (i = 0; i < n; i++) {
    Code[i] = Start[Len[i]]++;
  }
}

STATIC 
INT32 
MakeTree (
  IN  INT32   NParm, 
  IN  UINT16  FreqParm[], 
  OUT UINT8   LenParm[], 
  OUT UINT16  CodeParm[]
  )
/*++

Routine Description:

  Generates Huffman codes given a frequency distribution of symbols
  
Arguments:

  NParm    - number of symbols
  FreqParm - frequency of each symbol
  LenParm  - code length for each symbol
  CodeParm - code for each symbol
  
Returns:

  Root of the Huffman tree.
  
--*/
{
  INT32 i, j, k, Avail;
  
  //
  // make tree, calculate len[], return root
  //

  mN = NParm;
  mFreq = FreqParm;
  mLen = LenParm;
  Avail = mN;
  mHeapSize = 0;
  mHeap[1] = 0;
  for (i = 0; i < mN; i++) {
    mLen[i] = 0;
    if (mFreq[i]) {
      mHeap[++mHeapSize] = (INT16)i;
    }    
  }
  if (mHeapSize < 2) {
    CodeParm[mHeap[1]] = 0;
    return mHeap[1];
  }
  for (i = mHeapSize / 2; i >= 1; i--) {
    
    //
    // make priority queue 
    //
    DownHeap(i);
  }
  mSortPtr = CodeParm;
  do {
    i = mHeap[1];
    if (i < mN) {
      *mSortPtr++ = (UINT16)i;
    }
    mHeap[1] = mHeap[mHeapSize--];
    DownHeap(1);
    j = mHeap[1];
    if (j < mN) {
      *mSortPtr++ = (UINT16)j;
    }
    k = Avail++;
    mFreq[k] = (UINT16)(mFreq[i] + mFreq[j]);
    mHeap[1] = (INT16)k;
    DownHeap(1);
    mLeft[k] = (UINT16)i;
    mRight[k] = (UINT16)j;
  } while (mHeapSize > 1);
  
  mSortPtr = CodeParm;
  MakeLen(k);
  MakeCode(NParm, LenParm, CodeParm);
  
  //
  // return root
  //
  return k;
}


```

`efiXloader/3rd/uefitool/common/Tiano/EfiTianoCompress.h`:

```h
/* EfiTianoCompress.h

Copyright (c) 2014, Nikolaj Schlej. All rights reserved.<BR>
Copyright (c) 2004 - 2008, Intel Corporation. All rights reserved.<BR>
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

Module Name:

TianoCompress.h

Abstract:

Header file for compression routine.

*/

#ifndef EFITIANOCOMPRESS_H
#define EFITIANOCOMPRESS_H

#include <string.h>
#include <stdlib.h>

#include "../basetypes.h"

#ifdef __cplusplus
extern "C" {
#endif

    /*++

    Routine Description:

    Tiano compression routine.

    Arguments:

    SrcBuffer   - The buffer storing the source data
    SrcSize     - The size of source data
    DstBuffer   - The buffer to store the compressed data
    DstSize     - On input, the size of DstBuffer; On output,
    the size of the actual compressed data.

    Returns:

    EFI_BUFFER_TOO_SMALL  - The DstBuffer is too small. this case,
    DstSize contains the size needed.
    EFI_SUCCESS           - Compression is successful.
    EFI_OUT_OF_RESOURCES  - No resource to complete function.
    EFI_INVALID_PARAMETER - Parameter supplied is wrong.

    --*/
    EFI_STATUS
        TianoCompress (
            IN      CONST VOID   *SrcBuffer,
            IN      UINT32       SrcSize,
            IN      VOID         *DstBuffer,
            IN OUT  UINT32       *DstSize
        );

    EFI_STATUS
        TianoCompressLegacy(
            CONST VOID   *SrcBuffer,
            UINT32        SrcSize,
            VOID          *DstBuffer,
            UINT32        *DstSize
        );
    /*++

    Routine Description:

    EFI 1.1 compression routine.

    Arguments:

    SrcBuffer   - The buffer storing the source data
    SrcSize     - The size of source data
    DstBuffer   - The buffer to store the compressed data
    DstSize     - On input, the size of DstBuffer; On output,
    the size of the actual compressed data.

    Returns:

    EFI_BUFFER_TOO_SMALL  - The DstBuffer is too small. this case,
    DstSize contains the size needed.
    EFI_SUCCESS           - Compression is successful.
    EFI_OUT_OF_RESOURCES  - No resource to complete function.
    EFI_INVALID_PARAMETER - Parameter supplied is wrong.

    --*/
    EFI_STATUS
        EfiCompress (
            IN CONST VOID   *SrcBuffer,
            IN UINT32       SrcSize,
            IN VOID         *DstBuffer,
            IN OUT UINT32   *DstSize
        );

    EFI_STATUS
        EfiCompressLegacy(
            CONST VOID   *SrcBuffer,
            UINT32       SrcSize,
            VOID         *DstBuffer,
            UINT32       *DstSize
        );

#ifdef __cplusplus
}
#endif
#endif // EFITIANOCOMPRESS_H

```

`efiXloader/3rd/uefitool/common/Tiano/EfiTianoCompressLegacy.c`:

```c
/* EFI11/Tiano Compress Implementation

Copyright (c) 2015, Nikolaj Schlej
Copyright (c) 2006 - 2008, Intel Corporation
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHWARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

Module Name:

EfiTianoCompressLegacy.c

Abstract:

Compression routine. The compression algorithm is a mixture of
LZ77 and Huffman coding. LZ77 transforms the source data into a
sequence of Original Characters and Pointers to repeated strings.
This sequence is further divided into Blocks and Huffman codings
are applied to each Block.

Notes:

This legacy compression code can produce incorrect output,
but has better compression ratio as newer releases

*/

#include "EfiTianoCompress.h"

//
// Macro Definitions
//
#undef  UINT8_MAX
typedef INT32 NODE;
#define UINT8_MAX     0xff
#define UINT8_BIT     8
#define THRESHOLD     3
#define INIT_CRC      0
#define WNDBIT        19
#define WNDSIZ        (1U << WNDBIT)
#define MAXMATCH      256
#define BLKSIZ        (1U << 14)  // 16 * 1024U
#define PERC_FLAG     0x80000000U
#define CODE_BIT      16
#define NIL           0
#define MAX_HASH_VAL  (3 * WNDSIZ + (WNDSIZ / 512 + 1) * UINT8_MAX)
#define HASH(p, c)    ((p) + ((c) << (WNDBIT - 9)) + WNDSIZ * 2)
#define CRCPOLY       0xA001
#define UPDATE_CRC(c) mCrc = mCrcTable[(mCrc ^ (c)) & 0xFF] ^ (mCrc >> UINT8_BIT)

//
// C: the Char&Len Set; P: the Position Set; T: the exTra Set
//
#define NC    (UINT8_MAX + MAXMATCH + 2 - THRESHOLD)
#define CBIT  9
#define NP    (WNDBIT + 1)
//#define PBIT  5
#define NT    (CODE_BIT + 3)
#define TBIT  5
#if NT > NP
#define NPT NT
#else
#define NPT NP
#endif
//
// Function Prototypes
//

STATIC
  VOID
  PutDword(
  UINT32 Data
  );

STATIC
  INT32
  AllocateMemory (
  VOID
  );

STATIC
  VOID
  FreeMemory (
  VOID
  );

STATIC
  VOID
  InitSlide (
  VOID
  );

STATIC
  NODE
  Child (
  NODE   NodeQ,
  UINT8  CharC
  );

STATIC
  VOID
  MakeChild (
  NODE  NodeQ,
  UINT8 CharC,
  NODE  NodeR
  );

STATIC
  VOID
  Split (
  NODE Old
  );

STATIC
  VOID
  InsertNode (
  VOID
  );

STATIC
  VOID
  DeleteNode (
  VOID
  );

STATIC
  VOID
  GetNextMatch (
  VOID
  );

STATIC
  INT32
  Encode (
  VOID
  );

STATIC
  VOID
  CountTFreq (
  VOID
  );

STATIC
  VOID
  WritePTLen (
  INT32 Number,
  INT32 nbit,
  INT32 Special
  );

STATIC
  VOID
  WriteCLen (
  VOID
  );

STATIC
  VOID
  EncodeC (
  INT32 Value
  );

STATIC
  VOID
  EncodeP (
  UINT32 Value
  );

STATIC
  VOID
  SendBlock (
  VOID
  );

STATIC
  VOID
  Output (
  UINT32 c,
  UINT32 p
  );

STATIC
  VOID
  HufEncodeStart (
  VOID
  );

STATIC
  VOID
  HufEncodeEnd (
  VOID
  );

STATIC
  VOID
  MakeCrcTable (
  VOID
  );

STATIC
  VOID
  PutBits (
  INT32  Number,
  UINT32 Value
  );

STATIC
  INT32
  FreadCrc (
  UINT8 *Pointer,
  INT32 Number
  );

STATIC
  VOID
  InitPutBits (
  VOID
  );

STATIC
  VOID
  CountLen (
  INT32 Index
  );

STATIC
  VOID
  MakeLen (
  INT32 Root
  );

STATIC
  VOID
  DownHeap (
  INT32 Index
  );

STATIC
  VOID
  MakeCode (
  INT32       Number,
  UINT8 Len[  ],
  UINT16 Code[]
);

STATIC
  INT32
  MakeTree (
  INT32            NParm,
  UINT16  FreqParm[],
  UINT8   LenParm[ ],
  UINT16  CodeParm[]
);

//
//  Global Variables
//
STATIC UINT8  *mSrc, *mDst, *mSrcUpperLimit, *mDstUpperLimit;

STATIC UINT8  *mLevel, *mText, *mChildCount, *mBuf, mCLen[NC], mPTLen[NPT], *mLen;
STATIC INT16  mHeap[NC + 1];
STATIC INT32  mRemainder, mMatchLen, mBitCount, mHeapSize, mN;
STATIC UINT32 mBufSiz = 0, mOutputPos, mOutputMask, mSubBitBuf, mCrc;
STATIC UINT32 mCompSize, mOrigSize;

STATIC UINT16 *mFreq, *mSortPtr, mLenCnt[17], mLeft[2 * NC - 1], mRight[2 * NC - 1], mCrcTable[UINT8_MAX + 1],
  mCFreq[2 * NC - 1], mCCode[NC], mPFreq[2 * NP - 1], mPTCode[NPT], mTFreq[2 * NT - 1];

STATIC UINT8  mPbit;

STATIC NODE   mPos, mMatchPos, mAvail, *mPosition, *mParent, *mPrev, *mNext = NULL;

//
// functions
//
EFI_STATUS
EfiCompressLegacy(
CONST VOID   *SrcBuffer,
UINT32  SrcSize,
VOID   *DstBuffer,
UINT32  *DstSize
)
/*++

Routine Description:

The internal implementation of [Efi/Tiano]Compress().

Arguments:

SrcBuffer   - The buffer storing the source data
SrcSize     - The size of source data
DstBuffer   - The buffer to store the compressed data
DstSize     - On input, the size of DstBuffer; On output,
the size of the actual compressed data.

Returns:

EFI_BUFFER_TOO_SMALL  - The DstBuffer is too small. this case,
DstSize contains the size needed.
EFI_SUCCESS           - Compression is successful.
EFI_OUT_OF_RESOURCES  - No resource to complete function.
EFI_INVALID_PARAMETER - Parameter supplied is wrong.

--*/
{
    INT32 Status;

    //
    // Initializations
    //
    mPbit = 4;

    mBufSiz = 0;
    mBuf = NULL;
    mText = NULL;
    mLevel = NULL;
    mChildCount = NULL;
    mPosition = NULL;
    mParent = NULL;
    mPrev = NULL;
    mNext = NULL;

    mSrc = (UINT8*) SrcBuffer;
    mSrcUpperLimit = mSrc + SrcSize;
    mDst = DstBuffer;
    mDstUpperLimit = mDst + *DstSize;

    PutDword(0L);
    PutDword(0L);

    MakeCrcTable();

    mOrigSize = mCompSize = 0;
    mCrc = INIT_CRC;

    //
    // Compress it
    //
    Status = Encode();
    if (Status) {
        return EFI_OUT_OF_RESOURCES;
    }
    //
    // Null terminate the compressed data
    //
    if (mDst < mDstUpperLimit) {
        *mDst++ = 0;
    }
    //
    // Fill compressed size and original size
    //
    mDst = DstBuffer;
    PutDword(mCompSize + 1);
    PutDword(mOrigSize);

    //
    // Return
    //
    if (mCompSize + 1 + 8 > *DstSize) {
        *DstSize = mCompSize + 1 + 8;
        return EFI_BUFFER_TOO_SMALL;
    }
    else {
        *DstSize = mCompSize + 1 + 8;
        return EFI_SUCCESS;
    }

}

EFI_STATUS
TianoCompressLegacy (
CONST VOID   *SrcBuffer,
UINT32  SrcSize,
VOID   *DstBuffer,
UINT32  *DstSize
)
  /*++

  Routine Description:

  The internal implementation of [Efi/Tiano]Compress().

  Arguments:

  SrcBuffer   - The buffer storing the source data
  SrcSize     - The size of source data
  DstBuffer   - The buffer to store the compressed data
  DstSize     - On input, the size of DstBuffer; On output,
  the size of the actual compressed data.
  Version     - The version of de/compression algorithm.
  Version 1 for UEFI 2.0 de/compression algorithm.
  Version 2 for Tiano de/compression algorithm.

  Returns:

  EFI_BUFFER_TOO_SMALL  - The DstBuffer is too small. this case,
  DstSize contains the size needed.
  EFI_SUCCESS           - Compression is successful.
  EFI_OUT_OF_RESOURCES  - No resource to complete function.
  EFI_INVALID_PARAMETER - Parameter supplied is wrong.

  --*/
{
  INT32 Status;

  //
  // Initializations
  //
  mPbit = 5;

  mBufSiz         = 0;
  mBuf            = NULL;
  mText           = NULL;
  mLevel          = NULL;
  mChildCount     = NULL;
  mPosition       = NULL;
  mParent         = NULL;
  mPrev           = NULL;
  mNext           = NULL;

  mSrc            = (UINT8*) SrcBuffer;
  mSrcUpperLimit  = mSrc + SrcSize;
  mDst            = DstBuffer;
  mDstUpperLimit  = mDst +*DstSize;

  PutDword (0L);
  PutDword (0L);

  MakeCrcTable ();

  mOrigSize             = mCompSize = 0;
  mCrc                  = INIT_CRC;

  //
  // Compress it
  //
  Status = Encode ();
  if (Status) {
    return EFI_OUT_OF_RESOURCES;
  }
  //
  // Null terminate the compressed data
  //
  if (mDst < mDstUpperLimit) {
    *mDst++ = 0;
  }
  //
  // Fill compressed size and original size
  //
  mDst = DstBuffer;
  PutDword (mCompSize + 1);
  PutDword (mOrigSize);

  //
  // Return
  //
  if (mCompSize + 1 + 8 > *DstSize) {
    *DstSize = mCompSize + 1 + 8;
    return EFI_BUFFER_TOO_SMALL;
  } else {
    *DstSize = mCompSize + 1 + 8;
    return EFI_SUCCESS;
  }

}

STATIC
  VOID
  PutDword (
  UINT32 Data
  )
  /*++

  Routine Description:

  Put a DWORD to output stream

  Arguments:

  Data    - the DWORD to put

  Returns: (VOID)

  --*/
{
  if (mDst < mDstUpperLimit) {
    *mDst++ = (UINT8) (((UINT8) (Data)) & 0xff);
  }

  if (mDst < mDstUpperLimit) {
    *mDst++ = (UINT8) (((UINT8) (Data >> 0x08)) & 0xff);
  }

  if (mDst < mDstUpperLimit) {
    *mDst++ = (UINT8) (((UINT8) (Data >> 0x10)) & 0xff);
  }

  if (mDst < mDstUpperLimit) {
    *mDst++ = (UINT8) (((UINT8) (Data >> 0x18)) & 0xff);
  }
}

STATIC
  INT32
  AllocateMemory (
  VOID
  )
  /*++

  Routine Description:

  Allocate memory spaces for data structures used compression process

  Arguments:
  VOID

  Returns:

  EFI_SUCCESS           - Memory is allocated successfully
  EFI_OUT_OF_RESOURCES  - Allocation fails

  --*/
{
  UINT32  Index;

  mText     = malloc (WNDSIZ * 2 + MAXMATCH);
  if (!mText) return EFI_OUT_OF_RESOURCES;
  for (Index = 0; Index < WNDSIZ * 2 + MAXMATCH; Index++) {
    mText[Index] = 0;
  }

  mLevel            = malloc ((WNDSIZ + UINT8_MAX + 1) * sizeof (*mLevel));
  if (!mLevel)        return EFI_OUT_OF_RESOURCES;
  mChildCount       = malloc ((WNDSIZ + UINT8_MAX + 1) * sizeof (*mChildCount));
  if (!mChildCount)   return EFI_OUT_OF_RESOURCES;
  mPosition         = malloc ((WNDSIZ + UINT8_MAX + 1) * sizeof (*mPosition));
  if (!mPosition)     return EFI_OUT_OF_RESOURCES;
  mParent           = malloc (WNDSIZ * 2 * sizeof (*mParent));
  if (!mParent)       return EFI_OUT_OF_RESOURCES;
  mPrev             = malloc (WNDSIZ * 2 * sizeof (*mPrev));
  if (!mPrev)         return EFI_OUT_OF_RESOURCES;
  mNext             = malloc ((MAX_HASH_VAL + 1) * sizeof (*mNext));
  if (!mNext)         return EFI_OUT_OF_RESOURCES;

  mBufSiz     = BLKSIZ;
  mBuf        = malloc (mBufSiz);
  while (mBuf == NULL) {
    mBufSiz = (mBufSiz / 10U) * 9U;
    if (mBufSiz < 4 * 1024U) {
      return EFI_OUT_OF_RESOURCES;
    }

    mBuf = malloc (mBufSiz);
  }

  mBuf[0] = 0;

  return EFI_SUCCESS;
}

VOID
  FreeMemory (
  VOID
  )
  /*++

  Routine Description:

  Called when compression is completed to free memory previously allocated.

  Arguments: (VOID)

  Returns: (VOID)

  --*/
{
    free (mText);
    free (mLevel);
    free (mChildCount);
    free (mPosition);
    free (mParent);
    free (mPrev);
    free (mNext);
    free (mBuf);
}

STATIC
  VOID
  InitSlide (
  VOID
  )
  /*++

  Routine Description:

  Initialize String Info Log data structures

  Arguments: (VOID)

  Returns: (VOID)

  --*/
{
  NODE  Index;

    for (Index = (NODE) WNDSIZ; Index <= (NODE) WNDSIZ + UINT8_MAX; Index++) {
    mLevel[Index]     = 1;
    mPosition[Index]  = NIL;  // sentinel
  }

    for (Index = (NODE) WNDSIZ; Index < (NODE) WNDSIZ * 2; Index++) {
    mParent[Index] = NIL;
  }

  mAvail = 1;
    for (Index = 1; Index < (NODE) WNDSIZ - 1; Index++) {
    mNext[Index] = (NODE) (Index + 1);
  }

  mNext[WNDSIZ - 1] = NIL;
    for (Index = (NODE) WNDSIZ * 2; Index <= (NODE) MAX_HASH_VAL; Index++) {
    mNext[Index] = NIL;
  }
}

STATIC
  NODE
  Child (
  NODE  NodeQ,
  UINT8 CharC
  )
  /*++

  Routine Description:

  Find child node given the parent node and the edge character

  Arguments:

  NodeQ       - the parent node
  CharC       - the edge character

  Returns:

  The child node (NIL if not found)

  --*/
{
  NODE  NodeR;

  NodeR = mNext[HASH (NodeQ, CharC)];
  //
  // sentinel
  //
  mParent[NIL] = NodeQ;
  while (mParent[NodeR] != NodeQ) {
    NodeR = mNext[NodeR];
  }

  return NodeR;
}

STATIC
  VOID
  MakeChild (
  NODE  Parent,
  UINT8 CharC,
  NODE  Child
  )
  /*++

  Routine Description:

  Create a new child for a given parent node.

  Arguments:

  Parent       - the parent node
  CharC   - the edge character
  Child       - the child node

  Returns: (VOID)

  --*/
{
  NODE  Node1;
  NODE  Node2;

  Node1           = (NODE) HASH (Parent, CharC);
  Node2           = mNext[Node1];
  mNext[Node1]    = Child;
  mNext[Child]    = Node2;
  mPrev[Node2]    = Child;
  mPrev[Child]    = Node1;
  mParent[Child]  = Parent;
  mChildCount[Parent]++;
}

STATIC
  VOID
  Split (
  NODE Old
  )
  /*++

  Routine Description:

  Split a node.

  Arguments:

  Old     - the node to split

  Returns: (VOID)

  --*/
{
  NODE  New;
  NODE  TempNode;

  New               = mAvail;
  mAvail            = mNext[New];
  mChildCount[New]  = 0;
  TempNode          = mPrev[Old];
  mPrev[New]        = TempNode;
  mNext[TempNode]   = New;
  TempNode          = mNext[Old];
  mNext[New]        = TempNode;
  mPrev[TempNode]   = New;
  mParent[New]      = mParent[Old];
  mLevel[New]       = (UINT8) mMatchLen;
  mPosition[New]    = mPos;
  MakeChild (New, mText[mMatchPos + mMatchLen], Old);
  MakeChild (New, mText[mPos + mMatchLen], mPos);
}

STATIC
  VOID
  InsertNode (
  VOID
  )
  /*++

  Routine Description:

  Insert string info for current position into the String Info Log

  Arguments: (VOID)

  Returns: (VOID)

  --*/
{
  NODE  NodeQ;
  NODE  NodeR;
  NODE  Index2;
  NODE  NodeT;
  UINT8 CharC;
  UINT8 *t1;
  UINT8 *t2;

  if (mMatchLen >= 4) {
    //
    // We have just got a long match, the target tree
    // can be located by MatchPos + 1. Traverse the tree
    // from bottom up to get to a proper starting point.
    // The usage of PERC_FLAG ensures proper node deletion
    // DeleteNode() later.
    //
    mMatchLen--;
    NodeR = (NODE) ((mMatchPos + 1) | WNDSIZ);
    NodeQ = mParent[NodeR];
    while (NodeQ == NIL) {
      NodeR = mNext[NodeR];
      NodeQ = mParent[NodeR];
    }

    while (mLevel[NodeQ] >= mMatchLen) {
      NodeR = NodeQ;
      NodeQ = mParent[NodeQ];
    }

    NodeT = NodeQ;
    while (mPosition[NodeT] < 0) {
      mPosition[NodeT]  = mPos;
      NodeT             = mParent[NodeT];
    }

        if (NodeT < (NODE) WNDSIZ) {
      mPosition[NodeT] = (NODE) (mPos | (UINT32) PERC_FLAG);
    }
  } else {
    //
    // Locate the target tree
    //
    NodeQ = (NODE) (mText[mPos] + WNDSIZ);
    CharC = mText[mPos + 1];
    NodeR = Child (NodeQ, CharC);
    if (NodeR == NIL) {
      MakeChild (NodeQ, CharC, mPos);
      mMatchLen = 1;
      return ;
    }

    mMatchLen = 2;
  }
  //
  // Traverse down the tree to find a match.
  // Update Position value along the route.
  // Node split or creation is involved.
  //
  for (;;) {
        if (NodeR >= (NODE) WNDSIZ) {
      Index2    = MAXMATCH;
      mMatchPos = NodeR;
    } else {
      Index2    = mLevel[NodeR];
      mMatchPos = (NODE) (mPosition[NodeR] & (UINT32)~PERC_FLAG);
    }

    if (mMatchPos >= mPos) {
      mMatchPos -= WNDSIZ;
    }

    t1  = &mText[mPos + mMatchLen];
    t2  = &mText[mMatchPos + mMatchLen];
    while (mMatchLen < Index2) {
      if (*t1 != *t2) {
        Split (NodeR);
        return ;
      }

      mMatchLen++;
      t1++;
      t2++;
    }

    if (mMatchLen >= MAXMATCH) {
      break;
    }

    mPosition[NodeR]  = mPos;
    NodeQ             = NodeR;
    NodeR             = Child (NodeQ, *t1);
    if (NodeR == NIL) {
      MakeChild (NodeQ, *t1, mPos);
      return ;
    }

    mMatchLen++;
  }

  NodeT           = mPrev[NodeR];
  mPrev[mPos]     = NodeT;
  mNext[NodeT]    = mPos;
  NodeT           = mNext[NodeR];
  mNext[mPos]     = NodeT;
  mPrev[NodeT]    = mPos;
  mParent[mPos]   = NodeQ;
  mParent[NodeR]  = NIL;

  //
  // Special usage of 'next'
  //
  mNext[NodeR] = mPos;

}

STATIC
  VOID
  DeleteNode (
  VOID
  )
  /*++

  Routine Description:

  Delete outdated string info. (The Usage of PERC_FLAG
  ensures a clean deletion)

  Arguments: (VOID)

  Returns: (VOID)

  --*/
{
  NODE  NodeQ;
  NODE  NodeR;
  NODE  NodeS;
  NODE  NodeT;
  NODE  NodeU;

  if (mParent[mPos] == NIL) {
    return ;
  }

  NodeR         = mPrev[mPos];
  NodeS         = mNext[mPos];
  mNext[NodeR]  = NodeS;
  mPrev[NodeS]  = NodeR;
  NodeR         = mParent[mPos];
  mParent[mPos] = NIL;
    if (NodeR >= (NODE) WNDSIZ) {
    return ;
  }

  mChildCount[NodeR]--;
  if (mChildCount[NodeR] > 1) {
    return ;
  }

  NodeT = (NODE) (mPosition[NodeR] & (UINT32)~PERC_FLAG);
  if (NodeT >= mPos) {
    NodeT -= WNDSIZ;
  }

  NodeS = NodeT;
  NodeQ = mParent[NodeR];
  NodeU = mPosition[NodeQ];
  while (NodeU & (UINT32) PERC_FLAG) {
    NodeU &= (UINT32)~PERC_FLAG;
    if (NodeU >= mPos) {
      NodeU -= WNDSIZ;
    }

    if (NodeU > NodeS) {
      NodeS = NodeU;
    }

    mPosition[NodeQ]  = (NODE) (NodeS | WNDSIZ);
    NodeQ             = mParent[NodeQ];
    NodeU             = mPosition[NodeQ];
  }

    if (NodeQ < (NODE) WNDSIZ) {
    if (NodeU >= mPos) {
      NodeU -= WNDSIZ;
    }

    if (NodeU > NodeS) {
      NodeS = NodeU;
    }

    mPosition[NodeQ] = (NODE) (NodeS | WNDSIZ | (UINT32) PERC_FLAG);
  }

  NodeS           = Child (NodeR, mText[NodeT + mLevel[NodeR]]);
  NodeT           = mPrev[NodeS];
  NodeU           = mNext[NodeS];
  mNext[NodeT]    = NodeU;
  mPrev[NodeU]    = NodeT;
  NodeT           = mPrev[NodeR];
  mNext[NodeT]    = NodeS;
  mPrev[NodeS]    = NodeT;
  NodeT           = mNext[NodeR];
  mPrev[NodeT]    = NodeS;
  mNext[NodeS]    = NodeT;
  mParent[NodeS]  = mParent[NodeR];
  mParent[NodeR]  = NIL;
  mNext[NodeR]    = mAvail;
  mAvail          = NodeR;
}

STATIC
  VOID
  GetNextMatch (
  VOID
  )
  /*++

  Routine Description:

  Advance the current position (read new data if needed).
  Delete outdated string info. Find a match string for current position.

  Arguments: (VOID)

  Returns: (VOID)

  --*/
{
  INT32 Number;

  mRemainder--;
  mPos++;
  if (mPos == WNDSIZ * 2) {
    memmove (&mText[0], &mText[WNDSIZ], WNDSIZ + MAXMATCH);
    Number = FreadCrc (&mText[WNDSIZ + MAXMATCH], WNDSIZ);
    mRemainder += Number;
    mPos = WNDSIZ;
  }

  DeleteNode ();
  InsertNode ();
}

STATIC
  INT32
  Encode (
  VOID
  )
  /*++

  Routine Description:

  The mac controlling routine for compression process.

  Arguments: (VOID)

  Returns:

  EFI_SUCCESS           - The compression is successful
  EFI_OUT_0F_RESOURCES  - Not enough memory for compression process

  --*/
{
  INT32  Status;
  INT32       LastMatchLen;
  NODE        LastMatchPos;

  Status = AllocateMemory ();
  if (Status) {
    FreeMemory ();
    return Status;
  }

  InitSlide ();

  HufEncodeStart ();

  mRemainder  = FreadCrc (&mText[WNDSIZ], WNDSIZ + MAXMATCH);

  mMatchLen   = 0;
  mPos        = WNDSIZ;
  InsertNode ();
  if (mMatchLen > mRemainder) {
    mMatchLen = mRemainder;
  }

  while (mRemainder > 0) {
    LastMatchLen  = mMatchLen;
    LastMatchPos  = mMatchPos;
    GetNextMatch ();
    if (mMatchLen > mRemainder) {
      mMatchLen = mRemainder;
    }

    if (mMatchLen > LastMatchLen || LastMatchLen < THRESHOLD) {
      //
      // Not enough benefits are gained by outputting a pointer,
      // so just output the original character
      //
      Output (mText[mPos - 1], 0);

    } else {

      if (LastMatchLen == THRESHOLD) {
        if (((mPos - LastMatchPos - 2) & (WNDSIZ - 1)) > (1U << 11)) {
          Output (mText[mPos - 1], 0);
          continue;
        }
      }
      //
      // Outputting a pointer is beneficial enough, do it.
      //
      Output (
        LastMatchLen + (UINT8_MAX + 1 - THRESHOLD),
        (mPos - LastMatchPos - 2) & (WNDSIZ - 1)
        );
      LastMatchLen--;
      while (LastMatchLen > 0) {
        GetNextMatch ();
        LastMatchLen--;
      }

      if (mMatchLen > mRemainder) {
        mMatchLen = mRemainder;
      }
    }
  }

  HufEncodeEnd ();
  FreeMemory ();
  return EFI_SUCCESS;
}

STATIC
  VOID
  CountTFreq (
  VOID
  )
  /*++

  Routine Description:

  Count the frequencies for the Extra Set

  Arguments: (VOID)

  Returns: (VOID)

  --*/
{
  INT32 Index;
  INT32 Index3;
  INT32 Number;
  INT32 Count;

  for (Index = 0; Index < NT; Index++) {
    mTFreq[Index] = 0;
  }

  Number = NC;
  while (Number > 0 && mCLen[Number - 1] == 0) {
    Number--;
  }

  Index = 0;
  while (Index < Number) {
    Index3 = mCLen[Index++];
    if (Index3 == 0) {
      Count = 1;
      while (Index < Number && mCLen[Index] == 0) {
        Index++;
        Count++;
      }

      if (Count <= 2) {
        mTFreq[0] = (UINT16) (mTFreq[0] + Count);
      } else if (Count <= 18) {
        mTFreq[1]++;
      } else if (Count == 19) {
        mTFreq[0]++;
        mTFreq[1]++;
      } else {
        mTFreq[2]++;
      }
    } else {
      mTFreq[Index3 + 2]++;
    }
  }
}

STATIC
  VOID
  WritePTLen (
  INT32 Number,
  INT32 nbit,
  INT32 Special
  )
  /*++

  Routine Description:

  Outputs the code length array for the Extra Set or the Position Set.

  Arguments:

  Number       - the number of symbols
  nbit    - the number of bits needed to represent 'n'
  Special - the special symbol that needs to be take care of

  Returns: (VOID)

  --*/
{
  INT32 Index;
  INT32 Index3;

  while (Number > 0 && mPTLen[Number - 1] == 0) {
    Number--;
  }

  PutBits (nbit, Number);
  Index = 0;
  while (Index < Number) {
    Index3 = mPTLen[Index++];
    if (Index3 <= 6) {
      PutBits (3, Index3);
    } else {
      PutBits (Index3 - 3, (1U << (Index3 - 3)) - 2);
    }

    if (Index == Special) {
      while (Index < 6 && mPTLen[Index] == 0) {
        Index++;
      }

      PutBits (2, (Index - 3) & 3);
    }
  }
}

STATIC
  VOID
  WriteCLen (
  VOID
  )
  /*++

  Routine Description:

  Outputs the code length array for Char&Length Set

  Arguments: (VOID)

  Returns: (VOID)

  --*/
{
  INT32 Index;
  INT32 Index3;
  INT32 Number;
  INT32 Count;

  Number = NC;
  while (Number > 0 && mCLen[Number - 1] == 0) {
    Number--;
  }

  PutBits (CBIT, Number);
  Index = 0;
  while (Index < Number) {
    Index3 = mCLen[Index++];
    if (Index3 == 0) {
      Count = 1;
      while (Index < Number && mCLen[Index] == 0) {
        Index++;
        Count++;
      }

      if (Count <= 2) {
        for (Index3 = 0; Index3 < Count; Index3++) {
          PutBits (mPTLen[0], mPTCode[0]);
        }
      } else if (Count <= 18) {
        PutBits (mPTLen[1], mPTCode[1]);
        PutBits (4, Count - 3);
      } else if (Count == 19) {
        PutBits (mPTLen[0], mPTCode[0]);
        PutBits (mPTLen[1], mPTCode[1]);
        PutBits (4, 15);
      } else {
        PutBits (mPTLen[2], mPTCode[2]);
        PutBits (CBIT, Count - 20);
      }
    } else {
      PutBits (mPTLen[Index3 + 2], mPTCode[Index3 + 2]);
    }
  }
}

STATIC
  VOID
  EncodeC (
  INT32 Value
  )
{
  PutBits (mCLen[Value], mCCode[Value]);
}

STATIC
  VOID
  EncodeP (
  UINT32 Value
  )
{
  UINT32  Index;
  UINT32  NodeQ;

  Index = 0;
  NodeQ = Value;
  while (NodeQ) {
    NodeQ >>= 1;
    Index++;
  }

  PutBits (mPTLen[Index], mPTCode[Index]);
  if (Index > 1) {
    PutBits (Index - 1, Value & (0xFFFFFFFFU >> (32 - Index + 1)));
  }
}

STATIC
  VOID
  SendBlock (
  VOID
  )
  /*++

  Routine Description:

  Huffman code the block and output it.

  Arguments:
  (VOID)

  Returns:
  (VOID)

  --*/
{
  UINT32  Index;
  UINT32  Index2;
  UINT32  Index3;
  UINT32  Flags;
  UINT32  Root;
  UINT32  Pos;
  UINT32  Size;
  Flags = 0;

  Root  = MakeTree (NC, mCFreq, mCLen, mCCode);
  Size  = mCFreq[Root];
  PutBits (16, Size);
  if (Root >= NC) {
    CountTFreq ();
    Root = MakeTree (NT, mTFreq, mPTLen, mPTCode);
    if (Root >= NT) {
      WritePTLen (NT, TBIT, 3);
    } else {
      PutBits (TBIT, 0);
      PutBits (TBIT, Root);
    }

    WriteCLen ();
  } else {
    PutBits (TBIT, 0);
    PutBits (TBIT, 0);
    PutBits (CBIT, 0);
    PutBits (CBIT, Root);
  }

  Root = MakeTree (NP, mPFreq, mPTLen, mPTCode);
  if (Root >= NP) {
    WritePTLen (NP, mPbit, -1);
  } else {
        PutBits (mPbit, 0);
        PutBits (mPbit, Root);
  }

  Pos = 0;
  for (Index = 0; Index < Size; Index++) {
    if (Index % UINT8_BIT == 0) {
      Flags = mBuf[Pos++];
    } else {
      Flags <<= 1;
    }

    if (Flags & (1U << (UINT8_BIT - 1))) {
      EncodeC (mBuf[Pos++] + (1U << UINT8_BIT));
      Index3 = mBuf[Pos++];
      for (Index2 = 0; Index2 < 3; Index2++) {
        Index3 <<= UINT8_BIT;
        Index3 += mBuf[Pos++];
      }

      EncodeP (Index3);
    } else {
      EncodeC (mBuf[Pos++]);
    }
  }

  for (Index = 0; Index < NC; Index++) {
    mCFreq[Index] = 0;
  }

  for (Index = 0; Index < NP; Index++) {
    mPFreq[Index] = 0;
  }
}

STATIC
  VOID
  Output (
  UINT32 CharC,
  UINT32 Pos
  )
  /*++

  Routine Description:

  Outputs an Original Character or a Pointer

  Arguments:

  CharC     - The original character or the 'String Length' element of a Pointer
  Pos     - The 'Position' field of a Pointer

  Returns: (VOID)

  --*/
{
  STATIC UINT32 CPos;

  if ((mOutputMask >>= 1) == 0) {
    mOutputMask = 1U << (UINT8_BIT - 1);
    //
    // Check the buffer overflow per outputting UINT8_BIT symbols
    // which is an Original Character or a Pointer. The biggest
    // symbol is a Pointer which occupies 5 bytes.
    //
    if (mOutputPos >= mBufSiz - 5 * UINT8_BIT) {
      SendBlock ();
      mOutputPos = 0;
    }

    CPos        = mOutputPos++;
    mBuf[CPos]  = 0;
  }

  mBuf[mOutputPos++] = (UINT8) CharC;
  mCFreq[CharC]++;
  if (CharC >= (1U << UINT8_BIT)) {
    mBuf[CPos] |= mOutputMask;
    mBuf[mOutputPos++]  = (UINT8) (Pos >> 24);
    mBuf[mOutputPos++]  = (UINT8) (Pos >> 16);
    mBuf[mOutputPos++]  = (UINT8) (Pos >> (UINT8_BIT));
    mBuf[mOutputPos++]  = (UINT8) Pos;
    CharC               = 0;
    while (Pos) {
      Pos >>= 1;
      CharC++;
    }

    mPFreq[CharC]++;
  }
}

STATIC
  VOID
  HufEncodeStart (
  VOID
  )
{
  INT32 Index;

  for (Index = 0; Index < NC; Index++) {
    mCFreq[Index] = 0;
  }

  for (Index = 0; Index < NP; Index++) {
    mPFreq[Index] = 0;
  }

  mOutputPos = mOutputMask = 0;
  InitPutBits ();
  return ;
}

STATIC
  VOID
  HufEncodeEnd (
  VOID
  )
{
  SendBlock ();

  //
  // Flush remaining bits
  //
  PutBits (UINT8_BIT - 1, 0);

  return ;
}

STATIC
  VOID
  MakeCrcTable (
  VOID
  )
{
  UINT32  Index;
  UINT32  Index2;
  UINT32  Temp;

  for (Index = 0; Index <= UINT8_MAX; Index++) {
    Temp = Index;
    for (Index2 = 0; Index2 < UINT8_BIT; Index2++) {
      if (Temp & 1) {
        Temp = (Temp >> 1) ^ CRCPOLY;
      } else {
        Temp >>= 1;
      }
    }

    mCrcTable[Index] = (UINT16) Temp;
  }
}

STATIC
  VOID
  PutBits (
  INT32  Number,
  UINT32 Value
  )
  /*++

  Routine Description:

  Outputs rightmost n bits of x

  Arguments:

  Number   - the rightmost n bits of the data is used
  x   - the data

  Returns: (VOID)

  --*/
{
  UINT8 Temp;

  while (Number >= mBitCount) {
    //
    // Number -= mBitCount should never equal to 32
    //
    Temp = (UINT8) (mSubBitBuf | (Value >> (Number -= mBitCount)));
    if (mDst < mDstUpperLimit) {
      *mDst++ = Temp;
    }

    mCompSize++;
    mSubBitBuf  = 0;
    mBitCount   = UINT8_BIT;
  }

  mSubBitBuf |= Value << (mBitCount -= Number);
}

STATIC
  INT32
  FreadCrc (
  UINT8 *Pointer,
  INT32 Number
  )
  /*++

  Routine Description:

  Read source data

  Arguments:

  Pointer   - the buffer to hold the data
  Number   - number of bytes to read

  Returns:

  number of bytes actually read

  --*/
{
  INT32 Index;

  for (Index = 0; mSrc < mSrcUpperLimit && Index < Number; Index++) {
    *Pointer++ = *mSrc++;
  }

  Number = Index;

  Pointer -= Number;
  mOrigSize += Number;
  Index--;
  while (Index >= 0) {
    UPDATE_CRC (*Pointer++);
    Index--;
  }

  return Number;
}

STATIC
  VOID
  InitPutBits (
  VOID
  )
{
  mBitCount   = UINT8_BIT;
  mSubBitBuf  = 0;
}

STATIC
  VOID
  CountLen (
  INT32 Index
  )
  /*++

  Routine Description:

  Count the number of each code length for a Huffman tree.

  Arguments:

  Index   - the top node

  Returns: (VOID)

  --*/
{
  STATIC INT32  Depth = 0;

  if (Index < mN) {
    mLenCnt[(Depth < 16) ? Depth : 16]++;
  } else {
    Depth++;
    CountLen (mLeft[Index]);
    CountLen (mRight[Index]);
    Depth--;
  }
}

STATIC
  VOID
  MakeLen (
  INT32 Root
  )
  /*++

  Routine Description:

  Create code length array for a Huffman tree

  Arguments:

  Root   - the root of the tree

  Returns:

  VOID

  --*/
{
  INT32   Index;
  INT32   Index3;
  UINT32  Cum;

  for (Index = 0; Index <= 16; Index++) {
    mLenCnt[Index] = 0;
  }

  CountLen (Root);

  //
  // Adjust the length count array so that
  // no code will be generated longer than its designated length
  //
  Cum = 0;
  for (Index = 16; Index > 0; Index--) {
    Cum += mLenCnt[Index] << (16 - Index);
  }

  while (Cum != (1U << 16)) {
    mLenCnt[16]--;
    for (Index = 15; Index > 0; Index--) {
      if (mLenCnt[Index] != 0) {
        mLenCnt[Index]--;
        mLenCnt[Index + 1] += 2;
        break;
      }
    }

    Cum--;
  }

  for (Index = 16; Index > 0; Index--) {
    Index3 = mLenCnt[Index];
    Index3--;
    while (Index3 >= 0) {
      mLen[*mSortPtr++] = (UINT8) Index;
      Index3--;
    }
  }
}

STATIC
  VOID
  DownHeap (
  INT32 Index
  )
{
  INT32 Index2;
  INT32 Index3;

  //
  // priority queue: send Index-th entry down heap
  //
  Index3  = mHeap[Index];
  Index2  = 2 * Index;
  while (Index2 <= mHeapSize) {
    if (Index2 < mHeapSize && mFreq[mHeap[Index2]] > mFreq[mHeap[Index2 + 1]]) {
      Index2++;
    }

    if (mFreq[Index3] <= mFreq[mHeap[Index2]]) {
      break;
    }

    mHeap[Index]  = mHeap[Index2];
    Index         = Index2;
    Index2        = 2 * Index;
  }

  mHeap[Index] = (INT16) Index3;
}

STATIC
  VOID
  MakeCode (
  INT32       Number,
  UINT8 Len[  ],
  UINT16 Code[]
)
  /*++

  Routine Description:

  Assign code to each symbol based on the code length array

  Arguments:

  Number     - number of symbols
  Len   - the code length array
  Code  - stores codes for each symbol

  Returns: (VOID)

  --*/
{
  INT32   Index;
  UINT16  Start[18];

  Start[1] = 0;
  for (Index = 1; Index <= 16; Index++) {
    Start[Index + 1] = (UINT16) ((Start[Index] + mLenCnt[Index]) << 1);
  }

  for (Index = 0; Index < Number; Index++) {
    Code[Index] = Start[Len[Index]]++;
  }
}

STATIC
  INT32
  MakeTree (
  INT32            NParm,
  UINT16  FreqParm[],
  UINT8   LenParm[ ],
  UINT16  CodeParm[]
)
  /*++

  Routine Description:

  Generates Huffman codes given a frequency distribution of symbols

  Arguments:

  NParm    - number of symbols
  FreqParm - frequency of each symbol
  LenParm  - code length for each symbol
  CodeParm - code for each symbol

  Returns:

  Root of the Huffman tree.

  --*/
{
  INT32 Index;
  INT32 Index2;
  INT32 Index3;
  INT32 Avail;

  //
  // make tree, calculate len[], return root
  //
  mN        = NParm;
  mFreq     = FreqParm;
  mLen      = LenParm;
  Avail     = mN;
  mHeapSize = 0;
  mHeap[1]  = 0;
  for (Index = 0; Index < mN; Index++) {
    mLen[Index] = 0;
    if (mFreq[Index]) {
      mHeapSize++;
      mHeap[mHeapSize] = (INT16) Index;
    }
  }

  if (mHeapSize < 2) {
    CodeParm[mHeap[1]] = 0;
    return mHeap[1];
  }

  for (Index = mHeapSize / 2; Index >= 1; Index--) {
    //
    // make priority queue
    //
    DownHeap (Index);
  }

  mSortPtr = CodeParm;
  do {
    Index = mHeap[1];
    if (Index < mN) {
      *mSortPtr++ = (UINT16) Index;
    }

    mHeap[1] = mHeap[mHeapSize--];
    DownHeap (1);
    Index2 = mHeap[1];
    if (Index2 < mN) {
      *mSortPtr++ = (UINT16) Index2;
    }

    Index3        = Avail++;
    mFreq[Index3] = (UINT16) (mFreq[Index] + mFreq[Index2]);
    mHeap[1]      = (INT16) Index3;
    DownHeap (1);
    mLeft[Index3]   = (UINT16) Index;
    mRight[Index3]  = (UINT16) Index2;
  } while (mHeapSize > 1);

  mSortPtr = CodeParm;
  MakeLen (Index3);
  MakeCode (NParm, LenParm, CodeParm);

  //
  // return root
  //
  return Index3;
}

```

`efiXloader/3rd/uefitool/common/Tiano/EfiTianoDecompress.c`:

```c
/*++ EfiTianoDecompress.c

Copyright (c) 2018, LongSoft. All rights reserved.<BR>
Copyright (c) 2006 - 2018, Intel Corporation. All rights reserved.<BR>
Portions copyright (c) 2008 - 2009, Apple Inc. All rights reserved.<BR>
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

Module Name:

Decompress.c

Abstract:

UEFI Decompress Library implementation refer to UEFI specification.

--*/

#include "EfiTianoDecompress.h"

//
// Decompression algorithm begins here
//
#define BITBUFSIZ 32
#define MAXMATCH  256
#define THRESHOLD 3
#define CODE_BIT  16
#ifndef UINT8_MAX
#define UINT8_MAX 0xff
#endif
#define BAD_TABLE - 1

//
// C: Char&Len Set; P: Position Set; T: exTra Set
//
#define NC      (0xff + MAXMATCH + 2 - THRESHOLD)
#define CBIT    9
#define MAXPBIT 5
#define TBIT    5
#define MAXNP   ((1U << MAXPBIT) - 1)
#define NT      (CODE_BIT + 3)
#if NT > MAXNP
#define NPT NT
#else
#define NPT MAXNP
#endif

typedef struct {
    UINT8   *mSrcBase;  // Starting address of compressed data
    UINT8   *mDstBase;  // Starting address of decompressed data
    UINT32  mOutBuf;
    UINT32  mInBuf;

    UINT16  mBitCount;
    UINT32  mBitBuf;
    UINT32  mSubBitBuf;
    UINT16  mBlockSize;
    UINT32  mCompSize;
    UINT32  mOrigSize;

    UINT16  mBadTableFlag;

    UINT16  mLeft[2 * NC - 1];
    UINT16  mRight[2 * NC - 1];
    UINT8   mCLen[NC];
    UINT8   mPTLen[NPT];
    UINT16  mCTable[4096];
    UINT16  mPTTable[256];

    //
    // The length of the field 'Position Set Code Length Array Size' in Block Header.
    // For EFI 1.1 de/compression algorithm, mPBit = 4
    // For Tiano de/compression algorithm, mPBit = 5
    //
    UINT8   mPBit;
} SCRATCH_DATA;

STATIC
UINT64
EFIAPI
LShiftU64 (
    UINT64 Operand,
    UINT32 Count
    )
{
    return Operand << Count;
}

STATIC
VOID *
EFIAPI
SetMem (
    OUT VOID   *Buffer,
    IN UINTN   Length,
    IN UINT8   Value
    )
{
    return memset (Buffer, Value, Length);
}

STATIC
VOID *
EFIAPI
SetMem16 (
    OUT VOID   *Buffer,
    IN UINTN   Length,
    IN UINT16  Value
    )
{
    UINTN Index;
    UINT16* Buf = (UINT16*)Buffer;

    if (Buffer == NULL || Length == 0) {
        return Buffer;
    }

    Length /= sizeof(UINT16);

    for (Index = 0; Index < Length; Index++) {
        Buf[Index] = Value;
    }

    return Buffer;
}

/**
  Read NumOfBit of bits from source into mBitBuf.

  Shift mBitBuf NumOfBits left. Read in NumOfBits of bits from source.

  @param  Sd        The global scratch data.
  @param  NumOfBits The number of bits to shift and read.

**/
STATIC
VOID
FillBuf (
    IN  SCRATCH_DATA  *Sd,
    IN  UINT16        NumOfBits
    )
{
    //
    // Left shift NumOfBits of bits in advance
    //
    Sd->mBitBuf = (UINT32)LShiftU64 (((UINT64)Sd->mBitBuf), NumOfBits);

    //
    // Copy data needed in bytes into mSbuBitBuf
    //
    while (NumOfBits > Sd->mBitCount) {
        NumOfBits = (UINT16)(NumOfBits - Sd->mBitCount);
        Sd->mBitBuf |= (UINT32)LShiftU64 (((UINT64)Sd->mSubBitBuf), NumOfBits);

        if (Sd->mCompSize > 0) {
            //
            // Get 1 byte into SubBitBuf
            //
            Sd->mCompSize--;
            Sd->mSubBitBuf = Sd->mSrcBase[Sd->mInBuf++];
            Sd->mBitCount = 8;
        }
        else {
            //
            // No more bits from the source, just pad zero bit.
            //
            Sd->mSubBitBuf = 0;
            Sd->mBitCount = 8;
        }
    }

    //
    // Calculate additional bit count read to update mBitCount
    //
    Sd->mBitCount = (UINT16)(Sd->mBitCount - NumOfBits);

    //
    // Copy NumOfBits of bits from mSubBitBuf into mBitBuf
    //
    Sd->mBitBuf |= Sd->mSubBitBuf >> Sd->mBitCount;
}

/**
  Get NumOfBits of bits out from mBitBuf.

  Get NumOfBits of bits out from mBitBuf. Fill mBitBuf with subsequent
  NumOfBits of bits from source. Returns NumOfBits of bits that are
  popped out.

  @param  Sd        The global scratch data.
  @param  NumOfBits The number of bits to pop and read.

  @return The bits that are popped out.

**/
STATIC
UINT32
GetBits (
    IN  SCRATCH_DATA  *Sd,
    IN  UINT16        NumOfBits
    )
{
    UINT32  OutBits;

    //
    // Pop NumOfBits of Bits from Left
    //
    OutBits = (UINT32)(Sd->mBitBuf >> (BITBUFSIZ - NumOfBits));

    //
    // Fill up mBitBuf from source
    //
    FillBuf (Sd, NumOfBits);

    return OutBits;
}

/**
  Creates Huffman Code mapping table according to code length array.

  Creates Huffman Code mapping table for Extra Set, Char&Len Set
  and Position Set according to code length array.
  If TableBits > 16, then ASSERT ().

  @param  Sd        The global scratch data.
  @param  NumOfChar The number of symbols in the symbol set.
  @param  BitLen    Code length array.
  @param  TableBits The width of the mapping table.
  @param  Table     The table to be created.

  @retval  0 OK.
  @retval  BAD_TABLE The table is corrupted.

**/
STATIC
UINT16
MakeTable (
    IN  SCRATCH_DATA  *Sd,
    IN  UINT16        NumOfChar,
    IN  UINT8         *BitLen,
    IN  UINT16        TableBits,
    OUT UINT16        *Table
    )
{
    UINT16  Count[17];
    UINT16  Weight[17];
    UINT16  Start[18];
    UINT16  *Pointer;
    UINT16  Index3;
    UINT16  Index;
    UINT16  Len;
    UINT16  Char;
    UINT16  JuBits;
    UINT16  Avail;
    UINT16  NextCode;
    UINT16  Mask;
    UINT16  WordOfStart;
    UINT16  WordOfCount;
    UINT16  MaxTableLength;

    //
    // The maximum mapping table width supported by this internal
    // working function is 16.
    //
    if (TableBits >= (sizeof(Count) / sizeof(UINT16))) {
        return (UINT16)BAD_TABLE;
    }

    //
    // Initialize Count array starting from Index 0, as there is a possibility of Count array being uninitialized.
    //
    for (Index = 0; Index <= 16; Index++) {
        Count[Index] = 0;
    }

    for (Index = 0; Index < NumOfChar; Index++) {
        if (BitLen[Index] > 16) {
            return (UINT16)BAD_TABLE;
        }
        Count[BitLen[Index]]++;
    }

    Start[0] = 0;
    Start[1] = 0;

    for (Index = 1; Index <= 16; Index++) {
        WordOfStart = Start[Index];
        WordOfCount = Count[Index];
        Start[Index + 1] = (UINT16)(WordOfStart + (WordOfCount << (16 - Index)));
    }

    if (Start[17] != 0) {
        /*(1U << 16)*/
        return (UINT16)BAD_TABLE;
    }

    JuBits = (UINT16)(16 - TableBits);

    Weight[0] = 0;
    for (Index = 1; Index <= TableBits; Index++) {
        Start[Index] >>= JuBits;
        Weight[Index] = (UINT16)(1U << (TableBits - Index));
    }

    while (Index <= 16) {
        Weight[Index] = (UINT16)(1U << (16 - Index));
        Index++;
    }

    Index = (UINT16)(Start[TableBits + 1] >> JuBits);

    if (Index != 0) {
        Index3 = (UINT16)(1U << TableBits);
        if (Index < Index3) {
            SetMem16 (Table + Index, (Index3 - Index) * sizeof(*Table), 0);
        }
    }

    Avail = NumOfChar;
    Mask = (UINT16)(1U << (15 - TableBits));
    MaxTableLength = (UINT16)(1U << TableBits);

    for (Char = 0; Char < NumOfChar; Char++) {
        Len = BitLen[Char];
        if (Len == 0 || Len >= 17) {
            continue;
        }

        NextCode = (UINT16)(Start[Len] + Weight[Len]);

        if (Len <= TableBits) {

            for (Index = Start[Len]; Index < NextCode; Index++) {
                if (Index >= MaxTableLength) {
                    return (UINT16)BAD_TABLE;
                }
                Table[Index] = Char;
            }

        }
        else {
            Index3 = Start[Len];
            Pointer = &Table[Index3 >> JuBits];
            Index = (UINT16)(Len - TableBits);

            while (Index != 0) {
                if (*Pointer == 0 && Avail < (2 * NC - 1)) {
                    Sd->mRight[Avail] = Sd->mLeft[Avail] = 0;
                    *Pointer = Avail++;
                }

                if (*Pointer < (2 * NC - 1)) {
                    if ((Index3 & Mask) != 0) {
                        Pointer = &Sd->mRight[*Pointer];
                    }
                    else {
                        Pointer = &Sd->mLeft[*Pointer];
                    }
                }

                Index3 <<= 1;
                Index--;
            }

            *Pointer = Char;

        }

        Start[Len] = NextCode;
    }
    //
    // Succeeds
    //
    return 0;
}

/**
  Decodes a position value.

  Get a position value according to Position Huffman Table.

  @param  Sd The global scratch data.

  @return The position value decoded.

**/
UINT32
DecodeP (
    IN  SCRATCH_DATA  *Sd
    )
{
    UINT16  Val;
    UINT32  Mask;
    UINT32  Pos;

    Val = Sd->mPTTable[Sd->mBitBuf >> (BITBUFSIZ - 8)];

    if (Val >= MAXNP) {
        Mask = 1U << (BITBUFSIZ - 1 - 8);

        do {
            if ((Sd->mBitBuf & Mask) != 0) {
                Val = Sd->mRight[Val];
            }
            else {
                Val = Sd->mLeft[Val];
            }

            Mask >>= 1;
        } while (Val >= MAXNP);
    }
    //
    // Advance what we have read
    //
    FillBuf (Sd, Sd->mPTLen[Val]);

    Pos = Val;
    if (Val > 1) {
        Pos = (UINT32)((1U << (Val - 1)) + GetBits (Sd, (UINT16)(Val - 1)));
    }

    return Pos;
}

/**
  Reads code lengths for the Extra Set or the Position Set.

  Read in the Extra Set or Position Set Length Array, then
  generate the Huffman code mapping for them.

  @param  Sd      The global scratch data.
  @param  nn      The number of symbols.
  @param  nbit    The number of bits needed to represent nn.
  @param  Special The special symbol that needs to be taken care of.

  @retval  0 OK.
  @retval  BAD_TABLE Table is corrupted.

**/
STATIC
UINT16
ReadPTLen (
    IN  SCRATCH_DATA  *Sd,
    IN  UINT16        nn,
    IN  UINT16        nbit,
    IN  UINT16        Special
    )
{
    UINT16  Number;
    UINT16  CharC;
    UINT16  Index;
    UINT32  Mask;


    //
    // Read Extra Set Code Length Array size
    //
    Number = (UINT16)GetBits (Sd, nbit);

    if ((Number > sizeof(Sd->mPTLen)) || (nn > sizeof(Sd->mPTLen))) {
        //
        // Fail if Number or nn is greater than size of mPTLen
        //
        return (UINT16)BAD_TABLE;
    }

    if (Number == 0) {
        //
        // This represents only Huffman code used
        //
        CharC = (UINT16)GetBits (Sd, nbit);

        SetMem16 (&Sd->mPTTable[0], sizeof(Sd->mPTTable), CharC);

        SetMem (Sd->mPTLen, nn, 0);

        return 0;
    }

    Index = 0;

    while (Index < Number && Index < NPT) {

        CharC = (UINT16)(Sd->mBitBuf >> (BITBUFSIZ - 3));

        //
        // If a code length is less than 7, then it is encoded as a 3-bit
        // value. Or it is encoded as a series of "1"s followed by a
        // terminating "0". The number of "1"s = Code length - 4.
        //
        if (CharC == 7) {
            Mask = 1U << (BITBUFSIZ - 1 - 3);
            while (Mask & Sd->mBitBuf) {
                Mask >>= 1;
                CharC += 1;
            }
        }

        FillBuf(Sd, (UINT16)((CharC < 7) ? 3 : CharC - 3));

        Sd->mPTLen[Index++] = (UINT8)CharC;

        //
        // For Code&Len Set,
        // After the third length of the code length concatenation,
        // a 2-bit value is used to indicated the number of consecutive
        // zero lengths after the third length.
        //
        if (Index == Special) {
            CharC = (UINT16)GetBits (Sd, 2);
            while ((INT16)(--CharC) >= 0 && Index < NPT) {
                Sd->mPTLen[Index++] = 0;
            }
        }
    }

    while (Index < nn && Index < NPT) {
        Sd->mPTLen[Index++] = 0;
    }

    return MakeTable (Sd, nn, Sd->mPTLen, 8, Sd->mPTTable);
}

/**
  Reads code lengths for Char&Len Set.

  Read in and decode the Char&Len Set Code Length Array, then
  generate the Huffman Code mapping table for the Char&Len Set.

  @param  Sd The global scratch data.

**/
STATIC
VOID
ReadCLen (
    SCRATCH_DATA  *Sd
    )
{
    UINT16           Number;
    UINT16           CharC;
    UINT16           Index;
    UINT32           Mask;

    Number = (UINT16)GetBits (Sd, CBIT);

    if (Number == 0) {
        //
        // This represents only Huffman code used
        //
        CharC = (UINT16)GetBits (Sd, CBIT);

        SetMem (Sd->mCLen, NC, 0);
        SetMem16 (&Sd->mCTable[0], sizeof(Sd->mCTable), CharC);

        return;
    }

    Index = 0;
    while (Index < Number && Index < NC) {
        CharC = Sd->mPTTable[Sd->mBitBuf >> (BITBUFSIZ - 8)];
        if (CharC >= NT) {
            Mask = 1U << (BITBUFSIZ - 1 - 8);

            do {

                if (Mask & Sd->mBitBuf) {
                    CharC = Sd->mRight[CharC];
                }
                else {
                    CharC = Sd->mLeft[CharC];
                }

                Mask >>= 1;

            } while (CharC >= NT);
        }
        //
        // Advance what we have read
        //
        FillBuf (Sd, Sd->mPTLen[CharC]);

        if (CharC <= 2) {

            if (CharC == 0) {
                CharC = 1;
            }
            else if (CharC == 1) {
                CharC = (UINT16)(GetBits (Sd, 4) + 3);
            }
            else if (CharC == 2) {
                CharC = (UINT16)(GetBits (Sd, CBIT) + 20);
            }

            while ((INT16)(--CharC) >= 0 && Index < NC) {
                Sd->mCLen[Index++] = 0;
            }

        }
        else {

            Sd->mCLen[Index++] = (UINT8)(CharC - 2);

        }
    }

    SetMem (Sd->mCLen + Index, NC - Index, 0);

    MakeTable (Sd, NC, Sd->mCLen, 12, Sd->mCTable);

    return;
}

/**
  Decode a character/length value.

  Read one value from mBitBuf, Get one code from mBitBuf. If it is at block boundary, generates
  Huffman code mapping table for Extra Set, Code&Len Set and
  Position Set.

  @param  Sd The global scratch data.

  @return The value decoded.

**/
STATIC
UINT16
DecodeC (
    SCRATCH_DATA  *Sd
    )
{
    UINT16  Index2;
    UINT32  Mask;

    if (Sd->mBlockSize == 0) {
        //
        // Starting a new block
        // Read BlockSize from block header
        //
        Sd->mBlockSize = (UINT16)GetBits (Sd, 16);

        //
        // Read in the Extra Set Code Length Array,
        // Generate the Huffman code mapping table for Extra Set.
        //
        Sd->mBadTableFlag = ReadPTLen (Sd, NT, TBIT, 3);
        if (Sd->mBadTableFlag != 0) {
            return 0;
        }

        //
        // Read in and decode the Char&Len Set Code Length Array,
        // Generate the Huffman code mapping table for Char&Len Set.
        //
        ReadCLen (Sd);

        //
        // Read in the Position Set Code Length Array,
        // Generate the Huffman code mapping table for the Position Set.
        //
        Sd->mBadTableFlag = ReadPTLen (Sd, MAXNP, Sd->mPBit, (UINT16)(-1));
        if (Sd->mBadTableFlag != 0) {
            return 0;
        }
    }

    //
    // Get one code according to Code&Set Huffman Table
    //
    Sd->mBlockSize--;
    Index2 = Sd->mCTable[Sd->mBitBuf >> (BITBUFSIZ - 12)];

    if (Index2 >= NC) {
        Mask = 1U << (BITBUFSIZ - 1 - 12);

        do {
            if ((Sd->mBitBuf & Mask) != 0) {
                Index2 = Sd->mRight[Index2];
            }
            else {
                Index2 = Sd->mLeft[Index2];
            }

            Mask >>= 1;
        } while (Index2 >= NC);
    }
    //
    // Advance what we have read
    //
    FillBuf (Sd, Sd->mCLen[Index2]);

    return Index2;
}

/**
  Decode the source data and put the resulting data into the destination buffer.

  @param  Sd The global scratch data.

**/
STATIC
VOID
Decode (
    SCRATCH_DATA  *Sd
    )
{
    UINT16  BytesRemain;
    UINT32  DataIdx;
    UINT16  CharC;

    for (;;) {
        //
        // Get one code from mBitBuf
        //
        CharC = DecodeC(Sd);
        if (Sd->mBadTableFlag != 0) {
            goto Done;
        }

        if (CharC < 256) {
            //
            // Process an Original character
            //
            if (Sd->mOutBuf >= Sd->mOrigSize) {
                goto Done;
            }
            else {
                //
                // Write orignal character into mDstBase
                //
                Sd->mDstBase[Sd->mOutBuf++] = (UINT8)CharC;
            }

        }
        else {
            //
            // Process a Pointer
            //
            CharC = (UINT16)(CharC - (0x00000100U - THRESHOLD));

            //
            // Get string length
            //
            BytesRemain = CharC;

            //
            // Locate string position
            //
            DataIdx = Sd->mOutBuf - DecodeP(Sd) - 1;

            //
            // Write BytesRemain of bytes into mDstBase
            //
            BytesRemain--;

            while ((INT16)(BytesRemain) >= 0) {
                if (Sd->mOutBuf >= Sd->mOrigSize) {
                    goto Done;
                }
                if (DataIdx >= Sd->mOrigSize) {
                    Sd->mBadTableFlag = (UINT16)BAD_TABLE;
                    goto Done;
                }
                Sd->mDstBase[Sd->mOutBuf++] = Sd->mDstBase[DataIdx++];

                BytesRemain--;
            }

            //
            // Once mOutBuf is fully filled, directly return
            //
            if (Sd->mOutBuf >= Sd->mOrigSize) {
                goto Done;
            }
        }
    }

Done:
    return;
}

/**
  Given a compressed source buffer, this function retrieves the size of
  the uncompressed buffer and the size of the scratch buffer required
  to decompress the compressed source buffer.

  Retrieves the size of the uncompressed buffer and the temporary scratch buffer
  required to decompress the buffer specified by Source and SourceSize.
  If the size of the uncompressed buffer or the size of the scratch buffer cannot
  be determined from the compressed data specified by Source and SourceData,
  then EFI_INVALID_PARAMETER is returned.  Otherwise, the size of the uncompressed
  buffer is returned in DestinationSize, the size of the scratch buffer is returned
  in ScratchSize, and EFI_SUCCESS is returned.
  This function does not have scratch buffer available to perform a thorough
  checking of the validity of the source data.  It just retrieves the "Original Size"
  field from the beginning bytes of the source data and output it as DestinationSize.
  And ScratchSize is specific to the decompression implementation.

  @param  Source          The source buffer containing the compressed data.
  @param  SourceSize      The size, in bytes, of the source buffer.
  @param  DestinationSize A pointer to the size, in bytes, of the uncompressed buffer
                          that will be generated when the compressed buffer specified
                          by Source and SourceSize is decompressed.
  @param  ScratchSize     A pointer to the size, in bytes, of the scratch buffer that
                          is required to decompress the compressed buffer specified
                          by Source and SourceSize.

  @retval  EFI_SUCCESS    The size of the uncompressed data was returned
                          in DestinationSize, and the size of the scratch
                          buffer was returned in ScratchSize.
  @retval  EFI_INVALID_PARAMETER
                          The size of the uncompressed data or the size of
                          the scratch buffer cannot be determined from
                          the compressed data specified by Source
                          and SourceSize.
**/
EFI_STATUS
EFIAPI
GetInfo (
    IN  CONST VOID  *Source,
    IN  UINT32      SourceSize,
    OUT UINT32      *DestinationSize,
    OUT UINT32      *ScratchSize
    )
{
    UINT32  CompressedSize;

    if (Source == NULL || DestinationSize == NULL || ScratchSize == NULL || SourceSize < 8) {
        return EFI_INVALID_PARAMETER;
    }

    CompressedSize = *(UINT32 *)Source;
    if (SourceSize < (CompressedSize + 8) || (CompressedSize + 8) < 8) {
        return EFI_INVALID_PARAMETER;
    }

    *ScratchSize = sizeof(SCRATCH_DATA);
    *DestinationSize = *((UINT32 *)Source + 1);

    return EFI_SUCCESS;
}

/**
  Decompresses a compressed source buffer.

  Extracts decompressed data to its original form.
  This function is designed so that the decompression algorithm can be implemented
  without using any memory services.  As a result, this function is not allowed to
  call any memory allocation services in its implementation.  It is the caller's
  responsibility to allocate and free the Destination and Scratch buffers.
  If the compressed source data specified by Source is successfully decompressed
  into Destination, then RETURN_SUCCESS is returned.  If the compressed source data
  specified by Source is not in a valid compressed data format,
  then RETURN_INVALID_PARAMETER is returned.

  @param  Source      The source buffer containing the compressed data.
  @param  Destination The destination buffer to store the decompressed data.
  @param  Scratch     A temporary scratch buffer that is used to perform the decompression.
                      This is an optional parameter that may be NULL if the
                      required scratch buffer size is 0.

  @retval  EFI_SUCCESS    Decompression completed successfully, and
                          the uncompressed buffer is returned in Destination.
  @retval  EFI_INVALID_PARAMETER
                          The source buffer specified by Source is corrupted
                          (not in a valid compressed format).
**/
EFI_STATUS
EFIAPI
Decompress (
    IN      CONST VOID *Source,
    IN      UINT32     SrcSize,
    IN OUT  VOID       *Destination,
    IN      UINT32     DstSize,
    IN OUT  VOID       *Scratch,
    IN      UINT32     ScratchSize,
    IN      UINT8      Version
    )
{
    UINT32           CompSize;
    UINT32           OrigSize;
    SCRATCH_DATA     *Sd;
    CONST UINT8      *Src = Source;
    UINT8            *Dst = Destination;
    EFI_STATUS       Status = EFI_SUCCESS;

    if (ScratchSize < sizeof(SCRATCH_DATA)) {
        return EFI_INVALID_PARAMETER;
    }

    Sd = (SCRATCH_DATA *)Scratch;

    if (SrcSize < 8) {
        return EFI_INVALID_PARAMETER;
    }

    CompSize = Src[0] + (Src[1] << 8) + (Src[2] << 16) + (Src[3] << 24);
    OrigSize = Src[4] + (Src[5] << 8) + (Src[6] << 16) + (Src[7] << 24);

    //
    // If compressed file size is 0, return
    //
    if (OrigSize == 0) {
        return Status;
    }

    if (SrcSize < CompSize + 8) {
        return EFI_INVALID_PARAMETER;
    }

    if (DstSize != OrigSize) {
        return EFI_INVALID_PARAMETER;
    }

    Src = Src + 8;

    SetMem (Sd, sizeof(SCRATCH_DATA), 0);
    //
    // The length of the field 'Position Set Code Length Array Size' in Block Header.
    // For EFI 1.1 de/compression algorithm(Version 1), mPBit = 4
    // For Tiano de/compression algorithm(Version 2), mPBit = 5
    //
    switch (Version) {
    case 1:
        Sd->mPBit = 4;
        break;

    case 2:
        Sd->mPBit = 5;
        break;

    default:
        //
        // Currently, only have 2 versions
        //
        return EFI_INVALID_PARAMETER;
    }

    Sd->mSrcBase = (UINT8*)Src;
    Sd->mDstBase = Dst;
    //
    // CompSize and OrigSize are calculated in bytes
    //
    Sd->mCompSize = CompSize;
    Sd->mOrigSize = OrigSize;

    //
    // Fill the first BITBUFSIZ bits
    //
    FillBuf (Sd, BITBUFSIZ);

    //
    // Decompress it
    //
    Decode (Sd);

    if (Sd->mBadTableFlag != 0) {
        //
        // Something wrong with the source
        //
        Status = EFI_INVALID_PARAMETER;
    }

    return Status;
}

/*++

Routine Description:

The implementation of EFI_DECOMPRESS_PROTOCOL.GetInfo().

Arguments:

This        - The protocol instance pointer
Source      - The source buffer containing the compressed data.
SrcSize     - The size of source buffer
DstSize     - The size of destination buffer.
ScratchSize - The size of scratch buffer.

Returns:

EFI_SUCCESS           - The size of destination buffer and the size of scratch buffer are successful retrieved.
EFI_INVALID_PARAMETER - The source data is corrupted

--*/
EFI_STATUS
EFIAPI
EfiTianoGetInfo (
    IN      CONST VOID *Source,
    IN      UINT32      SrcSize,
    OUT     UINT32      *DstSize,
    OUT     UINT32      *ScratchSize
    )
{
    return GetInfo (Source, SrcSize, DstSize, ScratchSize);
}

/*++

Routine Description:

The implementation of EFI_DECOMPRESS_PROTOCOL.Decompress().

Arguments:

This        - The protocol instance pointer
Source      - The source buffer containing the compressed data.
SrcSize     - The size of source buffer
Destination - The destination buffer to store the decompressed data
DstSize     - The size of destination buffer.
Scratch     - The buffer used internally by the decompress routine. This  buffer is needed to store intermediate data.
ScratchSize - The size of scratch buffer.

Returns:

EFI_SUCCESS           - Decompression is successful
EFI_INVALID_PARAMETER - The source data is corrupted

--*/
EFI_STATUS
EFIAPI
EfiDecompress (
    IN      CONST VOID *Source,
    IN      UINT32     SrcSize,
    IN OUT  VOID       *Destination,
    IN      UINT32     DstSize,
    IN OUT  VOID       *Scratch,
    IN      UINT32     ScratchSize
    )
{
    //
    // For EFI 1.1 de/compression algorithm, the version is 1.
    //
    return Decompress (
        Source,
        SrcSize,
        Destination,
        DstSize,
        Scratch,
        ScratchSize,
        1
        );
}

/*++

Routine Description:

The implementation of EFI_TIANO_DECOMPRESS_PROTOCOL.Decompress().

Arguments:

This        - The protocol instance pointer
Source      - The source buffer containing the compressed data.
SrcSize     - The size of source buffer
Destination - The destination buffer to store the decompressed data
DstSize     - The size of destination buffer.
Scratch     - The buffer used internally by the decompress routine. This  buffer is needed to store intermediate data.
ScratchSize - The size of scratch buffer.

Returns:

EFI_SUCCESS           - Decompression is successful
EFI_INVALID_PARAMETER - The source data is corrupted

--*/
EFI_STATUS
EFIAPI
TianoDecompress (
    IN      CONST VOID *Source,
    IN      UINT32     SrcSize,
    IN OUT  VOID       *Destination,
    IN      UINT32     DstSize,
    IN OUT  VOID       *Scratch,
    IN      UINT32     ScratchSize
    )
{
    //
    // For Tiano de/compression algorithm, the version is 2.
    //
    return Decompress (
        Source,
        SrcSize,
        Destination,
        DstSize,
        Scratch,
        ScratchSize,
        2
        );
}

```

`efiXloader/3rd/uefitool/common/Tiano/EfiTianoDecompress.h`:

```h
/* EfiTianoDecompress.h

Copyright (c) 2015, Nikolaj Schlej. All rights reserved.<BR>
Copyright (c) 2004 - 2008, Intel Corporation. All rights reserved.<BR>
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

Module Name:

Decompress.h

Abstract:

Header file for decompression routine.
Providing both EFI and Tiano decompress algorithms.

--*/

#ifndef EFITIANODECOMPRESS_H
#define EFITIANODECOMPRESS_H
#include <string.h>
#include <stdlib.h>

#include "../basetypes.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef struct EFI_TIANO_HEADER_ {
    UINT32 CompSize;
    UINT32 OrigSize;
} EFI_TIANO_HEADER;

/*++

Routine Description:

The implementation is same as that of EFI_DECOMPRESS_PROTOCOL.GetInfo().

Arguments:

Source      - The source buffer containing the compressed data.
SrcSize     - The size of source buffer
DstSize     - The size of destination buffer.
ScratchSize - The size of scratch buffer.

Returns:

EFI_SUCCESS           - The size of destination buffer and the size of scratch buffer are successfully retrieved.
EFI_INVALID_PARAMETER - The source data is corrupted

--*/
EFI_STATUS
EFIAPI
EfiTianoGetInfo (
    IN      CONST VOID *Source,
    IN      UINT32      SrcSize,
    OUT     UINT32      *DstSize,
    OUT     UINT32      *ScratchSize
    );


/*++

Routine Description:

The implementation is same as that of EFI_DECOMPRESS_PROTOCOL.Decompress().

Arguments:

Source      - The source buffer containing the compressed data.
SrcSize     - The size of source buffer
Destination - The destination buffer to store the decompressed data
DstSize     - The size of destination buffer.
Scratch     - The buffer used internally by the decompress routine. This  buffer is needed to store intermediate data.
ScratchSize - The size of scratch buffer.

Returns:

EFI_SUCCESS           - Decompression is successful
EFI_INVALID_PARAMETER - The source data is corrupted

--*/
EFI_STATUS
EFIAPI
EfiDecompress(
    IN      CONST VOID *Source,
    IN      UINT32     SrcSize,
    IN OUT  VOID       *Destination,
    IN      UINT32     DstSize,
    IN OUT  VOID       *Scratch,
    IN      UINT32     ScratchSize
);

/*++

Routine Description:

The implementation is same as that  of EFI_TIANO_DECOMPRESS_PROTOCOL.Decompress().

Arguments:

Source      - The source buffer containing the compressed data.
SrcSize     - The size of source buffer
Destination - The destination buffer to store the decompressed data
DstSize     - The size of destination buffer.
Scratch     - The buffer used internally by the decompress routine. This  buffer is needed to store intermediate data.
ScratchSize - The size of scratch buffer.

Returns:

EFI_SUCCESS           - Decompression is successful
EFI_INVALID_PARAMETER - The source data is corrupted

--*/
EFI_STATUS
EFIAPI
TianoDecompress(
    IN      CONST VOID *Source,
    IN      UINT32     SrcSize,
    IN OUT  VOID       *Destination,
    IN      UINT32     DstSize,
    IN OUT  VOID       *Scratch,
    IN      UINT32     ScratchSize
    );

#ifdef __cplusplus
}
#endif
#endif // EFITIANODECOMPRESS_H

```

`efiXloader/3rd/uefitool/common/basetypes.h`:

```h
/* basetypes.h

Copyright (c) 2016, Nikolaj Schlej. All rights reserved.
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

*/

#ifndef BASETYPES_H
#define BASETYPES_H

#include <stdarg.h>
#include <stdint.h>
#include <stddef.h>

typedef size_t USTATUS;
#define U_SUCCESS                         0
#define U_INVALID_PARAMETER               1
#define U_BUFFER_TOO_SMALL                2
#define U_OUT_OF_RESOURCES                3
#define U_OUT_OF_MEMORY                   4
#define U_FILE_OPEN                       5
#define U_FILE_READ                       6
#define U_FILE_WRITE                      7
#define U_ITEM_NOT_FOUND                  8
#define U_UNKNOWN_ITEM_TYPE               9
#define U_INVALID_FLASH_DESCRIPTOR        10
#define U_INVALID_REGION                  11
#define U_EMPTY_REGION                    12
#define U_BIOS_REGION_NOT_FOUND           13
#define U_VOLUMES_NOT_FOUND               14
#define U_INVALID_VOLUME                  15
#define U_VOLUME_REVISION_NOT_SUPPORTED   16
#define U_COMPLEX_BLOCK_MAP               17
#define U_UNKNOWN_FFS                     18
#define U_INVALID_FILE                    19
#define U_INVALID_SECTION                 20
#define U_UNKNOWN_SECTION                 21
#define U_STANDARD_COMPRESSION_FAILED     22
#define U_CUSTOMIZED_COMPRESSION_FAILED   23
#define U_STANDARD_DECOMPRESSION_FAILED   24
#define U_CUSTOMIZED_DECOMPRESSION_FAILED 25
#define U_GZIP_DECOMPRESSION_FAILED       26
#define U_UNKNOWN_COMPRESSION_TYPE        27
#define U_DEPEX_PARSE_FAILED              28
#define U_UNKNOWN_EXTRACT_MODE            29
#define U_UNKNOWN_REPLACE_MODE            30
#define U_UNKNOWN_IMAGE_TYPE              31
#define U_UNKNOWN_PE_OPTIONAL_HEADER_TYPE 32
#define U_UNKNOWN_RELOCATION_TYPE         33
#define U_DIR_ALREADY_EXIST               34
#define U_DIR_CREATE                      35
#define U_DIR_CHANGE                      36
#define U_TRUNCATED_IMAGE                 37
#define U_INVALID_CAPSULE                 38
#define U_STORES_NOT_FOUND                39
#define U_INVALID_IMAGE                   40
#define U_INVALID_RAW_AREA                41
#define U_INVALID_FIT                     42
#define U_INVALID_MICROCODE               43
#define U_INVALID_ACM                     44
#define U_INVALID_BG_KEY_MANIFEST         45
#define U_INVALID_BG_BOOT_POLICY          46
#define U_INVALID_TXT_CONF                47
#define U_ELEMENTS_NOT_FOUND              48
#define U_PEI_CORE_ENTRY_POINT_NOT_FOUND  49
#define U_INVALID_STORE_SIZE              50
#define U_UNKNOWN_COMPRESSION_ALGORITHM   51
#define U_NOTHING_TO_PATCH                52
#define U_UNKNOWN_PATCH_TYPE              53
#define U_PATCH_OFFSET_OUT_OF_BOUNDS      54
#define U_INVALID_SYMBOL                  55

#define U_INVALID_MANIFEST                251
#define U_UNKNOWN_MANIFEST_HEADER_VERSION 252
#define U_INVALID_ME_PARTITION_TABLE      253
#define U_INVALID_ME_PARTITION            254

#define U_NOT_IMPLEMENTED                 0xFF

// EDK2 porting definitions
typedef uint8_t      BOOLEAN;
typedef int8_t       INT8;
typedef uint8_t      UINT8;
typedef int16_t      INT16;
typedef uint16_t     UINT16;
typedef int32_t      INT32;
typedef uint32_t     UINT32;
typedef int64_t      INT64;
typedef uint64_t     UINT64;
typedef char         CHAR8;
typedef uint16_t     CHAR16;
typedef size_t       UINTN;
typedef ptrdiff_t    INTN;

#define CONST  const
#define VOID   void
#define STATIC static

#ifndef INT32_MAX
#define INT32_MAX 0x7fffffff
#endif

#ifndef TRUE
#define TRUE  ((BOOLEAN)(1==1))
#endif

#ifndef FALSE
#define FALSE ((BOOLEAN)(0==1))
#endif

#define IN
#define OUT
#define EFIAPI
#define EFI_STATUS UINTN
#define EFI_SUCCESS U_SUCCESS
#define EFI_INVALID_PARAMETER U_INVALID_PARAMETER
#define EFI_OUT_OF_RESOURCES U_OUT_OF_RESOURCES
#define EFI_BUFFER_TOO_SMALL U_BUFFER_TOO_SMALL
#define EFI_ERROR(X) (X)

// Compression algorithms
#define COMPRESSION_ALGORITHM_UNKNOWN                0
#define COMPRESSION_ALGORITHM_NONE                   1
#define COMPRESSION_ALGORITHM_EFI11                  2
#define COMPRESSION_ALGORITHM_TIANO                  3
#define COMPRESSION_ALGORITHM_UNDECIDED              4
#define COMPRESSION_ALGORITHM_LZMA                   5
#define COMPRESSION_ALGORITHM_LZMA_INTEL_LEGACY      6
#define COMPRESSION_ALGORITHM_LZMAF86                7
#define COMPRESSION_ALGORITHM_GZIP                   8


// Item create modes
#define CREATE_MODE_APPEND    0
#define CREATE_MODE_PREPEND   1
#define CREATE_MODE_BEFORE    2
#define CREATE_MODE_AFTER     3

// Item extract modes
#define EXTRACT_MODE_AS_IS                 0
#define EXTRACT_MODE_BODY                  1
#define EXTRACT_MODE_BODY_UNCOMPRESSED     2

// Item replace modes
#define REPLACE_MODE_AS_IS    0
#define REPLACE_MODE_BODY     1

// Item patch modes
#define PATCH_MODE_HEADER     0
#define PATCH_MODE_BODY       1

// Patch types
#define PATCH_TYPE_OFFSET    'O'
#define PATCH_TYPE_PATTERN   'P'

// Erase polarity types
#define ERASE_POLARITY_FALSE   0
#define ERASE_POLARITY_TRUE    1
#define ERASE_POLARITY_UNKNOWN 0xFF

// Search modes
#define SEARCH_MODE_HEADER    1
#define SEARCH_MODE_BODY      2
#define SEARCH_MODE_ALL       3

// EFI GUID
typedef struct EFI_GUID_ {
    UINT32 Data1;
    UINT16 Data2;
    UINT16 Data3;
    UINT8  Data4[8];
} EFI_GUID;

// EFI Time
typedef struct EFI_TIME_ {
    UINT16  Year;       // Year:       2000 - 20XX
    UINT8   Month;      // Month:      1 - 12
    UINT8   Day;        // Day:        1 - 31
    UINT8   Hour;       // Hour:       0 - 23
    UINT8   Minute;     // Minute:     0 - 59
    UINT8   Second;     // Second:     0 - 59
    UINT8   Reserved0;
    UINT32  Nanosecond; // Nanosecond: 0 - 999,999,999
    INT16   TimeZone;   // TimeZone:   -1440 to 1440 or UNSPECIFIED (0x07FF)
    UINT8   Daylight;   // Daylight:   ADJUST_DAYLIGHT (1) or IN_DAYLIGHT (2) 
    UINT8   Reserved1;
} EFI_TIME;

// Align to 4 or 8 bytes
#define ALIGN4(Value) (((Value)+3) & ~3)
#define ALIGN8(Value) (((Value)+7) & ~7)

// Unused parameter declaration
#define U_UNUSED_PARAMETER(x) ((void)x)

// Assert macro
#include <assert.h>
#define ASSERT(x) assert(x)

// SHA256 hash size in bytes
#define SHA256_HASH_SIZE 0x20

#endif // BASETYPES_H

```

`efiXloader/3rd/uefitool/common/bootguard.h`:

```h
/* bootguard.h

Copyright (c) 2017, LongSoft. All rights reserved.
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

*/

#ifndef BOOTGUARD_H
#define BOOTGUARD_H

#include "basetypes.h"
#include "sha256.h"

#pragma pack(push, 1)

const UByteArray BG_VENDOR_HASH_FILE_GUID_PHOENIX // 389CC6F2-1EA8-467B-AB8A-78E769AE2A15
("\xF2\xC6\x9C\x38\xA8\x1E\x7B\x46\xAB\x8A\x78\xE7\x69\xAE\x2A\x15", 16);

#define BG_VENDOR_HASH_FILE_SIGNATURE_PHOENIX (*(UINT64 *)"$HASHTBL")

const UByteArray BG_VENDOR_HASH_FILE_GUID_AMI // CBC91F44-A4BC-4A5B-8696-703451D0B053
("\x44\x1F\xC9\xCB\xBC\xA4\x5B\x4A\x86\x96\x70\x34\x51\xD0\xB0\x53", 16);

typedef struct BG_VENDOR_HASH_FILE_ENTRY
{
    UINT8  Hash[SHA256_DIGEST_SIZE];
    UINT32 Offset;
    UINT32 Size;
} BG_VENDOR_HASH_FILE_ENTRY;

typedef struct BG_VENDOR_HASH_FILE_HEADER_PHOENIX_
{
    UINT64 Signature;
    UINT32 NumEntries;
    //BG_VENDOR_HASH_FILE_ENTRY Entries[];
} BG_VENDOR_HASH_FILE_HEADER_PHOENIX;

typedef struct BG_VENDOR_HASH_FILE_HEADER_AMI_NEW_
{
    BG_VENDOR_HASH_FILE_ENTRY Entries[2];
} BG_VENDOR_HASH_FILE_HEADER_AMI_NEW;

typedef struct BG_VENDOR_HASH_FILE_HEADER_AMI_OLD_
{
    UINT8  Hash[SHA256_DIGEST_SIZE];
    UINT32 Size;
    // Offset is derived from flash map, will be detected as root volume with DXE core
} BG_VENDOR_HASH_FILE_HEADER_AMI_OLD;

typedef struct BG_MICROSOFT_PMDA_HEADER_
{
    UINT32 Version;
    UINT32 NumEntries;
} BG_MICROSOFT_PMDA_HEADER;

#define BG_MICROSOFT_PMDA_VERSION 0x00000001

typedef struct BG_MICROSOFT_PMDA_ENTRY_
{
    UINT32 Address;
    UINT32 Size;
    UINT8  Hash[SHA256_DIGEST_SIZE];
} BG_MICROSOFT_PMDA_ENTRY;

//
// Intel ACM
//

#define INTEL_ACM_MODULE_TYPE               0x2
#define INTEL_ACM_MODULE_SUBTYPE_TXT_ACM    0x0
#define INTEL_ACM_MODULE_SUBTYPE_S_ACM      0x1
#define INTEL_ACM_MODULE_SUBTYPE_BOOTGUARD  0x3
#define INTEL_ACM_MODULE_VENDOR             0x8086

typedef struct INTEL_ACM_HEADER_ {
    UINT16 ModuleType;
    UINT16 ModuleSubtype;
    UINT32 HeaderType;
    UINT32 HeaderVersion;
    UINT16 ChipsetId;
    UINT16 Flags;
    UINT32 ModuleVendor;
    UINT8  DateDay;
    UINT8  DateMonth;
    UINT16 DateYear;
    UINT32 ModuleSize;
    UINT16 AcmSvn;
    UINT16 : 16;
    UINT32 Unknown1;
    UINT32 Unknown2;
    UINT32 GdtMax;
    UINT32 GdtBase;
    UINT32 SegmentSel;
    UINT32 EntryPoint;
    UINT8  Unknown3[64];
    UINT32 KeySize;
    UINT32 Unknown4;
    UINT8  RsaPubKey[256];
    UINT32 RsaPubExp;
    UINT8  RsaSig[256];
} INTEL_ACM_HEADER;

//
// Intel BootGuard Key Manifest
//
#define BG_BOOT_POLICY_MANIFEST_HEADER_TAG  (*(UINT64 *)"__ACBP__")
typedef struct BG_BOOT_POLICY_MANIFEST_HEADER_ {
    UINT64 Tag;
    UINT8  Version;
    UINT8  HeaderVersion;
    UINT8  PMBPMVersion;
    UINT8  BPSVN;
    UINT8  ACMSVN;
    UINT8  : 8;
    UINT16 NEMDataSize;
} BG_BOOT_POLICY_MANIFEST_HEADER;

typedef struct SHA256_HASH_ {
    UINT16 HashAlgorithmId;
    UINT16 Size;
    UINT8  HashBuffer[32];
} SHA256_HASH;

typedef struct RSA_PUBLIC_KEY_ {
    UINT8  Version;
    UINT16 KeySize;
    UINT32 Exponent;
    UINT8  Modulus[256];
} RSA_PUBLIC_KEY;

typedef struct RSA_SIGNATURE_ {
    UINT8  Version;
    UINT16 KeySize;
    UINT16 HashId;
    UINT8  Signature[256];
} RSA_SIGNATURE;

typedef struct KEY_SIGNATURE_ {
    UINT8          Version;
    UINT16         KeyId;
    RSA_PUBLIC_KEY PubKey;
    UINT16         SigScheme;
    RSA_SIGNATURE  Signature;
} BG_KEY_SIGNATURE;

#define BG_IBB_SEGMENT_FLAG_IBB      0x0
#define BG_IBB_SEGMENT_FLAG_NON_IBB  0x1
typedef struct BG_IBB_SEGMENT_ELEMENT_ {
UINT16: 16;
    UINT16 Flags;
    UINT32 Base;
    UINT32 Size;
} BG_IBB_SEGMENT_ELEMENT;

#define BG_BOOT_POLICY_MANIFEST_IBB_ELEMENT_TAG  (*(UINT64 *)"__IBBS__")
#define BG_IBB_FLAG_AUTHORITY_MEASURE            0x4

typedef struct BG_IBB_ELEMENT_ {
    UINT64                 Tag;
    UINT8                  Version;
    UINT16                 : 16;
    UINT8                  Unknown;
    UINT32                 Flags;
    UINT64                 IbbMchBar;
    UINT64                 VtdBar;
    UINT32                 PmrlBase;
    UINT32                 PmrlLimit;
    UINT64                 Unknown3;
    UINT64                 Unknown4;
    SHA256_HASH            IbbHash;
    UINT32                 EntryPoint;
    SHA256_HASH            Digest;
    UINT8                  IbbSegCount;
    // BG_IBB_SEGMENT_ELEMENT IbbSegment[];
} BG_IBB_ELEMENT;

#define BG_BOOT_POLICY_MANIFEST_PLATFORM_MANUFACTURER_ELEMENT_TAG  (*(UINT64 *)"__PMDA__")
typedef struct BG_PLATFORM_MANUFACTURER_ELEMENT_ {
    UINT64 Tag;
    UINT8  Version;
    UINT16 DataSize;
} BG_PLATFORM_MANUFACTURER_ELEMENT;

#define BG_BOOT_POLICY_MANIFEST_SIGNATURE_ELEMENT_TAG  (*(UINT64 *)"__PMSG__")
typedef struct BG_BOOT_POLICY_MANIFEST_SIGNATURE_ELEMENT_ {
    UINT64               Tag;
    UINT8                Version;
    BG_KEY_SIGNATURE     KeySignature;
} BG_BOOT_POLICY_MANIFEST_SIGNATURE_ELEMENT;

#define BG_KEY_MANIFEST_TAG  (*(UINT64 *)"__KEYM__")
typedef struct BG_KEY_MANIFEST_ {
    UINT64               Tag;
    UINT8                Version;
    UINT8                KmVersion;
    UINT8                KmSvn;
    UINT8                KmId;
    SHA256_HASH          BpKeyHash;
    BG_KEY_SIGNATURE     KeyManifestSignature;
} BG_KEY_MANIFEST;

#pragma pack(pop)

#endif // BOOTGUARD_H
```

`efiXloader/3rd/uefitool/common/bstrlib/LICENSE`:

```
Copyright (c) 2014, Paul Hsieh
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of bstrlib nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


```

`efiXloader/3rd/uefitool/common/bstrlib/bstrlib.c`:

```c
/*
 * This source file is part of the bstring string library.  This code was
 * written by Paul Hsieh in 2002-2015, and is covered by the BSD open source
 * license and the GPL. Refer to the accompanying documentation for details
 * on usage and license.
 */

/*
 * bstrlib.c
 *
 * This file is the core module for implementing the bstring functions.
 */

#if defined (_MSC_VER)
# define _CRT_SECURE_NO_WARNINGS
#endif

#include <stdio.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <limits.h>
#include "bstrlib.h"

/* Optionally include a mechanism for debugging memory */

#if defined(MEMORY_DEBUG) || defined(BSTRLIB_MEMORY_DEBUG)
#include "memdbg.h"
#endif

#ifndef bstr__alloc
#if defined (BSTRLIB_TEST_CANARY)
void* bstr__alloc (size_t sz) {
	char* p = (char *) malloc (sz);
	memset (p, 'X', sz);
	return p;
}
#else
#define bstr__alloc(x) malloc (x)
#endif
#endif

#ifndef bstr__free
#define bstr__free(p) free (p)
#endif

#ifndef bstr__realloc
#define bstr__realloc(p,x) realloc ((p), (x))
#endif

#ifndef bstr__memcpy
#define bstr__memcpy(d,s,l) memcpy ((d), (s), (l))
#endif

#ifndef bstr__memmove
#define bstr__memmove(d,s,l) memmove ((d), (s), (l))
#endif

#ifndef bstr__memset
#define bstr__memset(d,c,l) memset ((d), (c), (l))
#endif

#ifndef bstr__memcmp
#define bstr__memcmp(d,c,l) memcmp ((d), (c), (l))
#endif

#ifndef bstr__memchr
#define bstr__memchr(s,c,l) memchr ((s), (c), (l))
#endif

/* Just a length safe wrapper for memmove. */

#define bBlockCopy(D,S,L) { if ((L) > 0) bstr__memmove ((D),(S),(L)); }

/* Compute the snapped size for a given requested size.  By snapping to powers
   of 2 like this, repeated reallocations are avoided. */
static int snapUpSize (int i) {
	if (i < 8) {
		i = 8;
	} else {
		unsigned int j;
		j = (unsigned int) i;

		j |= (j >>  1);
		j |= (j >>  2);
		j |= (j >>  4);
		j |= (j >>  8);		/* Ok, since int >= 16 bits */
#if (UINT_MAX != 0xffff)
		j |= (j >> 16);		/* For 32 bit int systems */
#if (UINT_MAX > 0xffffffffUL)
		j |= (j >> 32);		/* For 64 bit int systems */
#endif
#endif
		/* Least power of two greater than i */
		j++;
		if ((int) j >= i) i = (int) j;
	}
	return i;
}

/*  int balloc (bstring b, int len)
 *
 *  Increase the size of the memory backing the bstring b to at least olen + 1.
 */
int balloc (bstring b, int olen) {
	int len;
	if (b == NULL || b->data == NULL || b->slen < 0 || b->mlen <= 0 ||
	    b->mlen < b->slen || olen <= 0) {
		return BSTR_ERR;
	}

	if (olen >= b->mlen) {
		unsigned char * x;

		if ((len = snapUpSize (olen)) <= b->mlen) return BSTR_OK;

		/* Assume probability of a non-moving realloc is 0.125 */
		if (7 * b->mlen < 8 * b->slen) {

			/* If slen is close to mlen in size then use realloc to reduce
			   the memory defragmentation */

			reallocStrategy:;

			x = (unsigned char *) bstr__realloc (b->data, (size_t) len + 1);
			if (x == NULL) {

				/* Since we failed, try allocating the tighest possible
				   allocation */

				len = olen;
				x = (unsigned char *) bstr__realloc (b->data, (size_t) len + 1);
				if (NULL == x) {
					return BSTR_ERR;
				}
			}
		} else {

			/* If slen is not close to mlen then avoid the penalty of copying
			   the extra bytes that are allocated, but not considered part of
			   the string */

			if (NULL == (x = (unsigned char *) bstr__alloc ((size_t) len + 1))) {

				/* Perhaps there is no available memory for the two
				   allocations to be in memory at once */

				goto reallocStrategy;

			} else {
				if (b->slen) bstr__memcpy ((char *) x, (char *) b->data,
				                           (size_t) b->slen);
				bstr__free (b->data);
			}
		}
		b->data = x;
		b->mlen = len;
		b->data[b->slen] = (unsigned char) '\0';

#if defined (BSTRLIB_TEST_CANARY)
		if (len > b->slen + 1) {
			memchr (b->data + b->slen + 1, 'X', len - (b->slen + 1));
		}
#endif
	}

	return BSTR_OK;
}

/*  int ballocmin (bstring b, int len)
 *
 *  Set the size of the memory backing the bstring b to len or b->slen+1,
 *  whichever is larger.  Note that repeated use of this function can degrade
 *  performance.
 */
int ballocmin (bstring b, int len) {
	unsigned char * s;

	if (b == NULL || b->data == NULL) return BSTR_ERR;
	if (b->slen >= INT_MAX || b->slen < 0) return BSTR_ERR;
	if (b->mlen <= 0 || b->mlen < b->slen || len <= 0) {
		return BSTR_ERR;
	}

	if (len < b->slen + 1) len = b->slen + 1;

	if (len != b->mlen) {
		s = (unsigned char *) bstr__realloc (b->data, (size_t) len);
		if (NULL == s) return BSTR_ERR;
		s[b->slen] = (unsigned char) '\0';
		b->data = s;
		b->mlen = len;
	}

	return BSTR_OK;
}

/*  bstring bfromcstr (const char * str)
 *
 *  Create a bstring which contains the contents of the '\0' terminated char *
 *  buffer str.
 */
bstring bfromcstr (const char * str) {
bstring b;
int i;
size_t j;

	if (str == NULL) return NULL;
	j = (strlen) (str);
	i = snapUpSize ((int) (j + (2 - (j != 0))));
	if (i <= (int) j) return NULL;

	b = (bstring) bstr__alloc (sizeof (struct tagbstring));
	if (NULL == b) return NULL;
	b->slen = (int) j;
	if (NULL == (b->data = (unsigned char *) bstr__alloc (b->mlen = i))) {
		bstr__free (b);
		return NULL;
	}

	bstr__memcpy (b->data, str, j+1);
	return b;
}

/*  bstring bfromcstrrangealloc (int minl, int maxl, const char* str)
 *
 *  Create a bstring which contains the contents of the '\0' terminated
 *  char* buffer str.  The memory buffer backing the string is at least
 *  minl characters in length, but an attempt is made to allocate up to
 *  maxl characters.
 */
bstring bfromcstrrangealloc (int minl, int maxl, const char* str) {
bstring b;
int i;
size_t j;

	/* Bad parameters? */
	if (str == NULL) return NULL;
	if (maxl < minl || minl < 0) return NULL;

	/* Adjust lengths */
	j = (strlen) (str);
	if ((size_t) minl < (j+1)) minl = (int) (j+1);
	if (maxl < minl) maxl = minl;
	i = maxl;

	b = (bstring) bstr__alloc (sizeof (struct tagbstring));
	if (b == NULL) return NULL;
	b->slen = (int) j;

	while (NULL == (b->data = (unsigned char *) bstr__alloc (b->mlen = i))) {
		int k = (i >> 1) + (minl >> 1);
		if (i == k || i < minl) {
			bstr__free (b);
			return NULL;
		}
		i = k;
	}

	bstr__memcpy (b->data, str, j+1);
	return b;
}

/*  bstring bfromcstralloc (int mlen, const char * str)
 *
 *  Create a bstring which contains the contents of the '\0' terminated
 *  char* buffer str.  The memory buffer backing the string is at least
 *  mlen characters in length.
 */
bstring bfromcstralloc (int mlen, const char * str) {
	return bfromcstrrangealloc (mlen, mlen, str);
}

/*  bstring blk2bstr (const void * blk, int len)
 *
 *  Create a bstring which contains the content of the block blk of length
 *  len.
 */
bstring blk2bstr (const void * blk, int len) {
bstring b;
int i;

	if (blk == NULL || len < 0) return NULL;
	b = (bstring) bstr__alloc (sizeof (struct tagbstring));
	if (b == NULL) return NULL;
	b->slen = len;

	i = len + (2 - (len != 0));
	i = snapUpSize (i);

	b->mlen = i;

	b->data = (unsigned char *) bstr__alloc ((size_t) b->mlen);
	if (b->data == NULL) {
		bstr__free (b);
		return NULL;
	}

	if (len > 0) bstr__memcpy (b->data, blk, (size_t) len);
	b->data[len] = (unsigned char) '\0';

	return b;
}

/*  char * bstr2cstr (const_bstring s, char z)
 *
 *  Create a '\0' terminated char * buffer which is equal to the contents of
 *  the bstring s, except that any contained '\0' characters are converted
 *  to the character in z. This returned value should be freed with a
 *  bcstrfree () call, by the calling application.
 */
char * bstr2cstr (const_bstring b, char z) {
int i, l;
char * r;

	if (b == NULL || b->slen < 0 || b->data == NULL) return NULL;
	l = b->slen;
	r = (char *) bstr__alloc ((size_t) (l + 1));
	if (r == NULL) return r;

	for (i=0; i < l; i ++) {
		r[i] = (char) ((b->data[i] == '\0') ? z : (char) (b->data[i]));
	}

	r[l] = (unsigned char) '\0';

	return r;
}

/*  int bcstrfree (char * s)
 *
 *  Frees a C-string generated by bstr2cstr ().  This is normally unnecessary
 *  since it just wraps a call to bstr__free (), however, if bstr__alloc ()
 *  and bstr__free () have been redefined as a macros within the bstrlib
 *  module (via defining them in memdbg.h after defining
 *  BSTRLIB_MEMORY_DEBUG) with some difference in behaviour from the std
 *  library functions, then this allows a correct way of freeing the memory
 *  that allows higher level code to be independent from these macro
 *  redefinitions.
 */
int bcstrfree (char * s) {
	if (s) {
		bstr__free (s);
		return BSTR_OK;
	}
	return BSTR_ERR;
}

/*  int bconcat (bstring b0, const_bstring b1)
 *
 *  Concatenate the bstring b1 to the bstring b0.
 */
int bconcat (bstring b0, const_bstring b1) {
int len, d;
bstring aux = (bstring) b1;

	if (b0 == NULL || b1 == NULL || b0->data == NULL || b1->data == NULL)
		return BSTR_ERR;

	d = b0->slen;
	len = b1->slen;
	if ((d | (b0->mlen - d) | len | (d + len)) < 0) return BSTR_ERR;

	if (b0->mlen <= d + len + 1) {
		ptrdiff_t pd = b1->data - b0->data;
		if (0 <= pd && pd < b0->mlen) {
			if (NULL == (aux = bstrcpy (b1))) return BSTR_ERR;
		}
		if (balloc (b0, d + len + 1) != BSTR_OK) {
			if (aux != b1) bdestroy (aux);
			return BSTR_ERR;
		}
	}

	bBlockCopy (&b0->data[d], &aux->data[0], (size_t) len);
	b0->data[d + len] = (unsigned char) '\0';
	b0->slen = d + len;
	if (aux != b1) bdestroy (aux);
	return BSTR_OK;
}

/*  int bconchar (bstring b, char c)
 *
 *  Concatenate the single character c to the bstring b.
 */
int bconchar (bstring b, char c) {
int d;

	if (b == NULL) return BSTR_ERR;
	d = b->slen;
	if ((d | (b->mlen - d)) < 0 || balloc (b, d + 2) != BSTR_OK)
		return BSTR_ERR;
	b->data[d] = (unsigned char) c;
	b->data[d + 1] = (unsigned char) '\0';
	b->slen++;
	return BSTR_OK;
}

/*  int bcatcstr (bstring b, const char * s)
 *
 *  Concatenate a char * string to a bstring.
 */
int bcatcstr (bstring b, const char * s) {
char * d;
int i, l;

	if (b == NULL || b->data == NULL || b->slen < 0 || b->mlen < b->slen
	 || b->mlen <= 0 || s == NULL) return BSTR_ERR;

	/* Optimistically concatenate directly */
	l = b->mlen - b->slen;
	d = (char *) &b->data[b->slen];
	for (i=0; i < l; i++) {
		if ((*d++ = *s++) == '\0') {
			b->slen += i;
			return BSTR_OK;
		}
	}
	b->slen += i;

	/* Need to explicitely resize and concatenate tail */
	return bcatblk (b, (const void *) s, (int) strlen (s));
}

/*  int bcatblk (bstring b, const void * s, int len)
 *
 *  Concatenate a fixed length buffer to a bstring.
 */
int bcatblk (bstring b, const void * s, int len) {
int nl;

	if (b == NULL || b->data == NULL || b->slen < 0 || b->mlen < b->slen
	 || b->mlen <= 0 || s == NULL || len < 0) return BSTR_ERR;

	if (0 > (nl = b->slen + len)) return BSTR_ERR; /* Overflow? */
	if (b->mlen <= nl && 0 > balloc (b, nl + 1)) return BSTR_ERR;

	bBlockCopy (&b->data[b->slen], s, (size_t) len);
	b->slen = nl;
	b->data[nl] = (unsigned char) '\0';
	return BSTR_OK;
}

/*  bstring bstrcpy (const_bstring b)
 *
 *  Create a copy of the bstring b.
 */
bstring bstrcpy (const_bstring b) {
bstring b0;
int i,j;

	/* Attempted to copy an invalid string? */
	if (b == NULL || b->slen < 0 || b->data == NULL) return NULL;

	b0 = (bstring) bstr__alloc (sizeof (struct tagbstring));
	if (b0 == NULL) {
		/* Unable to allocate memory for string header */
		return NULL;
	}

	i = b->slen;
	j = snapUpSize (i + 1);

	b0->data = (unsigned char *) bstr__alloc (j);
	if (b0->data == NULL) {
		j = i + 1;
		b0->data = (unsigned char *) bstr__alloc (j);
		if (b0->data == NULL) {
			/* Unable to allocate memory for string data */
			bstr__free (b0);
			return NULL;
		}
	}

	b0->mlen = j;
	b0->slen = i;

	if (i) bstr__memcpy ((char *) b0->data, (char *) b->data, i);
	b0->data[b0->slen] = (unsigned char) '\0';

	return b0;
}

/*  int bassign (bstring a, const_bstring b)
 *
 *  Overwrite the string a with the contents of string b.
 */
int bassign (bstring a, const_bstring b) {
	if (b == NULL || b->data == NULL || b->slen < 0)
		return BSTR_ERR;
	if (b->slen != 0) {
		if (balloc (a, b->slen) != BSTR_OK) return BSTR_ERR;
		bstr__memmove (a->data, b->data, b->slen);
	} else {
		if (a == NULL || a->data == NULL || a->mlen < a->slen ||
		    a->slen < 0 || a->mlen == 0)
			return BSTR_ERR;
	}
	a->data[b->slen] = (unsigned char) '\0';
	a->slen = b->slen;
	return BSTR_OK;
}

/*  int bassignmidstr (bstring a, const_bstring b, int left, int len)
 *
 *  Overwrite the string a with the middle of contents of string b
 *  starting from position left and running for a length len.  left and
 *  len are clamped to the ends of b as with the function bmidstr.
 */
int bassignmidstr (bstring a, const_bstring b, int left, int len) {
	if (b == NULL || b->data == NULL || b->slen < 0)
		return BSTR_ERR;

	if (left < 0) {
		len += left;
		left = 0;
	}

	if (len > b->slen - left) len = b->slen - left;

	if (a == NULL || a->data == NULL || a->mlen < a->slen ||
	    a->slen < 0 || a->mlen == 0)
		return BSTR_ERR;

	if (len > 0) {
		if (balloc (a, len) != BSTR_OK) return BSTR_ERR;
		bstr__memmove (a->data, b->data + left, len);
		a->slen = len;
	} else {
		a->slen = 0;
	}
	a->data[a->slen] = (unsigned char) '\0';
	return BSTR_OK;
}

/*  int bassigncstr (bstring a, const char * str)
 *
 *  Overwrite the string a with the contents of char * string str.  Note that
 *  the bstring a must be a well defined and writable bstring.  If an error
 *  occurs BSTR_ERR is returned however a may be partially overwritten.
 */
int bassigncstr (bstring a, const char * str) {
int i;
size_t len;
	if (a == NULL || a->data == NULL || a->mlen < a->slen ||
	    a->slen < 0 || a->mlen == 0 || NULL == str)
		return BSTR_ERR;

	for (i=0; i < a->mlen; i++) {
		if ('\0' == (a->data[i] = str[i])) {
			a->slen = i;
			return BSTR_OK;
		}
	}

	a->slen = i;
	len = strlen (str + i);
	if (len + 1 > (size_t) INT_MAX - i ||
	    0 > balloc (a, (int) (i + len + 1))) return BSTR_ERR;
	bBlockCopy (a->data + i, str + i, (size_t) len + 1);
	a->slen += (int) len;
	return BSTR_OK;
}

/*  int bassignblk (bstring a, const void * s, int len)
 *
 *  Overwrite the string a with the contents of the block (s, len).  Note that
 *  the bstring a must be a well defined and writable bstring.  If an error
 *  occurs BSTR_ERR is returned and a is not overwritten.
 */
int bassignblk (bstring a, const void * s, int len) {
	if (a == NULL || a->data == NULL || a->mlen < a->slen ||
	    a->slen < 0 || a->mlen == 0 || NULL == s || len < 0 || len >= INT_MAX)
		return BSTR_ERR;
	if (len + 1 > a->mlen && 0 > balloc (a, len + 1)) return BSTR_ERR;
	bBlockCopy (a->data, s, (size_t) len);
	a->data[len] = (unsigned char) '\0';
	a->slen = len;
	return BSTR_OK;
}

/*  int btrunc (bstring b, int n)
 *
 *  Truncate the bstring to at most n characters.
 */
int btrunc (bstring b, int n) {
	if (n < 0 || b == NULL || b->data == NULL || b->mlen < b->slen ||
	    b->slen < 0 || b->mlen <= 0) return BSTR_ERR;
	if (b->slen > n) {
		b->slen = n;
		b->data[n] = (unsigned char) '\0';
	}
	return BSTR_OK;
}

#define   upcase(c) (toupper ((unsigned char) c))
#define downcase(c) (tolower ((unsigned char) c))
#define   wspace(c) (isspace ((unsigned char) c))

/*  int btoupper (bstring b)
 *
 *  Convert contents of bstring to upper case.
 */
int btoupper (bstring b) {
int i, len;
	if (b == NULL || b->data == NULL || b->mlen < b->slen ||
	    b->slen < 0 || b->mlen <= 0) return BSTR_ERR;
	for (i=0, len = b->slen; i < len; i++) {
		b->data[i] = (unsigned char) upcase (b->data[i]);
	}
	return BSTR_OK;
}

/*  int btolower (bstring b)
 *
 *  Convert contents of bstring to lower case.
 */
int btolower (bstring b) {
int i, len;
	if (b == NULL || b->data == NULL || b->mlen < b->slen ||
	    b->slen < 0 || b->mlen <= 0) return BSTR_ERR;
	for (i=0, len = b->slen; i < len; i++) {
		b->data[i] = (unsigned char) downcase (b->data[i]);
	}
	return BSTR_OK;
}

/*  int bstricmp (const_bstring b0, const_bstring b1)
 *
 *  Compare two strings without differentiating between case.  The return
 *  value is the difference of the values of the characters where the two
 *  strings first differ after lower case transformation, otherwise 0 is
 *  returned indicating that the strings are equal.  If the lengths are
 *  different, then a difference from 0 is given, but if the first extra
 *  character is '\0', then it is taken to be the value UCHAR_MAX+1.
 */
int bstricmp (const_bstring b0, const_bstring b1) {
int i, v, n;

	if (bdata (b0) == NULL || b0->slen < 0 ||
	    bdata (b1) == NULL || b1->slen < 0) return SHRT_MIN;
	if ((n = b0->slen) > b1->slen) n = b1->slen;
	else if (b0->slen == b1->slen && b0->data == b1->data) return BSTR_OK;

	for (i = 0; i < n; i ++) {
		v  = (char) downcase (b0->data[i])
		   - (char) downcase (b1->data[i]);
		if (0 != v) return v;
	}

	if (b0->slen > n) {
		v = (char) downcase (b0->data[n]);
		if (v) return v;
		return UCHAR_MAX + 1;
	}
	if (b1->slen > n) {
		v = - (char) downcase (b1->data[n]);
		if (v) return v;
		return - (int) (UCHAR_MAX + 1);
	}
	return BSTR_OK;
}

/*  int bstrnicmp (const_bstring b0, const_bstring b1, int n)
 *
 *  Compare two strings without differentiating between case for at most n
 *  characters.  If the position where the two strings first differ is
 *  before the nth position, the return value is the difference of the values
 *  of the characters, otherwise 0 is returned.  If the lengths are different
 *  and less than n characters, then a difference from 0 is given, but if the
 *  first extra character is '\0', then it is taken to be the value
 *  UCHAR_MAX+1.
 */
int bstrnicmp (const_bstring b0, const_bstring b1, int n) {
int i, v, m;

	if (bdata (b0) == NULL || b0->slen < 0 ||
	    bdata (b1) == NULL || b1->slen < 0 || n < 0) return SHRT_MIN;
	m = n;
	if (m > b0->slen) m = b0->slen;
	if (m > b1->slen) m = b1->slen;

	if (b0->data != b1->data) {
		for (i = 0; i < m; i ++) {
			v  = (char) downcase (b0->data[i]);
			v -= (char) downcase (b1->data[i]);
			if (v != 0) return b0->data[i] - b1->data[i];
		}
	}

	if (n == m || b0->slen == b1->slen) return BSTR_OK;

	if (b0->slen > m) {
		v = (char) downcase (b0->data[m]);
		if (v) return v;
		return UCHAR_MAX + 1;
	}

	v = - (char) downcase (b1->data[m]);
	if (v) return v;
	return - (int) (UCHAR_MAX + 1);
}

/*  int biseqcaselessblk (const_bstring b, const void * blk, int len)
 *
 *  Compare content of b and the array of bytes in blk for length len for
 *  equality without differentiating between character case.  If the content
 *  differs other than in case, 0 is returned, if, ignoring case, the content
 *  is the same, 1 is returned, if there is an error, -1 is returned.  If the
 *  length of the strings are different, this function is O(1).  '\0'
 *  characters are not treated in any special way.
 */
int biseqcaselessblk (const_bstring b, const void * blk, int len) {
int i;

	if (bdata (b) == NULL || b->slen < 0 ||
	    blk == NULL || len < 0) return BSTR_ERR;
	if (b->slen != len) return 0;
	if (len == 0 || b->data == blk) return 1;
	for (i=0; i < len; i++) {
		if (b->data[i] != ((unsigned char*)blk)[i]) {
			unsigned char c = (unsigned char) downcase (b->data[i]);
			if (c != (unsigned char) downcase (((unsigned char*)blk)[i]))
				return 0;
		}
	}
	return 1;
}


/*  int biseqcaseless (const_bstring b0, const_bstring b1)
 *
 *  Compare two strings for equality without differentiating between case.
 *  If the strings differ other than in case, 0 is returned, if the strings
 *  are the same, 1 is returned, if there is an error, -1 is returned.  If
 *  the length of the strings are different, this function is O(1).  '\0'
 *  termination characters are not treated in any special way.
 */
int biseqcaseless (const_bstring b0, const_bstring b1) {
	if (NULL == b1) return BSTR_ERR;
	return biseqcaselessblk (b0, b1->data, b1->slen);
}

/*  int bisstemeqcaselessblk (const_bstring b0, const void * blk, int len)
 *
 *  Compare beginning of string b0 with a block of memory of length len
 *  without differentiating between case for equality.  If the beginning of b0
 *  differs from the memory block other than in case (or if b0 is too short),
 *  0 is returned, if the strings are the same, 1 is returned, if there is an
 *  error, -1 is returned.  '\0' characters are not treated in any special
 *  way.
 */
int bisstemeqcaselessblk (const_bstring b0, const void * blk, int len) {
int i;

	if (bdata (b0) == NULL || b0->slen < 0 || NULL == blk || len < 0)
		return BSTR_ERR;
	if (b0->slen < len) return BSTR_OK;
	if (b0->data == (const unsigned char *) blk || len == 0) return 1;

	for (i = 0; i < len; i ++) {
		if (b0->data[i] != ((const unsigned char *) blk)[i]) {
			if (downcase (b0->data[i]) !=
			    downcase (((const unsigned char *) blk)[i])) return 0;
		}
	}
	return 1;
}

/*
 * int bltrimws (bstring b)
 *
 * Delete whitespace contiguous from the left end of the string.
 */
int bltrimws (bstring b) {
int i, len;

	if (b == NULL || b->data == NULL || b->mlen < b->slen ||
	    b->slen < 0 || b->mlen <= 0) return BSTR_ERR;

	for (len = b->slen, i = 0; i < len; i++) {
		if (!wspace (b->data[i])) {
			return bdelete (b, 0, i);
		}
	}

	b->data[0] = (unsigned char) '\0';
	b->slen = 0;
	return BSTR_OK;
}

/*
 * int brtrimws (bstring b)
 *
 * Delete whitespace contiguous from the right end of the string.
 */
int brtrimws (bstring b) {
int i;

	if (b == NULL || b->data == NULL || b->mlen < b->slen ||
	    b->slen < 0 || b->mlen <= 0) return BSTR_ERR;

	for (i = b->slen - 1; i >= 0; i--) {
		if (!wspace (b->data[i])) {
			if (b->mlen > i) b->data[i+1] = (unsigned char) '\0';
			b->slen = i + 1;
			return BSTR_OK;
		}
	}

	b->data[0] = (unsigned char) '\0';
	b->slen = 0;
	return BSTR_OK;
}

/*
 * int btrimws (bstring b)
 *
 * Delete whitespace contiguous from both ends of the string.
 */
int btrimws (bstring b) {
int i, j;

	if (b == NULL || b->data == NULL || b->mlen < b->slen ||
	    b->slen < 0 || b->mlen <= 0) return BSTR_ERR;

	for (i = b->slen - 1; i >= 0; i--) {
		if (!wspace (b->data[i])) {
			if (b->mlen > i) b->data[i+1] = (unsigned char) '\0';
			b->slen = i + 1;
			for (j = 0; wspace (b->data[j]); j++) {}
			return bdelete (b, 0, j);
		}
	}

	b->data[0] = (unsigned char) '\0';
	b->slen = 0;
	return BSTR_OK;
}

/*  int biseqblk (const_bstring b, const void * blk, int len)
 *
 *  Compare the string b with the character block blk of length len.  If the
 *  content differs, 0 is returned, if the content is the same, 1 is returned,
 *  if there is an error, -1 is returned.  If the length of the strings are
 *  different, this function is O(1).  '\0' characters are not treated in any
 *  special way.
 */
int biseqblk (const_bstring b, const void * blk, int len) {
	if (len < 0 || b == NULL || blk == NULL || b->data == NULL || b->slen < 0)
		return BSTR_ERR;
	if (b->slen != len) return 0;
	if (len == 0 || b->data == blk) return 1;
	return !bstr__memcmp (b->data, blk, len);
}

/*  int biseq (const_bstring b0, const_bstring b1)
 *
 *  Compare the string b0 and b1.  If the strings differ, 0 is returned, if
 *  the strings are the same, 1 is returned, if there is an error, -1 is
 *  returned.  If the length of the strings are different, this function is
 *  O(1).  '\0' termination characters are not treated in any special way.
 */
int biseq (const_bstring b0, const_bstring b1) {
	if (b0 == NULL || b1 == NULL || b0->data == NULL || b1->data == NULL ||
		b0->slen < 0 || b1->slen < 0) return BSTR_ERR;
	if (b0->slen != b1->slen) return BSTR_OK;
	if (b0->data == b1->data || b0->slen == 0) return 1;
	return !bstr__memcmp (b0->data, b1->data, b0->slen);
}

/*  int bisstemeqblk (const_bstring b0, const void * blk, int len)
 *
 *  Compare beginning of string b0 with a block of memory of length len for
 *  equality.  If the beginning of b0 differs from the memory block (or if b0
 *  is too short), 0 is returned, if the strings are the same, 1 is returned,
 *  if there is an error, -1 is returned.  '\0' characters are not treated in
 *  any special way.
 */
int bisstemeqblk (const_bstring b0, const void * blk, int len) {
int i;

	if (bdata (b0) == NULL || b0->slen < 0 || NULL == blk || len < 0)
		return BSTR_ERR;
	if (b0->slen < len) return BSTR_OK;
	if (b0->data == (const unsigned char *) blk || len == 0) return 1;

	for (i = 0; i < len; i ++) {
		if (b0->data[i] != ((const unsigned char *) blk)[i]) return BSTR_OK;
	}
	return 1;
}

/*  int biseqcstr (const_bstring b, const char *s)
 *
 *  Compare the bstring b and char * string s.  The C string s must be '\0'
 *  terminated at exactly the length of the bstring b, and the contents
 *  between the two must be identical with the bstring b with no '\0'
 *  characters for the two contents to be considered equal.  This is
 *  equivalent to the condition that their current contents will be always be
 *  equal when comparing them in the same format after converting one or the
 *  other.  If the strings are equal 1 is returned, if they are unequal 0 is
 *  returned and if there is a detectable error BSTR_ERR is returned.
 */
int biseqcstr (const_bstring b, const char * s) {
int i;
	if (b == NULL || s == NULL || b->data == NULL || b->slen < 0)
		return BSTR_ERR;
	for (i=0; i < b->slen; i++) {
		if (s[i] == '\0' || b->data[i] != (unsigned char) s[i])
			return BSTR_OK;
	}
	return s[i] == '\0';
}

/*  int biseqcstrcaseless (const_bstring b, const char *s)
 *
 *  Compare the bstring b and char * string s.  The C string s must be '\0'
 *  terminated at exactly the length of the bstring b, and the contents
 *  between the two must be identical except for case with the bstring b with
 *  no '\0' characters for the two contents to be considered equal.  This is
 *  equivalent to the condition that their current contents will be always be
 *  equal ignoring case when comparing them in the same format after
 *  converting one or the other.  If the strings are equal, except for case,
 *  1 is returned, if they are unequal regardless of case 0 is returned and
 *  if there is a detectable error BSTR_ERR is returned.
 */
int biseqcstrcaseless (const_bstring b, const char * s) {
int i;
	if (b == NULL || s == NULL || b->data == NULL || b->slen < 0)
		return BSTR_ERR;
	for (i=0; i < b->slen; i++) {
		if (s[i] == '\0' ||
		    (b->data[i] != (unsigned char) s[i] &&
		     downcase (b->data[i]) != (unsigned char) downcase (s[i])))
			return BSTR_OK;
	}
	return s[i] == '\0';
}

/*  int bstrcmp (const_bstring b0, const_bstring b1)
 *
 *  Compare the string b0 and b1.  If there is an error, SHRT_MIN is returned,
 *  otherwise a value less than or greater than zero, indicating that the
 *  string pointed to by b0 is lexicographically less than or greater than
 *  the string pointed to by b1 is returned.  If the the string lengths are
 *  unequal but the characters up until the length of the shorter are equal
 *  then a value less than, or greater than zero, indicating that the string
 *  pointed to by b0 is shorter or longer than the string pointed to by b1 is
 *  returned.  0 is returned if and only if the two strings are the same.  If
 *  the length of the strings are different, this function is O(n).  Like its
 *  standard C library counter part strcmp, the comparison does not proceed
 *  past any '\0' termination characters encountered.
 */
int bstrcmp (const_bstring b0, const_bstring b1) {
int i, v, n;

	if (b0 == NULL || b1 == NULL || b0->data == NULL || b1->data == NULL ||
		b0->slen < 0 || b1->slen < 0) return SHRT_MIN;
	n = b0->slen; if (n > b1->slen) n = b1->slen;
	if (b0->slen == b1->slen && (b0->data == b1->data || b0->slen == 0))
		return BSTR_OK;

	for (i = 0; i < n; i ++) {
		v = ((char) b0->data[i]) - ((char) b1->data[i]);
		if (v != 0) return v;
		if (b0->data[i] == (unsigned char) '\0') return BSTR_OK;
	}

	if (b0->slen > n) return 1;
	if (b1->slen > n) return -1;
	return BSTR_OK;
}

/*  int bstrncmp (const_bstring b0, const_bstring b1, int n)
 *
 *  Compare the string b0 and b1 for at most n characters.  If there is an
 *  error, SHRT_MIN is returned, otherwise a value is returned as if b0 and
 *  b1 were first truncated to at most n characters then bstrcmp was called
 *  with these new strings are paremeters.  If the length of the strings are
 *  different, this function is O(n).  Like its standard C library counter
 *  part strcmp, the comparison does not proceed past any '\0' termination
 *  characters encountered.
 */
int bstrncmp (const_bstring b0, const_bstring b1, int n) {
int i, v, m;

	if (b0 == NULL || b1 == NULL || b0->data == NULL || b1->data == NULL ||
		b0->slen < 0 || b1->slen < 0) return SHRT_MIN;
	m = n;
	if (m > b0->slen) m = b0->slen;
	if (m > b1->slen) m = b1->slen;

	if (b0->data != b1->data) {
		for (i = 0; i < m; i ++) {
			v = ((char) b0->data[i]) - ((char) b1->data[i]);
			if (v != 0) return v;
			if (b0->data[i] == (unsigned char) '\0') return BSTR_OK;
		}
	}

	if (n == m || b0->slen == b1->slen) return BSTR_OK;

	if (b0->slen > m) return 1;
	return -1;
}

/*  bstring bmidstr (const_bstring b, int left, int len)
 *
 *  Create a bstring which is the substring of b starting from position left
 *  and running for a length len (clamped by the end of the bstring b.)  If
 *  b is detectably invalid, then NULL is returned.  The section described
 *  by (left, len) is clamped to the boundaries of b.
 */
bstring bmidstr (const_bstring b, int left, int len) {

	if (b == NULL || b->slen < 0 || b->data == NULL) return NULL;

	if (left < 0) {
		len += left;
		left = 0;
	}

	if (len > b->slen - left) len = b->slen - left;

	if (len <= 0) return bfromcstr ("");
	return blk2bstr (b->data + left, len);
}

/*  int bdelete (bstring b, int pos, int len)
 *
 *  Removes characters from pos to pos+len-1 inclusive and shifts the tail of
 *  the bstring starting from pos+len to pos.  len must be positive for this
 *  call to have any effect.  The section of the string described by (pos,
 *  len) is clamped to boundaries of the bstring b.
 */
int bdelete (bstring b, int pos, int len) {
	/* Clamp to left side of bstring */
	if (pos < 0) {
		len += pos;
		pos = 0;
	}

	if (len < 0 || b == NULL || b->data == NULL || b->slen < 0 ||
	    b->mlen < b->slen || b->mlen <= 0)
		return BSTR_ERR;
	if (len > 0 && pos < b->slen) {
		if (pos + len >= b->slen) {
			b->slen = pos;
		} else {
			bBlockCopy ((char *) (b->data + pos),
			            (char *) (b->data + pos + len),
			            b->slen - (pos+len));
			b->slen -= len;
		}
		b->data[b->slen] = (unsigned char) '\0';
	}
	return BSTR_OK;
}

/*  int bdestroy (bstring b)
 *
 *  Free up the bstring.  Note that if b is detectably invalid or not writable
 *  then no action is performed and BSTR_ERR is returned.  Like a freed memory
 *  allocation, dereferences, writes or any other action on b after it has
 *  been bdestroyed is undefined.
 */
int bdestroy (bstring b) {
	if (b == NULL || b->slen < 0 || b->mlen <= 0 || b->mlen < b->slen ||
	    b->data == NULL)
		return BSTR_ERR;

	bstr__free (b->data);

	/* In case there is any stale usage, there is one more chance to
	   notice this error. */

	b->slen = -1;
	b->mlen = -__LINE__;
	b->data = NULL;

	bstr__free (b);
	return BSTR_OK;
}

/*  int binstr (const_bstring b1, int pos, const_bstring b2)
 *
 *  Search for the bstring b2 in b1 starting from position pos, and searching
 *  forward.  If it is found then return with the first position where it is
 *  found, otherwise return BSTR_ERR.  Note that this is just a brute force
 *  string searcher that does not attempt clever things like the Boyer-Moore
 *  search algorithm.  Because of this there are many degenerate cases where
 *  this can take much longer than it needs to.
 */
int binstr (const_bstring b1, int pos, const_bstring b2) {
int j, ii, ll, lf;
unsigned char * d0;
unsigned char c0;
unsigned char * d1;
unsigned char c1;
int i;

	if (b1 == NULL || b1->data == NULL || b1->slen < 0 ||
	    b2 == NULL || b2->data == NULL || b2->slen < 0) return BSTR_ERR;
	if (b1->slen == pos) return (b2->slen == 0)?pos:BSTR_ERR;
	if (b1->slen < pos || pos < 0) return BSTR_ERR;
	if (b2->slen == 0) return pos;

	/* No space to find such a string? */
	if ((lf = b1->slen - b2->slen + 1) <= pos) return BSTR_ERR;

	/* An obvious alias case */
	if (b1->data == b2->data && pos == 0) return 0;

	i = pos;

	d0 = b2->data;
	d1 = b1->data;
	ll = b2->slen;

	/* Peel off the b2->slen == 1 case */
	c0 = d0[0];
	if (1 == ll) {
		for (;i < lf; i++) if (c0 == d1[i]) return i;
		return BSTR_ERR;
	}

	c1 = c0;
	j = 0;
	lf = b1->slen - 1;

	ii = -1;
	if (i < lf) do {
		/* Unrolled current character test */
		if (c1 != d1[i]) {
			if (c1 != d1[1+i]) {
				i += 2;
				continue;
			}
			i++;
		}

		/* Take note if this is the start of a potential match */
		if (0 == j) ii = i;

		/* Shift the test character down by one */
		j++;
		i++;

		/* If this isn't past the last character continue */
		if (j < ll) {
			c1 = d0[j];
			continue;
		}

		N0:;

		/* If no characters mismatched, then we matched */
		if (i == ii+j) return ii;

		/* Shift back to the beginning */
		i -= j;
		j  = 0;
		c1 = c0;
	} while (i < lf);

	/* Deal with last case if unrolling caused a misalignment */
	if (i == lf && ll == j+1 && c1 == d1[i]) goto N0;

	return BSTR_ERR;
}

/*  int binstrr (const_bstring b1, int pos, const_bstring b2)
 *
 *  Search for the bstring b2 in b1 starting from position pos, and searching
 *  backward.  If it is found then return with the first position where it is
 *  found, otherwise return BSTR_ERR.  Note that this is just a brute force
 *  string searcher that does not attempt clever things like the Boyer-Moore
 *  search algorithm.  Because of this there are many degenerate cases where
 *  this can take much longer than it needs to.
 */
int binstrr (const_bstring b1, int pos, const_bstring b2) {
int j, i, l;
unsigned char * d0, * d1;

	if (b1 == NULL || b1->data == NULL || b1->slen < 0 ||
	    b2 == NULL || b2->data == NULL || b2->slen < 0) return BSTR_ERR;
	if (b1->slen == pos && b2->slen == 0) return pos;
	if (b1->slen < pos || pos < 0) return BSTR_ERR;
	if (b2->slen == 0) return pos;

	/* Obvious alias case */
	if (b1->data == b2->data && pos == 0 && b2->slen <= b1->slen) return 0;

	i = pos;
	if ((l = b1->slen - b2->slen) < 0) return BSTR_ERR;

	/* If no space to find such a string then snap back */
	if (l + 1 <= i) i = l;
	j = 0;

	d0 = b2->data;
	d1 = b1->data;
	l  = b2->slen;

	for (;;) {
		if (d0[j] == d1[i + j]) {
			j ++;
			if (j >= l) return i;
		} else {
			i --;
			if (i < 0) break;
			j=0;
		}
	}

	return BSTR_ERR;
}

/*  int binstrcaseless (const_bstring b1, int pos, const_bstring b2)
 *
 *  Search for the bstring b2 in b1 starting from position pos, and searching
 *  forward but without regard to case.  If it is found then return with the
 *  first position where it is found, otherwise return BSTR_ERR.  Note that
 *  this is just a brute force string searcher that does not attempt clever
 *  things like the Boyer-Moore search algorithm.  Because of this there are
 *  many degenerate cases where this can take much longer than it needs to.
 */
int binstrcaseless (const_bstring b1, int pos, const_bstring b2) {
int j, i, l, ll;
unsigned char * d0, * d1;

	if (b1 == NULL || b1->data == NULL || b1->slen < 0 ||
	    b2 == NULL || b2->data == NULL || b2->slen < 0) return BSTR_ERR;
	if (b1->slen == pos) return (b2->slen == 0)?pos:BSTR_ERR;
	if (b1->slen < pos || pos < 0) return BSTR_ERR;
	if (b2->slen == 0) return pos;

	l = b1->slen - b2->slen + 1;

	/* No space to find such a string? */
	if (l <= pos) return BSTR_ERR;

	/* An obvious alias case */
	if (b1->data == b2->data && pos == 0) return BSTR_OK;

	i = pos;
	j = 0;

	d0 = b2->data;
	d1 = b1->data;
	ll = b2->slen;

	for (;;) {
		if (d0[j] == d1[i + j] || downcase (d0[j]) == downcase (d1[i + j])) {
			j ++;
			if (j >= ll) return i;
		} else {
			i ++;
			if (i >= l) break;
			j=0;
		}
	}

	return BSTR_ERR;
}

/*  int binstrrcaseless (const_bstring b1, int pos, const_bstring b2)
 *
 *  Search for the bstring b2 in b1 starting from position pos, and searching
 *  backward but without regard to case.  If it is found then return with the
 *  first position where it is found, otherwise return BSTR_ERR.  Note that
 *  this is just a brute force string searcher that does not attempt clever
 *  things like the Boyer-Moore search algorithm.  Because of this there are
 *  many degenerate cases where this can take much longer than it needs to.
 */
int binstrrcaseless (const_bstring b1, int pos, const_bstring b2) {
int j, i, l;
unsigned char * d0, * d1;

	if (b1 == NULL || b1->data == NULL || b1->slen < 0 ||
	    b2 == NULL || b2->data == NULL || b2->slen < 0) return BSTR_ERR;
	if (b1->slen == pos && b2->slen == 0) return pos;
	if (b1->slen < pos || pos < 0) return BSTR_ERR;
	if (b2->slen == 0) return pos;

	/* Obvious alias case */
	if (b1->data == b2->data && pos == 0 && b2->slen <= b1->slen)
		return BSTR_OK;

	i = pos;
	if ((l = b1->slen - b2->slen) < 0) return BSTR_ERR;

	/* If no space to find such a string then snap back */
	if (l + 1 <= i) i = l;
	j = 0;

	d0 = b2->data;
	d1 = b1->data;
	l  = b2->slen;

	for (;;) {
		if (d0[j] == d1[i + j] || downcase (d0[j]) == downcase (d1[i + j])) {
			j ++;
			if (j >= l) return i;
		} else {
			i --;
			if (i < 0) break;
			j=0;
		}
	}

	return BSTR_ERR;
}


/*  int bstrchrp (const_bstring b, int c, int pos)
 *
 *  Search for the character c in b forwards from the position pos
 *  (inclusive).
 */
int bstrchrp (const_bstring b, int c, int pos) {
unsigned char * p;

	if (b == NULL || b->data == NULL || b->slen <= pos || pos < 0)
		return BSTR_ERR;
	p = (unsigned char *) bstr__memchr ((b->data + pos), (unsigned char) c,
		                                (b->slen - pos));
	if (p) return (int) (p - b->data);
	return BSTR_ERR;
}

/*  int bstrrchrp (const_bstring b, int c, int pos)
 *
 *  Search for the character c in b backwards from the position pos in string
 *  (inclusive).
 */
int bstrrchrp (const_bstring b, int c, int pos) {
int i;

	if (b == NULL || b->data == NULL || b->slen <= pos || pos < 0)
		return BSTR_ERR;
	for (i=pos; i >= 0; i--) {
		if (b->data[i] == (unsigned char) c) return i;
	}
	return BSTR_ERR;
}

#if !defined (BSTRLIB_AGGRESSIVE_MEMORY_FOR_SPEED_TRADEOFF)
#define LONG_LOG_BITS_QTY (3)
#define LONG_BITS_QTY (1 << LONG_LOG_BITS_QTY)
#define LONG_TYPE unsigned char

#define CFCLEN ((1 << CHAR_BIT) / LONG_BITS_QTY)
struct charField { LONG_TYPE content[CFCLEN]; };
#define testInCharField(cf,c) ((cf)->content[(c) >> LONG_LOG_BITS_QTY] & \
	                           (((long)1) << ((c) & (LONG_BITS_QTY-1))))
#define setInCharField(cf,idx) { \
	unsigned int c = (unsigned int) (idx); \
	(cf)->content[c >> LONG_LOG_BITS_QTY] |= \
		(LONG_TYPE) (1ul << (c & (LONG_BITS_QTY-1))); \
}

#else

#define CFCLEN (1 << CHAR_BIT)
struct charField { unsigned char content[CFCLEN]; };
#define testInCharField(cf,c) ((cf)->content[(unsigned char) (c)])
#define setInCharField(cf,idx) (cf)->content[(unsigned int) (idx)] = ~0

#endif

/* Convert a bstring to charField */
static int buildCharField (struct charField * cf, const_bstring b) {
int i;
	if (b == NULL || b->data == NULL || b->slen <= 0) return BSTR_ERR;
	memset ((void *) cf->content, 0, sizeof (struct charField));
	for (i=0; i < b->slen; i++) {
		setInCharField (cf, b->data[i]);
	}
	return BSTR_OK;
}

static void invertCharField (struct charField * cf) {
int i;
	for (i=0; i < CFCLEN; i++) cf->content[i] = ~cf->content[i];
}

/* Inner engine for binchr */
static int binchrCF (const unsigned char * data, int len, int pos,
					 const struct charField * cf) {
int i;
	for (i=pos; i < len; i++) {
		unsigned char c = (unsigned char) data[i];
		if (testInCharField (cf, c)) return i;
	}
	return BSTR_ERR;
}

/*  int binchr (const_bstring b0, int pos, const_bstring b1);
 *
 *  Search for the first position in b0 starting from pos or after, in which
 *  one of the characters in b1 is found and return it.  If such a position
 *  does not exist in b0, then BSTR_ERR is returned.
 */
int binchr (const_bstring b0, int pos, const_bstring b1) {
struct charField chrs;
	if (pos < 0 || b0 == NULL || b0->data == NULL ||
	    b0->slen <= pos) return BSTR_ERR;
	if (1 == b1->slen) return bstrchrp (b0, b1->data[0], pos);
	if (0 > buildCharField (&chrs, b1)) return BSTR_ERR;
	return binchrCF (b0->data, b0->slen, pos, &chrs);
}

/* Inner engine for binchrr */
static int binchrrCF (const unsigned char * data, int pos,
                      const struct charField * cf) {
int i;
	for (i=pos; i >= 0; i--) {
		unsigned int c = (unsigned int) data[i];
		if (testInCharField (cf, c)) return i;
	}
	return BSTR_ERR;
}

/*  int binchrr (const_bstring b0, int pos, const_bstring b1);
 *
 *  Search for the last position in b0 no greater than pos, in which one of
 *  the characters in b1 is found and return it.  If such a position does not
 *  exist in b0, then BSTR_ERR is returned.
 */
int binchrr (const_bstring b0, int pos, const_bstring b1) {
struct charField chrs;
	if (pos < 0 || b0 == NULL || b0->data == NULL || b1 == NULL ||
	    b0->slen < pos) return BSTR_ERR;
	if (pos == b0->slen) pos--;
	if (1 == b1->slen) return bstrrchrp (b0, b1->data[0], pos);
	if (0 > buildCharField (&chrs, b1)) return BSTR_ERR;
	return binchrrCF (b0->data, pos, &chrs);
}

/*  int bninchr (const_bstring b0, int pos, const_bstring b1);
 *
 *  Search for the first position in b0 starting from pos or after, in which
 *  none of the characters in b1 is found and return it.  If such a position
 *  does not exist in b0, then BSTR_ERR is returned.
 */
int bninchr (const_bstring b0, int pos, const_bstring b1) {
struct charField chrs;
	if (pos < 0 || b0 == NULL || b0->data == NULL ||
	    b0->slen <= pos) return BSTR_ERR;
	if (buildCharField (&chrs, b1) < 0) return BSTR_ERR;
	invertCharField (&chrs);
	return binchrCF (b0->data, b0->slen, pos, &chrs);
}

/*  int bninchrr (const_bstring b0, int pos, const_bstring b1);
 *
 *  Search for the last position in b0 no greater than pos, in which none of
 *  the characters in b1 is found and return it.  If such a position does not
 *  exist in b0, then BSTR_ERR is returned.
 */
int bninchrr (const_bstring b0, int pos, const_bstring b1) {
struct charField chrs;
	if (pos < 0 || b0 == NULL || b0->data == NULL ||
	    b0->slen < pos) return BSTR_ERR;
	if (pos == b0->slen) pos--;
	if (buildCharField (&chrs, b1) < 0) return BSTR_ERR;
	invertCharField (&chrs);
	return binchrrCF (b0->data, pos, &chrs);
}

/*  int bsetstr (bstring b0, int pos, bstring b1, unsigned char fill)
 *
 *  Overwrite the string b0 starting at position pos with the string b1. If
 *  the position pos is past the end of b0, then the character "fill" is
 *  appended as necessary to make up the gap between the end of b0 and pos.
 *  If b1 is NULL, it behaves as if it were a 0-length string.
 */
int bsetstr (bstring b0, int pos, const_bstring b1, unsigned char fill) {
int d, newlen;
ptrdiff_t pd;
bstring aux = (bstring) b1;

	if (pos < 0 || b0 == NULL || b0->slen < 0 || NULL == b0->data ||
	    b0->mlen < b0->slen || b0->mlen <= 0) return BSTR_ERR;
	if (b1 != NULL && (b1->slen < 0 || b1->data == NULL)) return BSTR_ERR;

	d = pos;

	/* Aliasing case */
	if (NULL != aux) {
		if ((pd = (ptrdiff_t) (b1->data - b0->data)) >= 0 &&
		    pd < (ptrdiff_t) b0->mlen) {
			if (NULL == (aux = bstrcpy (b1))) return BSTR_ERR;
		}
		d += aux->slen;
	}

	/* Increase memory size if necessary */
	if (balloc (b0, d + 1) != BSTR_OK) {
		if (aux != b1) bdestroy (aux);
		return BSTR_ERR;
	}

	newlen = b0->slen;

	/* Fill in "fill" character as necessary */
	if (pos > newlen) {
		bstr__memset (b0->data + b0->slen, (int) fill,
		              (size_t) (pos - b0->slen));
		newlen = pos;
	}

	/* Copy b1 to position pos in b0. */
	if (aux != NULL) {
		bBlockCopy ((char *) (b0->data + pos), (char *) aux->data, aux->slen);
		if (aux != b1) bdestroy (aux);
	}

	/* Indicate the potentially increased size of b0 */
	if (d > newlen) newlen = d;

	b0->slen = newlen;
	b0->data[newlen] = (unsigned char) '\0';

	return BSTR_OK;
}

/*  int binsertblk (bstring b, int pos, const void * blk, int len,
 *                  unsigned char fill)
 *
 *  Inserts the block of characters at blk with length len into b at position
 *  pos.  If the position pos is past the end of b, then the character "fill"
 *  is appended as necessary to make up the gap between the end of b1 and pos.
 *  Unlike bsetstr, binsert does not allow b2 to be NULL.
 */
int binsertblk (bstring b, int pos, const void * blk, int len,
                unsigned char fill) {
int d, l;
unsigned char* aux = (unsigned char*) blk;

	if (b == NULL || blk == NULL || pos < 0 || len < 0 || b->slen < 0 ||
	    b->mlen <= 0 || b->mlen < b->slen) return BSTR_ERR;

	/* Compute the two possible end pointers */
	d = b->slen + len;
	l = pos + len;
	if ((d|l) < 0) return BSTR_ERR; /* Integer wrap around. */

	/* Aliasing case */
	if (((size_t) ((unsigned char*) blk + len)) >= ((size_t) b->data) &&
		((size_t) blk) < ((size_t) (b->data + b->mlen))) {
		if (NULL == (aux = (unsigned char*) bstr__alloc (len)))
			return BSTR_ERR;
		bstr__memcpy (aux, blk, len);
	}

	if (l > d) {
		/* Inserting past the end of the string */
		if (balloc (b, l + 1) != BSTR_OK) {
			if (aux != (unsigned char*) blk) bstr__free (aux);
			return BSTR_ERR;
		}
		bstr__memset (b->data + b->slen, (int) fill,
		              (size_t) (pos - b->slen));
		b->slen = l;
	} else {
		/* Inserting in the middle of the string */
		if (balloc (b, d + 1) != BSTR_OK) {
			if (aux != (unsigned char*) blk) bstr__free (aux);
			return BSTR_ERR;
		}
		bBlockCopy (b->data + l, b->data + pos, d - l);
		b->slen = d;
	}
	bBlockCopy (b->data + pos, aux, len);
	b->data[b->slen] = (unsigned char) '\0';
	if (aux != (unsigned char*) blk) bstr__free (aux);
	return BSTR_OK;
}

/*  int binsert (bstring b1, int pos, const_bstring b2, unsigned char fill)
 *
 *  Inserts the string b2 into b1 at position pos.  If the position pos is
 *  past the end of b1, then the character "fill" is appended as necessary to
 *  make up the gap between the end of b1 and pos.  Unlike bsetstr, binsert
 *  does not allow b2 to be NULL.
 */
int binsert (bstring b1, int pos, const_bstring b2, unsigned char fill) {
	if (NULL == b2 || (b2->mlen > 0 && b2->slen > b2->mlen)) return BSTR_ERR;
	return binsertblk (b1, pos, b2->data, b2->slen, fill);
}

/*  int breplace (bstring b1, int pos, int len, bstring b2,
 *                unsigned char fill)
 *
 *  Replace a section of a string from pos for a length len with the string
 *  b2. fill is used is pos > b1->slen.
 */
int breplace (bstring b1, int pos, int len, const_bstring b2,
              unsigned char fill) {
int pl, ret;
ptrdiff_t pd;
bstring aux = (bstring) b2;

	if (pos < 0 || len < 0) return BSTR_ERR;
	if (pos > INT_MAX - len) return BSTR_ERR; /* Overflow */
	pl = pos + len;
	if (b1 == NULL || b2 == NULL || b1->data == NULL || b2->data == NULL ||
	    b1->slen < 0 || b2->slen < 0 || b1->mlen < b1->slen ||
	    b1->mlen <= 0) return BSTR_ERR;

	/* Straddles the end? */
	if (pl >= b1->slen) {
		if ((ret = bsetstr (b1, pos, b2, fill)) < 0) return ret;
		if (pos + b2->slen < b1->slen) {
			b1->slen = pos + b2->slen;
			b1->data[b1->slen] = (unsigned char) '\0';
		}
		return ret;
	}

	/* Aliasing case */
	if ((pd = (ptrdiff_t) (b2->data - b1->data)) >= 0 &&
	    pd < (ptrdiff_t) b1->slen) {
		if (NULL == (aux = bstrcpy (b2))) return BSTR_ERR;
	}

	if (aux->slen > len) {
		if (balloc (b1, b1->slen + aux->slen - len) != BSTR_OK) {
			if (aux != b2) bdestroy (aux);
			return BSTR_ERR;
		}
	}

	if (aux->slen != len) bstr__memmove (b1->data + pos + aux->slen,
	                                     b1->data + pos + len,
	                                     b1->slen - (pos + len));
	bstr__memcpy (b1->data + pos, aux->data, aux->slen);
	b1->slen += aux->slen - len;
	b1->data[b1->slen] = (unsigned char) '\0';
	if (aux != b2) bdestroy (aux);
	return BSTR_OK;
}

/*
 *  findreplaceengine is used to implement bfindreplace and
 *  bfindreplacecaseless. It works by breaking the three cases of
 *  expansion, reduction and replacement, and solving each of these
 *  in the most efficient way possible.
 */

typedef int (*instr_fnptr) (const_bstring s1, int pos, const_bstring s2);

#define INITIAL_STATIC_FIND_INDEX_COUNT 32

static int findreplaceengine (bstring b, const_bstring find,
                              const_bstring repl, int pos,
                              instr_fnptr instr) {
int i, ret, slen, mlen, delta, acc;
int * d;
int static_d[INITIAL_STATIC_FIND_INDEX_COUNT+1]; /* This +1 is for LINT. */
ptrdiff_t pd;
bstring auxf = (bstring) find;
bstring auxr = (bstring) repl;

	if (b == NULL || b->data == NULL || find == NULL ||
		find->data == NULL || repl == NULL || repl->data == NULL ||
		pos < 0 || find->slen <= 0 || b->mlen <= 0 || b->slen > b->mlen ||
		b->slen < 0 || repl->slen < 0) return BSTR_ERR;
	if (pos > b->slen - find->slen) return BSTR_OK;

	/* Alias with find string */
	pd = (ptrdiff_t) (find->data - b->data);
	if ((ptrdiff_t) (pos - find->slen) < pd && pd < (ptrdiff_t) b->slen) {
		if (NULL == (auxf = bstrcpy (find))) return BSTR_ERR;
	}

	/* Alias with repl string */
	pd = (ptrdiff_t) (repl->data - b->data);
	if ((ptrdiff_t) (pos - repl->slen) < pd && pd < (ptrdiff_t) b->slen) {
		if (NULL == (auxr = bstrcpy (repl))) {
			if (auxf != find) bdestroy (auxf);
			return BSTR_ERR;
		}
	}

	delta = auxf->slen - auxr->slen;

	/* in-place replacement since find and replace strings are of equal
	   length */
	if (delta == 0) {
		while ((pos = instr (b, pos, auxf)) >= 0) {
			bstr__memcpy (b->data + pos, auxr->data, auxr->slen);
			pos += auxf->slen;
		}
		if (auxf != find) bdestroy (auxf);
		if (auxr != repl) bdestroy (auxr);
		return BSTR_OK;
	}

	/* shrinking replacement since auxf->slen > auxr->slen */
	if (delta > 0) {
		acc = 0;

		while ((i = instr (b, pos, auxf)) >= 0) {
			if (acc && i > pos)
				bstr__memmove (b->data + pos - acc, b->data + pos, i - pos);
			if (auxr->slen)
				bstr__memcpy (b->data + i - acc, auxr->data, auxr->slen);
			acc += delta;
			pos = i + auxf->slen;
		}

		if (acc) {
			i = b->slen;
			if (i > pos)
				bstr__memmove (b->data + pos - acc, b->data + pos, i - pos);
			b->slen -= acc;
			b->data[b->slen] = (unsigned char) '\0';
		}

		if (auxf != find) bdestroy (auxf);
		if (auxr != repl) bdestroy (auxr);
		return BSTR_OK;
	}

	/* expanding replacement since find->slen < repl->slen.  Its a lot
	   more complicated.  This works by first finding all the matches and
	   storing them to a growable array, then doing at most one resize of
	   the destination bstring and then performing the direct memory transfers
	   of the string segment pieces to form the final result. The growable
	   array of matches uses a deferred doubling reallocing strategy.  What
	   this means is that it starts as a reasonably fixed sized auto array in
	   the hopes that many if not most cases will never need to grow this
	   array.  But it switches as soon as the bounds of the array will be
	   exceeded.  An extra find result is always appended to this array that
	   corresponds to the end of the destination string, so slen is checked
	   against mlen - 1 rather than mlen before resizing.
	*/

	mlen = INITIAL_STATIC_FIND_INDEX_COUNT;
	d = (int *) static_d; /* Avoid malloc for trivial/initial cases */
	acc = slen = 0;

	while ((pos = instr (b, pos, auxf)) >= 0) {
		if (slen >= mlen - 1) {
			int *t;
			int sl;
			/* Overflow */
			if (mlen > (INT_MAX / sizeof(int *)) / 2) {
				ret = BSTR_ERR;
				goto done;
			}
			mlen += mlen;
			sl = sizeof (int *) * mlen;
			if (static_d == d) d = NULL; /* static_d cannot be realloced */
			if (NULL == (t = (int *) bstr__realloc (d, sl))) {
				ret = BSTR_ERR;
				goto done;
			}
			if (NULL == d) bstr__memcpy (t, static_d, sizeof (static_d));
			d = t;
		}
		d[slen] = pos;
		slen++;
		acc -= delta;
		pos += auxf->slen;
		if (pos < 0 || acc < 0) {
			ret = BSTR_ERR;
			goto done;
		}
	}

	/* slen <= INITIAL_STATIC_INDEX_COUNT-1 or mlen-1 here. */
	d[slen] = b->slen;

	if (BSTR_OK == (ret = balloc (b, b->slen + acc + 1))) {
		b->slen += acc;
		for (i = slen-1; i >= 0; i--) {
			int s, l;
			s = d[i] + auxf->slen;
			l = d[i+1] - s; /* d[slen] may be accessed here. */
			if (l) {
				bstr__memmove (b->data + s + acc, b->data + s, l);
			}
			if (auxr->slen) {
				bstr__memmove (b->data + s + acc - auxr->slen,
				               auxr->data, auxr->slen);
			}
			acc += delta;
		}
		b->data[b->slen] = (unsigned char) '\0';
	}

	done:;
	if (static_d != d) bstr__free (d);
	if (auxf != find) bdestroy (auxf);
	if (auxr != repl) bdestroy (auxr);
	return ret;
}

/*  int bfindreplace (bstring b, const_bstring find, const_bstring repl,
 *                    int pos)
 *
 *  Replace all occurrences of a find string with a replace string after a
 *  given point in a bstring.
 */
int bfindreplace (bstring b, const_bstring find, const_bstring repl,
                  int pos) {
	return findreplaceengine (b, find, repl, pos, binstr);
}

/*  int bfindreplacecaseless (bstring b, const_bstring find,
 *                            const_bstring repl, int pos)
 *
 *  Replace all occurrences of a find string, ignoring case, with a replace
 *  string after a given point in a bstring.
 */
int bfindreplacecaseless (bstring b, const_bstring find, const_bstring repl,
                          int pos) {
	return findreplaceengine (b, find, repl, pos, binstrcaseless);
}

/*  int binsertch (bstring b, int pos, int len, unsigned char fill)
 *
 *  Inserts the character fill repeatedly into b at position pos for a
 *  length len.  If the position pos is past the end of b, then the
 *  character "fill" is appended as necessary to make up the gap between the
 *  end of b and the position pos + len.
 */
int binsertch (bstring b, int pos, int len, unsigned char fill) {
int d, l, i;

	if (pos < 0 || b == NULL || b->slen < 0 || b->mlen < b->slen ||
	    b->mlen <= 0 || len < 0) return BSTR_ERR;

	/* Compute the two possible end pointers */
	d = b->slen + len;
	l = pos + len;
	if ((d|l) < 0) return BSTR_ERR;

	if (l > d) {
		/* Inserting past the end of the string */
		if (balloc (b, l + 1) != BSTR_OK) return BSTR_ERR;
		pos = b->slen;
		b->slen = l;
	} else {
		/* Inserting in the middle of the string */
		if (balloc (b, d + 1) != BSTR_OK) return BSTR_ERR;
		for (i = d - 1; i >= l; i--) {
			b->data[i] = b->data[i - len];
		}
		b->slen = d;
	}

	for (i=pos; i < l; i++) b->data[i] = fill;
	b->data[b->slen] = (unsigned char) '\0';
	return BSTR_OK;
}

/*  int bpattern (bstring b, int len)
 *
 *  Replicate the bstring, b in place, end to end repeatedly until it
 *  surpasses len characters, then chop the result to exactly len characters.
 *  This function operates in-place.  The function will return with BSTR_ERR
 *  if b is NULL or of length 0, otherwise BSTR_OK is returned.
 */
int bpattern (bstring b, int len) {
int i, d;

	d = blength (b);
	if (d <= 0 || len < 0 || balloc (b, len + 1) != BSTR_OK) return BSTR_ERR;
	if (len > 0) {
		if (d == 1) return bsetstr (b, len, NULL, b->data[0]);
		for (i = d; i < len; i++) b->data[i] = b->data[i - d];
	}
	b->data[len] = (unsigned char) '\0';
	b->slen = len;
	return BSTR_OK;
}

#define BS_BUFF_SZ (1024)

/*  int breada (bstring b, bNread readPtr, void * parm)
 *
 *  Use a finite buffer fread-like function readPtr to concatenate to the
 *  bstring b the entire contents of file-like source data in a roughly
 *  efficient way.
 */
int breada (bstring b, bNread readPtr, void * parm) {
int i, l, n;

	if (b == NULL || b->mlen <= 0 || b->slen < 0 || b->mlen < b->slen ||
	    readPtr == NULL) return BSTR_ERR;

	i = b->slen;
	for (n=i+16; ; n += ((n < BS_BUFF_SZ) ? n : BS_BUFF_SZ)) {
		if (BSTR_OK != balloc (b, n + 1)) return BSTR_ERR;
		l = (int) readPtr ((void *) (b->data + i), 1, n - i, parm);
		i += l;
		b->slen = i;
		if (i < n) break;
	}

	b->data[i] = (unsigned char) '\0';
	return BSTR_OK;
}

/*  bstring bread (bNread readPtr, void * parm)
 *
 *  Use a finite buffer fread-like function readPtr to create a bstring
 *  filled with the entire contents of file-like source data in a roughly
 *  efficient way.
 */
bstring bread (bNread readPtr, void * parm) {
bstring buff;

	if (0 > breada (buff = bfromcstr (""), readPtr, parm)) {
		bdestroy (buff);
		return NULL;
	}
	return buff;
}

/*  int bassigngets (bstring b, bNgetc getcPtr, void * parm, char terminator)
 *
 *  Use an fgetc-like single character stream reading function (getcPtr) to
 *  obtain a sequence of characters which are concatenated to the end of the
 *  bstring b.  The stream read is terminated by the passed in terminator
 *  parameter.
 *
 *  If getcPtr returns with a negative number, or the terminator character
 *  (which is appended) is read, then the stream reading is halted and the
 *  function returns with a partial result in b.  If there is an empty partial
 *  result, 1 is returned.  If no characters are read, or there is some other
 *  detectable error, BSTR_ERR is returned.
 */
int bassigngets (bstring b, bNgetc getcPtr, void * parm, char terminator) {
int c, d, e;

	if (b == NULL || b->mlen <= 0 || b->slen < 0 || b->mlen < b->slen ||
	    getcPtr == NULL) return BSTR_ERR;
	d = 0;
	e = b->mlen - 2;

	while ((c = getcPtr (parm)) >= 0) {
		if (d > e) {
			b->slen = d;
			if (balloc (b, d + 2) != BSTR_OK) return BSTR_ERR;
			e = b->mlen - 2;
		}
		b->data[d] = (unsigned char) c;
		d++;
		if (c == terminator) break;
	}

	b->data[d] = (unsigned char) '\0';
	b->slen = d;

	return d == 0 && c < 0;
}

/*  int bgetsa (bstring b, bNgetc getcPtr, void * parm, char terminator)
 *
 *  Use an fgetc-like single character stream reading function (getcPtr) to
 *  obtain a sequence of characters which are concatenated to the end of the
 *  bstring b.  The stream read is terminated by the passed in terminator
 *  parameter.
 *
 *  If getcPtr returns with a negative number, or the terminator character
 *  (which is appended) is read, then the stream reading is halted and the
 *  function returns with a partial result concatentated to b.  If there is
 *  an empty partial result, 1 is returned.  If no characters are read, or
 *  there is some other detectable error, BSTR_ERR is returned.
 */
int bgetsa (bstring b, bNgetc getcPtr, void * parm, char terminator) {
int c, d, e;

	if (b == NULL || b->mlen <= 0 || b->slen < 0 || b->mlen < b->slen ||
	    getcPtr == NULL) return BSTR_ERR;
	d = b->slen;
	e = b->mlen - 2;

	while ((c = getcPtr (parm)) >= 0) {
		if (d > e) {
			b->slen = d;
			if (balloc (b, d + 2) != BSTR_OK) return BSTR_ERR;
			e = b->mlen - 2;
		}
		b->data[d] = (unsigned char) c;
		d++;
		if (c == terminator) break;
	}

	b->data[d] = (unsigned char) '\0';
	b->slen = d;

	return d == 0 && c < 0;
}

/*  bstring bgets (bNgetc getcPtr, void * parm, char terminator)
 *
 *  Use an fgetc-like single character stream reading function (getcPtr) to
 *  obtain a sequence of characters which are concatenated into a bstring.
 *  The stream read is terminated by the passed in terminator function.
 *
 *  If getcPtr returns with a negative number, or the terminator character
 *  (which is appended) is read, then the stream reading is halted and the
 *  result obtained thus far is returned.  If no characters are read, or
 *  there is some other detectable error, NULL is returned.
 */
bstring bgets (bNgetc getcPtr, void * parm, char terminator) {
bstring buff;

	if (0 > bgetsa (buff = bfromcstr (""), getcPtr, parm, terminator) ||
	    0 >= buff->slen) {
		bdestroy (buff);
		buff = NULL;
	}
	return buff;
}

struct bStream {
	bstring buff;		/* Buffer for over-reads */
	void * parm;		/* The stream handle for core stream */
	bNread readFnPtr;	/* fread compatible fnptr for core stream */
	int isEOF;			/* track file's EOF state */
	int maxBuffSz;
};

/*  struct bStream * bsopen (bNread readPtr, void * parm)
 *
 *  Wrap a given open stream (described by a fread compatible function
 *  pointer and stream handle) into an open bStream suitable for the bstring
 *  library streaming functions.
 */
struct bStream * bsopen (bNread readPtr, void * parm) {
struct bStream * s;

	if (readPtr == NULL) return NULL;
	s = (struct bStream *) bstr__alloc (sizeof (struct bStream));
	if (s == NULL) return NULL;
	s->parm = parm;
	s->buff = bfromcstr ("");
	s->readFnPtr = readPtr;
	s->maxBuffSz = BS_BUFF_SZ;
	s->isEOF = 0;
	return s;
}

/*  int bsbufflength (struct bStream * s, int sz)
 *
 *  Set the length of the buffer used by the bStream.  If sz is zero, the
 *  length is not set.  This function returns with the previous length.
 */
int bsbufflength (struct bStream * s, int sz) {
int oldSz;
	if (s == NULL || sz < 0) return BSTR_ERR;
	oldSz = s->maxBuffSz;
	if (sz > 0) s->maxBuffSz = sz;
	return oldSz;
}

int bseof (const struct bStream * s) {
	if (s == NULL || s->readFnPtr == NULL) return BSTR_ERR;
	return s->isEOF && (s->buff->slen == 0);
}

/*  void * bsclose (struct bStream * s)
 *
 *  Close the bStream, and return the handle to the stream that was originally
 *  used to open the given stream.
 */
void * bsclose (struct bStream * s) {
void * parm;
	if (s == NULL) return NULL;
	s->readFnPtr = NULL;
	if (s->buff) bdestroy (s->buff);
	s->buff = NULL;
	parm = s->parm;
	s->parm = NULL;
	s->isEOF = 1;
	bstr__free (s);
	return parm;
}

/*  int bsreadlna (bstring r, struct bStream * s, char terminator)
 *
 *  Read a bstring terminated by the terminator character or the end of the
 *  stream from the bStream (s) and return it into the parameter r.  This
 *  function may read additional characters from the core stream that are not
 *  returned, but will be retained for subsequent read operations.
 */
int bsreadlna (bstring r, struct bStream * s, char terminator) {
int i, l, ret, rlo;
char * b;
struct tagbstring x;

	if (s == NULL || s->buff == NULL || r == NULL || r->mlen <= 0 ||
	    r->slen < 0 || r->mlen < r->slen) return BSTR_ERR;
	l = s->buff->slen;
	if (BSTR_OK != balloc (s->buff, s->maxBuffSz + 1)) return BSTR_ERR;
	b = (char *) s->buff->data;
	x.data = (unsigned char *) b;

	/* First check if the current buffer holds the terminator */
	b[l] = terminator; /* Set sentinel */
	for (i=0; b[i] != terminator; i++) ;
	if (i < l) {
		x.slen = i + 1;
		ret = bconcat (r, &x);
		s->buff->slen = l;
		if (BSTR_OK == ret) bdelete (s->buff, 0, i + 1);
		return BSTR_OK;
	}

	rlo = r->slen;

	/* If not then just concatenate the entire buffer to the output */
	x.slen = l;
	if (BSTR_OK != bconcat (r, &x)) return BSTR_ERR;

	/* Perform direct in-place reads into the destination to allow for
	   the minimum of data-copies */
	for (;;) {
		if (BSTR_OK != balloc (r, r->slen + s->maxBuffSz + 1))
		    return BSTR_ERR;
		b = (char *) (r->data + r->slen);
		l = (int) s->readFnPtr (b, 1, s->maxBuffSz, s->parm);
		if (l <= 0) {
			r->data[r->slen] = (unsigned char) '\0';
			s->buff->slen = 0;
			s->isEOF = 1;
			/* If nothing was read return with an error message */
			return BSTR_ERR & -(r->slen == rlo);
		}
		b[l] = terminator; /* Set sentinel */
		for (i=0; b[i] != terminator; i++) ;
		if (i < l) break;
		r->slen += l;
	}

	/* Terminator found, push over-read back to buffer */
	i++;
	r->slen += i;
	s->buff->slen = l - i;
	bstr__memcpy (s->buff->data, b + i, l - i);
	r->data[r->slen] = (unsigned char) '\0';
	return BSTR_OK;
}

/*  int bsreadlnsa (bstring r, struct bStream * s, bstring term)
 *
 *  Read a bstring terminated by any character in the term string or the end
 *  of the stream from the bStream (s) and return it into the parameter r.
 *  This function may read additional characters from the core stream that
 *  are not returned, but will be retained for subsequent read operations.
 */
int bsreadlnsa (bstring r, struct bStream * s, const_bstring term) {
int i, l, ret, rlo;
unsigned char * b;
struct tagbstring x;
struct charField cf;

	if (s == NULL || s->buff == NULL || r == NULL || term == NULL ||
	    term->data == NULL || r->mlen <= 0 || r->slen < 0 ||
	    r->mlen < r->slen) return BSTR_ERR;
	if (term->slen == 1) return bsreadlna (r, s, term->data[0]);
	if (term->slen < 1 || buildCharField (&cf, term)) return BSTR_ERR;

	l = s->buff->slen;
	if (BSTR_OK != balloc (s->buff, s->maxBuffSz + 1)) return BSTR_ERR;
	b = (unsigned char *) s->buff->data;
	x.data = b;

	/* First check if the current buffer holds the terminator */
	b[l] = term->data[0]; /* Set sentinel */
	for (i=0; !testInCharField (&cf, b[i]); i++) ;
	if (i < l) {
		x.slen = i + 1;
		ret = bconcat (r, &x);
		s->buff->slen = l;
		if (BSTR_OK == ret) bdelete (s->buff, 0, i + 1);
		return BSTR_OK;
	}

	rlo = r->slen;

	/* If not then just concatenate the entire buffer to the output */
	x.slen = l;
	if (BSTR_OK != bconcat (r, &x)) return BSTR_ERR;

	/* Perform direct in-place reads into the destination to allow for
	   the minimum of data-copies */
	for (;;) {
		if (BSTR_OK != balloc (r, r->slen + s->maxBuffSz + 1))
		    return BSTR_ERR;
		b = (unsigned char *) (r->data + r->slen);
		l = (int) s->readFnPtr (b, 1, s->maxBuffSz, s->parm);
		if (l <= 0) {
			r->data[r->slen] = (unsigned char) '\0';
			s->buff->slen = 0;
			s->isEOF = 1;
			/* If nothing was read return with an error message */
			return BSTR_ERR & -(r->slen == rlo);
		}

		b[l] = term->data[0]; /* Set sentinel */
		for (i=0; !testInCharField (&cf, b[i]); i++) ;
		if (i < l) break;
		r->slen += l;
	}

	/* Terminator found, push over-read back to buffer */
	i++;
	r->slen += i;
	s->buff->slen = l - i;
	bstr__memcpy (s->buff->data, b + i, l - i);
	r->data[r->slen] = (unsigned char) '\0';
	return BSTR_OK;
}

/*  int bsreada (bstring r, struct bStream * s, int n)
 *
 *  Read a bstring of length n (or, if it is fewer, as many bytes as is
 *  remaining) from the bStream.  This function may read additional
 *  characters from the core stream that are not returned, but will be
 *  retained for subsequent read operations.  This function will not read
 *  additional characters from the core stream beyond virtual stream pointer.
 */
int bsreada (bstring r, struct bStream * s, int n) {
int l, ret, orslen;
char * b;
struct tagbstring x;

	if (s == NULL || s->buff == NULL || r == NULL || r->mlen <= 0
	 || r->slen < 0 || r->mlen < r->slen || n <= 0) return BSTR_ERR;

	if (n > INT_MAX - r->slen) return BSTR_ERR;
	n += r->slen;

	l = s->buff->slen;

	orslen = r->slen;

	if (0 == l) {
		if (s->isEOF) return BSTR_ERR;
		if (r->mlen > n) {
			l = (int) s->readFnPtr (r->data + r->slen, 1, n - r->slen,
			                        s->parm);
			if (0 >= l || l > n - r->slen) {
				s->isEOF = 1;
				return BSTR_ERR;
			}
			r->slen += l;
			r->data[r->slen] = (unsigned char) '\0';
			return 0;
		}
	}

	if (BSTR_OK != balloc (s->buff, s->maxBuffSz + 1)) return BSTR_ERR;
	b = (char *) s->buff->data;
	x.data = (unsigned char *) b;

	do {
		if (l + r->slen >= n) {
			x.slen = n - r->slen;
			ret = bconcat (r, &x);
			s->buff->slen = l;
			if (BSTR_OK == ret) bdelete (s->buff, 0, x.slen);
			return BSTR_ERR & -(r->slen == orslen);
		}

		x.slen = l;
		if (BSTR_OK != bconcat (r, &x)) break;

		l = n - r->slen;
		if (l > s->maxBuffSz) l = s->maxBuffSz;

		l = (int) s->readFnPtr (b, 1, l, s->parm);

	} while (l > 0);
	if (l < 0) l = 0;
	if (l == 0) s->isEOF = 1;
	s->buff->slen = l;
	return BSTR_ERR & -(r->slen == orslen);
}

/*  int bsreadln (bstring r, struct bStream * s, char terminator)
 *
 *  Read a bstring terminated by the terminator character or the end of the
 *  stream from the bStream (s) and return it into the parameter r.  This
 *  function may read additional characters from the core stream that are not
 *  returned, but will be retained for subsequent read operations.
 */
int bsreadln (bstring r, struct bStream * s, char terminator) {
	if (s == NULL || s->buff == NULL || r == NULL || r->mlen <= 0)
		return BSTR_ERR;
	if (BSTR_OK != balloc (s->buff, s->maxBuffSz + 1)) return BSTR_ERR;
	r->slen = 0;
	return bsreadlna (r, s, terminator);
}

/*  int bsreadlns (bstring r, struct bStream * s, bstring term)
 *
 *  Read a bstring terminated by any character in the term string or the end
 *  of the stream from the bStream (s) and return it into the parameter r.
 *  This function may read additional characters from the core stream that
 *  are not returned, but will be retained for subsequent read operations.
 */
int bsreadlns (bstring r, struct bStream * s, const_bstring term) {
	if (s == NULL || s->buff == NULL || r == NULL || term == NULL
	 || term->data == NULL || r->mlen <= 0) return BSTR_ERR;
	if (term->slen == 1) return bsreadln (r, s, term->data[0]);
	if (term->slen < 1) return BSTR_ERR;
	if (BSTR_OK != balloc (s->buff, s->maxBuffSz + 1)) return BSTR_ERR;
	r->slen = 0;
	return bsreadlnsa (r, s, term);
}

/*  int bsread (bstring r, struct bStream * s, int n)
 *
 *  Read a bstring of length n (or, if it is fewer, as many bytes as is
 *  remaining) from the bStream.  This function may read additional
 *  characters from the core stream that are not returned, but will be
 *  retained for subsequent read operations.  This function will not read
 *  additional characters from the core stream beyond virtual stream pointer.
 */
int bsread (bstring r, struct bStream * s, int n) {
	if (s == NULL || s->buff == NULL || r == NULL || r->mlen <= 0
	 || n <= 0) return BSTR_ERR;
	if (BSTR_OK != balloc (s->buff, s->maxBuffSz + 1)) return BSTR_ERR;
	r->slen = 0;
	return bsreada (r, s, n);
}

/*  int bsunread (struct bStream * s, const_bstring b)
 *
 *  Insert a bstring into the bStream at the current position.  These
 *  characters will be read prior to those that actually come from the core
 *  stream.
 */
int bsunread (struct bStream * s, const_bstring b) {
	if (s == NULL || s->buff == NULL) return BSTR_ERR;
	return binsert (s->buff, 0, b, (unsigned char) '?');
}

/*  int bspeek (bstring r, const struct bStream * s)
 *
 *  Return the currently buffered characters from the bStream that will be
 *  read prior to reads from the core stream.
 */
int bspeek (bstring r, const struct bStream * s) {
	if (s == NULL || s->buff == NULL) return BSTR_ERR;
	return bassign (r, s->buff);
}

/*  bstring bjoinblk (const struct bstrList * bl, void * blk, int len);
 *
 *  Join the entries of a bstrList into one bstring by sequentially
 *  concatenating them with the content from blk for length len in between.
 *  If there is an error NULL is returned, otherwise a bstring with the
 *  correct result is returned.
 */
bstring bjoinblk (const struct bstrList * bl, const void * blk, int len) {
bstring b;
unsigned char * p;
int i, c, v;

	if (bl == NULL || bl->qty < 0) return NULL;
	if (len < 0) return NULL;
	if (len > 0 && blk == NULL) return NULL;
	if (bl->qty < 1) return bfromStatic ("");

	for (i = 0, c = 1; i < bl->qty; i++) {
		v = bl->entry[i]->slen;
		if (v < 0) return NULL;	/* Invalid input */
		if (v > INT_MAX - c) return NULL;	/* Overflow */
		c += v;
	}

	b = (bstring) bstr__alloc (sizeof (struct tagbstring));
	if (len == 0) {
		p = b->data = (unsigned char *) bstr__alloc (c);
		if (p == NULL) {
			bstr__free (b);
			return NULL;
		}
		for (i = 0; i < bl->qty; i++) {
			v = bl->entry[i]->slen;
			bstr__memcpy (p, bl->entry[i]->data, v);
			p += v;
		}
	} else {
		v = (bl->qty - 1) * len;
		if ((bl->qty > 512 || len > 127) &&
			v / len != bl->qty - 1) {
			bstr__free (b);
			return NULL; /* Overflow */
		}
		if (v > INT_MAX - c) {
			bstr__free (b);
			return NULL;    /* Overflow */
		}
		c += v;
		p = b->data = (unsigned char *) bstr__alloc (c);
		if (p == NULL) {
			bstr__free (b);
			return NULL;
		}
		v = bl->entry[0]->slen;
		bstr__memcpy (p, bl->entry[0]->data, v);
		p += v;
		for (i = 1; i < bl->qty; i++) {
			bstr__memcpy (p, blk, len);
			p += len;
			v = bl->entry[i]->slen;
			if (v) {
				bstr__memcpy (p, bl->entry[i]->data, v);
				p += v;
			}
		}
	}
	b->mlen = c;
	b->slen = c-1;
	b->data[c-1] = (unsigned char) '\0';
	return b;
}

/*  bstring bjoin (const struct bstrList * bl, const_bstring sep);
 *
 *  Join the entries of a bstrList into one bstring by sequentially
 *  concatenating them with the sep string in between.  If there is an error
 *  NULL is returned, otherwise a bstring with the correct result is returned.
 */
bstring bjoin (const struct bstrList * bl, const_bstring sep) {
	if (sep == NULL || (sep->slen < 0 || sep->data == NULL)) return NULL;
	return bjoinblk (bl, sep->data, sep->slen);
}

#define BSSSC_BUFF_LEN (256)

/*  int bssplitscb (struct bStream * s, const_bstring splitStr,
 *                  int (* cb) (void * parm, int ofs, const_bstring entry),
 *                  void * parm)
 *
 *  Iterate the set of disjoint sequential substrings read from a stream
 *  divided by any of the characters in splitStr.  An empty splitStr causes
 *  the whole stream to be iterated once.
 *
 *  Note: At the point of calling the cb function, the bStream pointer is
 *  pointed exactly at the position right after having read the split
 *  character.  The cb function can act on the stream by causing the bStream
 *  pointer to move, and bssplitscb will continue by starting the next split
 *  at the position of the pointer after the return from cb.
 *
 *  However, if the cb causes the bStream s to be destroyed then the cb must
 *  return with a negative value, otherwise bssplitscb will continue in an
 *  undefined manner.
 */
int bssplitscb (struct bStream * s, const_bstring splitStr,
	int (* cb) (void * parm, int ofs, const_bstring entry), void * parm) {
	struct charField chrs;
	bstring buff;
	int i = 0, p = 0, ret = 0;

	if (cb == NULL || s == NULL || s->readFnPtr == NULL ||
	    splitStr == NULL || splitStr->slen < 0) return BSTR_ERR;

	if (NULL == (buff = bfromcstr (""))) return BSTR_ERR;

	if (splitStr->slen == 0) {
		while (bsreada (buff, s, BSSSC_BUFF_LEN) >= 0) ;
		if ((ret = cb (parm, 0, buff)) > 0)
			ret = 0;
	} else {
		buildCharField (&chrs, splitStr);
		for (;;) {
			if (i >= buff->slen) {
				bsreada (buff, s, BSSSC_BUFF_LEN);
				if (i >= buff->slen) {
					if (0 < (ret = cb (parm, p, buff))) ret = 0;
					break;
				}
			}
			if (testInCharField (&chrs, buff->data[i])) {
				struct tagbstring t;
				unsigned char c;

				blk2tbstr (t, buff->data + i + 1, buff->slen - (i + 1));
				if ((ret = bsunread (s, &t)) < 0) break;
				buff->slen = i;
				c = buff->data[i];
				buff->data[i] = (unsigned char) '\0';
				if ((ret = cb (parm, p, buff)) < 0) break;
				buff->data[i] = c;
				buff->slen = 0;
				p += i + 1;
				i = -1;
			}
			i++;
		}
	}

	bdestroy (buff);
	return ret;
}

/*  int bssplitstrcb (struct bStream * s, const_bstring splitStr,
 *                    int (* cb) (void * parm, int ofs, const_bstring entry),
 *                    void * parm)
 *
 *  Iterate the set of disjoint sequential substrings read from a stream
 *  divided by the entire substring splitStr.  An empty splitStr causes
 *  each character of the stream to be iterated.
 *
 *  Note: At the point of calling the cb function, the bStream pointer is
 *  pointed exactly at the position right after having read the split
 *  character.  The cb function can act on the stream by causing the bStream
 *  pointer to move, and bssplitscb will continue by starting the next split
 *  at the position of the pointer after the return from cb.
 *
 *  However, if the cb causes the bStream s to be destroyed then the cb must
 *  return with a negative value, otherwise bssplitscb will continue in an
 *  undefined manner.
 */
int bssplitstrcb (struct bStream * s, const_bstring splitStr,
	int (* cb) (void * parm, int ofs, const_bstring entry), void * parm) {
	bstring buff;
	int i = 0, p = 0, ret = 0;

	if (cb == NULL || s == NULL || s->readFnPtr == NULL
	 || splitStr == NULL || splitStr->slen < 0) return BSTR_ERR;

	if (splitStr->slen == 1) return bssplitscb (s, splitStr, cb, parm);

	if (NULL == (buff = bfromcstr (""))) return BSTR_ERR;

	if (splitStr->slen == 0) {
		for (i=0; bsreada (buff, s, BSSSC_BUFF_LEN) >= 0; i++) {
			if ((ret = cb (parm, 0, buff)) < 0) {
				bdestroy (buff);
				return ret;
			}
			buff->slen = 0;
		}
		bdestroy (buff);
		return BSTR_OK;
	} else {
		for (;;) {
			if ((ret = binstr (buff, 0, splitStr)) >= 0) {
				struct tagbstring t;
				blk2tbstr (t, buff->data, ret);
				i = ret + splitStr->slen;
				if ((ret = cb (parm, p, &t)) < 0) break;
				p += i;
				bdelete (buff, 0, i);
			} else {
				bsreada (buff, s, BSSSC_BUFF_LEN);
				if (bseof (s)) {
					if ((ret = cb (parm, p, buff)) > 0) ret = 0;
					break;
				}
			}
		}
	}

	bdestroy (buff);
	return ret;
}

/*  int bstrListCreate (void)
 *
 *  Create a bstrList.
 */
struct bstrList * bstrListCreate (void) {
struct bstrList * sl =
	(struct bstrList *) bstr__alloc (sizeof (struct bstrList));
	if (sl) {
		sl->entry = (bstring *) bstr__alloc (1*sizeof (bstring));
		if (!sl->entry) {
			bstr__free (sl);
			sl = NULL;
		} else {
			sl->qty = 0;
			sl->mlen = 1;
		}
	}
	return sl;
}

/*  int bstrListDestroy (struct bstrList * sl)
 *
 *  Destroy a bstrList that has been created by bsplit, bsplits or
 *  bstrListCreate.
 */
int bstrListDestroy (struct bstrList * sl) {
int i;
	if (sl == NULL || sl->qty < 0) return BSTR_ERR;
	for (i=0; i < sl->qty; i++) {
		if (sl->entry[i]) {
			bdestroy (sl->entry[i]);
			sl->entry[i] = NULL;
		}
	}
	sl->qty  = -1;
	sl->mlen = -1;
	bstr__free (sl->entry);
	sl->entry = NULL;
	bstr__free (sl);
	return BSTR_OK;
}

/*  int bstrListAlloc (struct bstrList * sl, int msz)
 *
 *  Ensure that there is memory for at least msz number of entries for the
 *  list.
 */
int bstrListAlloc (struct bstrList * sl, int msz) {
bstring * l;
int smsz;
size_t nsz;
	if (!sl || msz <= 0 || !sl->entry || sl->qty < 0 || sl->mlen <= 0 ||
	    sl->qty > sl->mlen) return BSTR_ERR;
	if (sl->mlen >= msz) return BSTR_OK;
	smsz = snapUpSize (msz);
	nsz = ((size_t) smsz) * sizeof (bstring);
	if (nsz < (size_t) smsz) return BSTR_ERR;
	l = (bstring *) bstr__realloc (sl->entry, nsz);
	if (!l) {
		smsz = msz;
		nsz = ((size_t) smsz) * sizeof (bstring);
		l = (bstring *) bstr__realloc (sl->entry, nsz);
		if (!l) return BSTR_ERR;
	}
	sl->mlen = smsz;
	sl->entry = l;
	return BSTR_OK;
}

/*  int bstrListAllocMin (struct bstrList * sl, int msz)
 *
 *  Try to allocate the minimum amount of memory for the list to include at
 *  least msz entries or sl->qty whichever is greater.
 */
int bstrListAllocMin (struct bstrList * sl, int msz) {
bstring * l;
size_t nsz;
	if (!sl || msz <= 0 || !sl->entry || sl->qty < 0 || sl->mlen <= 0 ||
	    sl->qty > sl->mlen) return BSTR_ERR;
	if (msz < sl->qty) msz = sl->qty;
	if (sl->mlen == msz) return BSTR_OK;
	nsz = ((size_t) msz) * sizeof (bstring);
	if (nsz < (size_t) msz) return BSTR_ERR;
	l = (bstring *) bstr__realloc (sl->entry, nsz);
	if (!l) return BSTR_ERR;
	sl->mlen = msz;
	sl->entry = l;
	return BSTR_OK;
}

/*  int bsplitcb (const_bstring str, unsigned char splitChar, int pos,
 *                int (* cb) (void * parm, int ofs, int len), void * parm)
 *
 *  Iterate the set of disjoint sequential substrings over str divided by the
 *  character in splitChar.
 *
 *  Note: Non-destructive modification of str from within the cb function
 *  while performing this split is not undefined.  bsplitcb behaves in
 *  sequential lock step with calls to cb.  I.e., after returning from a cb
 *  that return a non-negative integer, bsplitcb continues from the position
 *  1 character after the last detected split character and it will halt
 *  immediately if the length of str falls below this point.  However, if the
 *  cb function destroys str, then it *must* return with a negative value,
 *  otherwise bsplitcb will continue in an undefined manner.
 */
int bsplitcb (const_bstring str, unsigned char splitChar, int pos,
	int (* cb) (void * parm, int ofs, int len), void * parm) {
int i, p, ret;

	if (cb == NULL || str == NULL || pos < 0 || pos > str->slen)
		return BSTR_ERR;

	p = pos;
	do {
		for (i=p; i < str->slen; i++) {
			if (str->data[i] == splitChar) break;
		}
		if ((ret = cb (parm, p, i - p)) < 0) return ret;
		p = i + 1;
	} while (p <= str->slen);
	return BSTR_OK;
}

/*  int bsplitscb (const_bstring str, const_bstring splitStr, int pos,
 *                 int (* cb) (void * parm, int ofs, int len), void * parm)
 *
 *  Iterate the set of disjoint sequential substrings over str divided by any
 *  of the characters in splitStr.  An empty splitStr causes the whole str to
 *  be iterated once.
 *
 *  Note: Non-destructive modification of str from within the cb function
 *  while performing this split is not undefined.  bsplitscb behaves in
 *  sequential lock step with calls to cb.  I.e., after returning from a cb
 *  that return a non-negative integer, bsplitscb continues from the position
 *  1 character after the last detected split character and it will halt
 *  immediately if the length of str falls below this point.  However, if the
 *  cb function destroys str, then it *must* return with a negative value,
 *  otherwise bsplitscb will continue in an undefined manner.
 */
int bsplitscb (const_bstring str, const_bstring splitStr, int pos,
	int (* cb) (void * parm, int ofs, int len), void * parm) {
struct charField chrs;
int i, p, ret;

	if (cb == NULL || str == NULL || pos < 0 || pos > str->slen
	 || splitStr == NULL || splitStr->slen < 0) return BSTR_ERR;
	if (splitStr->slen == 0) {
		if ((ret = cb (parm, 0, str->slen)) > 0) ret = 0;
		return ret;
	}

	if (splitStr->slen == 1)
		return bsplitcb (str, splitStr->data[0], pos, cb, parm);

	buildCharField (&chrs, splitStr);

	p = pos;
	do {
		for (i=p; i < str->slen; i++) {
			if (testInCharField (&chrs, str->data[i])) break;
		}
		if ((ret = cb (parm, p, i - p)) < 0) return ret;
		p = i + 1;
	} while (p <= str->slen);
	return BSTR_OK;
}

/*  int bsplitstrcb (const_bstring str, const_bstring splitStr, int pos,
 *	int (* cb) (void * parm, int ofs, int len), void * parm)
 *
 *  Iterate the set of disjoint sequential substrings over str divided by the
 *  substring splitStr.  An empty splitStr causes the whole str to be
 *  iterated once.
 *
 *  Note: Non-destructive modification of str from within the cb function
 *  while performing this split is not undefined.  bsplitstrcb behaves in
 *  sequential lock step with calls to cb.  I.e., after returning from a cb
 *  that return a non-negative integer, bsplitscb continues from the position
 *  1 character after the last detected split character and it will halt
 *  immediately if the length of str falls below this point.  However, if the
 *  cb function destroys str, then it *must* return with a negative value,
 *  otherwise bsplitscb will continue in an undefined manner.
 */
int bsplitstrcb (const_bstring str, const_bstring splitStr, int pos,
	int (* cb) (void * parm, int ofs, int len), void * parm) {
int i, p, ret;

	if (cb == NULL || str == NULL || pos < 0 || pos > str->slen
	 || splitStr == NULL || splitStr->slen < 0) return BSTR_ERR;

	if (0 == splitStr->slen) {
		for (i=pos; i < str->slen; i++) {
			if ((ret = cb (parm, i, 1)) < 0) return ret;
		}
		return BSTR_OK;
	}

	if (splitStr->slen == 1)
		return bsplitcb (str, splitStr->data[0], pos, cb, parm);

	for (i=p=pos; i <= str->slen - splitStr->slen; i++) {
		if (0 == bstr__memcmp (splitStr->data, str->data + i,
		                       splitStr->slen)) {
			if ((ret = cb (parm, p, i - p)) < 0) return ret;
			i += splitStr->slen;
			p = i;
		}
	}
	if ((ret = cb (parm, p, str->slen - p)) < 0) return ret;
	return BSTR_OK;
}

struct genBstrList {
	bstring b;
	struct bstrList * bl;
};

static int bscb (void * parm, int ofs, int len) {
struct genBstrList * g = (struct genBstrList *) parm;
	if (g->bl->qty >= g->bl->mlen) {
		int mlen = g->bl->mlen * 2;
		bstring * tbl;

		while (g->bl->qty >= mlen) {
			if (mlen < g->bl->mlen) return BSTR_ERR;
			mlen += mlen;
		}

		tbl = (bstring *) bstr__realloc (g->bl->entry,
		                                 sizeof (bstring) * mlen);
		if (tbl == NULL) return BSTR_ERR;

		g->bl->entry = tbl;
		g->bl->mlen = mlen;
	}

	g->bl->entry[g->bl->qty] = bmidstr (g->b, ofs, len);
	g->bl->qty++;
	return BSTR_OK;
}

/*  struct bstrList * bsplit (const_bstring str, unsigned char splitChar)
 *
 *  Create an array of sequential substrings from str divided by the character
 *  splitChar.
 */
struct bstrList * bsplit (const_bstring str, unsigned char splitChar) {
struct genBstrList g;

	if (str == NULL || str->data == NULL || str->slen < 0) return NULL;

	g.bl = (struct bstrList *) bstr__alloc (sizeof (struct bstrList));
	if (g.bl == NULL) return NULL;
	g.bl->mlen = 4;
	g.bl->entry = (bstring *) bstr__alloc (g.bl->mlen * sizeof (bstring));
	if (NULL == g.bl->entry) {
		bstr__free (g.bl);
		return NULL;
	}

	g.b = (bstring) str;
	g.bl->qty = 0;
	if (bsplitcb (str, splitChar, 0, bscb, &g) < 0) {
		bstrListDestroy (g.bl);
		return NULL;
	}
	return g.bl;
}

/*  struct bstrList * bsplitstr (const_bstring str, const_bstring splitStr)
 *
 *  Create an array of sequential substrings from str divided by the entire
 *  substring splitStr.
 */
struct bstrList * bsplitstr (const_bstring str, const_bstring splitStr) {
struct genBstrList g;

	if (str == NULL || str->data == NULL || str->slen < 0) return NULL;

	g.bl = (struct bstrList *) bstr__alloc (sizeof (struct bstrList));
	if (g.bl == NULL) return NULL;
	g.bl->mlen = 4;
	g.bl->entry = (bstring *) bstr__alloc (g.bl->mlen * sizeof (bstring));
	if (NULL == g.bl->entry) {
		bstr__free (g.bl);
		return NULL;
	}

	g.b = (bstring) str;
	g.bl->qty = 0;
	if (bsplitstrcb (str, splitStr, 0, bscb, &g) < 0) {
		bstrListDestroy (g.bl);
		return NULL;
	}
	return g.bl;
}

/*  struct bstrList * bsplits (const_bstring str, bstring splitStr)
 *
 *  Create an array of sequential substrings from str divided by any of the
 *  characters in splitStr.  An empty splitStr causes a single entry bstrList
 *  containing a copy of str to be returned.
 */
struct bstrList * bsplits (const_bstring str, const_bstring splitStr) {
struct genBstrList g;

	if (     str == NULL ||      str->slen < 0 ||      str->data == NULL ||
	    splitStr == NULL || splitStr->slen < 0 || splitStr->data == NULL)
		return NULL;

	g.bl = (struct bstrList *) bstr__alloc (sizeof (struct bstrList));
	if (g.bl == NULL) return NULL;
	g.bl->mlen = 4;
	g.bl->entry = (bstring *) bstr__alloc (g.bl->mlen * sizeof (bstring));
	if (NULL == g.bl->entry) {
		bstr__free (g.bl);
		return NULL;
	}
	g.b = (bstring) str;
	g.bl->qty = 0;

	if (bsplitscb (str, splitStr, 0, bscb, &g) < 0) {
		bstrListDestroy (g.bl);
		return NULL;
	}
	return g.bl;
}

#if defined (__TURBOC__) && !defined (__BORLANDC__)
# ifndef BSTRLIB_NOVSNP
#  define BSTRLIB_NOVSNP
# endif
#endif

/* Give WATCOM C/C++, MSVC some latitude for their non-support of vsnprintf */
#if defined(__WATCOMC__) || defined(_MSC_VER)
#define exvsnprintf(r,b,n,f,a) {r = _vsnprintf (b,n,f,a);}
#else
#ifdef BSTRLIB_NOVSNP
/* This is just a hack.  If you are using a system without a vsnprintf, it is
   not recommended that bformat be used at all. */
#define exvsnprintf(r,b,n,f,a) {vsprintf (b,f,a); r = -1;}
#define START_VSNBUFF (256)
#else

#if defined(__GNUC__) && !defined(__APPLE__)
/* Something is making gcc complain about this prototype not being here, so
   I've just gone ahead and put it in. */
extern int vsnprintf (char *buf, size_t count, const char *format, va_list arg);
#endif

#define exvsnprintf(r,b,n,f,a) {r = vsnprintf (b,n,f,a);}
#endif
#endif

#if !defined (BSTRLIB_NOVSNP)

#ifndef START_VSNBUFF
#define START_VSNBUFF (16)
#endif

/* On IRIX vsnprintf returns n-1 when the operation would overflow the target
   buffer, WATCOM and MSVC both return -1, while C99 requires that the
   returned value be exactly what the length would be if the buffer would be
   large enough.  This leads to the idea that if the return value is larger
   than n, then changing n to the return value will reduce the number of
   iterations required. */

/*  int bformata (bstring b, const char * fmt, ...)
 *
 *  After the first parameter, it takes the same parameters as printf (), but
 *  rather than outputting results to stdio, it appends the results to
 *  a bstring which contains what would have been output. Note that if there
 *  is an early generation of a '\0' character, the bstring will be truncated
 *  to this end point.
 */
int bformata (bstring b, const char * fmt, ...) {
va_list arglist;
bstring buff;
int n, r;

	if (b == NULL || fmt == NULL || b->data == NULL || b->mlen <= 0
	 || b->slen < 0 || b->slen > b->mlen) return BSTR_ERR;

	/* Since the length is not determinable beforehand, a search is
	   performed using the truncating "vsnprintf" call (to avoid buffer
	   overflows) on increasing potential sizes for the output result. */

	if ((n = (int) (2*strlen (fmt))) < START_VSNBUFF) n = START_VSNBUFF;
	if (NULL == (buff = bfromcstralloc (n + 2, ""))) {
		n = 1;
		if (NULL == (buff = bfromcstralloc (n + 2, ""))) return BSTR_ERR;
	}

	for (;;) {
		va_start (arglist, fmt);
		exvsnprintf (r, (char *) buff->data, n + 1, fmt, arglist);
		va_end (arglist);

		buff->data[n] = (unsigned char) '\0';
		buff->slen = (int) (strlen) ((char *) buff->data);

		if (buff->slen < n) break;

		if (r > n) n = r; else n += n;

		if (BSTR_OK != balloc (buff, n + 2)) {
			bdestroy (buff);
			return BSTR_ERR;
		}
	}

	r = bconcat (b, buff);
	bdestroy (buff);
	return r;
}

/*  int bassignformat (bstring b, const char * fmt, ...)
 *
 *  After the first parameter, it takes the same parameters as printf (), but
 *  rather than outputting results to stdio, it outputs the results to
 *  the bstring parameter b. Note that if there is an early generation of a
 *  '\0' character, the bstring will be truncated to this end point.
 */
int bassignformat (bstring b, const char * fmt, ...) {
va_list arglist;
bstring buff;
int n, r;

	if (b == NULL || fmt == NULL || b->data == NULL || b->mlen <= 0
	 || b->slen < 0 || b->slen > b->mlen) return BSTR_ERR;

	/* Since the length is not determinable beforehand, a search is
	   performed using the truncating "vsnprintf" call (to avoid buffer
	   overflows) on increasing potential sizes for the output result. */

	if ((n = (int) (2*strlen (fmt))) < START_VSNBUFF) n = START_VSNBUFF;
	if (NULL == (buff = bfromcstralloc (n + 2, ""))) {
		n = 1;
		if (NULL == (buff = bfromcstralloc (n + 2, ""))) return BSTR_ERR;
	}

	for (;;) {
		va_start (arglist, fmt);
		exvsnprintf (r, (char *) buff->data, n + 1, fmt, arglist);
		va_end (arglist);

		buff->data[n] = (unsigned char) '\0';
		buff->slen = (int) (strlen) ((char *) buff->data);

		if (buff->slen < n) break;

		if (r > n) n = r; else n += n;

		if (BSTR_OK != balloc (buff, n + 2)) {
			bdestroy (buff);
			return BSTR_ERR;
		}
	}

	r = bassign (b, buff);
	bdestroy (buff);
	return r;
}

/*  bstring bformat (const char * fmt, ...)
 *
 *  Takes the same parameters as printf (), but rather than outputting results
 *  to stdio, it forms a bstring which contains what would have been output.
 *  Note that if there is an early generation of a '\0' character, the
 *  bstring will be truncated to this end point.
 */
bstring bformat (const char * fmt, ...) {
va_list arglist;
bstring buff;
int n, r;

	if (fmt == NULL) return NULL;

	/* Since the length is not determinable beforehand, a search is
	   performed using the truncating "vsnprintf" call (to avoid buffer
	   overflows) on increasing potential sizes for the output result. */

	if ((n = (int) (2*strlen (fmt))) < START_VSNBUFF) n = START_VSNBUFF;
	if (NULL == (buff = bfromcstralloc (n + 2, ""))) {
		n = 1;
		if (NULL == (buff = bfromcstralloc (n + 2, ""))) return NULL;
	}

	for (;;) {
		va_start (arglist, fmt);
		exvsnprintf (r, (char *) buff->data, n + 1, fmt, arglist);
		va_end (arglist);

		buff->data[n] = (unsigned char) '\0';
		buff->slen = (int) (strlen) ((char *) buff->data);

		if (buff->slen < n) break;

		if (r > n) n = r; else n += n;

		if (BSTR_OK != balloc (buff, n + 2)) {
			bdestroy (buff);
			return NULL;
		}
	}

	return buff;
}

/*  int bvcformata (bstring b, int count, const char * fmt, va_list arglist)
 *
 *  The bvcformata function formats data under control of the format control
 *  string fmt and attempts to append the result to b.  The fmt parameter is
 *  the same as that of the printf function.  The variable argument list is
 *  replaced with arglist, which has been initialized by the va_start macro.
 *  The size of the output is upper bounded by count.  If the required output
 *  exceeds count, the string b is not augmented with any contents and a value
 *  below BSTR_ERR is returned.  If a value below -count is returned then it
 *  is recommended that the negative of this value be used as an update to the
 *  count in a subsequent pass.  On other errors, such as running out of
 *  memory, parameter errors or numeric wrap around BSTR_ERR is returned.
 *  BSTR_OK is returned when the output is successfully generated and
 *  appended to b.
 *
 *  Note: There is no sanity checking of arglist, and this function is
 *  destructive of the contents of b from the b->slen point onward.  If there
 *  is an early generation of a '\0' character, the bstring will be truncated
 *  to this end point.
 */
int bvcformata (bstring b, int count, const char * fmt, va_list arg) {
int n, r, l;

	if (b == NULL || fmt == NULL || count <= 0 || b->data == NULL
	 || b->mlen <= 0 || b->slen < 0 || b->slen > b->mlen) return BSTR_ERR;

	if (count > (n = b->slen + count) + 2) return BSTR_ERR;
	if (BSTR_OK != balloc (b, n + 2)) return BSTR_ERR;

	exvsnprintf (r, (char *) b->data + b->slen, count + 2, fmt, arg);
	b->data[b->slen + count + 2] = '\0';

	/* Did the operation complete successfully within bounds? */

	if (n >= (l = b->slen + (int) (strlen) ((char *) b->data + b->slen))) {
		b->slen = l;
		return BSTR_OK;
	}

	/* Abort, since the buffer was not large enough.  The return value
	   tries to help set what the retry length should be. */

	b->data[b->slen] = '\0';
	if (r > count+1) {
		l = r;
	} else {
		if (count > INT_MAX / 2)
			l = INT_MAX;
		else
			l = count + count;
	}
	n = -l;
	if (n > BSTR_ERR-1) n = BSTR_ERR-1;
	return n;
}

#endif

```

`efiXloader/3rd/uefitool/common/bstrlib/bstrlib.h`:

```h
/*
 * This source file is part of the bstring string library.  This code was
 * written by Paul Hsieh in 2002-2015, and is covered by the BSD open source
 * license and the GPL. Refer to the accompanying documentation for details
 * on usage and license.
 */

/*
 * bstrlib.h
 *
 * This file is the interface for the core bstring functions.
 */

#ifndef BSTRLIB_INCLUDE
#define BSTRLIB_INCLUDE

#ifdef __cplusplus
extern "C" {
#endif

#include <stdarg.h>
#include <string.h>
#include <limits.h>
#include <ctype.h>

#if !defined (BSTRLIB_VSNP_OK) && !defined (BSTRLIB_NOVSNP)
# if defined (__TURBOC__) && !defined (__BORLANDC__)
#  define BSTRLIB_NOVSNP
# endif
#endif

#define BSTR_ERR (-1)
#define BSTR_OK (0)
#define BSTR_BS_BUFF_LENGTH_GET (0)

typedef struct tagbstring * bstring;
typedef const struct tagbstring * const_bstring;

/* Version */
#define BSTR_VER_MAJOR  1
#define BSTR_VER_MINOR  0
#define BSTR_VER_UPDATE 0

/* Copy functions */
#define cstr2bstr bfromcstr
extern bstring bfromcstr (const char * str);
extern bstring bfromcstralloc (int mlen, const char * str);
extern bstring bfromcstrrangealloc (int minl, int maxl, const char* str);
extern bstring blk2bstr (const void * blk, int len);
extern char * bstr2cstr (const_bstring s, char z);
extern int bcstrfree (char * s);
extern bstring bstrcpy (const_bstring b1);
extern int bassign (bstring a, const_bstring b);
extern int bassignmidstr (bstring a, const_bstring b, int left, int len);
extern int bassigncstr (bstring a, const char * str);
extern int bassignblk (bstring a, const void * s, int len);

/* Destroy function */
extern int bdestroy (bstring b);

/* Space allocation hinting functions */
extern int balloc (bstring s, int len);
extern int ballocmin (bstring b, int len);

/* Substring extraction */
extern bstring bmidstr (const_bstring b, int left, int len);

/* Various standard manipulations */
extern int bconcat (bstring b0, const_bstring b1);
extern int bconchar (bstring b0, char c);
extern int bcatcstr (bstring b, const char * s);
extern int bcatblk (bstring b, const void * s, int len);
extern int binsert (bstring s1, int pos, const_bstring s2, unsigned char fill);
extern int binsertblk (bstring s1, int pos, const void * s2, int len, unsigned char fill);
extern int binsertch (bstring s1, int pos, int len, unsigned char fill);
extern int breplace (bstring b1, int pos, int len, const_bstring b2, unsigned char fill);
extern int bdelete (bstring s1, int pos, int len);
extern int bsetstr (bstring b0, int pos, const_bstring b1, unsigned char fill);
extern int btrunc (bstring b, int n);

/* Scan/search functions */
extern int bstricmp (const_bstring b0, const_bstring b1);
extern int bstrnicmp (const_bstring b0, const_bstring b1, int n);
extern int biseqcaseless (const_bstring b0, const_bstring b1);
extern int biseqcaselessblk (const_bstring b, const void * blk, int len);
extern int bisstemeqcaselessblk (const_bstring b0, const void * blk, int len);
extern int biseq (const_bstring b0, const_bstring b1);
extern int biseqblk (const_bstring b, const void * blk, int len);
extern int bisstemeqblk (const_bstring b0, const void * blk, int len);
extern int biseqcstr (const_bstring b, const char * s);
extern int biseqcstrcaseless (const_bstring b, const char * s);
extern int bstrcmp (const_bstring b0, const_bstring b1);
extern int bstrncmp (const_bstring b0, const_bstring b1, int n);
extern int binstr (const_bstring s1, int pos, const_bstring s2);
extern int binstrr (const_bstring s1, int pos, const_bstring s2);
extern int binstrcaseless (const_bstring s1, int pos, const_bstring s2);
extern int binstrrcaseless (const_bstring s1, int pos, const_bstring s2);
extern int bstrchrp (const_bstring b, int c, int pos);
extern int bstrrchrp (const_bstring b, int c, int pos);
#define bstrchr(b,c) bstrchrp ((b), (c), 0)
#define bstrrchr(b,c) bstrrchrp ((b), (c), blength(b)-1)
extern int binchr (const_bstring b0, int pos, const_bstring b1);
extern int binchrr (const_bstring b0, int pos, const_bstring b1);
extern int bninchr (const_bstring b0, int pos, const_bstring b1);
extern int bninchrr (const_bstring b0, int pos, const_bstring b1);
extern int bfindreplace (bstring b, const_bstring find, const_bstring repl, int pos);
extern int bfindreplacecaseless (bstring b, const_bstring find, const_bstring repl, int pos);

/* List of string container functions */
struct bstrList {
    int qty, mlen;
    bstring * entry;
};
extern struct bstrList * bstrListCreate (void);
extern int bstrListDestroy (struct bstrList * sl);
extern int bstrListAlloc (struct bstrList * sl, int msz);
extern int bstrListAllocMin (struct bstrList * sl, int msz);

/* String split and join functions */
extern struct bstrList * bsplit (const_bstring str, unsigned char splitChar);
extern struct bstrList * bsplits (const_bstring str, const_bstring splitStr);
extern struct bstrList * bsplitstr (const_bstring str, const_bstring splitStr);
extern bstring bjoin (const struct bstrList * bl, const_bstring sep);
extern bstring bjoinblk (const struct bstrList * bl, const void * s, int len);
extern int bsplitcb (const_bstring str, unsigned char splitChar, int pos,
	int (* cb) (void * parm, int ofs, int len), void * parm);
extern int bsplitscb (const_bstring str, const_bstring splitStr, int pos,
	int (* cb) (void * parm, int ofs, int len), void * parm);
extern int bsplitstrcb (const_bstring str, const_bstring splitStr, int pos,
	int (* cb) (void * parm, int ofs, int len), void * parm);

/* Miscellaneous functions */
extern int bpattern (bstring b, int len);
extern int btoupper (bstring b);
extern int btolower (bstring b);
extern int bltrimws (bstring b);
extern int brtrimws (bstring b);
extern int btrimws (bstring b);

#if !defined (BSTRLIB_NOVSNP)
extern bstring bformat (const char * fmt, ...);
extern int bformata (bstring b, const char * fmt, ...);
extern int bassignformat (bstring b, const char * fmt, ...);
extern int bvcformata (bstring b, int count, const char * fmt, va_list arglist);

#define bvformata(ret, b, fmt, lastarg) { \
bstring bstrtmp_b = (b); \
const char * bstrtmp_fmt = (fmt); \
int bstrtmp_r = BSTR_ERR, bstrtmp_sz = 16; \
	for (;;) { \
		va_list bstrtmp_arglist; \
		va_start (bstrtmp_arglist, lastarg); \
		bstrtmp_r = bvcformata (bstrtmp_b, bstrtmp_sz, bstrtmp_fmt, bstrtmp_arglist); \
		va_end (bstrtmp_arglist); \
		if (bstrtmp_r >= 0) { /* Everything went ok */ \
			bstrtmp_r = BSTR_OK; \
			break; \
		} else if (-bstrtmp_r <= bstrtmp_sz) { /* A real error? */ \
			bstrtmp_r = BSTR_ERR; \
			break; \
		} \
		bstrtmp_sz = -bstrtmp_r; /* Doubled or target size */ \
	} \
	ret = bstrtmp_r; \
}

#endif

typedef int (*bNgetc) (void *parm);
typedef size_t (* bNread) (void *buff, size_t elsize, size_t nelem, void *parm);

/* Input functions */
extern bstring bgets (bNgetc getcPtr, void * parm, char terminator);
extern bstring bread (bNread readPtr, void * parm);
extern int bgetsa (bstring b, bNgetc getcPtr, void * parm, char terminator);
extern int bassigngets (bstring b, bNgetc getcPtr, void * parm, char terminator);
extern int breada (bstring b, bNread readPtr, void * parm);

/* Stream functions */
extern struct bStream * bsopen (bNread readPtr, void * parm);
extern void * bsclose (struct bStream * s);
extern int bsbufflength (struct bStream * s, int sz);
extern int bsreadln (bstring b, struct bStream * s, char terminator);
extern int bsreadlns (bstring r, struct bStream * s, const_bstring term);
extern int bsread (bstring b, struct bStream * s, int n);
extern int bsreadlna (bstring b, struct bStream * s, char terminator);
extern int bsreadlnsa (bstring r, struct bStream * s, const_bstring term);
extern int bsreada (bstring b, struct bStream * s, int n);
extern int bsunread (struct bStream * s, const_bstring b);
extern int bspeek (bstring r, const struct bStream * s);
extern int bssplitscb (struct bStream * s, const_bstring splitStr, 
	int (* cb) (void * parm, int ofs, const_bstring entry), void * parm);
extern int bssplitstrcb (struct bStream * s, const_bstring splitStr, 
	int (* cb) (void * parm, int ofs, const_bstring entry), void * parm);
extern int bseof (const struct bStream * s);

struct tagbstring {
	int mlen;
	int slen;
	unsigned char * data;
};

/* Accessor macros */
#define blengthe(b, e)      (((b) == (void *)0 || (b)->slen < 0) ? (int)(e) : ((b)->slen))
#define blength(b)          (blengthe ((b), 0))
#define bdataofse(b, o, e)  (((b) == (void *)0 || (b)->data == (void*)0) ? (char *)(e) : ((char *)(b)->data) + (o))
#define bdataofs(b, o)      (bdataofse ((b), (o), (void *)0))
#define bdatae(b, e)        (bdataofse (b, 0, e))
#define bdata(b)            (bdataofs (b, 0))
#define bchare(b, p, e)     ((((unsigned)(p)) < (unsigned)blength(b)) ? ((b)->data[(p)]) : (e))
#define bchar(b, p)         bchare ((b), (p), '\0')

/* Static constant string initialization macro */
#define bsStaticMlen(q,m)   {(m), (int) sizeof(q)-1, (unsigned char *) ("" q "")}
#if defined(_MSC_VER)
# define bsStatic(q)        bsStaticMlen(q,-32)
#endif
#ifndef bsStatic
# define bsStatic(q)        bsStaticMlen(q,-__LINE__)
#endif

/* Static constant block parameter pair */
#define bsStaticBlkParms(q) ((void *)("" q "")), ((int) sizeof(q)-1)

#define bcatStatic(b,s)     ((bcatblk)((b), bsStaticBlkParms(s)))
#define bfromStatic(s)      ((blk2bstr)(bsStaticBlkParms(s)))
#define bassignStatic(b,s)  ((bassignblk)((b), bsStaticBlkParms(s)))
#define binsertStatic(b,p,s,f) ((binsertblk)((b), (p), bsStaticBlkParms(s), (f)))
#define bjoinStatic(b,s)    ((bjoinblk)((b), bsStaticBlkParms(s)))
#define biseqStatic(b,s)    ((biseqblk)((b), bsStaticBlkParms(s)))
#define bisstemeqStatic(b,s) ((bisstemeqblk)((b), bsStaticBlkParms(s)))
#define biseqcaselessStatic(b,s) ((biseqcaselessblk)((b), bsStaticBlkParms(s)))
#define bisstemeqcaselessStatic(b,s) ((bisstemeqcaselessblk)((b), bsStaticBlkParms(s)))

/* Reference building macros */
#define cstr2tbstr btfromcstr
#define btfromcstr(t,s) {                                            \
    (t).data = (unsigned char *) (s);                                \
    (t).slen = ((t).data) ? ((int) (strlen) ((char *)(t).data)) : 0; \
    (t).mlen = -1;                                                   \
}
#define blk2tbstr(t,s,l) {            \
    (t).data = (unsigned char *) (s); \
    (t).slen = l;                     \
    (t).mlen = -1;                    \
}
#define btfromblk(t,s,l) blk2tbstr(t,s,l)
#define bmid2tbstr(t,b,p,l) {                                                \
    const_bstring bstrtmp_s = (b);                                           \
    if (bstrtmp_s && bstrtmp_s->data && bstrtmp_s->slen >= 0) {              \
        int bstrtmp_left = (p);                                              \
        int bstrtmp_len  = (l);                                              \
        if (bstrtmp_left < 0) {                                              \
            bstrtmp_len += bstrtmp_left;                                     \
            bstrtmp_left = 0;                                                \
        }                                                                    \
        if (bstrtmp_len > bstrtmp_s->slen - bstrtmp_left)                    \
            bstrtmp_len = bstrtmp_s->slen - bstrtmp_left;                    \
        if (bstrtmp_len <= 0) {                                              \
            (t).data = (unsigned char *)"";                                  \
            (t).slen = 0;                                                    \
        } else {                                                             \
            (t).data = bstrtmp_s->data + bstrtmp_left;                       \
            (t).slen = bstrtmp_len;                                          \
        }                                                                    \
    } else {                                                                 \
        (t).data = (unsigned char *)"";                                      \
        (t).slen = 0;                                                        \
    }                                                                        \
    (t).mlen = -__LINE__;                                                    \
}
#define btfromblkltrimws(t,s,l) {                                            \
    int bstrtmp_idx = 0, bstrtmp_len = (l);                                  \
    unsigned char * bstrtmp_s = (s);                                         \
    if (bstrtmp_s && bstrtmp_len >= 0) {                                     \
        for (; bstrtmp_idx < bstrtmp_len; bstrtmp_idx++) {                   \
            if (!isspace (bstrtmp_s[bstrtmp_idx])) break;                    \
        }                                                                    \
    }                                                                        \
    (t).data = bstrtmp_s + bstrtmp_idx;                                      \
    (t).slen = bstrtmp_len - bstrtmp_idx;                                    \
    (t).mlen = -__LINE__;                                                    \
}
#define btfromblkrtrimws(t,s,l) {                                            \
    int bstrtmp_len = (l) - 1;                                               \
    unsigned char * bstrtmp_s = (s);                                         \
    if (bstrtmp_s && bstrtmp_len >= 0) {                                     \
        for (; bstrtmp_len >= 0; bstrtmp_len--) {                            \
            if (!isspace (bstrtmp_s[bstrtmp_len])) break;                    \
        }                                                                    \
    }                                                                        \
    (t).data = bstrtmp_s;                                                    \
    (t).slen = bstrtmp_len + 1;                                              \
    (t).mlen = -__LINE__;                                                    \
}
#define btfromblktrimws(t,s,l) {                                             \
    int bstrtmp_idx = 0, bstrtmp_len = (l) - 1;                              \
    unsigned char * bstrtmp_s = (s);                                         \
    if (bstrtmp_s && bstrtmp_len >= 0) {                                     \
        for (; bstrtmp_idx <= bstrtmp_len; bstrtmp_idx++) {                  \
            if (!isspace (bstrtmp_s[bstrtmp_idx])) break;                    \
        }                                                                    \
        for (; bstrtmp_len >= bstrtmp_idx; bstrtmp_len--) {                  \
            if (!isspace (bstrtmp_s[bstrtmp_len])) break;                    \
        }                                                                    \
    }                                                                        \
    (t).data = bstrtmp_s + bstrtmp_idx;                                      \
    (t).slen = bstrtmp_len + 1 - bstrtmp_idx;                                \
    (t).mlen = -__LINE__;                                                    \
}

/* Write protection macros */
#define bwriteprotect(t)     { if ((t).mlen >=  0) (t).mlen = -1; }
#define bwriteallow(t)       { if ((t).mlen == -1) (t).mlen = (t).slen + ((t).slen == 0); }
#define biswriteprotected(t) ((t).mlen <= 0)

#ifdef __cplusplus
}
#endif

#endif

```

`efiXloader/3rd/uefitool/common/bstrlib/bstrwrap.cpp`:

```cpp
/*
 * This source file is part of the bstring string library.  This code was
 * written by Paul Hsieh in 2002-2015, and is covered by the BSD open source
 * license and the GPL. Refer to the accompanying documentation for details
 * on usage and license.
 */

/*
 * bstrwrap.c
 *
 * This file is the C++ wrapper for the bstring functions.
 */

#if defined (_MSC_VER)
# define _CRT_SECURE_NO_WARNINGS
#endif

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdarg.h>
#include <limits.h>
#include "bstrwrap.h"

#if defined(MEMORY_DEBUG) || defined(BSTRLIB_MEMORY_DEBUG)
#include "memdbg.h"
#endif

#ifndef bstr__alloc
#define bstr__alloc(x) malloc (x)
#endif

#ifndef bstr__free
#define bstr__free(p) free (p)
#endif

#ifndef bstr__realloc
#define bstr__realloc(p,x) realloc ((p), (x))
#endif

#ifndef bstr__memcpy
#define bstr__memcpy(d,s,l) memcpy ((d), (s), (l))
#endif

#ifndef bstr__memmove
#define bstr__memmove(d,s,l) memmove ((d), (s), (l))
#endif

#ifndef bstr__memset
#define bstr__memset(d,c,l) memset ((d), (c), (l))
#endif

#ifndef bstr__memcmp
#define bstr__memcmp(d,c,l) memcmp ((d), (c), (l))
#endif

#ifndef bstr__memchr
#define bstr__memchr(s,c,l) memchr ((s), (c), (l))
#endif

#if defined(BSTRLIB_CAN_USE_IOSTREAM)
#include <iostream>
#endif

namespace Bstrlib {

// Constructors.

CBString::CBString () {
	slen = 0;
	mlen = 8;
	data = (unsigned char *) bstr__alloc (mlen);
	if (!data) {
		mlen = 0;
		bstringThrow ("Failure in default constructor");
	} else {
		data[0] = '\0';
	}
}

CBString::CBString (const void * blk, int len) { 
	data = NULL;
	if (len >= 0) {
		mlen = len + 1;
		slen = len;
		data = (unsigned char *) bstr__alloc (mlen);
	}
	if (!data) {
		mlen = slen = 0;
		bstringThrow ("Failure in block constructor");
	} else {
		if (slen > 0) bstr__memcpy (data, blk, slen);
		data[slen] = '\0';
	}
}

CBString::CBString (char c, int len) {
	data = NULL;
	if (len >= 0) {
		mlen = len + 1;
		slen = len;
		data = (unsigned char *) bstr__alloc (mlen);
	}
	if (!data) {
		mlen = slen = 0;
		bstringThrow ("Failure in repeat(char) constructor");
	} else {
		if (slen > 0) bstr__memset (data, c, slen);
		data[slen] = '\0';
	}
}

CBString::CBString (char c) {
	mlen = 2;
	slen = 1;
	if (NULL == (data = (unsigned char *) bstr__alloc (mlen))) {
		mlen = slen = 0;
		bstringThrow ("Failure in (char) constructor");
	} else {
		data[0] = (unsigned char) c;
		data[1] = '\0';
	}
}

CBString::CBString (unsigned char c) {
	mlen = 2;
	slen = 1;
	if (NULL == (data = (unsigned char *) bstr__alloc (mlen))) {
		mlen = slen = 0;
		bstringThrow ("Failure in (char) constructor");
	} else {
		data[0] = c;
		data[1] = '\0';
	}
}

CBString::CBString (const char *s) {
	if (s) {
		size_t sslen = strlen (s);
		if (sslen >= INT_MAX) bstringThrow ("Failure in (char *) constructor, string too large")
		slen = (int) sslen;
		mlen = slen + 1;
		if (NULL != (data = (unsigned char *) bstr__alloc (mlen))) {
			bstr__memcpy (data, s, mlen);
			return;
		}
	}
	data = NULL;
	bstringThrow ("Failure in (char *) constructor");
}

CBString::CBString (int len, const char *s) {
	if (s) {
		size_t sslen = strlen (s);
		if (sslen >= INT_MAX) bstringThrow ("Failure in (char *) constructor, string too large")
		slen = (int) sslen;
		mlen = slen + 1;
		if (mlen < len) mlen = len;
		if (NULL != (data = (unsigned char *) bstr__alloc (mlen))) {
			bstr__memcpy (data, s, slen + 1);
			return;
		}
	}
	data = NULL;
	bstringThrow ("Failure in (int len, char *) constructor");
}

CBString::CBString (const CBString& b) {
	slen = b.slen;
	mlen = slen + 1;
	data = NULL;
	if (mlen > 0) data = (unsigned char *) bstr__alloc (mlen);
	if (!data) {
		bstringThrow ("Failure in (CBString) constructor");
	} else {
		bstr__memcpy (data, b.data, slen);
		data[slen] = '\0';
	}
}

CBString::CBString (const tagbstring& x) {
	slen = x.slen;
	mlen = slen + 1;
	data = NULL;
	if (slen >= 0 && x.data != NULL) data = (unsigned char *) bstr__alloc (mlen);
	if (!data) {
		bstringThrow ("Failure in (tagbstring) constructor");
	} else {
		bstr__memcpy (data, x.data, slen);
		data[slen] = '\0';
	}
}

// Destructor.

CBString::~CBString () {
	if (data != NULL) {
		bstr__free (data);
		data = NULL;
	}
	mlen = 0;
	slen = -__LINE__;
}

// = operator.

const CBString& CBString::operator = (char c) {
	if (mlen <= 0) bstringThrow ("Write protection error");
	if (2 >= mlen) alloc (2);
	if (!data) {
		mlen = slen = 0;
		bstringThrow ("Failure in =(char) operator");
	} else {
		slen = 1;
		data[0] = (unsigned char) c;
		data[1] = '\0';
	}
	return *this;
}

const CBString& CBString::operator = (unsigned char c) {
	if (mlen <= 0) bstringThrow ("Write protection error");
	if (2 >= mlen) alloc (2);
	if (!data) {
		mlen = slen = 0;
		bstringThrow ("Failure in =(char) operator");
	} else {
		slen = 1;
		data[0] = c;
		data[1] = '\0';
	}
	return *this;
}

const CBString& CBString::operator = (const char *s) {
size_t tmpSlen;

	if (mlen <= 0) bstringThrow ("Write protection error");
	if (NULL == s) s = "";
	if ((tmpSlen = strlen (s)) >= (size_t) mlen) {
		if (tmpSlen >= INT_MAX-1) bstringThrow ("Failure in =(const char *) operator, string too large");
		alloc ((int) tmpSlen);
	}

	if (data) {
		slen = (int) tmpSlen;
		bstr__memcpy (data, s, tmpSlen + 1);
	} else {
		mlen = slen = 0;
		bstringThrow ("Failure in =(const char *) operator");
	}
	return *this;
}

const CBString& CBString::operator = (const CBString& b) {
	if (mlen <= 0) bstringThrow ("Write protection error");
	if (b.slen >= mlen) alloc (b.slen);

	slen = b.slen;
	if (!data) {
		mlen = slen = 0;
		bstringThrow ("Failure in =(CBString) operator");
	} else {
		bstr__memcpy (data, b.data, slen);
		data[slen] = '\0';
	}
	return *this;
}

const CBString& CBString::operator = (const tagbstring& x) {
	if (mlen <= 0) bstringThrow ("Write protection error");
	if (x.slen < 0) bstringThrow ("Failure in =(tagbstring) operator, badly formed tagbstring");
	if (x.slen >= mlen) alloc (x.slen);

	slen = x.slen;
	if (!data) {
		mlen = slen = 0;
		bstringThrow ("Failure in =(tagbstring) operator");
	} else {
		bstr__memcpy (data, x.data, slen);
		data[slen] = '\0';
	}
	return *this;
}

const CBString& CBString::operator += (const CBString& b) {
	if (BSTR_ERR == bconcat (this, (bstring) &b)) {
		bstringThrow ("Failure in concatenate");
	}
	return *this;
}

const CBString& CBString::operator += (const char *s) {
	char * d;
	int i, l;

	if (mlen <= 0) bstringThrow ("Write protection error");

	/* Optimistically concatenate directly */
	l = mlen - slen;
	d = (char *) &data[slen];
	for (i=0; i < l; i++) {
		if ((*d++ = *s++) == '\0') {
			slen += i;
			return *this;
		}
	}
	slen += i;

	if (BSTR_ERR == bcatcstr (this, s)) {
		bstringThrow ("Failure in concatenate");
	}
	return *this;
}

const CBString& CBString::operator += (char c) {
	if (BSTR_ERR == bconchar (this, c)) {
		bstringThrow ("Failure in concatenate");
	}
	return *this;
}

const CBString& CBString::operator += (unsigned char c) {
	if (BSTR_ERR == bconchar (this, (char) c)) {
		bstringThrow ("Failure in concatenate");
	}
	return *this;
}

const CBString& CBString::operator += (const tagbstring& x) {
	if (mlen <= 0) bstringThrow ("Write protection error");
	if (x.slen < 0) bstringThrow ("Failure in +=(tagbstring) operator, badly formed tagbstring");
	alloc (x.slen + slen + 1);

	if (!data) {
		mlen = slen = 0;
		bstringThrow ("Failure in +=(tagbstring) operator");
	} else {
		bstr__memcpy (data + slen, x.data, x.slen);
		slen += x.slen;
		data[slen] = '\0';
	}
	return *this;
}

const CBString CBString::operator + (char c) const {
	CBString retval (*this);
	retval += c;
	return retval;
}

const CBString CBString::operator + (unsigned char c) const {
	CBString retval (*this);
	retval += c;
	return retval;
}

const CBString CBString::operator + (const CBString& b) const {
	CBString retval (*this);
	retval += b;
	return retval;
}

const CBString CBString::operator + (const char *s) const {
	if (s == NULL) bstringThrow ("Failure in + (char *) operator, NULL");
	CBString retval (*this);
	retval += s;
	return retval;
}

const CBString CBString::operator + (const unsigned char *s) const {
	if (s == NULL) bstringThrow ("Failure in + (unsigned char *) operator, NULL");
	CBString retval (*this);
	retval += (const char *) s;
	return retval;
}

const CBString CBString::operator + (const tagbstring& x) const {
	if (x.slen < 0) bstringThrow ("Failure in + (tagbstring) operator, badly formed tagbstring");
	CBString retval (*this);
	retval += x;
	return retval;
}

bool CBString::operator == (const CBString& b) const {
	int retval;
	if (BSTR_ERR == (retval = biseq ((bstring)this, (bstring)&b))) {
		bstringThrow ("Failure in compare (==)");
	}
	return retval > 0;
}

bool CBString::operator == (const char * s) const {
	int retval;
	if (NULL == s) {
		bstringThrow ("Failure in compare (== NULL)");
	}
	if (BSTR_ERR == (retval = biseqcstr ((bstring) this, s))) {
		bstringThrow ("Failure in compare (==)");
	}
	return retval > 0;
}

bool CBString::operator == (const unsigned char * s) const {
	int retval;
	if (NULL == s) {
		bstringThrow ("Failure in compare (== NULL)");
	}
	if (BSTR_ERR == (retval = biseqcstr ((bstring) this, (const char *) s))) {
		bstringThrow ("Failure in compare (==)");
	}
	return retval > 0;
}

bool CBString::operator != (const CBString& b) const {
	return ! ((*this) == b);
}

bool CBString::operator != (const char * s) const {
	return ! ((*this) == s);
}

bool CBString::operator != (const unsigned char * s) const {
	return ! ((*this) == s);
}

bool CBString::operator < (const CBString& b) const {
	int retval;
	if (SHRT_MIN == (retval = bstrcmp ((bstring) this, (bstring)&b))) {
		bstringThrow ("Failure in compare (<)");
	}
	return retval < 0;
}

bool CBString::operator < (const char * s) const {
	if (s == NULL) {
		bstringThrow ("Failure in compare (<)");
	}
	return strcmp ((const char *)this->data, s) < 0;
}

bool CBString::operator < (const unsigned char * s) const {
	if (s == NULL) {
		bstringThrow ("Failure in compare (<)");
	}
	return strcmp ((const char *)this->data, (const char *)s) < 0;
}

bool CBString::operator <= (const CBString& b) const {
	int retval;
	if (SHRT_MIN == (retval = bstrcmp ((bstring) this, (bstring)&b))) {
		bstringThrow ("Failure in compare (<=)");
	}
	return retval <= 0;
}

bool CBString::operator <= (const char * s) const {
	if (s == NULL) {
		bstringThrow ("Failure in compare (<=)");
	}
	return strcmp ((const char *)this->data, s) <= 0;
}

bool CBString::operator <= (const unsigned char * s) const {
	if (s == NULL) {
		bstringThrow ("Failure in compare (<=)");
	}
	return strcmp ((const char *)this->data, (const char *)s) <= 0;
}

bool CBString::operator > (const CBString& b) const {
	return ! ((*this) <= b);
}

bool CBString::operator > (const char * s) const {
	return ! ((*this) <= s);
}

bool CBString::operator > (const unsigned char * s) const {
	return ! ((*this) <= s);
}

bool CBString::operator >= (const CBString& b) const {
	return ! ((*this) < b);
}

bool CBString::operator >= (const char * s) const {
	return ! ((*this) < s);
}

bool CBString::operator >= (const unsigned char * s) const {
	return ! ((*this) < s);
}

CBString::operator double () const {
double d = 0;
	if (1 != sscanf ((const char *)this->data, "%lf", &d)) {
		bstringThrow ("Unable to convert to a double");
	}
	return d;
}

CBString::operator float () const {
float d = 0;
	if (1 != sscanf ((const char *)this->data, "%f", &d)) {
		bstringThrow ("Unable to convert to a float");
	}
	return d;
}

CBString::operator int () const {
int d = 0;
	if (1 != sscanf ((const char *)this->data, "%d", &d)) {
		bstringThrow ("Unable to convert to an int");
	}
	return d;
}

CBString::operator unsigned int () const {
unsigned int d = 0;
	if (1 != sscanf ((const char *)this->data, "%u", &d)) {
		bstringThrow ("Unable to convert to an unsigned int");
	}
	return d;
}

#ifdef __TURBOC__
# ifndef BSTRLIB_NOVSNP
#  define BSTRLIB_NOVSNP
# endif
#endif

/* Give WATCOM C/C++, MSVC some latitude for their non-support of vsnprintf */
#if defined(__WATCOMC__) || defined(_MSC_VER)
#define exvsnprintf(r,b,n,f,a) {r = _vsnprintf (b,n,f,a);}
#else
#ifdef BSTRLIB_NOVSNP
/* This is just a hack.  If you are using a system without a vsnprintf, it is 
   not recommended that bformat be used at all. */
#define exvsnprintf(r,b,n,f,a) {vsprintf (b,f,a); r = -1;}
#define START_VSNBUFF (256)
#else

#if defined (__GNUC__) && !defined (__PPC__)
/* Something is making gcc complain about this prototype not being here, so 
   I've just gone ahead and put it in. */
extern "C" {
extern int vsnprintf (char *buf, size_t count, const char *format, va_list arg);
}
#endif

#define exvsnprintf(r,b,n,f,a) {r = vsnprintf (b,n,f,a);}
#endif
#endif

#ifndef START_VSNBUFF
#define START_VSNBUFF (16)
#endif

/*
 * Yeah I'd like to just call a vformat function or something, but because of
 * the ANSI specified brokeness of the va_* macros, it is actually not 
 * possible to do this correctly.
 */

void CBString::format (const char * fmt, ...) {
	bstring b;
	va_list arglist;
	int r, n;

	if (mlen <= 0) bstringThrow ("Write protection error");
	if (fmt == NULL) {
		*this = "<NULL>";
		bstringThrow ("CBString::format (NULL, ...) is erroneous.");
	} else {

		if ((b = bfromcstr ("")) == NULL) {
#ifdef BSTRLIB_THROWS_EXCEPTIONS
			bstringThrow ("CBString::format out of memory.");
#else
			*this = "<NULL>";
#endif
		} else {
			if ((n = (int) (2 * (strlen) (fmt))) < START_VSNBUFF) n = START_VSNBUFF;
			for (;;) {
				if (BSTR_OK != balloc (b, n + 2)) {
#ifdef BSTRLIB_THROWS_EXCEPTIONS
					bstringThrow ("CBString::format out of memory.");
#else
					b = bformat ("<NULL>");
					break;
#endif
				}

				va_start (arglist, fmt);
				exvsnprintf (r, (char *) b->data, n + 1, fmt, arglist);
				va_end (arglist);

				b->data[n] = '\0';
				b->slen = (int) (strlen) ((char *) b->data);

				if (b->slen < n) break;
				if (r > n) n = r; else n += n;
			}
			*this = *b;
			bdestroy (b);
		}
	}
}

void CBString::formata (const char * fmt, ...) {
	bstring b;
	va_list arglist;
	int r, n;

	if (mlen <= 0) bstringThrow ("Write protection error");
	if (fmt == NULL) {
		*this += "<NULL>";
		bstringThrow ("CBString::formata (NULL, ...) is erroneous.");
	} else {

		if ((b = bfromcstr ("")) == NULL) {
#ifdef BSTRLIB_THROWS_EXCEPTIONS
			bstringThrow ("CBString::format out of memory.");
#else
			*this += "<NULL>";
#endif
		} else {
			if ((n = (int) (2 * (strlen) (fmt))) < START_VSNBUFF) n = START_VSNBUFF;
			for (;;) {
				if (BSTR_OK != balloc (b, n + 2)) {
#ifdef BSTRLIB_THROWS_EXCEPTIONS
					bstringThrow ("CBString::format out of memory.");
#else
					b = bformat ("<NULL>");
					break;
#endif
				}

				va_start (arglist, fmt);
				exvsnprintf (r, (char *) b->data, n + 1, fmt, arglist);
				va_end (arglist);

				b->data[n] = '\0';
				b->slen = (int) (strlen) ((char *) b->data);

				if (b->slen < n) break;
				if (r > n) n = r; else n += n;
			}
			*this += *b;
			bdestroy (b);
		}
	}
}

int CBString::caselessEqual (const CBString& b) const {
int ret;
	if (BSTR_ERR == (ret = biseqcaseless ((bstring) this, (bstring) &b))) {
		bstringThrow ("CBString::caselessEqual Unable to compare");
	}
	return ret;
}

int CBString::caselessCmp (const CBString& b) const {
int ret;
	if (SHRT_MIN == (ret = bstricmp ((bstring) this, (bstring) &b))) {
		bstringThrow ("CBString::caselessCmp Unable to compare");
	}
	return ret;
}

int CBString::find (const CBString& b, int pos) const {
	return binstr ((bstring) this, pos, (bstring) &b);
}

/*
    int CBString::find (const char * b, int pos) const;

    Uses and unrolling and sliding paired indexes character matching.  Since 
    the unrolling is the primary real world impact the true purpose of this 
    algorithm choice is maximize the effectiveness of the unrolling.  The 
    idea is to scan until at least one match of the current indexed character 
    from each string, and then shift indexes of both down by and repeat until 
    the last character form b matches.  When the last character from b 
    matches if the were no mismatches in previous strlen(b) characters then 
    we know we have a full match, otherwise shift both indexes back strlen(b)
    characters and continue.

    In general, if there is any character in b that is not at all in this
    CBString, then this algorithm is O(slen).  The algorithm does not easily
    degenerate into O(slen * strlen(b)) performance except in very uncommon
    situations.  Thus from a real world perspective, the overhead of 
    precomputing suffix shifts in the Boyer-Moore algorithm is avoided, while
    delivering an unrolled matching inner loop most of the time.
 */

int CBString::find (const char * b, int pos) const {
int ii, j;
unsigned char c0;
int i, l;
unsigned char cx;
unsigned char * pdata;

	if (NULL == b) {
#ifdef BSTRLIB_THROWS_EXCEPTIONS
		bstringThrow ("CBString::find NULL.");
#else
		return BSTR_ERR;
#endif
	}

	if ((unsigned int) pos > (unsigned int) slen) return BSTR_ERR;
	if ('\0' == b[0]) return pos;
	if (pos == slen) return BSTR_ERR;
	if ('\0' == b[1]) return find (b[0], pos);

	cx = c0 = (unsigned char) b[0];
	l = slen - 1;

	pdata = data;
	for (ii = -1, i = pos, j = 0; i < l;) {
		/* Unrolled current character test */
		if (cx != pdata[i]) {
			if (cx != pdata[1+i]) {
				i += 2;
				continue;
			}
			i++;
		}

		/* Take note if this is the start of a potential match */
		if (0 == j) ii = i;

		/* Shift the test character down by one */
		j++;
		i++;

		/* If this isn't past the last character continue */
		if ('\0' != (cx = b[j])) continue;

		N0:;

		/* If no characters mismatched, then we matched */
		if (i == ii+j) return ii;

		/* Shift back to the beginning */
		i -= j;
		j = 0;
		cx = c0;
	}

	/* Deal with last case if unrolling caused a misalignment */
	if (i == l && cx == pdata[i] && '\0' == b[j+1]) goto N0;

	return BSTR_ERR;
}

int CBString::caselessfind (const CBString& b, int pos) const {
	return binstrcaseless ((bstring) this, pos, (bstring) &b);
}

int CBString::caselessfind (const char * b, int pos) const {
struct tagbstring t;

	if (NULL == b) {
#ifdef BSTRLIB_THROWS_EXCEPTIONS
		bstringThrow ("CBString::caselessfind NULL.");
#else
		return BSTR_ERR;
#endif
	}

	if ((unsigned int) pos > (unsigned int) slen) return BSTR_ERR;
	if ('\0' == b[0]) return pos;
	if (pos == slen) return BSTR_ERR;

	btfromcstr (t, b);
	return binstrcaseless ((bstring) this, pos, (bstring) &t);
}

int CBString::find (char c, int pos) const {
	if (pos < 0) return BSTR_ERR;
	for (;pos < slen; pos++) {
		if (data[pos] == (unsigned char) c) return pos;
	}
	return BSTR_ERR;
}

int CBString::reversefind (const CBString& b, int pos) const {
	return binstrr ((bstring) this, pos, (bstring) &b);
}

int CBString::reversefind (const char * b, int pos) const {
struct tagbstring t;
	if (NULL == b) {
#ifdef BSTRLIB_THROWS_EXCEPTIONS
		bstringThrow ("CBString::reversefind NULL.");
#else
		return BSTR_ERR;
#endif
	}
	cstr2tbstr (t, b);
	return binstrr ((bstring) this, pos, &t);
}

int CBString::caselessreversefind (const CBString& b, int pos) const {
	return binstrrcaseless ((bstring) this, pos, (bstring) &b);
}

int CBString::caselessreversefind (const char * b, int pos) const {
struct tagbstring t;

	if (NULL == b) {
#ifdef BSTRLIB_THROWS_EXCEPTIONS
		bstringThrow ("CBString::caselessreversefind NULL.");
#else
		return BSTR_ERR;
#endif
	}

	if ((unsigned int) pos > (unsigned int) slen) return BSTR_ERR;
	if ('\0' == b[0]) return pos;
	if (pos == slen) return BSTR_ERR;

	btfromcstr (t, b);
	return binstrrcaseless ((bstring) this, pos, (bstring) &t);
}

int CBString::reversefind (char c, int pos) const {
	if (pos > slen) return BSTR_ERR;
	if (pos == slen) pos--;
	for (;pos >= 0; pos--) {
		if (data[pos] == (unsigned char) c) return pos;
	}
	return BSTR_ERR;
}

int CBString::findchr (const CBString& b, int pos) const {
	return binchr ((bstring) this, pos, (bstring) &b);
}

int CBString::findchr (const char * s, int pos) const {
struct tagbstring t;
	if (NULL == s) {
#ifdef BSTRLIB_THROWS_EXCEPTIONS
		bstringThrow ("CBString::findchr NULL.");
#else
		return BSTR_ERR;
#endif
	}
	cstr2tbstr (t, s);
	return binchr ((bstring) this, pos, (bstring) &t);
}

int CBString::nfindchr (const CBString& b, int pos) const {
	return bninchr ((bstring) this, pos, (bstring) &b);
}

int CBString::nfindchr (const char * s, int pos) const {
struct tagbstring t;
	if (NULL == s) {
#ifdef BSTRLIB_THROWS_EXCEPTIONS
		bstringThrow ("CBString::nfindchr NULL.");
#else
		return BSTR_ERR;
#endif
	}
	cstr2tbstr (t, s);
	return bninchr ((bstring) this, pos, &t);
}

int CBString::reversefindchr (const CBString& b, int pos) const {
	return binchrr ((bstring) this, pos, (bstring) &b);
}

int CBString::reversefindchr (const char * s, int pos) const {
struct tagbstring t;
	if (NULL == s) {
#ifdef BSTRLIB_THROWS_EXCEPTIONS
		bstringThrow ("CBString::reversefindchr NULL.");
#else
		return BSTR_ERR;
#endif
	}
	cstr2tbstr (t, s);
	return binchrr ((bstring) this, pos, &t);
}

int CBString::nreversefindchr (const CBString& b, int pos) const {
	return bninchrr ((bstring) this, pos, (bstring) &b);
}

int CBString::nreversefindchr (const char * s, int pos) const {
struct tagbstring t;
	if (NULL == s) {
#ifdef BSTRLIB_THROWS_EXCEPTIONS
		bstringThrow ("CBString::nreversefindchr NULL.");
#else
		return BSTR_ERR;
#endif
	}
	cstr2tbstr (t, s);
	return bninchrr ((bstring) this, pos, &t);
}

CBString CBString::midstr (int left, int len) const {
struct tagbstring t;
	if (left < 0) {
		len += left;
		left = 0;
	}
	if (len > slen - left) len = slen - left;
	if (len <= 0) return CBString ("");
	blk2tbstr (t, data + left, len);
	return CBString (t);
}

void CBString::alloc (int len) {
	if (BSTR_ERR == balloc ((bstring)this, len)) {
		bstringThrow ("Failure in alloc");
	}
}

void CBString::fill (int len, unsigned char cfill) {
	slen = 0;
	if (BSTR_ERR == bsetstr (this, len, NULL, cfill)) {
		bstringThrow ("Failure in fill");
	}
}

void CBString::setsubstr (int pos, const CBString& b, unsigned char cfill) {
	if (BSTR_ERR == bsetstr (this, pos, (bstring) &b, cfill)) {
		bstringThrow ("Failure in setsubstr");
	}
}

void CBString::setsubstr (int pos, const char * s, unsigned char cfill) {
struct tagbstring t;
	if (NULL == s) {
#ifdef BSTRLIB_THROWS_EXCEPTIONS
		bstringThrow ("setsubstr NULL.");
#else
		return;
#endif
	}
	cstr2tbstr (t, s);
	if (BSTR_ERR == bsetstr (this, pos, &t, cfill)) {
		bstringThrow ("Failure in setsubstr");
	}
}

void CBString::insert (int pos, const CBString& b, unsigned char cfill) {
	if (BSTR_ERR == binsert (this, pos, (bstring) &b, cfill)) {
		bstringThrow ("Failure in insert");
	}
}

void CBString::insert (int pos, const char * s, unsigned char cfill) {
struct tagbstring t;
	if (NULL == s) {
#ifdef BSTRLIB_THROWS_EXCEPTIONS
		bstringThrow ("insert NULL.");
#else
		return;
#endif
	}
	cstr2tbstr (t, s);
	if (BSTR_ERR == binsert (this, pos, &t, cfill)) {
		bstringThrow ("Failure in insert");
	}
}

void CBString::insertchrs (int pos, int len, unsigned char cfill) {
	if (BSTR_ERR == binsertch (this, pos, len, cfill)) {
		bstringThrow ("Failure in insertchrs");
	}
}

void CBString::replace (int pos, int len, const CBString& b, unsigned char cfill) {
	if (BSTR_ERR == breplace (this, pos, len, (bstring) &b, cfill)) {
		bstringThrow ("Failure in replace");
	}
}

void CBString::replace (int pos, int len, const char * s, unsigned char cfill) {
struct tagbstring t;
size_t q;

	if (mlen <= 0) bstringThrow ("Write protection error");
	if (NULL == s || (pos|len) < 0) {
		bstringThrow ("Failure in replace");
	} else {
		if (pos + len >= slen) {
			cstr2tbstr (t, s);
			if (BSTR_ERR == bsetstr (this, pos, &t, cfill)) {
				bstringThrow ("Failure in replace");
			} else if (pos + t.slen < slen) {
				slen = pos + t.slen;
				data[slen] = '\0';
			}
		} else {

			/* Aliasing case */
			if ((unsigned int) (data - (unsigned char *) s) < (unsigned int) slen) {
				replace (pos, len, CBString(s), cfill);
				return;
			}

			if ((q = strlen (s)) > (size_t) len || len < 0) {
				if (slen + q - len >= INT_MAX) bstringThrow ("Failure in replace, result too long.");
				alloc ((int) (slen + q - len));
				if (NULL == data) return;
			}
			if ((int) q != len) bstr__memmove (data + pos + q, data + pos + len, slen - (pos + len));
			bstr__memcpy (data + pos, s, q);
			slen += ((int) q) - len;
			data[slen] = '\0';
		}
	}
}

void CBString::findreplace (const CBString& sfind, const CBString& repl, int pos) {
	if (BSTR_ERR == bfindreplace (this, (bstring) &sfind, (bstring) &repl, pos)) {
		bstringThrow ("Failure in findreplace");
	}
}

void CBString::findreplace (const CBString& sfind, const char * repl, int pos) {
struct tagbstring t;
	if (NULL == repl) {
#ifdef BSTRLIB_THROWS_EXCEPTIONS
		bstringThrow ("findreplace NULL.");
#else
		return;
#endif
	}
	cstr2tbstr (t, repl);
	if (BSTR_ERR == bfindreplace (this, (bstring) &sfind, (bstring) &t, pos)) {
		bstringThrow ("Failure in findreplace");
	}
}

void CBString::findreplace (const char * sfind, const CBString& repl, int pos) {
struct tagbstring t;
	if (NULL == sfind) {
#ifdef BSTRLIB_THROWS_EXCEPTIONS
		bstringThrow ("findreplace NULL.");
#else
		return;
#endif
	}
	cstr2tbstr (t, sfind);
	if (BSTR_ERR == bfindreplace (this, (bstring) &t, (bstring) &repl, pos)) {
		bstringThrow ("Failure in findreplace");
	}
}

void CBString::findreplace (const char * sfind, const char * repl, int pos) {
struct tagbstring t, u;
	if (NULL == repl || NULL == sfind) {
#ifdef BSTRLIB_THROWS_EXCEPTIONS
		bstringThrow ("findreplace NULL.");
#else
		return;
#endif
	}
	cstr2tbstr (t, sfind);
	cstr2tbstr (u, repl);
	if (BSTR_ERR == bfindreplace (this, (bstring) &t, (bstring) &u, pos)) {
		bstringThrow ("Failure in findreplace");
	}
}

void CBString::findreplacecaseless (const CBString& sfind, const CBString& repl, int pos) {
	if (BSTR_ERR == bfindreplacecaseless (this, (bstring) &sfind, (bstring) &repl, pos)) {
		bstringThrow ("Failure in findreplacecaseless");
	}
}

void CBString::findreplacecaseless (const CBString& sfind, const char * repl, int pos) {
struct tagbstring t;
	if (NULL == repl) {
#ifdef BSTRLIB_THROWS_EXCEPTIONS
		bstringThrow ("findreplacecaseless NULL.");
#else
		return;
#endif
	}
	cstr2tbstr (t, repl);
	if (BSTR_ERR == bfindreplacecaseless (this, (bstring) &sfind, (bstring) &t, pos)) {
		bstringThrow ("Failure in findreplacecaseless");
	}
}

void CBString::findreplacecaseless (const char * sfind, const CBString& repl, int pos) {
struct tagbstring t;
	if (NULL == sfind) {
#ifdef BSTRLIB_THROWS_EXCEPTIONS
		bstringThrow ("findreplacecaseless NULL.");
#else
		return;
#endif
	}
	cstr2tbstr (t, sfind);
	if (BSTR_ERR == bfindreplacecaseless (this, (bstring) &t, (bstring) &repl, pos)) {
		bstringThrow ("Failure in findreplacecaseless");
	}
}

void CBString::findreplacecaseless (const char * sfind, const char * repl, int pos) {
struct tagbstring t, u;
	if (NULL == repl || NULL == sfind) {
#ifdef BSTRLIB_THROWS_EXCEPTIONS
		bstringThrow ("findreplacecaseless NULL.");
#else
		return;
#endif
	}
	cstr2tbstr (t, sfind);
	cstr2tbstr (u, repl);
	if (BSTR_ERR == bfindreplacecaseless (this, (bstring) &t, (bstring) &u, pos)) {
		bstringThrow ("Failure in findreplacecaseless");
	}
}

void CBString::remove (int pos, int len) {
	if (BSTR_ERR == bdelete (this, pos, len)) {
		bstringThrow ("Failure in remove");
	}
}

void CBString::trunc (int len) {
	if (len < 0) {
		bstringThrow ("Failure in trunc");
	}
	if (len < slen) {
		slen = len;
		data[len] = '\0';
	}
}

void CBString::ltrim (const CBString& b) {
	int l = nfindchr (b, 0);
	if (l == BSTR_ERR) l = slen;
	remove (0, l);
}

void CBString::rtrim (const CBString& b) {
	int l = nreversefindchr (b, slen - 1);
#if BSTR_ERR != -1
	if (l == BSTR_ERR) l = -1;
#endif
	slen = l + 1;
	if (mlen > slen) data[slen] = '\0';
}

void CBString::toupper () {
	if (BSTR_ERR == btoupper ((bstring) this)) {
		bstringThrow ("Failure in toupper");
	}
}

void CBString::tolower () {
	if (BSTR_ERR == btolower ((bstring) this)) {
		bstringThrow ("Failure in tolower");
	}
}

void CBString::repeat (int count) {
	count *= slen;
	if (count == 0) {
		trunc (0);
		return;
	}
	if (count < 0 || BSTR_ERR == bpattern (this, count)) {
		bstringThrow ("Failure in repeat");
	}
}

int CBString::gets (bNgetc getcPtr, void * parm, char terminator) {
	if (mlen <= 0) bstringThrow ("Write protection error");
	bstring b = bgets (getcPtr, parm, terminator);
	if (b == NULL) {
		slen = 0;
		return -1;
	}
	*this = *b;
	bdestroy (b);
	return 0;
}

int CBString::read (bNread readPtr, void * parm) {
	if (mlen <= 0) bstringThrow ("Write protection error");
	bstring b = bread (readPtr, parm);
	if (b == NULL) {
		slen = 0;
		return -1;
	}
	*this = *b;
	bdestroy (b);
	return 0;
}

const CBString operator + (const char *a, const CBString& b) {
	return CBString(a) + b;
}

const CBString operator + (const unsigned char *a, const CBString& b) {
	return CBString((const char *)a) + b;
}

const CBString operator + (char c, const CBString& b) {
	return CBString(c) + b;
}

const CBString operator + (unsigned char c, const CBString& b) {
	return CBString(c) + b;
}

const CBString operator + (const tagbstring& x, const CBString& b) {
	return CBString(x) + b;
}

void CBString::writeprotect () {
	if (mlen >= 0) mlen = -1;
}

void CBString::writeallow () {
	if (mlen == -1) mlen = slen + (slen == 0);
	else if (mlen < 0) {
		bstringThrow ("Cannot unprotect a constant");
	}
}

#if defined(BSTRLIB_CAN_USE_STL)

// Constructors.

CBString::CBString (const CBStringList& l) {
int c;
size_t i;

	for (c=1, i=0; i < l.size(); i++) {
		c += l.at(i).slen;
	}

	mlen = c;
	slen = 0;
	data = (unsigned char *) bstr__alloc (c);
	if (!data) {
		mlen = slen = 0;
		bstringThrow ("Failure in (CBStringList) constructor");
	} else {
		for (i=0; i < l.size(); i++) {
			*this += l.at(i);
		}
	}
}

CBString::CBString (const struct CBStringList& l, const CBString& sep) {
int c, sl = sep.length ();
size_t i;

	for (c=1, i=0; i < l.size(); i++) {
		c += l.at(i).slen + sl;
	}

	mlen = c;
	slen = 0;
	data = (unsigned char *) bstr__alloc (mlen);
	if (!data) {
		mlen = slen = 0;
		bstringThrow ("Failure in (CBStringList) constructor");
	} else {
		for (i=0; i < l.size(); i++) {
			if (i > 0) *this += sep;
			*this += l.at(i);
		}
	}
}

CBString::CBString (const struct CBStringList& l, char sep) {
int c;
size_t i;

	for (c=1, i=0; i < l.size(); i++) {
		c += l.at(i).slen + 1;
	}

	mlen = c;
	slen = 0;
	data = (unsigned char *) bstr__alloc (mlen);
	if (!data) {
		mlen = slen = 0;
		bstringThrow ("Failure in (CBStringList) constructor");
	} else {
		for (i=0; i < l.size(); i++) {
			if (i > 0) *this += sep;
			*this += l.at(i);
		}
	}
}

CBString::CBString (const struct CBStringList& l, unsigned char sep) {
int c;
size_t i;

	for (c=1, i=0; i < l.size(); i++) {
		c += l.at(i).slen + 1;
	}

	mlen = c;
	slen = 0;
	data = (unsigned char *) bstr__alloc (mlen);
	if (!data) {
		mlen = slen = 0;
		bstringThrow ("Failure in (CBStringList) constructor");
	} else {
		for (i=0; i < l.size(); i++) {
			if (i > 0) *this += sep;
			*this += l.at(i);
		}
	}
}

void CBString::join (const struct CBStringList& l) {
int c;
size_t i;

	if (mlen <= 0) {
		bstringThrow ("Write protection error");
	}

	for (c=1, i=0; i < l.size(); i++) {
		c += l.at(i).slen;
		if (c < 0) bstringThrow ("Failure in (CBStringList) constructor, too long");
	}

	alloc (c);
	slen = 0;
	if (!data) {
		mlen = slen = 0;
		bstringThrow ("Failure in (CBStringList) constructor");
	} else {
		for (i=0; i < l.size(); i++) {
			*this += l.at(i);
		}
	}
}

void CBString::join (const struct CBStringList& l, const CBString& sep) {
int c, sl = sep.length();
size_t i;

	if (mlen <= 0) {
		bstringThrow ("Write protection error");
	}

	for (c=1, i=0; i < l.size(); i++) {
		c += l.at(i).slen + sl;
		if (c < sl) bstringThrow ("Failure in (CBStringList) constructor, too long");
	}

	alloc (c);
	slen = 0;
	if (!data) {
		mlen = slen = 0;
		bstringThrow ("Failure in (CBStringList) constructor");
	} else {
		for (i=0; i < l.size(); i++) {
			if (i > 0) *this += sep;
			*this += l.at(i);
		}
	}
}


void CBString::join (const struct CBStringList& l, char sep) {
int c;
size_t i;

	if (mlen <= 0) {
		bstringThrow ("Write protection error");
	}

	for (c=1, i=0; i < l.size(); i++) {
		c += l.at(i).slen + 1;
		if (c <= 0) bstringThrow ("Failure in (CBStringList) constructor, too long");
	}

	alloc (c);
	slen = 0;
	if (!data) {
		mlen = slen = 0;
		bstringThrow ("Failure in (CBStringList) constructor");
	} else {
		for (i=0; i < l.size(); i++) {
			if (i > 0) *this += sep;
			*this += l.at(i);
		}
	}
}

void CBString::join (const struct CBStringList& l, unsigned char sep) {
int c;
size_t i;

	if (mlen <= 0) {
		bstringThrow ("Write protection error");
	}

	for (c=1, i=0; i < l.size(); i++) {
		c += l.at(i).slen + 1;
		if (c <= 0) bstringThrow ("Failure in (CBStringList) constructor, too long");
	}

	alloc (c);
	slen = 0;
	if (!data) {
		mlen = slen = 0;
		bstringThrow ("Failure in (CBStringList) constructor");
	} else {
		for (i=0; i < l.size(); i++) {
			if (i > 0) *this += sep;
			*this += l.at(i);
		}
	}
}

// Split functions.

void CBStringList::split (const CBString& b, unsigned char splitChar) {
int p, i;

	p = 0;
	do {
		for (i = p; i < b.length (); i++) {
			if (b.character (i) == splitChar) break;
		}
		if (i >= p) this->push_back (CBString (&(b.data[p]), i - p));
		p = i + 1;
	} while (p <= b.length ());
}

void CBStringList::split (const CBString& b, const CBString& s) {
struct { unsigned long content[(1 << CHAR_BIT) / 32]; } chrs;
unsigned char c;
int p, i;

	if (s.length() == 0) bstringThrow ("Null splitstring failure");
	if (s.length() == 1) {
		this->split (b, s.character (0));
	} else {

		for (i=0; i < ((1 << CHAR_BIT) / 32); i++) chrs.content[i] = 0x0;
		for (i=0; i < s.length(); i++) {
			c = s.character (i);
			chrs.content[c >> 5] |= ((long)1) << (c & 31);
		}

		p = 0;
		do {
			for (i = p; i < b.length (); i++) {
				c = b.character (i);
				if (chrs.content[c >> 5] & ((long)1) << (c & 31)) break;
			}
			if (i >= p) this->push_back (CBString (&(b.data[p]), i - p));
			p = i + 1;
		} while (p <= b.length ());
	}
}

void CBStringList::splitstr (const CBString& b, const CBString& s) {
int p, i;

	if (s.length() == 1) {
		this->split (b, s.character (0));
	} else if (s.length() == 0) {
		for (i=0; i < b.length (); i++) {
			this->push_back (CBString (b.data[i]));
		}
	} else {
		for (p=0; (i = b.find (s, p)) >= 0; p = i + s.length ()) {
			this->push_back (b.midstr (p, i - p));
		}
		if (p <= b.length ()) {
			this->push_back (b.midstr (p, b.length () - p));
		}
	}
}

static int streamSplitCb (void * parm, int ofs, const_bstring entry) {
	CBStringList * r = (CBStringList *) parm;
	(void)ofs;
	r->push_back (CBString (*entry));
	return 0;
}

void CBStringList::split (const CBStream& b, const CBString& s) {
	if (0 > bssplitscb (b.m_s, (bstring) &s, streamSplitCb, 
	                    (void *) this)) {
		bstringThrow ("Split bstream failure");
	}
}
 
void CBStringList::split (const CBStream& b, unsigned char splitChar) {
CBString sc (splitChar);
	if (0 > bssplitscb (b.m_s, (bstring) &sc,
	                    streamSplitCb, (void *) this)) {
		bstringThrow ("Split bstream failure");
	}
}

void CBStringList::splitstr (const CBStream& b, const CBString& s) {
	if (0 > bssplitstrcb (b.m_s, (bstring) &s, streamSplitCb, 
	                    (void *) this)) {
		bstringThrow ("Split bstream failure");
	}
}

#endif

#if defined(BSTRLIB_CAN_USE_IOSTREAM)

std::ostream& operator << (std::ostream& sout, CBString b) {
	return sout.write ((const char *)b, b.length());
}

#include <ctype.h>

static int istreamGets (void * parm) {
	char c = '\n';
	((std::istream *)parm)->get(c);
	if (isspace (c)) c = '\n';
	return c;
}

std::istream& operator >> (std::istream& sin, CBString& b) {
	do {
		b.gets ((bNgetc) istreamGets, &sin, '\n');
		if (b.slen > 0 && b.data[b.slen-1] == '\n') b.slen--;
	} while (b.slen == 0 && !sin.eof ());
 	return sin;
}

struct sgetc {
	std::istream * sin;
	char terminator;
};

static int istreamGetc (void * parm) {
	char c = ((struct sgetc *)parm)->terminator;
	((struct sgetc *)parm)->sin->get(c);
	return c;
}

std::istream& getline (std::istream& sin, CBString& b, char terminator) {
struct sgetc parm;
	parm.sin = &sin;
	parm.terminator = terminator;
	b.gets ((bNgetc) istreamGetc, &parm, terminator);
	if (b.slen > 0 && b.data[b.slen-1] == terminator) b.slen--;
 	return sin;
}

#endif

CBStream::CBStream (bNread readPtr, void * parm) {
	m_s = bsopen (readPtr, parm);
}

CBStream::~CBStream () {
	bsclose (m_s);
}

int CBStream::buffLengthSet (int sz) {
	if (sz <= 0) {
		bstringThrow ("buffLengthSet parameter failure");
	}
	return bsbufflength (m_s, sz);
}

int CBStream::buffLengthGet () {
	return bsbufflength (m_s, 0);
}

CBString CBStream::readLine (char terminator) {
	CBString ret("");
	if (0 > bsreadln ((bstring) &ret, m_s, terminator) && eof () < 0) {
		bstringThrow ("Failed readLine");
	}
	return ret;
}

CBString CBStream::readLine (const CBString& terminator) {
	CBString ret("");
	if (0 > bsreadlns ((bstring) &ret, m_s, (bstring) &terminator) && eof () < 0) {
		bstringThrow ("Failed readLine");
	}
	return ret;
}

void CBStream::readLine (CBString& s, char terminator) {
	if (0 > bsreadln ((bstring) &s, m_s, terminator) && eof () < 0) {
		bstringThrow ("Failed readLine");
	}
}

void CBStream::readLine (CBString& s, const CBString& terminator) {
	if (0 > bsreadlns ((bstring) &s, m_s, (bstring) &terminator) && eof () < 0) {
		bstringThrow ("Failed readLine");
	}
}

void CBStream::readLineAppend (CBString& s, char terminator) {
	if (0 > bsreadlna ((bstring) &s, m_s, terminator) && eof () < 0) {
		bstringThrow ("Failed readLineAppend");
	}
}

void CBStream::readLineAppend (CBString& s, const CBString& terminator) {
	if (0 > bsreadlnsa ((bstring) &s, m_s, (bstring) &terminator) && eof () < 0) {
		bstringThrow ("Failed readLineAppend");
	}
}

#define BS_BUFF_SZ (1024)

CBString CBStream::read () {
	CBString ret("");
	while (!bseof (m_s)) {
		if (0 > bsreada ((bstring) &ret, m_s, BS_BUFF_SZ) && eof () < 0) {
			bstringThrow ("Failed read");
		}
	}
	return ret;
}

CBString& CBStream::operator >> (CBString& s) {
	while (!bseof (m_s)) {
		if (0 > bsreada ((bstring) &s, m_s, BS_BUFF_SZ) && eof () < 0) {
			bstringThrow ("Failed read");
		}
	}
	return s;
}

CBString CBStream::read (int n) {
	CBString ret("");
	if (0 > bsread ((bstring) &ret, m_s, n) && eof () < 0) {
		bstringThrow ("Failed read");
	}
	return ret;
}

void CBStream::read (CBString& s) {
	s.slen = 0;
	while (!bseof (m_s)) {
		if (0 > bsreada ((bstring) &s, m_s, BS_BUFF_SZ)) {
			bstringThrow ("Failed read");
		}
	}
}

void CBStream::read (CBString& s, int n) {
	if (0 > bsread ((bstring) &s, m_s, n)) {
		bstringThrow ("Failed read");
	}
}

void CBStream::readAppend (CBString& s) {
	while (!bseof (m_s)) {
		if (0 > bsreada ((bstring) &s, m_s, BS_BUFF_SZ)) {
			bstringThrow ("Failed readAppend");
		}
	}
}

void CBStream::readAppend (CBString& s, int n) {
	if (0 > bsreada ((bstring) &s, m_s, n)) {
		bstringThrow ("Failed readAppend");
	}
}

void CBStream::unread (const CBString& s) {
	if (0 > bsunread (m_s, (bstring) &s)) {
		bstringThrow ("Failed unread");
	}
}

CBString CBStream::peek () const {
	CBString ret ("");
	if (0 > bspeek ((bstring) &ret, m_s)) {
		bstringThrow ("Failed peek");
	}
	return ret;
}

void CBStream::peek (CBString& s) const {
	s.slen = 0;
	if (0 > bspeek ((bstring) &s, m_s)) {
		bstringThrow ("Failed peek");
	}
}

void CBStream::peekAppend (CBString& s) const {
	if (0 > bspeek ((bstring) &s, m_s)) {
		bstringThrow ("Failed peekAppend");
	}
}

int CBStream::eof () const {
	int ret = bseof (m_s);
	if (0 > ret) {
		bstringThrow ("Failed eof");
	}
	return ret;
}

} // namespace Bstrlib

```

`efiXloader/3rd/uefitool/common/bstrlib/bstrwrap.h`:

```h
/*
 * This source file is part of the bstring string library.  This code was
 * written by Paul Hsieh in 2002-2015, and is covered by the BSD open source
 * license and the GPL. Refer to the accompanying documentation for details
 * on usage and license.
 */

/*
 * bstrwrap.h
 *
 * This file is the C++ wrapper for the bstring functions.
 */

#ifndef BSTRWRAP_INCLUDE
#define BSTRWRAP_INCLUDE

/////////////////// Configuration defines //////////////////////////////

// WATCOM C/C++ has broken STL and std::iostream support.  If you have
// ported over STLport, then you can #define BSTRLIB_CAN_USE_STL to use
// the CBStringList class.
#if defined(__WATCOMC__)
#  if !defined (BSTRLIB_CAN_USE_STL) && !defined (BSTRLIB_CANNOT_USE_STL)
#    define BSTRLIB_CANNOT_USE_STL
#  endif
#  if !defined (BSTRLIB_CAN_USE_IOSTREAM) && !defined (BSTRLIB_CANNOT_USE_IOSTREAM)
#    define BSTRLIB_CANNOT_USE_IOSTREAM
#  endif
#endif

// By default it assumed that STL has been installed and works for your
// compiler.  If this is not the case, then #define BSTRLIB_CANNOT_USE_STL
#if !defined (BSTRLIB_CANNOT_USE_STL) && !defined (BSTRLIB_CAN_USE_STL)
#define BSTRLIB_CAN_USE_STL
#endif

// By default it assumed that std::iostream works well with your compiler.  
// If this is not the case, then #define BSTRLIB_CAN_USE_IOSTREAM
#if !defined (BSTRLIB_CANNOT_USE_IOSTREAM) && !defined (BSTRLIB_CAN_USE_IOSTREAM)
#define BSTRLIB_CAN_USE_IOSTREAM
#endif

// By default it is assumed that your compiler can deal with and has enabled
// exception handlling.  If this is not the case then you will need to 
// #define BSTRLIB_DOESNT_THROW_EXCEPTIONS
#if !defined (BSTRLIB_THROWS_EXCEPTIONS) && !defined (BSTRLIB_DOESNT_THROW_EXCEPTIONS)
#define BSTRLIB_THROWS_EXCEPTIONS
#endif

////////////////////////////////////////////////////////////////////////

#include <stdlib.h>
#include "bstrlib.h"
#include "../ubytearray.h"

#ifdef __cplusplus

#if defined(BSTRLIB_CAN_USE_STL)

#if defined(__WATCOMC__)
#pragma warning 604 10
#pragma warning 595 10
#pragma warning 594 10
#pragma warning 549 10
#endif

#include <vector>
#include <string>

#if defined(__WATCOMC__)
#pragma warning 604 9
#pragma warning 595 9
#pragma warning 594 9
#endif

#endif

namespace Bstrlib {

#ifdef BSTRLIB_THROWS_EXCEPTIONS
#if defined(BSTRLIB_CAN_USE_STL)
struct CBStringException : public std::exception {
private:
	std::string msg;
public:
	CBStringException (const std::string inmsg) : msg(inmsg) {}
	virtual ~CBStringException () throw () {}
	virtual const char *what () const throw () { return msg.c_str(); }
};
#else
struct CBStringException {
private:
	char * msg;
	int needToFree;
public:
	CBStringException (const char * inmsg) : needToFree(0) {
		if (inmsg) {
			msg = (char *) malloc (1 + strlen (inmsg));
			if (NULL == msg) msg = "Out of memory";
			else {
				strcpy (msg, inmsg);
				needToFree = 1;
			}
		} else {
			msg = "NULL exception message";
		}
	}
	virtual ~CBStringException () throw () {
		if (needToFree) {
			free (msg);
			needToFree = 0;
			msg = NULL;
		}
	}
	virtual const char *what () const throw () { return msg; }
};
#endif
#define bstringThrow(er) {\
	CBStringException bstr__cppwrapper_exception ("CBString::" er "");\
	throw bstr__cppwrapper_exception;\
}
#else
#define bstringThrow(er) {}
#endif

struct CBString;

#ifdef _MSC_VER
#pragma warning(disable:4512)
#endif

class CBCharWriteProtected {
friend struct CBString;
	private:
	const struct tagbstring& s;
	unsigned int idx;
	CBCharWriteProtected (const struct tagbstring& c, int i) : s(c), idx((unsigned int)i) {
		if (idx >= (unsigned) s.slen) {
			bstringThrow ("character index out of bounds");
		}
	}

	public:

	inline char operator = (char c) {
		if (s.mlen <= 0) {
			bstringThrow ("Write protection error");
		} else {
#ifndef BSTRLIB_THROWS_EXCEPTIONS
			if (idx >= (unsigned) s.slen) return '\0';
#endif
			s.data[idx] = (unsigned char) c;
		}
		return (char) s.data[idx];
	}
	inline unsigned char operator = (unsigned char c) {
		if (s.mlen <= 0) {
			bstringThrow ("Write protection error");
		} else {
#ifndef BSTRLIB_THROWS_EXCEPTIONS
			if (idx >= (unsigned) s.slen) return '\0';
#endif
			s.data[idx] = c;
		}
		return s.data[idx];
	}
	inline operator unsigned char () const {
#ifndef BSTRLIB_THROWS_EXCEPTIONS
		if (idx >= (unsigned) s.slen) return (unsigned char) '\0';
#endif
		return s.data[idx];
	}
};

struct CBString : public tagbstring {

	// Constructors
	CBString ();
	CBString (char c);
	CBString (unsigned char c);
	CBString (const char *s);
	CBString (int len, const char *s);
	CBString (const CBString& b);
	CBString (const tagbstring& x);
	CBString (char c, int len);
	CBString (const void * blk, int len);

#if defined(BSTRLIB_CAN_USE_STL)
	CBString (const struct CBStringList& l);
	CBString (const struct CBStringList& l, const CBString& sep);
	CBString (const struct CBStringList& l, char sep);
	CBString (const struct CBStringList& l, unsigned char sep);
#endif

	// Destructor
#if !defined(BSTRLIB_DONT_USE_VIRTUAL_DESTRUCTOR)
	virtual 
#endif
	~CBString ();

	// = operator
	const CBString& operator = (char c);
	const CBString& operator = (unsigned char c);
	const CBString& operator = (const char *s);
	const CBString& operator = (const CBString& b);
	const CBString& operator = (const tagbstring& x);

	// += operator
	const CBString& operator += (char c);
	const CBString& operator += (unsigned char c);
	const CBString& operator += (const char *s);
	const CBString& operator += (const CBString& b);
	const CBString& operator += (const tagbstring& x);

	// *= operator
	inline const CBString& operator *= (int count) {
		this->repeat (count);
		return *this;
	}

	// + operator
	const CBString operator + (char c) const;
	const CBString operator + (unsigned char c) const;
	const CBString operator + (const unsigned char *s) const;
	const CBString operator + (const char *s) const;
	const CBString operator + (const CBString& b) const;
	const CBString operator + (const tagbstring& x) const;

	// * operator
	inline const CBString operator * (int count) const {
		CBString retval (*this);
		retval.repeat (count);
		return retval;
	}

	// Comparison operators
	bool operator == (const CBString& b) const;
	bool operator == (const char * s) const;
	bool operator == (const unsigned char * s) const;
	bool operator != (const CBString& b) const;
	bool operator != (const char * s) const;
	bool operator != (const unsigned char * s) const;
	bool operator <  (const CBString& b) const;
	bool operator <  (const char * s) const;
	bool operator <  (const unsigned char * s) const;
	bool operator <= (const CBString& b) const;
	bool operator <= (const char * s) const;
	bool operator <= (const unsigned char * s) const;
	bool operator >  (const CBString& b) const;
	bool operator >  (const char * s) const;
	bool operator >  (const unsigned char * s) const;
	bool operator >= (const CBString& b) const;
	bool operator >= (const char * s) const;
	bool operator >= (const unsigned char * s) const;

	// Casts
	inline operator const char* () const { return (const char *)data; }
	inline operator const unsigned char* () const { return (const unsigned char *)data; }
	operator double () const;
	operator float () const;
	operator int () const;
	operator unsigned int () const;

	// Accessors
	inline int length () const {return slen;}

	inline unsigned char character (int i) const {
		if (((unsigned) i) >= (unsigned) slen) {
#ifdef BSTRLIB_THROWS_EXCEPTIONS
			bstringThrow ("character idx out of bounds");
#else
			return '\0';
#endif
		}
		return data[i];
	}
	inline unsigned char operator [] (int i) const { return character(i); }

	inline CBCharWriteProtected character (int i) {
		return CBCharWriteProtected (*this, i);
	}
	inline CBCharWriteProtected operator [] (int i) { return character(i); }

	// Space allocation hint method.
	void alloc (int length);

	// Search methods.
	int caselessEqual (const CBString& b) const;
	int caselessCmp (const CBString& b) const;
	int find (const CBString& b, int pos = 0) const;
	int find (const char * b, int pos = 0) const;
	int caselessfind (const CBString& b, int pos = 0) const;
	int caselessfind (const char * b, int pos = 0) const;
	int find (char c, int pos = 0) const;
	int reversefind (const CBString& b, int pos) const;
	int reversefind (const char * b, int pos) const;
	int caselessreversefind (const CBString& b, int pos) const;
	int caselessreversefind (const char * b, int pos) const;
	int reversefind (char c, int pos) const;
	int findchr (const CBString& b, int pos = 0) const;
	int findchr (const char * s, int pos = 0) const;
	int reversefindchr (const CBString& b, int pos) const;
	int reversefindchr (const char * s, int pos) const;
	int nfindchr (const CBString& b, int pos = 0) const;
	int nfindchr (const char * b, int pos = 0) const;
	int nreversefindchr (const CBString& b, int pos) const;
	int nreversefindchr (const char * b, int pos) const;

	// Search and substitute methods.
	void findreplace (const CBString& find, const CBString& repl, int pos = 0);
	void findreplace (const CBString& find, const char * repl, int pos = 0);
	void findreplace (const char * find, const CBString& repl, int pos = 0);
	void findreplace (const char * find, const char * repl, int pos = 0);
	void findreplacecaseless (const CBString& find, const CBString& repl, int pos = 0);
	void findreplacecaseless (const CBString& find, const char * repl, int pos = 0);
	void findreplacecaseless (const char * find, const CBString& repl, int pos = 0);
	void findreplacecaseless (const char * find, const char * repl, int pos = 0);

	// Extraction method.
	CBString midstr (int left, int len) const;

	// Standard manipulation methods.
	void setsubstr (int pos, const CBString& b, unsigned char fill = ' ');
	void setsubstr (int pos, const char * b, unsigned char fill = ' ');
	void insert (int pos, const CBString& b, unsigned char fill = ' ');
	void insert (int pos, const char * b, unsigned char fill = ' ');
	void insertchrs (int pos, int len, unsigned char fill = ' ');
	void replace (int pos, int len, const CBString& b, unsigned char fill = ' ');
	void replace (int pos, int len, const char * s, unsigned char fill = ' ');
	void remove (int pos, int len);
	void trunc (int len);

	// Miscellaneous methods.
	void format (const char * fmt, ...);
	void formata (const char * fmt, ...);
	void fill (int length, unsigned char fill = ' ');
	void repeat (int count);
	void ltrim (const CBString& b = CBString (bsStaticBlkParms (" \t\v\f\r\n")));
	void rtrim (const CBString& b = CBString (bsStaticBlkParms (" \t\v\f\r\n")));
	inline void trim (const CBString& b = CBString (bsStaticBlkParms (" \t\v\f\r\n"))) {
		rtrim (b);
		ltrim (b);
	}
	void toupper ();
	void tolower ();

	// Write protection methods.
	void writeprotect ();
	void writeallow ();
	inline bool iswriteprotected () const { return mlen <= 0; }

	// Join methods.
#if defined(BSTRLIB_CAN_USE_STL)
	void join (const struct CBStringList& l);
	void join (const struct CBStringList& l, const CBString& sep);
	void join (const struct CBStringList& l, char sep);
	void join (const struct CBStringList& l, unsigned char sep);
#endif

	// CBStream methods
	int gets (bNgetc getcPtr, void * parm, char terminator = '\n');
	int read (bNread readPtr, void * parm);

	// QString compatibility methods
	const char *toLocal8Bit() const { return *this; }
	bool contains(const char *str) { return find(str) >= 0; }
	bool isEmpty() const { return slen == 0; }
	void clear() { *this = ""; }
	CBString left(int len) const { return midstr(0, len); }
	CBString mid(int pos, int len) const { return midstr(pos, len); }
	static CBString fromUtf16(const unsigned short* str) {
		// Naive implementation assuming that only ASCII LE part of UCS2 is used, str may not be aligned.
		CBString msg;
		const char *str8 = reinterpret_cast<const char *>(str);
		while (str8[0]) {
			msg += str8[0];
			str8 += 2;
		}
		return msg;
	}
	CBString leftJustified(int length) { if (length > slen) { return *this + CBString(' ', length - slen); } return *this; }
};
extern const CBString operator + (const char *a, const CBString& b);
extern const CBString operator + (const unsigned char *a, const CBString& b);
extern const CBString operator + (char c, const CBString& b);
extern const CBString operator + (unsigned char c, const CBString& b);
extern const CBString operator + (const tagbstring& x, const CBString& b);
inline const CBString operator * (int count, const CBString& b) {
	CBString retval (b);
	retval.repeat (count);
	return retval;
}

#if defined(BSTRLIB_CAN_USE_IOSTREAM)
extern std::ostream& operator << (std::ostream& sout, CBString b);
extern std::istream& operator >> (std::istream& sin, CBString& b);
extern std::istream& getline (std::istream& sin, CBString& b, char terminator='\n');
#endif

struct CBStream {
friend struct CBStringList;
private:
	struct bStream * m_s;
public:
	CBStream (bNread readPtr, void * parm);
	~CBStream ();
	int buffLengthSet (int sz);
	int buffLengthGet ();
	int eof () const;

	CBString readLine (char terminator);
	CBString readLine (const CBString& terminator);
	void readLine (CBString& s, char terminator);
	void readLine (CBString& s, const CBString& terminator);
	void readLineAppend (CBString& s, char terminator);
	void readLineAppend (CBString& s, const CBString& terminator);

	CBString read ();
	CBString& operator >> (CBString& s);

	CBString read (int n);
	void read (CBString& s);
	void read (CBString& s, int n);
	void readAppend (CBString& s);
	void readAppend (CBString& s, int n);

	void unread (const CBString& s);
	inline CBStream& operator << (const CBString& s) {
		this->unread (s);
		return *this;
	}

	CBString peek () const;
	void peek (CBString& s) const;
	void peekAppend (CBString& s) const;
};

#if defined(BSTRLIB_CAN_USE_STL)
struct CBStringList : public std::vector<CBString> {
	// split a string into a vector of strings.
	void split (const CBString& b, unsigned char splitChar);
	void split (const CBString& b, const CBString& s);
	void splitstr (const CBString& b, const CBString& s);
	void split (const CBStream& b, unsigned char splitChar);
	void split (const CBStream& b, const CBString& s);
	void splitstr (const CBStream& b, const CBString& s);
};
#endif

} // namespace Bstrlib

#if !defined (BSTRLIB_DONT_ASSUME_NAMESPACE)
using namespace Bstrlib;
#endif

#endif
#endif

```

`efiXloader/3rd/uefitool/common/descriptor.cpp`:

```cpp
/* descriptor.cpp

Copyright (c) 2015, Nikolaj Schlej. All rights reserved.
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHWARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
*/

#include "descriptor.h"

// Calculate address of data structure addressed by descriptor address format
// 8 bit base or limit
const UINT8* calculateAddress8(const UINT8* baseAddress, const UINT8 baseOrLimit)
{
    return baseAddress + baseOrLimit * 0x10;
}

// 16 bit base or limit
const UINT8* calculateAddress16(const UINT8* baseAddress, const UINT16 baseOrLimit)
{
    return baseAddress + baseOrLimit * 0x1000;
}

// Calculate offset of region using its base
UINT32 calculateRegionOffset(const UINT16 base)
{
    return base * 0x1000;
}

//Calculate size of region using its base and limit
UINT32 calculateRegionSize(const UINT16 base, const UINT16 limit)
{
    if (limit)
        return (limit + 1 - base) * 0x1000;
    return 0;
}

// Return human-readable chip name for given JEDEC ID
UString jedecIdToUString(UINT8 vendorId, UINT8 deviceId0, UINT8 deviceId1)
{
    UINT32 jedecId = (UINT32)deviceId1 + ((UINT32)deviceId0 << 8) + ((UINT32)vendorId << 16);
    switch (jedecId) {
    // Winbond
    case 0xEF3010: return UString("Winbond W25X05");
    case 0xEF3011: return UString("Winbond W25X10");
    case 0xEF3012: return UString("Winbond W25X20");
    case 0xEF3013: return UString("Winbond W25X40");
    case 0xEF3014: return UString("Winbond W25X80");
    case 0xEF3015: return UString("Winbond W25X16");
    case 0xEF3016: return UString("Winbond W25X32");
    case 0xEF3017: return UString("Winbond W25X64");
    case 0xEF4012: return UString("Winbond W25Q20");
    case 0xEF4013: return UString("Winbond W25Q40");
    case 0xEF4014: return UString("Winbond W25Q80");
    case 0xEF4015: return UString("Winbond W25Q16");
    case 0xEF4016: return UString("Winbond W25Q32");
    case 0xEF4017: return UString("Winbond W25Q64");
    case 0xEF4018: return UString("Winbond W25Q128");
    case 0xEF4019: return UString("Winbond W25Q256");
    case 0xEF6011: return UString("Winbond W25Q10");
    case 0xEF6012: return UString("Winbond W25Q20");
    case 0xEF6013: return UString("Winbond W25Q40");
    case 0xEF6014: return UString("Winbond W25Q80");
    case 0xEF6015: return UString("Winbond W25Q16");
    case 0xEF6016: return UString("Winbond W25Q32");
    case 0xEF6017: return UString("Winbond W25Q64");
    case 0xEF6018: return UString("Winbond W25Q128");
    case 0xEF6019: return UString("Winbond W25Q256");
    case 0xEF7118: return UString("Winbond W25M256");
    case 0xEF7119: return UString("Winbond W25M512");

    // Macronix
    case 0xC22013: return UString("Macronix MX25L40");
    case 0xC22014: return UString("Macronix MX25L80");
    case 0xC22015: return UString("Macronix MX25L16");
    case 0xC22016: return UString("Macronix MX25U16");
    case 0xC22017: return UString("Macronix MX25L64");
    case 0xC22018: return UString("Macronix MX25L128");
    case 0xC22019: return UString("Macronix MX25L256");
    case 0xC2201A: return UString("Macronix MX66L512");
    case 0xC22415: return UString("Macronix MX25L16");
    case 0xC22515: return UString("Macronix MX25L16");
    case 0xC22534: return UString("Macronix MX25U80");
    case 0xC22535: return UString("Macronix MX25U16");
    case 0xC22536: return UString("Macronix MX25U32");
    case 0xC22537: return UString("Macronix MX25U64");
    case 0xC22538: return UString("Macronix MX25U128");
    case 0xC22539: return UString("Macronix MX25U256");
    case 0xC2253A: return UString("Macronix MX25U512");
    case 0xC22617: return UString("Macronix MX25L64");
    case 0xC22618: return UString("Macronix MX25L128");
    case 0xC25E16: return UString("Macronix MX25L32");
    case 0xC29517: return UString("Macronix MX25L64");
    
    // Micron
    case 0x202014: return UString("Micron M25P80");
    case 0x202015: return UString("Micron M25P16");
    case 0x202016: return UString("Micron M25P32");
    case 0x202017: return UString("Micron M25P64");
    case 0x202018: return UString("Micron M25P128");
    case 0x204011: return UString("Micron M45PE10");
    case 0x204012: return UString("Micron M45PE20");
    case 0x204013: return UString("Micron M45PE40");
    case 0x204014: return UString("Micron M45PE80");
    case 0x204015: return UString("Micron M45PE16");
    case 0x207114: return UString("Micron M25PX80");
    case 0x207115: return UString("Micron M25PX16");
    case 0x207116: return UString("Micron M25PX32");
    case 0x207117: return UString("Micron M25PX64");
    case 0x208011: return UString("Micron M25PE10");
    case 0x208012: return UString("Micron M25PE20");
    case 0x208013: return UString("Micron M25PE40");
    case 0x208014: return UString("Micron M25PE80");
    case 0x208015: return UString("Micron M25PE16");
    case 0x20BA15: return UString("Micron N25Q016");
    case 0x20BA16: return UString("Micron N25Q032");
    case 0x20BA17: return UString("Micron N25Q064");
    case 0x20BA18: return UString("Micron N25Q128");
    case 0x20BA19: return UString("Micron N25Q256");
    case 0x20BA20: return UString("Micron N25Q512");
    case 0x20BA21: return UString("Micron N25Q00A");
    case 0x20BB15: return UString("Micron N25Q016");
    case 0x20BB16: return UString("Micron N25Q032");
    case 0x20BB17: return UString("Micron N25Q064");
    case 0x20BB18: return UString("Micron MT25Q128");
    case 0x20BB19: return UString("Micron MT25Q256");
    case 0x20BB20: return UString("Micron MT25Q512");

    // Intel
    case 0x898911: return UString("Intel 25F160S33B8");
    case 0x898912: return UString("Intel 25F320S33B8");
    case 0x898913: return UString("Intel 25F640S33B8");
    case 0x898915: return UString("Intel 25F160S33T8");
    case 0x898916: return UString("Intel 25F320S33T8");
    case 0x898917: return UString("Intel 25F640S33T8");

    // Atmel / Adesto
    case 0x1F3217: return UString("Atmel AT25SF641");
    case 0x1F4216: return UString("Atmel AT25SL321");
    case 0x1F4218: return UString("Atmel AT25SL128A");
    case 0x1F4317: return UString("Atmel AT25SL641");
    case 0x1F4500: return UString("Atmel AT26DF081");
    case 0x1F4501: return UString("Atmel AT26DF081A");
    case 0x1F4502: return UString("Atmel AT25DF081");
    case 0x1F4600: return UString("Atmel AT26DF161");
    case 0x1F4601: return UString("Atmel AT26DF161A");
    case 0x1F4602: return UString("Atmel AT25DF161");
    case 0x1F4700: return UString("Atmel AT25DF321");
    case 0x1F4701: return UString("Atmel AT25DF321A");
    case 0x1F4800: return UString("Atmel AT25DF641");
    case 0x1F7018: return UString("Atmel AT25QF128");
    case 0x1F8600: return UString("Atmel AT25DQ161");
    case 0x1F8800: return UString("Atmel AT25DQ641");

    // Microchip
    case 0xBF2541: return UString("Microchip SST25VF016B");
    case 0xBF254A: return UString("Microchip SST25VF032B");
    case 0xBF258D: return UString("Microchip SST25VF040B");
    case 0xBF258E: return UString("Microchip SST25VF080B");
    case 0xBF254B: return UString("Microchip SST25VF064C");

    // EON / ESMT
    case 0x1C3013: return UString("EON EN25Q40");
    case 0x1C3014: return UString("EON EN25Q80");
    case 0x1C3015: return UString("EON EN25Q16");
    case 0x1C3016: return UString("EON EN25Q32");
    case 0x1C3017: return UString("EON EN25Q64");
    case 0x1C3018: return UString("EON EN25Q128");
    case 0x1C3114: return UString("EON EN25F80");
    case 0x1C3115: return UString("EON EN25F16");
    case 0x1C3116: return UString("EON EN25F32");
    case 0x1C3117: return UString("EON EN25F64");
    case 0x1C3811: return UString("EON EN25S10");
    case 0x1C3812: return UString("EON EN25S20");
    case 0x1C3813: return UString("EON EN25S40");
    case 0x1C3814: return UString("EON EN25S80");
    case 0x1C3815: return UString("EON EN25S16");
    case 0x1C3816: return UString("EON EN25S32");
    case 0x1C3817: return UString("EON EN25S64");
    case 0x1C7014: return UString("EON EN25QH80");
    case 0x1C7015: return UString("EON EN25QH16");
    case 0x1C7016: return UString("EON EN25QH32");
    case 0x1C7017: return UString("EON EN25QH64");
    case 0x1C7018: return UString("EON EN25QH128");
    case 0x1C7019: return UString("EON EN25QH256");

    // GigaDevice
    case 0xC84014: return UString("GigaDevice GD25x80");
    case 0xC84015: return UString("GigaDevice GD25x16");
    case 0xC84016: return UString("GigaDevice GD25x32");
    case 0xC84017: return UString("GigaDevice GD25x64");
    case 0xC84018: return UString("GigaDevice GD25x128");
    case 0xC84019: return UString("GigaDevice GD25x256C");
    case 0xC86017: return UString("GigaDevice GD25Lx64");
    case 0xC86018: return UString("GigaDevice GD25Lx128");
    case 0xC86019: return UString("GigaDevice GD25LQ256C");

    // Fidelix
    case 0xF83215: return UString("Fidelix FM25Q16");
    case 0xF83216: return UString("Fidelix FM25Q32");
    case 0xF83217: return UString("Fidelix FM25Q64");
    case 0xF83218: return UString("Fidelix FM25Q128");

    // Spansion
    case 0x014015: return UString("Spansion S25FL116K");
    case 0x014016: return UString("Spansion S25FL132K");
    case 0x014017: return UString("Spansion S25FL164K");
        
    // AMIC Technology
    case 0x373015: return UString("AMIC A25L016");
    case 0x373016: return UString("AMIC A25L032");
    case 0x374015: return UString("AMIC A25LQ16");
    case 0x374016: return UString("AMIC A25LQ32A");

    // PMC
    case 0x9DF713: return UString("PMC Pm25LV080B");
    case 0x9DF714: return UString("PMC Pm25LV016B");
    case 0x9DF744: return UString("PMC Pm25LQ080C");
    case 0x9DF745: return UString("PMC Pm25LQ016C");
    case 0x9DF746: return UString("PMC Pm25LQ032C");
    case 0x9DF77B: return UString("PMC Pm25LV512A");
    case 0x9DF77C: return UString("PMC Pm25LV010A");
    case 0x9DF77D: return UString("PMC Pm25LV020");
    case 0x9DF77E: return UString("PMC Pm25LV040");

    // ISSI
    case 0x9D6014: return UString("ISSI Ix25LP080");
    case 0x9D6015: return UString("ISSI Ix25LP016");
    case 0x9D6016: return UString("ISSI Ix25LP032");
    case 0x9D6017: return UString("ISSI Ix25LP064");
    case 0x9D6018: return UString("ISSI Ix25LP128");
    case 0x9D6019: return UString("ISSI Ix25LP256");
    case 0x9D7014: return UString("ISSI Ix25WP080");
    case 0x9D7015: return UString("ISSI Ix25WP016");
    case 0x9D7016: return UString("ISSI Ix25WP032");
    case 0x9D7017: return UString("ISSI Ix25WP064");
    case 0x9D7018: return UString("ISSI Ix25WP128");
    case 0x9D7019: return UString("ISSI Ix25WP256");
    }

    return UString("Unknown");
}

```

`efiXloader/3rd/uefitool/common/descriptor.h`:

```h
/* descriptor.h

Copyright (c) 2016, Nikolaj Schlej. All rights reserved.
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHWARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
*/

#ifndef DESCRIPTOR_H
#define DESCRIPTOR_H

#include "basetypes.h"
#include "ustring.h"
#include "ubytearray.h"

// Make sure we use right packing rules
#pragma pack(push,1)

// Flash descriptor header
typedef struct FLASH_DESCRIPTOR_HEADER_ {
    UINT8  ReservedVector[16];     // Reserved for ARM ResetVector, 0xFFs on x86/x86-64 machines
    UINT32 Signature;              // 0x0FF0A55A
} FLASH_DESCRIPTOR_HEADER;

// Flash descriptor signature
#define FLASH_DESCRIPTOR_SIGNATURE 0x0FF0A55A

// Descriptor region size
#define FLASH_DESCRIPTOR_SIZE      0x1000

// Maximum base value in descriptor map
#define FLASH_DESCRIPTOR_MAX_BASE  0xE0

// Descriptor version was reserved in older firmware
#define FLASH_DESCRIPTOR_VERSION_INVALID 0xFFFFFFFF
// The only known version found in Coffee Lake
#define FLASH_DESCRIPTOR_VERSION_MAJOR   1
#define FLASH_DESCRIPTOR_VERSION_MINOR   0

// Descriptor version present in Coffee Lake and newer
typedef struct _FLASH_DESCRIPTOR_VERSION {
    UINT32 Reserved : 14;
    UINT32 Minor : 7;
    UINT32 Major : 11;
} FLASH_DESCRIPTOR_VERSION;

// Descriptor map
// Base fields are storing bits [11:4] of actual base addresses, all other bits are 0
typedef struct FLASH_DESCRIPTOR_MAP_ {
    // FLMAP0
    UINT32 ComponentBase : 8;
    UINT32 NumberOfFlashChips : 2;      // Zero-based number of flash chips installed on board
    UINT32 : 6;
    UINT32 RegionBase : 8;
    UINT32 NumberOfRegions : 3;         // Reserved in v2 descriptor
    UINT32 : 5;
    // FLMAP 1
    UINT32 MasterBase : 8;
    UINT32 NumberOfMasters : 2;         // Zero-based number of flash masters
    UINT32 : 6;
    UINT32 PchStrapsBase : 8;
    UINT32 NumberOfPchStraps : 8;       // One-based number of UINT32s to read as PCH straps, min=0, max=255 (1 Kb)
    // FLMAP 2
    UINT32 ProcStrapsBase : 8;
    UINT32 NumberOfProcStraps : 8;      // One-based number of UINT32s to read as processor straps, min=0, max=255 (1 Kb)
    UINT32 : 16;
    // FLMAP 3
    UINT32 DescriptorVersion;           // Reserved prior to Coffee Lake
} FLASH_DESCRIPTOR_MAP;

// Component section
// Flash parameters DWORD structure
typedef struct FLASH_PARAMETERS_ {
    UINT8 FirstChipDensity : 4;
    UINT8 SecondChipDensity : 4;
    UINT8 : 8;
    UINT8 : 1;
    UINT8 ReadClockFrequency : 3; // Hardcoded value of 20 Mhz (000b) in v1 descriptors
    UINT8 FastReadEnabled : 1;
    UINT8 FastReadFrequency : 3;
    UINT8 FlashWriteFrequency : 3;
    UINT8 FlashReadStatusFrequency : 3;
    UINT8 DualOutputFastReadSupported : 1;
    UINT8 : 1;
} FLASH_PARAMETERS;

// Flash densities
#define FLASH_DENSITY_512KB   0x00
#define FLASH_DENSITY_1MB     0x01
#define FLASH_DENSITY_2MB     0x02
#define FLASH_DENSITY_4MB     0x03
#define FLASH_DENSITY_8MB     0x04
#define FLASH_DENSITY_16MB    0x05
#define FLASH_DENSITY_32MB    0x06
#define FLASH_DENSITY_64MB    0x07
#define FLASH_DENSITY_UNUSED  0x0F

// Flash frequencies
#define FLASH_FREQUENCY_20MHZ       0x00
#define FLASH_FREQUENCY_33MHZ       0x01
#define FLASH_FREQUENCY_48MHZ       0x02
#define FLASH_FREQUENCY_50MHZ_30MHZ 0x04
#define FLASH_FREQUENCY_17MHZ       0x06

// Component section structure
typedef struct FLASH_DESCRIPTOR_COMPONENT_SECTION_ {
    FLASH_PARAMETERS FlashParameters;
    UINT8            InvalidInstruction0;  // Instructions for SPI chip, that must not be executed, like FLASH ERASE
    UINT8            InvalidInstruction1;  //
    UINT8            InvalidInstruction2;  //
    UINT8            InvalidInstruction3;  //
    UINT16           PartitionBoundary;    // Upper 16 bit of partition boundary address. Default is 0x0000, which makes the boundary to be 0x00001000
    UINT16 : 16;
} FLASH_DESCRIPTOR_COMPONENT_SECTION;

// Region section
// All base and limit register are storing upper part of actual UINT32 base and limit
// If limit is zero - region is not present
typedef struct FLASH_DESCRIPTOR_REGION_SECTION_ {
    UINT16 DescriptorBase;             // Descriptor
    UINT16 DescriptorLimit;            //
    UINT16 BiosBase;                   // BIOS
    UINT16 BiosLimit;                  //
    UINT16 MeBase;                     // Management Engine
    UINT16 MeLimit;                    //
    UINT16 GbeBase;                    // Gigabit Ethernet
    UINT16 GbeLimit;                   //
    UINT16 PdrBase;                    // Platform Data
    UINT16 PdrLimit;                   //
    UINT16 DevExp1Base;                // Device Expansion 1
    UINT16 DevExp1Limit;               //
    UINT16 Bios2Base;                  // Secondary BIOS
    UINT16 Bios2Limit;                 //
    UINT16 MicrocodeBase;              // CPU microcode
    UINT16 MicrocodeLimit;             //
    UINT16 EcBase;                     // Embedded Controller
    UINT16 EcLimit;                    //
    UINT16 DevExp2Base;                // Device Expansion 2
    UINT16 DevExp2Limit;               //
    UINT16 IeBase;                     // Innovation Engine
    UINT16 IeLimit;                    //
    UINT16 Tgbe1Base;                  // 10 Gigabit Ethernet 1
    UINT16 Tgbe1Limit;                 //
    UINT16 Tgbe2Base;                  // 10 Gigabit Ethernet 2
    UINT16 Tgbe2Limit;                 //
    UINT16 Reserved1Base;              // Reserved 1
    UINT16 Reserved1Limit;             //
    UINT16 Reserved2Base;              // Reserved 2
    UINT16 Reserved2Limit;             //
    UINT16 PttBase;                    // Platform Trust Technology
    UINT16 PttLimit;                   //
} FLASH_DESCRIPTOR_REGION_SECTION;

// Master section
typedef struct FLASH_DESCRIPTOR_MASTER_SECTION_ {
    UINT16 BiosId;
    UINT8 BiosRead;
    UINT8 BiosWrite;
    UINT16 MeId;
    UINT8 MeRead;
    UINT8 MeWrite;
    UINT16 GbeId;
    UINT8 GbeRead;
    UINT8 GbeWrite;
} FLASH_DESCRIPTOR_MASTER_SECTION;

// Master section v2 (Skylake+)
typedef struct FLASH_DESCRIPTOR_MASTER_SECTION_V2_ {
    UINT32 : 8;
    UINT32 BiosRead : 12;
    UINT32 BiosWrite : 12;
    UINT32 : 8;
    UINT32 MeRead : 12;
    UINT32 MeWrite : 12;
    UINT32 : 8;
    UINT32 GbeRead : 12;
    UINT32 GbeWrite : 12;
    UINT32 : 32;
    UINT32 : 8;
    UINT32 EcRead : 12;
    UINT32 EcWrite : 12;
} FLASH_DESCRIPTOR_MASTER_SECTION_V2;

// Region access bits in master section
#define FLASH_DESCRIPTOR_REGION_ACCESS_DESC 0x01
#define FLASH_DESCRIPTOR_REGION_ACCESS_BIOS 0x02
#define FLASH_DESCRIPTOR_REGION_ACCESS_ME   0x04
#define FLASH_DESCRIPTOR_REGION_ACCESS_GBE  0x08
#define FLASH_DESCRIPTOR_REGION_ACCESS_PDR  0x10
#define FLASH_DESCRIPTOR_REGION_ACCESS_EC   0x20

// Base address of descriptor upper map
#define FLASH_DESCRIPTOR_UPPER_MAP_BASE 0x0EFC

// Descriptor upper map structure
typedef struct FLASH_DESCRIPTOR_UPPER_MAP_ {
    UINT8 VsccTableBase; // Base address of VSCC Table for ME, bits [11:4]
    UINT8 VsccTableSize; // Counted in UINT32s
    UINT16 ReservedZero; // Still unknown, zero in all descriptors I have seen
} FLASH_DESCRIPTOR_UPPER_MAP;

// VSCC table entry structure
typedef struct VSCC_TABLE_ENTRY_ {
    UINT8   VendorId;          // JEDEC VendorID byte
    UINT8   DeviceId0;         // JEDEC DeviceID first byte
    UINT8   DeviceId1;         // JEDEC DeviceID second byte
    UINT8   ReservedZero;      // Reserved, must be zero
    UINT32  VsccRegisterValue; // VSCC register value
} VSCC_TABLE_ENTRY;

// Base address and size of OEM section
#define FLASH_DESCRIPTOR_OEM_SECTION_BASE 0x0F00
#define FLASH_DESCRIPTOR_OEM_SECTION_SIZE 0x100

// Restore previous packing rules
#pragma pack(pop)

// Calculate address of data structure addressed by descriptor address format
// 8 bit base or limit
extern const UINT8* calculateAddress8(const UINT8* baseAddress, const UINT8 baseOrLimit);
// 16 bit base or limit
extern const UINT8* calculateAddress16(const UINT8* baseAddress, const UINT16 baseOrLimit);

// Calculate offset of region using it's base
extern UINT32 calculateRegionOffset(const UINT16 base);
// Calculate size of region using it's base and limit
extern UINT32 calculateRegionSize(const UINT16 base, const UINT16 limit);

// Return human-readable chip name for given JEDEC ID
extern UString jedecIdToUString(UINT8 vendorId, UINT8 deviceId0, UINT8 deviceId1);

#endif // DESCRIPTOR_H

```

`efiXloader/3rd/uefitool/common/ffs.cpp`:

```cpp
/* ffs.cpp

Copyright (c) 2015, Nikolaj Schlej. All rights reserved.
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHWARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
*/

#include <cstdio>

#include "ffs.h"
#include "guiddatabase.h"

// This is a workaround for the lack of static std::vector initializer before C++11
const UByteArray FFSv2VolumesInt[] = {
    EFI_FIRMWARE_FILE_SYSTEM_GUID,
    EFI_FIRMWARE_FILE_SYSTEM2_GUID,
    EFI_APPLE_AUTHENTICATION_FV_GUID,
    EFI_APPLE_IMMUTABLE_FV_GUID,
    EFI_INTEL_FILE_SYSTEM_GUID,
    EFI_INTEL_FILE_SYSTEM2_GUID,
    EFI_SONY_FILE_SYSTEM_GUID
};
// This number must be updated if the array above is grown
#define FFSv2VolumesIntSize 7
const std::vector<UByteArray> FFSv2Volumes(FFSv2VolumesInt, FFSv2VolumesInt + FFSv2VolumesIntSize);
// Luckily, FFSv3Volumes now only has 1 element
const std::vector<UByteArray> FFSv3Volumes(1, EFI_FIRMWARE_FILE_SYSTEM3_GUID);

const UINT8 ffsAlignmentTable[] =
{ 0, 4, 7, 9, 10, 12, 15, 16 };

const UINT8 ffsAlignment2Table[] =
{ 17, 18, 19, 20, 21, 22, 23, 24 };

VOID uint32ToUint24(UINT32 size, UINT8* ffsSize)
{
    ffsSize[2] = (UINT8)((size) >> 16U);
    ffsSize[1] = (UINT8)((size) >> 8U);
    ffsSize[0] = (UINT8)((size));
}

UINT32 uint24ToUint32(const UINT8* ffsSize)
{
    return (UINT32) ffsSize[0]
    + ((UINT32) ffsSize[1] << 8U)
    + ((UINT32) ffsSize[2] << 16U);
}

UString guidToUString(const EFI_GUID & guid, bool convertToString)
{
    if (convertToString) {
        UString readableName = guidDatabaseLookup(guid);
        if (!readableName.isEmpty())
            return readableName;
    }

    return usprintf("%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X",
        guid.Data1,
        guid.Data2,
        guid.Data3,
        guid.Data4[0],
        guid.Data4[1],
        guid.Data4[2],
        guid.Data4[3],
        guid.Data4[4],
        guid.Data4[5],
        guid.Data4[6],
        guid.Data4[7]);
}


bool ustringToGuid(const UString & str, EFI_GUID & guid)
{
    unsigned long p0;
    unsigned p1, p2, p3, p4, p5, p6, p7, p8, p9, p10;

    int err = std::sscanf(str.toLocal8Bit(), "%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X",
                          &p0, &p1, &p2, &p3, &p4, &p5, &p6, &p7, &p8, &p9, &p10);
    if (err == 0)
        return false;

    guid.Data1 = (UINT32)p0;
    guid.Data2 = (UINT16)p1;
    guid.Data3 = (UINT16)p2;
    guid.Data4[0] = (UINT8)p3;
    guid.Data4[1] = (UINT8)p4;
    guid.Data4[2] = (UINT8)p5;
    guid.Data4[3] = (UINT8)p6;
    guid.Data4[4] = (UINT8)p7;
    guid.Data4[5] = (UINT8)p8;
    guid.Data4[6] = (UINT8)p9;
    guid.Data4[7] = (UINT8)p10;

    return true;
}

UString fileTypeToUString(const UINT8 type)
{
    switch (type) {
        case EFI_FV_FILETYPE_RAW:                   return UString("Raw");
        case EFI_FV_FILETYPE_FREEFORM:              return UString("Freeform");
        case EFI_FV_FILETYPE_SECURITY_CORE:         return UString("SEC core");
        case EFI_FV_FILETYPE_PEI_CORE:              return UString("PEI core");
        case EFI_FV_FILETYPE_DXE_CORE:              return UString("DXE core");
        case EFI_FV_FILETYPE_PEIM:                  return UString("PEI module");
        case EFI_FV_FILETYPE_DRIVER:                return UString("DXE driver");
        case EFI_FV_FILETYPE_COMBINED_PEIM_DRIVER:  return UString("Combined PEI/DXE");
        case EFI_FV_FILETYPE_APPLICATION:           return UString("Application");
        case EFI_FV_FILETYPE_MM:                    return UString("SMM module");
        case EFI_FV_FILETYPE_FIRMWARE_VOLUME_IMAGE: return UString("Volume image");
        case EFI_FV_FILETYPE_COMBINED_MM_DXE:       return UString("Combined SMM/DXE");
        case EFI_FV_FILETYPE_MM_CORE:               return UString("SMM core");
        case EFI_FV_FILETYPE_MM_STANDALONE:         return UString("MM standalone module");
        case EFI_FV_FILETYPE_MM_CORE_STANDALONE:    return UString("MM standalone core");
        case EFI_FV_FILETYPE_PAD:                   return UString("Pad");
        default:                                    return usprintf("Unknown %u", type);
    };
}

UString sectionTypeToUString(const UINT8 type)
{
    switch (type) {
        case EFI_SECTION_COMPRESSION:               return UString("Compressed");
        case EFI_SECTION_GUID_DEFINED:              return UString("GUID defined");
        case EFI_SECTION_DISPOSABLE:                return UString("Disposable");
        case EFI_SECTION_PE32:                      return UString("PE32 image");
        case EFI_SECTION_PIC:                       return UString("PIC image");
        case EFI_SECTION_TE:                        return UString("TE image");
        case EFI_SECTION_DXE_DEPEX:                 return UString("DXE dependency");
        case EFI_SECTION_VERSION:                   return UString("Version");
        case EFI_SECTION_USER_INTERFACE:            return UString("UI");
        case EFI_SECTION_COMPATIBILITY16:           return UString("16-bit image");
        case EFI_SECTION_FIRMWARE_VOLUME_IMAGE:     return UString("Volume image");
        case EFI_SECTION_FREEFORM_SUBTYPE_GUID:     return UString("Freeform subtype GUID");
        case EFI_SECTION_RAW:                       return UString("Raw");
        case EFI_SECTION_PEI_DEPEX:                 return UString("PEI dependency");
        case EFI_SECTION_MM_DEPEX:                  return UString("MM dependency");
        case INSYDE_SECTION_POSTCODE:               return UString("Insyde postcode");
        case PHOENIX_SECTION_POSTCODE:              return UString("Phoenix postcode");
        default:                                    return usprintf("Unknown %u", type);
    }
}

UString bpdtEntryTypeToUString(const UINT16 type)
{
    switch (type) {
        case BPDT_ENTRY_TYPE_OEM_SMIP:           return UString("OEM SMIP");
        case BPDT_ENTRY_TYPE_OEM_RBE:            return UString("CSE RBE");
        case BPDT_ENTRY_TYPE_CSE_BUP:            return UString("CSE BUP");
        case BPDT_ENTRY_TYPE_UCODE:              return UString("uCode");
        case BPDT_ENTRY_TYPE_IBB:                return UString("IBB");
        case BPDT_ENTRY_TYPE_SBPDT:              return UString("S-BPDT");
        case BPDT_ENTRY_TYPE_OBB:                return UString("OBB");
        case BPDT_ENTRY_TYPE_CSE_MAIN:           return UString("CSE Main");
        case BPDT_ENTRY_TYPE_ISH:                return UString("ISH");
        case BPDT_ENTRY_TYPE_CSE_IDLM:           return UString("CSE IDLM");
        case BPDT_ENTRY_TYPE_IFP_OVERRIDE:       return UString("IFP Override");
        case BPDT_ENTRY_TYPE_DEBUG_TOKENS:       return UString("Debug Tokens");
        case BPDT_ENTRY_TYPE_USF_PHY_CONFIG:     return UString("USF Phy Config");
        case BPDT_ENTRY_TYPE_USB_GPP_LUN_ID:     return UString("USF GPP LUN ID");
        case BPDT_ENTRY_TYPE_PMC:                return UString("PMC");
        case BPDT_ENTRY_TYPE_IUNIT:              return UString("iUnit");
        case BPDT_ENTRY_TYPE_NVM_CONFIG:         return UString("NVM Config");
        case BPDT_ENTRY_TYPE_UEP:                return UString("UEP");
        case BPDT_ENTRY_TYPE_WLAN_UCODE:         return UString("WLAN uCode");
        case BPDT_ENTRY_TYPE_LOCL_SPRITES:       return UString("LOCL Sprites");
        case BPDT_ENTRY_TYPE_OEM_KEY_MANIFEST:   return UString("OEM Key Manifest");
        case BPDT_ENTRY_TYPE_DEFAULTS:           return UString("Defaults");
        case BPDT_ENTRY_TYPE_PAVP:               return UString("PAVP");
        case BPDT_ENTRY_TYPE_TCSS_FW_IOM:        return UString("TCSS FW IOM");
        case BPDT_ENTRY_TYPE_TCSS_FW_PHY:        return UString("TCSS FW PHY");
        case BPDT_ENTRY_TYPE_TBT:                return UString("TCSS TBT");
        default:                                 return usprintf("Unknown %u", type);
    }
}

UString cpdExtensionTypeToUstring(const UINT32 type)
{
    switch (type) {
        case CPD_EXT_TYPE_SYSTEM_INFO:               return UString("System Info");
        case CPD_EXT_TYPE_INIT_SCRIPT:               return UString("Init Script");
        case CPD_EXT_TYPE_FEATURE_PERMISSIONS:       return UString("Feature Permissions");
        case CPD_EXT_TYPE_PARTITION_INFO:            return UString("Partition Info");
        case CPD_EXT_TYPE_SHARED_LIB_ATTRIBUTES:     return UString("Shared Lib Attributes");
        case CPD_EXT_TYPE_PROCESS_ATTRIBUTES:        return UString("Process Attributes");
        case CPD_EXT_TYPE_THREAD_ATTRIBUTES:         return UString("Thread Attributes");
        case CPD_EXT_TYPE_DEVICE_TYPE:               return UString("Device Type");
        case CPD_EXT_TYPE_MMIO_RANGE:                return UString("MMIO Range");
        case CPD_EXT_TYPE_SPEC_FILE_PRODUCER:        return UString("Spec File Producer");
        case CPD_EXT_TYPE_MODULE_ATTRIBUTES:         return UString("Module Attributes");
        case CPD_EXT_TYPE_LOCKED_RANGES:             return UString("Locked Ranges");
        case CPD_EXT_TYPE_CLIENT_SYSTEM_INFO:        return UString("Client System Info");
        case CPD_EXT_TYPE_USER_INFO:                 return UString("User Info");
        case CPD_EXT_TYPE_KEY_MANIFEST:              return UString("Key Manifest");
        case CPD_EXT_TYPE_SIGNED_PACKAGE_INFO:       return UString("Signed Package Info");
        case CPD_EXT_TYPE_ANTI_CLONING_SKU_ID:       return UString("Anti-cloning SKU ID");
        case CPD_EXT_TYPE_CAVS:                      return UString("cAVS");
        case CPD_EXT_TYPE_IMR_INFO:                  return UString("IMR Info");
        case CPD_EXT_TYPE_RCIP_INFO:                 return UString("RCIP Info");
        case CPD_EXT_TYPE_BOOT_POLICY:               return UString("Boot Policy");
        case CPD_EXT_TYPE_SECURE_TOKEN:              return UString("Secure Token");
        case CPD_EXT_TYPE_IFWI_PARTITION_MANIFEST:   return UString("IFWI Partition Manifest");
        case CPD_EXT_TYPE_FD_HASH:                   return UString("FD Hash");
        case CPD_EXT_TYPE_IOM_METADATA:              return UString("IOM Metadata");
        case CPD_EXT_TYPE_MGP_METADATA:              return UString("MGP Metadata");
        case CPD_EXT_TYPE_TBT_METADATA:              return UString("TBT Metadata");
        default:                                     return usprintf("Unknown %u", type);
    }
}

```

`efiXloader/3rd/uefitool/common/ffs.h`:

```h
/* ffs.h

Copyright (c) 2016, Nikolaj Schlej. All rights reserved.
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHWARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
*/

#ifndef FFS_H
#define FFS_H

#include <vector>

#include "basetypes.h"
#include "ubytearray.h"
#include "ustring.h"

// Make sure we use right packing rules
#pragma pack(push,1)

extern UString guidToUString(const EFI_GUID& guid, bool convertToString = true);
extern bool ustringToGuid(const UString& str, EFI_GUID& guid);
extern UString fileTypeToUString(const UINT8 type);
extern UString sectionTypeToUString(const UINT8 type);
extern UString bpdtEntryTypeToUString(const UINT16 type);
extern UString cpdExtensionTypeToUstring(const UINT32 type);
//*****************************************************************************
// EFI Capsule
//*****************************************************************************
// Capsule header
typedef struct EFI_CAPSULE_HEADER_ {
    EFI_GUID  CapsuleGuid;
    UINT32    HeaderSize;
    UINT32    Flags;
    UINT32    CapsuleImageSize;
} EFI_CAPSULE_HEADER;

// Capsule flags
#define EFI_CAPSULE_HEADER_FLAG_SETUP                   0x00000001
#define EFI_CAPSULE_HEADER_FLAG_PERSIST_ACROSS_RESET    0x00010000
#define EFI_CAPSULE_HEADER_FLAG_POPULATE_SYSTEM_TABLE   0x00020000

// Standard FMP capsule GUID
const UByteArray EFI_FMP_CAPSULE_GUID // 6DCBD5ED-E82D-4C44-BDA1-7194199AD92A
("\xED\xD5\xCB\x6D\x2D\xE8\x44\x4C\xBD\xA1\x71\x94\x19\x9A\xD9\x2A", 16);

// Standard EFI capsule GUID
const UByteArray EFI_CAPSULE_GUID
("\xBD\x86\x66\x3B\x76\x0D\x30\x40\xB7\x0E\xB5\x51\x9E\x2F\xC5\xA0", 16);

// Intel capsule GUID
const UByteArray INTEL_CAPSULE_GUID
("\xB9\x82\x91\x53\xB5\xAB\x91\x43\xB6\x9A\xE3\xA9\x43\xF7\x2F\xCC", 16);

// Lenovo capsule GUID
const UByteArray LENOVO_CAPSULE_GUID
("\xD3\xAF\x0B\xE2\x14\x99\x4F\x4F\x95\x37\x31\x29\xE0\x90\xEB\x3C", 16);

// Another Lenovo capsule GUID
const UByteArray LENOVO2_CAPSULE_GUID
("\x76\xFE\xB5\x25\x43\x82\x5C\x4A\xA9\xBD\x7E\xE3\x24\x61\x98\xB5", 16);

// Toshiba EFI Capsule header
typedef struct TOSHIBA_CAPSULE_HEADER_ {
    EFI_GUID  CapsuleGuid;
    UINT32    HeaderSize;
    UINT32    FullSize;
    UINT32    Flags;
} TOSHIBA_CAPSULE_HEADER;

// Toshiba capsule GUID
const UByteArray TOSHIBA_CAPSULE_GUID
("\x62\x70\xE0\x3B\x51\x1D\xD2\x45\x83\x2B\xF0\x93\x25\x7E\xD4\x61", 16);

// AMI Aptio extended capsule header
typedef struct APTIO_CAPSULE_HEADER_ {
    EFI_CAPSULE_HEADER    CapsuleHeader;
    UINT16                RomImageOffset;  // offset in bytes from the beginning of the capsule header to the start of the capsule volume
    UINT16                RomLayoutOffset; // offset to the table of the module descriptors in the capsule's volume that are included in the signature calculation
    //FW_CERTIFICATE      FWCert;
    //ROM_AREA            RomAreaMap[1];
} APTIO_CAPSULE_HEADER;

// AMI Aptio signed extended capsule GUID
const UByteArray APTIO_SIGNED_CAPSULE_GUID
("\x8B\xA6\x3C\x4A\x23\x77\xFB\x48\x80\x3D\x57\x8C\xC1\xFE\xC4\x4D", 16);

// AMI Aptio unsigned extended capsule GUID
const UByteArray APTIO_UNSIGNED_CAPSULE_GUID
("\x90\xBB\xEE\x14\x0A\x89\xDB\x43\xAE\xD1\x5D\x3C\x45\x88\xA4\x18", 16);

//*****************************************************************************
// EFI Firmware Volume
//*****************************************************************************
// Firmware block map entry
// FvBlockMap ends with an entry {0x00000000, 0x00000000}
typedef struct EFI_FV_BLOCK_MAP_ENTRY_ {
    UINT32  NumBlocks;
    UINT32  Length;
} EFI_FV_BLOCK_MAP_ENTRY;

// Volume header
typedef struct EFI_FIRMWARE_VOLUME_HEADER_ {
    UINT8                  ZeroVector[16];
    EFI_GUID               FileSystemGuid;
    UINT64                 FvLength;
    UINT32                 Signature;
    UINT32                 Attributes;
    UINT16                 HeaderLength;
    UINT16                 Checksum;
    UINT16                 ExtHeaderOffset;  //Reserved in Revision 1
    UINT8                  Reserved;
    UINT8                  Revision;
    //EFI_FV_BLOCK_MAP_ENTRY FvBlockMap[2];
} EFI_FIRMWARE_VOLUME_HEADER;

// Standard file system GUIDs
const UByteArray EFI_FIRMWARE_FILE_SYSTEM_GUID // 7A9354D9-0468-444A-81CE-0BF617D890DF
("\xD9\x54\x93\x7A\x68\x04\x4A\x44\x81\xCE\x0B\xF6\x17\xD8\x90\xDF", 16);

const UByteArray EFI_FIRMWARE_FILE_SYSTEM2_GUID // 8C8CE578-8A3D-4F1C-9935-896185C32DD3
("\x78\xE5\x8C\x8C\x3D\x8A\x1C\x4F\x99\x35\x89\x61\x85\xC3\x2D\xD3", 16);

const UByteArray EFI_FIRMWARE_FILE_SYSTEM3_GUID // 5473C07A-3DCB-4DCA-BD6F-1E9689E7349A
("\x7A\xC0\x73\x54\xCB\x3D\xCA\x4D\xBD\x6F\x1E\x96\x89\xE7\x34\x9A", 16);

// Vendor-specific file system GUIDs
const UByteArray EFI_APPLE_IMMUTABLE_FV_GUID // 04ADEEAD-61FF-4D31-B6BA-64F8BF901F5A
("\xAD\xEE\xAD\x04\xFF\x61\x31\x4D\xB6\xBA\x64\xF8\xBF\x90\x1F\x5A", 16);

const UByteArray EFI_APPLE_AUTHENTICATION_FV_GUID // BD001B8C-6A71-487B-A14F-0C2A2DCF7A5D
("\x8C\x1B\x00\xBD\x71\x6A\x7B\x48\xA1\x4F\x0C\x2A\x2D\xCF\x7A\x5D", 16);

const UByteArray EFI_APPLE_MICROCODE_VOLUME_GUID // 153D2197-29BD-44DC-AC59-887F70E41A6B
("\x97\x21\x3D\x15\xBD\x29\xDC\x44\xAC\x59\x88\x7F\x70\xE4\x1A\x6B", 16);
#define EFI_APPLE_MICROCODE_VOLUME_HEADER_SIZE 0x100

const UByteArray EFI_INTEL_FILE_SYSTEM_GUID // AD3FFFFF-D28B-44C4-9F13-9EA98A97F9F0
("\xFF\xFF\x3F\xAD\x8B\xD2\xC4\x44\x9F\x13\x9E\xA9\x8A\x97\xF9\xF0", 16);

const UByteArray EFI_INTEL_FILE_SYSTEM2_GUID // D6A1CD70-4B33-4994-A6EA-375F2CCC5437
("\x70\xCD\xA1\xD6\x33\x4B\x94\x49\xA6\xEA\x37\x5F\x2C\xCC\x54\x37", 16);

const UByteArray EFI_SONY_FILE_SYSTEM_GUID // 4F494156-AED6-4D64-A537-B8A5557BCEEC
("\x56\x41\x49\x4F\xD6\xAE\x64\x4D\xA5\x37\xB8\xA5\x55\x7B\xCE\xEC", 16);

// Vector of volume GUIDs with FFSv2-compatible files
extern const std::vector<UByteArray> FFSv2Volumes;

// Vector of volume GUIDs with FFSv3-compatible files
extern const std::vector<UByteArray> FFSv3Volumes;

// Firmware volume signature
#define EFI_FV_SIGNATURE 0x4856465F // _FVH
#define EFI_FV_SIGNATURE_OFFSET 0x28

// Firmware volume attributes
// Revision 1
#define EFI_FVB_READ_DISABLED_CAP   0x00000001
#define EFI_FVB_READ_ENABLED_CAP    0x00000002
#define EFI_FVB_READ_STATUS         0x00000004
#define EFI_FVB_WRITE_DISABLED_CAP  0x00000008
#define EFI_FVB_WRITE_ENABLED_CAP   0x00000010
#define EFI_FVB_WRITE_STATUS        0x00000020
#define EFI_FVB_LOCK_CAP            0x00000040
#define EFI_FVB_LOCK_STATUS         0x00000080
#define EFI_FVB_STICKY_WRITE        0x00000200
#define EFI_FVB_MEMORY_MAPPED       0x00000400
#define EFI_FVB_ERASE_POLARITY      0x00000800
#define EFI_FVB_ALIGNMENT_CAP       0x00008000
#define EFI_FVB_ALIGNMENT_2         0x00010000
#define EFI_FVB_ALIGNMENT_4         0x00020000
#define EFI_FVB_ALIGNMENT_8         0x00040000
#define EFI_FVB_ALIGNMENT_16        0x00080000
#define EFI_FVB_ALIGNMENT_32        0x00100000
#define EFI_FVB_ALIGNMENT_64        0x00200000
#define EFI_FVB_ALIGNMENT_128       0x00400000
#define EFI_FVB_ALIGNMENT_256       0x00800000
#define EFI_FVB_ALIGNMENT_512       0x01000000
#define EFI_FVB_ALIGNMENT_1K        0x02000000
#define EFI_FVB_ALIGNMENT_2K        0x04000000
#define EFI_FVB_ALIGNMENT_4K        0x08000000
#define EFI_FVB_ALIGNMENT_8K        0x10000000
#define EFI_FVB_ALIGNMENT_16K       0x20000000
#define EFI_FVB_ALIGNMENT_32K       0x40000000
#define EFI_FVB_ALIGNMENT_64K       0x80000000
// Revision 2
#define EFI_FVB2_READ_DISABLED_CAP  0x00000001
#define EFI_FVB2_READ_ENABLED_CAP   0x00000002
#define EFI_FVB2_READ_STATUS        0x00000004
#define EFI_FVB2_WRITE_DISABLED_CAP 0x00000008
#define EFI_FVB2_WRITE_ENABLED_CAP  0x00000010
#define EFI_FVB2_WRITE_STATUS       0x00000020
#define EFI_FVB2_LOCK_CAP           0x00000040
#define EFI_FVB2_LOCK_STATUS        0x00000080
#define EFI_FVB2_STICKY_WRITE       0x00000200
#define EFI_FVB2_MEMORY_MAPPED      0x00000400
#define EFI_FVB2_ERASE_POLARITY     0x00000800
#define EFI_FVB2_READ_LOCK_CAP      0x00001000
#define EFI_FVB2_READ_LOCK_STATUS   0x00002000
#define EFI_FVB2_WRITE_LOCK_CAP     0x00004000
#define EFI_FVB2_WRITE_LOCK_STATUS  0x00008000
#define EFI_FVB2_ALIGNMENT          0x001F0000
#define EFI_FVB2_ALIGNMENT_1        0x00000000
#define EFI_FVB2_ALIGNMENT_2        0x00010000
#define EFI_FVB2_ALIGNMENT_4        0x00020000
#define EFI_FVB2_ALIGNMENT_8        0x00030000
#define EFI_FVB2_ALIGNMENT_16       0x00040000
#define EFI_FVB2_ALIGNMENT_32       0x00050000
#define EFI_FVB2_ALIGNMENT_64       0x00060000
#define EFI_FVB2_ALIGNMENT_128      0x00070000
#define EFI_FVB2_ALIGNMENT_256      0x00080000
#define EFI_FVB2_ALIGNMENT_512      0x00090000
#define EFI_FVB2_ALIGNMENT_1K       0x000A0000
#define EFI_FVB2_ALIGNMENT_2K       0x000B0000
#define EFI_FVB2_ALIGNMENT_4K       0x000C0000
#define EFI_FVB2_ALIGNMENT_8K       0x000D0000
#define EFI_FVB2_ALIGNMENT_16K      0x000E0000
#define EFI_FVB2_ALIGNMENT_32K      0x000F0000
#define EFI_FVB2_ALIGNMENT_64K      0x00100000
#define EFI_FVB2_ALIGNMENT_128K     0x00110000
#define EFI_FVB2_ALIGNMENT_256K     0x00120000
#define EFI_FVB2_ALIGNMENT_512K     0x00130000
#define EFI_FVB2_ALIGNMENT_1M       0x00140000
#define EFI_FVB2_ALIGNMENT_2M       0x00150000
#define EFI_FVB2_ALIGNMENT_4M       0x00160000
#define EFI_FVB2_ALIGNMENT_8M       0x00170000
#define EFI_FVB2_ALIGNMENT_16M      0x00180000
#define EFI_FVB2_ALIGNMENT_32M      0x00190000
#define EFI_FVB2_ALIGNMENT_64M      0x001A0000
#define EFI_FVB2_ALIGNMENT_128M     0x001B0000
#define EFI_FVB2_ALIGNMENT_256M     0x001C0000
#define EFI_FVB2_ALIGNMENT_512M     0x001D0000
#define EFI_FVB2_ALIGNMENT_1G       0x001E0000
#define EFI_FVB2_ALIGNMENT_2G       0x001F0000
#define EFI_FVB2_WEAK_ALIGNMENT     0x80000000

// Extended firmware volume header
typedef struct EFI_FIRMWARE_VOLUME_EXT_HEADER_ {
    EFI_GUID          FvName;
    UINT32            ExtHeaderSize;
} EFI_FIRMWARE_VOLUME_EXT_HEADER;

// Extended header entry
// The extended header entries follow each other and are
// terminated by ExtHeaderType EFI_FV_EXT_TYPE_END
#define EFI_FV_EXT_TYPE_END        0x0000
typedef struct EFI_FIRMWARE_VOLUME_EXT_ENTRY_ {
    UINT16  ExtEntrySize;
    UINT16  ExtEntryType;
} EFI_FIRMWARE_VOLUME_EXT_ENTRY;

// GUID that maps OEM file types to GUIDs
#define EFI_FV_EXT_TYPE_OEM_TYPE   0x0001
typedef struct EFI_FIRMWARE_VOLUME_EXT_HEADER_OEM_TYPE_ {
    EFI_FIRMWARE_VOLUME_EXT_ENTRY    Header;
    UINT32                           TypeMask;
    //EFI_GUID                       Types[];
} EFI_FIRMWARE_VOLUME_EXT_HEADER_OEM_TYPE;

#define EFI_FV_EXT_TYPE_GUID_TYPE  0x0002
typedef struct EFI_FIRMWARE_VOLUME_EXT_ENTRY_GUID_TYPE_ {
    EFI_FIRMWARE_VOLUME_EXT_ENTRY Header;
    EFI_GUID FormatType;
    //UINT8 Data[];
} EFI_FIRMWARE_VOLUME_EXT_ENTRY_GUID_TYPE;

//*****************************************************************************
// EFI FFS File
//*****************************************************************************
// Integrity check
typedef union {
    struct {
        UINT8	Header;
        UINT8	File;
    } Checksum;
    UINT16 TailReference;   // Revision 1
    UINT16 Checksum16;      // Revision 2
} EFI_FFS_INTEGRITY_CHECK;
// File header
typedef struct EFI_FFS_FILE_HEADER_ {
    EFI_GUID                Name;
    EFI_FFS_INTEGRITY_CHECK IntegrityCheck;
    UINT8                   Type;
    UINT8                   Attributes;
    UINT8                   Size[3];
    UINT8                   State;
} EFI_FFS_FILE_HEADER;

// Large file header
typedef struct EFI_FFS_FILE_HEADER2_ {
EFI_GUID                Name;
EFI_FFS_INTEGRITY_CHECK IntegrityCheck;
UINT8                   Type;
UINT8                   Attributes;
UINT8                   Size[3]; // Set to 0xFFFFFF
UINT8                   State;
UINT64                  ExtendedSize;
} EFI_FFS_FILE_HEADER2;

// Standard data checksum, used if FFS_ATTRIB_CHECKSUM is clear
#define FFS_FIXED_CHECKSUM   0x5A
#define FFS_FIXED_CHECKSUM2  0xAA

// File types
#define EFI_FV_FILETYPE_ALL                     0x00
#define EFI_FV_FILETYPE_RAW                     0x01
#define EFI_FV_FILETYPE_FREEFORM                0x02
#define EFI_FV_FILETYPE_SECURITY_CORE           0x03
#define EFI_FV_FILETYPE_PEI_CORE                0x04
#define EFI_FV_FILETYPE_DXE_CORE                0x05
#define EFI_FV_FILETYPE_PEIM                    0x06
#define EFI_FV_FILETYPE_DRIVER                  0x07
#define EFI_FV_FILETYPE_COMBINED_PEIM_DRIVER    0x08
#define EFI_FV_FILETYPE_APPLICATION             0x09
#define EFI_FV_FILETYPE_MM                      0x0A
#define EFI_FV_FILETYPE_FIRMWARE_VOLUME_IMAGE   0x0B
#define EFI_FV_FILETYPE_COMBINED_MM_DXE         0x0C
#define EFI_FV_FILETYPE_MM_CORE                 0x0D
#define EFI_FV_FILETYPE_MM_STANDALONE           0x0E
#define EFI_FV_FILETYPE_MM_CORE_STANDALONE      0x0F
#define EFI_FV_FILETYPE_OEM_MIN                 0xC0
#define EFI_FV_FILETYPE_OEM_MAX                 0xDF
#define EFI_FV_FILETYPE_DEBUG_MIN               0xE0
#define EFI_FV_FILETYPE_DEBUG_MAX               0xEF
#define EFI_FV_FILETYPE_PAD                     0xF0
#define EFI_FV_FILETYPE_FFS_MIN                 0xF0
#define EFI_FV_FILETYPE_FFS_MAX                 0xFF

// File attributes
#define FFS_ATTRIB_TAIL_PRESENT       0x01 // Valid only for revision 1 volumes
#define FFS_ATTRIB_RECOVERY           0x02 // Valid only for revision 1 volumes
#define FFS_ATTRIB_LARGE_FILE         0x01 // Valid only for FFSv3 volumes
#define FFS_ATTRIB_DATA_ALIGNMENT2    0x02 // Volaid only for revision 2 volumes, added in UEFI PI 1.6
#define FFS_ATTRIB_FIXED              0x04
#define FFS_ATTRIB_DATA_ALIGNMENT     0x38
#define FFS_ATTRIB_CHECKSUM           0x40

// FFS alignment table
extern const UINT8 ffsAlignmentTable[];

// Extended FFS alignment table, added in UEFI PI 1.6
extern const UINT8 ffsAlignment2Table[];


// File states
#define EFI_FILE_HEADER_CONSTRUCTION    0x01
#define EFI_FILE_HEADER_VALID           0x02
#define EFI_FILE_DATA_VALID             0x04
#define EFI_FILE_MARKED_FOR_UPDATE      0x08
#define EFI_FILE_DELETED                0x10
#define EFI_FILE_HEADER_INVALID         0x20
#define EFI_FILE_ERASE_POLARITY         0x80 // Defined as "all other bits must be set to ERASE_POLARITY" in UEFI PI

// PEI apriori file
const UByteArray EFI_PEI_APRIORI_FILE_GUID
("\x0A\xCC\x45\x1B\x6A\x15\x8A\x42\xAF\x62\x49\x86\x4D\xA0\xE6\xE6", 16);

// DXE apriori file
const UByteArray EFI_DXE_APRIORI_FILE_GUID
("\xE7\x0E\x51\xFC\xDC\xFF\xD4\x11\xBD\x41\x00\x80\xC7\x3C\x88\x81", 16);

// Volume top file
const UByteArray EFI_FFS_VOLUME_TOP_FILE_GUID
("\x2E\x06\xA0\x1B\x79\xC7\x82\x45\x85\x66\x33\x6A\xE8\xF7\x8F\x09", 16);

// Pad file GUID
const UByteArray EFI_FFS_PAD_FILE_GUID
("\x85\x65\x53\xE4\x09\x79\x60\x4A\xB5\xC6\xEC\xDE\xA6\xEB\xFB\x54", 16);

// AMI DXE core file
const UByteArray AMI_CORE_DXE_GUID // 5AE3F37E-4EAE-41AE-8240-35465B5E81EB
("\x7E\xF3\xE3\x5A\xAE\x4E\xAE\x41\x82\x40\x35\x46\x5B\x5E\x81\xEB", 16);

// EDK2 DXE code file
const UByteArray EFI_DXE_CORE_GUID // D6A2CB7F-6A18-4E2F-B43B-9920A733700A
("\x7F\xCB\xA2\xD6\x18\x6A\x2F\x4E\xB4\x3B\x99\x20\xA7\x33\x70\x0A", 16);

// TXT ACM
const UByteArray EFI_TXT_ACM_GUID // 2D27C618-7DCD-41F5-BB10-21166BE7E143
("\x18\xC6\x27\x2D\xCD\x7D\xF5\x41\xBB\x10\x21\x16\x6B\xE7\xE1\x43", 16);

// FFS size conversion routines
extern VOID uint32ToUint24(UINT32 size, UINT8* ffsSize);
extern UINT32 uint24ToUint32(const UINT8* ffsSize);

//*****************************************************************************
// EFI FFS File Section
//*****************************************************************************
// Common section header
typedef struct EFI_COMMON_SECTION_HEADER_ {
    UINT8    Size[3];
    UINT8    Type;
} EFI_COMMON_SECTION_HEADER;

// Large file common section header
typedef struct EFI_COMMON_SECTION_HEADER2_ {
    UINT8    Size[3];    // Must be 0xFFFFFF for this header to be used
    UINT8    Type;
    UINT32   ExtendedSize;
} EFI_COMMON_SECTION_HEADER2;

// Apple common section header
typedef struct EFI_COMMON_SECTION_HEADER_APPLE {
    UINT8    Size[3];    
    UINT8    Type;
    UINT32   Reserved;   // Must be 0x7FFF for this header to be used
} EFI_COMMON_SECTION_HEADER_APPLE;

// Section2 usage indicator
#define EFI_SECTION2_IS_USED 0xFFFFFF

// Apple section usage indicator
#define EFI_SECTION_APPLE_USED 0x7FFF

// File section types
#define EFI_SECTION_ALL 0x00 // Impossible attribute for file in the FS

// Encapsulation section types
#define EFI_SECTION_COMPRESSION     0x01
#define EFI_SECTION_GUID_DEFINED    0x02
#define EFI_SECTION_DISPOSABLE      0x03

// Leaf section types
#define EFI_SECTION_PE32                    0x10
#define EFI_SECTION_PIC                     0x11
#define EFI_SECTION_TE                      0x12
#define EFI_SECTION_DXE_DEPEX               0x13
#define EFI_SECTION_VERSION                 0x14
#define EFI_SECTION_USER_INTERFACE          0x15
#define EFI_SECTION_COMPATIBILITY16         0x16
#define EFI_SECTION_FIRMWARE_VOLUME_IMAGE   0x17
#define EFI_SECTION_FREEFORM_SUBTYPE_GUID   0x18
#define EFI_SECTION_RAW                     0x19
#define EFI_SECTION_PEI_DEPEX               0x1B
#define EFI_SECTION_MM_DEPEX                0x1C
#define PHOENIX_SECTION_POSTCODE            0xF0 // Specific to Phoenix SCT images
#define INSYDE_SECTION_POSTCODE             0x20 // Specific to Insyde H2O images

// Compression section
typedef struct EFI_COMPRESSION_SECTION_ {
    UINT32   UncompressedLength;
    UINT8    CompressionType;
} EFI_COMPRESSION_SECTION;

typedef struct EFI_COMPRESSION_SECTION_APPLE_ {
    UINT32   UncompressedLength;
    UINT32   CompressionType;
} EFI_COMPRESSION_SECTION_APPLE;

// Compression types
#define EFI_NOT_COMPRESSED                 0x00
#define EFI_STANDARD_COMPRESSION           0x01
#define EFI_CUSTOMIZED_COMPRESSION         0x02
#define EFI_CUSTOMIZED_COMPRESSION_LZMAF86 0x86

//GUID defined section
typedef struct EFI_GUID_DEFINED_SECTION_ {
    EFI_GUID SectionDefinitionGuid;
    UINT16   DataOffset;
    UINT16   Attributes;
} EFI_GUID_DEFINED_SECTION;

typedef struct EFI_GUID_DEFINED_SECTION_APPLE_ {
    EFI_GUID SectionDefinitionGuid;
    UINT16   DataOffset;
    UINT16   Attributes;
    UINT32   Reserved;
} EFI_GUID_DEFINED_SECTION_APPLE;

// Attributes for GUID defined section
#define EFI_GUIDED_SECTION_PROCESSING_REQUIRED  0x01
#define EFI_GUIDED_SECTION_AUTH_STATUS_VALID    0x02

// GUIDs of GUID-defined sections
const UByteArray EFI_GUIDED_SECTION_CRC32 // FC1BCDB0-7D31-49AA-936A-A4600D9DD083
("\xB0\xCD\x1B\xFC\x31\x7D\xAA\x49\x93\x6A\xA4\x60\x0D\x9D\xD0\x83", 16);

const UByteArray EFI_GUIDED_SECTION_TIANO // A31280AD-481E-41B6-95E8-127F4C984779
("\xAD\x80\x12\xA3\x1E\x48\xB6\x41\x95\xE8\x12\x7F\x4C\x98\x47\x79", 16);

const UByteArray EFI_GUIDED_SECTION_LZMA // EE4E5898-3914-4259-9D6E-DC7BD79403CF
("\x98\x58\x4E\xEE\x14\x39\x59\x42\x9D\x6E\xDC\x7B\xD7\x94\x03\xCF", 16);

const UByteArray EFI_GUIDED_SECTION_LZMAF86 // D42AE6BD-1352-4BFB-909A-CA72A6EAE889
("\xBD\xE6\x2A\xD4\x52\x13\xFB\x4B\x90\x9A\xCA\x72\xA6\xEA\xE8\x89", 16);

const UByteArray EFI_GUIDED_SECTION_GZIP // 1D301FE9-BE79-4353-91C2-D23BC959AE0C
("\xE9\x1F\x30\x1D\x79\xBE\x53\x43\x91\xC2\xD2\x3B\xC9\x59\xAE\x0C", 16);

const UByteArray EFI_FIRMWARE_CONTENTS_SIGNED_GUID // 0F9D89E8-9259-4F76-A5AF-0C89E34023DF
("\xE8\x89\x9D\x0F\x59\x92\x76\x4F\xA5\xAF\x0C\x89\xE3\x40\x23\xDF", 16);

//#define WIN_CERT_TYPE_PKCS_SIGNED_DATA 0x0002
#define WIN_CERT_TYPE_EFI_GUID         0x0EF1

typedef struct WIN_CERTIFICATE_ {
    UINT32  Length;
    UINT16  Revision;
    UINT16  CertificateType;
    //UINT8 CertData[];
} WIN_CERTIFICATE;

typedef struct WIN_CERTIFICATE_UEFI_GUID_ {
    WIN_CERTIFICATE   Header;     // Standard WIN_CERTIFICATE
    EFI_GUID          CertType;   // Determines format of CertData
    // UINT8          CertData[]; // Certificate data follows
} WIN_CERTIFICATE_UEFI_GUID;

// WIN_CERTIFICATE_UEFI_GUID.CertType
const UByteArray EFI_CERT_TYPE_RSA2048_SHA256_GUID // A7717414-C616-4977-9420-844712A735BF
("\x14\x74\x71\xA7\x16\xC6\x77\x49\x94\x20\x84\x47\x12\xA7\x35\xBF");

// WIN_CERTIFICATE_UEFI_GUID.CertData
typedef struct EFI_CERT_BLOCK_RSA2048_SHA256_ {
    EFI_GUID  HashType;
    UINT8     PublicKey[256];
    UINT8     Signature[256];
} EFI_CERT_BLOCK_RSA2048_SHA256;

const UByteArray EFI_HASH_ALGORITHM_SHA256_GUID // 51aa59de-fdf2-4ea3-bc63-875fb7842ee9
("\xde\x59\xAA\x51\xF2\xFD\xA3\x4E\xBC\x63\x87\x5F\xB7\x84\x2E\xE9");

// Version section
typedef struct EFI_VERSION_SECTION_ {
    UINT16   BuildNumber;
} EFI_VERSION_SECTION;

// Freeform subtype GUID section
typedef struct EFI_FREEFORM_SUBTYPE_GUID_SECTION_ {
    EFI_GUID SubTypeGuid;
} EFI_FREEFORM_SUBTYPE_GUID_SECTION;

// Phoenix SCT and Insyde postcode section
typedef struct POSTCODE_SECTION_ {
    UINT32   Postcode;
} POSTCODE_SECTION;

//*****************************************************************************
// EFI Dependency Expression
//*****************************************************************************
#define EFI_DEP_OPCODE_SIZE   1

///
/// If present, this must be the first and only opcode,
/// EFI_DEP_BEFORE is only used by DXE drivers
///
#define EFI_DEP_BEFORE        0x00

///
/// If present, this must be the first and only opcode,
/// EFI_DEP_AFTER is only used by DXE drivers
///
#define EFI_DEP_AFTER         0x01

#define EFI_DEP_PUSH          0x02
#define EFI_DEP_AND           0x03
#define EFI_DEP_OR            0x04
#define EFI_DEP_NOT           0x05
#define EFI_DEP_TRUE          0x06
#define EFI_DEP_FALSE         0x07
#define EFI_DEP_END           0x08


///
/// If present, this must be the first opcode,
/// EFI_DEP_SOR is only used by DXE drivers
///
#define EFI_DEP_SOR           0x09

//*****************************************************************************
// X86 Reset Vector Data
//*****************************************************************************
typedef struct X86_RESET_VECTOR_DATA_ {
    UINT8  ApEntryVector[8];   // Base: 0xffffffd0
    UINT8  Reserved0[8];
    UINT32 PeiCoreEntryPoint;  // Base: 0xffffffe0
    UINT8  Reserved1[12];
    UINT8  ResetVector[8];     // Base: 0xfffffff0
    UINT32 ApStartupSegment;   // Base: 0xfffffff8
    UINT32 BootFvBaseAddress;  // Base: 0xfffffffc
} X86_RESET_VECTOR_DATA;

#define X86_RESET_VECTOR_DATA_UNPOPULATED 0x12345678

//*****************************************************************************
// IFWI
//*****************************************************************************

// BPDT
#define BPDT_GREEN_SIGNATURE  0x000055AA
#define BPDT_YELLOW_SIGNATURE 0x00AA55AA

typedef struct BPDT_HEADER_ {
    UINT32 Signature;
    UINT16 NumEntries;
    UINT8  HeaderVersion;
    UINT8  RedundancyFlag; // Reserved zero in version 1
    UINT32 Checksum;
    UINT32 IfwiVersion;
    UINT16 FitcMajor;
    UINT16 FitcMinor;
    UINT16 FitcHotfix;
    UINT16 FitcBuild;
} BPDT_HEADER;

#define BPDT_HEADER_VERSION_1 1
#define BPDT_HEADER_VERSION_2 2

typedef struct BPDT_ENTRY_ {
    UINT32 Type : 16;
    UINT32 SplitSubPartitionFirstPart : 1;
    UINT32 SplitSubPartitionSecondPart : 1;
    UINT32 CodeSubPartition : 1;
    UINT32 UmaCachable : 1;
    UINT32 Reserved: 12;
    UINT32 Offset;
    UINT32 Size;
} BPDT_ENTRY;

#define BPDT_ENTRY_TYPE_OEM_SMIP         0
#define BPDT_ENTRY_TYPE_OEM_RBE          1
#define BPDT_ENTRY_TYPE_CSE_BUP          2
#define BPDT_ENTRY_TYPE_UCODE            3
#define BPDT_ENTRY_TYPE_IBB              4
#define BPDT_ENTRY_TYPE_SBPDT            5
#define BPDT_ENTRY_TYPE_OBB              6
#define BPDT_ENTRY_TYPE_CSE_MAIN         7
#define BPDT_ENTRY_TYPE_ISH              8
#define BPDT_ENTRY_TYPE_CSE_IDLM         9
#define BPDT_ENTRY_TYPE_IFP_OVERRIDE     10
#define BPDT_ENTRY_TYPE_DEBUG_TOKENS     11
#define BPDT_ENTRY_TYPE_USF_PHY_CONFIG   12
#define BPDT_ENTRY_TYPE_USB_GPP_LUN_ID   13
#define BPDT_ENTRY_TYPE_PMC              14
#define BPDT_ENTRY_TYPE_IUNIT            15
#define BPDT_ENTRY_TYPE_NVM_CONFIG       16
#define BPDT_ENTRY_TYPE_UEP              17
#define BPDT_ENTRY_TYPE_WLAN_UCODE       18
#define BPDT_ENTRY_TYPE_LOCL_SPRITES     19
#define BPDT_ENTRY_TYPE_OEM_KEY_MANIFEST 20
#define BPDT_ENTRY_TYPE_DEFAULTS         21
#define BPDT_ENTRY_TYPE_PAVP             22
#define BPDT_ENTRY_TYPE_TCSS_FW_IOM      23
#define BPDT_ENTRY_TYPE_TCSS_FW_PHY      24
#define BPDT_ENTRY_TYPE_TBT              25
#define BPDT_LAST_KNOWN_ENTRY_TYPE       BPDT_ENTRY_TYPE_TBT

// CPD
#define CPD_SIGNATURE 0x44504324 //$CPD

typedef struct CPD_REV1_HEADER_ {
    UINT32 Signature;
    UINT32 NumEntries;
    UINT8  HeaderVersion; // 1
    UINT8  EntryVersion;
    UINT8  HeaderLength;
    UINT8  HeaderChecksum;
    UINT8  ShortName[4];
} CPD_REV1_HEADER;

typedef struct CPD_REV2_HEADER_ {
    UINT32 Signature;
    UINT32 NumEntries;
    UINT8  HeaderVersion; // 2
    UINT8  EntryVersion;
    UINT8  HeaderLength;
    UINT8  Reserved;
    UINT8  ShortName[4];
    UINT32 Checksum;
} CPD_REV2_HEADER;

typedef struct CPD_ENTRY_ {
    UINT8  EntryName[12];
    struct {
        UINT32 Offset : 25;
        UINT32 HuffmanCompressed : 1;
        UINT32 Reserved : 6;
    } Offset;
    UINT32 Length;
    UINT32 Reserved;
} CPD_ENTRY;

typedef struct CPD_MANIFEST_HEADER_ {
    UINT32 HeaderType;
    UINT32 HeaderLength;
    UINT32 HeaderVersion;
    UINT32 Flags;
    UINT32 Vendor;
    UINT32 Date;
    UINT32 Size;
    UINT32 HeaderId;
    UINT32 Reserved1;
    UINT16 VersionMajor;
    UINT16 VersionMinor;
    UINT16 VersionBugfix;
    UINT16 VersionBuild;
    UINT32 SecurityVersion;
    UINT8  Reserved2[8];
    UINT8  Reserved3[64];
    UINT32 ModulusSize;
    UINT32 ExponentSize;
    //manifest_rsa_key_t public_key;
    //manifest_signature_t signature;
} CPD_MANIFEST_HEADER;

typedef struct CPD_EXTENTION_HEADER_ {
    UINT32 Type;
    UINT32 Length;
} CPD_EXTENTION_HEADER;

#define CPD_EXT_TYPE_SYSTEM_INFO             0
#define CPD_EXT_TYPE_INIT_SCRIPT             1
#define CPD_EXT_TYPE_FEATURE_PERMISSIONS     2
#define CPD_EXT_TYPE_PARTITION_INFO          3
#define CPD_EXT_TYPE_SHARED_LIB_ATTRIBUTES   4
#define CPD_EXT_TYPE_PROCESS_ATTRIBUTES      5
#define CPD_EXT_TYPE_THREAD_ATTRIBUTES       6
#define CPD_EXT_TYPE_DEVICE_TYPE             7
#define CPD_EXT_TYPE_MMIO_RANGE              8
#define CPD_EXT_TYPE_SPEC_FILE_PRODUCER      9
#define CPD_EXT_TYPE_MODULE_ATTRIBUTES       10
#define CPD_EXT_TYPE_LOCKED_RANGES           11
#define CPD_EXT_TYPE_CLIENT_SYSTEM_INFO      12
#define CPD_EXT_TYPE_USER_INFO               13
#define CPD_EXT_TYPE_KEY_MANIFEST            14
#define CPD_EXT_TYPE_SIGNED_PACKAGE_INFO     15
#define CPD_EXT_TYPE_ANTI_CLONING_SKU_ID     16
#define CPD_EXT_TYPE_CAVS                    17
#define CPD_EXT_TYPE_IMR_INFO                18
#define CPD_EXT_TYPE_BOOT_POLICY             19
#define CPD_EXT_TYPE_RCIP_INFO               20
#define CPD_EXT_TYPE_SECURE_TOKEN            21
#define CPD_EXT_TYPE_IFWI_PARTITION_MANIFEST 22
#define CPD_EXT_TYPE_FD_HASH                 23
#define CPD_EXT_TYPE_IOM_METADATA            24
#define CPD_EXT_TYPE_MGP_METADATA            25
#define CPD_EXT_TYPE_TBT_METADATA            26
#define CPD_LAST_KNOWN_EXT_TYPE              CPD_EXT_TYPE_TBT_METADATA

typedef struct CPD_EXT_SIGNED_PACKAGE_INFO_MODULE_ {
    UINT8  Name[12];
    UINT8  Type;
    UINT8  HashAlgorithm;
    UINT16 HashSize;
    UINT32 MetadataSize;
    UINT8  MetadataHash[32];
} CPD_EXT_SIGNED_PACKAGE_INFO_MODULE;

typedef struct CPD_EXT_SIGNED_PACKAGE_INFO_ {
    UINT32 ExtensionType;
    UINT32 ExtensionLength;
    UINT8  PackageName[4];
    UINT32 Vcn;
    UINT8  UsageBitmap[16];
    UINT32 Svn;
    UINT8  Reserved[16];
    // EXT_SIGNED_PACKAGE_INFO_MODULE Modules[];
} CPD_EXT_SIGNED_PACKAGE_INFO;

typedef struct CPD_EXT_MODULE_ATTRIBUTES_ {
    UINT32 ExtensionType;
    UINT32 ExtensionLength;
    UINT8  CompressionType;
    UINT8  Reserved[3];
    UINT32 UncompressedSize;
    UINT32 CompressedSize;
    UINT32 GlobalModuleId;
    UINT8  ImageHash[32];
} CPD_EXT_MODULE_ATTRIBUTES;

#define CPD_EXT_MODULE_COMPRESSION_TYPE_UNCOMPRESSED 0
#define CPD_EXT_MODULE_COMPRESSION_TYPE_HUFFMAN 1
#define CPD_EXT_MODULE_COMPRESSION_TYPE_LZMA 2

typedef struct CPD_EXT_IFWI_PARTITION_MANIFEST_ {
    UINT32 ExtensionType;
    UINT32 ExtensionLength;
    UINT8  PartitionName[4];
    UINT32 CompletePartitionLength;
    UINT16 PartitionVersionMinor;
    UINT16 PartitionVersionMajor;
    UINT32 DataFormatVersion;
    UINT32 InstanceId;
    UINT32 SupportMultipleInstances : 1;
    UINT32 SupportApiVersionBasedUpdate : 1;
    UINT32 ActionOnUpdate : 2;
    UINT32 ObeyFullUpdateRules : 1;
    UINT32 IfrEnableOnly : 1;
    UINT32 AllowCrossPointUpdate : 1;
    UINT32 AllowCrossHotfixUpdate : 1;
    UINT32 PartialUpdateOnly : 1;
    UINT32 ReservedFlags : 23;
    UINT32 HashAlgorithm : 8;
    UINT32 HashSize : 24;
    UINT8  CompletePartitionHash[32];
    UINT8  Reserved[20];
} CPD_EXT_IFWI_PARTITION_MANIFEST;

// Restore previous packing rules
#pragma pack(pop)

#endif // FFS_H

```

`efiXloader/3rd/uefitool/common/ffsbuilder.cpp`:

```cpp
/* fssbuilder.cpp

Copyright (c) 2015, Nikolaj Schlej. All rights reserved.
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

*/
#include "ffsbuilder.h"

#include "descriptor.h"
#include "ffs.h"
#include "peimage.h"
#include "utility.h"
#include "nvram.h"

#include <cstring>

USTATUS FfsBuilder::erase(const UModelIndex & index, UByteArray & erased)
{
    // Sanity check
    if (!index.isValid())
        return U_INVALID_PARAMETER;

    // Try to get emptyByte value from item's parsing data
    UINT8 emptyByte = 0xFF;
    if (!model->hasEmptyParsingData(index)) {
        if (model->type(index) == Types::Volume) {
            VOLUME_PARSING_DATA pdata = *(VOLUME_PARSING_DATA*)model->parsingData(index).constData();
            emptyByte = pdata.emptyByte;
        }
        else if (model->type(index) == Types::File) {
            FILE_PARSING_DATA pdata = *(FILE_PARSING_DATA*)model->parsingData(index).constData();
            emptyByte = pdata.emptyByte;
        }
    }

    erased = UByteArray(model->header(index).size() + model->body(index).size() + model->tail(index).size(), emptyByte);

    return U_SUCCESS;
}

USTATUS FfsBuilder::build(const UModelIndex & root, UByteArray & image)
{
    // Sanity check
    if (!root.isValid())
        return U_INVALID_PARAMETER;

    if (model->type(root) == Types::Capsule) {
        return buildCapsule(root, image);
    }
    else if (model->type(root) == Types::Image) {
        if (model->subtype(root) == Subtypes::IntelImage) {
            return buildIntelImage(root, image);
        }
        else if (model->subtype(root) == Subtypes::UefiImage) {
            return buildRawArea(root, image);
        }
    }

    return U_NOT_IMPLEMENTED;
}

USTATUS FfsBuilder::buildCapsule(const UModelIndex & index, UByteArray & capsule)
{
    // Sanity check
    if (!index.isValid())
        return U_INVALID_PARAMETER;

    // No action
    if (model->action(index) == Actions::NoAction) {
        // Use original item data
        capsule = model->header(index) + model->body(index) + model->tail(index);
        return U_SUCCESS;
    }

    // Rebuild or Replace
    else if (model->action(index) == Actions::Rebuild 
        || model->action(index) == Actions::Replace) {
        if (model->rowCount(index)) {
            // Clear the supplied UByteArray
            capsule.clear();

            // Right now there is only one capsule image element supported
            if (model->rowCount(index) != 1) {
                msg(usprintf("buildCapsule: building of capsules with %d items is not yet supported", model->rowCount(index)), index);
                return U_NOT_IMPLEMENTED;
            }
            
            // Build image
            UModelIndex imageIndex = index.child(0, 0);
            UByteArray imageData;
            
            // Check image type
            if (model->type(imageIndex) == Types::Image) {
                USTATUS result = U_SUCCESS;
                if (model->subtype(imageIndex) == Subtypes::IntelImage) {
                    result = buildIntelImage(imageIndex, imageData);
                }
                else if (model->subtype(imageIndex) == Subtypes::UefiImage) {
                    result = buildRawArea(imageIndex, imageData);
                }
                else {
                    msg(UString("buildCapsule: unexpected item subtype ") + itemSubtypeToUString(model->type(imageIndex), model->subtype(imageIndex)), imageIndex);
                    return U_UNKNOWN_ITEM_TYPE;
                }
                
                // Check build result
                if (result) {
                    msg(UString("buildCapsule: building of ") + model->name(imageIndex) + UString(" failed with error ") + errorCodeToUString(result), imageIndex);
                    return result;
                }
                else
                    capsule += imageData;
            }
            else {
                msg(UString("buildCapsule: unexpected item type ") + itemTypeToUString(model->type(imageIndex)), imageIndex);
                return U_UNKNOWN_ITEM_TYPE;
            }
            
            // Check size of reconstructed capsule body, it must remain the same
            UINT32 newSize = capsule.size();
            UINT32 oldSize = model->body(index).size();
            if (newSize > oldSize) {
                msg(usprintf("buildCapsule: new capsule size %Xh (%u) is bigger than the original %Xh (%u)", newSize, newSize, oldSize, oldSize), index);
                return U_INVALID_CAPSULE;
            }
            else if (newSize < oldSize) {
                msg(usprintf("buildCapsule: new capsule size %Xh (%u) is smaller than the original %Xh (%u)", newSize, newSize, oldSize, oldSize), index);
                return U_INVALID_CAPSULE;
            }
        }
        else
            capsule = model->body(index);

        // Build successful, append header and tail
        capsule = model->header(index) + capsule + model->tail(index);
        return U_SUCCESS;
    }

    msg(UString("buildCapsule: unexpected action " + actionTypeToUString(model->action(index))), index);
    return U_NOT_IMPLEMENTED;
}

USTATUS FfsBuilder::buildIntelImage(const UModelIndex & index, UByteArray & intelImage)
{
    // Sanity check
    if (!index.isValid())
        return U_SUCCESS;
    
    // No action
    if (model->action(index) == Actions::NoAction) {
        intelImage = model->header(index) + model->body(index) + model->tail(index);
        return U_SUCCESS;
    }
    // Remove
    else if (model->action(index) == Actions::Remove) {
        intelImage.clear();
        return U_SUCCESS;
    }
    // Rebuild
    else if (model->action(index) == Actions::Rebuild) {
        // First child will always be descriptor for this type of image, and it's read only for now
        intelImage = model->header(index.child(0, 0)) + model->body(index.child(0, 0)) + model->tail(index.child(0, 0));
        
        // Process other regions
        for (int i = 1; i < model->rowCount(index); i++) {
            UModelIndex currentRegion = index.child(i, 0);

            // Skip regions with Remove action
            if (model->action(currentRegion) == Actions::Remove)
                continue;

            // Check item type to be either region or padding
            UINT8 type = model->type(currentRegion);
            if (type == Types::Padding) {
                // Add padding as is
                intelImage += model->header(currentRegion) + model->body(currentRegion) + model->tail(currentRegion);
                continue;
            }

            // Check region subtype
            USTATUS result;
            UByteArray region;
            UINT8 regionType = model->subtype(currentRegion);
            switch (regionType) {
            case Subtypes::BiosRegion:
            case Subtypes::PdrRegion:
                result = buildRawArea(currentRegion, region);
                if (result) {
                    msg(UString("buildIntelImage: building of region ") + regionTypeToUString(regionType) + UString(" failed with error ") + errorCodeToUString(result), currentRegion);
                    return result;
                }
                break;
            case Subtypes::MeRegion:
            case Subtypes::GbeRegion:
            case Subtypes::DevExp1Region:
            case Subtypes::Bios2Region:
            case Subtypes::MicrocodeRegion:
            case Subtypes::EcRegion:
            case Subtypes::DevExp2Region:
            case Subtypes::IeRegion:
            case Subtypes::Tgbe1Region:
            case Subtypes::Tgbe2Region:
            case Subtypes::Reserved1Region:
            case Subtypes::Reserved2Region:
            case Subtypes::PttRegion:
                // Add region as is
                region = model->header(currentRegion) + model->body(currentRegion);
                break;
            default:
                msg(UString("buildIntelImage: unknown region type"), currentRegion);
                return U_UNKNOWN_ITEM_TYPE;
            }

            // Append the resulting region
            intelImage += region;
        }
        
        // Check size of new image, it must be same as old one
        UINT32 newSize = intelImage.size();
        UINT32 oldSize = model->body(index).size();
        if (newSize > oldSize) {
            msg(usprintf("buildIntelImage: new image size %Xh (%u) is bigger than the original %Xh (%u)", newSize, newSize, oldSize, oldSize), index);
            return U_INVALID_IMAGE;
        }
        else if (newSize < oldSize) {
            msg(usprintf("buildIntelImage: new image size %Xh (%u) is smaller than the original %Xh (%u)", newSize, newSize, oldSize, oldSize), index);
            return U_INVALID_IMAGE;
        }

        // Build successful, append header and tail
        intelImage = model->header(index) + intelImage + model->tail(index);
        return U_SUCCESS;
    }

    msg(UString("buildIntelImage: unexpected action " + actionTypeToUString(model->action(index))), index);
    return U_NOT_IMPLEMENTED;
}

USTATUS FfsBuilder::buildRawArea(const UModelIndex & index, UByteArray & rawArea)
{
    // Sanity check
    if (!index.isValid())
        return U_INVALID_PARAMETER;

    // No action required
    if (model->action(index) == Actions::NoAction) {
        rawArea = model->header(index) + model->body(index) + model->tail(index);
        return U_SUCCESS;
    }
    // Remove
    else if (model->action(index) == Actions::Remove) {
        rawArea.clear();
        return U_SUCCESS;
    }
    // Rebuild or Replace
    else if (model->action(index) == Actions::Rebuild 
        || model->action(index) == Actions::Replace) {
        // Rebuild if there is at least 1 child
        if (model->rowCount(index)) {
            // Clear the supplied UByteArray
            rawArea.clear();

            // Build children
            for (int i = 0; i < model->rowCount(index); i++) {
                USTATUS result = U_SUCCESS;
                UModelIndex currentChild = index.child(i, 0);
                UByteArray currentData;
                // Check child type
                if (model->type(currentChild) == Types::Volume) {
                    result = buildVolume(currentChild, currentData);
                }
                else if (model->type(currentChild) == Types::Padding) {
                    result = buildPadding(currentChild, currentData);
                }
                else {
                    msg(UString("buildRawArea: unexpected item type ") + itemTypeToUString(model->type(currentChild)), currentChild);
                    return U_UNKNOWN_ITEM_TYPE;
                }
                // Check build result
                if (result) {
                    msg(UString("buildRawArea: building of ") + model->name(currentChild) + UString(" failed with error ") + errorCodeToUString(result), currentChild);
                    return result;
                }
                // Append current data
                rawArea += currentData;
            }

            // Check size of new raw area, it must be same as original one
            UINT32 newSize = rawArea.size();
            UINT32 oldSize = model->body(index).size();
            if (newSize > oldSize) {
                msg(usprintf("buildRawArea: new area size %Xh (%u) is bigger than the original %Xh (%u)", newSize, newSize, oldSize, oldSize), index);
                return U_INVALID_RAW_AREA;
            }
            else if (newSize < oldSize) {
                msg(usprintf("buildRawArea: new area size %Xh (%u) is smaller than the original %Xh (%u)", newSize, newSize, oldSize, oldSize), index);
                return U_INVALID_RAW_AREA;
            }
        }
        // No need to rebuild a raw area with no children
        else {
            rawArea = model->body(index);
        }

        // Build successful, add header if needed
        rawArea = model->header(index) + rawArea + model->tail(index);
        return U_SUCCESS;
    }

    msg(UString("buildRawArea: unexpected action " + actionTypeToUString(model->action(index))), index);
    return U_NOT_IMPLEMENTED;
}

USTATUS FfsBuilder::buildPadding(const UModelIndex & index, UByteArray & padding)
{
    // Sanity check
    if (!index.isValid())
        return U_INVALID_PARAMETER;

    // No action required
    if (model->action(index) == Actions::NoAction) {
        padding = model->header(index) + model->body(index) + model->tail(index);
        return U_SUCCESS;
    }
    // Remove
    else if (model->action(index) == Actions::Remove) {
        padding.clear();
        return U_SUCCESS;
    }
    // Erase
    else if (model->action(index) == Actions::Erase) {
        return erase(index, padding);
    }

    msg(UString("buildPadding: unexpected action " + actionTypeToUString(model->action(index))), index);
    return U_NOT_IMPLEMENTED;
}

USTATUS FfsBuilder::buildNonUefiData(const UModelIndex & index, UByteArray & data)
{
    // Sanity check
    if (!index.isValid())
        return U_INVALID_PARAMETER;

    // No action required
    if (model->action(index) == Actions::NoAction) {
        data = model->header(index) + model->body(index) + model->tail(index);
        return U_SUCCESS;
    }
    // Remove
    else if (model->action(index) == Actions::Remove) {
        data.clear();
        return U_SUCCESS;
    }
    // Erase
    else if (model->action(index) == Actions::Erase) {
        return erase(index, data);
    }

    // TODO: rebuild properly

    msg(UString("buildNoUefiData: unexpected action " + actionTypeToUString(model->action(index))), index);
    return U_NOT_IMPLEMENTED;
}

USTATUS FfsBuilder::buildFreeSpace(const UModelIndex & index, UByteArray & freeSpace)
{
    // Sanity check
    if (!index.isValid())
        return U_INVALID_PARAMETER;

    // No actions possible for free space
    freeSpace = model->header(index) + model->body(index) + model->tail(index);
    return U_SUCCESS;
}

USTATUS FfsBuilder::buildVolume(const UModelIndex & index, UByteArray & volume)
{
    U_UNUSED_PARAMETER(index);
    U_UNUSED_PARAMETER(volume);

    return U_NOT_IMPLEMENTED;
}

USTATUS FfsBuilder::buildPadFile(const UModelIndex & index, UByteArray & padFile)
{
    U_UNUSED_PARAMETER(index);
    U_UNUSED_PARAMETER(padFile);

    return U_NOT_IMPLEMENTED;
}

USTATUS FfsBuilder::buildFile(const UModelIndex & index, UByteArray & file)
{
    U_UNUSED_PARAMETER(index);
    U_UNUSED_PARAMETER(file);

    return U_NOT_IMPLEMENTED;
}

USTATUS FfsBuilder::buildSection(const UModelIndex & index, UByteArray & section)
{
    U_UNUSED_PARAMETER(index);
    U_UNUSED_PARAMETER(section);

    return U_NOT_IMPLEMENTED;
}



```

`efiXloader/3rd/uefitool/common/ffsbuilder.h`:

```h
/* fssbuilder.h

Copyright (c) 2016, Nikolaj Schlej. All rights reserved.
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

*/

#ifndef FFSBUILDER_H
#define FFSBUILDER_H

#include <vector>

#include "basetypes.h"
#include "ubytearray.h"
#include "ustring.h"
#include "treemodel.h"

class FfsBuilder
{
public:
    FfsBuilder(const TreeModel * treeModel) : model(treeModel) {}
    ~FfsBuilder() {}

    std::vector<std::pair<UString, UModelIndex> > getMessages() const { return messagesVector; }
    void clearMessages() { messagesVector.clear(); }

    USTATUS build(const UModelIndex & root, UByteArray & image);

private:
    const TreeModel* model;
    std::vector<std::pair<UString, UModelIndex> > messagesVector;
    void msg(const UString & message, const UModelIndex &index = UModelIndex()) {
        messagesVector.push_back(std::pair<UString, UModelIndex>(message, index));
    }

    USTATUS buildCapsule(const UModelIndex & index, UByteArray & capsule);
    USTATUS buildIntelImage(const UModelIndex & index, UByteArray & intelImage);
    USTATUS buildRawArea(const UModelIndex & index, UByteArray & rawArea);
    USTATUS buildPadding(const UModelIndex & index, UByteArray & padding);
    USTATUS buildVolume(const UModelIndex & index, UByteArray & volume);
    USTATUS buildNonUefiData(const UModelIndex & index, UByteArray & data);
    USTATUS buildFreeSpace(const UModelIndex & index, UByteArray & freeSpace);
    USTATUS buildPadFile(const UModelIndex & index, UByteArray & padFile);
    USTATUS buildFile(const UModelIndex & index, UByteArray & file);
    USTATUS buildSection(const UModelIndex & index, UByteArray & section);
    
    // Utility functions
    USTATUS erase(const UModelIndex & index, UByteArray & erased);
};

#endif // FFSBUILDER_H

```

`efiXloader/3rd/uefitool/common/ffsops.cpp`:

```cpp
/* fssops.cpp

Copyright (c) 2015, Nikolaj Schlej. All rights reserved.
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

*/

#include "ffsops.h"
#include "ffs.h"
#include "utility.h"

USTATUS FfsOperations::extract(const UModelIndex & index, UString & name, UByteArray & extracted, const UINT8 mode)
{
    // Sanity check
    if (!index.isValid())
        return U_INVALID_PARAMETER;

    // Default name
    name = uniqueItemName(index);

    // Get extracted data
    if (mode == EXTRACT_MODE_AS_IS) {
        // Extract as is, with header body and tail
        extracted.clear();
        extracted += model->header(index);
        extracted += model->body(index);
        extracted += model->tail(index);
    }
    else if (mode == EXTRACT_MODE_BODY) {
        name += UString("_body");
        // Extract without header and tail
        extracted.clear();
        extracted += model->body(index);
    }
    else if (mode == EXTRACT_MODE_BODY_UNCOMPRESSED) {
        name += UString("_body_unc");
        // Extract without header and tail, uncompressed
        extracted.clear();
        // There is no need to redo decompression, we can use child items
        for (int i = 0; i < model->rowCount(index); i++) {
             UModelIndex childIndex = index.child(i, 0);
             // Ensure 4-byte alignment of current section
             extracted += UByteArray(ALIGN4((UINT32)extracted.size()) - (UINT32)extracted.size(), '\x00');
             // Add current section header, body and tail
             extracted += model->header(childIndex);
             extracted += model->body(childIndex);
             extracted += model->tail(childIndex);
        }
    }
    else
        return U_UNKNOWN_EXTRACT_MODE;

    return U_SUCCESS;
}

USTATUS FfsOperations::replace(const UModelIndex & index, UByteArray & data, const UINT8 mode)
{
    U_UNUSED_PARAMETER(data);

    // Sanity check
    if (!index.isValid())
        return U_INVALID_PARAMETER;

    if (mode == REPLACE_MODE_AS_IS) {
        return U_NOT_IMPLEMENTED;
    }
    else if (mode == REPLACE_MODE_BODY) {
        return U_NOT_IMPLEMENTED;
    }
    
     return U_UNKNOWN_REPLACE_MODE;
}

USTATUS FfsOperations::remove(const UModelIndex & index)
{
    // Sanity check
    if (!index.isValid())
        return U_INVALID_PARAMETER;

    // Set remove action
    model->setAction(index, Actions::Remove);

    return U_SUCCESS;
}

USTATUS FfsOperations::rebuild(const UModelIndex & index)
{
    // Sanity check
    if (!index.isValid())
        return U_INVALID_PARAMETER;

    // On insert action, set insert action for children
    //if (action == Actions::Insert)
    //    for (int i = 0; i < item->childCount(); i++)
    //        setAction(index.child(i, 0), Actions::Insert);

    // Set rebuild action
    model->setAction(index, Actions::Rebuild);

    // Rebuild parent, if it has no action now
    UModelIndex parent = index.parent();
    if (parent.isValid() && model->type(parent) != Types::Root
        && model->action(parent) == Actions::NoAction)
       rebuild(parent);
    
    return U_SUCCESS;
}

```

`efiXloader/3rd/uefitool/common/ffsops.h`:

```h
/* fssops.h

Copyright (c) 2015, Nikolaj Schlej. All rights reserved.
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

*/

#ifndef FFSOPS_H
#define FFSOPS_H

#include <vector>

#include "basetypes.h"
#include "ubytearray.h"
#include "ustring.h"
#include "treemodel.h"
#include "ffsparser.h"

class FfsOperations
{
public:

    FfsOperations(TreeModel * treeModel) : model(treeModel) {}
    ~FfsOperations() {};

    std::vector<std::pair<UString, UModelIndex> > getMessages() const { return messagesVector; }
    void clearMessages() { messagesVector.clear(); }

    USTATUS extract(const UModelIndex & index, UString & name, UByteArray & extracted, const UINT8 mode);
    USTATUS replace(const UModelIndex & index, UByteArray & data, const UINT8 mode);
    
    USTATUS remove(const UModelIndex & index);
    USTATUS rebuild(const UModelIndex & index);

private:
    TreeModel * model;

    std::vector<std::pair<UString, UModelIndex> > messagesVector;

    void msg(const UString & message, const UModelIndex &index = UModelIndex()) {
        messagesVector.push_back(std::pair<UString, UModelIndex>(message, index));
    }
};

#endif // FFSOPS_H

```

`efiXloader/3rd/uefitool/common/ffsparser.cpp`:

```cpp
/* ffsparser.cpp

Copyright (c) 2018, Nikolaj Schlej. All rights reserved.
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHWARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
*/

// A workaround for compilers not supporting c++11 and c11
// for using PRIX64.
#define __STDC_FORMAT_MACROS

#include "ffsparser.h"

#include <map>
#include <algorithm>
#include <inttypes.h>

#include "descriptor.h"
#include "ffs.h"
#include "gbe.h"
#include "me.h"
#include "fit.h"
#include "nvram.h"
#include "utility.h"
#include "peimage.h"
#include "parsingdata.h"
#include "types.h"
#include "utility.h"

#include "nvramparser.h"
#include "meparser.h"

#ifndef QT_CORE_LIB
namespace Qt {
    enum GlobalColor {
        red = 7,
        green = 8,
        cyan = 10,
        yellow = 12,
    };
}
#endif

// Region info
struct REGION_INFO {
    UINT32 offset;
    UINT32 length;
    UINT8  type;
    UByteArray data;
    friend bool operator< (const REGION_INFO & lhs, const REGION_INFO & rhs){ return lhs.offset < rhs.offset; }
};

// BPDT partition info
struct BPDT_PARTITION_INFO {
    BPDT_ENTRY ptEntry;
    UINT8 type;
    UModelIndex index;
    friend bool operator< (const BPDT_PARTITION_INFO & lhs, const BPDT_PARTITION_INFO & rhs){ return lhs.ptEntry.Offset < rhs.ptEntry.Offset; }
};

// CPD partition info
struct CPD_PARTITION_INFO {
    CPD_ENTRY ptEntry;
    UINT8 type;
    UModelIndex index;
    friend bool operator< (const CPD_PARTITION_INFO & lhs, const CPD_PARTITION_INFO & rhs){ return lhs.ptEntry.Offset.Offset < rhs.ptEntry.Offset.Offset; }
};

// Constructor
FfsParser::FfsParser(TreeModel* treeModel) : model(treeModel),
imageBase(0), addressDiff(0x100000000ULL),
bgAcmFound(false), bgKeyManifestFound(false), bgBootPolicyFound(false), bgProtectedRegionsBase(0) {
    nvramParser = new NvramParser(treeModel, this);
    meParser = new MeParser(treeModel, this);
}

// Destructor
FfsParser::~FfsParser() {
    delete nvramParser;
    delete meParser;
}

// Obtain parser messages
std::vector<std::pair<UString, UModelIndex> > FfsParser::getMessages() const {
    std::vector<std::pair<UString, UModelIndex> > meVector = meParser->getMessages();
    std::vector<std::pair<UString, UModelIndex> > nvramVector = nvramParser->getMessages();
    std::vector<std::pair<UString, UModelIndex> > resultVector = messagesVector;
    resultVector.insert(resultVector.end(), meVector.begin(), meVector.end());
    resultVector.insert(resultVector.end(), nvramVector.begin(), nvramVector.end());
    return resultVector;
}

// Firmware image parsing functions
USTATUS FfsParser::parse(const UByteArray & buffer)
{
    UModelIndex root;

    // Reset global parser state
    openedImage = buffer;
    imageBase = 0;
    addressDiff = 0x100000000ULL;
    bgAcmFound = false;
    bgKeyManifestFound = false;
    bgBootPolicyFound = false;
    bgProtectedRegionsBase = 0;
    lastVtf = UModelIndex();
    fitTable.clear();
    securityInfo = "";
    bgAcmFound = false;
    bgKeyManifestFound = false;
    bgBootPolicyFound = false;
    bgKmHash = UByteArray();
    bgBpHash = UByteArray();
    bgBpDigest = UByteArray();
    bgProtectedRanges.clear();
    bgDxeCoreIndex = UModelIndex();

    // Parse input buffer
    USTATUS result = performFirstPass(buffer, root);
    if (result == U_SUCCESS) {
        if (lastVtf.isValid()) {
            result = performSecondPass(root);
        }
        else {
            msg(usprintf("%s: not a single Volume Top File is found, the image may be corrupted", __FUNCTION__));
        }
    }

    addInfoRecursive(root);
    return result;
}

USTATUS FfsParser::performFirstPass(const UByteArray & buffer, UModelIndex & index)
{
    // Sanity check
    if (buffer.isEmpty()) {
        return EFI_INVALID_PARAMETER;
    }

    USTATUS result;

    // Try parsing as UEFI Capsule
    result = parseCapsule(buffer, 0, UModelIndex(), index);;
    if (result != U_ITEM_NOT_FOUND) {
        return result;
    }

    // Try parsing as Intel image
    result = parseIntelImage(buffer, 0, UModelIndex(), index);
    if (result != U_ITEM_NOT_FOUND) {
        return result;
    }

    // Parse as generic image
    return parseGenericImage(buffer, 0, UModelIndex(), index);
}

USTATUS FfsParser::parseGenericImage(const UByteArray & buffer, const UINT32 localOffset, const UModelIndex & parent, UModelIndex & index)
{
    // Parse as generic UEFI image
    UString name("UEFI image");
    UString info = usprintf("Full size: %Xh (%u)", buffer.size(), buffer.size());

    // Add tree item
    index = model->addItem(localOffset, Types::Image, Subtypes::UefiImage, name, UString(), info, UByteArray(), buffer, UByteArray(), Fixed, parent);

    // Parse the image as raw area
    bgProtectedRegionsBase = imageBase = model->base(parent) + localOffset;
    return parseRawArea(index);
}

USTATUS FfsParser::parseCapsule(const UByteArray & capsule, const UINT32 localOffset, const UModelIndex & parent, UModelIndex & index)
{
    // Check buffer size to be more than or equal to size of EFI_CAPSULE_HEADER
    if ((UINT32)capsule.size() < sizeof(EFI_CAPSULE_HEADER)) {
        return U_ITEM_NOT_FOUND;
    }

    UINT32 capsuleHeaderSize = 0;
    // Check buffer for being normal EFI capsule header
    if (capsule.startsWith(EFI_CAPSULE_GUID)
        || capsule.startsWith(EFI_FMP_CAPSULE_GUID)
        || capsule.startsWith(INTEL_CAPSULE_GUID)
        || capsule.startsWith(LENOVO_CAPSULE_GUID)
        || capsule.startsWith(LENOVO2_CAPSULE_GUID)) {
        // Get info
        const EFI_CAPSULE_HEADER* capsuleHeader = (const EFI_CAPSULE_HEADER*)capsule.constData();

        // Check sanity of HeaderSize and CapsuleImageSize values
        if (capsuleHeader->HeaderSize == 0 || capsuleHeader->HeaderSize > (UINT32)capsule.size()
            || capsuleHeader->HeaderSize > capsuleHeader->CapsuleImageSize) {
            msg(usprintf("%s: UEFI capsule header size of %Xh (%u) bytes is invalid", __FUNCTION__,
                         capsuleHeader->HeaderSize,
                         capsuleHeader->HeaderSize));
            return U_INVALID_CAPSULE;
        }
        if (capsuleHeader->CapsuleImageSize > (UINT32)capsule.size()) {
            msg(usprintf("%s: UEFI capsule image size of %Xh (%u) bytes is invalid", __FUNCTION__,
                         capsuleHeader->CapsuleImageSize,
                         capsuleHeader->CapsuleImageSize));
            return U_INVALID_CAPSULE;
        }

        capsuleHeaderSize = capsuleHeader->HeaderSize;
        UByteArray header = capsule.left(capsuleHeaderSize);
        UByteArray body = capsule.mid(capsuleHeaderSize);
        UString name("UEFI capsule");
        UString info = UString("Capsule GUID: ") + guidToUString(capsuleHeader->CapsuleGuid, false) +
        usprintf("\nFull size: %Xh (%u)\nHeader size: %Xh (%u)\nImage size: %Xh (%u)\nFlags: %08Xh",
                 capsule.size(), capsule.size(),
                 capsuleHeaderSize, capsuleHeaderSize,
                 capsuleHeader->CapsuleImageSize - capsuleHeaderSize, capsuleHeader->CapsuleImageSize - capsuleHeaderSize,
                 capsuleHeader->Flags);

        // Add tree item
        index = model->addItem(localOffset, Types::Capsule, Subtypes::UefiCapsule, name, UString(), info, header, body, UByteArray(), Fixed, parent);
    }
    // Check buffer for being Toshiba capsule header
    else if (capsule.startsWith(TOSHIBA_CAPSULE_GUID)) {
        // Get info
        const TOSHIBA_CAPSULE_HEADER* capsuleHeader = (const TOSHIBA_CAPSULE_HEADER*)capsule.constData();

        // Check sanity of HeaderSize and FullSize values
        if (capsuleHeader->HeaderSize == 0 || capsuleHeader->HeaderSize > (UINT32)capsule.size()
            || capsuleHeader->HeaderSize > capsuleHeader->FullSize) {
            msg(usprintf("%s: Toshiba capsule header size of %Xh (%u) bytes is invalid", __FUNCTION__,
                         capsuleHeader->HeaderSize, capsuleHeader->HeaderSize));
            return U_INVALID_CAPSULE;
        }
        if (capsuleHeader->FullSize > (UINT32)capsule.size()) {
            msg(usprintf("%s: Toshiba capsule full size of %Xh (%u) bytes is invalid", __FUNCTION__,
                         capsuleHeader->FullSize, capsuleHeader->FullSize));
            return U_INVALID_CAPSULE;
        }

        capsuleHeaderSize = capsuleHeader->HeaderSize;
        UByteArray header = capsule.left(capsuleHeaderSize);
        UByteArray body = capsule.mid(capsuleHeaderSize);
        UString name("Toshiba capsule");
        UString info = UString("Capsule GUID: ") + guidToUString(capsuleHeader->CapsuleGuid, false) +
        usprintf("\nFull size: %Xh (%u)\nHeader size: %Xh (%u)\nImage size: %Xh (%u)\nFlags: %08Xh",
                 capsule.size(), capsule.size(),
                 capsuleHeaderSize, capsuleHeaderSize,
                 capsuleHeader->FullSize - capsuleHeaderSize, capsuleHeader->FullSize - capsuleHeaderSize,
                 capsuleHeader->Flags);

        // Add tree item
        index = model->addItem(localOffset, Types::Capsule, Subtypes::ToshibaCapsule, name, UString(), info, header, body, UByteArray(), Fixed, parent);
    }
    // Check buffer for being extended Aptio capsule header
    else if (capsule.startsWith(APTIO_SIGNED_CAPSULE_GUID)
             || capsule.startsWith(APTIO_UNSIGNED_CAPSULE_GUID)) {
        bool signedCapsule = capsule.startsWith(APTIO_SIGNED_CAPSULE_GUID);

        if ((UINT32)capsule.size() <= sizeof(APTIO_CAPSULE_HEADER)) {
            msg(usprintf("%s: AMI capsule image file is smaller than minimum size of 20h (32) bytes", __FUNCTION__));
            return U_INVALID_CAPSULE;
        }

        // Get info
        const APTIO_CAPSULE_HEADER* capsuleHeader = (const APTIO_CAPSULE_HEADER*)capsule.constData();

        // Check sanity of RomImageOffset and CapsuleImageSize values
        if (capsuleHeader->RomImageOffset == 0 || capsuleHeader->RomImageOffset > (UINT32)capsule.size()
            || capsuleHeader->RomImageOffset > capsuleHeader->CapsuleHeader.CapsuleImageSize) {
            msg(usprintf("%s: AMI capsule image offset of %Xh (%u) bytes is invalid", __FUNCTION__,
                         capsuleHeader->RomImageOffset, capsuleHeader->RomImageOffset));
            return U_INVALID_CAPSULE;
        }
        if (capsuleHeader->CapsuleHeader.CapsuleImageSize > (UINT32)capsule.size()) {
            msg(usprintf("%s: AMI capsule image size of %Xh (%u) bytes is invalid", __FUNCTION__,
                         capsuleHeader->CapsuleHeader.CapsuleImageSize,
                         capsuleHeader->CapsuleHeader.CapsuleImageSize));
            return U_INVALID_CAPSULE;
        }

        capsuleHeaderSize = capsuleHeader->RomImageOffset;
        UByteArray header = capsule.left(capsuleHeaderSize);
        UByteArray body = capsule.mid(capsuleHeaderSize);
        UString name("AMI Aptio capsule");
        UString info = UString("Capsule GUID: ") + guidToUString(capsuleHeader->CapsuleHeader.CapsuleGuid, false) +
        usprintf("\nFull size: %Xh (%u)\nHeader size: %Xh (%u)\nImage size: %Xh (%u)\nFlags: %08Xh",
                 capsule.size(), capsule.size(),
                 capsuleHeaderSize, capsuleHeaderSize,
                 capsuleHeader->CapsuleHeader.CapsuleImageSize - capsuleHeaderSize, capsuleHeader->CapsuleHeader.CapsuleImageSize - capsuleHeaderSize,
                 capsuleHeader->CapsuleHeader.Flags);

        // Add tree item
        index = model->addItem(localOffset, Types::Capsule, signedCapsule ? Subtypes::AptioSignedCapsule : Subtypes::AptioUnsignedCapsule, name, UString(), info, header, body, UByteArray(), Fixed, parent);

        // Show message about possible Aptio signature break
        if (signedCapsule) {
            msg(usprintf("%s: Aptio capsule signature may become invalid after image modifications", __FUNCTION__), index);
        }
    }

    // Capsule present
    if (capsuleHeaderSize > 0) {
        UByteArray image = capsule.mid(capsuleHeaderSize);
        UModelIndex imageIndex;

        // Try parsing as Intel image
        USTATUS result = parseIntelImage(image, capsuleHeaderSize, index, imageIndex);
        if (result != U_ITEM_NOT_FOUND) {
            return result;
        }

        // Parse as generic image
        return parseGenericImage(image, capsuleHeaderSize, index, imageIndex);
    }

    return U_ITEM_NOT_FOUND;
}

USTATUS FfsParser::parseIntelImage(const UByteArray & intelImage, const UINT32 localOffset, const UModelIndex & parent, UModelIndex & index)
{
    // Check for buffer size to be greater or equal to descriptor region size
    if (intelImage.size() < FLASH_DESCRIPTOR_SIZE) {
        msg(usprintf("%s: input file is smaller than minimum descriptor size of %Xh (%u) bytes", __FUNCTION__, FLASH_DESCRIPTOR_SIZE, FLASH_DESCRIPTOR_SIZE));
        return U_ITEM_NOT_FOUND;
    }

    // Store the beginning of descriptor as descriptor base address
    const FLASH_DESCRIPTOR_HEADER* descriptor = (const FLASH_DESCRIPTOR_HEADER*)intelImage.constData();

    // Check descriptor signature
    if (descriptor->Signature != FLASH_DESCRIPTOR_SIGNATURE) {
        return U_ITEM_NOT_FOUND;
    }

    // Parse descriptor map
    const FLASH_DESCRIPTOR_MAP* descriptorMap = (const FLASH_DESCRIPTOR_MAP*)((UINT8*)descriptor + sizeof(FLASH_DESCRIPTOR_HEADER));
    const FLASH_DESCRIPTOR_UPPER_MAP* upperMap = (const FLASH_DESCRIPTOR_UPPER_MAP*)((UINT8*)descriptor + FLASH_DESCRIPTOR_UPPER_MAP_BASE);

    // Check sanity of base values
    if (descriptorMap->MasterBase > FLASH_DESCRIPTOR_MAX_BASE
        || descriptorMap->MasterBase == descriptorMap->RegionBase
        || descriptorMap->MasterBase == descriptorMap->ComponentBase) {
        msg(usprintf("%s: invalid descriptor master base %02Xh", __FUNCTION__, descriptorMap->MasterBase));
        return U_INVALID_FLASH_DESCRIPTOR;
    }
    if (descriptorMap->RegionBase > FLASH_DESCRIPTOR_MAX_BASE
        || descriptorMap->RegionBase == descriptorMap->ComponentBase) {
        msg(usprintf("%s: invalid descriptor region base %02Xh", __FUNCTION__, descriptorMap->RegionBase));
        return U_INVALID_FLASH_DESCRIPTOR;
    }
    if (descriptorMap->ComponentBase > FLASH_DESCRIPTOR_MAX_BASE) {
        msg(usprintf("%s: invalid descriptor component base %02Xh", __FUNCTION__, descriptorMap->ComponentBase));
        return U_INVALID_FLASH_DESCRIPTOR;
    }

    const FLASH_DESCRIPTOR_REGION_SECTION* regionSection = (const FLASH_DESCRIPTOR_REGION_SECTION*)calculateAddress8((UINT8*)descriptor, descriptorMap->RegionBase);
    const FLASH_DESCRIPTOR_COMPONENT_SECTION* componentSection = (const FLASH_DESCRIPTOR_COMPONENT_SECTION*)calculateAddress8((UINT8*)descriptor, descriptorMap->ComponentBase);

    UINT8 descriptorVersion = 2;
    // Check descriptor version by getting hardcoded value of FlashParameters.ReadClockFrequency
    if (componentSection->FlashParameters.ReadClockFrequency == FLASH_FREQUENCY_20MHZ)
        descriptorVersion = 1;

    // Regions
    std::vector<REGION_INFO> regions;

    // ME region
    REGION_INFO me;
    me.type = Subtypes::MeRegion;
    me.offset = 0;
    me.length = 0;
    if (regionSection->MeLimit) {
        me.offset = calculateRegionOffset(regionSection->MeBase);
        me.length = calculateRegionSize(regionSection->MeBase, regionSection->MeLimit);
        me.data = intelImage.mid(me.offset, me.length);
        regions.push_back(me);
    }

    // BIOS region
    if (regionSection->BiosLimit) {
        REGION_INFO bios;
        bios.type = Subtypes::BiosRegion;
        bios.offset = calculateRegionOffset(regionSection->BiosBase);
        bios.length = calculateRegionSize(regionSection->BiosBase, regionSection->BiosLimit);

        // Check for Gigabyte specific descriptor map
        if (bios.length == (UINT32)intelImage.size()) {
            if (!me.offset) {
                msg(usprintf("%s: can't determine BIOS region start from Gigabyte-specific descriptor", __FUNCTION__));
                return U_INVALID_FLASH_DESCRIPTOR;
            }
            // Use ME region end as BIOS region offset
            bios.offset = me.offset + me.length;
            bios.length = (UINT32)intelImage.size() - bios.offset;
            bios.data = intelImage.mid(bios.offset, bios.length);
        }
        // Normal descriptor map
        else {
            bios.data = intelImage.mid(bios.offset, bios.length);
        }

        regions.push_back(bios);
    }
    else {
        msg(usprintf("%s: descriptor parsing failed, BIOS region not found in descriptor", __FUNCTION__));
        return U_INVALID_FLASH_DESCRIPTOR;
    }

    // Add all other regions
    for (UINT8 i = Subtypes::GbeRegion; i <= Subtypes::PttRegion; i++) {
        if (descriptorVersion == 1 && i == Subtypes::MicrocodeRegion)
            break; // Do not parse Microcode and other following regions for legacy descriptors

        const UINT16* RegionBase = ((const UINT16*)regionSection) + 2 * i;
        const UINT16* RegionLimit = ((const UINT16*)regionSection) + 2 * i + 1;
        if (*RegionLimit && !(*RegionBase == 0xFFFF && *RegionLimit == 0xFFFF)) {
            REGION_INFO region;
            region.type = i;
            region.offset = calculateRegionOffset(*RegionBase);
            region.length = calculateRegionSize(*RegionBase, *RegionLimit);
            if (region.length != 0) {
                region.data = intelImage.mid(region.offset, region.length);
                regions.push_back(region);
            }
        }
    }

    // Sort regions in ascending order
    std::sort(regions.begin(), regions.end());

    // Check for intersections and paddings between regions
    REGION_INFO region;
    // Check intersection with the descriptor
    if (regions.front().offset < FLASH_DESCRIPTOR_SIZE) {
        msg(usprintf("%s: ", __FUNCTION__) + itemSubtypeToUString(Types::Region, regions.front().type)
            + UString(" region has intersection with flash descriptor"),
            index);
        return U_INVALID_FLASH_DESCRIPTOR;
    }
    // Check for padding between descriptor and the first region
    else if (regions.front().offset > FLASH_DESCRIPTOR_SIZE) {
        region.offset = FLASH_DESCRIPTOR_SIZE;
        region.length = regions.front().offset - FLASH_DESCRIPTOR_SIZE;
        region.data = intelImage.mid(region.offset, region.length);
        region.type = getPaddingType(region.data);
        regions.insert(regions.begin(), region);
    }
    // Check for intersections/paddings between regions
    for (size_t i = 1; i < regions.size(); i++) {
        UINT32 previousRegionEnd = regions[i-1].offset + regions[i-1].length;
        // Check that current region is fully present in the image
        if ((UINT64)regions[i].offset + (UINT64)regions[i].length > (UINT64)intelImage.size()) {
            msg(usprintf("%s: ", __FUNCTION__) + itemSubtypeToUString(Types::Region, regions[i].type)
                + UString(" region is located outside of the opened image. If your system uses dual-chip storage, please append another part to the opened image"),
                index);
            return U_TRUNCATED_IMAGE;
        }

        // Check for intersection with previous region
        if (regions[i].offset < previousRegionEnd) {
            msg(usprintf("%s: ", __FUNCTION__) + itemSubtypeToUString(Types::Region, regions[i].type)
                + UString(" region has intersection with ") + itemSubtypeToUString(Types::Region, regions[i - 1].type) +UString(" region"),
                index);
            return U_INVALID_FLASH_DESCRIPTOR;
        }
        // Check for padding between current and previous regions
        else if (regions[i].offset > previousRegionEnd) {
            region.offset = previousRegionEnd;
            region.length = regions[i].offset - previousRegionEnd;
            region.data = intelImage.mid(region.offset, region.length);
            region.type = getPaddingType(region.data);
            std::vector<REGION_INFO>::iterator iter = regions.begin();
            std::advance(iter, i);
            regions.insert(iter, region);
        }
    }
    // Check for padding after the last region
    if ((UINT64)regions.back().offset + (UINT64)regions.back().length < (UINT64)intelImage.size()) {
        region.offset = regions.back().offset + regions.back().length;
        region.length = intelImage.size() - region.offset;
        region.data = intelImage.mid(region.offset, region.length);
        region.type = getPaddingType(region.data);
        regions.push_back(region);
    }

    // Region map is consistent

    // Intel image
    UString name("Intel image");
    UString info = usprintf("Full size: %Xh (%u)\nFlash chips: %u\nRegions: %u\nMasters: %u\nPCH straps: %u\nPROC straps: %u",
        intelImage.size(), intelImage.size(),
        descriptorMap->NumberOfFlashChips + 1, //
        descriptorMap->NumberOfRegions + 1,    // Zero-based numbers in storage
        descriptorMap->NumberOfMasters + 1,    //
        descriptorMap->NumberOfPchStraps,
        descriptorMap->NumberOfProcStraps);

    // Set image base
    imageBase = model->base(parent) + localOffset;

    // Add Intel image tree item
    index = model->addItem(localOffset, Types::Image, Subtypes::IntelImage, name, UString(), info, UByteArray(), intelImage, UByteArray(), Fixed, parent);

    // Descriptor
    // Get descriptor info
    UByteArray body = intelImage.left(FLASH_DESCRIPTOR_SIZE);
    name = UString("Descriptor region");
    info = usprintf("ReservedVector:\n%02X %02X %02X %02X %02X %02X %02X %02X\n"
                    "%02X %02X %02X %02X %02X %02X %02X %02X\nFull size: %Xh (%u)",
                    descriptor->ReservedVector[0],  descriptor->ReservedVector[1],  descriptor->ReservedVector[2],  descriptor->ReservedVector[3],
                    descriptor->ReservedVector[4],  descriptor->ReservedVector[5],  descriptor->ReservedVector[6],  descriptor->ReservedVector[7],
                    descriptor->ReservedVector[8],  descriptor->ReservedVector[9],  descriptor->ReservedVector[10], descriptor->ReservedVector[11],
                    descriptor->ReservedVector[12], descriptor->ReservedVector[13], descriptor->ReservedVector[14], descriptor->ReservedVector[15],
                    FLASH_DESCRIPTOR_SIZE, FLASH_DESCRIPTOR_SIZE);

    // Add offsets of actual regions
    for (size_t i = 0; i < regions.size(); i++) {
        if (regions[i].type != Subtypes::ZeroPadding && regions[i].type != Subtypes::OnePadding && regions[i].type != Subtypes::DataPadding)
            info += UString("\n") + itemSubtypeToUString(Types::Region, regions[i].type)
            + usprintf(" region offset: %Xh", regions[i].offset + localOffset);
    }

    // Region access settings
    if (descriptorVersion == 1) {
        const FLASH_DESCRIPTOR_MASTER_SECTION* masterSection = (const FLASH_DESCRIPTOR_MASTER_SECTION*)calculateAddress8((UINT8*)descriptor, descriptorMap->MasterBase);
        info += UString("\nRegion access settings:");
        info += usprintf("\nBIOS: %02Xh %02Xh ME: %02Xh %02Xh\nGbE:  %02Xh %02Xh",
            masterSection->BiosRead,
            masterSection->BiosWrite,
            masterSection->MeRead,
            masterSection->MeWrite,
            masterSection->GbeRead,
            masterSection->GbeWrite);

        // BIOS access table
        info  += UString("\nBIOS access table:")
               + UString("\n      Read  Write")
              + usprintf("\nDesc  %s  %s",  masterSection->BiosRead  & FLASH_DESCRIPTOR_REGION_ACCESS_DESC ? "Yes " : "No  ",
                                            masterSection->BiosWrite & FLASH_DESCRIPTOR_REGION_ACCESS_DESC ? "Yes " : "No  ");
        info  += UString("\nBIOS  Yes   Yes")
              + usprintf("\nME    %s  %s",  masterSection->BiosRead  & FLASH_DESCRIPTOR_REGION_ACCESS_ME   ? "Yes " : "No  ",
                                            masterSection->BiosWrite & FLASH_DESCRIPTOR_REGION_ACCESS_ME   ? "Yes " : "No  ");
        info += usprintf("\nGbE   %s  %s",  masterSection->BiosRead  & FLASH_DESCRIPTOR_REGION_ACCESS_GBE  ? "Yes " : "No  ",
                                            masterSection->BiosWrite & FLASH_DESCRIPTOR_REGION_ACCESS_GBE  ? "Yes " : "No  ");
        info += usprintf("\nPDR   %s  %s",  masterSection->BiosRead  & FLASH_DESCRIPTOR_REGION_ACCESS_PDR  ? "Yes " : "No  ",
                                            masterSection->BiosWrite & FLASH_DESCRIPTOR_REGION_ACCESS_PDR  ? "Yes " : "No  ");
    }
    else if (descriptorVersion == 2) {
        const FLASH_DESCRIPTOR_MASTER_SECTION_V2* masterSection = (const FLASH_DESCRIPTOR_MASTER_SECTION_V2*)calculateAddress8((UINT8*)descriptor, descriptorMap->MasterBase);
        info += UString("\nRegion access settings:");
        info += usprintf("\nBIOS: %03Xh %03Xh ME: %03Xh %03Xh\nGbE:  %03Xh %03Xh EC: %03Xh %03Xh",
            masterSection->BiosRead,
            masterSection->BiosWrite,
            masterSection->MeRead,
            masterSection->MeWrite,
            masterSection->GbeRead,
            masterSection->GbeWrite,
            masterSection->EcRead,
            masterSection->EcWrite);

        // BIOS access table
        info  += UString("\nBIOS access table:")
               + UString("\n      Read  Write")
              + usprintf("\nDesc  %s  %s",
            masterSection->BiosRead  & FLASH_DESCRIPTOR_REGION_ACCESS_DESC ? "Yes " : "No  ",
            masterSection->BiosWrite & FLASH_DESCRIPTOR_REGION_ACCESS_DESC ? "Yes " : "No  ");
        info  += UString("\nBIOS  Yes   Yes")
              + usprintf("\nME    %s  %s",
            masterSection->BiosRead  & FLASH_DESCRIPTOR_REGION_ACCESS_ME ? "Yes " : "No  ",
            masterSection->BiosWrite & FLASH_DESCRIPTOR_REGION_ACCESS_ME ? "Yes " : "No  ");
        info += usprintf("\nGbE   %s  %s",
            masterSection->BiosRead  & FLASH_DESCRIPTOR_REGION_ACCESS_GBE ? "Yes " : "No  ",
            masterSection->BiosWrite & FLASH_DESCRIPTOR_REGION_ACCESS_GBE ? "Yes " : "No  ");
        info += usprintf("\nPDR   %s  %s",
            masterSection->BiosRead  & FLASH_DESCRIPTOR_REGION_ACCESS_PDR ? "Yes " : "No  ",
            masterSection->BiosWrite & FLASH_DESCRIPTOR_REGION_ACCESS_PDR ? "Yes " : "No  ");
        info += usprintf("\nEC    %s  %s",
            masterSection->BiosRead  & FLASH_DESCRIPTOR_REGION_ACCESS_EC ? "Yes " : "No  ",
            masterSection->BiosWrite & FLASH_DESCRIPTOR_REGION_ACCESS_EC ? "Yes " : "No  ");

        // Prepend descriptor version if present
        if (descriptorMap->DescriptorVersion != FLASH_DESCRIPTOR_VERSION_INVALID) {
            const FLASH_DESCRIPTOR_VERSION* version = (const FLASH_DESCRIPTOR_VERSION*)&descriptorMap->DescriptorVersion;
            UString versionStr = usprintf("Flash descriptor version: %d.%d", version->Major, version->Minor);
            if (version->Major != FLASH_DESCRIPTOR_VERSION_MAJOR || version->Minor != FLASH_DESCRIPTOR_VERSION_MINOR) {
                versionStr += ", unknown";
                msg(usprintf("%s: unknown flash descriptor version %d.%d", __FUNCTION__, version->Major, version->Minor));
            }
            info = versionStr + "\n" + info;
        }
    }

    // VSCC table
    const VSCC_TABLE_ENTRY* vsccTableEntry = (const VSCC_TABLE_ENTRY*)((UINT8*)descriptor + ((UINT16)upperMap->VsccTableBase << 4));
    info += UString("\nFlash chips in VSCC table:");
    UINT8 vsscTableSize = upperMap->VsccTableSize * sizeof(UINT32) / sizeof(VSCC_TABLE_ENTRY);
    for (UINT8 i = 0; i < vsscTableSize; i++) {
        UString jedecId = jedecIdToUString(vsccTableEntry->VendorId, vsccTableEntry->DeviceId0, vsccTableEntry->DeviceId1);
        info += usprintf("\n%02X%02X%02X (", vsccTableEntry->VendorId, vsccTableEntry->DeviceId0, vsccTableEntry->DeviceId1)
            + jedecId
            + UString(")");
        if (jedecId == UString("Unknown")) {
            msg(usprintf("%s: SPI flash with unknown JEDEC ID %02X%02X%02X found in VSCC table", __FUNCTION__,
                         vsccTableEntry->VendorId, vsccTableEntry->DeviceId0, vsccTableEntry->DeviceId1), index);
        }
        vsccTableEntry++;
    }

    // Add descriptor tree item
    UModelIndex regionIndex = model->addItem(localOffset, Types::Region, Subtypes::DescriptorRegion, name, UString(), info, UByteArray(), body, UByteArray(), Fixed, index);


    // Parse regions
    USTATUS result = U_SUCCESS;
    USTATUS parseResult = U_SUCCESS;
    for (size_t i = 0; i < regions.size(); i++) {
        region = regions[i];
        switch (region.type) {
        case Subtypes::BiosRegion:
            result = parseBiosRegion(region.data, region.offset, index, regionIndex);
            break;
        case Subtypes::MeRegion:
            result = parseMeRegion(region.data, region.offset, index, regionIndex);
            break;
        case Subtypes::GbeRegion:
            result = parseGbeRegion(region.data, region.offset, index, regionIndex);
            break;
        case Subtypes::PdrRegion:
            result = parsePdrRegion(region.data, region.offset, index, regionIndex);
            break;
        case Subtypes::DevExp1Region:
            result = parseDevExp1Region(region.data, region.offset, index, regionIndex);
            break;
        case Subtypes::Bios2Region:
        case Subtypes::MicrocodeRegion:
        case Subtypes::EcRegion:
        case Subtypes::DevExp2Region:
        case Subtypes::IeRegion:
        case Subtypes::Tgbe1Region:
        case Subtypes::Tgbe2Region:
        case Subtypes::Reserved1Region:
        case Subtypes::Reserved2Region:
        case Subtypes::PttRegion:
            result = parseGenericRegion(region.type, region.data, region.offset, index, regionIndex);
            break;
        case Subtypes::ZeroPadding:
        case Subtypes::OnePadding:
        case Subtypes::DataPadding: {
            // Add padding between regions
            UByteArray padding = intelImage.mid(region.offset, region.length);

            // Get info
            name = UString("Padding");
            info = usprintf("Full size: %Xh (%u)",
                padding.size(), padding.size());

            // Add tree item
            regionIndex = model->addItem(region.offset, Types::Padding, getPaddingType(padding), name, UString(), info, UByteArray(), padding, UByteArray(), Fixed, index);
            result = U_SUCCESS;
            } break;
        default:
            msg(usprintf("%s: region of unknown type found", __FUNCTION__), index);
            result = U_INVALID_FLASH_DESCRIPTOR;
        }
        // Store the first failed result as a final result
        if (!parseResult && result) {
            parseResult = result;
        }
    }

    return parseResult;
}

USTATUS FfsParser::parseGbeRegion(const UByteArray & gbe, const UINT32 localOffset, const UModelIndex & parent, UModelIndex & index)
{
    // Check sanity
    if (gbe.isEmpty())
        return U_EMPTY_REGION;
    if ((UINT32)gbe.size() < GBE_VERSION_OFFSET + sizeof(GBE_VERSION))
        return U_INVALID_REGION;

    // Get info
    UString name("GbE region");
    const GBE_MAC_ADDRESS* mac = (const GBE_MAC_ADDRESS*)gbe.constData();
    const GBE_VERSION* version = (const GBE_VERSION*)(gbe.constData() + GBE_VERSION_OFFSET);
    UString info = usprintf("Full size: %Xh (%u)\nMAC: %02X:%02X:%02X:%02X:%02X:%02X\nVersion: %u.%u",
        gbe.size(), gbe.size(),
        mac->vendor[0], mac->vendor[1], mac->vendor[2],
        mac->device[0], mac->device[1], mac->device[2],
        version->major,
        version->minor);

    // Add tree item
    index = model->addItem(localOffset, Types::Region, Subtypes::GbeRegion, name, UString(), info, UByteArray(), gbe, UByteArray(), Fixed, parent);

    return U_SUCCESS;
}

USTATUS FfsParser::parseMeRegion(const UByteArray & me, const UINT32 localOffset, const UModelIndex & parent, UModelIndex & index)
{
    // Check sanity
    if (me.isEmpty())
        return U_EMPTY_REGION;

    // Get info
    UString name("ME region");
    UString info = usprintf("Full size: %Xh (%u)", me.size(), me.size());

    // Parse region
    bool versionFound = true;
    bool emptyRegion = false;
    // Check for empty region
    if (me.size() == me.count('\xFF') || me.size() == me.count('\x00')) {
        // Further parsing not needed
        emptyRegion = true;
        info += ("\nState: empty");
    }
    else {
        // Search for new signature
        INT32 versionOffset = me.indexOf(ME_VERSION_SIGNATURE2);
        if (versionOffset < 0){ // New signature not found
            // Search for old signature
            versionOffset = me.indexOf(ME_VERSION_SIGNATURE);
            if (versionOffset < 0){
                info += ("\nVersion: unknown");
                versionFound = false;
            }
        }

        // Check sanity
        if ((UINT32)me.size() < (UINT32)versionOffset + sizeof(ME_VERSION))
            return U_INVALID_REGION;

        // Add version information
        if (versionFound) {
            const ME_VERSION* version = (const ME_VERSION*)(me.constData() + versionOffset);
            info += usprintf("\nVersion: %u.%u.%u.%u",
                version->Major,
                version->Minor,
                version->Bugfix,
                version->Build);
        }
    }

    // Add tree item
    index = model->addItem(localOffset, Types::Region, Subtypes::MeRegion, name, UString(), info, UByteArray(), me, UByteArray(), Fixed, parent);

    // Show messages
    if (emptyRegion) {
        msg(usprintf("%s: ME region is empty", __FUNCTION__), index);
    }
    else if (!versionFound) {
        msg(usprintf("%s: ME version is unknown, it can be damaged", __FUNCTION__), index);
    }
    else {
        meParser->parseMeRegionBody(index);
    }

    return U_SUCCESS;
}

USTATUS FfsParser::parsePdrRegion(const UByteArray & pdr, const UINT32 localOffset, const UModelIndex & parent, UModelIndex & index)
{
    // Check sanity
    if (pdr.isEmpty())
        return U_EMPTY_REGION;

    // Get info
    UString name("PDR region");
    UString info = usprintf("Full size: %Xh (%u)", pdr.size(), pdr.size());

    // Add tree item
    index = model->addItem(localOffset, Types::Region, Subtypes::PdrRegion, name, UString(), info, UByteArray(), pdr, UByteArray(), Fixed, parent);

    // Parse PDR region as BIOS space
    USTATUS result = parseRawArea(index);
    if (result && result != U_VOLUMES_NOT_FOUND && result != U_INVALID_VOLUME && result != U_STORES_NOT_FOUND)
        return result;

    return U_SUCCESS;
}

USTATUS FfsParser::parseDevExp1Region(const UByteArray & devExp1, const UINT32 localOffset, const UModelIndex & parent, UModelIndex & index)
{
    // Check sanity
    if (devExp1.isEmpty())
        return U_EMPTY_REGION;

    // Get info
    UString name("DevExp1 region");
    UString info = usprintf("Full size: %Xh (%u)", devExp1.size(), devExp1.size());

    bool emptyRegion = false;
    // Check for empty region
    if (devExp1.size() == devExp1.count('\xFF') || devExp1.size() == devExp1.count('\x00')) {
        // Further parsing not needed
        emptyRegion = true;
        info += ("\nState: empty");
    }

    // Add tree item
    index = model->addItem(localOffset, Types::Region, Subtypes::DevExp1Region, name, UString(), info, UByteArray(), devExp1, UByteArray(), Fixed, parent);

    if (!emptyRegion) {
        meParser->parseMeRegionBody(index);
    }
    return U_SUCCESS;
}

USTATUS FfsParser::parseGenericRegion(const UINT8 subtype, const UByteArray & region, const UINT32 localOffset, const UModelIndex & parent, UModelIndex & index)
{
    // Check sanity
    if (region.isEmpty())
        return U_EMPTY_REGION;

    // Get info
    UString name = itemSubtypeToUString(Types::Region, subtype) + UString(" region");
    UString info = usprintf("Full size: %Xh (%u)", region.size(), region.size());

    // Add tree item
    index = model->addItem(localOffset, Types::Region, subtype, name, UString(), info, UByteArray(), region, UByteArray(), Fixed, parent);

    return U_SUCCESS;
}

USTATUS FfsParser::parseBiosRegion(const UByteArray & bios, const UINT32 localOffset, const UModelIndex & parent, UModelIndex & index)
{
    // Sanity check
    if (bios.isEmpty())
        return U_EMPTY_REGION;

    // Get info
    UString name("BIOS region");
    UString info = usprintf("Full size: %Xh (%u)", bios.size(), bios.size());

    // Add tree item
    index = model->addItem(localOffset, Types::Region, Subtypes::BiosRegion, name, UString(), info, UByteArray(), bios, UByteArray(), Fixed, parent);

    return parseRawArea(index);
}

USTATUS FfsParser::parseRawArea(const UModelIndex & index)
{
    // Sanity check
    if (!index.isValid())
        return U_INVALID_PARAMETER;

    // Get item data
    UByteArray data = model->body(index);
    UINT32 headerSize = model->header(index).size();

    USTATUS result;
    UString name;
    UString info;

    // Search for the first item
    UINT8  prevItemType = 0;
    UINT32 prevItemOffset = 0;
    UINT32 prevItemSize = 0;
    UINT32 prevItemAltSize = 0;

    result = findNextRawAreaItem(index, 0, prevItemType, prevItemOffset, prevItemSize, prevItemAltSize);
    if (result) {
        // No need to parse further
        return U_SUCCESS;
    }

    // Set base of protected regions to be the first volume
    if (model->type(index) == Types::Region
        && model->subtype(index) == Subtypes::BiosRegion) {
        bgProtectedRegionsBase = (UINT64)model->base(index) + prevItemOffset;
    }

    // First item is not at the beginning of this raw area
    if (prevItemOffset > 0) {
        // Get info
        UByteArray padding = data.left(prevItemOffset);
        name = UString("Padding");
        info = usprintf("Full size: %Xh (%u)", padding.size(), padding.size());

        // Add tree item
        model->addItem(headerSize, Types::Padding, getPaddingType(padding), name, UString(), info, UByteArray(), padding, UByteArray(), Fixed, index);
    }

    // Search for and parse all items
    UINT8  itemType = prevItemType;
    UINT32 itemOffset = prevItemOffset;
    UINT32 itemSize = prevItemSize;
    UINT32 itemAltSize = prevItemAltSize;

    while (!result) {
        // Padding between items
        if (itemOffset > prevItemOffset + prevItemSize) {
            UINT32 paddingOffset = prevItemOffset + prevItemSize;
            UINT32 paddingSize = itemOffset - paddingOffset;
            UByteArray padding = data.mid(paddingOffset, paddingSize);

            // Get info
            name = UString("Padding");
            info = usprintf("Full size: %Xh (%u)", padding.size(), padding.size());

            // Add tree item
            model->addItem(headerSize + paddingOffset, Types::Padding, getPaddingType(padding), name, UString(), info, UByteArray(), padding, UByteArray(), Fixed, index);
        }

        // Check that item is fully present in input
        if (itemSize > (UINT32)data.size() || itemOffset + itemSize > (UINT32)data.size()) {
            // Mark the rest as padding and finish parsing
            UByteArray padding = data.mid(itemOffset);

            // Get info
            name = UString("Padding");
            info = usprintf("Full size: %Xh (%u)", padding.size(), padding.size());

            // Add tree item
            UModelIndex paddingIndex = model->addItem(headerSize + itemOffset, Types::Padding, getPaddingType(padding), name, UString(), info, UByteArray(), padding, UByteArray(), Fixed, index);
            msg(usprintf("%s: one of volumes inside overlaps the end of data", __FUNCTION__), paddingIndex);

            // Update variables
            prevItemOffset = itemOffset;
            prevItemSize = padding.size();
            break;
        }

        // Parse current volume's header
        if (itemType == Types::Volume) {
            UModelIndex volumeIndex;
            UByteArray volume = data.mid(itemOffset, itemSize);
            result = parseVolumeHeader(volume, headerSize + itemOffset, index, volumeIndex);
            if (result) {
                msg(usprintf("%s: volume header parsing failed with error ", __FUNCTION__) + errorCodeToUString(result), index);
            } else {
                // Show messages
                if (itemSize != itemAltSize)
                    msg(usprintf("%s: volume size stored in header %Xh differs from calculated using block map %Xh", __FUNCTION__,
                    itemSize, itemAltSize),
                    volumeIndex);
            }
        }
        else if (itemType == Types::Microcode) {
            UModelIndex microcodeIndex;
            UByteArray microcode = data.mid(itemOffset, itemSize);
            result = parseIntelMicrocodeHeader(microcode, headerSize + itemOffset, index, microcodeIndex);
            if (result) {
                msg(usprintf("%s: microcode header parsing failed with error ", __FUNCTION__) + errorCodeToUString(result), index);
            }
        }
        else if (itemType == Types::BpdtStore) {
            UByteArray bpdtStore = data.mid(itemOffset, itemSize);

            // Get info
            name = UString("BPDT region");
            info = usprintf("Full size: %Xh (%u)", bpdtStore.size(), bpdtStore.size());

            // Add tree item
            UModelIndex bpdtIndex = model->addItem(headerSize + itemOffset, Types::BpdtStore, 0, name, UString(), info, UByteArray(), bpdtStore, UByteArray(), Fixed, index);

            // Parse BPDT region
            UModelIndex bpdtPtIndex;
            result = parseBpdtRegion(bpdtStore, 0, 0, bpdtIndex, bpdtPtIndex);
            if (result) {
                msg(usprintf("%s: BPDT store parsing failed with error ", __FUNCTION__) + errorCodeToUString(result), index);
            }
        }
        else {
            return U_UNKNOWN_ITEM_TYPE;
        }

        // Go to next item
        prevItemOffset = itemOffset;
        prevItemSize = itemSize;
        prevItemType = itemType;
        result = findNextRawAreaItem(index, itemOffset + prevItemSize, itemType, itemOffset, itemSize, itemAltSize);

        // Silence value not used after assignment warning
        (void)prevItemType;
    }

    // Padding at the end of RAW area
    itemOffset = prevItemOffset + prevItemSize;
    if ((UINT32)data.size() > itemOffset) {
        UByteArray padding = data.mid(itemOffset);

        // Get info
        name = UString("Padding");
        info = usprintf("Full size: %Xh (%u)", padding.size(), padding.size());

        // Add tree item
        model->addItem(headerSize + itemOffset, Types::Padding, getPaddingType(padding), name, UString(), info, UByteArray(), padding, UByteArray(), Fixed, index);
    }

    // Parse bodies
    for (int i = 0; i < model->rowCount(index); i++) {
        UModelIndex current = index.child(i, 0);
        switch (model->type(current)) {
        case Types::Volume:
            parseVolumeBody(current);
            break;
        case Types::Microcode:
            // Parsing already done
            break;
        case Types::BpdtStore:
            // Parsing already done
            break;
        case Types::BpdtPartition:
            // Parsing already done
            break;
        case Types::Padding:
            // No parsing required
            break;
        default:
            return U_UNKNOWN_ITEM_TYPE;
        }
    }

    return U_SUCCESS;
}

USTATUS FfsParser::parseVolumeHeader(const UByteArray & volume, const UINT32 localOffset, const UModelIndex & parent, UModelIndex & index)
{
    // Sanity check
    if (volume.isEmpty())
        return U_INVALID_PARAMETER;

    // Check that there is space for the volume header
        if ((UINT32)volume.size() < sizeof(EFI_FIRMWARE_VOLUME_HEADER)) {
        msg(usprintf("%s: input volume size %Xh (%u) is smaller than volume header size 40h (64)", __FUNCTION__, volume.size(), volume.size()));
        return U_INVALID_VOLUME;
    }

    // Populate volume header
    const EFI_FIRMWARE_VOLUME_HEADER* volumeHeader = (const EFI_FIRMWARE_VOLUME_HEADER*)(volume.constData());

    // Check sanity of HeaderLength value
    if ((UINT32)ALIGN8(volumeHeader->HeaderLength) > (UINT32)volume.size()) {
        msg(usprintf("%s: volume header overlaps the end of data", __FUNCTION__));
        return U_INVALID_VOLUME;
    }
    // Check sanity of ExtHeaderOffset value
    if (volumeHeader->Revision > 1 && volumeHeader->ExtHeaderOffset
        && (UINT32)ALIGN8(volumeHeader->ExtHeaderOffset + sizeof(EFI_FIRMWARE_VOLUME_EXT_HEADER)) > (UINT32)volume.size()) {
        msg(usprintf("%s: extended volume header overlaps the end of data", __FUNCTION__));
        return U_INVALID_VOLUME;
    }

    // Calculate volume header size
    UINT32 headerSize;
    EFI_GUID extendedHeaderGuid = {0, 0, 0, {0, 0, 0, 0, 0, 0, 0, 0 }};
    bool hasExtendedHeader = false;
    if (volumeHeader->Revision > 1 && volumeHeader->ExtHeaderOffset) {
        hasExtendedHeader = true;
        const EFI_FIRMWARE_VOLUME_EXT_HEADER* extendedHeader = (const EFI_FIRMWARE_VOLUME_EXT_HEADER*)(volume.constData() + volumeHeader->ExtHeaderOffset);
        headerSize = volumeHeader->ExtHeaderOffset + extendedHeader->ExtHeaderSize;
        extendedHeaderGuid = extendedHeader->FvName;
    }
    else {
        headerSize = volumeHeader->HeaderLength;
    }

    // Extended header end can be unaligned
    headerSize = ALIGN8(headerSize);

    // Check for volume structure to be known
    bool isUnknown = true;
    bool isNvramVolume = false;
    bool isMicrocodeVolume = false;
    UINT8 ffsVersion = 0;

    // Check for FFS v2 volume
    UByteArray guid = UByteArray((const char*)&volumeHeader->FileSystemGuid, sizeof(EFI_GUID));
    if (std::find(FFSv2Volumes.begin(), FFSv2Volumes.end(), guid) != FFSv2Volumes.end()) {
        isUnknown = false;
        ffsVersion = 2;
    }
    // Check for FFS v3 volume
    else if (std::find(FFSv3Volumes.begin(), FFSv3Volumes.end(), guid) != FFSv3Volumes.end()) {
        isUnknown = false;
        ffsVersion = 3;
    }
    // Check for VSS NVRAM volume
    else if (guid == NVRAM_MAIN_STORE_VOLUME_GUID || guid == NVRAM_ADDITIONAL_STORE_VOLUME_GUID) {
        isUnknown = false;
        isNvramVolume = true;
    }
    // Check for Microcode volume
    else if (guid == EFI_APPLE_MICROCODE_VOLUME_GUID) {
        isUnknown = false;
        isMicrocodeVolume = true;
        headerSize = EFI_APPLE_MICROCODE_VOLUME_HEADER_SIZE;
    }

    // Check volume revision and alignment
    bool msgAlignmentBitsSet = false;
    bool msgUnaligned = false;
    bool msgUnknownRevision = false;
    UINT32 alignment = 0x10000; // Default volume alignment is 64K
    if (volumeHeader->Revision == 1) {
        // Acquire alignment capability bit
        bool alignmentCap = (volumeHeader->Attributes & EFI_FVB_ALIGNMENT_CAP) != 0;
        if (!alignmentCap) {
            if (volumeHeader->Attributes & 0xFFFF0000)
                msgAlignmentBitsSet = true;
        }
        // Do not check for volume alignment on revision 1 volumes
        // No one gives a single damn about setting it correctly
    }
    else if (volumeHeader->Revision == 2) {
        // Acquire alignment
        alignment = (UINT32)(1UL << ((volumeHeader->Attributes & EFI_FVB2_ALIGNMENT) >> 16));
        // Check alignment
        if (!isUnknown && !model->compressed(parent) && ((model->base(parent) + localOffset - imageBase) % alignment))
            msgUnaligned = true;
    }
    else {
        msgUnknownRevision = true;
    }

    // Check attributes
    // Determine value of empty byte
    UINT8 emptyByte = volumeHeader->Attributes & EFI_FVB_ERASE_POLARITY ? '\xFF' : '\x00';

    // Check for AppleCRC32 and UsedSpace in ZeroVector
    bool hasAppleCrc32 = false;
    UINT32 volumeSize = volume.size();
    UINT32 appleCrc32 = *(UINT32*)(volume.constData() + 8);
    UINT32 usedSpace = *(UINT32*)(volume.constData() + 12);
    if (appleCrc32 != 0) {
        // Calculate CRC32 of the volume body
        UINT32 crc = (UINT32)crc32(0, (const UINT8*)(volume.constData() + volumeHeader->HeaderLength), volumeSize - volumeHeader->HeaderLength);
        if (crc == appleCrc32) {
            hasAppleCrc32 = true;
        }
    }

    // Check header checksum by recalculating it
    bool msgInvalidChecksum = false;
    UByteArray tempHeader((const char*)volumeHeader, volumeHeader->HeaderLength);
    ((EFI_FIRMWARE_VOLUME_HEADER*)tempHeader.data())->Checksum = 0;
    UINT16 calculated = calculateChecksum16((const UINT16*)tempHeader.constData(), volumeHeader->HeaderLength);
    if (volumeHeader->Checksum != calculated)
        msgInvalidChecksum = true;

    // Get info
    UByteArray header = volume.left(headerSize);
    UByteArray body = volume.mid(headerSize);
    UString name = guidToUString(volumeHeader->FileSystemGuid);
    UString info = usprintf("ZeroVector:\n%02X %02X %02X %02X %02X %02X %02X %02X\n"
        "%02X %02X %02X %02X %02X %02X %02X %02X\nSignature: _FVH\nFileSystem GUID: ",
        volumeHeader->ZeroVector[0], volumeHeader->ZeroVector[1], volumeHeader->ZeroVector[2], volumeHeader->ZeroVector[3],
        volumeHeader->ZeroVector[4], volumeHeader->ZeroVector[5], volumeHeader->ZeroVector[6], volumeHeader->ZeroVector[7],
        volumeHeader->ZeroVector[8], volumeHeader->ZeroVector[9], volumeHeader->ZeroVector[10], volumeHeader->ZeroVector[11],
        volumeHeader->ZeroVector[12], volumeHeader->ZeroVector[13], volumeHeader->ZeroVector[14], volumeHeader->ZeroVector[15])
        + guidToUString(volumeHeader->FileSystemGuid, false) \
        + usprintf("\nFull size: %Xh (%u)\nHeader size: %Xh (%u)\nBody size: %Xh (%u)\nRevision: %u\nAttributes: %08Xh\nErase polarity: %u\nChecksum: %04Xh",
        volumeSize, volumeSize,
        headerSize, headerSize,
        volumeSize - headerSize, volumeSize - headerSize,
        volumeHeader->Revision,
        volumeHeader->Attributes,
        (emptyByte ? 1 : 0),
        volumeHeader->Checksum) +
        (msgInvalidChecksum ? usprintf(", invalid, should be %04Xh", calculated) : UString(", valid"));

    // Extended header present
    if (volumeHeader->Revision > 1 && volumeHeader->ExtHeaderOffset) {
        const EFI_FIRMWARE_VOLUME_EXT_HEADER* extendedHeader = (const EFI_FIRMWARE_VOLUME_EXT_HEADER*)(volume.constData() + volumeHeader->ExtHeaderOffset);
        info += usprintf("\nExtended header size: %Xh (%u)\nVolume GUID: ",
            extendedHeader->ExtHeaderSize, extendedHeader->ExtHeaderSize) + guidToUString(extendedHeader->FvName, false);
        name = guidToUString(extendedHeader->FvName); // Replace FFS GUID with volume GUID
    }

    // Add text
    UString text;
    if (hasAppleCrc32)
        text += UString("AppleCRC32 ");

    // Add tree item
    UINT8 subtype = Subtypes::UnknownVolume;
    if (!isUnknown) {
        if (ffsVersion == 2)
            subtype = Subtypes::Ffs2Volume;
        else if (ffsVersion == 3)
            subtype = Subtypes::Ffs3Volume;
        else if (isNvramVolume)
            subtype = Subtypes::NvramVolume;
        else if (isMicrocodeVolume)
            subtype = Subtypes::MicrocodeVolume;
    }
    index = model->addItem(localOffset, Types::Volume, subtype, name, text, info, header, body, UByteArray(), Movable, parent);

    // Set parsing data for created volume
    VOLUME_PARSING_DATA pdata;
    pdata.emptyByte = emptyByte;
    pdata.ffsVersion = ffsVersion;
    pdata.hasExtendedHeader = hasExtendedHeader ? TRUE : FALSE;
    pdata.extendedHeaderGuid = extendedHeaderGuid;
    pdata.alignment = alignment;
    pdata.revision = volumeHeader->Revision;
    pdata.hasAppleCrc32 = hasAppleCrc32;
    pdata.hasValidUsedSpace = FALSE; // Will be updated later, if needed
    pdata.usedSpace = usedSpace;
    pdata.isWeakAligned = (volumeHeader->Revision > 1 && (volumeHeader->Attributes & EFI_FVB2_WEAK_ALIGNMENT));
    model->setParsingData(index, UByteArray((const char*)&pdata, sizeof(pdata)));

    // Show messages
    if (isUnknown)
        msg(usprintf("%s: unknown file system ", __FUNCTION__) + guidToUString(volumeHeader->FileSystemGuid), index);
    if (msgInvalidChecksum)
        msg(usprintf("%s: volume header checksum is invalid", __FUNCTION__), index);
    if (msgAlignmentBitsSet)
        msg(usprintf("%s: alignment bits set on volume without alignment capability", __FUNCTION__), index);
    if (msgUnaligned)
        msg(usprintf("%s: unaligned volume", __FUNCTION__), index);
    if (msgUnknownRevision)
        msg(usprintf("%s: unknown volume revision %u", __FUNCTION__, volumeHeader->Revision), index);

    return U_SUCCESS;
}

BOOLEAN FfsParser::microcodeHeaderValid(const INTEL_MICROCODE_HEADER* ucodeHeader)
{
    // Check main reserved bytes to be zero
    bool reservedBytesValid = true;
    for (UINT32 i = 0; i < sizeof(ucodeHeader->Reserved); i++) {
        if (ucodeHeader->Reserved[i] != 0x00) {
            reservedBytesValid = false;
            break;
        }
    }
    if (!reservedBytesValid) {
        return FALSE;
    }

    // Check CpuFlags reserved bytes to be zero
    for (UINT32 i = 0; i < sizeof(ucodeHeader->ProcessorFlagsReserved); i++) {
        if (ucodeHeader->ProcessorFlagsReserved[i] != 0x00) {
            reservedBytesValid = false;
            break;
        }
    }
    if (!reservedBytesValid) {
        return FALSE;
    }

    // Check data size to be multiple of 4 and less than 0x1000000
    if (ucodeHeader->DataSize % 4 != 0 ||
        ucodeHeader->DataSize > 0xFFFFFF) {
        return FALSE;
    }

    // Check TotalSize to be greater or equal than DataSize and less than 0x1000000
    if (ucodeHeader->TotalSize < ucodeHeader->DataSize ||
        ucodeHeader->TotalSize > 0xFFFFFF) {
        return FALSE;
    }

    // Check date to be sane
    // Check day to be in 0x01-0x09, 0x10-0x19, 0x20-0x29, 0x30-0x31
    if (ucodeHeader->DateDay < 0x01 ||
        (ucodeHeader->DateDay > 0x09 && ucodeHeader->DateDay < 0x10) ||
        (ucodeHeader->DateDay > 0x19 && ucodeHeader->DateDay < 0x20) ||
        (ucodeHeader->DateDay > 0x29 && ucodeHeader->DateDay < 0x30) ||
        ucodeHeader->DateDay > 0x31) {
        return FALSE;
    }
    // Check month to be in 0x01-0x09, 0x10-0x12
    if (ucodeHeader->DateMonth < 0x01 ||
        (ucodeHeader->DateMonth > 0x09 && ucodeHeader->DateMonth < 0x10) ||
        ucodeHeader->DateMonth > 0x12) {
        return FALSE;
    }
    // Check year to be in 0x1990-0x1999, 0x2000-0x2009, 0x2010-0x2019, 0x2020-0x2029, 0x2030-0x2030, 0x2040-0x2049
    if (ucodeHeader->DateYear < 0x1990 ||
        (ucodeHeader->DateYear > 0x1999 && ucodeHeader->DateYear < 0x2000) ||
        (ucodeHeader->DateYear > 0x2009 && ucodeHeader->DateYear < 0x2010) ||
        (ucodeHeader->DateYear > 0x2019 && ucodeHeader->DateYear < 0x2020) ||
        (ucodeHeader->DateYear > 0x2029 && ucodeHeader->DateYear < 0x2030) ||
        (ucodeHeader->DateYear > 0x2039 && ucodeHeader->DateYear < 0x2040) ||
        ucodeHeader->DateYear > 0x2049) {
        return FALSE;
    }
    // Check HeaderVersion to be 1.
    if (ucodeHeader->HeaderVersion != 1) {
        return FALSE;
    }
    // Check LoaderRevision to be 1.
    if (ucodeHeader->LoaderRevision != 1) {
        return FALSE;
    }

    return TRUE;
}

USTATUS FfsParser::findNextRawAreaItem(const UModelIndex & index, const UINT32 localOffset, UINT8 & nextItemType, UINT32 & nextItemOffset, UINT32 & nextItemSize, UINT32 & nextItemAlternativeSize)
{
    UByteArray data = model->body(index);
    UINT32 dataSize = data.size();

    if (dataSize < sizeof(UINT32))
        return U_STORES_NOT_FOUND;

    UINT32 offset = localOffset;
    for (; offset < dataSize - sizeof(UINT32); offset++) {
        const UINT32* currentPos = (const UINT32*)(data.constData() + offset);
        const UINT32 restSize = dataSize - offset;
        if (readUnaligned(currentPos) == INTEL_MICROCODE_HEADER_VERSION_1) {// Intel microcode
            // Check data size
            if (restSize < sizeof(INTEL_MICROCODE_HEADER)) {
                continue;
            }

            // Check microcode header candidate
            const INTEL_MICROCODE_HEADER* ucodeHeader = (const INTEL_MICROCODE_HEADER*)currentPos;
            if (FALSE == microcodeHeaderValid(ucodeHeader)) {
                continue;
            }

            // Check size candidate
            if (ucodeHeader->TotalSize == 0)
                continue;

            // All checks passed, microcode found
            nextItemType = Types::Microcode;
            nextItemSize = ucodeHeader->TotalSize;
            nextItemAlternativeSize = ucodeHeader->TotalSize;
            nextItemOffset = offset;
            break;
        }
        else if (readUnaligned(currentPos) == EFI_FV_SIGNATURE) {
            if (offset < EFI_FV_SIGNATURE_OFFSET)
                continue;

            const EFI_FIRMWARE_VOLUME_HEADER* volumeHeader = (const EFI_FIRMWARE_VOLUME_HEADER*)(data.constData() + offset - EFI_FV_SIGNATURE_OFFSET);
            if (volumeHeader->FvLength < sizeof(EFI_FIRMWARE_VOLUME_HEADER) + 2 * sizeof(EFI_FV_BLOCK_MAP_ENTRY) || volumeHeader->FvLength >= 0xFFFFFFFFUL) {
                continue;
            }
            if (volumeHeader->Revision != 1 && volumeHeader->Revision != 2) {
                continue;
            }

            // Calculate alternative volume size using it's BlockMap
            nextItemAlternativeSize = 0;
            const EFI_FV_BLOCK_MAP_ENTRY* entry = (const EFI_FV_BLOCK_MAP_ENTRY*)(data.constData() + offset - EFI_FV_SIGNATURE_OFFSET + sizeof(EFI_FIRMWARE_VOLUME_HEADER));
            while (entry->NumBlocks != 0 && entry->Length != 0) {
                if ((void*)entry >= data.constData() + data.size()) {
                   continue;
                }

                nextItemAlternativeSize += entry->NumBlocks * entry->Length;
                entry += 1;
            }

            // All checks passed, volume found
            nextItemType = Types::Volume;
            nextItemSize = (UINT32)volumeHeader->FvLength;
            nextItemOffset = offset - EFI_FV_SIGNATURE_OFFSET;
            break;
        }
        else if (readUnaligned(currentPos) == BPDT_GREEN_SIGNATURE || readUnaligned(currentPos) == BPDT_YELLOW_SIGNATURE) {
            // Check data size
            if (restSize < sizeof(BPDT_HEADER))
                continue;

            const BPDT_HEADER *bpdtHeader = (const BPDT_HEADER *)currentPos;
            // Check version
            if (bpdtHeader->HeaderVersion != BPDT_HEADER_VERSION_1) // IFWI 2.0 only for now
                continue;

            UINT32 ptBodySize = bpdtHeader->NumEntries * sizeof(BPDT_ENTRY);
            UINT32 ptSize = sizeof(BPDT_HEADER) + ptBodySize;
            // Check data size again
            if (restSize < ptSize)
                continue;

            UINT32 sizeCandidate = 0;
            // Parse partition table
            const BPDT_ENTRY* firstPtEntry = (const BPDT_ENTRY*)((const UINT8*)bpdtHeader + sizeof(BPDT_HEADER));
            for (UINT16 i = 0; i < bpdtHeader->NumEntries; i++) {
                // Populate entry header
                const BPDT_ENTRY* ptEntry = firstPtEntry + i;
                // Check that entry is present in the image
                if (ptEntry->Offset != 0
                    && ptEntry->Offset != 0xFFFFFFFF
                    && ptEntry->Size != 0
                    && sizeCandidate < ptEntry->Offset + ptEntry->Size) {
                        sizeCandidate = ptEntry->Offset + ptEntry->Size;
                }
            }

            // Check size candidate
            if (sizeCandidate == 0)
                continue;

             // All checks passed, BPDT found
            nextItemType = Types::BpdtStore;
            nextItemSize = sizeCandidate;
            nextItemAlternativeSize = sizeCandidate;
            nextItemOffset = offset;
            break;
        }
    }

    // No more stores found
    if (offset >= dataSize - sizeof(UINT32)) {
        return U_STORES_NOT_FOUND;
    }

    return U_SUCCESS;
}

USTATUS FfsParser::parseVolumeNonUefiData(const UByteArray & data, const UINT32 localOffset, const UModelIndex & index)
{
    // Sanity check
    if (!index.isValid())
        return U_INVALID_PARAMETER;

    // Get info
    UString info = usprintf("Full size: %Xh (%u)", data.size(), data.size());

    // Add padding tree item
    UModelIndex paddingIndex = model->addItem(localOffset, Types::Padding, Subtypes::DataPadding, UString("Non-UEFI data"), UString(), info, UByteArray(), data, UByteArray(), Fixed, index);
    msg(usprintf("%s: non-UEFI data found in volume's free space", __FUNCTION__), paddingIndex);

    // Parse contents as RAW area
    return parseRawArea(paddingIndex);
}

USTATUS FfsParser::parseVolumeBody(const UModelIndex & index)
{
    // Sanity check
    if (!index.isValid())
        return U_INVALID_PARAMETER;

    // Get volume header size and body
    UByteArray volumeBody = model->body(index);
    UINT32 volumeHeaderSize = model->header(index).size();

    // Parse VSS NVRAM volumes with a dedicated function
    if (model->subtype(index) == Subtypes::NvramVolume)
        return nvramParser->parseNvramVolumeBody(index);

    // Parse Microcode volume with a dedicated function
    if (model->subtype(index) == Subtypes::MicrocodeVolume)
        return parseMicrocodeVolumeBody(index);

    // Get required values from parsing data
    UINT8 emptyByte = 0xFF;
    UINT8 ffsVersion = 2;
    UINT32 usedSpace = 0;
    if (model->hasEmptyParsingData(index) == false) {
        UByteArray data = model->parsingData(index);
        const VOLUME_PARSING_DATA* pdata = (const VOLUME_PARSING_DATA*)data.constData();
        emptyByte = pdata->emptyByte;
        ffsVersion = pdata->ffsVersion;
        usedSpace = pdata->usedSpace;
    }

    // Check for unknown FFS version
    if (ffsVersion != 2 && ffsVersion != 3)
        return U_SUCCESS;

    // Search for and parse all files
    UINT32 volumeBodySize = volumeBody.size();
    UINT32 fileOffset = 0;

    while (fileOffset < volumeBodySize) {
        UINT32 fileSize = getFileSize(volumeBody, fileOffset, ffsVersion);

        if (fileSize == 0) {
            msg(usprintf("%s: file header parsing failed with invalid size", __FUNCTION__), index);
            return U_INVALID_PARAMETER;
        }

        // Check that we are at the empty space
        UByteArray header = volumeBody.mid(fileOffset, (int)std::min(sizeof(EFI_FFS_FILE_HEADER), (size_t)volumeBodySize - fileOffset));
        if (header.count(emptyByte) == header.size()) { //Empty space
            // Check volume usedSpace entry to be valid
            if (usedSpace > 0 && usedSpace == fileOffset + volumeHeaderSize) {
                if (model->hasEmptyParsingData(index) == false) {
                    UByteArray data = model->parsingData(index);
                    VOLUME_PARSING_DATA* pdata = (VOLUME_PARSING_DATA*)data.data();
                    pdata->hasValidUsedSpace = TRUE;
                    model->setParsingData(index, data);
                    model->setText(index, model->text(index) + "UsedSpace ");
                }
            }

            // Check free space to be actually free
            UByteArray freeSpace = volumeBody.mid(fileOffset);
            if (freeSpace.count(emptyByte) != freeSpace.size()) {
                // Search for the first non-empty byte
                UINT32 i;
                UINT32 size = freeSpace.size();
                const UINT8* current = (UINT8*)freeSpace.constData();
                for (i = 0; i < size; i++) {
                    if (*current++ != emptyByte)
                        break;
                }

                // Align found index to file alignment
                // It must be possible because minimum 16 bytes of empty were found before
                if (i != ALIGN8(i)) {
                    i = ALIGN8(i) - 8;
                }

                // Add all bytes before as free space
                if (i > 0) {
                    UByteArray free = freeSpace.left(i);

                    // Get info
                    UString info = usprintf("Full size: %Xh (%u)", free.size(), free.size());

                    // Add free space item
                    model->addItem(volumeHeaderSize + fileOffset, Types::FreeSpace, 0, UString("Volume free space"), UString(), info, UByteArray(), free, UByteArray(), Movable, index);
                }

                // Parse non-UEFI data
                parseVolumeNonUefiData(freeSpace.mid(i), volumeHeaderSize + fileOffset + i, index);
            }
            else {
                // Get info
                UString info = usprintf("Full size: %Xh (%u)", freeSpace.size(), freeSpace.size());

                // Add free space item
                model->addItem(volumeHeaderSize + fileOffset, Types::FreeSpace, 0, UString("Volume free space"), UString(), info, UByteArray(), freeSpace, UByteArray(), Movable, index);
            }
            break; // Exit from parsing loop
        }

        // We aren't at the end of empty space
        // Check that the remaining space can still have a file in it
        if (volumeBodySize - fileOffset < sizeof(EFI_FFS_FILE_HEADER) || // Remaining space is smaller than the smallest possible file
            volumeBodySize - fileOffset < fileSize) { // Remaining space is smaller than non-empty file size
            // Parse non-UEFI data
            parseVolumeNonUefiData(volumeBody.mid(fileOffset), volumeHeaderSize + fileOffset, index);
            break; // Exit from parsing loop
        }

        // Parse current file's header
        UModelIndex fileIndex;
        USTATUS result = parseFileHeader(volumeBody.mid(fileOffset, fileSize), volumeHeaderSize + fileOffset, index, fileIndex);
        if (result) {
            msg(usprintf("%s: file header parsing failed with error ", __FUNCTION__) + errorCodeToUString(result), index);
        }

        // Move to next file
        fileOffset += fileSize;
        fileOffset = ALIGN8(fileOffset);
    }

    // Check for duplicate GUIDs
    for (int i = 0; i < model->rowCount(index); i++) {
        UModelIndex current = index.child(i, 0);
        // Skip non-file entries and pad files
        if (model->type(current) != Types::File || model->subtype(current) == EFI_FV_FILETYPE_PAD)
            continue;

        // Get current file GUID
        UByteArray currentGuid(model->header(current).constData(), sizeof(EFI_GUID));

        // Check files after current for having an equal GUID
        for (int j = i + 1; j < model->rowCount(index); j++) {
            UModelIndex another = index.child(j, 0);

            // Skip non-file entries
            if (model->type(another) != Types::File)
                continue;

            // Get another file GUID
            UByteArray anotherGuid(model->header(another).constData(), sizeof(EFI_GUID));

            // Check GUIDs for being equal
            if (currentGuid == anotherGuid) {
                msg(usprintf("%s: file with duplicate GUID ", __FUNCTION__) + guidToUString(readUnaligned((EFI_GUID*)(anotherGuid.data()))), another);
            }
        }
    }

    //Parse bodies
    for (int i = 0; i < model->rowCount(index); i++) {
        UModelIndex current = index.child(i, 0);
        switch (model->type(current)) {
        case Types::File:
            parseFileBody(current);
            break;
        case Types::Padding:
        case Types::FreeSpace:
            // No parsing required
            break;
        default:
            return U_UNKNOWN_ITEM_TYPE;
        }
    }

    return U_SUCCESS;
}

UINT32 FfsParser::getFileSize(const UByteArray & volume, const UINT32 fileOffset, const UINT8 ffsVersion)
{
    if ((UINT32)volume.size() < fileOffset + sizeof(EFI_FFS_FILE_HEADER)) {
        return 0;
    }

    const EFI_FFS_FILE_HEADER* fileHeader = (const EFI_FFS_FILE_HEADER*)(volume.constData() + fileOffset);

    if (ffsVersion == 2) {
        return uint24ToUint32(fileHeader->Size);
    }
    else if (ffsVersion == 3) {
        if (fileHeader->Attributes & FFS_ATTRIB_LARGE_FILE) {
            if ((UINT32)volume.size() < fileOffset + sizeof(EFI_FFS_FILE_HEADER2)) {
                return 0;
            }

            const EFI_FFS_FILE_HEADER2* fileHeader2 = (const EFI_FFS_FILE_HEADER2*)(volume.constData() + fileOffset);
            return (UINT32) fileHeader2->ExtendedSize;
        }

        return uint24ToUint32(fileHeader->Size);
    }

    return 0;
}

USTATUS FfsParser::parseFileHeader(const UByteArray & file, const UINT32 localOffset, const UModelIndex & parent, UModelIndex & index)
{
    // Sanity check
    if (file.isEmpty()) {
        return U_INVALID_PARAMETER;
    }
    if ((UINT32)file.size() < sizeof(EFI_FFS_FILE_HEADER)) {
        return U_INVALID_FILE;
    }

    // Obtain required information from parent volume
    UINT8 ffsVersion = 2;
    bool isWeakAligned = false;
    UINT32 volumeAlignment = 0xFFFFFFFF;
    UINT8 volumeRevision = 2;
    UModelIndex parentVolumeIndex = model->type(parent) == Types::Volume ? parent : model->findParentOfType(parent, Types::Volume);
    if (parentVolumeIndex.isValid() && model->hasEmptyParsingData(parentVolumeIndex) == false) {
        UByteArray data = model->parsingData(parentVolumeIndex);
        const VOLUME_PARSING_DATA* pdata = (const VOLUME_PARSING_DATA*)data.constData();
        ffsVersion = pdata->ffsVersion;
        volumeAlignment = pdata->alignment;
        volumeRevision = pdata->revision;
        isWeakAligned = pdata->isWeakAligned;
    }

    // Get file header
    UByteArray header = file.left(sizeof(EFI_FFS_FILE_HEADER));
    EFI_FFS_FILE_HEADER* tempFileHeader = (EFI_FFS_FILE_HEADER*)header.data();
    if (ffsVersion == 3 && (tempFileHeader->Attributes & FFS_ATTRIB_LARGE_FILE)) {
        if ((UINT32)file.size() < sizeof(EFI_FFS_FILE_HEADER2))
            return U_INVALID_FILE;
        header = file.left(sizeof(EFI_FFS_FILE_HEADER2));
    }
    const EFI_FFS_FILE_HEADER* fileHeader = (const EFI_FFS_FILE_HEADER*)header.constData();

    // Check file alignment
    bool msgUnalignedFile = false;
    UINT8 alignmentPower = ffsAlignmentTable[(fileHeader->Attributes & FFS_ATTRIB_DATA_ALIGNMENT) >> 3];
    if (volumeRevision > 1 && (fileHeader->Attributes & FFS_ATTRIB_DATA_ALIGNMENT2)) {
        alignmentPower = ffsAlignment2Table[(fileHeader->Attributes & FFS_ATTRIB_DATA_ALIGNMENT) >> 3];
    }

    UINT32 alignment = (UINT32)(1UL << alignmentPower);
    if ((localOffset + header.size()) % alignment) {
        msgUnalignedFile = true;
    }

    // Check file alignment agains volume alignment
    bool msgFileAlignmentIsGreaterThanVolumeAlignment = false;
    if (!isWeakAligned && volumeAlignment < alignment) {
        msgFileAlignmentIsGreaterThanVolumeAlignment = true;
    }

    // Get file body
    UByteArray body = file.mid(header.size());

    // Check for file tail presence
    UByteArray tail;
    bool msgInvalidTailValue = false;
    if (volumeRevision == 1 && (fileHeader->Attributes & FFS_ATTRIB_TAIL_PRESENT)) {
        //Check file tail;
        UINT16 tailValue = *(UINT16*)body.right(sizeof(UINT16)).constData();
        if (fileHeader->IntegrityCheck.TailReference != (UINT16)~tailValue)
            msgInvalidTailValue = true;

        // Get tail and remove it from file body
        tail = body.right(sizeof(UINT16));
        body = body.left(body.size() - sizeof(UINT16));
    }

    // Check header checksum
    UINT8 calculatedHeader = 0x100 - (calculateSum8((const UINT8*)header.constData(), header.size()) - fileHeader->IntegrityCheck.Checksum.Header - fileHeader->IntegrityCheck.Checksum.File - fileHeader->State);
    bool msgInvalidHeaderChecksum = false;
    if (fileHeader->IntegrityCheck.Checksum.Header != calculatedHeader) {
        msgInvalidHeaderChecksum = true;
    }

    // Check data checksum
    // Data checksum must be calculated
    bool msgInvalidDataChecksum = false;
    UINT8 calculatedData = 0;
    if (fileHeader->Attributes & FFS_ATTRIB_CHECKSUM) {
        calculatedData = calculateChecksum8((const UINT8*)body.constData(), body.size());
    }
    // Data checksum must be one of predefined values
    else if (volumeRevision == 1) {
        calculatedData = FFS_FIXED_CHECKSUM;
    }
    else {
        calculatedData = FFS_FIXED_CHECKSUM2;
    }

    if (fileHeader->IntegrityCheck.Checksum.File != calculatedData) {
        msgInvalidDataChecksum = true;
    }

    // Check file type
    bool msgUnknownType = false;
    if (fileHeader->Type > EFI_FV_FILETYPE_MM_CORE_STANDALONE && fileHeader->Type != EFI_FV_FILETYPE_PAD) {
        msgUnknownType = true;
    };

    // Get info
    UString name;
    UString info;
    if (fileHeader->Type != EFI_FV_FILETYPE_PAD) {
        name = guidToUString(fileHeader->Name);
    } else {
        name = UString("Pad-file");
    }

    info = UString("File GUID: ") + guidToUString(fileHeader->Name, false) +
        usprintf("\nType: %02Xh\nAttributes: %02Xh\nFull size: %Xh (%u)\nHeader size: %Xh (%u)\nBody size: %Xh (%u)\nTail size: %Xh (%u)\nState: %02Xh",
        fileHeader->Type,
        fileHeader->Attributes,
        header.size() + body.size() + tail.size(), header.size() + body.size() + tail.size(),
        header.size(), header.size(),
        body.size(), body.size(),
        tail.size(), tail.size(),
        fileHeader->State) +
        usprintf("\nHeader checksum: %02Xh", fileHeader->IntegrityCheck.Checksum.Header) + (msgInvalidHeaderChecksum ? usprintf(", invalid, should be %02Xh", calculatedHeader) : UString(", valid")) +
        usprintf("\nData checksum: %02Xh", fileHeader->IntegrityCheck.Checksum.File) + (msgInvalidDataChecksum ? usprintf(", invalid, should be %02Xh", calculatedData) : UString(", valid"));

    UString text;
    bool isVtf = false;
    bool isDxeCore = false;
    // Check if the file is a Volume Top File
    UByteArray fileGuid = UByteArray((const char*)&fileHeader->Name, sizeof(EFI_GUID));
    if (fileGuid == EFI_FFS_VOLUME_TOP_FILE_GUID) {
        // Mark it as the last VTF
        // This information will later be used to determine memory addresses of uncompressed image elements
        // Because the last byte of the last VFT is mapped to 0xFFFFFFFF physical memory address
        isVtf = true;
        text = UString("Volume Top File");
    }
    // Check if the file is the first DXE Core
    else if (fileGuid == EFI_DXE_CORE_GUID || fileGuid == AMI_CORE_DXE_GUID) {
        // Mark is as first DXE core
        // This information may be used to determine DXE volume offset for old AMI or post-IBB protected ranges
        isDxeCore = true;
    }

    // Construct fixed state
    ItemFixedState fixed = (ItemFixedState)((fileHeader->Attributes & FFS_ATTRIB_FIXED) != 0);

    // Add tree item
    index = model->addItem(localOffset, Types::File, fileHeader->Type, name, text, info, header, body, tail, fixed, parent);

    // Set parsing data for created file
    FILE_PARSING_DATA pdata;
    pdata.emptyByte = (fileHeader->State & EFI_FILE_ERASE_POLARITY) ? 0xFF : 0x00;
    pdata.guid = fileHeader->Name;
    model->setParsingData(index, UByteArray((const char*)&pdata, sizeof(pdata)));

    // Override lastVtf index, if needed
    if (isVtf) {
        lastVtf = index;
    }

    // Override first DXE core index, if needed
    if (isDxeCore && !bgDxeCoreIndex.isValid()) {
        bgDxeCoreIndex = index;
    }

    // Show messages
    if (msgUnalignedFile)
        msg(usprintf("%s: unaligned file", __FUNCTION__), index);
    if (msgFileAlignmentIsGreaterThanVolumeAlignment)
        msg(usprintf("%s: file alignment %Xh is greater than parent volume alignment %Xh", __FUNCTION__, alignment, volumeAlignment), index);
    if (msgInvalidHeaderChecksum)
        msg(usprintf("%s: invalid header checksum %02Xh, should be %02Xh", __FUNCTION__, fileHeader->IntegrityCheck.Checksum.Header, calculatedHeader), index);
    if (msgInvalidDataChecksum)
        msg(usprintf("%s: invalid data checksum %02Xh, should be %02Xh", __FUNCTION__, fileHeader->IntegrityCheck.Checksum.File, calculatedData), index);
    if (msgInvalidTailValue)
        msg(usprintf("%s: invalid tail value %04Xh", __FUNCTION__, *(const UINT16*)tail.constData()), index);
    if (msgUnknownType)
        msg(usprintf("%s: unknown file type %02Xh", __FUNCTION__, fileHeader->Type), index);

    return U_SUCCESS;
}

UINT32 FfsParser::getSectionSize(const UByteArray & file, const UINT32 sectionOffset, const UINT8 ffsVersion)
{
    if ((UINT32)file.size() < sectionOffset + sizeof(EFI_COMMON_SECTION_HEADER)) {
        return 0;
    }
    const EFI_COMMON_SECTION_HEADER* sectionHeader = (const EFI_COMMON_SECTION_HEADER*)(file.constData() + sectionOffset);

    if (ffsVersion == 2) {
        return uint24ToUint32(sectionHeader->Size);
    }
    else if (ffsVersion == 3) {
        UINT32 size = uint24ToUint32(sectionHeader->Size);
        if (size == EFI_SECTION2_IS_USED) {
            if ((UINT32)file.size() < sectionOffset + sizeof(EFI_COMMON_SECTION_HEADER2)) {
                return 0;
            }
            const EFI_COMMON_SECTION_HEADER2* sectionHeader2 = (const EFI_COMMON_SECTION_HEADER2*)(file.constData() + sectionOffset);
            return sectionHeader2->ExtendedSize;
        }

        return size;
    }

    return 0;
}

USTATUS FfsParser::parseFileBody(const UModelIndex & index)
{
    // Sanity check
    if (!index.isValid())
        return U_INVALID_PARAMETER;

    // Do not parse non-file bodies
    if (model->type(index) != Types::File)
        return U_SUCCESS;

    // Parse pad-file body
    if (model->subtype(index) == EFI_FV_FILETYPE_PAD)
        return parsePadFileBody(index);

    // Parse raw files as raw areas
    if (model->subtype(index) == EFI_FV_FILETYPE_RAW || model->subtype(index) == EFI_FV_FILETYPE_ALL) {
        UByteArray fileGuid = UByteArray(model->header(index).constData(), sizeof(EFI_GUID));

        // Parse NVAR store
        if (fileGuid == NVRAM_NVAR_STORE_FILE_GUID) {
            model->setText(index, UString("NVAR store"));
            return nvramParser->parseNvarStore(index);
        }
        else if (fileGuid == NVRAM_NVAR_PEI_EXTERNAL_DEFAULTS_FILE_GUID) {
            model->setText(index, UString("NVRAM external defaults"));
            return nvramParser->parseNvarStore(index);
        }
        else if (fileGuid == NVRAM_NVAR_BB_DEFAULTS_FILE_GUID) {
            model->setText(index, UString("NVAR bb defaults"));
            return nvramParser->parseNvarStore(index);
        }
        // Parse vendor hash file
        else if (fileGuid == BG_VENDOR_HASH_FILE_GUID_PHOENIX) {
            return parseVendorHashFile(fileGuid, index);
        }

        return parseRawArea(index);
    }

    // Parse sections
    return parseSections(model->body(index), index, true);
}

USTATUS FfsParser::parsePadFileBody(const UModelIndex & index)
{
    // Sanity check
    if (!index.isValid())
        return U_INVALID_PARAMETER;

    // Check if all bytes of the file are empty
    UByteArray body = model->body(index);

    // Obtain required information from parent file
    UINT8 emptyByte = 0xFF;
    UModelIndex parentFileIndex = model->findParentOfType(index, Types::File);
    if (parentFileIndex.isValid() && model->hasEmptyParsingData(parentFileIndex) == false) {
        UByteArray data = model->parsingData(index);
        const FILE_PARSING_DATA* pdata = (const FILE_PARSING_DATA*)data.constData();
        emptyByte = pdata->emptyByte;
    }

    // Check if the while PAD file is empty
    if (body.size() == body.count(emptyByte))
        return U_SUCCESS;

    // Search for the first non-empty byte
    UINT32 nonEmptyByteOffset;
    UINT32 size = body.size();
    const UINT8* current = (const UINT8*)body.constData();
    for (nonEmptyByteOffset = 0; nonEmptyByteOffset < size; nonEmptyByteOffset++) {
        if (*current++ != emptyByte)
            break;
    }

    // Add all bytes before as free space...
    UINT32 headerSize = model->header(index).size();
    if (nonEmptyByteOffset >= 8) {
        // Align free space to 8 bytes boundary
        if (nonEmptyByteOffset != ALIGN8(nonEmptyByteOffset))
            nonEmptyByteOffset = ALIGN8(nonEmptyByteOffset) - 8;

        UByteArray free = body.left(nonEmptyByteOffset);

        // Get info
        UString info = usprintf("Full size: %Xh (%u)", free.size(), free.size());

        // Add tree item
        model->addItem(headerSize, Types::FreeSpace, 0, UString("Free space"), UString(), info, UByteArray(), free, UByteArray(), Movable, index);
    }
    else {
        nonEmptyByteOffset = 0;
    }

    // ... and all bytes after as a padding
    UByteArray padding = body.mid(nonEmptyByteOffset);

    // Get info
    UString info = usprintf("Full size: %Xh (%u)", padding.size(), padding.size());

    // Add tree item
    UModelIndex dataIndex = model->addItem(headerSize + nonEmptyByteOffset, Types::Padding, Subtypes::DataPadding, UString("Non-UEFI data"), UString(), info, UByteArray(), padding, UByteArray(), Fixed, index);

    // Show message
    msg(usprintf("%s: non-UEFI data found in pad-file", __FUNCTION__), dataIndex);

    // Rename the file
    model->setName(index, UString("Non-empty pad-file"));

    // Parse contents as RAW area
    return parseRawArea(dataIndex);
}

USTATUS FfsParser::parseSections(const UByteArray & sections, const UModelIndex & index, const bool insertIntoTree)
{
    // Sanity check
    if (!index.isValid())
        return U_INVALID_PARAMETER;

    // Search for and parse all sections
    UINT32 bodySize = sections.size();
    UINT32 headerSize = model->header(index).size();
    UINT32 sectionOffset = 0;
    USTATUS result = U_SUCCESS;

    // Obtain required information from parent volume
    UINT8 ffsVersion = 2;
    UModelIndex parentVolumeIndex = model->findParentOfType(index, Types::Volume);
    if (parentVolumeIndex.isValid() && model->hasEmptyParsingData(parentVolumeIndex) == false) {
        UByteArray data = model->parsingData(parentVolumeIndex);
        const VOLUME_PARSING_DATA* pdata = (const VOLUME_PARSING_DATA*)data.constData();
        ffsVersion = pdata->ffsVersion;
    }

    while (sectionOffset < bodySize) {
        // Get section size
        UINT32 sectionSize = getSectionSize(sections, sectionOffset, ffsVersion);

        // Check section size
        if (sectionSize < sizeof(EFI_COMMON_SECTION_HEADER) || sectionSize > (bodySize - sectionOffset)) {
            // Final parsing
            if (insertIntoTree) {
                // Add padding to fill the rest of sections
                UByteArray padding = sections.mid(sectionOffset);

                // Get info
                UString info = usprintf("Full size: %Xh (%u)", padding.size(), padding.size());

                // Add tree item
                UModelIndex dataIndex = model->addItem(headerSize + sectionOffset, Types::Padding, Subtypes::DataPadding, UString("Non-UEFI data"), UString(), info, UByteArray(), padding, UByteArray(), Fixed, index);

                // Show message
                msg(usprintf("%s: non-UEFI data found in sections area", __FUNCTION__), dataIndex);

                // Exit from parsing loop
                break;
            }
            // Preparsing
            else {
                return U_INVALID_SECTION;
            }
        }

        // Parse section header
        UModelIndex sectionIndex;
        result = parseSectionHeader(sections.mid(sectionOffset, sectionSize), headerSize + sectionOffset, index, sectionIndex, insertIntoTree);
        if (result) {
            if (insertIntoTree)
                msg(UString("parseSections: section header parsing failed with error ") + errorCodeToUString(result), index);
            else
                return U_INVALID_SECTION;
        }

        // Move to next section
        sectionOffset += sectionSize;
        sectionOffset = ALIGN4(sectionOffset);
    }

    // Parse bodies, will be skipped if insertIntoTree is not required
    for (int i = 0; i < model->rowCount(index); i++) {
        UModelIndex current = index.child(i, 0);
        switch (model->type(current)) {
        case Types::Section:
            parseSectionBody(current);
            break;
        case Types::Padding:
            // No parsing required
            break;
        default:
            return U_UNKNOWN_ITEM_TYPE;
        }
    }

    return U_SUCCESS;
}

USTATUS FfsParser::parseSectionHeader(const UByteArray & section, const UINT32 localOffset, const UModelIndex & parent, UModelIndex & index, const bool insertIntoTree)
{
    // Check sanity
    if ((UINT32)section.size() < sizeof(EFI_COMMON_SECTION_HEADER)) {
        return U_INVALID_SECTION;
    }

    const EFI_COMMON_SECTION_HEADER* sectionHeader = (const EFI_COMMON_SECTION_HEADER*)(section.constData());
    switch (sectionHeader->Type) {
    // Special
    case EFI_SECTION_COMPRESSION:           return parseCompressedSectionHeader(section, localOffset, parent, index, insertIntoTree);
    case EFI_SECTION_GUID_DEFINED:          return parseGuidedSectionHeader(section, localOffset, parent, index, insertIntoTree);
    case EFI_SECTION_FREEFORM_SUBTYPE_GUID: return parseFreeformGuidedSectionHeader(section, localOffset, parent, index, insertIntoTree);
    case EFI_SECTION_VERSION:               return parseVersionSectionHeader(section, localOffset, parent, index, insertIntoTree);
    case PHOENIX_SECTION_POSTCODE:
    case INSYDE_SECTION_POSTCODE:           return parsePostcodeSectionHeader(section, localOffset, parent, index, insertIntoTree);
    // Common
    case EFI_SECTION_DISPOSABLE:
    case EFI_SECTION_DXE_DEPEX:
    case EFI_SECTION_PEI_DEPEX:
    case EFI_SECTION_MM_DEPEX:
    case EFI_SECTION_PE32:
    case EFI_SECTION_PIC:
    case EFI_SECTION_TE:
    case EFI_SECTION_COMPATIBILITY16:
    case EFI_SECTION_USER_INTERFACE:
    case EFI_SECTION_FIRMWARE_VOLUME_IMAGE:
    case EFI_SECTION_RAW:                   return parseCommonSectionHeader(section, localOffset, parent, index, insertIntoTree);
    // Unknown
    default:
        USTATUS result = parseCommonSectionHeader(section, localOffset, parent, index, insertIntoTree);
        msg(usprintf("%s: section with unknown type %02Xh", __FUNCTION__, sectionHeader->Type), index);
        return result;
    }
}

USTATUS FfsParser::parseCommonSectionHeader(const UByteArray & section, const UINT32 localOffset, const UModelIndex & parent, UModelIndex & index, const bool insertIntoTree)
{
    // Check sanity
    if ((UINT32)section.size() < sizeof(EFI_COMMON_SECTION_HEADER)) {
        return U_INVALID_SECTION;
    }

    // Obtain required information from parent volume
    UINT8 ffsVersion = 2;
    UModelIndex parentVolumeIndex = model->findParentOfType(parent, Types::Volume);
    if (parentVolumeIndex.isValid() && model->hasEmptyParsingData(parentVolumeIndex) == false) {
        UByteArray data = model->parsingData(parentVolumeIndex);
        const VOLUME_PARSING_DATA* pdata = (const VOLUME_PARSING_DATA*)data.constData();
        ffsVersion = pdata->ffsVersion;
    }

    // Obtain header fields
    UINT32 headerSize;
    UINT8  type;
    const EFI_COMMON_SECTION_HEADER_APPLE* appleHeader = (const EFI_COMMON_SECTION_HEADER_APPLE*)(section.constData());
    if ((UINT32)section.size() >= sizeof(EFI_COMMON_SECTION_HEADER_APPLE) && appleHeader->Reserved == EFI_SECTION_APPLE_USED) {
        headerSize = sizeof(EFI_COMMON_SECTION_HEADER_APPLE);
        type = appleHeader->Type;
    }
    else {
        const EFI_COMMON_SECTION_HEADER* sectionHeader = (const EFI_COMMON_SECTION_HEADER*)(section.constData());
        headerSize = sizeof(EFI_COMMON_SECTION_HEADER);
        if (ffsVersion == 3 && uint24ToUint32(sectionHeader->Size) == EFI_SECTION2_IS_USED)
            headerSize = sizeof(EFI_COMMON_SECTION_HEADER2);
        type = sectionHeader->Type;
    }

    // Check sanity again
    if ((UINT32)section.size() < headerSize) {
        return U_INVALID_SECTION;
    }

    UByteArray header = section.left(headerSize);
    UByteArray body = section.mid(headerSize);

    // Get info
    UString name = sectionTypeToUString(type) + UString(" section");
    UString info = usprintf("Type: %02Xh\nFull size: %Xh (%u)\nHeader size: %Xh (%u)\nBody size: %Xh (%u)",
        type,
        section.size(), section.size(),
        headerSize, headerSize,
        body.size(), body.size());

    // Add tree item
    if (insertIntoTree) {
        index = model->addItem(localOffset, Types::Section, type, name, UString(), info, header, body, UByteArray(), Movable, parent);
    }

    return U_SUCCESS;
}

USTATUS FfsParser::parseCompressedSectionHeader(const UByteArray & section, const UINT32 localOffset, const UModelIndex & parent, UModelIndex & index, const bool insertIntoTree)
{
    // Check sanity
    if ((UINT32)section.size() < sizeof(EFI_COMMON_SECTION_HEADER))
        return U_INVALID_SECTION;

    // Obtain required information from parent volume
    UINT8 ffsVersion = 2;
    UModelIndex parentVolumeIndex = model->findParentOfType(parent, Types::Volume);
    if (parentVolumeIndex.isValid() && model->hasEmptyParsingData(parentVolumeIndex) == false) {
        UByteArray data = model->parsingData(parentVolumeIndex);
        const VOLUME_PARSING_DATA* pdata = (const VOLUME_PARSING_DATA*)data.constData();
        ffsVersion = pdata->ffsVersion;
    }

    // Obtain header fields
    UINT32 headerSize;
    UINT8 compressionType;
    UINT32 uncompressedLength;
    const EFI_COMMON_SECTION_HEADER* sectionHeader = (const EFI_COMMON_SECTION_HEADER*)(section.constData());
    const EFI_COMMON_SECTION_HEADER2* section2Header = (const EFI_COMMON_SECTION_HEADER2*)(section.constData());
    const EFI_COMMON_SECTION_HEADER_APPLE* appleHeader = (const EFI_COMMON_SECTION_HEADER_APPLE*)(section.constData());

    if ((UINT32)section.size() >= sizeof(EFI_COMMON_SECTION_HEADER_APPLE) && appleHeader->Reserved == EFI_SECTION_APPLE_USED) { // Check for apple section
        const EFI_COMPRESSION_SECTION_APPLE* appleSectionHeader = (const EFI_COMPRESSION_SECTION_APPLE*)(appleHeader + 1);
        headerSize = sizeof(EFI_COMMON_SECTION_HEADER_APPLE) + sizeof(EFI_COMPRESSION_SECTION_APPLE);
        compressionType = (UINT8)appleSectionHeader->CompressionType;
        uncompressedLength = appleSectionHeader->UncompressedLength;
    }
    else if (ffsVersion == 3 && uint24ToUint32(sectionHeader->Size) == EFI_SECTION2_IS_USED) { // Check for extended header section
        const EFI_COMPRESSION_SECTION* compressedSectionHeader = (const EFI_COMPRESSION_SECTION*)(section2Header + 1);
        if ((UINT32)section.size() < sizeof(EFI_COMMON_SECTION_HEADER2) + sizeof(EFI_COMPRESSION_SECTION))
            return U_INVALID_SECTION;
        headerSize = sizeof(EFI_COMMON_SECTION_HEADER2) + sizeof(EFI_COMPRESSION_SECTION);
        compressionType = compressedSectionHeader->CompressionType;
        uncompressedLength = compressedSectionHeader->UncompressedLength;
    }
    else { // Normal section
        const EFI_COMPRESSION_SECTION* compressedSectionHeader = (const EFI_COMPRESSION_SECTION*)(sectionHeader + 1);
        headerSize = sizeof(EFI_COMMON_SECTION_HEADER) + sizeof(EFI_COMPRESSION_SECTION);
        compressionType = compressedSectionHeader->CompressionType;
        uncompressedLength = compressedSectionHeader->UncompressedLength;
    }

    // Check sanity again
    if ((UINT32)section.size() < headerSize) {
        return U_INVALID_SECTION;
    }

    UByteArray header = section.left(headerSize);
    UByteArray body = section.mid(headerSize);

    // Get info
    UString name = sectionTypeToUString(sectionHeader->Type) + UString(" section");
    UString info = usprintf("Type: %02Xh\nFull size: %Xh (%u)\nHeader size: %Xh (%u)\nBody size: %Xh (%u)\nCompression type: %02Xh\nDecompressed size: %Xh (%u)",
        sectionHeader->Type,
        section.size(), section.size(),
        headerSize, headerSize,
        body.size(), body.size(),
        compressionType,
        uncompressedLength, uncompressedLength);

    // Add tree item
    if (insertIntoTree) {
        index = model->addItem(localOffset, Types::Section, sectionHeader->Type, name, UString(), info, header, body, UByteArray(), Movable, parent);

        // Set section parsing data
        COMPRESSED_SECTION_PARSING_DATA pdata;
        pdata.compressionType = compressionType;
        pdata.uncompressedSize = uncompressedLength;
        model->setParsingData(index, UByteArray((const char*)&pdata, sizeof(pdata)));
    }

    return U_SUCCESS;
}

USTATUS FfsParser::parseGuidedSectionHeader(const UByteArray & section, const UINT32 localOffset, const UModelIndex & parent, UModelIndex & index, const bool insertIntoTree)
{
    // Check sanity
    if ((UINT32)section.size() < sizeof(EFI_COMMON_SECTION_HEADER))
        return U_INVALID_SECTION;

    // Obtain required information from parent volume
    UINT8 ffsVersion = 2;
    UModelIndex parentVolumeIndex = model->findParentOfType(parent, Types::Volume);
    if (parentVolumeIndex.isValid() && model->hasEmptyParsingData(parentVolumeIndex) == false) {
        UByteArray data = model->parsingData(parentVolumeIndex);
        const VOLUME_PARSING_DATA* pdata = (const VOLUME_PARSING_DATA*)data.constData();
        ffsVersion = pdata->ffsVersion;
    }

    // Obtain header fields
    UINT32 headerSize;
    EFI_GUID guid;
    UINT16 dataOffset;
    UINT16 attributes;
    const EFI_COMMON_SECTION_HEADER* sectionHeader = (const EFI_COMMON_SECTION_HEADER*)(section.constData());
    const EFI_COMMON_SECTION_HEADER2* section2Header = (const EFI_COMMON_SECTION_HEADER2*)(section.constData());
    const EFI_COMMON_SECTION_HEADER_APPLE* appleHeader = (const EFI_COMMON_SECTION_HEADER_APPLE*)(section.constData());

    if ((UINT32)section.size() >= sizeof(EFI_COMMON_SECTION_HEADER_APPLE) && appleHeader->Reserved == EFI_SECTION_APPLE_USED) { // Check for apple section
        const EFI_GUID_DEFINED_SECTION_APPLE* appleSectionHeader = (const EFI_GUID_DEFINED_SECTION_APPLE*)(appleHeader + 1);
        headerSize = sizeof(EFI_COMMON_SECTION_HEADER_APPLE) + sizeof(EFI_GUID_DEFINED_SECTION_APPLE);
        if ((UINT32)section.size() < headerSize)
            return U_INVALID_SECTION;
        guid = appleSectionHeader->SectionDefinitionGuid;
        dataOffset = appleSectionHeader->DataOffset;
        attributes = appleSectionHeader->Attributes;
    }
    else if (ffsVersion == 3 && uint24ToUint32(sectionHeader->Size) == EFI_SECTION2_IS_USED) { // Check for extended header section
        const EFI_GUID_DEFINED_SECTION* guidDefinedSectionHeader = (const EFI_GUID_DEFINED_SECTION*)(section2Header + 1);
        if ((UINT32)section.size() < sizeof(EFI_COMMON_SECTION_HEADER2) + sizeof(EFI_GUID_DEFINED_SECTION))
            return U_INVALID_SECTION;
        headerSize = sizeof(EFI_COMMON_SECTION_HEADER2) + sizeof(EFI_GUID_DEFINED_SECTION);
        guid = guidDefinedSectionHeader->SectionDefinitionGuid;
        dataOffset = guidDefinedSectionHeader->DataOffset;
        attributes = guidDefinedSectionHeader->Attributes;
    }
    else { // Normal section
        const EFI_GUID_DEFINED_SECTION* guidDefinedSectionHeader = (const EFI_GUID_DEFINED_SECTION*)(sectionHeader + 1);
        headerSize = sizeof(EFI_COMMON_SECTION_HEADER) + sizeof(EFI_GUID_DEFINED_SECTION);
        guid = guidDefinedSectionHeader->SectionDefinitionGuid;
        dataOffset = guidDefinedSectionHeader->DataOffset;
        attributes = guidDefinedSectionHeader->Attributes;
    }
    // Check sanity again
    if ((UINT32)section.size() < headerSize)
        return U_INVALID_SECTION;

    // Check for special GUIDed sections
    UString additionalInfo;
    UByteArray baGuid((const char*)&guid, sizeof(EFI_GUID));
    bool msgSignedSectionFound = false;
    bool msgNoAuthStatusAttribute = false;
    bool msgNoProcessingRequiredAttributeCompressed = false;
    bool msgNoProcessingRequiredAttributeSigned = false;
    bool msgInvalidCrc = false;
    bool msgUnknownCertType = false;
    bool msgUnknownCertSubtype = false;
    bool msgProcessingRequiredAttributeOnUnknownGuidedSection = false;
    if (baGuid == EFI_GUIDED_SECTION_CRC32) {
        if ((attributes & EFI_GUIDED_SECTION_AUTH_STATUS_VALID) == 0) { // Check that AuthStatusValid attribute is set on compressed GUIDed sections
            msgNoAuthStatusAttribute = true;
        }

        if ((UINT32)section.size() < headerSize + sizeof(UINT32))
            return U_INVALID_SECTION;

        UINT32 crc = *(UINT32*)(section.constData() + headerSize);
        additionalInfo += UString("\nChecksum type: CRC32");
        // Calculate CRC32 of section data
        UINT32 calculated = (UINT32)crc32(0, (const UINT8*)section.constData() + dataOffset, section.size() - dataOffset);
        if (crc == calculated) {
            additionalInfo += usprintf("\nChecksum: %08Xh, valid", crc);
        }
        else {
            additionalInfo += usprintf("\nChecksum: %08Xh, invalid, should be %08Xh", crc, calculated);
            msgInvalidCrc = true;
        }
        // No need to change dataOffset here
    }
    else if (baGuid == EFI_GUIDED_SECTION_LZMA || baGuid == EFI_GUIDED_SECTION_LZMAF86 || baGuid == EFI_GUIDED_SECTION_TIANO || baGuid == EFI_GUIDED_SECTION_GZIP) {
        if ((attributes & EFI_GUIDED_SECTION_PROCESSING_REQUIRED) == 0) { // Check that ProcessingRequired attribute is set on compressed GUIDed sections
            msgNoProcessingRequiredAttributeCompressed = true;
        }
        // No need to change dataOffset here
    }
    else if (baGuid == EFI_CERT_TYPE_RSA2048_SHA256_GUID) {
        if ((attributes & EFI_GUIDED_SECTION_PROCESSING_REQUIRED) == 0) { // Check that ProcessingRequired attribute is set on signed GUIDed sections
            msgNoProcessingRequiredAttributeSigned = true;
        }

        // Get certificate type and length
        if ((UINT32)section.size() < headerSize + sizeof(EFI_CERT_BLOCK_RSA2048_SHA256))
            return U_INVALID_SECTION;

        // Adjust dataOffset
        dataOffset += sizeof(EFI_CERT_BLOCK_RSA2048_SHA256);
        additionalInfo += UString("\nCertificate type: RSA2048/SHA256");
        msgSignedSectionFound = true;
    }
    else if (baGuid == EFI_FIRMWARE_CONTENTS_SIGNED_GUID) {
        if ((attributes & EFI_GUIDED_SECTION_PROCESSING_REQUIRED) == 0) { // Check that ProcessingRequired attribute is set on signed GUIDed sections
            msgNoProcessingRequiredAttributeSigned = true;
        }

        // Get certificate type and length
        if ((UINT32)section.size() < headerSize + sizeof(WIN_CERTIFICATE))
            return U_INVALID_SECTION;

        const WIN_CERTIFICATE* winCertificate = (const WIN_CERTIFICATE*)(section.constData() + headerSize);
        UINT32 certLength = winCertificate->Length;
        UINT16 certType = winCertificate->CertificateType;

        // Adjust dataOffset
        dataOffset += certLength;

        // Check section size once again
        if ((UINT32)section.size() < dataOffset)
            return U_INVALID_SECTION;

        // Check certificate type
        if (certType == WIN_CERT_TYPE_EFI_GUID) {
            additionalInfo += UString("\nCertificate type: UEFI");

            // Get certificate GUID
            const WIN_CERTIFICATE_UEFI_GUID* winCertificateUefiGuid = (const WIN_CERTIFICATE_UEFI_GUID*)(section.constData() + headerSize);
            UByteArray certTypeGuid((const char*)&winCertificateUefiGuid->CertType, sizeof(EFI_GUID));

            if (certTypeGuid == EFI_CERT_TYPE_RSA2048_SHA256_GUID) {
                additionalInfo += UString("\nCertificate subtype: RSA2048/SHA256");
            }
            else {
                additionalInfo += UString("\nCertificate subtype: unknown, GUID ") + guidToUString(winCertificateUefiGuid->CertType);
                msgUnknownCertSubtype = true;
            }
        }
        else {
            additionalInfo += usprintf("\nCertificate type: unknown (%04Xh)", certType);
            msgUnknownCertType = true;
        }
        msgSignedSectionFound = true;
    }
    // Check that ProcessingRequired attribute is not set on GUIDed sections with unknown GUID
    else if ((attributes & EFI_GUIDED_SECTION_PROCESSING_REQUIRED) == EFI_GUIDED_SECTION_PROCESSING_REQUIRED) {
        msgProcessingRequiredAttributeOnUnknownGuidedSection = true;
    }

    UByteArray header = section.left(dataOffset);
    UByteArray body = section.mid(dataOffset);

    // Get info
    UString name = guidToUString(guid);
    UString info = UString("Section GUID: ") + guidToUString(guid, false) +
        usprintf("\nType: %02Xh\nFull size: %Xh (%u)\nHeader size: %Xh (%u)\nBody size: %Xh (%u)\nData offset: %Xh\nAttributes: %04Xh",
        sectionHeader->Type,
        section.size(), section.size(),
        header.size(), header.size(),
        body.size(), body.size(),
        dataOffset,
        attributes);

    // Append additional info
    info += additionalInfo;

    // Add tree item
    if (insertIntoTree) {
        index = model->addItem(localOffset, Types::Section, sectionHeader->Type, name, UString(), info, header, body, UByteArray(), Movable, parent);

        // Set parsing data
        GUIDED_SECTION_PARSING_DATA pdata;
        pdata.guid = guid;
        model->setParsingData(index, UByteArray((const char*)&pdata, sizeof(pdata)));

        // Show messages
        if (msgSignedSectionFound)
            msg(usprintf("%s: section signature may become invalid after any modification", __FUNCTION__), index);
        if (msgNoAuthStatusAttribute)
            msg(usprintf("%s: CRC32 GUIDed section without AuthStatusValid attribute", __FUNCTION__), index);
        if (msgNoProcessingRequiredAttributeCompressed)
            msg(usprintf("%s: compressed GUIDed section without ProcessingRequired attribute", __FUNCTION__), index);
        if (msgNoProcessingRequiredAttributeSigned)
            msg(usprintf("%s: signed GUIDed section without ProcessingRequired attribute", __FUNCTION__), index);
        if (msgInvalidCrc)
            msg(usprintf("%s: GUID defined section with invalid CRC32", __FUNCTION__), index);
        if (msgUnknownCertType)
            msg(usprintf("%s: signed GUIDed section with unknown type", __FUNCTION__), index);
        if (msgUnknownCertSubtype)
            msg(usprintf("%s: signed GUIDed section with unknown subtype", __FUNCTION__), index);
        if (msgProcessingRequiredAttributeOnUnknownGuidedSection)
            msg(usprintf("%s: processing required bit set for GUIDed section with unknown GUID", __FUNCTION__), index);
    }

    return U_SUCCESS;
}

USTATUS FfsParser::parseFreeformGuidedSectionHeader(const UByteArray & section, const UINT32 localOffset, const UModelIndex & parent, UModelIndex & index, const bool insertIntoTree)
{
    // Check sanity
    if ((UINT32)section.size() < sizeof(EFI_COMMON_SECTION_HEADER))
        return U_INVALID_SECTION;

    // Obtain required information from parent volume
    UINT8 ffsVersion = 2;
    UModelIndex parentVolumeIndex = model->findParentOfType(parent, Types::Volume);
    if (parentVolumeIndex.isValid() && model->hasEmptyParsingData(parentVolumeIndex) == false) {
        UByteArray data = model->parsingData(parentVolumeIndex);
        const VOLUME_PARSING_DATA* pdata = (const VOLUME_PARSING_DATA*)data.constData();
        ffsVersion = pdata->ffsVersion;
    }

    // Obtain header fields
    UINT32 headerSize;
    EFI_GUID guid;
    UINT8 type;
    const EFI_COMMON_SECTION_HEADER* sectionHeader = (const EFI_COMMON_SECTION_HEADER*)(section.constData());
    const EFI_COMMON_SECTION_HEADER2* section2Header = (const EFI_COMMON_SECTION_HEADER2*)(section.constData());
    const EFI_COMMON_SECTION_HEADER_APPLE* appleHeader = (const EFI_COMMON_SECTION_HEADER_APPLE*)(section.constData());

    if ((UINT32)section.size() >= sizeof(EFI_COMMON_SECTION_HEADER_APPLE) && appleHeader->Reserved == EFI_SECTION_APPLE_USED) { // Check for apple section
        const EFI_FREEFORM_SUBTYPE_GUID_SECTION* appleSectionHeader = (const EFI_FREEFORM_SUBTYPE_GUID_SECTION*)(appleHeader + 1);
        headerSize = sizeof(EFI_COMMON_SECTION_HEADER_APPLE) + sizeof(EFI_FREEFORM_SUBTYPE_GUID_SECTION);
        guid = appleSectionHeader->SubTypeGuid;
        type = appleHeader->Type;
    }
    else if (ffsVersion == 3 && uint24ToUint32(sectionHeader->Size) == EFI_SECTION2_IS_USED) { // Check for extended header section
        const EFI_FREEFORM_SUBTYPE_GUID_SECTION* fsgSectionHeader = (const EFI_FREEFORM_SUBTYPE_GUID_SECTION*)(section2Header + 1);
        if ((UINT32)section.size() < sizeof(EFI_COMMON_SECTION_HEADER2) + sizeof(EFI_FREEFORM_SUBTYPE_GUID_SECTION))
            return U_INVALID_SECTION;
        headerSize = sizeof(EFI_COMMON_SECTION_HEADER2) + sizeof(EFI_FREEFORM_SUBTYPE_GUID_SECTION);
        guid = fsgSectionHeader->SubTypeGuid;
        type = section2Header->Type;
    }
    else { // Normal section
        const EFI_FREEFORM_SUBTYPE_GUID_SECTION* fsgSectionHeader = (const EFI_FREEFORM_SUBTYPE_GUID_SECTION*)(sectionHeader + 1);
        headerSize = sizeof(EFI_COMMON_SECTION_HEADER) + sizeof(EFI_FREEFORM_SUBTYPE_GUID_SECTION);
        guid = fsgSectionHeader->SubTypeGuid;
        type = sectionHeader->Type;
    }

    // Check sanity again
    if ((UINT32)section.size() < headerSize)
        return U_INVALID_SECTION;

    UByteArray header = section.left(headerSize);
    UByteArray body = section.mid(headerSize);

    // Get info
    UString name = sectionTypeToUString(type) + (" section");
    UString info = usprintf("Type: %02Xh\nFull size: %Xh (%u)\nHeader size: %Xh (%u)\nBody size: %Xh (%u)\nSubtype GUID: ",
        type,
        section.size(), section.size(),
        header.size(), header.size(),
        body.size(), body.size())
        + guidToUString(guid, false);

    // Add tree item
    if (insertIntoTree) {
        index = model->addItem(localOffset, Types::Section, type, name, UString(), info, header, body, UByteArray(), Movable, parent);

        // Set parsing data
        FREEFORM_GUIDED_SECTION_PARSING_DATA pdata;
        pdata.guid = guid;
        model->setParsingData(index, UByteArray((const char*)&pdata, sizeof(pdata)));

        // Rename section
        model->setName(index, guidToUString(guid));
    }

    return U_SUCCESS;
}

USTATUS FfsParser::parseVersionSectionHeader(const UByteArray & section, const UINT32 localOffset, const UModelIndex & parent, UModelIndex & index, const bool insertIntoTree)
{
    // Check sanity
    if ((UINT32)section.size() < sizeof(EFI_COMMON_SECTION_HEADER))
        return U_INVALID_SECTION;

    // Obtain required information from parent volume
    UINT8 ffsVersion = 2;
    UModelIndex parentVolumeIndex = model->findParentOfType(parent, Types::Volume);
    if (parentVolumeIndex.isValid() && model->hasEmptyParsingData(parentVolumeIndex) == false) {
        UByteArray data = model->parsingData(parentVolumeIndex);
        const VOLUME_PARSING_DATA* pdata = (const VOLUME_PARSING_DATA*)data.constData();
        ffsVersion = pdata->ffsVersion;
    }

    // Obtain header fields
    UINT32 headerSize;
    UINT16 buildNumber;
    UINT8 type;
    const EFI_COMMON_SECTION_HEADER* sectionHeader = (const EFI_COMMON_SECTION_HEADER*)(section.constData());
    const EFI_COMMON_SECTION_HEADER2* section2Header = (const EFI_COMMON_SECTION_HEADER2*)(section.constData());
    const EFI_COMMON_SECTION_HEADER_APPLE* appleHeader = (const EFI_COMMON_SECTION_HEADER_APPLE*)(section.constData());

    if ((UINT32)section.size() >= sizeof(EFI_COMMON_SECTION_HEADER_APPLE) && appleHeader->Reserved == EFI_SECTION_APPLE_USED) { // Check for apple section
        const EFI_VERSION_SECTION* versionHeader = (const EFI_VERSION_SECTION*)(appleHeader + 1);
        headerSize = sizeof(EFI_COMMON_SECTION_HEADER_APPLE) + sizeof(EFI_VERSION_SECTION);
        buildNumber = versionHeader->BuildNumber;
        type = appleHeader->Type;
    }
    else if (ffsVersion == 3 && uint24ToUint32(sectionHeader->Size) == EFI_SECTION2_IS_USED) { // Check for extended header section
        const EFI_VERSION_SECTION* versionHeader = (const EFI_VERSION_SECTION*)(section2Header + 1);
        headerSize = sizeof(EFI_COMMON_SECTION_HEADER2) + sizeof(EFI_VERSION_SECTION);
        buildNumber = versionHeader->BuildNumber;
        type = section2Header->Type;
    }
    else { // Normal section
        const EFI_VERSION_SECTION* versionHeader = (const EFI_VERSION_SECTION*)(sectionHeader + 1);
        headerSize = sizeof(EFI_COMMON_SECTION_HEADER) + sizeof(EFI_VERSION_SECTION);
        buildNumber = versionHeader->BuildNumber;
        type = sectionHeader->Type;
    }

    // Check sanity again
    if ((UINT32)section.size() < headerSize)
        return U_INVALID_SECTION;

    UByteArray header = section.left(headerSize);
    UByteArray body = section.mid(headerSize);

    // Get info
    UString name = sectionTypeToUString(type) + (" section");
    UString info = usprintf("Type: %02Xh\nFull size: %Xh (%u)\nHeader size: %Xh (%u)\nBody size: %Xh (%u)\nBuild number: %u",
        type,
        section.size(), section.size(),
        header.size(), header.size(),
        body.size(), body.size(),
        buildNumber);

    // Add tree item
    if (insertIntoTree) {
        index = model->addItem(localOffset, Types::Section, type, name, UString(), info, header, body, UByteArray(), Movable, parent);
    }

    return U_SUCCESS;
}

USTATUS FfsParser::parsePostcodeSectionHeader(const UByteArray & section, const UINT32 localOffset, const UModelIndex & parent, UModelIndex & index, const bool insertIntoTree)
{
    // Check sanity
    if ((UINT32)section.size() < sizeof(EFI_COMMON_SECTION_HEADER))
        return U_INVALID_SECTION;

    // Obtain required information from parent volume
    UINT8 ffsVersion = 2;
    UModelIndex parentVolumeIndex = model->findParentOfType(parent, Types::Volume);
    if (parentVolumeIndex.isValid() && model->hasEmptyParsingData(parentVolumeIndex) == false) {
        UByteArray data = model->parsingData(parentVolumeIndex);
        const VOLUME_PARSING_DATA* pdata = (const VOLUME_PARSING_DATA*)data.constData();
        ffsVersion = pdata->ffsVersion;
    }

    // Obtain header fields
    UINT32 headerSize;
    UINT32 postCode;
    UINT8 type;
    const EFI_COMMON_SECTION_HEADER* sectionHeader = (const EFI_COMMON_SECTION_HEADER*)(section.constData());
    const EFI_COMMON_SECTION_HEADER2* section2Header = (const EFI_COMMON_SECTION_HEADER2*)(section.constData());
    const EFI_COMMON_SECTION_HEADER_APPLE* appleHeader = (const EFI_COMMON_SECTION_HEADER_APPLE*)(section.constData());

    if ((UINT32)section.size() >= sizeof(EFI_COMMON_SECTION_HEADER_APPLE) && appleHeader->Reserved == EFI_SECTION_APPLE_USED) { // Check for apple section
        const POSTCODE_SECTION* postcodeHeader = (const POSTCODE_SECTION*)(appleHeader + 1);
        headerSize = sizeof(EFI_COMMON_SECTION_HEADER_APPLE) + sizeof(POSTCODE_SECTION);
        postCode = postcodeHeader->Postcode;
        type = appleHeader->Type;
    }
    else if (ffsVersion == 3 && uint24ToUint32(sectionHeader->Size) == EFI_SECTION2_IS_USED) { // Check for extended header section
        const POSTCODE_SECTION* postcodeHeader = (const POSTCODE_SECTION*)(section2Header + 1);
        headerSize = sizeof(EFI_COMMON_SECTION_HEADER2) + sizeof(POSTCODE_SECTION);
        postCode = postcodeHeader->Postcode;
        type = section2Header->Type;
    }
    else { // Normal section
        const POSTCODE_SECTION* postcodeHeader = (const POSTCODE_SECTION*)(sectionHeader + 1);
        headerSize = sizeof(EFI_COMMON_SECTION_HEADER) + sizeof(POSTCODE_SECTION);
        postCode = postcodeHeader->Postcode;
        type = sectionHeader->Type;
    }

    // Check sanity again
    if ((UINT32)section.size() < headerSize)
        return U_INVALID_SECTION;

    UByteArray header = section.left(headerSize);
    UByteArray body = section.mid(headerSize);

    // Get info
    UString name = sectionTypeToUString(type) + (" section");
    UString info = usprintf("Type: %02Xh\nFull size: %Xh (%u)\nHeader size: %Xh (%u)\nBody size: %Xh (%u)\nPostcode: %Xh",
        type,
        section.size(), section.size(),
        header.size(), header.size(),
        body.size(), body.size(),
        postCode);

    // Add tree item
    if (insertIntoTree) {
        index = model->addItem(localOffset, Types::Section, sectionHeader->Type, name, UString(), info, header, body, UByteArray(), Movable, parent);
    }

    return U_SUCCESS;
}

USTATUS FfsParser::parseSectionBody(const UModelIndex & index)
{
    // Sanity check
    if (!index.isValid())
        return U_INVALID_PARAMETER;
    UByteArray header = model->header(index);
    if ((UINT32)header.size() < sizeof(EFI_COMMON_SECTION_HEADER))
        return U_INVALID_SECTION;

    const EFI_COMMON_SECTION_HEADER* sectionHeader = (const EFI_COMMON_SECTION_HEADER*)(header.constData());

    switch (sectionHeader->Type) {
    // Encapsulation
    case EFI_SECTION_COMPRESSION:           return parseCompressedSectionBody(index);
    case EFI_SECTION_GUID_DEFINED:          return parseGuidedSectionBody(index);
    case EFI_SECTION_DISPOSABLE:            return parseSections(model->body(index), index, true);
    // Leaf
    case EFI_SECTION_FREEFORM_SUBTYPE_GUID: return parseRawArea(index);
    case EFI_SECTION_VERSION:               return parseVersionSectionBody(index);
    case EFI_SECTION_DXE_DEPEX:
    case EFI_SECTION_PEI_DEPEX:
    case EFI_SECTION_MM_DEPEX:              return parseDepexSectionBody(index);
    case EFI_SECTION_TE:                    return parseTeImageSectionBody(index);
    case EFI_SECTION_PE32:
    case EFI_SECTION_PIC:                   return parsePeImageSectionBody(index);
    case EFI_SECTION_USER_INTERFACE:        return parseUiSectionBody(index);
    case EFI_SECTION_FIRMWARE_VOLUME_IMAGE: return parseRawArea(index);
    case EFI_SECTION_RAW:                   return parseRawSectionBody(index);
    // No parsing needed
    case EFI_SECTION_COMPATIBILITY16:
    case PHOENIX_SECTION_POSTCODE:
    case INSYDE_SECTION_POSTCODE:
    default:
        return U_SUCCESS;
    }
}

USTATUS FfsParser::parseCompressedSectionBody(const UModelIndex & index)
{
    // Sanity check
    if (!index.isValid())
        return U_INVALID_PARAMETER;

    // Obtain required information from parsing data
    UINT8 compressionType = EFI_NOT_COMPRESSED;
    UINT32 uncompressedSize = model->body(index).size();
    if (model->hasEmptyParsingData(index) == false) {
        UByteArray data = model->parsingData(index);
        const COMPRESSED_SECTION_PARSING_DATA* pdata = (const COMPRESSED_SECTION_PARSING_DATA*)data.constData();
        compressionType = readUnaligned(pdata).compressionType;
        uncompressedSize = readUnaligned(pdata).uncompressedSize;
    }

    // Decompress section
    UINT8 algorithm = COMPRESSION_ALGORITHM_NONE;
    UINT32 dictionarySize = 0;
    UByteArray decompressed;
    UByteArray efiDecompressed;
    USTATUS result = decompress(model->body(index), compressionType, algorithm, dictionarySize, decompressed, efiDecompressed);
    if (result) {
        msg(UString("parseCompressedSectionBody: decompression failed with error ") + errorCodeToUString(result), index);
        return U_SUCCESS;
    }

    // Check reported uncompressed size
    if (uncompressedSize != (UINT32)decompressed.size()) {
        msg(usprintf("parseCompressedSectionBody: decompressed size stored in header %Xh (%u) differs from actual %Xh (%u)",
            uncompressedSize, uncompressedSize,
            decompressed.size(), decompressed.size()),
            index);
        model->addInfo(index, usprintf("\nActual decompressed size: %Xh (%u)", decompressed.size(), decompressed.size()));
    }

    // Check for undecided compression algorithm, this is a special case
    if (algorithm == COMPRESSION_ALGORITHM_UNDECIDED) {
        // Try preparse of sections decompressed with Tiano algorithm
        if (U_SUCCESS == parseSections(decompressed, index, false)) {
            algorithm = COMPRESSION_ALGORITHM_TIANO;
        }
        // Try preparse of sections decompressed with EFI 1.1 algorithm
        else if (U_SUCCESS == parseSections(efiDecompressed, index, false)) {
            algorithm = COMPRESSION_ALGORITHM_EFI11;
            decompressed = efiDecompressed;
        }
        else {
            msg(UString("parseCompressedSectionBody: can't guess the correct decompression algorithm, both preparse steps are failed"), index);
        }
    }

    // Add info
    model->addInfo(index, UString("\nCompression algorithm: ") + compressionTypeToUString(algorithm));
    if (algorithm == COMPRESSION_ALGORITHM_LZMA || algorithm == COMPRESSION_ALGORITHM_LZMA_INTEL_LEGACY) {
        model->addInfo(index, usprintf("\nLZMA dictionary size: %Xh", dictionarySize));
    }

    // Update parsing data
    COMPRESSED_SECTION_PARSING_DATA pdata;
    pdata.algorithm = algorithm;
    pdata.dictionarySize = dictionarySize;
    pdata.compressionType = compressionType;
    pdata.uncompressedSize = uncompressedSize;
    model->setParsingData(index, UByteArray((const char*)&pdata, sizeof(pdata)));

    if (algorithm != COMPRESSION_ALGORITHM_NONE)
        model->setCompressed(index, true);

    // Parse decompressed data
    return parseSections(decompressed, index, true);
}

USTATUS FfsParser::parseGuidedSectionBody(const UModelIndex & index)
{
    // Sanity check
    if (!index.isValid())
        return U_INVALID_PARAMETER;

    // Obtain required information from parsing data
    EFI_GUID guid = { 0, 0, 0, {0, 0, 0, 0, 0, 0, 0, 0 }};
    if (model->hasEmptyParsingData(index) == false) {
        UByteArray data = model->parsingData(index);
        const GUIDED_SECTION_PARSING_DATA* pdata = (const GUIDED_SECTION_PARSING_DATA*)data.constData();
        guid = readUnaligned(pdata).guid;
    }

    // Check if section requires processing
    UByteArray processed = model->body(index);
    UByteArray efiDecompressed;
    UString info;
    bool parseCurrentSection = true;
    UINT8 algorithm = COMPRESSION_ALGORITHM_NONE;
    UINT32 dictionarySize = 0;
    UByteArray baGuid = UByteArray((const char*)&guid, sizeof(EFI_GUID));
    // Tiano compressed section
    if (baGuid == EFI_GUIDED_SECTION_TIANO) {
        USTATUS result = decompress(model->body(index), EFI_STANDARD_COMPRESSION, algorithm, dictionarySize, processed, efiDecompressed);
        if (result) {
            msg(usprintf("%s: decompression failed with error ", __FUNCTION__) + errorCodeToUString(result), index);
            return U_SUCCESS;
        }

        // Check for undecided compression algorithm, this is a special case
        if (algorithm == COMPRESSION_ALGORITHM_UNDECIDED) {
            // Try preparse of sections decompressed with Tiano algorithm
            if (U_SUCCESS == parseSections(processed, index, false)) {
                algorithm = COMPRESSION_ALGORITHM_TIANO;
            }
            // Try preparse of sections decompressed with EFI 1.1 algorithm
            else if (U_SUCCESS == parseSections(efiDecompressed, index, false)) {
                algorithm = COMPRESSION_ALGORITHM_EFI11;
                processed = efiDecompressed;
            }
            else {
                msg(usprintf("%s: can't guess the correct decompression algorithm, both preparse steps are failed", __FUNCTION__), index);
                parseCurrentSection = false;
            }
        }

        info += UString("\nCompression algorithm: ") + compressionTypeToUString(algorithm);
        info += usprintf("\nDecompressed size: %Xh (%u)", processed.size(), processed.size());
    }
    // LZMA compressed section
    else if (baGuid == EFI_GUIDED_SECTION_LZMA) {
        USTATUS result = decompress(model->body(index), EFI_CUSTOMIZED_COMPRESSION, algorithm, dictionarySize, processed, efiDecompressed);
        if (result) {
            msg(usprintf("%s: decompression failed with error ", __FUNCTION__) + errorCodeToUString(result), index);
            return U_SUCCESS;
        }

        if (algorithm == COMPRESSION_ALGORITHM_LZMA) {
            info += UString("\nCompression algorithm: LZMA");
            info += usprintf("\nDecompressed size: %Xh (%u)", processed.size(), processed.size());
            info += usprintf("\nLZMA dictionary size: %Xh", dictionarySize);
        }
        else {
            info += UString("\nCompression algorithm: unknown");
            parseCurrentSection = false;
        }
    }
    // LZMAF86 compressed section
    else if (baGuid == EFI_GUIDED_SECTION_LZMAF86) {
        USTATUS result = decompress(model->body(index), EFI_CUSTOMIZED_COMPRESSION_LZMAF86, algorithm, dictionarySize, processed, efiDecompressed);
        if (result) {
            msg(usprintf("%s: decompression failed with error ", __FUNCTION__) + errorCodeToUString(result), index);
            return U_SUCCESS;
        }

        if (algorithm == COMPRESSION_ALGORITHM_LZMAF86) {
            info += UString("\nCompression algorithm: LZMAF86");
            info += usprintf("\nDecompressed size: %Xh (%u)", processed.size(), processed.size());
            info += usprintf("\nLZMA dictionary size: %Xh", dictionarySize);
        }
        else {
            info += UString("\nCompression algorithm: unknown");
            parseCurrentSection = false;
        }
    }
    // GZip compressed section
    else if (baGuid == EFI_GUIDED_SECTION_GZIP) {
        USTATUS result = gzipDecompress(model->body(index), processed);
        if (result) {
            msg(usprintf("%s: decompression failed with error ", __FUNCTION__) + errorCodeToUString(result), index);
            return U_SUCCESS;
        }

        info += UString("\nCompression algorithm: GZip");
        info += usprintf("\nDecompressed size: %Xh (%u)", processed.size(), processed.size());
    }

    // Add info
    model->addInfo(index, info);

    // Update data
    if (algorithm != COMPRESSION_ALGORITHM_NONE)
        model->setCompressed(index, true);

    // Set parsing data
    GUIDED_SECTION_PARSING_DATA pdata;
    pdata.dictionarySize = dictionarySize;
    model->setParsingData(index, UByteArray((const char*)&pdata, sizeof(pdata)));

    if (!parseCurrentSection) {
        msg(usprintf("%s: GUID defined section can not be processed", __FUNCTION__), index);
        return U_SUCCESS;
    }

    return parseSections(processed, index, true);
}

USTATUS FfsParser::parseVersionSectionBody(const UModelIndex & index)
{
    // Sanity check
    if (!index.isValid())
        return U_INVALID_PARAMETER;

    // Add info
    model->addInfo(index, UString("\nVersion string: ") + UString::fromUtf16((const CHAR16*)model->body(index).constData()));

    return U_SUCCESS;
}

USTATUS FfsParser::parseDepexSectionBody(const UModelIndex & index)
{
    // Sanity check
    if (!index.isValid())
        return U_INVALID_PARAMETER;

    UByteArray body = model->body(index);
    UString parsed;

    // Check data to be present
    if (body.size() < 2) { // 2 is a minimal sane value, i.e TRUE + END
        msg(usprintf("%s: DEPEX section too short", __FUNCTION__), index);
        return U_DEPEX_PARSE_FAILED;
    }

    const EFI_GUID * guid;
    const UINT8* current = (const UINT8*)body.constData();

    // Special cases of first opcode
    switch (*current) {
    case EFI_DEP_BEFORE:
        if (body.size() != 2 * EFI_DEP_OPCODE_SIZE + sizeof(EFI_GUID)) {
            msg(usprintf("%s: DEPEX section too long for a section starting with BEFORE opcode", __FUNCTION__), index);
            return U_SUCCESS;
        }
        guid = (const EFI_GUID*)(current + EFI_DEP_OPCODE_SIZE);
        parsed += UString("\nBEFORE ") + guidToUString(readUnaligned(guid));
        current += EFI_DEP_OPCODE_SIZE + sizeof(EFI_GUID);
        if (*current != EFI_DEP_END){
            msg(usprintf("%s: DEPEX section ends with non-END opcode", __FUNCTION__), index);
            return U_SUCCESS;
        }
        return U_SUCCESS;
    case EFI_DEP_AFTER:
        if (body.size() != 2 * EFI_DEP_OPCODE_SIZE + sizeof(EFI_GUID)){
            msg(usprintf("%s: DEPEX section too long for a section starting with AFTER opcode", __FUNCTION__), index);
            return U_SUCCESS;
        }
        guid = (const EFI_GUID*)(current + EFI_DEP_OPCODE_SIZE);
        parsed += UString("\nAFTER ") + guidToUString(readUnaligned(guid));
        current += EFI_DEP_OPCODE_SIZE + sizeof(EFI_GUID);
        if (*current != EFI_DEP_END) {
            msg(usprintf("%s: DEPEX section ends with non-END opcode", __FUNCTION__), index);
            return U_SUCCESS;
        }
        return U_SUCCESS;
    case EFI_DEP_SOR:
        if (body.size() <= 2 * EFI_DEP_OPCODE_SIZE) {
            msg(usprintf("%s: DEPEX section too short for a section starting with SOR opcode", __FUNCTION__), index);
            return U_SUCCESS;
        }
        parsed += UString("\nSOR");
        current += EFI_DEP_OPCODE_SIZE;
        break;
    }

    // Parse the rest of depex
    while (current - (const UINT8*)body.constData() < body.size()) {
        switch (*current) {
        case EFI_DEP_BEFORE: {
            msg(usprintf("%s: misplaced BEFORE opcode", __FUNCTION__), index);
            return U_SUCCESS;
        }
        case EFI_DEP_AFTER: {
            msg(usprintf("%s: misplaced AFTER opcode", __FUNCTION__), index);
            return U_SUCCESS;
        }
        case EFI_DEP_SOR: {
            msg(usprintf("%s: misplaced SOR opcode", __FUNCTION__), index);
            return U_SUCCESS;
        }
        case EFI_DEP_PUSH:
            // Check that the rest of depex has correct size
            if ((UINT32)body.size() - (UINT32)(current - (const UINT8*)body.constData()) <= EFI_DEP_OPCODE_SIZE + sizeof(EFI_GUID)) {
                parsed.clear();
                msg(usprintf("%s: remains of DEPEX section too short for PUSH opcode", __FUNCTION__), index);
                return U_SUCCESS;
            }
            guid = (const EFI_GUID*)(current + EFI_DEP_OPCODE_SIZE);
            parsed += UString("\nPUSH ") + guidToUString(readUnaligned(guid));
            current += EFI_DEP_OPCODE_SIZE + sizeof(EFI_GUID);
            break;
        case EFI_DEP_AND:
            parsed += UString("\nAND");
            current += EFI_DEP_OPCODE_SIZE;
            break;
        case EFI_DEP_OR:
            parsed += UString("\nOR");
            current += EFI_DEP_OPCODE_SIZE;
            break;
        case EFI_DEP_NOT:
            parsed += UString("\nNOT");
            current += EFI_DEP_OPCODE_SIZE;
            break;
        case EFI_DEP_TRUE:
            parsed += UString("\nTRUE");
            current += EFI_DEP_OPCODE_SIZE;
            break;
        case EFI_DEP_FALSE:
            parsed += UString("\nFALSE");
            current += EFI_DEP_OPCODE_SIZE;
            break;
        case EFI_DEP_END:
            parsed += UString("\nEND");
            current += EFI_DEP_OPCODE_SIZE;
            // Check that END is the last opcode
            if (current - (const UINT8*)body.constData() < body.size()) {
                parsed.clear();
                msg(usprintf("%s: DEPEX section ends with non-END opcode", __FUNCTION__), index);
            }
            break;
        default:
            msg(usprintf("%s: unknown opcode %02Xh", __FUNCTION__, *current), index);
            return U_SUCCESS;
            break;
        }
    }

    // Add info
    model->addInfo(index, UString("\nParsed expression:") + parsed);

    return U_SUCCESS;
}

USTATUS FfsParser::parseUiSectionBody(const UModelIndex & index)
{
    // Sanity check
    if (!index.isValid())
        return U_INVALID_PARAMETER;

    UString text = UString::fromUtf16((const CHAR16*)model->body(index).constData());

    // Add info
    model->addInfo(index, UString("\nText: ") + text);

    // Rename parent file
    model->setText(model->findParentOfType(index, Types::File), text);

    return U_SUCCESS;
}

USTATUS FfsParser::parseAprioriRawSection(const UByteArray & body, UString & parsed)
{
    // Sanity check
    if (body.size() % sizeof(EFI_GUID)) {
        msg(usprintf("%s: apriori file has size is not a multiple of 16", __FUNCTION__));
    }
    parsed.clear();
    UINT32 count = body.size() / sizeof(EFI_GUID);
    if (count > 0) {
        for (UINT32 i = 0; i < count; i++) {
            const EFI_GUID* guid = (const EFI_GUID*)body.constData() + i;
            parsed += UString("\n") + guidToUString(readUnaligned(guid));
        }
    }

    return U_SUCCESS;
}

USTATUS FfsParser::parseRawSectionBody(const UModelIndex & index)
{
    // Sanity check
    if (!index.isValid())
        return U_INVALID_PARAMETER;

    // Check for apriori file
    UModelIndex parentFile = model->findParentOfType(index, Types::File);
    if (!parentFile.isValid())
        return U_INVALID_FILE; //TODO: better return code

    // Get parent file parsing data
    UByteArray parentFileGuid(model->header(parentFile).constData(), sizeof(EFI_GUID));
    if (parentFileGuid == EFI_PEI_APRIORI_FILE_GUID) { // PEI apriori file
        // Set parent file text
        model->setText(parentFile, UString("PEI apriori file"));
        // Parse apriori file list
        UString str;
        USTATUS result = parseAprioriRawSection(model->body(index), str);
        if (!result && !str.isEmpty())
            model->addInfo(index, UString("\nFile list:") + str);
        return result;
    }
    else if (parentFileGuid == EFI_DXE_APRIORI_FILE_GUID) { // DXE apriori file
        // Rename parent file
        model->setText(parentFile, UString("DXE apriori file"));
        // Parse apriori file list
        UString str;
        USTATUS result = parseAprioriRawSection(model->body(index), str);
        if (!result && !str.isEmpty())
            model->addInfo(index, UString("\nFile list:") + str);
        return result;
    }
    else if (parentFileGuid == NVRAM_NVAR_EXTERNAL_DEFAULTS_FILE_GUID) { // AMI NVRAM external defaults
        // Rename parent file
        model->setText(parentFile, UString("NVRAM external defaults"));
        // Parse NVAR area
        return nvramParser->parseNvarStore(index);
    }
    else if (parentFileGuid == BG_VENDOR_HASH_FILE_GUID_AMI) { // AMI vendor hash file
        // Parse AMI vendor hash file
        return parseVendorHashFile(parentFileGuid, index);
    }

    // Parse as raw area
    return parseRawArea(index);
}


USTATUS FfsParser::parsePeImageSectionBody(const UModelIndex & index)
{
    // Sanity check
    if (!index.isValid())
        return U_INVALID_PARAMETER;

    // Get section body
    UByteArray body = model->body(index);
    if ((UINT32)body.size() < sizeof(EFI_IMAGE_DOS_HEADER)) {
        msg(usprintf("%s: section body size is smaller than DOS header size", __FUNCTION__), index);
        return U_SUCCESS;
    }

    UString info;
    const EFI_IMAGE_DOS_HEADER* dosHeader = (const EFI_IMAGE_DOS_HEADER*)body.constData();
    if (dosHeader->e_magic != EFI_IMAGE_DOS_SIGNATURE) {
        info += usprintf("\nDOS signature: %04Xh, invalid", dosHeader->e_magic);
        msg(usprintf("%s: PE32 image with invalid DOS signature", __FUNCTION__), index);
        model->addInfo(index, info);
        return U_SUCCESS;
    }

    const EFI_IMAGE_PE_HEADER* peHeader = (EFI_IMAGE_PE_HEADER*)(body.constData() + dosHeader->e_lfanew);
    if (body.size() < (UINT8*)peHeader - (UINT8*)dosHeader) {
        info += UString("\nDOS header: invalid");
        msg(usprintf("%s: PE32 image with invalid DOS header", __FUNCTION__), index);
        model->addInfo(index, info);
        return U_SUCCESS;
    }

    if (peHeader->Signature != EFI_IMAGE_PE_SIGNATURE) {
        info += usprintf("\nPE signature: %08Xh, invalid", peHeader->Signature);
        msg(usprintf("%s: PE32 image with invalid PE signature", __FUNCTION__), index);
        model->addInfo(index, info);
        return U_SUCCESS;
    }

    const EFI_IMAGE_FILE_HEADER* imageFileHeader = (const EFI_IMAGE_FILE_HEADER*)(peHeader + 1);
    if (body.size() < (UINT8*)imageFileHeader - (UINT8*)dosHeader) {
        info += UString("\nPE header: invalid");
        msg(usprintf("%s: PE32 image with invalid PE header", __FUNCTION__), index);
        model->addInfo(index, info);
        return U_SUCCESS;
    }

    info += usprintf("\nDOS signature: %04Xh\nPE signature: %08Xh",
        dosHeader->e_magic,
        peHeader->Signature) +
        UString("\nMachine type: ") + machineTypeToUString(imageFileHeader->Machine) +
        usprintf("\nNumber of sections: %u\nCharacteristics: %04Xh",
        imageFileHeader->NumberOfSections,
        imageFileHeader->Characteristics);

    EFI_IMAGE_OPTIONAL_HEADER_POINTERS_UNION optionalHeader;
    optionalHeader.H32 = (const EFI_IMAGE_OPTIONAL_HEADER32*)(imageFileHeader + 1);
    if (body.size() < (UINT8*)optionalHeader.H32 - (UINT8*)dosHeader) {
        info += UString("\nPE optional header: invalid");
        msg(usprintf("%s: PE32 image with invalid PE optional header", __FUNCTION__), index);
        model->addInfo(index, info);
        return U_SUCCESS;
    }

    if (optionalHeader.H32->Magic == EFI_IMAGE_PE_OPTIONAL_HDR32_MAGIC) {
        info += usprintf("\nOptional header signature: %04Xh\nSubsystem: %04Xh\nAddress of entry point: %Xh\nBase of code: %Xh\nImage base: %Xh",
            optionalHeader.H32->Magic,
            optionalHeader.H32->Subsystem,
            optionalHeader.H32->AddressOfEntryPoint,
            optionalHeader.H32->BaseOfCode,
            optionalHeader.H32->ImageBase);
    }
    else if (optionalHeader.H32->Magic == EFI_IMAGE_PE_OPTIONAL_HDR64_MAGIC) {
        info += usprintf("\nOptional header signature: %04Xh\nSubsystem: %04Xh\nAddress of entry point: %Xh\nBase of code: %Xh\nImage base: %" PRIX64 "h",
            optionalHeader.H64->Magic,
            optionalHeader.H64->Subsystem,
            optionalHeader.H64->AddressOfEntryPoint,
            optionalHeader.H64->BaseOfCode,
            optionalHeader.H64->ImageBase);
    }
    else {
        info += usprintf("\nOptional header signature: %04Xh, unknown", optionalHeader.H32->Magic);
        msg(usprintf("%s: PE32 image with invalid optional PE header signature", __FUNCTION__), index);
    }

    model->addInfo(index, info);
    return U_SUCCESS;
}


USTATUS FfsParser::parseTeImageSectionBody(const UModelIndex & index)
{
    // Check sanity
    if (!index.isValid())
        return U_INVALID_PARAMETER;

    // Get section body
    UByteArray body = model->body(index);
    if ((UINT32)body.size() < sizeof(EFI_IMAGE_TE_HEADER)) {
        msg(usprintf("%s: section body size is smaller than TE header size", __FUNCTION__), index);
        return U_SUCCESS;
    }

    UString info;
    const EFI_IMAGE_TE_HEADER* teHeader = (const EFI_IMAGE_TE_HEADER*)body.constData();
    if (teHeader->Signature != EFI_IMAGE_TE_SIGNATURE) {
        info += usprintf("\nSignature: %04Xh, invalid", teHeader->Signature);
        msg(usprintf("%s: TE image with invalid TE signature", __FUNCTION__), index);
    }
    else {
        info += usprintf("\nSignature: %04Xh", teHeader->Signature) +
            UString("\nMachine type: ") + machineTypeToUString(teHeader->Machine) +
            usprintf("\nNumber of sections: %u\nSubsystem: %02Xh\nStripped size: %Xh (%u)\n"
            "Base of code: %Xh\nAddress of entry point: %Xh\nImage base: %" PRIX64 "h\nAdjusted image base: %" PRIX64 "h",
            teHeader->NumberOfSections,
            teHeader->Subsystem,
            teHeader->StrippedSize, teHeader->StrippedSize,
            teHeader->BaseOfCode,
            teHeader->AddressOfEntryPoint,
            teHeader->ImageBase,
            teHeader->ImageBase + teHeader->StrippedSize - sizeof(EFI_IMAGE_TE_HEADER));
    }

    // Update parsing data
    TE_IMAGE_SECTION_PARSING_DATA pdata;
    pdata.imageBaseType = EFI_IMAGE_TE_BASE_OTHER; // Will be determined later
    pdata.originalImageBase = (UINT32)teHeader->ImageBase;
    pdata.adjustedImageBase = (UINT32)(teHeader->ImageBase + teHeader->StrippedSize - sizeof(EFI_IMAGE_TE_HEADER));
    model->setParsingData(index, UByteArray((const char*)&pdata, sizeof(pdata)));

    // Add TE info
    model->addInfo(index, info);

    return U_SUCCESS;
}


USTATUS FfsParser::performSecondPass(const UModelIndex & index)
{
    // Sanity check
    if (!index.isValid() || !lastVtf.isValid())
        return U_INVALID_PARAMETER;

    // Check for compressed lastVtf
    if (model->compressed(lastVtf)) {
        msg(usprintf("%s: the last VTF appears inside compressed item, the image may be damaged", __FUNCTION__), lastVtf);
        return U_SUCCESS;
    }

    // Calculate address difference
    const UINT32 vtfSize = model->header(lastVtf).size() + model->body(lastVtf).size() + model->tail(lastVtf).size();
    addressDiff = 0xFFFFFFFFULL - model->base(lastVtf) - vtfSize + 1;

    // Parse reset vector data
    parseResetVectorData();

    // Find and parse FIT
    parseFit(index);

    // Check protected ranges
    checkProtectedRanges(index);

    // Check TE files to have original or adjusted base
    checkTeImageBase(index);

    return U_SUCCESS;
}

USTATUS FfsParser::parseResetVectorData()
{
    // Sanity check
    if (!lastVtf.isValid())
        return U_SUCCESS;

    // Check VTF to have enough space at the end to fit Reset Vector Data
    UByteArray vtf = model->header(lastVtf) + model->body(lastVtf) + model->tail(lastVtf);
    if ((UINT32)vtf.size() < sizeof(X86_RESET_VECTOR_DATA))
        return U_SUCCESS;

    const X86_RESET_VECTOR_DATA* resetVectorData = (const X86_RESET_VECTOR_DATA*)(vtf.constData() + vtf.size() - sizeof(X86_RESET_VECTOR_DATA));

    // Add info
    UString info = usprintf("\nAP entry vector: %02X %02X %02X %02X %02X %02X %02X %02X\n"
                            "Reset vector: %02X %02X %02X %02X %02X %02X %02X %02X\n"
                            "PEI core entry point: %08Xh\n"
                            "AP startup segment: %08X\n"
                            "BootFV base address: %08X\n",
        resetVectorData->ApEntryVector[0], resetVectorData->ApEntryVector[1], resetVectorData->ApEntryVector[2], resetVectorData->ApEntryVector[3],
        resetVectorData->ApEntryVector[4], resetVectorData->ApEntryVector[5], resetVectorData->ApEntryVector[6], resetVectorData->ApEntryVector[7],
        resetVectorData->ResetVector[0], resetVectorData->ResetVector[1], resetVectorData->ResetVector[2], resetVectorData->ResetVector[3],
        resetVectorData->ResetVector[4], resetVectorData->ResetVector[5], resetVectorData->ResetVector[6], resetVectorData->ResetVector[7],
        resetVectorData->PeiCoreEntryPoint,
        resetVectorData->ApStartupSegment,
        resetVectorData->BootFvBaseAddress);

    model->addInfo(lastVtf, info);
    return U_SUCCESS;
}

USTATUS FfsParser::checkTeImageBase(const UModelIndex & index)
{
    // Sanity check
    if (!index.isValid())
        return U_SUCCESS;

    // Determine relocation type of uncompressed TE image sections
    if (model->compressed(index) == false
        && model->type(index) == Types::Section
        && model->subtype(index) == EFI_SECTION_TE) {
        // Obtain required values from parsing data
        UINT32 originalImageBase = 0;
        UINT32 adjustedImageBase = 0;
        UINT8  imageBaseType = EFI_IMAGE_TE_BASE_OTHER;
        if (model->hasEmptyParsingData(index) == false) {
            UByteArray data = model->parsingData(index);
            const TE_IMAGE_SECTION_PARSING_DATA* pdata = (const TE_IMAGE_SECTION_PARSING_DATA*)data.constData();
            originalImageBase = readUnaligned(pdata).originalImageBase;
            adjustedImageBase = readUnaligned(pdata).adjustedImageBase;
        }

        if (originalImageBase != 0 || adjustedImageBase != 0) {
            // Check data memory address to be equal to either OriginalImageBase or AdjustedImageBase
            UINT64 address = addressDiff + model->base(index);
            UINT32 base = (UINT32)address + model->header(index).size();

            if (originalImageBase == base) {
                imageBaseType = EFI_IMAGE_TE_BASE_ORIGINAL;
            }
            else if (adjustedImageBase == base) {
                imageBaseType = EFI_IMAGE_TE_BASE_ADJUSTED;
            }
            else {
                // Check for one-bit difference
                UINT32 xored = base ^ originalImageBase; // XOR result can't be zero
                if ((xored & (xored - 1)) == 0) { // Check that XOR result is a power of 2, i.e. has exactly one bit set
                    imageBaseType = EFI_IMAGE_TE_BASE_ORIGINAL;
                }
                else { // The same check for adjustedImageBase
                    xored = base ^ adjustedImageBase;
                    if ((xored & (xored - 1)) == 0) {
                        imageBaseType = EFI_IMAGE_TE_BASE_ADJUSTED;
                    }
                }
            }

            // Show message if imageBaseType is still unknown
            if (imageBaseType == EFI_IMAGE_TE_BASE_OTHER) {
                msg(usprintf("%s: TE image base is neither zero, nor original, nor adjusted, nor top-swapped", __FUNCTION__), index);
            }

            // Update parsing data
            TE_IMAGE_SECTION_PARSING_DATA pdata;
            pdata.imageBaseType = imageBaseType;
            pdata.originalImageBase = originalImageBase;
            pdata.adjustedImageBase = adjustedImageBase;
            model->setParsingData(index, UByteArray((const char*)&pdata, sizeof(pdata)));
        }
    }

    // Process child items
    for (int i = 0; i < model->rowCount(index); i++) {
        checkTeImageBase(index.child(i, 0));
    }

    return U_SUCCESS;
}

USTATUS FfsParser::addInfoRecursive(const UModelIndex & index)
{
    // Sanity check
    if (!index.isValid())
        return U_INVALID_PARAMETER;

    // Add offset
    model->addInfo(index, usprintf("Offset: %Xh\n", model->offset(index)), false);

    // Add current base if the element is not compressed
    // or it's compressed, but it's parent isn't
    if ((!model->compressed(index)) || (index.parent().isValid() && !model->compressed(index.parent()))) {
        // Add physical address of the whole item or it's header and data portions separately
        UINT64 address = addressDiff + model->base(index);
        if (address <= 0xFFFFFFFFUL) {
            UINT32 headerSize = model->header(index).size();
            if (headerSize) {
                model->addInfo(index, usprintf("Data address: %08Xh\n", address + headerSize),false);
                model->addInfo(index, usprintf("Header address: %08Xh\n", address), false);
            }
            else {
                model->addInfo(index, usprintf("Address: %08Xh\n", address), false);
            }
        }
        // Add base
        model->addInfo(index, usprintf("Base: %Xh\n", model->base(index)), false);
    }
    model->addInfo(index, usprintf("Fixed: %s\n", model->fixed(index) ? "Yes" : "No"), false);

    // Process child items
    for (int i = 0; i < model->rowCount(index); i++) {
        addInfoRecursive(index.child(i, 0));
    }

    return U_SUCCESS;
}

USTATUS FfsParser::checkProtectedRanges(const UModelIndex & index)
{
    // Sanity check
    if (!index.isValid())
        return U_INVALID_PARAMETER;

    // Calculate digest for BG-protected ranges
    UByteArray protectedParts;
    bool bgProtectedRangeFound = false;
    try {
        for (UINT32 i = 0; i < (UINT32)bgProtectedRanges.size(); i++) {
            if (bgProtectedRanges[i].Type == BG_PROTECTED_RANGE_INTEL_BOOT_GUARD_IBB && bgProtectedRanges[i].Size > 0) {
                bgProtectedRangeFound = true;
                if ((UINT64)bgProtectedRanges[i].Offset >= addressDiff) {
                    bgProtectedRanges[i].Offset -= (UINT32)addressDiff;
                } else {
                    // TODO: Explore this.
                    msg(usprintf("%s: Suspicious BG protection offset", __FUNCTION__), index);
                }
                protectedParts += openedImage.mid(bgProtectedRanges[i].Offset, bgProtectedRanges[i].Size);
                markProtectedRangeRecursive(index, bgProtectedRanges[i]);
            }
        }
    } catch (...) {
        bgProtectedRangeFound = false;
    }

    if (bgProtectedRangeFound) {
        UByteArray digest(SHA256_DIGEST_SIZE, '\x00');
        sha256(protectedParts.constData(), protectedParts.size(), digest.data());

        if (digest != bgBpDigest) {
            msg(usprintf("%s: BG-protected ranges hash mismatch, opened image may refuse to boot", __FUNCTION__), index);
        }
    }
    else if (bgBootPolicyFound) {
        msg(usprintf("%s: BootPolicy doesn't define any BG-protected ranges", __FUNCTION__), index);
    }

    // Calculate digests for vendor-protected ranges
    for (UINT32 i = 0; i < (UINT32)bgProtectedRanges.size(); i++) {
        if (bgProtectedRanges[i].Type == BG_PROTECTED_RANGE_VENDOR_HASH_AMI_OLD
            && bgProtectedRanges[i].Size != 0 && bgProtectedRanges[i].Size != 0xFFFFFFFF) {
            if (!bgDxeCoreIndex.isValid()) {
                msg(usprintf("%s: can't determine DXE volume offset, old AMI protected range hash can't be checked", __FUNCTION__), index);
            }
            else {
                // Offset will be determined as the offset of root volume with first DXE core
                UModelIndex dxeRootVolumeIndex = model->findLastParentOfType(bgDxeCoreIndex, Types::Volume);
                if (!dxeRootVolumeIndex.isValid()) {
                    msg(usprintf("%s: can't determine DXE volume offset, old AMI protected range hash can't be checked", __FUNCTION__), index);
                }
                else {
                    bgProtectedRanges[i].Offset = model->base(dxeRootVolumeIndex);
                    protectedParts = openedImage.mid(bgProtectedRanges[i].Offset, bgProtectedRanges[i].Size);

                    UByteArray digest(SHA256_DIGEST_SIZE, '\x00');
                    sha256(protectedParts.constData(), protectedParts.size(), digest.data());

                    if (digest != bgProtectedRanges[i].Hash) {
                        msg(usprintf("%s: old AMI protected range [%Xh:%Xh] hash mismatch, opened image may refuse to boot", __FUNCTION__,
                            bgProtectedRanges[i].Offset, bgProtectedRanges[i].Offset + bgProtectedRanges[i].Size),
                            model->findByBase(bgProtectedRanges[i].Offset));
                    }

                    markProtectedRangeRecursive(index, bgProtectedRanges[i]);
                }
            }
        }
        else if (bgProtectedRanges[i].Type == BG_PROTECTED_RANGE_INTEL_BOOT_GUARD_POST_IBB) {
            if (!bgDxeCoreIndex.isValid()) {
                msg(usprintf("%s: can't determine DXE volume offset, post-IBB protected range hash can't be checked", __FUNCTION__), index);
            }
            else {
                // Offset will be determined as the offset of root volume with first DXE core
                UModelIndex dxeRootVolumeIndex = model->findLastParentOfType(bgDxeCoreIndex, Types::Volume);
                if (!dxeRootVolumeIndex.isValid()) {
                    msg(usprintf("%s: can't determine DXE volume offset, post-IBB protected range hash can't be checked", __FUNCTION__), index);
                }
                else
                {
                    bgProtectedRanges[i].Offset = model->base(dxeRootVolumeIndex);
                    bgProtectedRanges[i].Size = model->header(dxeRootVolumeIndex).size() + model->body(dxeRootVolumeIndex).size() + model->tail(dxeRootVolumeIndex).size();
                    protectedParts = openedImage.mid(bgProtectedRanges[i].Offset, bgProtectedRanges[i].Size);

                    UByteArray digest(SHA256_DIGEST_SIZE, '\x00');
                    sha256(protectedParts.constData(), protectedParts.size(), digest.data());

                    if (digest != bgProtectedRanges[i].Hash) {
                        msg(usprintf("%s: post-IBB protected range [%Xh:%Xh] hash mismatch, opened image may refuse to boot", __FUNCTION__,
                            bgProtectedRanges[i].Offset, bgProtectedRanges[i].Offset + bgProtectedRanges[i].Size),
                            model->findByBase(bgProtectedRanges[i].Offset));
                    }

                    markProtectedRangeRecursive(index, bgProtectedRanges[i]);
                }
            }
        }
        else if (bgProtectedRanges[i].Type == BG_PROTECTED_RANGE_VENDOR_HASH_AMI_NEW
            && bgProtectedRanges[i].Size != 0 && bgProtectedRanges[i].Size != 0xFFFFFFFF
            && bgProtectedRanges[i].Offset != 0 && bgProtectedRanges[i].Offset != 0xFFFFFFFF) {

            bgProtectedRanges[i].Offset -= (UINT32)addressDiff;
            protectedParts = openedImage.mid(bgProtectedRanges[i].Offset, bgProtectedRanges[i].Size);

            UByteArray digest(SHA256_DIGEST_SIZE, '\x00');
            sha256(protectedParts.constData(), protectedParts.size(), digest.data());

            if (digest != bgProtectedRanges[i].Hash) {
                msg(usprintf("%s: AMI protected range [%Xh:%Xh] hash mismatch, opened image may refuse to boot", __FUNCTION__,
                    bgProtectedRanges[i].Offset, bgProtectedRanges[i].Offset + bgProtectedRanges[i].Size),
                    model->findByBase(bgProtectedRanges[i].Offset));
            }

            markProtectedRangeRecursive(index, bgProtectedRanges[i]);
        }
        else if (bgProtectedRanges[i].Type == BG_PROTECTED_RANGE_VENDOR_HASH_PHOENIX
            && bgProtectedRanges[i].Size != 0 && bgProtectedRanges[i].Size != 0xFFFFFFFF
            && bgProtectedRanges[i].Offset != 0xFFFFFFFF) {
            bgProtectedRanges[i].Offset += (UINT32)bgProtectedRegionsBase;
            protectedParts = openedImage.mid(bgProtectedRanges[i].Offset, bgProtectedRanges[i].Size);

            UByteArray digest(SHA256_DIGEST_SIZE, '\x00');
            sha256(protectedParts.constData(), protectedParts.size(), digest.data());

            if (digest != bgProtectedRanges[i].Hash) {
                msg(usprintf("%s: Phoenix protected range [%Xh:%Xh] hash mismatch, opened image may refuse to boot", __FUNCTION__,
                    bgProtectedRanges[i].Offset, bgProtectedRanges[i].Offset + bgProtectedRanges[i].Size),
                    model->findByBase(bgProtectedRanges[i].Offset));
            }

            markProtectedRangeRecursive(index, bgProtectedRanges[i]);
        }
        else if (bgProtectedRanges[i].Type == BG_PROTECTED_RANGE_VENDOR_HASH_MICROSOFT
            && bgProtectedRanges[i].Size != 0 && bgProtectedRanges[i].Size != 0xFFFFFFFF
            && bgProtectedRanges[i].Offset != 0 && bgProtectedRanges[i].Offset != 0xFFFFFFFF) {
            bgProtectedRanges[i].Offset -= (UINT32)addressDiff;
            protectedParts = openedImage.mid(bgProtectedRanges[i].Offset, bgProtectedRanges[i].Size);

            UByteArray digest(SHA256_DIGEST_SIZE, '\x00');
            sha256(protectedParts.constData(), protectedParts.size(), digest.data());

            if (digest != bgProtectedRanges[i].Hash) {
                msg(usprintf("%s: Microsoft protected range [%Xh:%Xh] hash mismatch, opened image may refuse to boot", __FUNCTION__,
                    bgProtectedRanges[i].Offset, bgProtectedRanges[i].Offset + bgProtectedRanges[i].Size),
                    model->findByBase(bgProtectedRanges[i].Offset));
            }

            markProtectedRangeRecursive(index, bgProtectedRanges[i]);
        }
    }

    return U_SUCCESS;
}

USTATUS FfsParser::markProtectedRangeRecursive(const UModelIndex & index, const BG_PROTECTED_RANGE & range)
{
    if (!index.isValid())
        return U_SUCCESS;

    // Mark compressed items
    UModelIndex parentIndex = model->parent(index);
    if (parentIndex.isValid() && model->compressed(index) && model->compressed(parentIndex)) {
        model->setMarking(index, model->marking(parentIndex));
    }
    // Mark normal items
    else {
        UINT32 currentOffset = model->base(index);
        UINT32 currentSize = model->header(index).size() + model->body(index).size() + model->tail(index).size();

        if (std::min(currentOffset + currentSize, range.Offset + range.Size) > std::max(currentOffset, range.Offset)) {
            if (range.Offset <= currentOffset && currentOffset + currentSize <= range.Offset + range.Size) { // Mark as fully in range
                if (range.Type == BG_PROTECTED_RANGE_INTEL_BOOT_GUARD_IBB) {
                    model->setMarking(index, Qt::red);
                }
                else {
                    model->setMarking(index, Qt::cyan);
                }
            }
            else { // Mark as partially in range
                model->setMarking(index, Qt::yellow);
            }
        }
    }

    for (int i = 0; i < model->rowCount(index); i++) {
        markProtectedRangeRecursive(index.child(i, 0), range);
    }

    return U_SUCCESS;
}

USTATUS FfsParser::parseVendorHashFile(const UByteArray & fileGuid, const UModelIndex & index)
{
    if (!index.isValid())
        return EFI_INVALID_PARAMETER;

    if (fileGuid == BG_VENDOR_HASH_FILE_GUID_PHOENIX) {
        const UByteArray &body = model->body(index);
        UINT32 size = (UINT32)body.size();

        // File too small to have even a signature
        if (size < sizeof(BG_VENDOR_HASH_FILE_SIGNATURE_PHOENIX)) {
            msg(usprintf("%s: unknown or corrupted Phoenix hash file found", __FUNCTION__), index);
            model->setText(index, UString("Phoenix hash file"));
            return U_INVALID_FILE;
        }

        const BG_VENDOR_HASH_FILE_HEADER_PHOENIX* header = (const BG_VENDOR_HASH_FILE_HEADER_PHOENIX*)body.constData();
        if (header->Signature == BG_VENDOR_HASH_FILE_SIGNATURE_PHOENIX) {
            if (size < sizeof(BG_VENDOR_HASH_FILE_HEADER_PHOENIX) ||
                size < sizeof(BG_VENDOR_HASH_FILE_HEADER_PHOENIX) + header->NumEntries * sizeof(BG_VENDOR_HASH_FILE_ENTRY)) {
                msg(usprintf("%s: unknown or corrupted Phoenix hash file found", __FUNCTION__), index);
                model->setText(index, UString("Phoenix hash file"));
                return U_INVALID_FILE;
            }

            if (header->NumEntries > 0) {
                bool protectedRangesFound = false;
                for (UINT32 i = 0; i < header->NumEntries; i++) {
                    protectedRangesFound = true;
                    const BG_VENDOR_HASH_FILE_ENTRY* entry = (const BG_VENDOR_HASH_FILE_ENTRY*)(header + 1) + i;

                    BG_PROTECTED_RANGE range;
                    range.Offset = entry->Offset;
                    range.Size = entry->Size;
                    range.Hash = UByteArray((const char*)entry->Hash, sizeof(entry->Hash));
                    range.Type = BG_PROTECTED_RANGE_VENDOR_HASH_PHOENIX;
                    bgProtectedRanges.push_back(range);
                }

                if (protectedRangesFound) {
                    securityInfo += usprintf("Phoenix hash file found at base %Xh\nProtected ranges:", model->base(index));
                    for (UINT32 i = 0; i < header->NumEntries; i++) {
                        const BG_VENDOR_HASH_FILE_ENTRY* entry = (const BG_VENDOR_HASH_FILE_ENTRY*)(header + 1) + i;
                        securityInfo += usprintf("\nRelativeOffset: %08Xh Size: %Xh\nHash: ", entry->Offset, entry->Size);
                        for (UINT8 j = 0; j < sizeof(entry->Hash); j++) {
                            securityInfo += usprintf("%02X", entry->Hash[j]);
                        }
                    }
                    securityInfo += UString("\n------------------------------------------------------------------------\n\n");
                }

                msg(usprintf("%s: Phoenix hash file found", __FUNCTION__), index);
            }
            else {
                msg(usprintf("%s: empty Phoenix hash file found", __FUNCTION__), index);
            }

            model->setText(index, UString("Phoenix hash file"));
        }
    }
    else if (fileGuid == BG_VENDOR_HASH_FILE_GUID_AMI) {
        UModelIndex fileIndex = model->parent(index);
        const UByteArray &body = model->body(index);
        UINT32 size = (UINT32)body.size();
        if (size != (UINT32)body.count('\xFF')) {
            if (size == sizeof(BG_VENDOR_HASH_FILE_HEADER_AMI_NEW)) {
                bool protectedRangesFound = false;
                UINT32 NumEntries = (UINT32)body.size() / sizeof(BG_VENDOR_HASH_FILE_ENTRY);
                for (UINT32 i = 0; i < NumEntries; i++) {
                    protectedRangesFound = true;
                    const BG_VENDOR_HASH_FILE_ENTRY* entry = (const BG_VENDOR_HASH_FILE_ENTRY*)(body.constData()) + i;
                    BG_PROTECTED_RANGE range;
                    range.Offset = entry->Offset;
                    range.Size = entry->Size;
                    range.Hash = UByteArray((const char*)entry->Hash, sizeof(entry->Hash));
                    range.Type = BG_PROTECTED_RANGE_VENDOR_HASH_AMI_NEW;
                    bgProtectedRanges.push_back(range);
                }

                if (protectedRangesFound) {
                    securityInfo += usprintf("New AMI hash file found at base %Xh\nProtected ranges:", model->base(fileIndex));
                    for (UINT32 i = 0; i < NumEntries; i++) {
                        const BG_VENDOR_HASH_FILE_ENTRY* entry = (const BG_VENDOR_HASH_FILE_ENTRY*)(body.constData()) + i;
                        securityInfo += usprintf("\nAddress: %08Xh Size: %Xh\nHash: ", entry->Offset, entry->Size);
                        for (UINT8 j = 0; j < sizeof(entry->Hash); j++) {
                            securityInfo += usprintf("%02X", entry->Hash[j]);
                        }
                    }
                    securityInfo += UString("\n------------------------------------------------------------------------\n\n");
                }

                msg(usprintf("%s: new AMI hash file found", __FUNCTION__), fileIndex);
            }
            else if (size == sizeof(BG_VENDOR_HASH_FILE_HEADER_AMI_OLD)) {
                securityInfo += usprintf("Old AMI hash file found at base %Xh\nProtected range:", model->base(fileIndex));
                const BG_VENDOR_HASH_FILE_HEADER_AMI_OLD* entry = (const BG_VENDOR_HASH_FILE_HEADER_AMI_OLD*)(body.constData());
                securityInfo += usprintf("\nSize: %Xh\nHash: ", entry->Size);
                for (UINT8 i = 0; i < sizeof(entry->Hash); i++) {
                    securityInfo += usprintf("%02X", entry->Hash[i]);
                }
                securityInfo += UString("\n------------------------------------------------------------------------\n\n");

                BG_PROTECTED_RANGE range;
                range.Offset = 0;
                range.Size = entry->Size;
                range.Hash = UByteArray((const char*)entry->Hash, sizeof(entry->Hash));
                range.Type = BG_PROTECTED_RANGE_VENDOR_HASH_AMI_OLD;
                bgProtectedRanges.push_back(range);

                msg(usprintf("%s: old AMI hash file found", __FUNCTION__), fileIndex);
            }
            else {
                msg(usprintf("%s: unknown or corrupted AMI hash file found", __FUNCTION__), index);
            }
        }
        else {
            msg(usprintf("%s: empty AMI hash file found", __FUNCTION__), fileIndex);
        }

        model->setText(fileIndex, UString("AMI hash file"));
    }

    return U_SUCCESS;
}

#ifndef U_ENABLE_FIT_PARSING_SUPPORT
USTATUS FfsParser::parseFit(const UModelIndex & index)
{
    U_UNUSED_PARAMETER(index);
    return U_SUCCESS;
}

#else
USTATUS FfsParser::parseFit(const UModelIndex & index)
{
    // Check sanity
    if (!index.isValid())
        return EFI_INVALID_PARAMETER;

    // Search for FIT
    UModelIndex fitIndex;
    UINT32 fitOffset;
    findFitRecursive(index, fitIndex, fitOffset);

    // FIT not found
    if (!fitIndex.isValid())
        return U_SUCCESS;

    // Explicitly set the item containing FIT as fixed
    model->setFixed(fitIndex, true);

    // Special case of FIT header
    UByteArray fitBody = model->body(fitIndex);
    const FIT_ENTRY* fitHeader = (const FIT_ENTRY*)(fitBody.constData() + fitOffset);

    // Check FIT checksum, if present
    UINT32 fitSize = fitHeader->Size * sizeof(FIT_ENTRY);
    if (fitHeader->CsFlag) {
        // Calculate FIT entry checksum
        UByteArray tempFIT = model->body(fitIndex).mid(fitOffset, fitSize);
        FIT_ENTRY* tempFitHeader = (FIT_ENTRY*)tempFIT.data();
        tempFitHeader->Checksum = 0;
        UINT8 calculated = calculateChecksum8((const UINT8*)tempFitHeader, fitSize);
        if (calculated != fitHeader->Checksum) {
            msg(usprintf("%s: invalid FIT table checksum %02Xh, should be %02Xh", __FUNCTION__, fitHeader->Checksum, calculated), fitIndex);
        }
    }

    // Check fit header type
    if (fitHeader->Type != FIT_TYPE_HEADER) {
        msg(UString("Invalid FIT header type"), fitIndex);
        return U_INVALID_FIT;
    }

    // Add FIT header
    std::vector<UString> currentStrings;
    currentStrings.push_back(UString("_FIT_            "));
    currentStrings.push_back(usprintf("%08Xh", fitSize));
    currentStrings.push_back(usprintf("%04Xh", fitHeader->Version));
    currentStrings.push_back(usprintf("%02Xh", fitHeader->Checksum));
    currentStrings.push_back(fitEntryTypeToUString(fitHeader->Type));
    currentStrings.push_back(UString()); // Empty info for FIT header
    fitTable.push_back(std::pair<std::vector<UString>, UModelIndex>(currentStrings, fitIndex));

    // Process all other entries
    UModelIndex acmIndex;
    UModelIndex kmIndex;
    UModelIndex bpIndex;
    for (UINT32 i = 1; i < fitHeader->Size; i++) {
        currentStrings.clear();
        UString info;
        UModelIndex itemIndex;
        const FIT_ENTRY* currentEntry = fitHeader + i;
        UINT32 currentEntrySize = currentEntry->Size;

        // Check sanity
        if (currentEntry->Type == FIT_TYPE_HEADER) {
            msg(usprintf("%s: second FIT header found, the table is damaged", __FUNCTION__), fitIndex);
            return U_INVALID_FIT;
        }

        // Special case of version 0 entries
        if (currentEntry->Version == 0) {
            const FIT_ENTRY_VERSION_0_CONFIG_POLICY* policy = (const FIT_ENTRY_VERSION_0_CONFIG_POLICY*)currentEntry;
            info += usprintf("Index: %04Xh BitPosition: %02Xh AccessWidth: %02Xh DataRegAddr: %04Xh IndexRegAddr: %04Xh",
                policy->Index,
                policy->BitPosition,
                policy->AccessWidth,
                policy->DataRegisterAddress,
                policy->IndexRegisterAddress);
        }
        else if (currentEntry->Address > addressDiff && currentEntry->Address < 0xFFFFFFFFUL) { // Only elements in the image need to be parsed
            UINT32 currentEntryBase = (UINT32)(currentEntry->Address - addressDiff);
            itemIndex = model->findByBase(currentEntryBase);
            if (itemIndex.isValid()) {
                USTATUS status = U_INVALID_FIT;
                UByteArray item = model->header(itemIndex) + model->body(itemIndex) + model->tail(itemIndex);
                UINT32 localOffset = currentEntryBase - model->base(itemIndex);

                switch (currentEntry->Type) {
                case FIT_TYPE_MICROCODE:
                    status = parseFitEntryMicrocode(item, localOffset, itemIndex, info, currentEntrySize);
                    break;

                case FIT_TYPE_BIOS_AC_MODULE:
                    status = parseFitEntryAcm(item, localOffset, itemIndex, info, currentEntrySize);
                    acmIndex = itemIndex;
                    break;

                case FIT_TYPE_AC_KEY_MANIFEST:
                    status = parseFitEntryBootGuardKeyManifest(item, localOffset, itemIndex, info, currentEntrySize);
                    kmIndex = itemIndex;
                    break;

                case FIT_TYPE_AC_BOOT_POLICY:
                    status = parseFitEntryBootGuardBootPolicy(item, localOffset, itemIndex, info, currentEntrySize);
                    bpIndex = itemIndex;
                    break;

                default:
                    // Do nothing
                    status = U_SUCCESS;
                    break;
                }

                if (status != U_SUCCESS)
                    itemIndex = UModelIndex();
            }
            else {
                msg(usprintf("%s: FIT entry #%d not found in the image", __FUNCTION__, i), fitIndex);
            }
        }

        if (itemIndex.isValid()) {
            // Explicitly set the item referenced by FIT as fixed
            // TODO: lift this restriction after FIT builder is ready
            model->setFixed(itemIndex, true);
        }

        // Add entry to fitTable
        currentStrings.push_back(usprintf("%016" PRIX64 "h", currentEntry->Address));
        currentStrings.push_back(usprintf("%08Xh", currentEntrySize, currentEntrySize));
        currentStrings.push_back(usprintf("%04Xh", currentEntry->Version));
        currentStrings.push_back(usprintf("%02Xh", currentEntry->Checksum));
        currentStrings.push_back(fitEntryTypeToUString(currentEntry->Type));
        currentStrings.push_back(info);
        fitTable.push_back(std::pair<std::vector<UString>, UModelIndex>(currentStrings, itemIndex));
    }

    // Perform validation of BootGuard stuff
    if (bgAcmFound) {
        if (!bgKeyManifestFound) {
            msg(usprintf("%s: ACM found, but KeyManifest isn't", __FUNCTION__), acmIndex);
        }
        else if (!bgBootPolicyFound) {
            msg(usprintf("%s: ACM and KeyManifest found, BootPolicy isn't", __FUNCTION__), kmIndex);
        }
        else {
            // Check key hashes
            if (!bgKmHash.isEmpty() && bgBpHash.isEmpty() && bgKmHash != bgBpHash) {
                msg(usprintf("%s: BootPolicy key hash stored in KeyManifest differs from the hash of public key stored in BootPolicy", __FUNCTION__), bpIndex);
                return U_SUCCESS;
            }
        }
    }

    return U_SUCCESS;
}

void FfsParser::findFitRecursive(const UModelIndex & index, UModelIndex & found, UINT32 & fitOffset)
{
    // Sanity check
    if (!index.isValid()) {
        return;
    }

    // Process child items
    for (int i = 0; i < model->rowCount(index); i++) {
        findFitRecursive(index.child(i, 0), found, fitOffset);
        if (found.isValid())
            return;
    }

    // Check for all FIT signatures in item's body
    UByteArray lastVtfBody = model->body(lastVtf);
    UINT32 storedFitAddress = *(const UINT32*)(lastVtfBody.constData() + lastVtfBody.size() - FIT_POINTER_OFFSET);
    for (INT32 offset = model->body(index).indexOf(FIT_SIGNATURE);
        offset >= 0;
        offset = model->body(index).indexOf(FIT_SIGNATURE, offset + 1)) {
        // FIT candidate found, calculate it's physical address
        UINT32 fitAddress = model->base(index) + (UINT32)addressDiff + model->header(index).size() + (UINT32)offset;

        // Check FIT address to be stored in the last VTF
        if (fitAddress == storedFitAddress) {
            found = index;
            fitOffset = offset;
            msg(usprintf("%s: real FIT table found at physical address %08Xh", __FUNCTION__, fitAddress), found);
            break;
        }
        else if (model->rowCount(index) == 0) // Show messages only to leaf items
            msg(usprintf("%s: FIT table candidate found, but not referenced from the last VTF", __FUNCTION__), index);
    }
}

USTATUS FfsParser::parseFitEntryMicrocode(const UByteArray & microcode, const UINT32 localOffset, const UModelIndex & parent, UString & info, UINT32 &realSize)
{
    U_UNUSED_PARAMETER(parent);
    if ((UINT32)microcode.size() - localOffset < sizeof(INTEL_MICROCODE_HEADER)) {
        return U_INVALID_MICROCODE;
    }

    const INTEL_MICROCODE_HEADER* ucodeHeader = (const INTEL_MICROCODE_HEADER*)(microcode.constData() + localOffset);
    if (!microcodeHeaderValid(ucodeHeader)) {
        return U_INVALID_MICROCODE;
    }

    if ((UINT32)microcode.size() - localOffset < ucodeHeader->TotalSize) {
        return U_INVALID_MICROCODE;
    }

    // Valid microcode found
    info = usprintf("CpuSignature: %08Xh, Revision: %08Xh, Date: %02X.%02X.%04X",
                    ucodeHeader->ProcessorSignature,
                    ucodeHeader->UpdateRevision,
                    ucodeHeader->DateDay,
                    ucodeHeader->DateMonth,
                    ucodeHeader->DateYear);
    realSize = ucodeHeader->TotalSize;
    return U_SUCCESS;
}

USTATUS FfsParser::parseFitEntryAcm(const UByteArray & acm, const UINT32 localOffset, const UModelIndex & parent, UString & info, UINT32 &realSize)
{
    if ((UINT32)acm.size() < localOffset + sizeof(INTEL_ACM_HEADER)) {
        return U_INVALID_ACM;
    }

    const INTEL_ACM_HEADER* header = (const INTEL_ACM_HEADER*)(acm.constData() + localOffset);
    if (header->ModuleType != INTEL_ACM_MODULE_TYPE || header->ModuleVendor != INTEL_ACM_MODULE_VENDOR) {
        return U_INVALID_ACM;
    }

    UINT32 acmSize = header->ModuleSize * sizeof(UINT32);
    if ((UINT32)acm.size() < localOffset + acmSize) {
        return U_INVALID_ACM;
    }

    // Valid ACM found
    info = usprintf("LocalOffset: %08Xh, EntryPoint: %08Xh, ACM SVN: %04Xh, Date: %02X.%02X.%04X",
                    localOffset,
                    header->EntryPoint,
                    header->AcmSvn,
                    header->DateDay,
                    header->DateMonth,
                    header->DateYear
                    );
    realSize = acmSize;

    // Add ACM header info
    UString acmInfo;
    acmInfo += usprintf(" found at base %Xh\n"
                        "ModuleType: %04Xh         ModuleSubtype: %04Xh     HeaderLength: %08Xh\n"
                        "HeaderVersion: %08Xh  ChipsetId:  %04Xh        Flags: %04Xh\n"
                        "ModuleVendor: %04Xh       Date: %02X.%02X.%04X         ModuleSize: %08Xh\n"
                        "EntryPoint: %08Xh     AcmSvn: %04Xh            Unknown1: %08Xh\n"
                        "Unknown2: %08Xh       GdtBase: %08Xh       GdtMax: %08Xh\n"
                        "SegSel: %08Xh         KeySize: %08Xh       Unknown3: %08Xh",
                        model->base(parent) + localOffset,
                        header->ModuleType,
                        header->ModuleSubtype,
                        header->ModuleSize * sizeof(UINT32),
                        header->HeaderVersion,
                        header->ChipsetId,
                        header->Flags,
                        header->ModuleVendor,
                        header->DateDay, header->DateMonth, header->DateYear,
                        header->ModuleSize * sizeof(UINT32),
                        header->EntryPoint,
                        header->AcmSvn,
                        header->Unknown1,
                        header->Unknown2,
                        header->GdtBase,
                        header->GdtMax,
                        header->SegmentSel,
                        header->KeySize * sizeof(UINT32),
                        header->Unknown4 * sizeof(UINT32)
                        );
    // Add PubKey
    acmInfo += usprintf("\n\nACM RSA Public Key (Exponent: %Xh):", header->RsaPubExp);
    for (UINT16 i = 0; i < sizeof(header->RsaPubKey); i++) {
        if (i % 32 == 0)
            acmInfo += UString("\n");
        acmInfo += usprintf("%02X", header->RsaPubKey[i]);
    }
    // Add RsaSig
    acmInfo += UString("\n\nACM RSA Signature:");
    for (UINT16 i = 0; i < sizeof(header->RsaSig); i++) {
        if (i % 32 == 0)
            acmInfo += UString("\n");
        acmInfo += usprintf("%02X", header->RsaSig[i]);
    }
    acmInfo += UString("\n------------------------------------------------------------------------\n\n");

    if(header->ModuleSubtype == INTEL_ACM_MODULE_SUBTYPE_TXT_ACM)
        securityInfo += "TXT ACM" + acmInfo;
    else if(header->ModuleSubtype == INTEL_ACM_MODULE_SUBTYPE_S_ACM)
        securityInfo += "S-ACM" + acmInfo;
    else if (header->ModuleSubtype == INTEL_ACM_MODULE_SUBTYPE_BOOTGUARD)
        securityInfo += "BootGuard ACM" + acmInfo;
    else
        securityInfo += "Intel ACM" + acmInfo;

    bgAcmFound = true;
    return U_SUCCESS;
}

USTATUS FfsParser::parseFitEntryBootGuardKeyManifest(const UByteArray & keyManifest, const UINT32 localOffset, const UModelIndex & parent, UString & info, UINT32 &realSize)
{
    U_UNUSED_PARAMETER(realSize);
    if ((UINT32)keyManifest.size() < localOffset + sizeof(BG_KEY_MANIFEST)) {
        return U_INVALID_BG_KEY_MANIFEST;
    }

    const BG_KEY_MANIFEST* header = (const BG_KEY_MANIFEST*)(keyManifest.constData() + localOffset);
    if (header->Tag != BG_KEY_MANIFEST_TAG) {
        return U_INVALID_BG_KEY_MANIFEST;
    }

    // Valid KM found
    info = usprintf("LocalOffset: %08Xh, KM Version: %02Xh, KM SVN: %02Xh, KM ID: %02Xh",
                    localOffset,
                    header->KmVersion,
                    header->KmSvn,
                    header->KmId
                    );

    // Add KM header info
    securityInfo += usprintf(
                              "Intel BootGuard Key manifest found at base %Xh\n"
                              "Tag: __KEYM__ Version: %02Xh KmVersion: %02Xh KmSvn: %02Xh KmId: %02Xh",
                              model->base(parent) + localOffset,
                              header->Version,
                              header->KmVersion,
                              header->KmSvn,
                              header->KmId
                              );

    // Add hash of Key Manifest PubKey, this hash will be written to FPFs
    UINT8 hash[SHA256_DIGEST_SIZE];
    sha256(&header->KeyManifestSignature.PubKey.Modulus, sizeof(header->KeyManifestSignature.PubKey.Modulus), hash);
    securityInfo += UString("\n\nKey Manifest RSA Public Key Hash:\n");
    for (UINT8 i = 0; i < sizeof(hash); i++) {
        securityInfo += usprintf("%02X", hash[i]);
    }

    // Add BpKeyHash
    securityInfo += UString("\n\nBoot Policy RSA Public Key Hash:\n");
    for (UINT8 i = 0; i < sizeof(header->BpKeyHash.HashBuffer); i++) {
        securityInfo += usprintf("%02X", header->BpKeyHash.HashBuffer[i]);
    }
    bgKmHash = UByteArray((const char*)header->BpKeyHash.HashBuffer, sizeof(header->BpKeyHash.HashBuffer));

    // Add Key Manifest PubKey
    securityInfo += usprintf("\n\nKey Manifest RSA Public Key (Exponent: %Xh):",
                              header->KeyManifestSignature.PubKey.Exponent);
    for (UINT16 i = 0; i < sizeof(header->KeyManifestSignature.PubKey.Modulus); i++) {
        if (i % 32 == 0)
            securityInfo += UString("\n");
        securityInfo += usprintf("%02X", header->KeyManifestSignature.PubKey.Modulus[i]);
    }
    // Add Key Manifest Signature
    securityInfo += UString("\n\nKey Manifest RSA Signature:");
    for (UINT16 i = 0; i < sizeof(header->KeyManifestSignature.Signature.Signature); i++) {
        if (i % 32 == 0)
            securityInfo += UString("\n");
        securityInfo += usprintf("%02X", header->KeyManifestSignature.Signature.Signature[i]);
    }
    securityInfo += UString("\n------------------------------------------------------------------------\n\n");
    bgKeyManifestFound = true;
    return U_SUCCESS;
}

USTATUS FfsParser::findNextBootGuardBootPolicyElement(const UByteArray & bootPolicy, const UINT32 elementOffset, UINT32 & nextElementOffset, UINT32 & nextElementSize)
{
    UINT32 dataSize = bootPolicy.size();
    if (dataSize < sizeof(UINT64)) {
        return U_ELEMENTS_NOT_FOUND;
    }

    UINT32 offset = elementOffset;
    for (; offset < dataSize - sizeof(UINT64); offset++) {
        const UINT64* currentPos = (const UINT64*)(bootPolicy.constData() + offset);
        if (*currentPos == BG_BOOT_POLICY_MANIFEST_IBB_ELEMENT_TAG && offset + sizeof(BG_IBB_ELEMENT) < dataSize) {
            const BG_IBB_ELEMENT* header = (const BG_IBB_ELEMENT*)currentPos;
            // Check that all segments are present
            if (offset + sizeof(BG_IBB_ELEMENT) + sizeof(BG_IBB_SEGMENT_ELEMENT) * header->IbbSegCount < dataSize) {
                nextElementOffset = offset;
                nextElementSize = sizeof(BG_IBB_ELEMENT) + sizeof(BG_IBB_SEGMENT_ELEMENT) * header->IbbSegCount;
                return U_SUCCESS;
            }
        }
        else if (*currentPos == BG_BOOT_POLICY_MANIFEST_PLATFORM_MANUFACTURER_ELEMENT_TAG && offset + sizeof(BG_PLATFORM_MANUFACTURER_ELEMENT) < dataSize) {
            const BG_PLATFORM_MANUFACTURER_ELEMENT* header = (const BG_PLATFORM_MANUFACTURER_ELEMENT*)currentPos;
            // Check that data is present
            if (offset + sizeof(BG_PLATFORM_MANUFACTURER_ELEMENT) + header->DataSize < dataSize) {
                nextElementOffset = offset;
                nextElementSize = sizeof(BG_PLATFORM_MANUFACTURER_ELEMENT) + header->DataSize;
                return U_SUCCESS;
            }
        }
        else if (*currentPos == BG_BOOT_POLICY_MANIFEST_SIGNATURE_ELEMENT_TAG && offset + sizeof(BG_BOOT_POLICY_MANIFEST_SIGNATURE_ELEMENT) < dataSize) {
            nextElementOffset = offset;
            nextElementSize = sizeof(BG_BOOT_POLICY_MANIFEST_SIGNATURE_ELEMENT);
            return U_SUCCESS;
        }
    }

    return U_ELEMENTS_NOT_FOUND;
}

USTATUS FfsParser::parseFitEntryBootGuardBootPolicy(const UByteArray & bootPolicy, const UINT32 localOffset, const UModelIndex & parent, UString & info, UINT32 &realSize)
{
    U_UNUSED_PARAMETER(realSize);
    if ((UINT32)bootPolicy.size() < localOffset + sizeof(BG_BOOT_POLICY_MANIFEST_HEADER)) {
        return U_INVALID_BG_BOOT_POLICY;
    }

    const BG_BOOT_POLICY_MANIFEST_HEADER* header = (const BG_BOOT_POLICY_MANIFEST_HEADER*)(bootPolicy.constData() + localOffset);
    if (header->Tag != BG_BOOT_POLICY_MANIFEST_HEADER_TAG) {
        return U_INVALID_BG_BOOT_POLICY;
    }

    UINT32 bmSize = sizeof(BG_BOOT_POLICY_MANIFEST_HEADER);
    if ((UINT32)bootPolicy.size() < localOffset + bmSize) {
        return U_INVALID_BG_BOOT_POLICY;
    }

    // Valid BPM found
    info = usprintf("LocalOffset: %08Xh, BP SVN: %02Xh, ACM SVN: %02Xh",
                    localOffset,
                    header->BPSVN,
                    header->ACMSVN
                    );

    // Add BP header info
    securityInfo += usprintf(
                              "Intel BootGuard Boot Policy Manifest found at base %Xh\n"
                              "Tag: __ACBP__ Version: %02Xh HeaderVersion: %02Xh\n"
                              "PMBPMVersion: %02Xh PBSVN: %02Xh ACMSVN: %02Xh NEMDataStack: %04Xh\n",
                              model->base(parent) + localOffset,
                              header->Version,
                              header->HeaderVersion,
                              header->PMBPMVersion,
                              header->BPSVN,
                              header->ACMSVN,
                              header->NEMDataSize
                              );

    // Iterate over elements to get them all
    UINT32 elementOffset = 0;
    UINT32 elementSize = 0;
    USTATUS status = findNextBootGuardBootPolicyElement(bootPolicy, localOffset + sizeof(BG_BOOT_POLICY_MANIFEST_HEADER), elementOffset, elementSize);
    while (status == U_SUCCESS) {
        const UINT64* currentPos = (const UINT64*)(bootPolicy.constData() + elementOffset);
        if (*currentPos == BG_BOOT_POLICY_MANIFEST_IBB_ELEMENT_TAG) {
            const BG_IBB_ELEMENT* elementHeader = (const BG_IBB_ELEMENT*)currentPos;
            // Valid IBB element found
            securityInfo += usprintf(
                                      "\nInitial Boot Block Element found at base %Xh\n"
                                      "Tag: __IBBS__       Version: %02Xh         Unknown: %02Xh\n"
                                      "Flags: %08Xh    IbbMchBar: %08Xh VtdBar: %08Xh\n"
                                      "PmrlBase: %08Xh PmrlLimit: %08Xh  EntryPoint: %08Xh",
                                      model->base(parent) + localOffset + elementOffset,
                                      elementHeader->Version,
                                      elementHeader->Unknown,
                                      elementHeader->Flags,
                                      elementHeader->IbbMchBar,
                                      elementHeader->VtdBar,
                                      elementHeader->PmrlBase,
                                      elementHeader->PmrlLimit,
                                      elementHeader->EntryPoint
                                      );

            // Add PostIbbHash
            securityInfo += UString("\n\nPost IBB Hash:\n");
            for (UINT8 i = 0; i < sizeof(elementHeader->IbbHash.HashBuffer); i++) {
                securityInfo += usprintf("%02X", elementHeader->IbbHash.HashBuffer[i]);
            }

            // Check for non-empry PostIbbHash
            UByteArray postIbbHash((const char*)elementHeader->IbbHash.HashBuffer, sizeof(elementHeader->IbbHash.HashBuffer));
            if (postIbbHash.count('\x00') != postIbbHash.size() && postIbbHash.count('\xFF') != postIbbHash.size()) {
                BG_PROTECTED_RANGE range;
                range.Type = BG_PROTECTED_RANGE_INTEL_BOOT_GUARD_POST_IBB;
                range.Hash = postIbbHash;
                bgProtectedRanges.push_back(range);
            }

            // Add Digest
            bgBpDigest = UByteArray((const char*)elementHeader->Digest.HashBuffer, sizeof(elementHeader->Digest.HashBuffer));
            securityInfo += UString("\n\nIBB Digest:\n");
            for (UINT8 i = 0; i < (UINT8)bgBpDigest.size(); i++) {
                securityInfo += usprintf("%02X", (UINT8)bgBpDigest.at(i));
            }

            // Add all IBB segments
            securityInfo += UString("\n\nIBB Segments:\n");
            const BG_IBB_SEGMENT_ELEMENT* segments = (const BG_IBB_SEGMENT_ELEMENT*)(elementHeader + 1);
            for (UINT8 i = 0; i < elementHeader->IbbSegCount; i++) {
                securityInfo += usprintf("Flags: %04Xh Address: %08Xh Size: %08Xh\n",
                                          segments[i].Flags, segments[i].Base, segments[i].Size);
                if (segments[i].Flags == BG_IBB_SEGMENT_FLAG_IBB) {
                    BG_PROTECTED_RANGE range;
                    range.Offset = segments[i].Base;
                    range.Size = segments[i].Size;
                    range.Type = BG_PROTECTED_RANGE_INTEL_BOOT_GUARD_IBB;
                    bgProtectedRanges.push_back(range);
                }
            }
        }
        else if (*currentPos == BG_BOOT_POLICY_MANIFEST_PLATFORM_MANUFACTURER_ELEMENT_TAG) {
            const BG_PLATFORM_MANUFACTURER_ELEMENT* elementHeader = (const BG_PLATFORM_MANUFACTURER_ELEMENT*)currentPos;
            securityInfo += usprintf(
                                      "\nPlatform Manufacturer Data Element found at base %Xh\n"
                                      "Tag: __PMDA__ Version: %02Xh DataSize: %02Xh",
                                      model->base(parent) + localOffset + elementOffset,
                                      elementHeader->Version,
                                      elementHeader->DataSize
                                      );
            // Check for Microsoft PMDA hash data
            const BG_MICROSOFT_PMDA_HEADER* pmdaHeader = (const BG_MICROSOFT_PMDA_HEADER*)(elementHeader + 1);
            if (pmdaHeader->Version == BG_MICROSOFT_PMDA_VERSION
                && elementHeader->DataSize == sizeof(BG_MICROSOFT_PMDA_HEADER) + sizeof(BG_MICROSOFT_PMDA_ENTRY)*pmdaHeader->NumEntries) {
                // Add entries
                securityInfo += UString("\nMicrosoft PMDA-based protected ranges:\n");
                const BG_MICROSOFT_PMDA_ENTRY* entries = (const BG_MICROSOFT_PMDA_ENTRY*)(pmdaHeader + 1);
                for (UINT32 i = 0; i < pmdaHeader->NumEntries; i++) {

                    securityInfo += usprintf("Address: %08Xh Size: %08Xh\n", entries[i].Address, entries[i].Size);
                    securityInfo += UString("Hash: ");
                    for (UINT8 j = 0; j < sizeof(entries[i].Hash); j++) {
                        securityInfo += usprintf("%02X", entries[i].Hash[j]);
                    }
                    securityInfo += UString("\n");

                    BG_PROTECTED_RANGE range;
                    range.Offset = entries[i].Address;
                    range.Size = entries[i].Size;
                    range.Hash = UByteArray((const char*)entries[i].Hash, sizeof(entries[i].Hash));
                    range.Type = BG_PROTECTED_RANGE_VENDOR_HASH_MICROSOFT;
                    bgProtectedRanges.push_back(range);
                }
            }
            else {
                // Add raw data
                const UINT8* data = (const UINT8*)(elementHeader + 1);
                for (UINT16 i = 0; i < elementHeader->DataSize; i++) {
                    if (i % 32 == 0)
                        securityInfo += UString("\n");
                    securityInfo += usprintf("%02X", data[i]);
                }
                securityInfo += UString("\n");
            }
        }
        else if (*currentPos == BG_BOOT_POLICY_MANIFEST_SIGNATURE_ELEMENT_TAG) {
            const BG_BOOT_POLICY_MANIFEST_SIGNATURE_ELEMENT* elementHeader = (const BG_BOOT_POLICY_MANIFEST_SIGNATURE_ELEMENT*)currentPos;
            securityInfo += usprintf(
                                      "\nBoot Policy Signature Element found at base %Xh\n"
                                      "Tag: __PMSG__ Version: %02Xh",
                                      model->base(parent) + localOffset + elementOffset,
                                      elementHeader->Version
                                      );

            // Add PubKey
            securityInfo += usprintf("\n\nBoot Policy RSA Public Key (Exponent: %Xh):", elementHeader->KeySignature.PubKey.Exponent);
            for (UINT16 i = 0; i < sizeof(elementHeader->KeySignature.PubKey.Modulus); i++) {
                if (i % 32 == 0)
                    securityInfo += UString("\n");
                securityInfo += usprintf("%02X", elementHeader->KeySignature.PubKey.Modulus[i]);
            }

            // Calculate and add PubKey hash
            UINT8 hash[SHA256_DIGEST_SIZE];
            sha256(&elementHeader->KeySignature.PubKey.Modulus, sizeof(elementHeader->KeySignature.PubKey.Modulus), hash);
            securityInfo += UString("\n\nBoot Policy RSA Public Key Hash:");
            for (UINT8 i = 0; i < sizeof(hash); i++) {
                if (i % 32 == 0)
                    securityInfo += UString("\n");
                securityInfo += usprintf("%02X", hash[i]);
            }
            bgBpHash = UByteArray((const char*)hash, sizeof(hash));

            // Add Signature
            securityInfo += UString("\n\nBoot Policy RSA Signature:");
            for (UINT16 i = 0; i < sizeof(elementHeader->KeySignature.Signature.Signature); i++) {
                if (i % 32 == 0)
                    securityInfo += UString("\n");
                securityInfo += usprintf("%02X", elementHeader->KeySignature.Signature.Signature[i]);
            }
        }
        status = findNextBootGuardBootPolicyElement(bootPolicy, elementOffset + elementSize, elementOffset, elementSize);
    }

    securityInfo += UString("\n------------------------------------------------------------------------\n\n");
    bgBootPolicyFound = true;
    return U_SUCCESS;
}
#endif

USTATUS FfsParser::parseMicrocodeVolumeBody(const UModelIndex & index)
{
    const UINT32 headerSize = (UINT32)model->header(index).size();
    const UINT32 bodySize = (UINT32)model->body(index).size();
    UINT32 offset = 0;
    USTATUS result = U_SUCCESS;

    while(true) {
        // Parse current microcode
        UModelIndex currentMicrocode;
        UByteArray ucode = model->body(index).mid(offset);

        // Check for empty area
        if (ucode.size() == ucode.count('\xFF') || ucode.size() == ucode.count('\x00')) {
            result = U_INVALID_MICROCODE;
        }
        else {
            result = parseIntelMicrocodeHeader(ucode, headerSize + offset, index, currentMicrocode);
        }

        // Add the rest as padding
        if (result) {
            if (offset < bodySize) {
                // Get info
                UString name = UString("Padding");
                UString info = usprintf("Full size: %Xh (%u)", ucode.size(), ucode.size());

                // Add tree item
                model->addItem(headerSize + offset, Types::Padding, getPaddingType(ucode), name, UString(), info, UByteArray(), ucode, UByteArray(), Fixed, index);
            }
            return U_SUCCESS;
        }

        // Get to next candidate
        offset += model->header(currentMicrocode).size() + model->body(currentMicrocode).size() + model->tail(currentMicrocode).size();
        if (offset >= bodySize)
            break;
    }
    return U_SUCCESS;
}

USTATUS FfsParser::parseIntelMicrocodeHeader(const UByteArray & microcode, const UINT32 localOffset, const UModelIndex & parent, UModelIndex & index)
{
    // We have enough data to fit the header
    if ((UINT32)microcode.size() <  sizeof(INTEL_MICROCODE_HEADER)) {
        return U_INVALID_MICROCODE;
    }

    const INTEL_MICROCODE_HEADER* ucodeHeader = (const INTEL_MICROCODE_HEADER*)microcode.constData();

    if (!microcodeHeaderValid(ucodeHeader)) {
        return U_INVALID_MICROCODE;
    }

    // We have enough data to fit the whole TotalSize
    if ((UINT32)microcode.size() < ucodeHeader->TotalSize) {
        return U_INVALID_MICROCODE;
    }

    // Valid microcode found
    UINT32 dataSize = ucodeHeader->DataSize;
    if (dataSize == 0) {
        dataSize = INTEL_MICROCODE_REAL_DATA_SIZE_ON_ZERO;
    }

    // Cross check DataSize and TotalSize
    if (ucodeHeader->TotalSize < sizeof(INTEL_MICROCODE_HEADER) + dataSize) {
        return U_INVALID_MICROCODE;
    }

    // Recalculate the whole microcode checksum
    UByteArray tempMicrocode = microcode;
    INTEL_MICROCODE_HEADER* tempUcodeHeader = (INTEL_MICROCODE_HEADER*)(tempMicrocode.data());
    tempUcodeHeader->Checksum = 0;
    UINT32 calculated = calculateChecksum32((const UINT32*)tempMicrocode.constData(), tempUcodeHeader->TotalSize);
    bool msgInvalidChecksum = (ucodeHeader->Checksum != calculated);

    // Construct header, body and tail
    UByteArray header = microcode.left(sizeof(INTEL_MICROCODE_HEADER));
    UByteArray body = microcode.mid(sizeof(INTEL_MICROCODE_HEADER), dataSize);
    UByteArray tail;

    // Check if the tail is present
    if (ucodeHeader->TotalSize > sizeof(INTEL_MICROCODE_HEADER) + dataSize) {
        tail = microcode.mid(sizeof(INTEL_MICROCODE_HEADER) + dataSize, ucodeHeader->TotalSize - (sizeof(INTEL_MICROCODE_HEADER) + dataSize));
    }

    // Check if we have extended header in the tail
    UString extendedHeaderInfo;
    bool msgUnknownOrDamagedMicrocodeTail = false;
    if ((UINT32)tail.size() >= sizeof(INTEL_MICROCODE_EXTENDED_HEADER)) {
        const INTEL_MICROCODE_EXTENDED_HEADER* extendedHeader = (const INTEL_MICROCODE_EXTENDED_HEADER*)tail.constData();

        // Reserved bytes are all zeroes
        bool extendedReservedBytesValid = true;
        for (UINT8 i = 0; i < sizeof(extendedHeader->Reserved); i++) {
            if (extendedHeader->Reserved[i] != 0x00) {
                extendedReservedBytesValid = false;
                break;
            }
        }

        // We have more than 0 entries and they are all in the tail
        if (extendedReservedBytesValid
            && extendedHeader->EntryCount > 0
            && (UINT32)tail.size() == sizeof(INTEL_MICROCODE_EXTENDED_HEADER) + extendedHeader->EntryCount * sizeof(INTEL_MICROCODE_EXTENDED_HEADER_ENTRY)) {
            // Recalculate extended header checksum
            INTEL_MICROCODE_EXTENDED_HEADER* tempExtendedHeader = (INTEL_MICROCODE_EXTENDED_HEADER*)(tempMicrocode.data() + sizeof(INTEL_MICROCODE_HEADER) + dataSize);
            tempExtendedHeader->Checksum = 0;
            UINT32 extendedCalculated = calculateChecksum32((const UINT32*)tempExtendedHeader, sizeof(INTEL_MICROCODE_EXTENDED_HEADER) + extendedHeader->EntryCount * sizeof(INTEL_MICROCODE_EXTENDED_HEADER_ENTRY));

            extendedHeaderInfo = usprintf("\nExtended header entries: %u\nExtended header checksum: %08Xh, ",
                                          extendedHeader->EntryCount,
                                          extendedHeader->Checksum)
                               + (extendedHeader->Checksum == extendedCalculated ? UString("valid") : usprintf("invalid, should be %08Xh", extendedCalculated));

            const INTEL_MICROCODE_EXTENDED_HEADER_ENTRY* firstEntry = (const INTEL_MICROCODE_EXTENDED_HEADER_ENTRY*)(extendedHeader + 1);
            for (UINT8 i = 0; i < extendedHeader->EntryCount; i++) {
                const INTEL_MICROCODE_EXTENDED_HEADER_ENTRY* entry = (const INTEL_MICROCODE_EXTENDED_HEADER_ENTRY*)(firstEntry + i);

                // Recalculate checksum after patching
                tempUcodeHeader->Checksum = 0;
                tempUcodeHeader->ProcessorFlags = entry->ProcessorFlags;
                tempUcodeHeader->ProcessorSignature = entry->ProcessorSignature;
                UINT32 entryCalculated = calculateChecksum32((const UINT32*)tempMicrocode.constData(), sizeof(INTEL_MICROCODE_HEADER) + dataSize);

                extendedHeaderInfo += usprintf("\nCPU signature #%u: %08Xh\nCPU flags #%u: %02Xh\nChecksum #%u: %08Xh, ",
                                               i + 1, entry->ProcessorSignature,
                                               i + 1, entry->ProcessorFlags,
                                               i + 1, entry->Checksum)
                                    + (entry->Checksum == entryCalculated ? UString("valid") : usprintf("invalid, should be %08Xh", entryCalculated));
            }
        }
        else {
            msgUnknownOrDamagedMicrocodeTail = true;
        }
    }
    else if (tail.size() != 0) {
        msgUnknownOrDamagedMicrocodeTail = true;
    }

    // Get microcode binary
    UByteArray microcodeBinary = microcode.left(ucodeHeader->TotalSize);

    // Add info
    UString name("Intel microcode");
    UString info = usprintf("Full size: %Xh (%u)\nHeader size: 0h (0u)\nBody size: %Xh (%u)\nTail size: 0h (0u)\n"
                            "Date: %02X.%02X.%04x\nCPU signature: %08Xh\nRevision: %08Xh\nCPU flags: %02Xh\nChecksum: %08Xh, ",
                            microcodeBinary.size(), microcodeBinary.size(),
                            microcodeBinary.size(), microcodeBinary.size(),
                            ucodeHeader->DateDay,
                            ucodeHeader->DateMonth,
                            ucodeHeader->DateYear,
                            ucodeHeader->ProcessorSignature,
                            ucodeHeader->UpdateRevision,
                            ucodeHeader->ProcessorFlags,
                            ucodeHeader->Checksum)
                 + (ucodeHeader->Checksum == calculated ? UString("valid") : usprintf("invalid, should be %08Xh", calculated))
                 + extendedHeaderInfo;

    // Add tree item
    index = model->addItem(localOffset, Types::Microcode, Subtypes::IntelMicrocode, name, UString(), info, UByteArray(), microcodeBinary, UByteArray(), Fixed, parent);
    if (msgInvalidChecksum)
        msg(usprintf("%s: invalid microcode checksum %08Xh, should be %08Xh", __FUNCTION__, ucodeHeader->Checksum, calculated), index);
    if (msgUnknownOrDamagedMicrocodeTail)
        msg(usprintf("%s: extended header of size %Xh (%u) found, but it's damaged or has unknown format", __FUNCTION__, tail.size(), tail.size()), index);

    // No need to parse the body further for now
    return U_SUCCESS;
}

USTATUS FfsParser::parseBpdtRegion(const UByteArray & region, const UINT32 localOffset, const UINT32 sbpdtOffsetFixup, const UModelIndex & parent, UModelIndex & index)
{
    UINT32 regionSize = (UINT32)region.size();

    // Check region size
    if (regionSize < sizeof(BPDT_HEADER)) {
        msg(usprintf("%s: BPDT region too small to fit BPDT partition table header", __FUNCTION__), parent);
        return U_INVALID_ME_PARTITION_TABLE;
    }

    // Populate partition table header
    const BPDT_HEADER* ptHeader = (const BPDT_HEADER*)(region.constData());

    // Check region size again
    UINT32 ptBodySize = ptHeader->NumEntries * sizeof(BPDT_ENTRY);
    UINT32 ptSize = sizeof(BPDT_HEADER) + ptBodySize;
    if (regionSize < ptSize) {
        msg(usprintf("%s: BPDT region too small to fit BPDT partition table", __FUNCTION__), parent);
        return U_INVALID_ME_PARTITION_TABLE;
    }

    // Get info
    UByteArray header = region.left(sizeof(BPDT_HEADER));
    UByteArray body = region.mid(sizeof(BPDT_HEADER), ptBodySize);

    UString name = UString("BPDT partition table");
    UString info = usprintf("Full size: %Xh (%u)\nHeader size: %Xh (%u)\nBody size: %Xh (%u)\nNumber of entries: %u\nVersion: %2Xh\n"
                            "IFWI version: %Xh\nFITC version: %u.%u.%u.%u",
                            ptSize, ptSize,
                            header.size(), header.size(),
                            ptBodySize, ptBodySize,
                            ptHeader->NumEntries,
                            ptHeader->HeaderVersion,
                            ptHeader->IfwiVersion,
                            ptHeader->FitcMajor, ptHeader->FitcMinor, ptHeader->FitcHotfix, ptHeader->FitcBuild);

    // Add tree item
    index = model->addItem(localOffset, Types::BpdtStore, 0, name, UString(), info, header, body, UByteArray(), Fixed, parent);

    // Adjust offset
    UINT32 offset = sizeof(BPDT_HEADER);

    // Add partition table entries
    std::vector<BPDT_PARTITION_INFO> partitions;
    const BPDT_ENTRY* firstPtEntry = (const BPDT_ENTRY*)((const UINT8*)ptHeader + sizeof(BPDT_HEADER));
    for (UINT16 i = 0; i < ptHeader->NumEntries; i++) {
        // Populate entry header
        const BPDT_ENTRY* ptEntry = firstPtEntry + i;

        // Get info
        name = bpdtEntryTypeToUString(ptEntry->Type);
        info = usprintf("Full size: %Xh (%u)\nType: %Xh\nPartition offset: %Xh\nPartition length: %Xh",
                        sizeof(BPDT_ENTRY), sizeof(BPDT_ENTRY),
                        ptEntry->Type,
                        ptEntry->Offset,
                        ptEntry->Size) +
        UString("\nSplit sub-partition first part: ") + (ptEntry->SplitSubPartitionFirstPart ? "Yes" : "No") +
        UString("\nSplit sub-partition second part: ") + (ptEntry->SplitSubPartitionSecondPart ? "Yes" : "No") +
        UString("\nCode sub-partition: ") + (ptEntry->CodeSubPartition ? "Yes" : "No") +
        UString("\nUMA cachable: ") + (ptEntry->UmaCachable ? "Yes" : "No");

        // Add tree item
        UModelIndex entryIndex = model->addItem(localOffset + offset, Types::BpdtEntry, 0, name, UString(), info, UByteArray(), UByteArray((const char*)ptEntry, sizeof(BPDT_ENTRY)), UByteArray(), Fixed, index);

        // Adjust offset
        offset += sizeof(BPDT_ENTRY);

        if (ptEntry->Offset != 0 && ptEntry->Offset != 0xFFFFFFFF && ptEntry->Size != 0) {
            // Add to partitions vector
            BPDT_PARTITION_INFO partition;
            partition.type = Types::BpdtPartition;
            partition.ptEntry = *ptEntry;
            partition.ptEntry.Offset -= sbpdtOffsetFixup;
            partition.index = entryIndex;
            partitions.push_back(partition);
        }
    }

    // Add padding if there's no partions to add
    if (partitions.size() == 0) {
        UByteArray partition = region.mid(ptSize);

        // Get info
        name = UString("Padding");
        info = usprintf("Full size: %Xh (%u)",
                        partition.size(), partition.size());

        // Add tree item
        model->addItem(localOffset + ptSize, Types::Padding, getPaddingType(partition), name, UString(), info, UByteArray(), partition, UByteArray(), Fixed, parent);
        return U_SUCCESS;
    }

make_partition_table_consistent:
    // Sort partitions by offset
    std::sort(partitions.begin(), partitions.end());

    // Check for intersections and paddings between partitions
    BPDT_PARTITION_INFO padding;

    // Check intersection with the partition table header
    if (partitions.front().ptEntry.Offset < ptSize) {
        msg(usprintf("%s: BPDT partition has intersection with BPDT partition table, skipped", __FUNCTION__),
            partitions.front().index);
        partitions.erase(partitions.begin());
        goto make_partition_table_consistent;
    }
    // Check for padding between partition table and the first partition
    else if (partitions.front().ptEntry.Offset > ptSize) {
        padding.ptEntry.Offset = ptSize;
        padding.ptEntry.Size = partitions.front().ptEntry.Offset - padding.ptEntry.Offset;
        padding.type = Types::Padding;
        partitions.insert(partitions.begin(), padding);
    }
    // Check for intersections/paddings between partitions
    for (size_t i = 1; i < partitions.size(); i++) {
        UINT32 previousPartitionEnd = partitions[i - 1].ptEntry.Offset + partitions[i - 1].ptEntry.Size;

        // Check that partition is fully present in the image
        if ((UINT64)partitions[i].ptEntry.Offset + (UINT64)partitions[i].ptEntry.Size > regionSize) {
            if ((UINT64)partitions[i].ptEntry.Offset >= (UINT64)region.size()) {
                msg(usprintf("%s: BPDT partition is located outside of the opened image, skipped", __FUNCTION__), partitions[i].index);
                partitions.erase(partitions.begin() + i);
                goto make_partition_table_consistent;
            }
            else {
                msg(usprintf("%s: BPDT partition can't fit into it's region, truncated", __FUNCTION__), partitions[i].index);
                partitions[i].ptEntry.Size = regionSize - (UINT32)partitions[i].ptEntry.Offset;
            }
        }

        // Check for intersection with previous partition
        if (partitions[i].ptEntry.Offset < previousPartitionEnd) {
            // Check if current partition is located inside previous one
            if (partitions[i].ptEntry.Offset + partitions[i].ptEntry.Size <= previousPartitionEnd) {
                msg(usprintf("%s: BPDT partition is located inside another BPDT partition, skipped", __FUNCTION__),
                    partitions[i].index);
                partitions.erase(partitions.begin() + i);
                goto make_partition_table_consistent;
            }
            else {
                msg(usprintf("%s: BPDT partition intersects with prevous one, skipped", __FUNCTION__),
                    partitions[i].index);
                partitions.erase(partitions.begin() + i);
                goto make_partition_table_consistent;
            }
        }

        // Check for padding between current and previous partitions
        else if (partitions[i].ptEntry.Offset > previousPartitionEnd) {
            padding.ptEntry.Offset = previousPartitionEnd;
            padding.ptEntry.Size = partitions[i].ptEntry.Offset - previousPartitionEnd;
            padding.type = Types::Padding;
            std::vector<BPDT_PARTITION_INFO>::iterator iter = partitions.begin();
            std::advance(iter, i);
            partitions.insert(iter, padding);
        }
    }

    // Partition map is consistent
    for (size_t i = 0; i < partitions.size(); i++) {
        if (partitions[i].type == Types::BpdtPartition) {
            // Get info
            UString name = bpdtEntryTypeToUString(partitions[i].ptEntry.Type);
            UByteArray partition = region.mid(partitions[i].ptEntry.Offset, partitions[i].ptEntry.Size);
            UByteArray signature = partition.left(sizeof(UINT32));

            UString info = usprintf("Full size: %Xh (%u)\nType: %Xh",
                                    partition.size(), partition.size(),
                                    partitions[i].ptEntry.Type) +
            UString("\nSplit sub-partition first part: ") + (partitions[i].ptEntry.SplitSubPartitionFirstPart ? "Yes" : "No") +
            UString("\nSplit sub-partition second part: ") + (partitions[i].ptEntry.SplitSubPartitionSecondPart ? "Yes" : "No") +
            UString("\nCode sub-partition: ") + (partitions[i].ptEntry.CodeSubPartition ? "Yes" : "No") +
            UString("\nUMA cachable: ") + (partitions[i].ptEntry.UmaCachable ? "Yes" : "No");

            UString text = bpdtEntryTypeToUString(partitions[i].ptEntry.Type);

            // Add tree item
            UModelIndex partitionIndex = model->addItem(localOffset + partitions[i].ptEntry.Offset, Types::BpdtPartition, 0, name, text, info, UByteArray(), partition, UByteArray(), Fixed, parent);

            // Special case of S-BPDT
            if (partitions[i].ptEntry.Type == BPDT_ENTRY_TYPE_SBPDT) {
                UModelIndex sbpdtIndex;
                parseBpdtRegion(partition, 0, partitions[i].ptEntry.Offset, partitionIndex, sbpdtIndex); // Third parameter is a fixup for S-BPDT offset entries, because they are calculated from the start of BIOS region
            }

            // Parse code partitions
            if (readUnaligned((const UINT32*)partition.constData()) == CPD_SIGNATURE) {
                // Parse code partition contents
                UModelIndex cpdIndex;
                parseCpdRegion(partition, localOffset, partitionIndex, cpdIndex);
            }

            if (partitions[i].ptEntry.Type > BPDT_LAST_KNOWN_ENTRY_TYPE) {
                msg(usprintf("%s: BPDT entry of unknown type found", __FUNCTION__), partitionIndex);
            }
        }
        else if (partitions[i].type == Types::Padding) {
            UByteArray partition = region.mid(partitions[i].ptEntry.Offset, partitions[i].ptEntry.Size);

            // Get info
            name = UString("Padding");
            info = usprintf("Full size: %Xh (%u)",
                            partition.size(), partition.size());

            // Add tree item
            model->addItem(localOffset + partitions[i].ptEntry.Offset, Types::Padding, getPaddingType(partition), name, UString(), info, UByteArray(), partition, UByteArray(), Fixed, parent);
        }
    }

    // Add padding after the last region
    if ((UINT64)partitions.back().ptEntry.Offset + (UINT64)partitions.back().ptEntry.Size < regionSize) {
        UByteArray partition = region.mid(partitions.back().ptEntry.Offset + partitions.back().ptEntry.Size, regionSize - padding.ptEntry.Offset);

        // Get info
        name = UString("Padding");
        info = usprintf("Full size: %Xh (%u)",
                        partition.size(), partition.size());

        // Add tree item
        model->addItem(localOffset + partitions.back().ptEntry.Offset + partitions.back().ptEntry.Size, Types::Padding, getPaddingType(partition), name, UString(), info, UByteArray(), partition, UByteArray(), Fixed, parent);
    }

    return U_SUCCESS;
}

USTATUS FfsParser::parseCpdRegion(const UByteArray & region, const UINT32 localOffset, const UModelIndex & parent, UModelIndex & index)
{
    // Check directory size
    if ((UINT32)region.size() < sizeof(CPD_REV1_HEADER)) {
        msg(usprintf("%s: CPD too small to fit rev1 partition table header", __FUNCTION__), parent);
        return U_INVALID_ME_PARTITION_TABLE;
    }

    // Populate partition table header
    const CPD_REV1_HEADER* cpdHeader = (const CPD_REV1_HEADER*)region.constData();

    // Check header version to be known
    UINT32 ptHeaderSize = 0;
    if (cpdHeader->HeaderVersion == 2) {
        if ((UINT32)region.size() < sizeof(CPD_REV2_HEADER)) {
            msg(usprintf("%s: CPD too small to fit rev2 partition table header", __FUNCTION__), parent);
            return U_INVALID_ME_PARTITION_TABLE;
        }

        ptHeaderSize = sizeof(CPD_REV2_HEADER);
    }
    else if (cpdHeader->HeaderVersion == 1) {
        ptHeaderSize = sizeof(CPD_REV1_HEADER);
    }

    // Check directory size again
    UINT32 ptBodySize = cpdHeader->NumEntries * sizeof(CPD_ENTRY);
    UINT32 ptSize = ptHeaderSize + ptBodySize;
    if ((UINT32)region.size() < ptSize) {
        msg(usprintf("%s: CPD too small to fit the whole partition table", __FUNCTION__), parent);
        return U_INVALID_ME_PARTITION_TABLE;
    }

    // Get info
    UByteArray header = region.left(ptHeaderSize);
    UByteArray body = region.mid(ptHeaderSize);
    UString name = usprintf("CPD partition table");
    UString info = usprintf("Full size: %Xh (%u)\nHeader size: %Xh (%u)\nBody size: %Xh (%u)\nNumber of entries: %u\n"
                            "Header version: %02X\nEntry version: %02X",
                            region.size(), region.size(),
                            header.size(), header.size(),
                            body.size(), body.size(),
                            cpdHeader->NumEntries,
                            cpdHeader->HeaderVersion,
                            cpdHeader->EntryVersion);

    // Add tree item
    index = model->addItem(localOffset, Types::CpdStore, 0, name, UString(), info, header, body, UByteArray(), Fixed, parent);

    // Add partition table entries
    std::vector<CPD_PARTITION_INFO> partitions;
    UINT32 offset = ptHeaderSize;
    const CPD_ENTRY* firstCpdEntry = (const CPD_ENTRY*)(body.constData());
    for (UINT32 i = 0; i < cpdHeader->NumEntries; i++) {
        // Populate entry header
        const CPD_ENTRY* cpdEntry = firstCpdEntry + i;
        UByteArray entry((const char*)cpdEntry, sizeof(CPD_ENTRY));

        // Get info
        name = usprintf("%c%c%c%c%c%c%c%c%c%c%c%c",
                        cpdEntry->EntryName[0], cpdEntry->EntryName[1], cpdEntry->EntryName[2], cpdEntry->EntryName[3],
                        cpdEntry->EntryName[4], cpdEntry->EntryName[5], cpdEntry->EntryName[6], cpdEntry->EntryName[7],
                        cpdEntry->EntryName[8], cpdEntry->EntryName[9], cpdEntry->EntryName[10], cpdEntry->EntryName[11]);
        info = usprintf("Full size: %Xh (%u)\nEntry offset: %Xh\nEntry length: %Xh\nHuffman compressed: ",
                        entry.size(), entry.size(),
                        cpdEntry->Offset.Offset,
                        cpdEntry->Length)
        + (cpdEntry->Offset.HuffmanCompressed ? "Yes" : "No");

        // Add tree item
        UModelIndex entryIndex = model->addItem(offset, Types::CpdEntry, 0, name, UString(), info, UByteArray(), entry, UByteArray(), Fixed, index);

        // Adjust offset
        offset += sizeof(CPD_ENTRY);

        if (cpdEntry->Offset.Offset != 0 && cpdEntry->Length != 0) {
            // Add to partitions vector
            CPD_PARTITION_INFO partition;
            partition.type = Types::CpdPartition;
            partition.ptEntry = *cpdEntry;
            partition.index = entryIndex;
            partitions.push_back(partition);
        }
    }

    // Add padding if there's no partions to add
    if (partitions.size() == 0) {
        UByteArray partition = region.mid(ptSize);

        // Get info
        name = UString("Padding");
        info = usprintf("Full size: %Xh (%u)",
                        partition.size(), partition.size());

        // Add tree item
        model->addItem(localOffset + ptSize, Types::Padding, getPaddingType(partition), name, UString(), info, UByteArray(), partition, UByteArray(), Fixed, parent);

        return U_SUCCESS;
    }

    // Sort partitions by offset
    std::sort(partitions.begin(), partitions.end());

    // Because lenghts for all Huffmann-compressed partitions mean nothing at all, we need to split all partitions into 2 classes:
    // 1. CPD manifest (should be the first)
    // 2. Metadata entries (should begin right after partition manifest and end before any code partition)
    UINT32 i = 1;
    while (i < partitions.size()) {
        name = usprintf("%c%c%c%c%c%c%c%c%c%c%c%c",
                        partitions[i].ptEntry.EntryName[0], partitions[i].ptEntry.EntryName[1], partitions[i].ptEntry.EntryName[2],  partitions[i].ptEntry.EntryName[3],
                        partitions[i].ptEntry.EntryName[4], partitions[i].ptEntry.EntryName[5], partitions[i].ptEntry.EntryName[6],  partitions[i].ptEntry.EntryName[7],
                        partitions[i].ptEntry.EntryName[8], partitions[i].ptEntry.EntryName[9], partitions[i].ptEntry.EntryName[10], partitions[i].ptEntry.EntryName[11]);

        // Check if the current entry is metadata entry
        if (!name.contains(".met")) {
            // No need to parse further, all metadata partitions are parsed
            break;
        }

        // Parse into data block, find Module Attributes extension, and get compressed size from there
        UINT32 offset = 0;
        UINT32 length = 0xFFFFFFFF; // Special guardian value
        UByteArray partition = region.mid(partitions[i].ptEntry.Offset.Offset, partitions[i].ptEntry.Length);
        while (offset < (UINT32)partition.size()) {
            const CPD_EXTENTION_HEADER* extHeader = (const CPD_EXTENTION_HEADER*) (partition.constData() + offset);
            if (extHeader->Length <= ((UINT32)partition.size() - offset)) {
                if (extHeader->Type == CPD_EXT_TYPE_MODULE_ATTRIBUTES) {
                    const CPD_EXT_MODULE_ATTRIBUTES* attrHeader = (const CPD_EXT_MODULE_ATTRIBUTES*)(partition.constData() + offset);
                    length = attrHeader->CompressedSize;
                }
                offset += extHeader->Length;
            }
            else break;
        }

        // Search down for corresponding code partition
        // Construct it's name by replacing last 4 non-zero butes of the name with zeros
        UINT32 j = 0;
        for (UINT32 k = 11; k > 0 && j < 4; k--) {
            if (name[k] != '\x00') {
                name[k] = '\x00';
                j++;
            }
        }

        // Search
        j = i + 1;
        while (j < partitions.size()) {
            if (name == usprintf("%c%c%c%c%c%c%c%c%c%c%c%c",
                                 partitions[j].ptEntry.EntryName[0], partitions[j].ptEntry.EntryName[1], partitions[j].ptEntry.EntryName[2],  partitions[j].ptEntry.EntryName[3],
                                 partitions[j].ptEntry.EntryName[4], partitions[j].ptEntry.EntryName[5], partitions[j].ptEntry.EntryName[6],  partitions[j].ptEntry.EntryName[7],
                                 partitions[j].ptEntry.EntryName[8], partitions[j].ptEntry.EntryName[9], partitions[j].ptEntry.EntryName[10], partitions[j].ptEntry.EntryName[11])) {
                // Found it, update it's Length if needed
                if (partitions[j].ptEntry.Offset.HuffmanCompressed) {
                    partitions[j].ptEntry.Length = length;
                }
                else if (length != 0xFFFFFFFF && partitions[j].ptEntry.Length != length) {
                    msg(usprintf("%s: partition size mismatch between partition table (%Xh) and partition metadata (%Xh)", __FUNCTION__,
                                 partitions[j].ptEntry.Length, length), partitions[j].index);
                    partitions[j].ptEntry.Length = length; // Believe metadata
                }
                // No need to search further
                break;
            }
            // Check the next partition
            j++;
        }
        // Check the next partition
        i++;
    }

make_partition_table_consistent:
    // Sort partitions by offset
    std::sort(partitions.begin(), partitions.end());

    // Check for intersections and paddings between partitions
    CPD_PARTITION_INFO padding;

    // Check intersection with the partition table header
    if (partitions.front().ptEntry.Offset.Offset < ptSize) {
        msg(usprintf("%s: CPD partition has intersection with CPD partition table, skipped", __FUNCTION__),
            partitions.front().index);
        partitions.erase(partitions.begin());
        goto make_partition_table_consistent;
    }
    // Check for padding between partition table and the first partition
    else if (partitions.front().ptEntry.Offset.Offset > ptSize) {
        padding.ptEntry.Offset.Offset = ptSize;
        padding.ptEntry.Length = partitions.front().ptEntry.Offset.Offset - padding.ptEntry.Offset.Offset;
        padding.type = Types::Padding;
        partitions.insert(partitions.begin(), padding);
    }
    // Check for intersections/paddings between partitions
    for (size_t i = 1; i < partitions.size(); i++) {
        UINT32 previousPartitionEnd = partitions[i - 1].ptEntry.Offset.Offset + partitions[i - 1].ptEntry.Length;

        // Check that current region is fully present in the image
        if ((UINT64)partitions[i].ptEntry.Offset.Offset + (UINT64)partitions[i].ptEntry.Length > (UINT64)region.size()) {
            if ((UINT64)partitions[i].ptEntry.Offset.Offset >= (UINT64)region.size()) {
                msg(usprintf("%s: CPD partition is located outside of the opened image, skipped", __FUNCTION__), partitions[i].index);
                partitions.erase(partitions.begin() + i);
                goto make_partition_table_consistent;
            }
            else {
                msg(usprintf("%s: CPD partition can't fit into it's region, truncated", __FUNCTION__), partitions[i].index);
                partitions[i].ptEntry.Length = (UINT32)region.size() - (UINT32)partitions[i].ptEntry.Offset.Offset;
            }
        }

        // Check for intersection with previous partition
        if (partitions[i].ptEntry.Offset.Offset < previousPartitionEnd) {
            // Check if current partition is located inside previous one
            if (partitions[i].ptEntry.Offset.Offset + partitions[i].ptEntry.Length <= previousPartitionEnd) {
                msg(usprintf("%s: CPD partition is located inside another CPD partition, skipped", __FUNCTION__),
                    partitions[i].index);
                partitions.erase(partitions.begin() + i);
                goto make_partition_table_consistent;
            }
            else {
                msg(usprintf("%s: CPD partition intersects with previous one, skipped", __FUNCTION__),
                    partitions[i].index);
                partitions.erase(partitions.begin() + i);
                goto make_partition_table_consistent;
            }
        }
        // Check for padding between current and previous partitions
        else if (partitions[i].ptEntry.Offset.Offset > previousPartitionEnd) {
            padding.ptEntry.Offset.Offset = previousPartitionEnd;
            padding.ptEntry.Length = partitions[i].ptEntry.Offset.Offset - previousPartitionEnd;
            padding.type = Types::Padding;
            std::vector<CPD_PARTITION_INFO>::iterator iter = partitions.begin();
            std::advance(iter, i);
            partitions.insert(iter, padding);
        }
    }
    // Check for padding after the last region
    if ((UINT64)partitions.back().ptEntry.Offset.Offset + (UINT64)partitions.back().ptEntry.Length < (UINT64)region.size()) {
        padding.ptEntry.Offset.Offset = partitions.back().ptEntry.Offset.Offset + partitions.back().ptEntry.Length;
        padding.ptEntry.Length = (UINT32)region.size() - padding.ptEntry.Offset.Offset;
        padding.type = Types::Padding;
        partitions.push_back(padding);
    }

    // Partition map is consistent
    for (size_t i = 0; i < partitions.size(); i++) {
        if (partitions[i].type == Types::CpdPartition) {
            UByteArray partition = region.mid(partitions[i].ptEntry.Offset.Offset, partitions[i].ptEntry.Length);

            // Get info
            name = usprintf("%c%c%c%c%c%c%c%c%c%c%c%c",
                            partitions[i].ptEntry.EntryName[0], partitions[i].ptEntry.EntryName[1], partitions[i].ptEntry.EntryName[2], partitions[i].ptEntry.EntryName[3],
                            partitions[i].ptEntry.EntryName[4], partitions[i].ptEntry.EntryName[5], partitions[i].ptEntry.EntryName[6], partitions[i].ptEntry.EntryName[7],
                            partitions[i].ptEntry.EntryName[8], partitions[i].ptEntry.EntryName[9], partitions[i].ptEntry.EntryName[10], partitions[i].ptEntry.EntryName[11]);

            // It's a manifest
            if (name.contains(".man")) {
                if (!partitions[i].ptEntry.Offset.HuffmanCompressed
                    && partitions[i].ptEntry.Length >= sizeof(CPD_MANIFEST_HEADER)) {
                    const CPD_MANIFEST_HEADER* manifestHeader = (const CPD_MANIFEST_HEADER*) partition.constData();
                    if (manifestHeader->HeaderId == ME_MANIFEST_HEADER_ID) {
                        UByteArray header = partition.left(manifestHeader->HeaderLength * sizeof(UINT32));
                        UByteArray body = partition.mid(header.size());

                        info += usprintf(
                                         "\nHeader type: %u\nHeader length: %Xh (%u)\nHeader version: %Xh\nFlags: %08Xh\nVendor: %Xh\n"
                                         "Date: %Xh\nSize: %Xh (%u)\nVersion: %u.%u.%u.%u\nSecurity version number: %u\nModulus size: %Xh (%u)\nExponent size: %Xh (%u)",
                                         manifestHeader->HeaderType,
                                         manifestHeader->HeaderLength * sizeof(UINT32), manifestHeader->HeaderLength * sizeof(UINT32),
                                         manifestHeader->HeaderVersion,
                                         manifestHeader->Flags,
                                         manifestHeader->Vendor,
                                         manifestHeader->Date,
                                         manifestHeader->Size * sizeof(UINT32), manifestHeader->Size * sizeof(UINT32),
                                         manifestHeader->VersionMajor, manifestHeader->VersionMinor, manifestHeader->VersionBugfix, manifestHeader->VersionBuild,
                                         manifestHeader->SecurityVersion,
                                         manifestHeader->ModulusSize * sizeof(UINT32), manifestHeader->ModulusSize * sizeof(UINT32),
                                         manifestHeader->ExponentSize * sizeof(UINT32), manifestHeader->ExponentSize * sizeof(UINT32));

                        // Add tree item
                        UModelIndex partitionIndex = model->addItem(localOffset + partitions[i].ptEntry.Offset.Offset, Types::CpdPartition, Subtypes::ManifestCpdPartition, name, UString(), info, header, body, UByteArray(), Fixed, parent);

                        // Parse data as extensions area
                        parseCpdExtensionsArea(partitionIndex);
                    }
                }
            }
            // It's a metadata
            else if (name.contains(".met")) {
                info = usprintf("Full size: %Xh (%u)\nEntry offset: %Xh\nEntry length: %Xh\nHuffman compressed: ",
                                partition.size(), partition.size(),
                                partitions[i].ptEntry.Offset.Offset,
                                partitions[i].ptEntry.Length)
                + (partitions[i].ptEntry.Offset.HuffmanCompressed ? "Yes" : "No");

                // Calculate SHA256 hash over the metadata and add it to it's info
                UByteArray hash(SHA256_DIGEST_SIZE, '\x00');
                sha256(partition.constData(), partition.size(), hash.data());
                info += UString("\nMetadata hash: ") + UString(hash.toHex().constData());

                // Add three item
                UModelIndex partitionIndex = model->addItem(localOffset + partitions[i].ptEntry.Offset.Offset, Types::CpdPartition,  Subtypes::MetadataCpdPartition, name, UString(), info, UByteArray(), partition, UByteArray(), Fixed, parent);

                // Parse data as extensions area
                parseCpdExtensionsArea(partitionIndex);
            }
            // It's a key
            else if (name.contains(".key")) {
                info = usprintf("Full size: %Xh (%u)\nEntry offset: %Xh\nEntry length: %Xh\nHuffman compressed: ",
                                partition.size(), partition.size(),
                                partitions[i].ptEntry.Offset.Offset,
                                partitions[i].ptEntry.Length)
                + (partitions[i].ptEntry.Offset.HuffmanCompressed ? "Yes" : "No");

                // Calculate SHA256 hash over the key and add it to it's info
                UByteArray hash(SHA256_DIGEST_SIZE, '\x00');
                sha256(partition.constData(), partition.size(), hash.data());
                info += UString("\nHash: ") + UString(hash.toHex().constData());

                // Add three item
                UModelIndex partitionIndex = model->addItem(localOffset + partitions[i].ptEntry.Offset.Offset, Types::CpdPartition,  Subtypes::KeyCpdPartition, name, UString(), info, UByteArray(), partition, UByteArray(), Fixed, parent);

                // Parse data as extensions area
                parseCpdExtensionsArea(partitionIndex);
            }
            // It's a code
            else {
                info = usprintf("Full size: %Xh (%u)\nEntry offset: %Xh\nEntry length: %Xh\nHuffman compressed: ",
                                partition.size(), partition.size(),
                                partitions[i].ptEntry.Offset.Offset,
                                partitions[i].ptEntry.Length)
                + (partitions[i].ptEntry.Offset.HuffmanCompressed ? "Yes" : "No");

                // Calculate SHA256 hash over the code and add it to it's info
                UByteArray hash(SHA256_DIGEST_SIZE, '\x00');
                sha256(partition.constData(), partition.size(), hash.data());
                info += UString("\nHash: ") + UString(hash.toHex().constData());

                UModelIndex codeIndex = model->addItem(localOffset + partitions[i].ptEntry.Offset.Offset, Types::CpdPartition, Subtypes::CodeCpdPartition, name, UString(), info, UByteArray(), partition, UByteArray(), Fixed, parent);
                parseRawArea(codeIndex);
            }
        }
        else if (partitions[i].type == Types::Padding) {
            UByteArray partition = region.mid(partitions[i].ptEntry.Offset.Offset, partitions[i].ptEntry.Length);

            // Get info
            name = UString("Padding");
            info = usprintf("Full size: %Xh (%u)", partition.size(), partition.size());

            // Add tree item
            model->addItem(localOffset + partitions[i].ptEntry.Offset.Offset, Types::Padding, getPaddingType(partition), name, UString(), info, UByteArray(), partition, UByteArray(), Fixed, parent);
        }
        else {
            msg(usprintf("%s: CPD partition of unknown type found", __FUNCTION__), parent);
            return U_INVALID_ME_PARTITION_TABLE;
        }
    }

    return U_SUCCESS;
}

USTATUS FfsParser::parseCpdExtensionsArea(const UModelIndex & index)
{
    if (!index.isValid()) {
        return U_INVALID_PARAMETER;
    }

    UByteArray body = model->body(index);
    UINT32 offset = 0;
    while (offset < (UINT32)body.size()) {
        const CPD_EXTENTION_HEADER* extHeader = (const CPD_EXTENTION_HEADER*) (body.constData() + offset);
        if (extHeader->Length <= ((UINT32)body.size() - offset)) {
            UByteArray partition = body.mid(offset, extHeader->Length);

            UString name = cpdExtensionTypeToUstring(extHeader->Type);
            UString info = usprintf("Full size: %Xh (%u)\nType: %Xh", partition.size(), partition.size(), extHeader->Type);

            // Parse Signed Package Info a bit further
            UModelIndex extIndex;
            if (extHeader->Type == CPD_EXT_TYPE_SIGNED_PACKAGE_INFO) {
                UByteArray header = partition.left(sizeof(CPD_EXT_SIGNED_PACKAGE_INFO));
                UByteArray data = partition.mid(header.size());

                const CPD_EXT_SIGNED_PACKAGE_INFO* infoHeader = (const CPD_EXT_SIGNED_PACKAGE_INFO*)header.constData();

                info = usprintf("Full size: %Xh (%u)\nHeader size: %Xh (%u)\nBody size: %Xh (%u)\nType: %Xh\n"
                                "Package name: %c%c%c%c\nVersion control number: %Xh\nSecurity version number: %Xh\n"
                                "Usage bitmap: %02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X",
                                partition.size(), partition.size(),
                                header.size(), header.size(),
                                body.size(), body.size(),
                                infoHeader->ExtensionType,
                                infoHeader->PackageName[0], infoHeader->PackageName[1], infoHeader->PackageName[2], infoHeader->PackageName[3],
                                infoHeader->Vcn,
                                infoHeader->Svn,
                                infoHeader->UsageBitmap[0],  infoHeader->UsageBitmap[1],  infoHeader->UsageBitmap[2],  infoHeader->UsageBitmap[3],
                                infoHeader->UsageBitmap[4],  infoHeader->UsageBitmap[5],  infoHeader->UsageBitmap[6],  infoHeader->UsageBitmap[7],
                                infoHeader->UsageBitmap[8],  infoHeader->UsageBitmap[9],  infoHeader->UsageBitmap[10], infoHeader->UsageBitmap[11],
                                infoHeader->UsageBitmap[12], infoHeader->UsageBitmap[13], infoHeader->UsageBitmap[14], infoHeader->UsageBitmap[15]);

                // Add tree item
                extIndex = model->addItem(offset, Types::CpdExtension, 0, name, UString(), info, header, data, UByteArray(), Fixed, index);
                parseSignedPackageInfoData(extIndex);
            }
            // Parse IFWI Partition Manifest a bit further
            else if (extHeader->Type == CPD_EXT_TYPE_IFWI_PARTITION_MANIFEST) {
                const CPD_EXT_IFWI_PARTITION_MANIFEST* attrHeader = (const CPD_EXT_IFWI_PARTITION_MANIFEST*)partition.constData();

                // This hash is stored reversed
                // Need to reverse it back to normal
                UByteArray hash((const char*)&attrHeader->CompletePartitionHash, sizeof(attrHeader->CompletePartitionHash));
                std::reverse(hash.begin(), hash.end());

                info = usprintf("Full size: %Xh (%u)\nType: %Xh\n"
                                "Partition name: %c%c%c%c\nPartition length: %Xh\nPartition version major: %Xh\nPartition version minor: %Xh\n"
                                "Data format version: %Xh\nInstance ID: %Xh\nHash algorithm: %Xh\nHash size: %Xh\nAction on update: %Xh",
                                partition.size(), partition.size(),
                                attrHeader->ExtensionType,
                                attrHeader->PartitionName[0], attrHeader->PartitionName[1], attrHeader->PartitionName[2], attrHeader->PartitionName[3],
                                attrHeader->CompletePartitionLength,
                                attrHeader->PartitionVersionMajor, attrHeader->PartitionVersionMinor,
                                attrHeader->DataFormatVersion,
                                attrHeader->InstanceId,
                                attrHeader->HashAlgorithm,
                                attrHeader->HashSize,
                                attrHeader->ActionOnUpdate)
                + UString("\nSupport multiple instances: ") + (attrHeader->SupportMultipleInstances ? "Yes" : "No")
                + UString("\nSupport API version based update: ") + (attrHeader->SupportApiVersionBasedUpdate ? "Yes" : "No")
                + UString("\nObey full update rules: ") + (attrHeader->ObeyFullUpdateRules ? "Yes" : "No")
                + UString("\nIFR enable only: ") + (attrHeader->IfrEnableOnly ? "Yes" : "No")
                + UString("\nAllow cross point update: ") + (attrHeader->AllowCrossPointUpdate ? "Yes" : "No")
                + UString("\nAllow cross hotfix update: ") + (attrHeader->AllowCrossHotfixUpdate ? "Yes" : "No")
                + UString("\nPartial update only: ") + (attrHeader->PartialUpdateOnly ? "Yes" : "No")
                + UString("\nPartition hash: ") +  UString(hash.toHex().constData());

                // Add tree item
                extIndex = model->addItem(offset, Types::CpdExtension, 0, name, UString(), info, UByteArray(), partition, UByteArray(), Fixed, index);
            }
            // Parse Module Attributes a bit further
            else if (extHeader->Type == CPD_EXT_TYPE_MODULE_ATTRIBUTES) {
                const CPD_EXT_MODULE_ATTRIBUTES* attrHeader = (const CPD_EXT_MODULE_ATTRIBUTES*)partition.constData();

                // This hash is stored reversed
                // Need to reverse it back to normal
                UByteArray hash((const char*)&attrHeader->ImageHash, sizeof(attrHeader->ImageHash));
                std::reverse(hash.begin(), hash.end());

                info = usprintf("Full size: %Xh (%u)\nType: %Xh\n"
                                "Compression type: %Xh\nUncompressed size: %Xh (%u)\nCompressed size: %Xh (%u)\nGlobal module ID: %Xh\nImage hash: ",
                                partition.size(), partition.size(),
                                attrHeader->ExtensionType,
                                attrHeader->CompressionType,
                                attrHeader->UncompressedSize, attrHeader->UncompressedSize,
                                attrHeader->CompressedSize, attrHeader->CompressedSize,
                                attrHeader->GlobalModuleId) + UString(hash.toHex().constData());

                // Add tree item
                extIndex = model->addItem(offset, Types::CpdExtension, 0, name, UString(), info, UByteArray(), partition, UByteArray(), Fixed, index);
            }
            // Parse everything else
            else {
                // Add tree item, if needed
                extIndex = model->addItem(offset, Types::CpdExtension, 0, name, UString(), info, UByteArray(), partition, UByteArray(), Fixed, index);
            }

            if (extHeader->Type > CPD_LAST_KNOWN_EXT_TYPE) {
                msg(usprintf("%s: CPD extention of unknown type found", __FUNCTION__), extIndex);
            }

            offset += extHeader->Length;
        }
        else break;
        // TODO: add padding at the end
    }

    return U_SUCCESS;
}

USTATUS FfsParser::parseSignedPackageInfoData(const UModelIndex & index)
{
    if (!index.isValid()) {
        return U_INVALID_PARAMETER;
    }

    UByteArray body = model->body(index);
    UINT32 offset = 0;
    while (offset < (UINT32)body.size()) {
        const CPD_EXT_SIGNED_PACKAGE_INFO_MODULE* moduleHeader = (const CPD_EXT_SIGNED_PACKAGE_INFO_MODULE*)(body.constData() + offset);
        if (sizeof(CPD_EXT_SIGNED_PACKAGE_INFO_MODULE) <= ((UINT32)body.size() - offset)) {
            UByteArray module((const char*)moduleHeader, sizeof(CPD_EXT_SIGNED_PACKAGE_INFO_MODULE));

            UString name = usprintf("%c%c%c%c%c%c%c%c%c%c%c%c",
                                    moduleHeader->Name[0], moduleHeader->Name[1], moduleHeader->Name[2], moduleHeader->Name[3],
                                    moduleHeader->Name[4], moduleHeader->Name[5], moduleHeader->Name[6], moduleHeader->Name[7],
                                    moduleHeader->Name[8], moduleHeader->Name[9], moduleHeader->Name[10],moduleHeader->Name[11]);

            // This hash is stored reversed
            // Need to reverse it back to normal
            UByteArray hash((const char*)&moduleHeader->MetadataHash, sizeof(moduleHeader->MetadataHash));
            std::reverse(hash.begin(), hash.end());

            UString info = usprintf("Full size: %X (%u)\nType: %Xh\nHash algorithm: %Xh\nHash size: %Xh (%u)\nMetadata size: %Xh (%u)\nMetadata hash: ",
                                    module.size(), module.size(),
                                    moduleHeader->Type,
                                    moduleHeader->HashAlgorithm,
                                    moduleHeader->HashSize, moduleHeader->HashSize,
                                    moduleHeader->MetadataSize, moduleHeader->MetadataSize) + UString(hash.toHex().constData());
            // Add tree otem
            model->addItem(offset, Types::CpdSpiEntry, 0, name, UString(), info, UByteArray(), module, UByteArray(), Fixed, index);

            offset += module.size();
        }
        else break;
        // TODO: add padding at the end
    }

    return U_SUCCESS;
}

```

`efiXloader/3rd/uefitool/common/ffsparser.h`:

```h
/* ffsparser.h

Copyright (c) 2017, LongSoft. All rights reserved.
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHWARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
*/

#ifndef FFSPARSER_H
#define FFSPARSER_H

#include <vector>

#include "basetypes.h"
#include "ustring.h"
#include "ubytearray.h"
#include "treemodel.h"
#include "bootguard.h"
#include "fit.h"

typedef struct BG_PROTECTED_RANGE_ {
    UINT32     Offset;
    UINT32     Size;
    UINT8      Type;
    UByteArray Hash;
} BG_PROTECTED_RANGE;

#define BG_PROTECTED_RANGE_INTEL_BOOT_GUARD_IBB      0x01
#define BG_PROTECTED_RANGE_INTEL_BOOT_GUARD_POST_IBB 0x02
#define BG_PROTECTED_RANGE_VENDOR_HASH_PHOENIX       0x03
#define BG_PROTECTED_RANGE_VENDOR_HASH_AMI_OLD       0x04
#define BG_PROTECTED_RANGE_VENDOR_HASH_AMI_NEW       0x05
#define BG_PROTECTED_RANGE_VENDOR_HASH_MICROSOFT     0x06

class NvramParser;
class MeParser;

class FfsParser
{
public:
    // Constructor and destructor
    FfsParser(TreeModel* treeModel);
    ~FfsParser();

    // Obtain parser messages 
    std::vector<std::pair<UString, UModelIndex> > getMessages() const;
    // Clear messages
    void clearMessages() { messagesVector.clear(); }

    // Parse firmware image
    USTATUS parse(const UByteArray &buffer);
    
    // Obtain parsed FIT table
    std::vector<std::pair<std::vector<UString>, UModelIndex> > getFitTable() const { return fitTable; }

    // Obtain Security Info
    UString getSecurityInfo() const { return securityInfo; }

    // Obtain offset/address difference
    UINT64 getAddressDiff() { return addressDiff; }

private:
    TreeModel *model;
    std::vector<std::pair<UString, UModelIndex> > messagesVector;
    void msg(const UString & message, const UModelIndex & index = UModelIndex()) {
        messagesVector.push_back(std::pair<UString, UModelIndex>(message, index));
    };

    NvramParser* nvramParser;
    MeParser* meParser;
 
    UByteArray openedImage;
    UModelIndex lastVtf;
    UINT32 imageBase;
    UINT64 addressDiff;
    std::vector<std::pair<std::vector<UString>, UModelIndex> > fitTable;
    
    UString securityInfo;
    bool bgAcmFound;
    bool bgKeyManifestFound;
    bool bgBootPolicyFound;
    UByteArray bgKmHash;
    UByteArray bgBpHash;
    UByteArray bgBpDigest;
    std::vector<BG_PROTECTED_RANGE> bgProtectedRanges;
    UINT64 bgProtectedRegionsBase;
    UModelIndex bgDxeCoreIndex;

    // First pass
    USTATUS performFirstPass(const UByteArray & imageFile, UModelIndex & index);

    USTATUS parseCapsule(const UByteArray & capsule, const UINT32 localOffset, const UModelIndex & parent, UModelIndex & index);
    USTATUS parseIntelImage(const UByteArray & intelImage, const UINT32 localOffset, const UModelIndex & parent, UModelIndex & index);
    USTATUS parseGenericImage(const UByteArray & intelImage, const UINT32 localOffset, const UModelIndex & parent, UModelIndex & index);

    USTATUS parseBpdtRegion(const UByteArray & region, const UINT32 localOffset, const UINT32 sbpdtOffsetFixup, const UModelIndex & parent, UModelIndex & index);
    USTATUS parseCpdRegion(const UByteArray & region, const UINT32 localOffset, const UModelIndex & parent, UModelIndex & index);
    USTATUS parseCpdExtensionsArea(const UModelIndex & index);
    USTATUS parseSignedPackageInfoData(const UModelIndex & index);
    
    USTATUS parseRawArea(const UModelIndex & index);
    USTATUS parseVolumeHeader(const UByteArray & volume, const UINT32 localOffset, const UModelIndex & parent, UModelIndex & index);
    USTATUS parseVolumeBody(const UModelIndex & index);
    USTATUS parseMicrocodeVolumeBody(const UModelIndex & index);
    USTATUS parseFileHeader(const UByteArray & file, const UINT32 localOffset, const UModelIndex & parent, UModelIndex & index);
    USTATUS parseFileBody(const UModelIndex & index);
    USTATUS parseSectionHeader(const UByteArray & section, const UINT32 localOffset, const UModelIndex & parent, UModelIndex & index, const bool insertIntoTree);
    USTATUS parseSectionBody(const UModelIndex & index);

    USTATUS parseGbeRegion(const UByteArray & gbe, const UINT32 localOffset, const UModelIndex & parent, UModelIndex & index);
    USTATUS parseMeRegion(const UByteArray & me, const UINT32 localOffset, const UModelIndex & parent, UModelIndex & index);
    USTATUS parseBiosRegion(const UByteArray & bios, const UINT32 localOffset, const UModelIndex & parent, UModelIndex & index);
    USTATUS parsePdrRegion(const UByteArray & pdr, const UINT32 localOffset, const UModelIndex & parent, UModelIndex & index);
    USTATUS parseDevExp1Region(const UByteArray & devExp1, const UINT32 localOffset, const UModelIndex & parent, UModelIndex & index);
    USTATUS parseGenericRegion(const UINT8 subtype, const UByteArray & region, const UINT32 localOffset, const UModelIndex & parent, UModelIndex & index);

    USTATUS parsePadFileBody(const UModelIndex & index);
    USTATUS parseVolumeNonUefiData(const UByteArray & data, const UINT32 localOffset, const UModelIndex & index);

    USTATUS parseSections(const UByteArray & sections, const UModelIndex & index, const bool insertIntoTree);
    USTATUS parseCommonSectionHeader(const UByteArray & section, const UINT32 localOffset, const UModelIndex & parent, UModelIndex & index, const bool insertIntoTree);
    USTATUS parseCompressedSectionHeader(const UByteArray & section, const UINT32 localOffset, const UModelIndex & parent, UModelIndex & index, const bool insertIntoTree);
    USTATUS parseGuidedSectionHeader(const UByteArray & section, const UINT32 localOffset, const UModelIndex & parent, UModelIndex & index, const bool insertIntoTree);
    USTATUS parseFreeformGuidedSectionHeader(const UByteArray & section, const UINT32 localOffset, const UModelIndex & parent, UModelIndex & index, const bool insertIntoTree);
    USTATUS parseVersionSectionHeader(const UByteArray & section, const UINT32 localOffset, const UModelIndex & parent, UModelIndex & index, const bool insertIntoTree);
    USTATUS parsePostcodeSectionHeader(const UByteArray & section, const UINT32 localOffset, const UModelIndex & parent, UModelIndex & index, const bool insertIntoTree);

    USTATUS parseCompressedSectionBody(const UModelIndex & index);
    USTATUS parseGuidedSectionBody(const UModelIndex & index);
    USTATUS parseVersionSectionBody(const UModelIndex & index);
    USTATUS parseDepexSectionBody(const UModelIndex & index);
    USTATUS parseUiSectionBody(const UModelIndex & index);
    USTATUS parseRawSectionBody(const UModelIndex & index);
    USTATUS parsePeImageSectionBody(const UModelIndex & index);
    USTATUS parseTeImageSectionBody(const UModelIndex & index);

    USTATUS parseAprioriRawSection(const UByteArray & body, UString & parsed);
    USTATUS findNextRawAreaItem(const UModelIndex & index, const UINT32 localOffset, UINT8 & nextItemType, UINT32 & nextItemOffset, UINT32 & nextItemSize, UINT32 & nextItemAlternativeSize);
    UINT32  getFileSize(const UByteArray & volume, const UINT32 fileOffset, const UINT8 ffsVersion);
    UINT32  getSectionSize(const UByteArray & file, const UINT32 sectionOffset, const UINT8 ffsVersion);
    
    USTATUS parseIntelMicrocodeHeader(const UByteArray & store, const UINT32 localOffset, const UModelIndex & parent, UModelIndex & index);
    BOOLEAN microcodeHeaderValid(const INTEL_MICROCODE_HEADER* ucodeHeader);

    // Second pass
    USTATUS performSecondPass(const UModelIndex & index);
    USTATUS addInfoRecursive(const UModelIndex & index);
    USTATUS checkTeImageBase(const UModelIndex & index);
    USTATUS checkProtectedRanges(const UModelIndex & index);
    USTATUS markProtectedRangeRecursive(const UModelIndex & index, const BG_PROTECTED_RANGE & range);

    USTATUS parseResetVectorData();
    USTATUS parseFit(const UModelIndex & index);
    USTATUS parseVendorHashFile(const UByteArray & fileGuid, const UModelIndex & index);


#ifdef U_ENABLE_FIT_PARSING_SUPPORT
    void findFitRecursive(const UModelIndex & index, UModelIndex & found, UINT32 & fitOffset);

    // FIT entries
    USTATUS parseFitEntryMicrocode(const UByteArray & microcode, const UINT32 localOffset, const UModelIndex & parent, UString & info, UINT32 &realSize);
    USTATUS parseFitEntryAcm(const UByteArray & acm, const UINT32 localOffset, const UModelIndex & parent, UString & info, UINT32 &realSize);
    USTATUS parseFitEntryBootGuardKeyManifest(const UByteArray & keyManifest, const UINT32 localOffset, const UModelIndex & parent, UString & info, UINT32 &realSize);
    USTATUS parseFitEntryBootGuardBootPolicy(const UByteArray & bootPolicy, const UINT32 localOffset, const UModelIndex & parent, UString & info, UINT32 &realSize);
    USTATUS findNextBootGuardBootPolicyElement(const UByteArray & bootPolicy, const UINT32 elementOffset, UINT32 & nextElementOffset, UINT32 & nextElementSize);
#endif

#ifdef U_ENABLE_NVRAM_PARSING_SUPPORT
    friend class NvramParser; // Make FFS parsing routines accessible to NvramParser
#endif
    
#ifdef U_ENABLE_ME_PARSING_SUPPORT
    friend class MeParser; // Make FFS parsing routines accessible to MeParser
#endif
};

#endif // FFSPARSER_H

```

`efiXloader/3rd/uefitool/common/ffsreport.cpp`:

```cpp
/* fssreport.cpp

Copyright (c) 2016, Nikolaj Schlej. All rights reserved.
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

*/

#include "ffsreport.h"
#include "ffs.h"
#include "utility.h"

std::vector<UString> FfsReport::generate()
{
    std::vector<UString> report;
    
    // Check model pointer
    if (!model) {
        report.push_back(usprintf("%s: invalid model pointer provided", __FUNCTION__));
        return report;
    }

    // Check root index to be valid
    UModelIndex root = model->index(0,0);
    if (!root.isValid()) {
        report.push_back(usprintf("%s: model root index is invalid", __FUNCTION__));
        return report;
    }

    // Generate report recursive
    report.push_back(UString("      Type       |        Subtype        |   Base   |   Size   |  CRC32   |   Name "));
    USTATUS result = generateRecursive(report, root);
    if (result) {
        report.push_back(usprintf("%s: generateRecursive returned ", __FUNCTION__) + errorCodeToUString(result));
    }

    return report;
}

USTATUS FfsReport::generateRecursive(std::vector<UString> & report, const UModelIndex & index, const UINT32 level)
{
    if (!index.isValid())
        return U_SUCCESS; // Nothing to report for invalid index
    
    // Calculate item CRC32
    UByteArray data = model->header(index) + model->body(index) + model->tail(index);
    UINT32 crc = (UINT32)crc32(0, (const UINT8*)data.constData(), data.size());

    // Information on current item
    UString text = model->text(index);
    UString offset = "|   N/A    ";
    if ((!model->compressed(index)) || (index.parent().isValid() && !model->compressed(index.parent()))) {
        offset = usprintf("| %08X ", model->base(index));
    }

    report.push_back(
        UString(" ") + itemTypeToUString(model->type(index)).leftJustified(16) 
        + UString("| ") + itemSubtypeToUString(model->type(index), model->subtype(index)).leftJustified(22)
        + offset
        + usprintf("| %08X | %08X | ", data.size(), crc) 
        + urepeated('-', level) + UString(" ") + model->name(index) + (text.isEmpty() ? UString() : UString(" | ") + text)
        );

    // Information on child items
    for (int i = 0; i < model->rowCount(index); i++) {
        generateRecursive(report, index.child(i,0), level + 1);
    }

    return U_SUCCESS;
}


```

`efiXloader/3rd/uefitool/common/ffsreport.h`:

```h
/* fssreport.h

Copyright (c) 2016, Nikolaj Schlej. All rights reserved.
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

*/

#ifndef FFSREPORT_H
#define FFSREPORT_H

#include <vector>

#include "basetypes.h"
#include "ubytearray.h"
#include "ustring.h"
#include "treemodel.h"


class FfsReport
{
public:

    FfsReport(TreeModel * treeModel) : model(treeModel) {}
    ~FfsReport() {};

    std::vector<UString> generate();

private:
    TreeModel* model;
    
    USTATUS generateRecursive(std::vector<UString> & report, const UModelIndex & index, const UINT32 level = 0);
};

#endif // FFSREPORT_H


```

`efiXloader/3rd/uefitool/common/ffsutils.cpp`:

```cpp
/* ffsutils.cpp

Copyright (c) 2019, LongSoft. All rights reserved.
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

*/

#include "ffsutils.h"
#include "utility.h"
#include "ffs.h"

namespace FfsUtils {

USTATUS findFileRecursive(TreeModel *model, const UModelIndex index, const UString & hexPattern, const UINT8 mode, std::set<std::pair<UModelIndex, UModelIndex> > & files)
{
    if (!index.isValid())
        return U_SUCCESS;

    if (hexPattern.isEmpty())
        return U_INVALID_PARAMETER;

    const char *hexPatternRaw = hexPattern.toLocal8Bit();
    std::vector<UINT8> pattern, patternMask;
    if (!makePattern(hexPatternRaw, pattern, patternMask))
        return U_INVALID_PARAMETER;

    // Check for "all substrings" pattern
    size_t count = 0;
    for (size_t i = 0; i < patternMask.size(); i++)
        if (patternMask[i] == 0)
            count++;
    if (count == patternMask.size())
        return U_SUCCESS;

    bool hasChildren = (model->rowCount(index) > 0);
    for (int i = 0; i < model->rowCount(index); i++) {
        findFileRecursive(model, index.child(i, index.column()), hexPattern, mode, files);
    }

    UByteArray data;
    if (hasChildren) {
        if (mode == SEARCH_MODE_HEADER)
            data = model->header(index);
        else if (mode == SEARCH_MODE_ALL)
            data = model->header(index) + model->body(index);
    }
    else {
        if (mode == SEARCH_MODE_HEADER)
            data = model->header(index);
        else if (mode == SEARCH_MODE_BODY)
            data = model->body(index);
        else
            data = model->header(index) + model->body(index);
    }

    const UINT8 *rawData = reinterpret_cast<const UINT8 *>(data.constData());
    INTN offset = findPattern(pattern.data(), patternMask.data(), pattern.size(), rawData, data.size(), 0);

    // For patterns that cross header|body boundary, skip patterns entirely located in body, since
    // children search above has already found them.
    if (hasChildren && mode == SEARCH_MODE_ALL && offset >= model->header(index).size()) {
        offset = -1;
    }

    if (offset >= 0) {
        if (model->type(index) != Types::File) {
            UModelIndex ffs = model->findParentOfType(index, Types::File);
            if (model->type(index) == Types::Section && model->subtype(index) == EFI_SECTION_FREEFORM_SUBTYPE_GUID)
                files.insert(std::pair<UModelIndex, UModelIndex>(ffs, index));
            else
                files.insert(std::pair<UModelIndex, UModelIndex>(ffs, UModelIndex()));
        }
        else {
            files.insert(std::pair<UModelIndex, UModelIndex>(index, UModelIndex()));
        }

    }

    return U_SUCCESS;
}

};

```

`efiXloader/3rd/uefitool/common/ffsutils.h`:

```h
/* fssreport.h

Copyright (c) 2019, LongSoft. All rights reserved.
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

*/

#ifndef FFSUTILS_H
#define FFSUTILS_H

#include <set>

#include "basetypes.h"
#include "ubytearray.h"
#include "ustring.h"
#include "treemodel.h"

namespace FfsUtils {

USTATUS findFileRecursive(TreeModel *model, const UModelIndex index, const UString & hexPattern, const UINT8 mode, std::set<std::pair<UModelIndex, UModelIndex> > & files);

};

#endif // FFSUTILS_H

```

`efiXloader/3rd/uefitool/common/filesystem.h`:

```h
/* filesystem.h

Copyright (c) 2015, Nikolaj Schlej. All rights reserved.
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

*/

#ifndef FILESYSTEM_H
#define FILESYSTEM_H

#include "basetypes.h"
#include "ustring.h"
#include "ubytearray.h"
#include <sys/stat.h>
#include <fstream>

#ifdef WIN32
#include <direct.h>
#include <stdlib.h>
static inline bool isExistOnFs(const UString & path) {
    struct _stat buf;
    return (_stat(path.toLocal8Bit(), &buf) == 0);
}

static inline bool makeDirectory(const UString & dir) {
    return (_mkdir(dir.toLocal8Bit()) == 0);
}

static inline bool changeDirectory(const UString & dir) {
    return (_chdir(dir.toLocal8Bit()) == 0);
}

static inline void removeDirectory(const UString & dir) {
    int r = _rmdir(dir.toLocal8Bit());
    // Hack: unlike *nix, Windows does not permit deleting current directories.
    if (r < 0 && errno == EACCES && changeDirectory(dir + UString("/../"))) {
        _rmdir(dir.toLocal8Bit());
    }
}

static inline UString getAbsPath(const UString & path) {
    char abs[_MAX_PATH] = {};
    if (_fullpath(abs, path.toLocal8Bit(), sizeof(abs)))
        return UString(abs);
    return path;
}
#else
#include <unistd.h>
#include <stdlib.h>
static inline bool isExistOnFs(const UString & path) {
    struct stat buf;
    return (stat(path.toLocal8Bit(), &buf) == 0);
}

static inline bool makeDirectory(const UString & dir) {
    return (mkdir(dir.toLocal8Bit(), ACCESSPERMS) == 0);
}

static inline void removeDirectory(const UString & dir) {
    rmdir(dir.toLocal8Bit());
}

static inline bool changeDirectory(const UString & dir) {
    return (chdir(dir.toLocal8Bit()) == 0);
}

static inline UString getAbsPath(const UString & path) {
    char abs[PATH_MAX] = {};
    // Last is a non-standard extension for non-existent files.
    if (realpath(path.toLocal8Bit(), abs) || abs[0] != '\0')
        return UString(abs);
    return path;
}
#endif

static inline USTATUS readFileIntoBuffer(const UString & inPath, UByteArray &buf) {
    if (!isExistOnFs(inPath))
        return U_FILE_OPEN;

    std::ifstream inputFile(inPath.toLocal8Bit(), std::ios::in | std::ios::binary);
    if (!inputFile)
        return U_FILE_OPEN;
    std::vector<char> buffer(std::istreambuf_iterator<char>(inputFile),
        (std::istreambuf_iterator<char>()));
    inputFile.close();

    buf = buffer;

    return U_SUCCESS;
}

#endif

```

`efiXloader/3rd/uefitool/common/fit.h`:

```h
/* fit.h

Copyright (c) 2015, Nikolaj Schlej. All rights reserved.
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHWARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
*/

#ifndef FIT_H
#define FIT_H

#include "basetypes.h"
#include "ubytearray.h"

// Make sure we use right packing rules
#pragma pack(push, 1)

// Memory address of a pointer to FIT, 40h back from the end of flash chip
#define FIT_POINTER_OFFSET 0x40

// Entry types 
#define FIT_TYPE_HEADER            0x00
#define FIT_TYPE_MICROCODE         0x01
#define FIT_TYPE_BIOS_AC_MODULE    0x02
#define FIT_TYPE_BIOS_INIT_MODULE  0x07
#define FIT_TYPE_TPM_POLICY        0x08
#define FIT_TYPE_BIOS_POLICY_DATA  0x09
#define FIT_TYPE_TXT_CONF_POLICY   0x0A
#define FIT_TYPE_AC_KEY_MANIFEST   0x0B
#define FIT_TYPE_AC_BOOT_POLICY    0x0C
#define FIT_TYPE_EMPTY             0x7F

#define FIT_HEADER_VERSION         0x0100
#define FIT_MICROCODE_VERSION      0x0100

const UByteArray FIT_SIGNATURE
("\x5F\x46\x49\x54\x5F\x20\x20\x20", 8); 

typedef struct FIT_ENTRY_ {
    UINT64 Address;
    UINT32 Size : 24;
    UINT32 : 8;
    UINT16 Version;
    UINT8  Type : 7;
    UINT8  CsFlag : 1;
    UINT8  Checksum;
} FIT_ENTRY;

typedef struct {
    UINT16 IndexRegisterAddress;
    UINT16 DataRegisterAddress;
    UINT8  AccessWidth;
    UINT8  BitPosition;
    UINT16 Index;
} FIT_ENTRY_VERSION_0_CONFIG_POLICY;

// This scructure is described in Section 9.11.1 of the Intel Software Developer manual Volume 3A Part 1
typedef struct INTEL_MICROCODE_HEADER_ {
    UINT32 HeaderVersion;             // 0x00000001
    UINT32 UpdateRevision;
    UINT16 DateYear;                  // BCD
    UINT8  DateDay;                   // BCD
    UINT8  DateMonth;                 // BCD
    UINT32 ProcessorSignature;
    UINT32 Checksum;                  // Checksum of Update Data and Header. Used to verify the integrity of the update header and data.
                                      // Checksum is correct when the summation of all the DWORDs (including the extended Processor Signature Table)
                                      // that comprise the microcode update result in 00000000H.
    UINT32 LoaderRevision;            // 0x00000001
    UINT8  ProcessorFlags;
    UINT8  ProcessorFlagsReserved[3]; // Zeroes
    UINT32 DataSize;                  // Specifies the size of the encrypted data in bytes, and must be a multiple of DWORDs.
                                      // If this value is 00000000H, then the microcode update encrypted data is 2000 bytes (or 500 DWORDs).
                                      // Sane values are less than 0x1000000
    UINT32 TotalSize;                 // Specifies the total size of the microcode update in bytes.
                                      // It is the summation of the header size, the encrypted data size and the size of the optional extended signature table.
                                      // This value is always a multiple of 1024 according to the spec, but Intel already breached it several times.
                                      // Sane values are less than 0x1000000
    UINT8  Reserved[12];              // Zeroes
} INTEL_MICROCODE_HEADER;

#define INTEL_MICROCODE_REAL_DATA_SIZE_ON_ZERO 2000

typedef struct INTEL_MICROCODE_EXTENDED_HEADER_ {
    UINT32 EntryCount;
    UINT32 Checksum; // Checksum of extended processor signature table.
                     // Used to verify the integrity of the extended processor signature table.
                     // Checksum is correct when the summation of the DWORDs that comprise the extended processor signature table results in 00000000H.

    UINT8  Reserved[12];
    // INTEL_MICROCODE_EXTENDED_HEADER_ENTRY Entries[EntryCount];
} INTEL_MICROCODE_EXTENDED_HEADER;

typedef struct INTEL_MICROCODE_EXTENDED_HEADER_ENTRY_ {
    UINT32 ProcessorSignature;
    UINT32 ProcessorFlags;
    UINT32 Checksum;          // To calculate the Checksum, substitute the Primary Processor Signature entry and the Processor Flags entry with the corresponding Extended Patch entry.
                              // Delete the Extended Processor Signature Table entries.
                              // Checksum is correct when the summation of all DWORDs that comprise the created Extended Processor Patch results in 00000000H.
} INTEL_MICROCODE_EXTENDED_HEADER_ENTRY;

#define INTEL_MICROCODE_HEADER_VERSION_1    0x00000001

#pragma pack(pop)

#endif // FIT_H

```

`efiXloader/3rd/uefitool/common/gbe.h`:

```h
/* gbe.h

Copyright (c) 2015, Nikolaj Schlej. All rights reserved.
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHWARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
*/

#ifndef GBE_H
#define GBE_H

#include "basetypes.h"

// Make sure we use right packing rules
#pragma pack(push, 1)

typedef struct GBE_MAC_ADDRESS_ {
    UINT8 vendor[3];
    UINT8 device[3];
} GBE_MAC_ADDRESS;

#define GBE_VERSION_OFFSET 10

typedef struct GBE_VERSION_ {
    UINT8 id    : 4;
    UINT8 minor : 4;
    UINT8 major;
} GBE_VERSION;

// Restore previous packing rules
#pragma pack(pop)

#endif // GBE_H

```

`efiXloader/3rd/uefitool/common/guiddatabase.cpp`:

```cpp
/* guiddatabase.cpp

Copyright (c) 2017, LongSoft. All rights reserved.
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHWARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
*/

#include "guiddatabase.h"
#include "ubytearray.h"
#include "ffs.h"

#include <fstream>
#include <string>

#if defined(U_ENABLE_GUID_DATABASE_SUPPORT)
#include <sstream>
#include <vector>
#include <cstdio>

static GuidDatabase gLocalGuidDatabase;

#ifdef QT_CORE_LIB

#include <QFile>
#include <QTextStream>

// This is required to be able to read Qt-embedded paths

static std::string readGuidDatabase(const UString &path) {
    QFile guids(path);
    if (guids.open(QFile::ReadOnly | QFile::Text))
        return QTextStream(&guids).readAll().toStdString();
    return std::string {};
}

#else

static std::string readGuidDatabase(const UString &path) {
    std::ifstream guids(path.toLocal8Bit());
    std::stringstream ret;
    if (ret)
        ret << guids.rdbuf();
    return ret.str();
}

#endif

void initGuidDatabase(const UString & path, UINT32* numEntries)
{
    gLocalGuidDatabase.clear();

    std::stringstream file(readGuidDatabase(path));

    while (!file.eof()) {
        std::string line;
        std::getline(file, line);

        // Use sharp symbol as commentary
        if (line.size() == 0 || line[0] == '#')
            continue;

        // GUID and name are comma-separated 
        std::vector<UString> lineParts;
        std::string::size_type prev = 0, curr = 0;
        while ((curr = line.find(',', curr)) != std::string::npos) {
            std::string substring( line.substr(prev, curr-prev) );
            lineParts.push_back(UString(substring.c_str()));
            prev = ++curr;
        }
        lineParts.push_back(UString(line.substr(prev, curr-prev).c_str()));

        if (lineParts.size() < 2)
            continue;

        EFI_GUID guid;
        if (!ustringToGuid(lineParts[0], guid))
            continue;

        gLocalGuidDatabase[guid] = lineParts[1];
    }

    if (numEntries)
        *numEntries = (UINT32)gLocalGuidDatabase.size();
}

UString guidDatabaseLookup(const EFI_GUID & guid)
{
    return gLocalGuidDatabase[guid];
}

#else
void initGuidDatabase(const UString & path, UINT32* numEntries)
{
    U_UNUSED_PARAMETER(path);
    if (numEntries)
        *numEntries = 0;
}

UString guidDatabaseLookup(const EFI_GUID & guid)
{
	U_UNUSED_PARAMETER(guid);
    return UString();
}
#endif

GuidDatabase guidDatabaseFromTreeRecursive(TreeModel * model, const UModelIndex index)
{
    GuidDatabase db;

    if (!index.isValid())
        return db;

    for (int i = 0; i < model->rowCount(index); i++) {
        GuidDatabase tmpDb = guidDatabaseFromTreeRecursive(model, index.child(i, index.column()));
        db.insert(tmpDb.begin(), tmpDb.end());
    }

    if (model->type(index) == Types::File && !model->text(index).isEmpty())
        db[readUnaligned((const EFI_GUID*)model->header(index).left(16).constData())] = model->text(index);

    return db;
}

USTATUS guidDatabaseExportToFile(const UString & outPath, GuidDatabase & db)
{
    std::ofstream outputFile(outPath.toLocal8Bit(), std::ios::out | std::ios::trunc);
    if (!outputFile)
        return U_FILE_OPEN;
    for (GuidDatabase::iterator it = db.begin(); it != db.end(); it++) {
        std::string guid(guidToUString (it->first, false).toLocal8Bit());
        std::string name(it->second.toLocal8Bit());
        outputFile << guid << ',' << name << '\n';
    }

    return U_SUCCESS;
}

```

`efiXloader/3rd/uefitool/common/guiddatabase.h`:

```h
/* guiddatabase.h

Copyright (c) 2017, LongSoft. All rights reserved.
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHWARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
*/

#ifndef GUID_DATABASE_H
#define GUID_DATABASE_H

#include <map>
#include <string>

#include "basetypes.h"
#include "ffs.h"
#include "ffsparser.h"
#include "ustring.h"
#include "utility.h"


struct OperatorLessForGuids {
    bool operator()(const EFI_GUID &lhs, const EFI_GUID &rhs) const {
        return (memcmp(&lhs, &rhs, sizeof(EFI_GUID)) < 0);
    }
};

typedef std::map<EFI_GUID, UString, OperatorLessForGuids> GuidDatabase;

UString guidDatabaseLookup(const EFI_GUID &guid);
void initGuidDatabase(const UString &path = "", UINT32 *numEntries = NULL);
GuidDatabase guidDatabaseFromTreeRecursive(TreeModel *model, const UModelIndex index);
USTATUS guidDatabaseExportToFile(const UString &outPath, GuidDatabase &db);

#endif // GUID_DATABASE_H

```

`efiXloader/3rd/uefitool/common/guids.csv`:

```csv
CSV Schema (1 sample row):
Headers: 00000000-0000-0000-0000-000000000000, ZeroGuid
Sample: "00026AEB-F334-4C15-A7F0-E1E897E9FE91", "NvmeRecovery"
... [3373 more rows omitted]

```

`efiXloader/3rd/uefitool/common/me.h`:

```h
/* me.h

Copyright (c) 2015, Nikolaj Schlej. All rights reserved.
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHWARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
*/

#ifndef ME_H
#define ME_H

#include "basetypes.h"

// Make sure we use right packing rules
#pragma pack(push, 1)

typedef struct ME_VERSION_ {
    UINT32 Signature;
    UINT32 Reserved;
    UINT16 Major;
    UINT16 Minor;
    UINT16 Bugfix;
    UINT16 Build;
} ME_VERSION;

const UByteArray ME_VERSION_SIGNATURE("\x24\x4D\x41\x4E", 4);  //$MAN
const UByteArray ME_VERSION_SIGNATURE2("\x24\x4D\x4E\x32", 4); //$MN2

// FPT
#define ME_ROM_BYPASS_VECTOR_SIZE 0x10
const UByteArray FPT_HEADER_SIGNATURE("\x24\x46\x50\x54", 4); //$FPT

typedef struct FPT_HEADER_ {
    UINT32 Signature;
    UINT32 NumEntries;
    UINT8  HeaderVersion;
    UINT8  EntryVersion;
    UINT8  HeaderLength;
    UINT8  Checksum;      // One bit for Redundant before IFWI
    UINT16 TicksToAdd;
    UINT16 TokensToAdd;
    UINT32 UmaSize;       // Flags in SPS
    UINT32 FlashLayout;   // Crc32 before IFWI
    UINT16 FitcMajor;
    UINT16 FitcMinor;
    UINT16 FitcHotfix;
    UINT16 FitcBuild;
} FPT_HEADER;

typedef struct FPT_HEADER_ENTRY_{
    CHAR8  Name[4];
    CHAR8  Owner[4];
    UINT32 Offset;
    UINT32 Size;
    UINT32 Reserved[3];
    UINT8  Type             : 7;
    UINT8  CopyToDramCache  : 1;
    UINT8  Reserved1        : 7;
    UINT8  BuiltWithLength1 : 1;
    UINT8  BuiltWithLength2 : 1;
    UINT8  Reserved2        : 7;
    UINT8  EntryValid;
} FPT_HEADER_ENTRY;

// IFWI
typedef struct IFWI_HEADER_ENTRY_ {
    UINT32 Offset;
    UINT32 Size;
} IFWI_HEADER_ENTRY;

// IFWI 1.6 (ME), 2.0 (BIOS)
typedef struct IFWI_16_LAYOUT_HEADER_ {
    UINT8             RomBypassVector[16];
    IFWI_HEADER_ENTRY DataPartition;
    IFWI_HEADER_ENTRY BootPartition[5];
    UINT64            Checksum;
} IFWI_16_LAYOUT_HEADER;

// IFWI 1.7 (ME)
typedef struct IFWI_17_LAYOUT_HEADER_ {
    UINT8  RomBypassVector[16];
    UINT16 HeaderSize;
    UINT8  Flags;
    UINT8  Reserved;
    UINT32 Checksum;
    IFWI_HEADER_ENTRY DataPartition;
    IFWI_HEADER_ENTRY BootPartition[5];
    IFWI_HEADER_ENTRY TempPage;
} IFWI_17_LAYOUT_HEADER;

#define ME_MANIFEST_HEADER_ID 0x324E4D24 //$MN2

// Restore previous packing rules
#pragma pack(pop)

#endif // ME_H

```

`efiXloader/3rd/uefitool/common/meparser.cpp`:

```cpp
/* meparser.cpp

Copyright (c) 2019, Nikolaj Schlej. All rights reserved.

This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php.

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

*/

#include <inttypes.h>
#include <map>

#include "ffs.h"
#include "me.h"
#include "meparser.h"
#include "parsingdata.h"
#include "utility.h"

#ifdef U_ENABLE_ME_PARSING_SUPPORT

struct FPT_PARTITION_INFO {
    FPT_HEADER_ENTRY ptEntry;
    UINT8 type;
    UModelIndex index;
    friend bool operator< (const FPT_PARTITION_INFO & lhs, const FPT_PARTITION_INFO & rhs){ return lhs.ptEntry.Offset < rhs.ptEntry.Offset; }
};

struct IFWI_PARTITION_INFO {
    IFWI_HEADER_ENTRY ptEntry;
    UINT8 type;
    UINT8 subtype;
    friend bool operator< (const IFWI_PARTITION_INFO & lhs, const IFWI_PARTITION_INFO & rhs){ return lhs.ptEntry.Offset < rhs.ptEntry.Offset; }
};

USTATUS MeParser::parseMeRegionBody(const UModelIndex & index)
{
    // Sanity check
    if (!index.isValid())
        return U_INVALID_PARAMETER;

    // Obtain ME region
    UByteArray meRegion = model->body(index);

    // Check region size
    if ((UINT32)meRegion.size() < ME_ROM_BYPASS_VECTOR_SIZE + sizeof(UINT32)) {
        msg(usprintf("%s: ME region too small to fit ROM bypass vector", __FUNCTION__), index);
        return U_INVALID_ME_PARTITION_TABLE;
    }

    // Check ME signature to determine it's version
    // ME v11 and older layout
    if (meRegion.left(sizeof(UINT32)) == FPT_HEADER_SIGNATURE || meRegion.mid(ME_ROM_BYPASS_VECTOR_SIZE, sizeof(UINT32)) == FPT_HEADER_SIGNATURE) {
        UModelIndex ptIndex;
        return parseFptRegion(meRegion, index, ptIndex);
    }

    // IFWI 1.6
    // Check region size
    if ((UINT32)meRegion.size() < sizeof(IFWI_16_LAYOUT_HEADER)) {
        msg(usprintf("%s: ME region too small to fit IFWI 1.6 layout header", __FUNCTION__), index);
        return U_INVALID_ME_PARTITION_TABLE;
    }

    const IFWI_16_LAYOUT_HEADER* ifwi16Header = (const IFWI_16_LAYOUT_HEADER*)meRegion.constData();
    // Check region size
    if ((UINT32)meRegion.size() < ifwi16Header->DataPartition.Offset + sizeof(UINT32)) {
        msg(usprintf("%s: ME region too small to fit IFWI 1.6 data partition", __FUNCTION__), index);
        return U_INVALID_ME_PARTITION_TABLE;
    }
    // Data partition always points to FPT header
    if (meRegion.mid(ifwi16Header->DataPartition.Offset, sizeof(UINT32)) == FPT_HEADER_SIGNATURE) {
        UModelIndex ptIndex;
        return parseIfwi16Region(meRegion, index, ptIndex);
    }

    // IFWI 1.7
    if ((UINT32)meRegion.size() < sizeof(IFWI_17_LAYOUT_HEADER)) {
        msg(usprintf("%s: ME region too small to fit IFWI 1.7 layout header", __FUNCTION__), index);
        return U_INVALID_ME_PARTITION_TABLE;
    }
    
    const IFWI_17_LAYOUT_HEADER* ifwi17Header = (const IFWI_17_LAYOUT_HEADER*)meRegion.constData();
    // Check region size
    if ((UINT32)meRegion.size() < ifwi17Header->DataPartition.Offset + sizeof(UINT32)) {
        msg(usprintf("%s: ME region too small to fit IFWI 1.7 data partition", __FUNCTION__), index);
        return U_INVALID_ME_PARTITION_TABLE;
    }
    // Data partition always points to FPT header
    if (meRegion.mid(ifwi17Header->DataPartition.Offset, sizeof(UINT32)) == FPT_HEADER_SIGNATURE) {
        UModelIndex ptIndex;
        return parseIfwi17Region(meRegion, index, ptIndex);
    }

    // Something else entirely
    msg(usprintf("%s: unknown ME region format", __FUNCTION__), index);
    return U_INVALID_ME_PARTITION_TABLE;
}

USTATUS MeParser::parseFptRegion(const UByteArray & region, const UModelIndex & parent, UModelIndex & index)
{
    // Check region size
    if ((UINT32)region.size() < sizeof(FPT_HEADER)) {
        msg(usprintf("%s: region too small to fit FPT header", __FUNCTION__), parent);
        return U_INVALID_ME_PARTITION_TABLE;
    }
    
    // Populate partition table header
    const FPT_HEADER* ptHeader = (const FPT_HEADER*)region.constData();
    UINT32 romBypassVectorSize = 0;
    if (region.left(sizeof(UINT32)) != FPT_HEADER_SIGNATURE) {
        // Adjust the header to skip ROM bypass vector
        romBypassVectorSize = ME_ROM_BYPASS_VECTOR_SIZE;
        ptHeader = (const FPT_HEADER*)(region.constData() + romBypassVectorSize);
    }
    
    // Check region size again
    UINT32 ptBodySize = ptHeader->NumEntries * sizeof(FPT_HEADER_ENTRY);
    UINT32 ptSize = romBypassVectorSize + sizeof(FPT_HEADER) + ptBodySize;
    if ((UINT32)region.size() < ptSize) {
        msg(usprintf("%s: ME region too small to fit partition table", __FUNCTION__), parent);
        return U_INVALID_ME_PARTITION_TABLE;
    }
    
    // Recalculate checksum
    UByteArray tempHeader = UByteArray((const char*)ptHeader, sizeof(FPT_HEADER));
    FPT_HEADER* tempPtHeader = (FPT_HEADER*)tempHeader.data();
    tempPtHeader->Checksum = 0;
    UINT8 calculated = calculateChecksum8((const UINT8*)tempPtHeader, sizeof(FPT_HEADER));
    bool msgInvalidPtHeaderChecksum = (calculated != ptHeader->Checksum);
    
    // Get info
    UByteArray header = region.left(romBypassVectorSize + sizeof(FPT_HEADER));
    UByteArray body = region.mid(header.size(), ptBodySize);
    
    UString name = UString("FPT partition table");
    UString info = usprintf("Full size: %Xh (%u)\nHeader size: %Xh (%u)\nBody size: %Xh (%u)\nNumber of entries: %u\nHeader version: %02Xh\nEntry version: %02Xh\n"
                            "Header length: %02Xh\nTicks to add: %04Xh\nTokens to add: %04Xh\nUMA size: %Xh\nFlash layout: %Xh\nFITC version: %u.%u.%u.%u\nChecksum: %02Xh, ",
                            ptSize, ptSize,
                            header.size(), header.size(),
                            ptBodySize, ptBodySize,
                            ptHeader->NumEntries,
                            ptHeader->HeaderVersion,
                            ptHeader->EntryVersion,
                            ptHeader->HeaderLength,
                            ptHeader->TicksToAdd,
                            ptHeader->TokensToAdd,
                            ptHeader->UmaSize,
                            ptHeader->FlashLayout,
                            ptHeader->FitcMajor, ptHeader->FitcMinor, ptHeader->FitcHotfix, ptHeader->FitcBuild,
                            ptHeader->Checksum) + (ptHeader->Checksum == calculated ? UString("valid") : usprintf("invalid, should be %02Xh", calculated));
    
    // Add tree item
    index = model->addItem(0, Types::FptStore, 0, name, UString(), info, header, body, UByteArray(), Fixed, parent);
    
    // Show messages
    if (msgInvalidPtHeaderChecksum) {
        msg(usprintf("%s: FPT partition table header checksum is invalid", __FUNCTION__), index);
    }

    // Add partition table entries
    std::vector<FPT_PARTITION_INFO> partitions;
    UINT32 offset = header.size();
    const FPT_HEADER_ENTRY* firstPtEntry = (const FPT_HEADER_ENTRY*)(region.constData() + offset);
    for (UINT8 i = 0; i < ptHeader->NumEntries; i++) {
        // Populate entry header
        const FPT_HEADER_ENTRY* ptEntry = firstPtEntry + i;
        
        // Get info
        name = usprintf("%c%c%c%c", ptEntry->Name[0], ptEntry->Name[1], ptEntry->Name[2], ptEntry->Name[3]);
        info = usprintf("Full size: %Xh (%u)\nPartition offset: %Xh\nPartition length: %Xh\nPartition type: %02Xh",
                        sizeof(FPT_HEADER_ENTRY), sizeof(FPT_HEADER_ENTRY),
                        ptEntry->Offset,
                        ptEntry->Size,
                        ptEntry->Type);
        
        // Add tree item
        const UINT8 type = (ptEntry->Offset != 0 && ptEntry->Offset != 0xFFFFFFFF && ptEntry->Size != 0 && ptEntry->EntryValid != 0xFF) ? Subtypes::ValidFptEntry : Subtypes::InvalidFptEntry;
        UModelIndex entryIndex = model->addItem(offset, Types::FptEntry, type, name, UString(), info, UByteArray(), UByteArray((const char*)ptEntry, sizeof(FPT_HEADER_ENTRY)), UByteArray(), Fixed, index);
        
        // Adjust offset
        offset += sizeof(FPT_HEADER_ENTRY);
        
        // Add valid partitions
        if (type == Subtypes::ValidFptEntry) { // Skip absent and invalid partitions
            // Add to partitions vector
            FPT_PARTITION_INFO partition;
            partition.type = Types::FptPartition;
            partition.ptEntry = *ptEntry;
            partition.index = entryIndex;
            partitions.push_back(partition);
        }
    }

make_partition_table_consistent:
    // Sort partitions by offset
    std::sort(partitions.begin(), partitions.end());
    
    // Check for intersections and paddings between partitions
    FPT_PARTITION_INFO padding;
    
    // Check intersection with the partition table header
    if (partitions.front().ptEntry.Offset < ptSize) {
        msg(usprintf("%s: ME partition has intersection with ME partition table, skipped", __FUNCTION__),
            partitions.front().index);
        partitions.erase(partitions.begin());
        goto make_partition_table_consistent;
    }
    // Check for padding between partition table and the first partition
    else if (partitions.front().ptEntry.Offset > ptSize) {
        padding.ptEntry.Offset = ptSize;
        padding.ptEntry.Size = partitions.front().ptEntry.Offset - ptSize;
        padding.type = Types::Padding;
        partitions.insert(partitions.begin(), padding);
    }
    // Check for intersections/paddings between partitions
    for (size_t i = 1; i < partitions.size(); i++) {
        UINT32 previousPartitionEnd = partitions[i - 1].ptEntry.Offset + partitions[i - 1].ptEntry.Size;
        
        // Check that current region is fully present in the image
        if ((UINT32)partitions[i].ptEntry.Offset + (UINT32)partitions[i].ptEntry.Size > (UINT32)region.size()) {
            if ((UINT32)partitions[i].ptEntry.Offset >= (UINT32)region.size()) {
                msg(usprintf("%s: FPT partition is located outside of the opened image, skipped", __FUNCTION__), partitions[i].index);
                partitions.erase(partitions.begin() + i);
                goto make_partition_table_consistent;
            }
            else {
                msg(usprintf("%s: FPT partition can't fit into the region, truncated", __FUNCTION__), partitions[i].index);
                partitions[i].ptEntry.Size = (UINT32)region.size() - (UINT32)partitions[i].ptEntry.Offset;
            }
        }

        // Check for intersection with previous partition
        if (partitions[i].ptEntry.Offset < previousPartitionEnd) {
            // Check if current partition is located inside previous one
            if (partitions[i].ptEntry.Offset + partitions[i].ptEntry.Size <= previousPartitionEnd) {
                msg(usprintf("%s: FPT partition is located inside another FPT partition, skipped", __FUNCTION__),
                    partitions[i].index);
                partitions.erase(partitions.begin() + i);
                goto make_partition_table_consistent;
            }
            else {
                msg(usprintf("%s: FPT partition intersects with previous one, skipped", __FUNCTION__),
                    partitions[i].index);
                partitions.erase(partitions.begin() + i);
                goto make_partition_table_consistent;
            }
        }
        
        // Check for padding between current and previous partitions
        else if (partitions[i].ptEntry.Offset > previousPartitionEnd) {
            padding.ptEntry.Offset = previousPartitionEnd;
            padding.ptEntry.Size = partitions[i].ptEntry.Offset - previousPartitionEnd;
            padding.type = Types::Padding;
            std::vector<FPT_PARTITION_INFO>::iterator iter = partitions.begin();
            std::advance(iter, i);
            partitions.insert(iter, padding);
        }
    }
    // Check for padding after the last region
    if ((UINT32)partitions.back().ptEntry.Offset + (UINT32)partitions.back().ptEntry.Size < (UINT32)region.size()) {
        padding.ptEntry.Offset = partitions.back().ptEntry.Offset + partitions.back().ptEntry.Size;
        padding.ptEntry.Size = region.size() - padding.ptEntry.Offset;
        padding.type = Types::Padding;
        partitions.push_back(padding);
    }
    
    // Partition map is consistent
    for (size_t i = 0; i < partitions.size(); i++) {
        UByteArray partition = region.mid(partitions[i].ptEntry.Offset, partitions[i].ptEntry.Size);
        if (partitions[i].type == Types::FptPartition) {
            UModelIndex partitionIndex;
            // Get info
            name = usprintf("%c%c%c%c", partitions[i].ptEntry.Name[0], partitions[i].ptEntry.Name[1], partitions[i].ptEntry.Name[2], partitions[i].ptEntry.Name[3]);
            info = usprintf("Full size: %Xh (%u)\nPartition type: %02Xh\n",
                partition.size(), partition.size(),
                partitions[i].ptEntry.Type);

            // Add tree item
            UINT8 type = Subtypes::CodeFptPartition + partitions[i].ptEntry.Type;
            partitionIndex = model->addItem(partitions[i].ptEntry.Offset, Types::FptPartition, type, name, UString(), info, UByteArray(), partition, UByteArray(), Fixed, parent);
            if (type == Subtypes::CodeFptPartition && partition.size() >= (int) sizeof(UINT32) && readUnaligned((const UINT32*)partition.constData()) == CPD_SIGNATURE) {
                // Parse code partition contents
                UModelIndex cpdIndex;
                ffsParser->parseCpdRegion(partition, partitions[i].ptEntry.Offset, partitionIndex, cpdIndex);
            }
        }
        else if (partitions[i].type == Types::Padding) {
            // Get info
            name = UString("Padding");
            info = usprintf("Full size: %Xh (%u)", partition.size(), partition.size());
            
            // Add tree item
            model->addItem(partitions[i].ptEntry.Offset, Types::Padding, getPaddingType(partition), name, UString(), info, UByteArray(), partition, UByteArray(), Fixed, parent);
        }
    }
    
    return U_SUCCESS;
}

USTATUS MeParser::parseIfwi16Region(const UByteArray & region, const UModelIndex & parent, UModelIndex & index)
{
    // Check region size again
    if ((UINT32)region.size() < sizeof(IFWI_16_LAYOUT_HEADER)) {
        msg(usprintf("%s: ME region too small to fit IFWI 1.6 layout header", __FUNCTION__), parent);
        return U_INVALID_ME_PARTITION_TABLE;
    }
    
    const IFWI_16_LAYOUT_HEADER* ifwiHeader = (const IFWI_16_LAYOUT_HEADER*)region.constData();
    
    // Add header
    UINT32 ptSize = sizeof(IFWI_16_LAYOUT_HEADER);
    UByteArray header = region.left(ptSize);
    
    UString name = UString("IFWI 1.6 header");
    UString info = usprintf("Full size: %Xh (%u)\n"
                            "Data  partition offset: %Xh\nData  partition size:   %Xh\n"
                            "Boot1 partition offset: %Xh\nBoot1 partition size:   %Xh\n"
                            "Boot2 partition offset: %Xh\nBoot2 partition size:   %Xh\n"
                            "Boot3 partition offset: %Xh\nBoot3 partition size:   %Xh\n"
                            "Boot4 partition offset: %Xh\nBoot4 partition size:   %Xh\n"
                            "Boot5 partition offset: %Xh\nBoot5 partition size:   %Xh\n"
                            "Checksum: %Xh",
                            header.size(), header.size(),
                            ifwiHeader->DataPartition.Offset, ifwiHeader->DataPartition.Size,
                            ifwiHeader->BootPartition[0].Offset, ifwiHeader->BootPartition[0].Size,
                            ifwiHeader->BootPartition[1].Offset, ifwiHeader->BootPartition[1].Size,
                            ifwiHeader->BootPartition[2].Offset, ifwiHeader->BootPartition[2].Size,
                            ifwiHeader->BootPartition[3].Offset, ifwiHeader->BootPartition[3].Size,
                            ifwiHeader->BootPartition[4].Offset, ifwiHeader->BootPartition[4].Size,
                            ifwiHeader->Checksum);
    // Add tree item
    index = model->addItem(0, Types::IfwiHeader, 0, name, UString(), info, UByteArray(), header, UByteArray(), Fixed, parent);
    
    std::vector<IFWI_PARTITION_INFO> partitions;
    // Add data partition
    {
        IFWI_PARTITION_INFO partition;
        partition.type = Types::IfwiPartition;
        partition.subtype = Subtypes::DataIfwiPartition;
        partition.ptEntry = ifwiHeader->DataPartition;
        partitions.push_back(partition);
    }
    // Add boot partitions
    for (UINT8 i = 0 ; i < 4; i++) {
        if (ifwiHeader->BootPartition[i].Offset != 0 && ifwiHeader->BootPartition[i].Offset != 0xFFFFFFFF) {
            IFWI_PARTITION_INFO partition;
            partition.type = Types::IfwiPartition;
            partition.subtype = Subtypes::BootIfwiPartition;
            partition.ptEntry = ifwiHeader->BootPartition[i];
            partitions.push_back(partition);
        }
    }

make_partition_table_consistent:
    // Sort partitions by offset
    std::sort(partitions.begin(), partitions.end());
    
    // Check for intersections and paddings between partitions
    IFWI_PARTITION_INFO padding;
    
    // Check intersection with the partition table header
    if (partitions.front().ptEntry.Offset < ptSize) {
        msg(usprintf("%s: IFWI partition has intersection with IFWI layout header, skipped", __FUNCTION__), index);
        partitions.erase(partitions.begin());
        goto make_partition_table_consistent;
    }
    // Check for padding between partition table and the first partition
    else if (partitions.front().ptEntry.Offset > ptSize) {
        padding.ptEntry.Offset = ptSize;
        padding.ptEntry.Size = partitions.front().ptEntry.Offset - ptSize;
        padding.type = Types::Padding;
        partitions.insert(partitions.begin(), padding);
    }
    // Check for intersections/paddings between partitions
    for (size_t i = 1; i < partitions.size(); i++) {
        UINT32 previousPartitionEnd = partitions[i - 1].ptEntry.Offset + partitions[i - 1].ptEntry.Size;
        
        // Check that current region is fully present in the image
        if ((UINT32)partitions[i].ptEntry.Offset + (UINT32)partitions[i].ptEntry.Size > (UINT32)region.size()) {
            if ((UINT32)partitions[i].ptEntry.Offset >= (UINT32)region.size()) {
                msg(usprintf("%s: IFWI partition is located outside of the opened image, skipped", __FUNCTION__), index);
                partitions.erase(partitions.begin() + i);
                goto make_partition_table_consistent;
            }
            else {
                msg(usprintf("%s: IFWI partition can't fit into the region, truncated", __FUNCTION__), index);
                partitions[i].ptEntry.Size = (UINT32)region.size() - (UINT32)partitions[i].ptEntry.Offset;
            }
        }
        
        // Check for intersection with previous partition
        if (partitions[i].ptEntry.Offset < previousPartitionEnd) {
            // Check if current partition is located inside previous one
            if (partitions[i].ptEntry.Offset + partitions[i].ptEntry.Size <= previousPartitionEnd) {
                msg(usprintf("%s: IFWI partition is located inside another IFWI partition, skipped", __FUNCTION__), index);
                partitions.erase(partitions.begin() + i);
                goto make_partition_table_consistent;
            }
            else {
                msg(usprintf("%s: IFWI partition intersects with previous one, skipped", __FUNCTION__), index);
                partitions.erase(partitions.begin() + i);
                goto make_partition_table_consistent;
            }
        }
        
        // Check for padding between current and previous partitions
        else if (partitions[i].ptEntry.Offset > previousPartitionEnd) {
            padding.ptEntry.Offset = previousPartitionEnd;
            padding.ptEntry.Size = partitions[i].ptEntry.Offset - previousPartitionEnd;
            padding.type = Types::Padding;
            std::vector<IFWI_PARTITION_INFO>::iterator iter = partitions.begin();
            std::advance(iter, i);
            partitions.insert(iter, padding);
        }
    }
    // Check for padding after the last region
    if ((UINT32)partitions.back().ptEntry.Offset + (UINT32)partitions.back().ptEntry.Size < (UINT32)region.size()) {
        padding.ptEntry.Offset = partitions.back().ptEntry.Offset + partitions.back().ptEntry.Size;
        padding.ptEntry.Size = region.size() - padding.ptEntry.Offset;
        padding.type = Types::Padding;
        partitions.push_back(padding);
    }
    
    // Partition map is consistent
    for (size_t i = 0; i < partitions.size(); i++) {
        UByteArray partition = region.mid(partitions[i].ptEntry.Offset, partitions[i].ptEntry.Size);
        if (partitions[i].type == Types::IfwiPartition) {
            UModelIndex partitionIndex;
            if (partitions[i].subtype == Subtypes::DataIfwiPartition) {
                name = "Data partition";
            }
            else if (partitions[i].subtype == Subtypes::BootIfwiPartition) {
                name = "Boot partition";
            }
            
            // Get info
            info = usprintf("Full size: %Xh (%u)\n",
                            partition.size(), partition.size());
            
            // Add tree item
            partitionIndex = model->addItem(partitions[i].ptEntry.Offset, partitions[i].type, partitions[i].subtype, name, UString(), info, UByteArray(), partition, UByteArray(), Fixed, parent);
            
            // Parse partition further
            if (partitions[i].subtype == Subtypes::DataIfwiPartition) {
                UModelIndex dataPartitionFptRegionIndex;
                parseFptRegion(partition, partitionIndex, dataPartitionFptRegionIndex);
            }
            else if (partitions[i].subtype == Subtypes::BootIfwiPartition) {
                // Parse code partition contents
                UModelIndex bootPartitionBpdtRegionIndex;
                ffsParser->parseBpdtRegion(partition, 0, 0, partitionIndex, bootPartitionBpdtRegionIndex);
            }
        }
        else if (partitions[i].type == Types::Padding) {
            // Get info
            name = UString("Padding");
            info = usprintf("Full size: %Xh (%u)", partition.size(), partition.size());
            
            // Add tree item
            model->addItem(partitions[i].ptEntry.Offset, Types::Padding, getPaddingType(partition), name, UString(), info, UByteArray(), partition, UByteArray(), Fixed, parent);
        }
    }

    return U_SUCCESS;
}

USTATUS MeParser::parseIfwi17Region(const UByteArray & region, const UModelIndex & parent, UModelIndex & index)
{
    // Check region size again
    if ((UINT32)region.size() < sizeof(IFWI_17_LAYOUT_HEADER)) {
        msg(usprintf("%s: ME region too small to fit IFWI 1.7 layout header", __FUNCTION__), parent);
        return U_INVALID_ME_PARTITION_TABLE;
    }
    
    const IFWI_17_LAYOUT_HEADER* ifwiHeader = (const IFWI_17_LAYOUT_HEADER*)region.constData();
    // TODO: add check for HeaderSize to be 0x40
    
    // Add header
    UINT32 ptSize = sizeof(IFWI_17_LAYOUT_HEADER);
    UByteArray header = region.left(ptSize);
    
    UString name = UString("IFWI 1.7 header");
    UString info = usprintf("Full size: %Xh (%u)\n"
                            "Flags: %02Xh\n"
                            "Reserved: %02Xh\n"
                            "Checksum: %Xh\n"
                            "Data  partition offset: %Xh\nData  partition size:   %Xh\n"
                            "Boot1 partition offset: %Xh\nBoot1 partition size:   %Xh\n"
                            "Boot2 partition offset: %Xh\nBoot2 partition size:   %Xh\n"
                            "Boot3 partition offset: %Xh\nBoot3 partition size:   %Xh\n"
                            "Boot4 partition offset: %Xh\nBoot4 partition size:   %Xh\n"
                            "Boot5 partition offset: %Xh\nBoot5 partition size:   %Xh\n"
                            "Temp page offset:       %Xh\nTemp page size:         %Xh\n",
                            header.size(), header.size(),
                            ifwiHeader->Flags,
                            ifwiHeader->Reserved,
                            ifwiHeader->Checksum,
                            ifwiHeader->DataPartition.Offset, ifwiHeader->DataPartition.Size,
                            ifwiHeader->BootPartition[0].Offset, ifwiHeader->BootPartition[0].Size,
                            ifwiHeader->BootPartition[1].Offset, ifwiHeader->BootPartition[1].Size,
                            ifwiHeader->BootPartition[2].Offset, ifwiHeader->BootPartition[2].Size,
                            ifwiHeader->BootPartition[3].Offset, ifwiHeader->BootPartition[3].Size,
                            ifwiHeader->BootPartition[4].Offset, ifwiHeader->BootPartition[4].Size,
                            ifwiHeader->TempPage.Offset, ifwiHeader->TempPage.Size);
    // Add tree item
    index = model->addItem(0, Types::IfwiHeader, 0, name, UString(), info, UByteArray(), header, UByteArray(), Fixed, parent);
    
    std::vector<IFWI_PARTITION_INFO> partitions;
    // Add data partition
    {
        IFWI_PARTITION_INFO partition;
        partition.type = Types::IfwiPartition;
        partition.subtype = Subtypes::DataIfwiPartition;
        partition.ptEntry = ifwiHeader->DataPartition;
        partitions.push_back(partition);
    }
    // Add boot partitions
    for (UINT8 i = 0 ; i < 4; i++) {
        if (ifwiHeader->BootPartition[i].Offset != 0 && ifwiHeader->BootPartition[i].Offset != 0xFFFFFFFF) {
            IFWI_PARTITION_INFO partition;
            partition.type = Types::IfwiPartition;
            partition.subtype = Subtypes::BootIfwiPartition;
            partition.ptEntry = ifwiHeader->BootPartition[i];
            partitions.push_back(partition);
        }
    }
    // Add temp page
    if (ifwiHeader->TempPage.Offset != 0 && ifwiHeader->TempPage.Offset != 0xFFFFFFFF) {
        IFWI_PARTITION_INFO partition;
        partition.type = Types::IfwiPartition;
        partition.subtype = Subtypes::DataPadding;
        partition.ptEntry = ifwiHeader->TempPage;
        partitions.push_back(partition);
    }
    
make_partition_table_consistent:
    // Sort partitions by offset
    std::sort(partitions.begin(), partitions.end());
    
    // Check for intersections and paddings between partitions
    IFWI_PARTITION_INFO padding;
    
    // Check intersection with the partition table header
    if (partitions.front().ptEntry.Offset < ptSize) {
        msg(usprintf("%s: IFWI partition has intersection with IFWI layout header, skipped", __FUNCTION__), index);
        partitions.erase(partitions.begin());
        goto make_partition_table_consistent;
    }
    // Check for padding between partition table and the first partition
    else if (partitions.front().ptEntry.Offset > ptSize) {
        padding.ptEntry.Offset = ptSize;
        padding.ptEntry.Size = partitions.front().ptEntry.Offset - ptSize;
        padding.type = Types::Padding;
        partitions.insert(partitions.begin(), padding);
    }
    // Check for intersections/paddings between partitions
    for (size_t i = 1; i < partitions.size(); i++) {
        UINT32 previousPartitionEnd = partitions[i - 1].ptEntry.Offset + partitions[i - 1].ptEntry.Size;
        
        // Check that current region is fully present in the image
        if ((UINT32)partitions[i].ptEntry.Offset + (UINT32)partitions[i].ptEntry.Size > (UINT32)region.size()) {
            if ((UINT32)partitions[i].ptEntry.Offset >= (UINT32)region.size()) {
                msg(usprintf("%s: IFWI partition is located outside of the opened image, skipped", __FUNCTION__), index);
                partitions.erase(partitions.begin() + i);
                goto make_partition_table_consistent;
            }
            else {
                msg(usprintf("%s: IFWI partition can't fit into the region, truncated", __FUNCTION__), index);
                partitions[i].ptEntry.Size = (UINT32)region.size() - (UINT32)partitions[i].ptEntry.Offset;
            }
        }
        
        // Check for intersection with previous partition
        if (partitions[i].ptEntry.Offset < previousPartitionEnd) {
            // Check if current partition is located inside previous one
            if (partitions[i].ptEntry.Offset + partitions[i].ptEntry.Size <= previousPartitionEnd) {
                msg(usprintf("%s: IFWI partition is located inside another IFWI partition, skipped", __FUNCTION__), index);
                partitions.erase(partitions.begin() + i);
                goto make_partition_table_consistent;
            }
            else {
                msg(usprintf("%s: IFWI partition intersects with previous one, skipped", __FUNCTION__), index);
                partitions.erase(partitions.begin() + i);
                goto make_partition_table_consistent;
            }
        }
        
        // Check for padding between current and previous partitions
        else if (partitions[i].ptEntry.Offset > previousPartitionEnd) {
            padding.ptEntry.Offset = previousPartitionEnd;
            padding.ptEntry.Size = partitions[i].ptEntry.Offset - previousPartitionEnd;
            padding.type = Types::Padding;
            std::vector<IFWI_PARTITION_INFO>::iterator iter = partitions.begin();
            std::advance(iter, i);
            partitions.insert(iter, padding);
        }
    }
    // Check for padding after the last region
    if ((UINT32)partitions.back().ptEntry.Offset + (UINT32)partitions.back().ptEntry.Size < (UINT32)region.size()) {
        padding.ptEntry.Offset = partitions.back().ptEntry.Offset + partitions.back().ptEntry.Size;
        padding.ptEntry.Size = region.size() - padding.ptEntry.Offset;
        padding.type = Types::Padding;
        partitions.push_back(padding);
    }
    
    // Partition map is consistent
    for (size_t i = 0; i < partitions.size(); i++) {
        UByteArray partition = region.mid(partitions[i].ptEntry.Offset, partitions[i].ptEntry.Size);
        if (partitions[i].type == Types::IfwiPartition) {
            UModelIndex partitionIndex;
            if (partitions[i].subtype == Subtypes::DataIfwiPartition) {
                name = "Data partition";
                
            }
            else if (partitions[i].subtype == Subtypes::BootIfwiPartition){
                name = "Boot partition";
            }
            else {
                name = "Temp page";
            }
            
            // Get info
            info = usprintf("Full size: %Xh (%u)\n",
                            partition.size(), partition.size());
            
            // Add tree item
            partitionIndex = model->addItem(partitions[i].ptEntry.Offset, partitions[i].type, partitions[i].subtype, name, UString(), info, UByteArray(), partition, UByteArray(), Fixed, parent);
            
            // Parse partition further
            if (partitions[i].subtype == Subtypes::DataIfwiPartition) {
                UModelIndex dataPartitionFptRegionIndex;
                parseFptRegion(partition, partitionIndex, dataPartitionFptRegionIndex);
            }
            else if (partitions[i].subtype == Subtypes::BootIfwiPartition) {
                // Parse code partition contents
                UModelIndex bootPartitionBpdtRegionIndex;
                ffsParser->parseBpdtRegion(partition, 0, 0, partitionIndex, bootPartitionBpdtRegionIndex);
            }
        }
        else if (partitions[i].type == Types::Padding) {
            // Get info
            name = UString("Padding");
            info = usprintf("Full size: %Xh (%u)", partition.size(), partition.size());
            
            // Add tree item
            model->addItem(partitions[i].ptEntry.Offset, Types::Padding, getPaddingType(partition), name, UString(), info, UByteArray(), partition, UByteArray(), Fixed, parent);
        }
    }
    
    return U_SUCCESS;
}

#endif // U_ENABLE_ME_PARSING_SUPPORT


```

`efiXloader/3rd/uefitool/common/meparser.h`:

```h
/* meparser.h

Copyright (c) 2016, Nikolaj Schlej. All rights reserved.

This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php.

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

*/

#ifndef MEPARSER_H
#define MEPARSER_H

#include <vector>

#include "basetypes.h"
#include "ustring.h"
#include "ubytearray.h"
#include "treemodel.h"
#include "ffsparser.h"
#include "sha256.h"

#ifdef U_ENABLE_ME_PARSING_SUPPORT
class MeParser 
{
public:
    // Default constructor and destructor
    MeParser(TreeModel* treeModel, FfsParser* parser) : model(treeModel), ffsParser(parser) {}
    ~MeParser() {}

    // Returns messages 
    std::vector<std::pair<UString, UModelIndex> > getMessages() const { return messagesVector; }
    // Clears messages
    void clearMessages() { messagesVector.clear(); }

    // ME parsing
    USTATUS parseMeRegionBody(const UModelIndex & index);
private:
    TreeModel *model;
    FfsParser *ffsParser;
    std::vector<std::pair<UString, UModelIndex> > messagesVector;

    void msg(const UString message, const UModelIndex index = UModelIndex()) {
        messagesVector.push_back(std::pair<UString, UModelIndex>(message, index));
    }

    USTATUS parseFptRegion(const UByteArray & region, const UModelIndex & parent, UModelIndex & index);
    USTATUS parseIfwi16Region(const UByteArray & region, const UModelIndex & parent, UModelIndex & index);
    USTATUS parseIfwi17Region(const UByteArray & region, const UModelIndex & parent, UModelIndex & index);
};
#else
class MeParser 
{
public:
    // Default constructor and destructor
    MeParser(TreeModel* treeModel, FfsParser* parser) { U_UNUSED_PARAMETER(treeModel); U_UNUSED_PARAMETER(parser); }
    ~MeParser() {}

    // Returns messages 
    std::vector<std::pair<UString, UModelIndex> > getMessages() const { return std::vector<std::pair<UString, UModelIndex> >(); }
    // Clears messages
    void clearMessages() {}

    // ME parsing
    USTATUS parseMeRegionBody(const UModelIndex & index) { U_UNUSED_PARAMETER(index); return U_SUCCESS; }
};
#endif // U_ENABLE_ME_PARSING_SUPPORT
#endif // MEPARSER_H

```

`efiXloader/3rd/uefitool/common/nvram.cpp`:

```cpp
/* nvram.cpp
Copyright (c) 2016, Nikolaj Schlej. All rights reserved.

This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php.

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

*/

#include "nvram.h"

UString nvarAttributesToUString(const UINT8 attributes)
{
    if (attributes == 0x00 || attributes == 0xFF) 
        return UString();

    UString str;
    if (attributes & NVRAM_NVAR_ENTRY_RUNTIME)         str += UString(", Runtime");
    if (attributes & NVRAM_NVAR_ENTRY_ASCII_NAME)      str += UString(", AsciiName");
    if (attributes & NVRAM_NVAR_ENTRY_GUID)            str += UString(", Guid");
    if (attributes & NVRAM_NVAR_ENTRY_DATA_ONLY)       str += UString(", DataOnly");
    if (attributes & NVRAM_NVAR_ENTRY_EXT_HEADER)      str += UString(", ExtHeader");
    if (attributes & NVRAM_NVAR_ENTRY_HW_ERROR_RECORD) str += UString(", HwErrorRecord");
    if (attributes & NVRAM_NVAR_ENTRY_AUTH_WRITE)      str += UString(", AuthWrite");
    if (attributes & NVRAM_NVAR_ENTRY_VALID)           str += UString(", Valid");
    
    str.remove(0, 2); // Remove first comma and space
    return str;
}

UString nvarExtendedAttributesToUString(const UINT8 attributes)
{
    UString str;
    if (attributes & NVRAM_NVAR_ENTRY_EXT_CHECKSUM)        str += UString(", Checksum");
    if (attributes & NVRAM_NVAR_ENTRY_EXT_AUTH_WRITE)      str += UString(", AuthWrite");
    if (attributes & NVRAM_NVAR_ENTRY_EXT_TIME_BASED)      str += UString(", TimeBasedAuthWrite");
    if (attributes & NVRAM_NVAR_ENTRY_EXT_UNKNOWN_MASK)    str += UString(", Unknown");

    str.remove(0, 2); // Remove first comma and space
    return str;
}

extern UString vssAttributesToUString(const UINT32 attributes)
{
    UString str;
    if (attributes & NVRAM_VSS_VARIABLE_NON_VOLATILE)                          str += UString(", NonVolatile");
    if (attributes & NVRAM_VSS_VARIABLE_BOOTSERVICE_ACCESS)                    str += UString(", BootService");
    if (attributes & NVRAM_VSS_VARIABLE_RUNTIME_ACCESS)                        str += UString(", Runtime");
    if (attributes & NVRAM_VSS_VARIABLE_HARDWARE_ERROR_RECORD)                 str += UString(", HwErrorRecord");
    if (attributes & NVRAM_VSS_VARIABLE_AUTHENTICATED_WRITE_ACCESS)            str += UString(", AuthWrite");
    if (attributes & NVRAM_VSS_VARIABLE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS) str += UString(", TimeBasedAuthWrite");
    if (attributes & NVRAM_VSS_VARIABLE_APPEND_WRITE)                          str += UString(", AppendWrite");
    if (attributes & NVRAM_VSS_VARIABLE_APPLE_DATA_CHECKSUM)                   str += UString(", AppleChecksum");
    if (attributes & NVRAM_VSS_VARIABLE_UNKNOWN_MASK)                          str += UString(", Unknown");

    str.remove(0, 2); // Remove first comma and space
    return str;
}

UString evsaAttributesToUString(const UINT32 attributes)
{
    UString str;
    if (attributes & NVRAM_EVSA_DATA_NON_VOLATILE)                          str += UString(", NonVolatile");
    if (attributes & NVRAM_EVSA_DATA_BOOTSERVICE_ACCESS)                    str += UString(", BootService");
    if (attributes & NVRAM_EVSA_DATA_RUNTIME_ACCESS)                        str += UString(", Runtime");
    if (attributes & NVRAM_EVSA_DATA_HARDWARE_ERROR_RECORD)                 str += UString(", HwErrorRecord");
    if (attributes & NVRAM_EVSA_DATA_AUTHENTICATED_WRITE_ACCESS)            str += UString(", AuthWrite");
    if (attributes & NVRAM_EVSA_DATA_TIME_BASED_AUTHENTICATED_WRITE_ACCESS) str += UString(", TimeBasedAuthWrite");
    if (attributes & NVRAM_EVSA_DATA_APPEND_WRITE)                          str += UString(", AppendWrite");
    if (attributes & NVRAM_EVSA_DATA_EXTENDED_HEADER)                       str += UString(", ExtendedHeader");
    if (attributes & NVRAM_EVSA_DATA_UNKNOWN_MASK)                          str += UString(", Unknown");

    str.remove(0, 2); // Remove first comma and space
    return str;
}

UString efiTimeToUString(const EFI_TIME & time)
{
    return usprintf("%04u-%02u-%02uT%02u:%02u:%02u.%u",
        time.Year,
        time.Month,
        time.Day,
        time.Hour,
        time.Minute,
        time.Second,
        time.Nanosecond);
}

UString flashMapGuidToUString(const EFI_GUID & guid)
{
    const UByteArray baGuid((const char*)&guid, sizeof(EFI_GUID));
    if (baGuid == NVRAM_PHOENIX_FLASH_MAP_VOLUME_HEADER)        return UString("Volume header");
    if (baGuid == NVRAM_PHOENIX_FLASH_MAP_MICROCODES_GUID)      return UString("Microcodes");
    if (baGuid == NVRAM_PHOENIX_FLASH_MAP_CMDB_GUID)            return UString("CMDB");
    if (baGuid == NVRAM_PHOENIX_FLASH_MAP_PUBKEY1_GUID 
        || baGuid == NVRAM_PHOENIX_FLASH_MAP_PUBKEY2_GUID)      return UString("SLIC pubkey");
    if (baGuid == NVRAM_PHOENIX_FLASH_MAP_MARKER1_GUID 
        || baGuid == NVRAM_PHOENIX_FLASH_MAP_MARKER2_GUID)      return UString("SLIC marker");
    if (baGuid == NVRAM_PHOENIX_FLASH_MAP_EVSA1_GUID
        || baGuid == NVRAM_PHOENIX_FLASH_MAP_EVSA2_GUID
        || baGuid == NVRAM_PHOENIX_FLASH_MAP_EVSA3_GUID
        || baGuid == NVRAM_PHOENIX_FLASH_MAP_EVSA4_GUID
        || baGuid == NVRAM_PHOENIX_FLASH_MAP_EVSA5_GUID
        || baGuid == NVRAM_PHOENIX_FLASH_MAP_EVSA6_GUID
        || baGuid == NVRAM_PHOENIX_FLASH_MAP_EVSA7_GUID)        return UString("EVSA store");
    if (baGuid == NVRAM_PHOENIX_FLASH_MAP_SELF_GUID)            return UString("Flash map");
    return UString("Unknown");
}


```

`efiXloader/3rd/uefitool/common/nvram.h`:

```h
/* nvram.h

Copyright (c) 2016, Nikolaj Schlej. All rights reserved.

This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php.

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

*/

#ifndef NVRAM_H
#define NVRAM_H

#include "basetypes.h"
#include "ubytearray.h"
#include "ustring.h"

// Make sure we use right packing rules
#pragma pack(push, 1)

//
// NVAR store and entry
//

// CEF5B9A3-476D-497F-9FDC-E98143E0422C
const UByteArray NVRAM_NVAR_STORE_FILE_GUID
("\xA3\xB9\xF5\xCE\x6D\x47\x7F\x49\x9F\xDC\xE9\x81\x43\xE0\x42\x2C", 16);

// 9221315B-30BB-46B5-813E-1B1BF4712BD3
const UByteArray NVRAM_NVAR_EXTERNAL_DEFAULTS_FILE_GUID
("\x5B\x31\x21\x92\xBB\x30\xB5\x46\x81\x3E\x1B\x1B\xF4\x71\x2B\xD3", 16);

// 77D3DC50-D42B-4916-AC80-8F469035D150
const UByteArray NVRAM_NVAR_PEI_EXTERNAL_DEFAULTS_FILE_GUID
("\x50\xDC\xD3\x77\x2B\xD4\x16\x49\xAC\x80\x8F\x46\x90\x35\xD1\x50", 16);

// AF516361-B4C5-436E-A7E3-A149A31B1461
const UByteArray NVRAM_NVAR_BB_DEFAULTS_FILE_GUID
("\x61\x63\x51\xAF\xC5\xB4\x6E\x43\xA7\xE3\xA1\x49\xA3\x1B\x14\x61", 16);

extern UString nvarAttributesToUString(const UINT8 attributes);
extern UString nvarExtendedAttributesToUString(const UINT8 attributes);
extern UString efiTimeToUString(const EFI_TIME & time);

typedef struct NVAR_ENTRY_HEADER_ {
    UINT32 Signature;      // NVAR
    UINT16 Size;           // Size of the entry including header
    UINT32 Next : 24;      // Offset to the next entry in a list, or empty if the latest in the list
    UINT32 Attributes : 8; // Attributes
} NVAR_ENTRY_HEADER;

// NVAR signature
#define NVRAM_NVAR_ENTRY_SIGNATURE         0x5241564E

// Attributes
#define NVRAM_NVAR_ENTRY_RUNTIME           0x01
#define NVRAM_NVAR_ENTRY_ASCII_NAME        0x02
#define NVRAM_NVAR_ENTRY_GUID              0x04
#define NVRAM_NVAR_ENTRY_DATA_ONLY         0x08
#define NVRAM_NVAR_ENTRY_EXT_HEADER        0x10
#define NVRAM_NVAR_ENTRY_HW_ERROR_RECORD   0x20
#define NVRAM_NVAR_ENTRY_AUTH_WRITE        0x40
#define NVRAM_NVAR_ENTRY_VALID             0x80

// Extended attributes
#define NVRAM_NVAR_ENTRY_EXT_CHECKSUM      0x01
#define NVRAM_NVAR_ENTRY_EXT_AUTH_WRITE    0x10
#define NVRAM_NVAR_ENTRY_EXT_TIME_BASED    0x20
#define NVRAM_NVAR_ENTRY_EXT_UNKNOWN_MASK  0xCE

//
// TianoCore VSS store and variables
//

// FFF12B8D-7696-4C8B-A985-2747075B4F50
const UByteArray NVRAM_MAIN_STORE_VOLUME_GUID
("\x8D\x2B\xF1\xFF\x96\x76\x8B\x4C\xA9\x85\x27\x47\x07\x5B\x4F\x50", 16);

// 00504624-8A59-4EEB-BD0F-6B36E96128E0
const UByteArray NVRAM_ADDITIONAL_STORE_VOLUME_GUID
("\x24\x46\x50\x00\x59\x8A\xEB\x4E\xBD\x0F\x6B\x36\xE9\x61\x28\xE0", 16);

#define NVRAM_VSS_STORE_SIGNATURE            0x53535624 // $VSS
#define NVRAM_APPLE_SVS_STORE_SIGNATURE      0x53565324 // $SVS
#define NVRAM_APPLE_NSS_STORE_SIGNATURE      0x53534E24 // $NSS
#define NVRAM_APPLE_FSYS_STORE_SIGNATURE     0x73797346 // Fsys
#define NVRAM_APPLE_GAID_STORE_SIGNATURE     0x64696147 // Gaid
#define NVRAM_VSS_VARIABLE_START_ID          0x55AA

// Variable store header flags
#define NVRAM_VSS_VARIABLE_STORE_FORMATTED  0x5a
#define NVRAM_VSS_VARIABLE_STORE_HEALTHY    0xfe

// Variable store status
#define NVRAM_VSS_VARIABLE_STORE_STATUS_RAW     0
#define NVRAM_VSS_VARIABLE_STORE_STATUS_VALID   1
#define NVRAM_VSS_VARIABLE_STORE_STATUS_INVALID 2
#define NVRAM_VSS_VARIABLE_STORE_STATUS_UNKNOWN 3

// Variable store header
typedef struct VSS_VARIABLE_STORE_HEADER_ {
    UINT32  Signature; // $VSS signature
    UINT32  Size;      // Size of variable store, including store header
    UINT8   Format;    // Store format state
    UINT8   State;     // Store health state
    UINT16  Unknown;   // Used in Apple $SVS varstores
    UINT32  : 32;
} VSS_VARIABLE_STORE_HEADER;

// Normal variable header
typedef struct VSS_VARIABLE_HEADER_ {
    UINT16    StartId;    // Variable start marker AA55
    UINT8     State;      // Variable state
    UINT8     Reserved;
    UINT32    Attributes; // Variable attributes
    UINT32    NameSize;   // Size of variable name, stored as null-terminated UCS2 string
    UINT32    DataSize;   // Size of variable data without header and name
    EFI_GUID  VendorGuid; // Variable vendor GUID
} VSS_VARIABLE_HEADER;

// Intel variable header
typedef struct VSS_INTEL_VARIABLE_HEADER_ {
    UINT16    StartId;    // Variable start marker AA55
    UINT8     State;      // Variable state
    UINT8     Reserved;
    UINT32    Attributes; // Variable attributes
    UINT32    TotalSize;  // Size of variable including header
    EFI_GUID  VendorGuid; // Variable vendor GUID
} VSS_INTEL_VARIABLE_HEADER;

// Apple variation of normal variable header, with one new field
typedef struct VSS_APPLE_VARIABLE_HEADER_ {
    UINT16    StartId;    // Variable start marker AA55
    UINT8     State;      // Variable state
    UINT8     Reserved;
    UINT32    Attributes; // Variable attributes
    UINT32    NameSize;   // Size of variable name, stored as null-terminated UCS2 string
    UINT32    DataSize;   // Size of variable data without header and name
    EFI_GUID  VendorGuid; // Variable vendor GUID
    UINT32    DataCrc32;  // CRC32 of the data
} VSS_APPLE_VARIABLE_HEADER;

// Authenticated variable header, used for SecureBoot vars
typedef struct VSS_AUTH_VARIABLE_HEADER_ {
    UINT16    StartId;          // Variable start marker AA55
    UINT8     State;            // Variable state 
    UINT8     Reserved;
    UINT32    Attributes;       // Variable attributes
    UINT64    MonotonicCounter; // Monotonic counter against replay attack
    EFI_TIME  Timestamp;        // Time stamp against replay attack
    UINT32    PubKeyIndex;      // Index in PubKey database
    UINT32    NameSize;         // Size of variable name, stored as null-terminated UCS2 string
    UINT32    DataSize;         // Size of variable data without header and name
    EFI_GUID  VendorGuid;       // Variable vendor GUID
} VSS_AUTH_VARIABLE_HEADER;

// VSS variable states
#define NVRAM_VSS_VARIABLE_IN_DELETED_TRANSITION     0xfe  // Variable is in obsolete transistion
#define NVRAM_VSS_VARIABLE_DELETED                   0xfd  // Variable is obsolete
#define NVRAM_VSS_VARIABLE_HEADER_VALID              0x7f  // Variable has valid header
#define NVRAM_VSS_VARIABLE_ADDED                     0x3f  // Variable has been completely added
#define NVRAM_VSS_INTEL_VARIABLE_VALID               0xfc  // Intel special variable valid
#define NVRAM_VSS_INTEL_VARIABLE_INVALID             0xf8  // Intel special variable invalid 

// VSS variable attributes
#define NVRAM_VSS_VARIABLE_NON_VOLATILE                          0x00000001
#define NVRAM_VSS_VARIABLE_BOOTSERVICE_ACCESS                    0x00000002
#define NVRAM_VSS_VARIABLE_RUNTIME_ACCESS                        0x00000004
#define NVRAM_VSS_VARIABLE_HARDWARE_ERROR_RECORD                 0x00000008
#define NVRAM_VSS_VARIABLE_AUTHENTICATED_WRITE_ACCESS            0x00000010
#define NVRAM_VSS_VARIABLE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS 0x00000020
#define NVRAM_VSS_VARIABLE_APPEND_WRITE                          0x00000040
#define NVRAM_VSS_VARIABLE_APPLE_DATA_CHECKSUM                   0x80000000
#define NVRAM_VSS_VARIABLE_UNKNOWN_MASK                          0x7FFFFF80

extern UString vssAttributesToUString(const UINT32 attributes);

//
// VSS2 variables
//

// aaf32c78-947b-439a-a180-2e144ec37792
#define NVRAM_VSS2_AUTH_VAR_KEY_DATABASE_GUID_PART1 0xaaf32c78
const UByteArray NVRAM_VSS2_AUTH_VAR_KEY_DATABASE_GUID
("\x78\x2C\xF3\xAA\x7B\x94\x9A\x43\xA1\x80\x2E\x14\x4E\xC3\x77\x92");

#define NVRAM_VSS2_STORE_GUID_PART1 0xddcf3617
const UByteArray NVRAM_VSS2_STORE_GUID
("\x17\x36\xCF\xDD\x75\x32\x64\x41\x98\xB6\xFE\x85\x70\x7F\xFE\x7D");

const UByteArray NVRAM_FDC_STORE_GUID
("\x16\x36\xCF\xDD\x75\x32\x64\x41\x98\xB6\xFE\x85\x70\x7F\xFE\x7D");

// Variable store header
typedef struct VSS2_VARIABLE_STORE_HEADER_ {
    EFI_GUID Signature; // VSS2 Store Guid
    UINT32   Size;      // Size of variable store, including store header
    UINT8    Format;    // Store format state
    UINT8    State;     // Store health state
    UINT16   Unknown;
    UINT32   : 32;
} VSS2_VARIABLE_STORE_HEADER;

// VSS2 entries are 4-bytes aligned in VSS2 stores

//
// _FDC region
//

#define NVRAM_FDC_VOLUME_SIGNATURE 0x4344465F

typedef struct FDC_VOLUME_HEADER_ {
    UINT32 Signature; //_FDC signature
    UINT32 Size;      // Size of the whole region
    //EFI_FIRMWARE_VOLUME_HEADER VolumeHeader;
    //EFI_FV_BLOCK_MAP_ENTRY FvBlockMap[2];
    //VSS_VARIABLE_STORE_HEADER VssHeader;
} FDC_VOLUME_HEADER;

//
// FTW block
//
#define EFI_FAULT_TOLERANT_WORKING_BLOCK_VALID   0x1
#define EFI_FAULT_TOLERANT_WORKING_BLOCK_INVALID 0x2

// 9E58292B-7C68-497D-0ACE6500FD9F1B95
const UByteArray EDKII_WORKING_BLOCK_SIGNATURE_GUID
("\x2B\x29\x58\x9E\x68\x7C\x7D\x49\x0A\xCE\x65\x00\xFD\x9F\x1B\x95", 16);

// 9E58292B-7C68-497D-A0CE6500FD9F1B95
const UByteArray VSS2_WORKING_BLOCK_SIGNATURE_GUID
("\x2B\x29\x58\x9E\x68\x7C\x7D\x49\xA0\xCE\x65\x00\xFD\x9F\x1B\x95", 16);

#define NVRAM_MAIN_STORE_VOLUME_GUID_DATA1       0xFFF12B8D
#define EDKII_WORKING_BLOCK_SIGNATURE_GUID_DATA1 0x9E58292B

typedef struct EFI_FAULT_TOLERANT_WORKING_BLOCK_HEADER32_ {
    EFI_GUID  Signature; // NVRAM_MAIN_STORE_VOLUME_GUID
    UINT32    Crc; // Crc32 of the header with empty Crc and State fields
    UINT8     State;
    UINT8     Reserved[3];
    UINT32    WriteQueueSize; // Size of the FTW block without the header
    //UINT8   WriteQueue[WriteQueueSize];
} EFI_FAULT_TOLERANT_WORKING_BLOCK_HEADER32;

typedef struct EFI_FAULT_TOLERANT_WORKING_BLOCK_HEADER64_ {
    EFI_GUID  Signature; // NVRAM_MAIN_STORE_VOLUME_GUID or EDKII_WORKING_BLOCK_SIGNATURE_GUID
    UINT32    Crc; // Crc32 of the header with empty Crc and State fields
    UINT8     State;
    UINT8     Reserved[3];
    UINT64    WriteQueueSize; // Size of the FTW block without the header
    //UINT8   WriteQueue[WriteQueueSize];
} EFI_FAULT_TOLERANT_WORKING_BLOCK_HEADER64;

//
// Apple Fsys store
//

typedef struct APPLE_FSYS_STORE_HEADER_ {
    UINT32  Signature;  // Fsys or Gaid signature
    UINT8   Unknown0;   // Still unknown
    UINT32  Unknown1;   // Still unknown
    UINT16  Size;       // Size of variable store
} APPLE_FSYS_STORE_HEADER;

// Apple Fsys entry format
// UINT8 NameLength;
// CHAR8 Name[];
// UINT16 DataLength;
// UINT8 Data[]
// Store ends with a chunk named "EOF" without data
// All free bytes in store are zeroed
// Has CRC32 of the whole store without checksum field at the end

//
// EVSA store and entries
//

#define NVRAM_EVSA_STORE_SIGNATURE 0x41535645

#define NVRAM_EVSA_ENTRY_TYPE_STORE        0xEC
#define NVRAM_EVSA_ENTRY_TYPE_GUID1        0xED
#define NVRAM_EVSA_ENTRY_TYPE_GUID2        0xE1
#define NVRAM_EVSA_ENTRY_TYPE_NAME1        0xEE
#define NVRAM_EVSA_ENTRY_TYPE_NAME2        0xE2
#define NVRAM_EVSA_ENTRY_TYPE_DATA1        0xEF
#define NVRAM_EVSA_ENTRY_TYPE_DATA2        0xE3
#define NVRAM_EVSA_ENTRY_TYPE_DATA_INVALID 0x83

typedef struct EVSA_ENTRY_HEADER_ {
    UINT8  Type;
    UINT8  Checksum;
    UINT16 Size;
} EVSA_ENTRY_HEADER;

typedef struct EVSA_STORE_ENTRY_ {
    EVSA_ENTRY_HEADER Header;
    UINT32 Signature; // EVSA signature
    UINT32 Attributes;
    UINT32 StoreSize;
    UINT32 : 32;
} EVSA_STORE_ENTRY;

typedef struct EVSA_GUID_ENTRY_ {
    EVSA_ENTRY_HEADER Header;
    UINT16 GuidId;
    //EFI_GUID Guid;
} EVSA_GUID_ENTRY;

typedef struct EVSA_NAME_ENTRY_ {
    EVSA_ENTRY_HEADER Header;
    UINT16 VarId;
    //CHAR16 Name[];
} EVSA_NAME_ENTRY;

typedef struct EVSA_DATA_ENTRY_ {
    EVSA_ENTRY_HEADER Header;
    UINT16 GuidId;
    UINT16 VarId;
    UINT32 Attributes;
    //UINT8 Data[];
} EVSA_DATA_ENTRY;

// VSS variable attributes
#define NVRAM_EVSA_DATA_NON_VOLATILE                          0x00000001
#define NVRAM_EVSA_DATA_BOOTSERVICE_ACCESS                    0x00000002
#define NVRAM_EVSA_DATA_RUNTIME_ACCESS                        0x00000004
#define NVRAM_EVSA_DATA_HARDWARE_ERROR_RECORD                 0x00000008
#define NVRAM_EVSA_DATA_AUTHENTICATED_WRITE_ACCESS            0x00000010
#define NVRAM_EVSA_DATA_TIME_BASED_AUTHENTICATED_WRITE_ACCESS 0x00000020
#define NVRAM_EVSA_DATA_APPEND_WRITE                          0x00000040
#define NVRAM_EVSA_DATA_EXTENDED_HEADER                       0x10000000
#define NVRAM_EVSA_DATA_UNKNOWN_MASK                          0xEFFFFF80

typedef struct EVSA_DATA_ENTRY_EXTENDED_ {
    EVSA_ENTRY_HEADER Header;
    UINT16 GuidId;
    UINT16 VarId;
    UINT32 Attributes;
    UINT32 DataSize;
    //UINT8 Data[];
} EVSA_DATA_ENTRY_EXTENDED;

extern UString evsaAttributesToUString(const UINT32 attributes);

//
// Phoenix SCT Flash Map
//

#define NVRAM_PHOENIX_FLASH_MAP_SIGNATURE_PART1  0x414C465F
#define NVRAM_PHOENIX_FLASH_MAP_SIGNATURE_LENGTH 10

// _FLASH_MAP
const UByteArray NVRAM_PHOENIX_FLASH_MAP_SIGNATURE
("\x5F\x46\x4C\x41\x53\x48\x5F\x4D\x41\x50", 10);

typedef struct PHOENIX_FLASH_MAP_HEADER_ {
    UINT8  Signature[10]; // _FLASH_MAP signature
    UINT16 NumEntries;    // Number of entries in the map
    UINT32 : 32;          // Reserved field
} PHOENIX_FLASH_MAP_HEADER;

typedef struct PHOENIX_FLASH_MAP_ENTRY_ {
    EFI_GUID Guid;
    UINT16 DataType;
    UINT16 EntryType;
    UINT64 PhysicalAddress;
    UINT32 Size;
    UINT32 Offset;
} PHOENIX_FLASH_MAP_ENTRY;

#define NVRAM_PHOENIX_FLASH_MAP_ENTRY_TYPE_VOLUME     0x0000
#define NVRAM_PHOENIX_FLASH_MAP_ENTRY_TYPE_DATA_BLOCK 0x0001

extern UString flashMapGuidToUString(const EFI_GUID & guid);

// B091E7D2-05A0-4198-94F0-74B7B8C55459
const UByteArray NVRAM_PHOENIX_FLASH_MAP_VOLUME_HEADER
("\xD2\xE7\x91\xB0\xA0\x05\x98\x41\x94\xF0\x74\xB7\xB8\xC5\x54\x59", 16);

// FD3F690E-B4B0-4D68-89DB-19A1A3318F90
const UByteArray NVRAM_PHOENIX_FLASH_MAP_MICROCODES_GUID
("\x0E\x69\x3F\xFD\xB0\xB4\x68\x4D\x89\xDB\x19\xA1\xA3\x31\x8F\x90", 16);

// 46310243-7B03-4132-BE44-2243FACA7CDD
const UByteArray NVRAM_PHOENIX_FLASH_MAP_CMDB_GUID
("\x43\x02\x31\x46\x03\x7B\x32\x41\xBE\x44\x22\x43\xFA\xCA\x7C\xDD", 16);

// 1B2C4952-D778-4B64-BDA1-15A36F5FA545
const UByteArray NVRAM_PHOENIX_FLASH_MAP_PUBKEY1_GUID
("\x52\x49\x2C\x1B\x78\xD7\x64\x4B\xBD\xA1\x15\xA3\x6F\x5F\xA5\x45", 16);

// 127C1C4E-9135-46E3-B006-F9808B0559A5
const UByteArray NVRAM_PHOENIX_FLASH_MAP_MARKER1_GUID
("\x4E\x1C\x7C\x12\x35\x91\xE3\x46\xB0\x06\xF9\x80\x8B\x05\x59\xA5", 16);

// 7CE75114-8272-45AF-B536-761BD38852CE
const UByteArray NVRAM_PHOENIX_FLASH_MAP_PUBKEY2_GUID
("\x14\x51\xE7\x7C\x72\x82\xAF\x45\xB5\x36\x76\x1B\xD3\x88\x52\xCE", 16);

// 071A3DBE-CFF4-4B73-83F0-598C13DCFDD5
const UByteArray NVRAM_PHOENIX_FLASH_MAP_MARKER2_GUID
("\xBE\x3D\x1A\x07\xF4\xCF\x73\x4B\x83\xF0\x59\x8C\x13\xDC\xFD\xD5", 16);

// FACFB110-7BFD-4EFB-873E-88B6B23B97EA
const UByteArray NVRAM_PHOENIX_FLASH_MAP_EVSA1_GUID
("\x10\xB1\xCF\xFA\xFD\x7B\xFB\x4E\x87\x3E\x88\xB6\xB2\x3B\x97\xEA", 16);

// E68DC11A-A5F4-4AC3-AA2E-29E298BFF645
const UByteArray NVRAM_PHOENIX_FLASH_MAP_EVSA2_GUID
("\x1A\xC1\x8D\xE6\xF4\xA5\xC3\x4A\xAA\x2E\x29\xE2\x98\xBF\xF6\x45", 16);

// 4B3828AE-0ACE-45B6-8CDB-DAFC28BBF8C5
const UByteArray NVRAM_PHOENIX_FLASH_MAP_EVSA3_GUID
("\xAE\x28\x38\x4B\xCE\x0A\xB6\x45\x8C\xDB\xDA\xFC\x28\xBB\xF8\xC5", 16);

// C22E6B8A-8159-49A3-B353-E84B79DF19C0
const UByteArray NVRAM_PHOENIX_FLASH_MAP_EVSA4_GUID
("\x8A\x6B\x2E\xC2\x59\x81\xA3\x49\xB3\x53\xE8\x4B\x79\xDF\x19\xC0", 16);

// B6B5FAB9-75C4-4AAE-8314-7FFFA7156EAA
const UByteArray NVRAM_PHOENIX_FLASH_MAP_EVSA5_GUID
("\xB9\xFA\xB5\xB6\xC4\x75\xAE\x4A\x83\x14\x7F\xFF\xA7\x15\x6E\xAA", 16);

// 919B9699-8DD0-4376-AA0B-0E54CCA47D8F
const UByteArray NVRAM_PHOENIX_FLASH_MAP_EVSA6_GUID
("\x99\x96\x9B\x91\xD0\x8D\x76\x43\xAA\x0B\x0E\x54\xCC\xA4\x7D\x8F", 16);

// 58A90A52-929F-44F8-AC35-A7E1AB18AC91
const UByteArray NVRAM_PHOENIX_FLASH_MAP_EVSA7_GUID
("\x52\x0A\xA9\x58\x9F\x92\xF8\x44\xAC\x35\xA7\xE1\xAB\x18\xAC\x91", 16);

// 8CB71915-531F-4AF5-82BF-A09140817BAA
const UByteArray NVRAM_PHOENIX_FLASH_MAP_SELF_GUID
("\x15\x19\xB7\x8C\x1F\x53\xF5\x4A\x82\xBF\xA0\x91\x40\x81\x7B\xAA", 16);

//
// SLIC pubkey and marker
//

typedef struct OEM_ACTIVATION_PUBKEY_ {
    UINT32 Type;         // 0
    UINT32 Size;         // 0x9C
    UINT8  KeyType;
    UINT8  Version;
    UINT16 Reserved;
    UINT32 Algorithm;
    UINT32 Magic;        // RSA1 signature
    UINT32 BitLength;
    UINT32 Exponent;
    UINT8  Modulus[128];
} OEM_ACTIVATION_PUBKEY;

#define OEM_ACTIVATION_PUBKEY_TYPE  0x00000000
#define OEM_ACTIVATION_PUBKEY_MAGIC 0x31415352 // RSA1

typedef struct OEM_ACTIVATION_MARKER_ {
    UINT32 Type;         // 1
    UINT32 Size;         // 0xB6
    UINT32 Version;
    UINT8  OemId[6];
    UINT8  OemTableId[8];
    UINT64 WindowsFlag;  // WINDOWS signature
    UINT32 SlicVersion;
    UINT8  Reserved[16];
    UINT8  Signature[128];
} OEM_ACTIVATION_MARKER;

#define OEM_ACTIVATION_MARKER_TYPE               0x00000001
#define OEM_ACTIVATION_MARKER_WINDOWS_FLAG_PART1 0x444E4957
#define OEM_ACTIVATION_MARKER_WINDOWS_FLAG       0x2053574F444E4957UL
#define OEM_ACTIVATION_MARKER_RESERVED_BYTE      0x00

//
// Phoenix CMDB, no londer used, requires no parsing
//

typedef struct PHOENIX_CMDB_HEADER_ {
    UINT32 Signature;  // CMDB signature
    UINT32 HeaderSize; // Size of this header
    UINT32 TotalSize;  // Total size of header and chunks, without strings
    // UINT8 StartChunk[3];
    // UINT8 StringChunk[5][x];
    // C_STR Strings[2*x + 1];
} PHOENIX_CMDB_HEADER;

#define NVRAM_PHOENIX_CMDB_HEADER_SIGNATURE 0x42444D43
#define NVRAM_PHOENIX_CMDB_SIZE 0x100;

// Restore previous packing rules
#pragma pack(pop)

#endif // NVRAM_H

```

`efiXloader/3rd/uefitool/common/nvramparser.cpp`:

```cpp
/* nvramparser.cpp

Copyright (c) 2016, Nikolaj Schlej. All rights reserved.

This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php.

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

*/

//TODO: relax fixed restrictions once NVRAM builder is ready

// A workaround for compilers not supporting c++11 and c11
// for using PRIX64.
#define __STDC_FORMAT_MACROS

#include <inttypes.h>
#include <map>

#include "nvramparser.h"
#include "parsingdata.h"
#include "utility.h"
#include "nvram.h"
#include "ffs.h"
#include "fit.h"

#ifdef U_ENABLE_NVRAM_PARSING_SUPPORT
USTATUS NvramParser::parseNvarStore(const UModelIndex & index)
{
    // Sanity check
    if (!index.isValid())
        return U_INVALID_PARAMETER;

    // Obtain required information from parent file
    UINT8 emptyByte = 0xFF;
    UModelIndex parentFileIndex = model->findParentOfType(index, Types::File);
    if (parentFileIndex.isValid() && model->hasEmptyParsingData(parentFileIndex) == false) {
        UByteArray data = model->parsingData(parentFileIndex);
        const FILE_PARSING_DATA* pdata = (const FILE_PARSING_DATA*)data.constData();
        emptyByte = readUnaligned(pdata).emptyByte;
    }

    // Get local offset
    UINT32 localOffset = model->header(index).size();

    // Get item data
    const UByteArray data = model->body(index);

    // Parse all entries
    UINT32 offset = 0;
    UINT32 guidsInStore = 0;
    while (1) {
        bool msgUnknownExtDataFormat = false;
        bool msgExtHeaderTooLong = false;
        bool msgExtDataTooShort = false;

        bool isInvalid = false;
        bool isInvalidLink = false;
        bool hasExtendedHeader = false;
        bool hasChecksum = false;
        bool hasTimestamp = false;
        bool hasHash = false;
        bool hasGuidIndex = false;

        UINT32 guidIndex = 0;
        UINT8  storedChecksum = 0;
        UINT8  calculatedChecksum = 0;
        UINT32 extendedHeaderSize = 0;
        UINT8  extendedAttributes = 0;
        UINT64 timestamp = 0;
        UByteArray hash;

        UINT8 subtype = Subtypes::FullNvarEntry;
        UString name;
        UString guid;
        UString text;
        UByteArray header;
        UByteArray body;
        UByteArray tail;

        UINT32 guidAreaSize = guidsInStore * sizeof(EFI_GUID);
        UINT32 unparsedSize = (UINT32)data.size() - offset - guidAreaSize;

        // Get entry header
        const NVAR_ENTRY_HEADER* entryHeader = (const NVAR_ENTRY_HEADER*)(data.constData() + offset);

        // Check header size and signature
        if (unparsedSize < sizeof(NVAR_ENTRY_HEADER) ||
            entryHeader->Signature != NVRAM_NVAR_ENTRY_SIGNATURE ||
            unparsedSize < entryHeader->Size) {
            // Check if the data left is a free space or a padding
            UByteArray padding = data.mid(offset, unparsedSize);

            // Get info
            UString info = usprintf("Full size: %Xh (%u)", padding.size(), padding.size());

            if ((UINT32)padding.count(emptyByte) == unparsedSize) { // Free space
                // Add tree item
                model->addItem(localOffset + offset, Types::FreeSpace, 0, UString("Free space"), UString(), info, UByteArray(), padding, UByteArray(), Fixed, index);
            }
            else {
                // Nothing is parsed yet, but the file is not empty 
                if (!offset) {
                    msg(usprintf("%s: file can't be parsed as NVAR variables store", __FUNCTION__), index);
                    return U_SUCCESS;
                }

                // Add tree item
                model->addItem(localOffset + offset, Types::Padding, getPaddingType(padding), UString("Padding"), UString(), info, UByteArray(), padding, UByteArray(), Fixed, index);
            }

            // Add GUID store area
            UByteArray guidArea = data.right(guidAreaSize);
            // Get info
            name = UString("GUID store");
            info = usprintf("Full size: %Xh (%u)\nGUIDs in store: %u",
                guidArea.size(), guidArea.size(),
                guidsInStore);
            // Add tree item
            model->addItem(localOffset + offset + padding.size(), Types::Padding, getPaddingType(guidArea), name, UString(), info, UByteArray(), guidArea, UByteArray(), Fixed, index);

            return U_SUCCESS;
        }

        // Contruct generic header and body
        header = data.mid(offset, sizeof(NVAR_ENTRY_HEADER));
        body = data.mid(offset + sizeof(NVAR_ENTRY_HEADER), entryHeader->Size - sizeof(NVAR_ENTRY_HEADER));

        UINT32 lastVariableFlag = emptyByte ? 0xFFFFFF : 0;

        // Set default next to predefined last value
        NVAR_ENTRY_PARSING_DATA pdata;
        pdata.emptyByte = emptyByte;
        pdata.next = lastVariableFlag;

        // Entry is marked as invalid
        if ((entryHeader->Attributes & NVRAM_NVAR_ENTRY_VALID) == 0) { // Valid attribute is not set
            isInvalid = true;
            // Do not parse further
            goto parsing_done;
        }

        // Add next node information to parsing data
        if (entryHeader->Next != lastVariableFlag) {
            subtype = Subtypes::LinkNvarEntry;
            pdata.next = entryHeader->Next;
        }

        // Entry with extended header
        if (entryHeader->Attributes & NVRAM_NVAR_ENTRY_EXT_HEADER) {
            hasExtendedHeader = true;
            msgUnknownExtDataFormat = true;

            extendedHeaderSize = readUnaligned((UINT16*)(body.constData() + body.size() - sizeof(UINT16)));
            if (extendedHeaderSize > (UINT32)body.size()) {
                msgExtHeaderTooLong = true;
                isInvalid = true;
                // Do not parse further
                goto parsing_done;
            }

            extendedAttributes = *(UINT8*)(body.constData() + body.size() - extendedHeaderSize);

            // Variable with checksum
            if (extendedAttributes & NVRAM_NVAR_ENTRY_EXT_CHECKSUM) {
                // Get stored checksum
                storedChecksum = *(UINT8*)(body.constData() + body.size() - sizeof(UINT16) - sizeof(UINT8));

                // Recalculate checksum for the variable
                calculatedChecksum = 0;
                // Include entry data
                UINT8* start = (UINT8*)(entryHeader + 1);
                for (UINT8* p = start; p < start + entryHeader->Size - sizeof(NVAR_ENTRY_HEADER); p++) {
                    calculatedChecksum += *p;
                }
                // Include entry size and flags
                start = (UINT8*)&entryHeader->Size;
                for (UINT8*p = start; p < start + sizeof(UINT16); p++) {
                    calculatedChecksum += *p;
                }
                // Include entry attributes
                calculatedChecksum += entryHeader->Attributes;

                hasChecksum = true;
                msgUnknownExtDataFormat = false;
            }

            tail = body.mid(body.size() - extendedHeaderSize);
            body = body.left(body.size() - extendedHeaderSize);

            // Entry with authenticated write (for SecureBoot)
            if (entryHeader->Attributes & NVRAM_NVAR_ENTRY_AUTH_WRITE) {
                if ((entryHeader->Attributes & NVRAM_NVAR_ENTRY_DATA_ONLY)) {// Data only auth. variables has no hash
                    if ((UINT32)tail.size() < sizeof(UINT64)) {
                        msgExtDataTooShort = true;
                        isInvalid = true;
                        // Do not parse further
                        goto parsing_done;
                    }

                    timestamp = readUnaligned(tail.constData() + sizeof(UINT8));
                    hasTimestamp = true;
                    msgUnknownExtDataFormat = false;
                }
                else { // Full or link variable have hash
                    if ((UINT32)tail.size() < sizeof(UINT64) + SHA256_HASH_SIZE) {
                        msgExtDataTooShort = true;
                        isInvalid = true;
                        // Do not parse further
                        goto parsing_done;
                    }

                    timestamp = readUnaligned((UINT64*)(tail.constData() + sizeof(UINT8)));
                    hash = tail.mid(sizeof(UINT64) + sizeof(UINT8), SHA256_HASH_SIZE);
                    hasTimestamp = true;
                    hasHash = true;
                    msgUnknownExtDataFormat = false;
                }
            }
        }

        // Entry is data-only (nameless and GUIDless entry or link)
        if (entryHeader->Attributes & NVRAM_NVAR_ENTRY_DATA_ONLY) { // Data-only attribute is set
            isInvalidLink = true;
            UModelIndex nvarIndex;
            // Search previously added entries for a link to this variable
            // WARNING: O(n^2), may be very slow
            for (int i = model->rowCount(index) - 1; i >= 0; i--) {
                nvarIndex = index.child(i, 0);
                if (model->hasEmptyParsingData(nvarIndex) == false) {
                    UByteArray nvarData = model->parsingData(nvarIndex);
                    const NVAR_ENTRY_PARSING_DATA nvarPdata = readUnaligned((const NVAR_ENTRY_PARSING_DATA*)nvarData.constData());
                    if (nvarPdata.isValid && nvarPdata.next + model->offset(nvarIndex) - localOffset == offset) { // Previous link is present and valid
                        isInvalidLink = false;
                        break;
                    }
                }
            }
            // Check if the link is valid
            if (!isInvalidLink) {
                // Use the name and text of the previous link
                name = model->name(nvarIndex);
                text = model->text(nvarIndex);

                if (entryHeader->Next == lastVariableFlag)
                    subtype = Subtypes::DataNvarEntry;
            }

            // Do not parse further
            goto parsing_done;
        }

        // Get entry name
        {
            UINT32 nameOffset = (entryHeader->Attributes & NVRAM_NVAR_ENTRY_GUID) ? sizeof(EFI_GUID) : sizeof(UINT8); // GUID can be stored with the variable or in a separate store, so there will only be an index of it
            CHAR8* namePtr = (CHAR8*)(entryHeader + 1) + nameOffset;
            UINT32 nameSize = 0;
            if (entryHeader->Attributes & NVRAM_NVAR_ENTRY_ASCII_NAME) { // Name is stored as ASCII string of CHAR8s
                text = UString(namePtr);
                nameSize = text.length() + 1;
            }
            else { // Name is stored as UCS2 string of CHAR16s
                text = UString::fromUtf16((CHAR16*)namePtr);
                nameSize = (text.length() + 1) * 2;
            }

            // Get entry GUID
            if (entryHeader->Attributes & NVRAM_NVAR_ENTRY_GUID) { // GUID is strored in the variable itself
                name = guidToUString(readUnaligned((EFI_GUID*)(entryHeader + 1)));
                guid = guidToUString(readUnaligned((EFI_GUID*)(entryHeader + 1)), false);
            }
            // GUID is stored in GUID list at the end of the store
            else {
                guidIndex = *(UINT8*)(entryHeader + 1);
                if (guidsInStore < guidIndex + 1)
                    guidsInStore = guidIndex + 1;

                // The list begins at the end of the store and goes backwards
                const EFI_GUID* guidPtr = (const EFI_GUID*)(data.constData() + data.size()) - 1 - guidIndex;
                name = guidToUString(readUnaligned(guidPtr));
                guid = guidToUString(readUnaligned(guidPtr), false);
                hasGuidIndex = true;
            }

            // Include name and GUID into the header and remove them from body
            header = data.mid(offset, sizeof(NVAR_ENTRY_HEADER) + nameOffset + nameSize);
            body = body.mid(nameOffset + nameSize);
        }
    parsing_done:
        UString info;

        // Rename invalid entries according to their types
        pdata.isValid = TRUE;
        if (isInvalid) {
            name = UString("Invalid");
            subtype = Subtypes::InvalidNvarEntry;
            pdata.isValid = FALSE;
        }
        else if (isInvalidLink) {
            name = UString("Invalid link");
            subtype = Subtypes::InvalidLinkNvarEntry;
            pdata.isValid = FALSE;
        }
        else // Add GUID info for valid entries
            info += UString("Variable GUID: ") + guid + UString("\n");

        // Add GUID index information
        if (hasGuidIndex)
            info += usprintf("GUID index: %u\n", guidIndex);

        // Add header, body and extended data info
        info += usprintf("Full size: %Xh (%u)\nHeader size: %Xh (%u)\nBody size: %Xh (%u)",
            entryHeader->Size, entryHeader->Size,
            header.size(), header.size(),
            body.size(), body.size());

        // Add attributes info
        info += usprintf("\nAttributes: %02Xh", entryHeader->Attributes);
        // Translate attributes to text
        if (entryHeader->Attributes && entryHeader->Attributes != 0xFF)
            info += UString(" (") + nvarAttributesToUString(entryHeader->Attributes) + UString(")");

        // Add next node info
        if (!isInvalid && entryHeader->Next != lastVariableFlag)
            info += usprintf("\nNext node at offset: %Xh", localOffset + offset + entryHeader->Next);

        // Add extended header info
        if (hasExtendedHeader) {
            info += usprintf("\nExtended header size: %Xh (%u)\nExtended attributes: %Xh (",
                extendedHeaderSize, extendedHeaderSize,
                extendedAttributes) + nvarExtendedAttributesToUString(extendedAttributes) + UString(")");

            // Add checksum
            if (hasChecksum)
                info += usprintf("\nChecksum: %02Xh", storedChecksum) +
                (calculatedChecksum ? usprintf(", invalid, should be %02Xh", 0x100 - calculatedChecksum) : UString(", valid"));

            // Add timestamp
            if (hasTimestamp)
                info += usprintf("\nTimestamp: %" PRIX64 "h", timestamp);

            // Add hash
            if (hasHash)
                info += UString("\nHash: ") + UString(hash.toHex().constData());
        }

        // Add tree item
        UModelIndex varIndex = model->addItem(localOffset + offset, Types::NvarEntry, subtype, name, text, info, header, body, tail, Fixed, index);

        // Set parsing data for created entry
        model->setParsingData(varIndex, UByteArray((const char*)&pdata, sizeof(pdata)));

        // Show messages
        if (msgUnknownExtDataFormat) msg(usprintf("%s: unknown extended data format", __FUNCTION__), varIndex);
        if (msgExtHeaderTooLong)     msg(usprintf("%s: extended header size (%Xh) is greater than body size (%Xh)", __FUNCTION__,
            extendedHeaderSize, body.size()), varIndex);
        if (msgExtDataTooShort)      msg(usprintf("%s: extended header size (%Xh) is too small for timestamp and hash", __FUNCTION__,
            tail.size()), varIndex);

        // Try parsing the entry data as NVAR storage if it begins with NVAR signature
        if ((subtype == Subtypes::DataNvarEntry || subtype == Subtypes::FullNvarEntry)
            && body.size() >= 4 && readUnaligned((const UINT32*)body.constData()) == NVRAM_NVAR_ENTRY_SIGNATURE)
            parseNvarStore(varIndex);

        // Move to next exntry
        offset += entryHeader->Size;
    }

    return U_SUCCESS;
}

USTATUS NvramParser::parseNvramVolumeBody(const UModelIndex & index)
{
    // Sanity check
    if (!index.isValid())
        return U_INVALID_PARAMETER;

    // Obtain required fields from parsing data
    UINT8 emptyByte = 0xFF;
    if (model->hasEmptyParsingData(index) == false) {
        UByteArray data = model->parsingData(index);
        const VOLUME_PARSING_DATA* pdata = (const VOLUME_PARSING_DATA*)data.constData();
        emptyByte = pdata->emptyByte;
    }

    // Get local offset
    UINT32 localOffset = model->header(index).size();

    // Get item data
    UByteArray data = model->body(index);

    // Search for first store
    USTATUS result;
    UINT32 prevStoreOffset;
    result = findNextStore(index, data, localOffset, 0, prevStoreOffset);
    if (result)
        return result;

    // First store is not at the beginning of volume body
    UString name;
    UString info;
    if (prevStoreOffset > 0) {
        // Get info
        UByteArray padding = data.left(prevStoreOffset);
        name = UString("Padding");
        info = usprintf("Full size: %Xh (%u)", padding.size(), padding.size());

        // Add tree item
        model->addItem(localOffset, Types::Padding, getPaddingType(padding), name, UString(), info, UByteArray(), padding, UByteArray(), Fixed, index);
    }

    // Search for and parse all stores
    UINT32 storeOffset = prevStoreOffset;
    UINT32 prevStoreSize = 0;

    while (!result) {
        // Padding between stores
        if (storeOffset > prevStoreOffset + prevStoreSize) {
            UINT32 paddingOffset = prevStoreOffset + prevStoreSize;
            UINT32 paddingSize = storeOffset - paddingOffset;
            UByteArray padding = data.mid(paddingOffset, paddingSize);

            // Get info
            name = UString("Padding");
            info = usprintf("Full size: %Xh (%u)", padding.size(), padding.size());

            // Add tree item
            model->addItem(localOffset + paddingOffset, Types::Padding, getPaddingType(padding), name, UString(), info, UByteArray(), padding, UByteArray(), Fixed, index);
        }

        // Get store size
        UINT32 storeSize = 0;
        result = getStoreSize(data, storeOffset, storeSize);
        if (result) {
            msg(usprintf("%s: getStoreSize failed with error ", __FUNCTION__) + errorCodeToUString(result), index);
            return result;
        }

        // Check that current store is fully present in input
        if (storeSize > (UINT32)data.size() || storeOffset + storeSize > (UINT32)data.size()) {
            // Mark the rest as padding and finish parsing
            UByteArray padding = data.mid(storeOffset);

            // Get info
            name = UString("Padding");
            info = usprintf("Full size: %Xh (%u)", padding.size(), padding.size());

            // Add tree item
            UModelIndex paddingIndex = model->addItem(localOffset + storeOffset, Types::Padding, getPaddingType(padding), name, UString(), info, UByteArray(), padding, UByteArray(), Fixed, index);
            msg(usprintf("%s: one of stores inside overlaps the end of data", __FUNCTION__), paddingIndex);

            // Update variables
            prevStoreOffset = storeOffset;
            prevStoreSize = padding.size();
            break;
        }

        // Parse current store header
        UModelIndex storeIndex;
        UByteArray store = data.mid(storeOffset, storeSize);
        result = parseStoreHeader(store, localOffset + storeOffset, index, storeIndex);
        if (result)
            msg(usprintf("%s: store header parsing failed with error ", __FUNCTION__) + errorCodeToUString(result), index);

        // Go to next store
        prevStoreOffset = storeOffset;
        prevStoreSize = storeSize;
        result = findNextStore(index, data, localOffset, storeOffset + prevStoreSize, storeOffset);
    }

    // Padding/free space at the end
    storeOffset = prevStoreOffset + prevStoreSize;
    if ((UINT32)data.size() > storeOffset) {
        UByteArray padding = data.mid(storeOffset);
        // Add info
        info = usprintf("Full size: %Xh (%u)", padding.size(), padding.size());

        if (padding.count(emptyByte) == padding.size()) { // Free space
            // Add tree item
            model->addItem(localOffset + storeOffset, Types::FreeSpace, 0, UString("Free space"), UString(), info, UByteArray(), padding, UByteArray(), Fixed, index);
        }
        else {
            // Nothing is parsed yet, but the file is not empty 
            if (!storeOffset) {
                msg(usprintf("%s: can't be parsed as NVRAM volume", __FUNCTION__), index);
                return U_SUCCESS;
            }

            // Add tree item
            model->addItem(localOffset + storeOffset, Types::Padding, getPaddingType(padding), UString("Padding"), UString(), info, UByteArray(), padding, UByteArray(), Fixed, index);
        }
    }

    // Parse bodies
    for (int i = 0; i < model->rowCount(index); i++) {
        UModelIndex current = index.child(i, 0);
        switch (model->type(current)) {
        case Types::FdcStore:
            parseFdcStoreBody(current);
            break;
        case Types::VssStore:
            parseVssStoreBody(current, 0);
            break;
        case Types::Vss2Store:
            parseVssStoreBody(current, 4);
            break;
        case Types::FsysStore:
            parseFsysStoreBody(current);
            break;
        case Types::EvsaStore:
            parseEvsaStoreBody(current);
            break;
        case Types::FlashMapStore:
            parseFlashMapBody(current);
            break;
        default:
            // Ignore unknown!
            break;
        }
    }

    return U_SUCCESS;
}

USTATUS NvramParser::findNextStore(const UModelIndex & index, const UByteArray & volume, const UINT32 localOffset, const UINT32 storeOffset, UINT32 & nextStoreOffset)
{
    UINT32 dataSize = volume.size();

    if (dataSize < sizeof(UINT32))
        return U_STORES_NOT_FOUND;

	// TODO: add checks for restSize
    UINT32 offset = storeOffset;
    for (; offset < dataSize - sizeof(UINT32); offset++) {
        const UINT32* currentPos = (const UINT32*)(volume.constData() + offset);
        if (*currentPos == NVRAM_VSS_STORE_SIGNATURE || *currentPos == NVRAM_APPLE_SVS_STORE_SIGNATURE || *currentPos == NVRAM_APPLE_NSS_STORE_SIGNATURE) { // $VSS, $SVS or $NSS signatures found, perform checks
            const VSS_VARIABLE_STORE_HEADER* vssHeader = (const VSS_VARIABLE_STORE_HEADER*)currentPos;
            if (vssHeader->Format != NVRAM_VSS_VARIABLE_STORE_FORMATTED) {
                msg(usprintf("%s: VSS store candidate at offset %Xh skipped, has invalid format %02Xh", __FUNCTION__, localOffset + offset, vssHeader->Format), index);
                continue;
            }
            if (vssHeader->Size == 0 || vssHeader->Size == 0xFFFFFFFF) {
                msg(usprintf("%s: VSS store candidate at offset %Xh skipped, has invalid size %Xh", __FUNCTION__, localOffset + offset, vssHeader->Size), index);
                continue;
            }
            // All checks passed, store found
            break;
        }
        else if (*currentPos == NVRAM_VSS2_AUTH_VAR_KEY_DATABASE_GUID_PART1 || *currentPos == NVRAM_VSS2_STORE_GUID_PART1) { // VSS2 store signatures found, perform checks
            UByteArray guid = UByteArray(volume.constData() + offset, sizeof(EFI_GUID));
            if (guid != NVRAM_VSS2_AUTH_VAR_KEY_DATABASE_GUID && guid != NVRAM_VSS2_STORE_GUID) // Check the whole signature
                continue;

            const VSS2_VARIABLE_STORE_HEADER* vssHeader = (const VSS2_VARIABLE_STORE_HEADER*)currentPos;
            if (vssHeader->Format != NVRAM_VSS_VARIABLE_STORE_FORMATTED) {
                msg(usprintf("%s: VSS2 store candidate at offset %Xh skipped, has invalid format %02Xh", __FUNCTION__, localOffset + offset, vssHeader->Format), index);
                continue;
            }
            if (vssHeader->Size == 0 || vssHeader->Size == 0xFFFFFFFF) {
                msg(usprintf("%s: VSS2 store candidate at offset %Xh skipped, has invalid size %Xh", __FUNCTION__, localOffset + offset, vssHeader->Size), index);
                continue;
            }
            // All checks passed, store found
            break;
        }
        else if (*currentPos == NVRAM_FDC_VOLUME_SIGNATURE) { // FDC signature found
            const FDC_VOLUME_HEADER* fdcHeader = (const FDC_VOLUME_HEADER*)currentPos;
            if (fdcHeader->Size == 0 || fdcHeader->Size == 0xFFFFFFFF) {
                msg(usprintf("%s: FDC store candidate at offset %Xh skipped, has invalid size %Xh", __FUNCTION__, localOffset + offset, fdcHeader->Size), index);
                continue;
            }
            // All checks passed, store found
            break;
        }
        else if (*currentPos == NVRAM_APPLE_FSYS_STORE_SIGNATURE || *currentPos == NVRAM_APPLE_GAID_STORE_SIGNATURE) { // Fsys or Gaid signature found
            const APPLE_FSYS_STORE_HEADER* fsysHeader = (const APPLE_FSYS_STORE_HEADER*)currentPos;
            if (fsysHeader->Size == 0 || fsysHeader->Size == 0xFFFF) {
                msg(usprintf("%s: Fsys store candidate at offset %Xh skipped, has invalid size %Xh", __FUNCTION__, localOffset + offset, fsysHeader->Size), index);
                continue;
            }
            // All checks passed, store found
            break;
        }
        else if (*currentPos == NVRAM_EVSA_STORE_SIGNATURE) { //EVSA signature found
            if (offset < sizeof(UINT32))
                continue;

            const EVSA_STORE_ENTRY* evsaHeader = (const EVSA_STORE_ENTRY*)(currentPos - 1);
            if (evsaHeader->Header.Type != NVRAM_EVSA_ENTRY_TYPE_STORE) {
                msg(usprintf("%s: EVSA store candidate at offset %Xh skipped, has invalid type %02Xh", __FUNCTION__, localOffset + offset - 4, evsaHeader->Header.Type), index);
                continue;
            }
            if (evsaHeader->StoreSize == 0 || evsaHeader->StoreSize == 0xFFFFFFFF) {
                msg(usprintf("%s: EVSA store candidate at offset %Xh skipped, has invalid size %Xh", __FUNCTION__, localOffset + offset, evsaHeader->StoreSize), index);
                continue;
            }
            // All checks passed, store found
            offset -= sizeof(UINT32);
            break;
        }
        else if (*currentPos == NVRAM_MAIN_STORE_VOLUME_GUID_DATA1 || *currentPos == EDKII_WORKING_BLOCK_SIGNATURE_GUID_DATA1) { // Possible FTW block signature found
            UByteArray guid = UByteArray(volume.constData() + offset, sizeof(EFI_GUID));
            if (guid != NVRAM_MAIN_STORE_VOLUME_GUID && guid != EDKII_WORKING_BLOCK_SIGNATURE_GUID && guid != VSS2_WORKING_BLOCK_SIGNATURE_GUID) // Check the whole signature
                continue;

            // Detect header variant based on WriteQueueSize
            const EFI_FAULT_TOLERANT_WORKING_BLOCK_HEADER32* ftwHeader = (const EFI_FAULT_TOLERANT_WORKING_BLOCK_HEADER32*)currentPos;
            if (ftwHeader->WriteQueueSize % 0x10 == 0x04) { // Header with 32 bit WriteQueueSize
                if (ftwHeader->WriteQueueSize == 0 || ftwHeader->WriteQueueSize == 0xFFFFFFFF) {
                    msg(usprintf("%s: FTW block candidate at offset %Xh skipped, has invalid body size %Xh", __FUNCTION__, localOffset + offset, ftwHeader->WriteQueueSize), index);
                    continue;
                }
            }
            else if (ftwHeader->WriteQueueSize % 0x10 == 0x00) { // Header with 64 bit WriteQueueSize
                const EFI_FAULT_TOLERANT_WORKING_BLOCK_HEADER64* ftw64Header = (const EFI_FAULT_TOLERANT_WORKING_BLOCK_HEADER64*)currentPos;
                if (ftw64Header->WriteQueueSize == 0 || ftw64Header->WriteQueueSize >= 0xFFFFFFFF) {
                    msg(usprintf("%s: FTW block candidate at offset %Xh skipped, has invalid body size %Xh", __FUNCTION__, localOffset + offset, ftw64Header->WriteQueueSize), index);
                    continue;
                }
            }
            else // Unknown header
                continue;

            // All checks passed, store found
            break;
        }
        else if (*currentPos == NVRAM_PHOENIX_FLASH_MAP_SIGNATURE_PART1) {// Phoenix SCT flash map
            UByteArray signature = UByteArray(volume.constData() + offset, NVRAM_PHOENIX_FLASH_MAP_SIGNATURE_LENGTH);
            if (signature != NVRAM_PHOENIX_FLASH_MAP_SIGNATURE) // Check the whole signature
                continue;

            // All checks passed, store found
            break;
        }
        else if (*currentPos == NVRAM_PHOENIX_CMDB_HEADER_SIGNATURE) { // Phoenix SCT CMDB store
            const PHOENIX_CMDB_HEADER* cmdbHeader = (const PHOENIX_CMDB_HEADER*)currentPos;

            // Check size
            if (cmdbHeader->HeaderSize != sizeof(PHOENIX_CMDB_HEADER))
                continue;

            // All checks passed, store found
            break;
        }
        else if (*currentPos == INTEL_MICROCODE_HEADER_VERSION_1) {// Intel microcode
            const INTEL_MICROCODE_HEADER* ucodeHeader = (const INTEL_MICROCODE_HEADER*)currentPos;
            
            // TotalSize is greater then DataSize and is multiple of 1024
            if (FALSE == ffsParser->microcodeHeaderValid(ucodeHeader)) {
                continue;
            }

            // All checks passed, store found
            break;
        }
        else if (*currentPos == OEM_ACTIVATION_PUBKEY_MAGIC) { // SLIC pubkey
            if (offset < 4 * sizeof(UINT32))
                continue;

            const OEM_ACTIVATION_PUBKEY* pubkeyHeader = (const OEM_ACTIVATION_PUBKEY*)(currentPos - 4);
            // Check type
            if (pubkeyHeader->Type != OEM_ACTIVATION_PUBKEY_TYPE)
                continue;

            // All checks passed, store found
            offset -= 4 * sizeof(UINT32);
            break;
        }
        else if (*currentPos == OEM_ACTIVATION_MARKER_WINDOWS_FLAG_PART1) { // SLIC marker
            if (offset >= dataSize - sizeof(UINT64) ||
                *(const UINT64*)currentPos != OEM_ACTIVATION_MARKER_WINDOWS_FLAG ||
                offset < 26) // Check full windows flag and structure size
                continue;

            const OEM_ACTIVATION_MARKER* markerHeader = (const OEM_ACTIVATION_MARKER*)(volume.constData() + offset - 26);
            // Check reserved bytes
            bool reservedBytesValid = true;
            for (UINT32 i = 0; i < sizeof(markerHeader->Reserved); i++)
                if (markerHeader->Reserved[i] != OEM_ACTIVATION_MARKER_RESERVED_BYTE) {
                    reservedBytesValid = false;
                    break;
                }
            if (!reservedBytesValid)
                continue;

            // All checks passed, store found
            offset -= 26;
            break;
        }
    }
    // No more stores found
    if (offset >= dataSize - sizeof(UINT32))
        return U_STORES_NOT_FOUND;

    nextStoreOffset = offset;

    return U_SUCCESS;
}

USTATUS NvramParser::getStoreSize(const UByteArray & data, const UINT32 storeOffset, UINT32 & storeSize)
{
    const UINT32* signature = (const UINT32*)(data.constData() + storeOffset);
    if (*signature == NVRAM_VSS_STORE_SIGNATURE || *signature == NVRAM_APPLE_SVS_STORE_SIGNATURE || *signature == NVRAM_APPLE_NSS_STORE_SIGNATURE) {
        const VSS_VARIABLE_STORE_HEADER* vssHeader = (const VSS_VARIABLE_STORE_HEADER*)signature;
        storeSize = vssHeader->Size;
    }
    else if (*signature == NVRAM_VSS2_AUTH_VAR_KEY_DATABASE_GUID_PART1 || *signature == NVRAM_VSS2_STORE_GUID_PART1) {
        const VSS2_VARIABLE_STORE_HEADER* vssHeader = (const VSS2_VARIABLE_STORE_HEADER*)signature;
        storeSize = vssHeader->Size;
    }
    else if (*signature == NVRAM_FDC_VOLUME_SIGNATURE) {
        const FDC_VOLUME_HEADER* fdcHeader = (const FDC_VOLUME_HEADER*)signature;
        storeSize = fdcHeader->Size;
    }
    else if (*signature == NVRAM_APPLE_FSYS_STORE_SIGNATURE || *signature == NVRAM_APPLE_GAID_STORE_SIGNATURE) {
        const APPLE_FSYS_STORE_HEADER* fsysHeader = (const APPLE_FSYS_STORE_HEADER*)signature;
        storeSize = fsysHeader->Size;
    }
    else if (*(signature + 1) == NVRAM_EVSA_STORE_SIGNATURE) {
        const EVSA_STORE_ENTRY* evsaHeader = (const EVSA_STORE_ENTRY*)signature;
        storeSize = evsaHeader->StoreSize;
    }
    else if (*signature == NVRAM_MAIN_STORE_VOLUME_GUID_DATA1 || *signature == EDKII_WORKING_BLOCK_SIGNATURE_GUID_DATA1) {
        const EFI_FAULT_TOLERANT_WORKING_BLOCK_HEADER32* ftwHeader = (const EFI_FAULT_TOLERANT_WORKING_BLOCK_HEADER32*)signature;
        if (ftwHeader->WriteQueueSize % 0x10 == 0x04) { // Header with 32 bit WriteQueueSize
            storeSize = sizeof(EFI_FAULT_TOLERANT_WORKING_BLOCK_HEADER32) + ftwHeader->WriteQueueSize;
        }
        else { //  Header with 64 bit WriteQueueSize
            const EFI_FAULT_TOLERANT_WORKING_BLOCK_HEADER64* ftw64Header = (const EFI_FAULT_TOLERANT_WORKING_BLOCK_HEADER64*)signature;
            storeSize = sizeof(EFI_FAULT_TOLERANT_WORKING_BLOCK_HEADER64) + (UINT32)ftw64Header->WriteQueueSize;
        }
    }
    else if (*signature == NVRAM_PHOENIX_FLASH_MAP_SIGNATURE_PART1) { // Phoenix SCT flash map
        const PHOENIX_FLASH_MAP_HEADER* flashMapHeader = (const PHOENIX_FLASH_MAP_HEADER*)signature;
        storeSize = sizeof(PHOENIX_FLASH_MAP_HEADER) + sizeof(PHOENIX_FLASH_MAP_ENTRY) * flashMapHeader->NumEntries;
    }
    else if (*signature == NVRAM_PHOENIX_CMDB_HEADER_SIGNATURE) { // Phoenix SCT CMDB store
        storeSize = NVRAM_PHOENIX_CMDB_SIZE; // It's a predefined max size, no need to calculate
    }
    else if (*(signature + 4) == OEM_ACTIVATION_PUBKEY_MAGIC) { // SLIC pubkey
        const OEM_ACTIVATION_PUBKEY* pubkeyHeader = (const OEM_ACTIVATION_PUBKEY*)signature;
        storeSize = pubkeyHeader->Size;
    }
    else if (*(const UINT64*)(data.constData() + storeOffset + 26) == OEM_ACTIVATION_MARKER_WINDOWS_FLAG) { // SLIC marker
        const OEM_ACTIVATION_MARKER* markerHeader = (const OEM_ACTIVATION_MARKER*)signature;
        storeSize = markerHeader->Size;
    }
    else if (*signature == INTEL_MICROCODE_HEADER_VERSION_1) { // Intel microcode, must be checked after SLIC marker because of the same *signature values
        const INTEL_MICROCODE_HEADER* ucodeHeader = (const INTEL_MICROCODE_HEADER*)signature;
        storeSize = ucodeHeader->TotalSize;
    } else {
        return U_INVALID_PARAMETER; // Unreachable
    }
    return U_SUCCESS;
}

USTATUS NvramParser::parseVssStoreHeader(const UByteArray & store, const UINT32 localOffset, const bool sizeOverride, const UModelIndex & parent, UModelIndex & index)
{
    const UINT32 dataSize = (const UINT32)store.size();

    // Check store size
    if (dataSize < sizeof(VSS_VARIABLE_STORE_HEADER)) {
        msg(usprintf("%s: volume body is too small even for VSS store header", __FUNCTION__), parent);
        return U_SUCCESS;
    }

    // Get VSS store header
    const VSS_VARIABLE_STORE_HEADER* vssStoreHeader = (const VSS_VARIABLE_STORE_HEADER*)store.constData();

    // Check for size override
    UINT32 storeSize = vssStoreHeader->Size;
    if (sizeOverride) {
        storeSize = dataSize;
    }

    // Check store size
    if (dataSize < storeSize) {
        msg(usprintf("%s: VSS store size %Xh (%u) is greater than volume body size %Xh (%u)", __FUNCTION__,
            storeSize, storeSize,
            dataSize, dataSize), parent);
        return U_SUCCESS;
    }

    // Construct header and body
    UByteArray header = store.left(sizeof(VSS_VARIABLE_STORE_HEADER));
    UByteArray body = store.mid(sizeof(VSS_VARIABLE_STORE_HEADER), storeSize - sizeof(VSS_VARIABLE_STORE_HEADER));

    // Add info
    UString name;
    if (vssStoreHeader->Signature == NVRAM_APPLE_SVS_STORE_SIGNATURE) {
        name = UString("SVS store");
    }
    else if (vssStoreHeader->Signature == NVRAM_APPLE_NSS_STORE_SIGNATURE) {
        name = UString("NSS store");
    }
    else {
        name = UString("VSS store");
    }
    
    UString info = usprintf("Signature: %Xh\nFull size: %Xh (%u)\nHeader size: %Xh (%u)\nBody size: %Xh (%u)\nFormat: %02Xh\nState: %02Xh\nUnknown: %04Xh",
        vssStoreHeader->Signature,
        storeSize, storeSize,
        header.size(), header.size(),
        body.size(), body.size(),
        vssStoreHeader->Format,
        vssStoreHeader->State,
        vssStoreHeader->Unknown);

    // Add tree item
    index = model->addItem(localOffset, Types::VssStore, 0, name, UString(), info, header, body, UByteArray(), Fixed, parent);

    return U_SUCCESS;
}

USTATUS NvramParser::parseVss2StoreHeader(const UByteArray & store, const UINT32 localOffset, const bool sizeOverride, const UModelIndex & parent, UModelIndex & index)
{
    const UINT32 dataSize = (const UINT32)store.size();

    // Check store size
    if (dataSize < sizeof(VSS2_VARIABLE_STORE_HEADER)) {
        msg(usprintf("%s: volume body is too small even for VSS2 store header", __FUNCTION__), parent);
        return U_SUCCESS;
    }

    // Get VSS2 store header
    const VSS2_VARIABLE_STORE_HEADER* vssStoreHeader = (const VSS2_VARIABLE_STORE_HEADER*)store.constData();

    // Check for size override
    UINT32 storeSize = vssStoreHeader->Size;
    if (sizeOverride) {
        storeSize = dataSize;
    }

    // Check store size
    if (dataSize < storeSize) {
        msg(usprintf("%s: VSS2 store size %Xh (%u) is greater than volume body size %Xh (%u)", __FUNCTION__,
            storeSize, storeSize,
            dataSize, dataSize), parent);
        return U_SUCCESS;
    }

    // Construct header and body
    UByteArray header = store.left(sizeof(VSS2_VARIABLE_STORE_HEADER));
    UByteArray body = store.mid(sizeof(VSS2_VARIABLE_STORE_HEADER), storeSize - sizeof(VSS2_VARIABLE_STORE_HEADER));

    // Add info
    UString name = UString("VSS2 store");
    UString info = UString("Signature: ") + guidToUString(vssStoreHeader->Signature, false) +
        usprintf("\nFull size: %Xh (%u)\nHeader size: %Xh (%u)\nBody size: %Xh (%u)\nFormat: %02Xh\nState: %02Xh\nUnknown: %04Xh",
            storeSize, storeSize,
            header.size(), header.size(),
            body.size(), body.size(),
            vssStoreHeader->Format,
            vssStoreHeader->State,
            vssStoreHeader->Unknown);

    // Add tree item
    index = model->addItem(localOffset, Types::Vss2Store, 0, name, UString(), info, header, body, UByteArray(), Fixed, parent);

    return U_SUCCESS;
}

USTATUS NvramParser::parseFtwStoreHeader(const UByteArray & store, const UINT32 localOffset, const UModelIndex & parent, UModelIndex & index)
{
    const UINT32 dataSize = (const UINT32)store.size();

    // Check store size
    if (dataSize < sizeof(EFI_FAULT_TOLERANT_WORKING_BLOCK_HEADER64)) {
        msg(usprintf("%s: volume body is too small even for FTW store header", __FUNCTION__), parent);
        return U_SUCCESS;
    }

    // Obtain required information from parent volume
    UINT8 emptyByte = 0xFF;
    UModelIndex parentVolumeIndex = model->findParentOfType(parent, Types::Volume);
    if (parentVolumeIndex.isValid() && model->hasEmptyParsingData(parentVolumeIndex) == false) {
        UByteArray data = model->parsingData(parentVolumeIndex);
        const VOLUME_PARSING_DATA* pdata = (const VOLUME_PARSING_DATA*)data.constData();
        emptyByte = pdata->emptyByte;
    }

    // Get FTW block headers
    const EFI_FAULT_TOLERANT_WORKING_BLOCK_HEADER32* ftw32BlockHeader = (const EFI_FAULT_TOLERANT_WORKING_BLOCK_HEADER32*)store.constData();
    const EFI_FAULT_TOLERANT_WORKING_BLOCK_HEADER64* ftw64BlockHeader = (const EFI_FAULT_TOLERANT_WORKING_BLOCK_HEADER64*)store.constData();

    // Check store size
    UINT32 ftwBlockSize;
    bool has32bitHeader;
    if (ftw32BlockHeader->WriteQueueSize % 0x10 == 0x04) { // Header with 32 bit WriteQueueSize
        ftwBlockSize = sizeof(EFI_FAULT_TOLERANT_WORKING_BLOCK_HEADER32) + ftw32BlockHeader->WriteQueueSize;
        has32bitHeader = true;
    }
    else { // Header with 64 bit WriteQueueSize
        ftwBlockSize = sizeof(EFI_FAULT_TOLERANT_WORKING_BLOCK_HEADER64) + (UINT32)ftw64BlockHeader->WriteQueueSize;
        has32bitHeader = false;
    }
    if (dataSize < ftwBlockSize) {
        msg(usprintf("%s: FTW store size %Xh (%u) is greater than volume body size %Xh (%u)", __FUNCTION__,
            ftwBlockSize, ftwBlockSize,
            dataSize, dataSize), parent);
        return U_SUCCESS;
    }

    // Construct header and body
    UINT32 headerSize = has32bitHeader ? sizeof(EFI_FAULT_TOLERANT_WORKING_BLOCK_HEADER32) : sizeof(EFI_FAULT_TOLERANT_WORKING_BLOCK_HEADER64);
    UByteArray header = store.left(headerSize);
    UByteArray body = store.mid(headerSize, ftwBlockSize - headerSize);

    // Check block header checksum
    UByteArray crcHeader = header;
    EFI_FAULT_TOLERANT_WORKING_BLOCK_HEADER32* crcFtwBlockHeader = (EFI_FAULT_TOLERANT_WORKING_BLOCK_HEADER32*)header.data();
    crcFtwBlockHeader->Crc = emptyByte ? 0xFFFFFFFF : 0;
    crcFtwBlockHeader->State = emptyByte ? 0xFF : 0;
    UINT32 calculatedCrc = (UINT32)crc32(0, (const UINT8*)crcFtwBlockHeader, headerSize);

    // Add info
    UString name("FTW store");
    UString info = UString("Signature: ") + guidToUString(ftw32BlockHeader->Signature, false) +
        usprintf("\nFull size: %Xh (%u)\nHeader size: %Xh (%u)\nBody size: %Xh (%u)\nState: %02Xh\nHeader CRC32: %08Xh",
            ftwBlockSize, ftwBlockSize,
            headerSize, headerSize,
            body.size(), body.size(),
            ftw32BlockHeader->State,
            ftw32BlockHeader->Crc) +
            (ftw32BlockHeader->Crc != calculatedCrc ? usprintf(", invalid, should be %08Xh", calculatedCrc) : UString(", valid"));

    // Add tree item
    index = model->addItem(localOffset, Types::FtwStore, 0, name, UString(), info, header, body, UByteArray(), Fixed, parent);

    return U_SUCCESS;
}

USTATUS NvramParser::parseFdcStoreHeader(const UByteArray & store, const UINT32 localOffset, const UModelIndex & parent, UModelIndex & index)
{
    const UINT32 dataSize = (const UINT32)store.size();

    // Check store size
    if (dataSize < sizeof(FDC_VOLUME_HEADER)) {
        msg(usprintf("%s: volume body is too small even for FDC store header", __FUNCTION__), parent);
        return U_SUCCESS;
    }

    // Get Fdc store header
    const FDC_VOLUME_HEADER* fdcStoreHeader = (const FDC_VOLUME_HEADER*)store.constData();

    // Check store size
    if (dataSize < fdcStoreHeader->Size) {
        msg(usprintf("%s: FDC store size %Xh (%u) is greater than volume body size %Xh (%u)", __FUNCTION__,
            fdcStoreHeader->Size, fdcStoreHeader->Size,
            dataSize, dataSize), parent);
        return U_SUCCESS;
    }

    // Construct header and body
    UByteArray header = store.left(sizeof(FDC_VOLUME_HEADER));
    UByteArray body = store.mid(sizeof(FDC_VOLUME_HEADER), fdcStoreHeader->Size - sizeof(FDC_VOLUME_HEADER));

    // Add info
    UString name("FDC store");
    UString info = usprintf("Signature: _FDC\nFull size: %Xh (%u)\nHeader size: %Xh (%u)\nBody size: %Xh (%u)",
        fdcStoreHeader->Size, fdcStoreHeader->Size,
        header.size(), header.size(),
        body.size(), body.size());

    // Add tree item
    index = model->addItem(localOffset, Types::FdcStore, 0, name, UString(), info, header, body, UByteArray(), Fixed, parent);

    return U_SUCCESS;
}

USTATUS NvramParser::parseFsysStoreHeader(const UByteArray & store, const UINT32 localOffset, const UModelIndex & parent, UModelIndex & index)
{
    const UINT32 dataSize = (const UINT32)store.size();

    // Check store size
    if (dataSize < sizeof(APPLE_FSYS_STORE_HEADER)) {
        msg(usprintf("%s: volume body is too small even for Fsys store header", __FUNCTION__), parent);
        return U_SUCCESS;
    }

    // Get Fsys store header
    const APPLE_FSYS_STORE_HEADER* fsysStoreHeader = (const APPLE_FSYS_STORE_HEADER*)store.constData();

    // Check store size
    if (dataSize < fsysStoreHeader->Size) {
        msg(usprintf("%s: Fsys store size %Xh (%u) is greater than volume body size %Xh (%u)", __FUNCTION__,
            fsysStoreHeader->Size, fsysStoreHeader->Size,
            dataSize, dataSize), parent);
        return U_SUCCESS;
    }

    // Construct header and body
    UByteArray header = store.left(sizeof(APPLE_FSYS_STORE_HEADER));
    UByteArray body = store.mid(sizeof(APPLE_FSYS_STORE_HEADER), fsysStoreHeader->Size - sizeof(APPLE_FSYS_STORE_HEADER) - sizeof(UINT32));

    // Check store checksum
    UINT32 storedCrc = *(UINT32*)store.right(sizeof(UINT32)).constData();
    UINT32 calculatedCrc = (UINT32)crc32(0, (const UINT8*)store.constData(), (const UINT32)store.size() - sizeof(UINT32));

    // Add info
    bool isGaidStore = (fsysStoreHeader->Signature == NVRAM_APPLE_GAID_STORE_SIGNATURE);
    UString name = isGaidStore ? UString("Gaid store") : UString("Fsys store");
    UString info = usprintf("Signature: %s\nFull size: %Xh (%u)\nHeader size: %Xh (%u)\nBody size: %Xh (%u)\nUnknown0: %02Xh\nUnknown1: %08Xh\nCRC32: %08Xh",
        isGaidStore ? "Gaid" : "Fsys",
        fsysStoreHeader->Size, fsysStoreHeader->Size,
        header.size(), header.size(),
        body.size(), body.size(),
        fsysStoreHeader->Unknown0,
        fsysStoreHeader->Unknown1)
        + (storedCrc != calculatedCrc ? usprintf(", invalid, should be %08Xh", calculatedCrc) : UString(", valid"));

    // Add tree item
    index = model->addItem(localOffset, Types::FsysStore, 0, name, UString(), info, header, body, UByteArray(), Fixed, parent);

    return U_SUCCESS;
}

USTATUS NvramParser::parseEvsaStoreHeader(const UByteArray & store, const UINT32 localOffset, const UModelIndex & parent, UModelIndex & index)
{
    const UINT32 dataSize = (const UINT32)store.size();

    // Check dataSize
    if (dataSize < sizeof(EVSA_STORE_ENTRY)) {
        msg(usprintf("%s: volume body is too small even for EVSA store header", __FUNCTION__), parent);
        return U_SUCCESS;
    }

    // Get EVSA store header
    const EVSA_STORE_ENTRY* evsaStoreHeader = (const EVSA_STORE_ENTRY*)store.constData();

    // Check store size
    if (dataSize < evsaStoreHeader->StoreSize) {
        msg(usprintf("%s: EVSA store size %Xh (%u) is greater than volume body size %Xh (%u)", __FUNCTION__,
            evsaStoreHeader->StoreSize, evsaStoreHeader->StoreSize,
            dataSize, dataSize), parent);
        return U_SUCCESS;
    }

    // Construct header and body
    UByteArray header = store.left(evsaStoreHeader->Header.Size);
    UByteArray body = store.mid(evsaStoreHeader->Header.Size, evsaStoreHeader->StoreSize - evsaStoreHeader->Header.Size);

    // Recalculate checksum
    UINT8 calculated = calculateChecksum8(((const UINT8*)evsaStoreHeader) + 2, evsaStoreHeader->Header.Size - 2);

    // Add info
    UString name("EVSA store");
    UString info = usprintf("Signature: EVSA\nFull size: %Xh (%u)\nHeader size: %Xh (%u)\nBody size: %Xh (%u)\nType: %02Xh\nAttributes: %08Xh\nChecksum: %02Xh",
        evsaStoreHeader->StoreSize, evsaStoreHeader->StoreSize,
        header.size(), header.size(),
        body.size(), body.size(),
        evsaStoreHeader->Header.Type,
        evsaStoreHeader->Attributes,
        evsaStoreHeader->Header.Checksum) +
        (evsaStoreHeader->Header.Checksum != calculated ? usprintf("%, invalid, should be %02Xh", calculated) : UString(", valid"));

    // Add tree item
    index = model->addItem(localOffset, Types::EvsaStore, 0, name, UString(), info, header, body, UByteArray(), Fixed, parent);

    return U_SUCCESS;
}

USTATUS NvramParser::parseFlashMapStoreHeader(const UByteArray & store, const UINT32 localOffset, const UModelIndex & parent, UModelIndex & index)
{
    const UINT32 dataSize = (const UINT32)store.size();

    // Check data size
    if (dataSize < sizeof(PHOENIX_FLASH_MAP_HEADER)) {
        msg(usprintf("%s: volume body is too small even for FlashMap block header", __FUNCTION__), parent);
        return U_SUCCESS;
    }

    // Get FlashMap block header
    const PHOENIX_FLASH_MAP_HEADER* flashMapHeader = (const PHOENIX_FLASH_MAP_HEADER*)store.constData();

    // Check store size
    UINT32 flashMapSize = sizeof(PHOENIX_FLASH_MAP_HEADER) + flashMapHeader->NumEntries * sizeof(PHOENIX_FLASH_MAP_ENTRY);
    if (dataSize < flashMapSize) {
        msg(usprintf("%s: FlashMap block size %Xh (%u) is greater than volume body size %Xh (%u)", __FUNCTION__,
            flashMapSize, flashMapSize,
            dataSize, dataSize), parent);
        return U_SUCCESS;
    }

    // Construct header and body
    UByteArray header = store.left(sizeof(PHOENIX_FLASH_MAP_HEADER));
    UByteArray body = store.mid(sizeof(PHOENIX_FLASH_MAP_HEADER), flashMapSize - sizeof(PHOENIX_FLASH_MAP_HEADER));

    // Add info
    UString name("Phoenix SCT flash map");
    UString info = usprintf("Signature: _FLASH_MAP\nFull size: %Xh (%u)\nHeader size: %Xh (%u)\nBody size: %Xh (%u)\nNumber of entries: %u",
        flashMapSize, flashMapSize,
        header.size(), header.size(),
        body.size(), body.size(),
        flashMapHeader->NumEntries);

    // Add tree item
    index = model->addItem(localOffset, Types::FlashMapStore, 0, name, UString(), info, header, body, UByteArray(), Fixed, parent);

    return U_SUCCESS;
}

USTATUS NvramParser::parseCmdbStoreHeader(const UByteArray & store, const UINT32 localOffset, const UModelIndex & parent, UModelIndex & index)
{
    const UINT32 dataSize = (const UINT32)store.size();

    // Check store size
    if (dataSize < sizeof(PHOENIX_CMDB_HEADER)) {
        msg(usprintf("%s: volume body is too small even for CMDB store header", __FUNCTION__), parent);
        return U_SUCCESS;
    }

    UINT32 cmdbSize = NVRAM_PHOENIX_CMDB_SIZE;
    if (dataSize < cmdbSize) {
        msg(usprintf("%s: CMDB store size %Xh (%u) is greater than volume body size %Xh (%u)", __FUNCTION__,
            cmdbSize, cmdbSize,
            dataSize, dataSize), parent);
        return U_SUCCESS;
    }

    // Get store header
    const PHOENIX_CMDB_HEADER* cmdbHeader = (const PHOENIX_CMDB_HEADER*)store.constData();

    // Construct header and body
    UByteArray header = store.left(cmdbHeader->TotalSize);
    UByteArray body = store.mid(cmdbHeader->TotalSize, cmdbSize - cmdbHeader->TotalSize);

    // Add info
    UString name("CMDB store");
    UString info = usprintf("Signature: CMDB\nFull size: %Xh (%u)\nHeader size: %Xh (%u)\nBody size: %Xh (%u)",
        cmdbSize, cmdbSize,
        header.size(), header.size(),
        body.size(), body.size());

    // Add tree item
    index = model->addItem(localOffset, Types::CmdbStore, 0, name, UString(), info, header, body, UByteArray(), Fixed, parent);

    return U_SUCCESS;
}

USTATUS NvramParser::parseSlicPubkeyHeader(const UByteArray & store, const UINT32 localOffset, const UModelIndex & parent, UModelIndex & index)
{
    const UINT32 dataSize = (const UINT32)store.size();

    // Check data size
    if (dataSize < sizeof(OEM_ACTIVATION_PUBKEY)) {
        msg(usprintf("%s: volume body is too small even for SLIC pubkey header", __FUNCTION__), parent);
        return U_SUCCESS;
    }

    // Get SLIC pubkey header
    const OEM_ACTIVATION_PUBKEY* pubkeyHeader = (const OEM_ACTIVATION_PUBKEY*)store.constData();

    // Check store size
    if (dataSize < pubkeyHeader->Size) {
        msg(usprintf("%s: SLIC pubkey size %Xh (%u) is greater than volume body size %Xh (%u)", __FUNCTION__,
            pubkeyHeader->Size, pubkeyHeader->Size,
            dataSize, dataSize), parent);
        return U_SUCCESS;
    }

    // Construct header and body
    UByteArray header = store.left(sizeof(OEM_ACTIVATION_PUBKEY));

    // Add info
    UString name("SLIC pubkey");
    UString info = usprintf("Type: 0h\nFull size: %Xh (%u)\nHeader size: %Xh (%u)\nBody size: 0h (0)\n"
        "Key type: %02Xh\nVersion: %02Xh\nAlgorithm: %08Xh\nMagic: RSA1\nBit length: %08Xh\nExponent: %08Xh",
        pubkeyHeader->Size, pubkeyHeader->Size,
        header.size(), header.size(),
        pubkeyHeader->KeyType,
        pubkeyHeader->Version,
        pubkeyHeader->Algorithm,
        pubkeyHeader->BitLength,
        pubkeyHeader->Exponent);

    // Add tree item
    index = model->addItem(localOffset, Types::SlicData, Subtypes::PubkeySlicData, name, UString(), info, header, UByteArray(), UByteArray(), Fixed, parent);

    return U_SUCCESS;
}

USTATUS NvramParser::parseSlicMarkerHeader(const UByteArray & store, const UINT32 localOffset, const UModelIndex & parent, UModelIndex & index)
{
    const UINT32 dataSize = (const UINT32)store.size();

    // Check data size
    if (dataSize < sizeof(OEM_ACTIVATION_MARKER)) {
        msg(usprintf("%s: volume body is too small even for SLIC marker header", __FUNCTION__), parent);
        return U_SUCCESS;
    }

    // Get SLIC marker header
    const OEM_ACTIVATION_MARKER* markerHeader = (const OEM_ACTIVATION_MARKER*)store.constData();

    // Check store size
    if (dataSize < markerHeader->Size) {
        msg(usprintf("%s: SLIC marker size %Xh (%u) is greater than volume body size %Xh (%u)", __FUNCTION__,
            markerHeader->Size, markerHeader->Size,
            dataSize, dataSize), parent);
        return U_SUCCESS;
    }

    // Construct header and body
    UByteArray header = store.left(sizeof(OEM_ACTIVATION_MARKER));

    // Add info
    UString name("SLIC marker");
    UString info = usprintf("Type: 1h\nFull size: %Xh (%u)\nHeader size: %Xh (%u)\nBody size: 0h (0)\n"
        "Version: %08Xh\nOEM ID: %s\nOEM table ID: %s\nWindows flag: WINDOWS\nSLIC version: %08Xh",
        markerHeader->Size, markerHeader->Size,
        header.size(), header.size(),
        markerHeader->Version,
        (const char*)UString((const char*)&(markerHeader->OemId)).left(6).toLocal8Bit(),
        (const char*)UString((const char*)&(markerHeader->OemTableId)).left(8).toLocal8Bit(),
        markerHeader->SlicVersion);


    // Add tree item
    index = model->addItem(localOffset, Types::SlicData, Subtypes::MarkerSlicData, name, UString(), info, header, UByteArray(), UByteArray(), Fixed, parent);

    return U_SUCCESS;
}

USTATUS NvramParser::parseStoreHeader(const UByteArray & store, const UINT32 localOffset, const UModelIndex & parent, UModelIndex & index)
{
    const UINT32 dataSize = (const UINT32)store.size();
    const UINT32* signature = (const UINT32*)store.constData();
    // Check store size
    if (dataSize < sizeof(UINT32)) {
        msg(usprintf("%s: volume body is too small even for a store signature", __FUNCTION__), parent);
        return U_SUCCESS;
    }

    // Check signature and run parser function needed
    // VSS/SVS/NSS store
    if (*signature == NVRAM_VSS_STORE_SIGNATURE || *signature == NVRAM_APPLE_SVS_STORE_SIGNATURE || *signature == NVRAM_APPLE_NSS_STORE_SIGNATURE)
        return parseVssStoreHeader(store, localOffset, false, parent, index);
    // VSS2 store
    if (*signature == NVRAM_VSS2_AUTH_VAR_KEY_DATABASE_GUID_PART1 || *signature == NVRAM_VSS2_STORE_GUID_PART1)
        return parseVss2StoreHeader(store, localOffset, false, parent, index);
    // FTW store
    else if (*signature == NVRAM_MAIN_STORE_VOLUME_GUID_DATA1 || *signature == EDKII_WORKING_BLOCK_SIGNATURE_GUID_DATA1)
        return parseFtwStoreHeader(store, localOffset, parent, index);
    // FDC store
    else if (*signature == NVRAM_FDC_VOLUME_SIGNATURE)
        return parseFdcStoreHeader(store, localOffset, parent, index);
    // Apple Fsys/Gaid store
    else if (*signature == NVRAM_APPLE_FSYS_STORE_SIGNATURE || *signature == NVRAM_APPLE_GAID_STORE_SIGNATURE)
        return parseFsysStoreHeader(store, localOffset, parent, index);
    // EVSA store
    else if (dataSize >= 2 * sizeof(UINT32) && *(signature + 1) == NVRAM_EVSA_STORE_SIGNATURE)
        return parseEvsaStoreHeader(store, localOffset, parent, index);
    // Phoenix SCT flash map
    else if (*signature == NVRAM_PHOENIX_FLASH_MAP_SIGNATURE_PART1)
        return parseFlashMapStoreHeader(store, localOffset, parent, index);
    // Phoenix CMDB store
    else if (*signature == NVRAM_PHOENIX_CMDB_HEADER_SIGNATURE)
        return parseCmdbStoreHeader(store, localOffset, parent, index);
    // SLIC pubkey
    else if (dataSize >= 5 * sizeof(UINT32) && *(signature + 4) == OEM_ACTIVATION_PUBKEY_MAGIC)
        return parseSlicPubkeyHeader(store, localOffset, parent, index);
    // SLIC marker
    else if (dataSize >= 34 && *(const UINT64*)(store.constData() + 26) == OEM_ACTIVATION_MARKER_WINDOWS_FLAG)
        return parseSlicMarkerHeader(store, localOffset, parent, index);
    // Intel microcode
    // Must be checked after SLIC marker because of the same *signature values
    else if (*signature == INTEL_MICROCODE_HEADER_VERSION_1)
        return ffsParser->parseIntelMicrocodeHeader(store, localOffset, parent, index);

    msg(usprintf("parseStoreHeader: don't know how to parse a header with signature %08Xh", *signature), parent);
    return U_SUCCESS;
}

USTATUS NvramParser::parseFdcStoreBody(const UModelIndex & index)
{
    // Sanity check
    if (!index.isValid())
        return U_INVALID_PARAMETER;

    // Get item data
    const UByteArray data = model->body(index);

    // Get local offset
    UINT32 localOffset = model->header(index).size();

    // The body is a firmware volume with either a VSS or VSS2 store
    UModelIndex volumeIndex;
    USTATUS status = ffsParser->parseVolumeHeader(data, localOffset, index, volumeIndex);
    if (status || !volumeIndex.isValid()) {
        msg(usprintf("%s: store can't be parsed as FDC store", __FUNCTION__), index);
        return U_SUCCESS;
    }

    // Determine if it's a VSS or VSS2 store inside
    UByteArray store = model->body(volumeIndex);
    if ((UINT32)store.size() >= sizeof(UINT32) && *(const UINT32*)store.constData() == NVRAM_VSS_STORE_SIGNATURE) {
        UModelIndex vssIndex;
        status = parseVssStoreHeader(store, localOffset + model->header(volumeIndex).size(), true, volumeIndex, vssIndex);
        if (status)
            return status;
        return parseVssStoreBody(vssIndex, 0);
    }
    else if ((UINT32)store.size() >= sizeof(EFI_GUID) && store.left(sizeof(EFI_GUID)) == NVRAM_FDC_STORE_GUID) {
        UModelIndex vss2Index;
        status = parseVss2StoreHeader(store, localOffset + model->header(volumeIndex).size(), true, volumeIndex, vss2Index);
        if (status)
            return status;
        return parseVssStoreBody(vss2Index, 0);
    }
    else {
        msg(usprintf("%s: internal volume can't be parsed as VSS/VSS2 store", __FUNCTION__), index);
        return U_SUCCESS;
    }

}

USTATUS NvramParser::parseVssStoreBody(const UModelIndex & index, UINT8 alignment)
{
    // Sanity check
    if (!index.isValid())
        return U_INVALID_PARAMETER;

    // Obtain required information from parent volume
    UINT8 emptyByte = 0xFF;
    UModelIndex parentVolumeIndex = model->findParentOfType(index, Types::Volume);
    if (parentVolumeIndex.isValid() && model->hasEmptyParsingData(parentVolumeIndex) == false) {
        UByteArray data = model->parsingData(parentVolumeIndex);
        const VOLUME_PARSING_DATA* pdata = (const VOLUME_PARSING_DATA*)data.constData();
        emptyByte = pdata->emptyByte;
    }

    // Get local offset
    UINT32 localOffset = model->header(index).size();

    // Get item data
    const UByteArray data = model->body(index);

    // Check that the is enough space for variable header
    const UINT32 dataSize = (UINT32)data.size();
    if (dataSize < sizeof(VSS_VARIABLE_HEADER)) {
        msg(usprintf("%s: store body is too small even for VSS variable header", __FUNCTION__), index);
        return U_SUCCESS;
    }

    UINT32 offset = 0;

    // Parse all variables
    while (1) {
        bool isInvalid = true;
        bool isAuthenticated = false;
        bool isAppleCrc32 = false;
        bool isIntelSpecial = false;

        UINT32 storedCrc32 = 0;
        UINT32 calculatedCrc32 = 0;
        UINT64 monotonicCounter = 0;
        EFI_TIME timestamp = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
        UINT32 pubKeyIndex = 0;

        UINT8 subtype = 0;
        UString name;
        UString text;
        EFI_GUID* variableGuid = NULL;
        CHAR16*   variableName = (CHAR16*)L"";
        UByteArray header;
        UByteArray body;

        UINT32 unparsedSize = dataSize - offset;

        // Get variable header
        const VSS_VARIABLE_HEADER* variableHeader = (const VSS_VARIABLE_HEADER*)(data.constData() + offset);

        // Check variable header to fit in still unparsed data
        UINT32 variableSize = 0;
        if (unparsedSize >= sizeof(VSS_VARIABLE_HEADER)
            && variableHeader->StartId == NVRAM_VSS_VARIABLE_START_ID) {
            // Apple VSS variable with CRC32 of the data  
            if (variableHeader->Attributes & NVRAM_VSS_VARIABLE_APPLE_DATA_CHECKSUM) {
                isAppleCrc32 = true;
                if (unparsedSize < sizeof(VSS_APPLE_VARIABLE_HEADER)) {
                    variableSize = 0;
                }
                else {
                    const VSS_APPLE_VARIABLE_HEADER* appleVariableHeader = (const VSS_APPLE_VARIABLE_HEADER*)variableHeader;
                    variableSize = sizeof(VSS_APPLE_VARIABLE_HEADER) + appleVariableHeader->NameSize + appleVariableHeader->DataSize;
                    variableGuid = (EFI_GUID*)&appleVariableHeader->VendorGuid;
                    variableName = (CHAR16*)(appleVariableHeader + 1);

                    header = data.mid(offset, sizeof(VSS_APPLE_VARIABLE_HEADER) + appleVariableHeader->NameSize);
                    body = data.mid(offset + header.size(), appleVariableHeader->DataSize);

                    // Calculate CRC32 of the variable data
                    storedCrc32 = appleVariableHeader->DataCrc32;
                    calculatedCrc32 = (UINT32)crc32(0, (const UINT8*)body.constData(), body.size());
                }
            }

            // Authenticated variable
            else if ((variableHeader->Attributes & NVRAM_VSS_VARIABLE_AUTHENTICATED_WRITE_ACCESS)
                || (variableHeader->Attributes & NVRAM_VSS_VARIABLE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS)
                || (variableHeader->Attributes & NVRAM_VSS_VARIABLE_APPEND_WRITE)
                || (variableHeader->NameSize == 0 && variableHeader->DataSize == 0)) { // If both NameSize and DataSize are zeros, it's auth variable with zero montonic counter
                isAuthenticated = true;
                if (unparsedSize < sizeof(VSS_AUTH_VARIABLE_HEADER)) {
                    variableSize = 0;
                }
                else {
                    const VSS_AUTH_VARIABLE_HEADER* authVariableHeader = (const VSS_AUTH_VARIABLE_HEADER*)variableHeader;
                    variableSize = sizeof(VSS_AUTH_VARIABLE_HEADER) + authVariableHeader->NameSize + authVariableHeader->DataSize;
                    variableGuid = (EFI_GUID*)&authVariableHeader->VendorGuid;
                    variableName = (CHAR16*)(authVariableHeader + 1);

                    header = data.mid(offset, sizeof(VSS_AUTH_VARIABLE_HEADER) + authVariableHeader->NameSize);
                    body = data.mid(offset + header.size(), authVariableHeader->DataSize);

                    monotonicCounter = authVariableHeader->MonotonicCounter;
                    timestamp = authVariableHeader->Timestamp;
                    pubKeyIndex = authVariableHeader->PubKeyIndex;
                }
            }

            // Intel special variable
            else if (variableHeader->State == NVRAM_VSS_INTEL_VARIABLE_VALID
                || variableHeader->State == NVRAM_VSS_INTEL_VARIABLE_INVALID) {
                isIntelSpecial = true;
                const VSS_INTEL_VARIABLE_HEADER* intelVariableHeader = (const VSS_INTEL_VARIABLE_HEADER*)variableHeader;
                variableSize = intelVariableHeader->TotalSize;
                variableGuid = (EFI_GUID*)&intelVariableHeader->VendorGuid;
                variableName = (CHAR16*)(intelVariableHeader + 1);

                UINT32 i = 0;
                while (variableName[i] != 0) ++i;

                i = sizeof(VSS_INTEL_VARIABLE_HEADER) + 2 * (i + 1);
                i = i < variableSize ? i : variableSize;

                header = data.mid(offset, i);
                body = data.mid(offset + header.size(), variableSize - i);
            }

            // Normal VSS variable
            else {
                variableSize = sizeof(VSS_VARIABLE_HEADER) + variableHeader->NameSize + variableHeader->DataSize;
                variableGuid = (EFI_GUID*)&variableHeader->VendorGuid;
                variableName = (CHAR16*)(variableHeader + 1);

                header = data.mid(offset, sizeof(VSS_VARIABLE_HEADER) + variableHeader->NameSize);
                body = data.mid(offset + header.size(), variableHeader->DataSize);
            }

            // Check variable state
            if (variableHeader->State == NVRAM_VSS_INTEL_VARIABLE_VALID
                || variableHeader->State == NVRAM_VSS_VARIABLE_ADDED
                || variableHeader->State == NVRAM_VSS_VARIABLE_HEADER_VALID) {
                isInvalid = false;
            }

            // Check variable size
            if (variableSize > unparsedSize) {
                variableSize = 0;
            }
        }

        // Can't parse further, add the last element and break the loop
        if (!variableSize) {
            // Check if the data left is a free space or a padding
            UByteArray padding = data.mid(offset, unparsedSize);
            // Get info
            UString info = usprintf("Full size: %Xh (%u)", padding.size(), padding.size());

            if (padding.count(emptyByte) == padding.size()) { // Free space
                // Add tree item
                model->addItem(localOffset + offset, Types::FreeSpace, 0, UString("Free space"), UString(), info, UByteArray(), padding, UByteArray(), Fixed, index);
            }
            else { // Padding
                // Nothing is parsed yet, but the store is not empty 
                if (!offset) {
                    msg(usprintf("%s: store can't be parsed as VSS store", __FUNCTION__), index);
                    return U_SUCCESS;
                }

                // Add tree item
                model->addItem(localOffset + offset, Types::Padding, getPaddingType(padding), UString("Padding"), UString(), info, UByteArray(), padding, UByteArray(), Fixed, index);
            }

            return U_SUCCESS;
        }

        UString info;

        // Rename invalid variables
        if (isInvalid || !variableGuid) {
            isInvalid = true;
            name = UString("Invalid");
        }
        else { // Add GUID and text for valid variables
            name = guidToUString(readUnaligned(variableGuid));
            info += UString("Variable GUID: ") + guidToUString(readUnaligned(variableGuid), false) + UString("\n");
            text = UString::fromUtf16(variableName);
        }

        // Add info
        info += usprintf("Full size: %Xh (%u)\nHeader size %Xh (%u)\nBody size: %Xh (%u)\nState: %02Xh\nReserved: %02Xh\nAttributes: %08Xh (",
            variableSize, variableSize,
            header.size(), header.size(),
            body.size(), body.size(),
            variableHeader->State,
            variableHeader->Reserved,
            variableHeader->Attributes) + vssAttributesToUString(variableHeader->Attributes) + UString(")");

        // Set subtype and add related info
        if (isInvalid)
            subtype = Subtypes::InvalidVssEntry;
        else if (isAuthenticated) {
            subtype = Subtypes::AuthVssEntry;
            info += usprintf("\nMonotonic counter: %" PRIX64 "h\nTimestamp: ", monotonicCounter) + efiTimeToUString(timestamp)
                + usprintf("\nPubKey index: %u", pubKeyIndex);
        }
        else if (isAppleCrc32) {
            subtype = Subtypes::AppleVssEntry;
            info += usprintf("\nData checksum: %08Xh", storedCrc32) +
                (storedCrc32 != calculatedCrc32 ? usprintf(", invalid, should be %08Xh", calculatedCrc32) : UString(", valid"));
        }
        else if (isIntelSpecial) {
            subtype = Subtypes::IntelVssEntry;
        }
        else {
            subtype = Subtypes::StandardVssEntry;
        }

        // Add tree item
        model->addItem(localOffset + offset, Types::VssEntry, subtype, name, text, info, header, body, UByteArray(), Fixed, index);

        // Apply alignment, if needed
        if (alignment) {
            variableSize = ((variableSize + alignment - 1) & (~(alignment - 1)));
        }

        // Move to next variable
        offset += variableSize;
    }

    return U_SUCCESS;
}

USTATUS NvramParser::parseFsysStoreBody(const UModelIndex & index)
{
    // Sanity check
    if (!index.isValid())
        return U_INVALID_PARAMETER;

    // Get local offset
    UINT32 localOffset = model->header(index).size();

    // Get item data
    const UByteArray data = model->body(index);

    // Check that the is enough space for variable header
    const UINT32 storeDataSize = (UINT32)data.size();
    UINT32 offset = 0;

    // Parse all variables
    while (1) {
        UINT32 unparsedSize = storeDataSize - offset;
        UINT32 variableSize = 0;

        // Get nameSize and name of the variable
        UINT8 nameSize = *(UINT8*)(data.constData() + offset);
        bool valid = !(nameSize & 0x80); // Last bit is a validity bit, 0 means valid
        nameSize &= 0x7F;

        // Check sanity
        if (unparsedSize >= nameSize + sizeof(UINT8)) {
            variableSize = nameSize + sizeof(UINT8);
        }

        UByteArray name;
        if (variableSize) {
            name = data.mid(offset + sizeof(UINT8), nameSize);
            // Check for EOF variable
            if (nameSize == 3 && name[0] == 'E' && name[1] == 'O' && name[2] == 'F') {
                // There is no data afterward, add EOF variable and free space and return
                UByteArray header = data.mid(offset, sizeof(UINT8) + nameSize);
                UString info = usprintf("Full size: %Xh (%u)", header.size(), header.size());

                // Add EOF tree item
                model->addItem(localOffset + offset, Types::FsysEntry, Subtypes::NormalFsysEntry, UString("EOF"), UString(), info, header, UByteArray(), UByteArray(), Fixed, index);

                // Add free space
                offset += header.size();
                UByteArray body = data.mid(offset);
                info = usprintf("Full size: %Xh (%u)", body.size(), body.size());

                // Add free space tree item
                model->addItem(localOffset + offset, Types::FreeSpace, 0, UString("Free space"), UString(), info, UByteArray(), body, UByteArray(), Fixed, index);

                return U_SUCCESS;
            }
        }

        // Get dataSize and data of the variable
        const UINT16 dataSize = *(UINT16*)(data.constData() + offset + sizeof(UINT8) + nameSize);
        if (unparsedSize >= sizeof(UINT8) + nameSize + sizeof(UINT16) + dataSize) {
            variableSize = sizeof(UINT8) + nameSize + sizeof(UINT16) + dataSize;
        }
        else {
            // Last variable is bad, add the rest as padding and return
            UByteArray body = data.mid(offset);
            UString info = usprintf("Full size: %Xh (%u)", body.size(), body.size());

            // Add padding tree item
            model->addItem(localOffset + offset, Types::Padding, getPaddingType(body), UString("Padding"), UString(), info, UByteArray(), body, UByteArray(), Fixed, index);

            // Show message
            msg(usprintf("%s: next variable appears too big, added as padding", __FUNCTION__), index);

            return U_SUCCESS;
        }

        // Construct header and body
        UByteArray header = data.mid(offset, sizeof(UINT8) + nameSize + sizeof(UINT16));
        UByteArray body = data.mid(offset + sizeof(UINT8) + nameSize + sizeof(UINT16), dataSize);

        // Add info
        UString info = usprintf("Full size: %Xh (%u)\nHeader size %Xh (%u)\nBody size: %Xh (%u)",
            variableSize, variableSize,
            header.size(), header.size(),
            body.size(), body.size());

        // Add tree item
        model->addItem(localOffset + offset, Types::FsysEntry, valid ? Subtypes::NormalFsysEntry : Subtypes::InvalidFsysEntry, UString(name.constData()), UString(), info, header, body, UByteArray(), Fixed, index);

        // Move to next variable
        offset += variableSize;
    }

    return U_SUCCESS;
}

USTATUS NvramParser::parseEvsaStoreBody(const UModelIndex & index)
{
    // Sanity check
    if (!index.isValid())
        return U_INVALID_PARAMETER;

    // Obtain required information from parent volume
    UINT8 emptyByte = 0xFF;
    UModelIndex parentVolumeIndex = model->findParentOfType(index, Types::Volume);
    if (parentVolumeIndex.isValid() && model->hasEmptyParsingData(parentVolumeIndex) == false) {
        UByteArray data = model->parsingData(parentVolumeIndex);
        const VOLUME_PARSING_DATA* pdata = (const VOLUME_PARSING_DATA*)data.constData();
        emptyByte = pdata->emptyByte;
    }

    // Get local offset
    UINT32 localOffset = model->header(index).size();

    // Get item data
    const UByteArray data = model->body(index);

    // Check that the is enough space for entry header
    const UINT32 storeDataSize = (UINT32)data.size();
    UINT32 offset = 0;

    std::map<UINT16, EFI_GUID> guidMap;
    std::map<UINT16, UString> nameMap;

    // Parse all entries
    UINT32 unparsedSize = storeDataSize;
    while (unparsedSize) {
        UINT32 variableSize = 0;
        UString name;
        UString info;
        UByteArray header;
        UByteArray body;
        UINT8 subtype;
        UINT8 calculated;

        const EVSA_ENTRY_HEADER* entryHeader = (const EVSA_ENTRY_HEADER*)(data.constData() + offset);

        // Check entry size
        variableSize = sizeof(EVSA_ENTRY_HEADER);
        if (unparsedSize < variableSize || unparsedSize < entryHeader->Size) {
            body = data.mid(offset);
            info = usprintf("Full size: %Xh (%u)", body.size(), body.size());

            if (body.count(emptyByte) == body.size()) { // Free space
                // Add free space tree item
                model->addItem(localOffset + offset, Types::FreeSpace, 0, UString("Free space"), UString(), info, UByteArray(), body, UByteArray(), Fixed, index);
            }
            else {
                // Add padding tree item
                UModelIndex itemIndex = model->addItem(localOffset + offset, Types::Padding, getPaddingType(body), UString("Padding"), UString(), info, UByteArray(), body, UByteArray(), Fixed, index);

                // Show message
                msg(usprintf("%s: variable parsing failed, the rest of unparsed store added as padding", __FUNCTION__), itemIndex);
            }
            break;
        }
        variableSize = entryHeader->Size;

        // Recalculate entry checksum
        calculated = calculateChecksum8(((const UINT8*)entryHeader) + 2, entryHeader->Size - 2);

        // GUID entry
        if (entryHeader->Type == NVRAM_EVSA_ENTRY_TYPE_GUID1 ||
            entryHeader->Type == NVRAM_EVSA_ENTRY_TYPE_GUID2) {
            const EVSA_GUID_ENTRY* guidHeader = (const EVSA_GUID_ENTRY*)entryHeader;
            header = data.mid(offset, sizeof(EVSA_GUID_ENTRY));
            body = data.mid(offset + sizeof(EVSA_GUID_ENTRY), guidHeader->Header.Size - sizeof(EVSA_GUID_ENTRY));
            EFI_GUID guid = *(EFI_GUID*)body.constData();
            name = guidToUString(guid);
            info = UString("GUID: ") + guidToUString(guid, false) + usprintf("\nFull size: %Xh (%u)\nHeader size %Xh (%u)\nBody size: %Xh (%u)\nType: %02Xh\nChecksum: %02Xh",
                variableSize, variableSize,
                header.size(), header.size(),
                body.size(), body.size(),
                guidHeader->Header.Type,
                guidHeader->Header.Checksum)
                + (guidHeader->Header.Checksum != calculated ? usprintf(", invalid, should be %02Xh", calculated) : UString(", valid"))
                + usprintf("\nGuidId: %04Xh", guidHeader->GuidId);
            subtype = Subtypes::GuidEvsaEntry;
            guidMap.insert(std::pair<UINT16, EFI_GUID>(guidHeader->GuidId, guid));
        }
        // Name entry
        else if (entryHeader->Type == NVRAM_EVSA_ENTRY_TYPE_NAME1 ||
            entryHeader->Type == NVRAM_EVSA_ENTRY_TYPE_NAME2) {
            const EVSA_NAME_ENTRY* nameHeader = (const EVSA_NAME_ENTRY*)entryHeader;
            header = data.mid(offset, sizeof(EVSA_NAME_ENTRY));
            body = data.mid(offset + sizeof(EVSA_NAME_ENTRY), nameHeader->Header.Size - sizeof(EVSA_NAME_ENTRY));
            name = UString::fromUtf16((const CHAR16*)body.constData());
            info = UString("Name: ") + name + usprintf("\nFull size: %Xh (%u)\nHeader size %Xh (%u)\nBody size: %Xh (%u)\nType: %02Xh\nChecksum: %02Xh",
                variableSize, variableSize,
                header.size(), header.size(),
                body.size(), body.size(),
                nameHeader->Header.Type,
                nameHeader->Header.Checksum)
                + (nameHeader->Header.Checksum != calculated ? usprintf(", invalid, should be %02Xh", calculated) : UString(", valid"))
                + usprintf("\nVarId: %04Xh", nameHeader->VarId);
            subtype = Subtypes::NameEvsaEntry;
            nameMap.insert(std::pair<UINT16, UString>(nameHeader->VarId, name));
        }
        // Data entry
        else if (entryHeader->Type == NVRAM_EVSA_ENTRY_TYPE_DATA1 ||
            entryHeader->Type == NVRAM_EVSA_ENTRY_TYPE_DATA2 ||
            entryHeader->Type == NVRAM_EVSA_ENTRY_TYPE_DATA_INVALID) {
            const EVSA_DATA_ENTRY* dataHeader = (const EVSA_DATA_ENTRY*)entryHeader;
            // Check for extended header
            UINT32 headerSize = sizeof(EVSA_DATA_ENTRY);
            UINT32 dataSize = dataHeader->Header.Size - sizeof(EVSA_DATA_ENTRY);
            if (dataHeader->Attributes & NVRAM_EVSA_DATA_EXTENDED_HEADER) {
                const EVSA_DATA_ENTRY_EXTENDED* dataHeaderExtended = (const EVSA_DATA_ENTRY_EXTENDED*)entryHeader;
                headerSize = sizeof(EVSA_DATA_ENTRY_EXTENDED);
                dataSize = dataHeaderExtended->DataSize;
                variableSize = headerSize + dataSize;
            }

            header = data.mid(offset, headerSize);
            body = data.mid(offset + headerSize, dataSize);
            name = UString("Data");
            info = usprintf("Full size: %Xh (%u)\nHeader size %Xh (%u)\nBody size: %Xh (%u)\nType: %02Xh\nChecksum: %02Xh",
                variableSize, variableSize,
                headerSize, headerSize,
                dataSize, dataSize,
                dataHeader->Header.Type,
                dataHeader->Header.Checksum)
                + (dataHeader->Header.Checksum != calculated ? usprintf(", invalid, should be %02Xh", calculated) : UString(", valid"))
                + usprintf("\nVarId: %04Xh\nGuidId: %04Xh\nAttributes: %08Xh (",
                    dataHeader->VarId,
                    dataHeader->GuidId,
                    dataHeader->Attributes)
                + evsaAttributesToUString(dataHeader->Attributes) + UString(")");
            subtype = Subtypes::DataEvsaEntry;
        }
        // Unknown entry or free space
        else {
            body = data.mid(offset);
            info = usprintf("Full size: %Xh (%u)", body.size(), body.size());

            if (body.count(emptyByte) == body.size()) { // Free space
                // Add free space tree item
                model->addItem(localOffset + offset, Types::FreeSpace, 0, UString("Free space"), UString(), info, UByteArray(), body, UByteArray(), Fixed, index);
            }
            else {
                // Add padding tree item
                UModelIndex itemIndex = model->addItem(localOffset + offset, Types::Padding, getPaddingType(body), UString("Padding"), UString(), info, UByteArray(), body, UByteArray(), Fixed, index);

                // Show message
                msg(usprintf("%s: unknown variable of type %02Xh found at offset %Xh, the rest of unparsed store added as padding", __FUNCTION__, entryHeader->Type, offset), itemIndex);
            }
            break;
        }

        // Add tree item
        model->addItem(localOffset + offset, Types::EvsaEntry, subtype, name, UString(), info, header, body, UByteArray(), Fixed, index);

        // Move to next variable
        offset += variableSize;
        unparsedSize = storeDataSize - offset;
    }

    // Reparse all data variables to detect invalid ones and assign name and test to valid ones
    for (int i = 0; i < model->rowCount(index); i++) {
        UModelIndex current = index.child(i, 0);
        if (model->subtype(current) == Subtypes::DataEvsaEntry) {
            UByteArray header = model->header(current);
            const EVSA_DATA_ENTRY* dataHeader = (const EVSA_DATA_ENTRY*)header.constData();
            UString guid;
            if (guidMap.count(dataHeader->GuidId))
                guid = guidToUString(guidMap[dataHeader->GuidId], false);
            UString name;
            if (nameMap.count(dataHeader->VarId))
                name = nameMap[dataHeader->VarId];

            // Check for variable validity
            if (guid.isEmpty() && name.isEmpty()) { // Both name and guid aren't found
                model->setSubtype(current, Subtypes::InvalidEvsaEntry);
                model->setName(current, UString("Invalid"));
                msg(usprintf("%s: data variable with invalid GuidId and invalid VarId", __FUNCTION__), current);
            }
            else if (guid.isEmpty()) { // Guid not found
                model->setSubtype(current, Subtypes::InvalidEvsaEntry);
                model->setName(current, UString("Invalid"));
                msg(usprintf("%s: data variable with invalid GuidId", __FUNCTION__), current);
            }
            else if (name.isEmpty()) { // Name not found
                model->setSubtype(current, Subtypes::InvalidEvsaEntry);
                model->setName(current, UString("Invalid"));
                msg(usprintf("%s: data variable with invalid VarId", __FUNCTION__), current);
            }
            else { // Variable is OK, rename it
                if (dataHeader->Header.Type == NVRAM_EVSA_ENTRY_TYPE_DATA_INVALID) {
                    model->setSubtype(current, Subtypes::InvalidEvsaEntry);
                    model->setName(current, UString("Invalid"));
                }
                else {
                    model->setName(current, guid);
                }
                model->setText(current, name);
                model->addInfo(current, UString("GUID: ") + guid + UString("\nName: ") + name + UString("\n"), false);
            }
        }
    }

    return U_SUCCESS;
}


USTATUS NvramParser::parseFlashMapBody(const UModelIndex & index)
{
    // Sanity check
    if (!index.isValid())
        return U_INVALID_PARAMETER;

    // Get parsing data for the current item
    UINT32 localOffset = model->header(index).size();
    const UByteArray data = model->body(index);


    const UINT32 dataSize = (UINT32)data.size();
    UINT32 offset = 0;
    UINT32 unparsedSize = dataSize;
    // Parse all entries
    while (unparsedSize) {
        const PHOENIX_FLASH_MAP_ENTRY* entryHeader = (const PHOENIX_FLASH_MAP_ENTRY*)(data.constData() + offset);

        // Check entry size
        if (unparsedSize < sizeof(PHOENIX_FLASH_MAP_ENTRY)) {
            // Last variable is bad, add the rest as padding and return
            UByteArray body = data.mid(offset);
            UString info = usprintf("Full size: %Xh (%u)", body.size(), body.size());

            // Add padding tree item
            model->addItem(localOffset + offset, Types::Padding, getPaddingType(body), UString("Padding"), UString(), info, UByteArray(), body, UByteArray(), Fixed, index);

            // Show message
            if (unparsedSize < entryHeader->Size)
                msg(usprintf("%s: next entry appears too big, added as padding", __FUNCTION__), index);

            break;
        }

        UString name = guidToUString(entryHeader->Guid);

        // Construct header
        UByteArray header = data.mid(offset, sizeof(PHOENIX_FLASH_MAP_ENTRY));

        // Add info
        UString info = UString("Entry GUID: ") + guidToUString(entryHeader->Guid, false) +
            usprintf("\nFull size: 24h (36)\nHeader size: 24h (36)\nBody size: 0h (0)\n"
                "Entry type: %04Xh\nData type: %04Xh\nMemory address: %08Xh\nSize: %08Xh\nOffset: %08Xh",
                entryHeader->EntryType,
                entryHeader->DataType,
                entryHeader->PhysicalAddress,
                entryHeader->Size,
                entryHeader->Offset);

        // Determine subtype
        UINT8 subtype = 0;
        switch (entryHeader->DataType) {
        case NVRAM_PHOENIX_FLASH_MAP_ENTRY_TYPE_VOLUME:
            subtype = Subtypes::VolumeFlashMapEntry;
            break;
        case NVRAM_PHOENIX_FLASH_MAP_ENTRY_TYPE_DATA_BLOCK:
            subtype = Subtypes::DataFlashMapEntry;
            break;
        }

        // Add tree item
        model->addItem(localOffset + offset, Types::FlashMapEntry, subtype, name, flashMapGuidToUString(entryHeader->Guid), info, header, UByteArray(), UByteArray(), Fixed, index);

        // Move to next variable
        offset += sizeof(PHOENIX_FLASH_MAP_ENTRY);
        unparsedSize = dataSize - offset;
    }

    return U_SUCCESS;
}
#endif // U_ENABLE_NVRAM_PARSING_SUPPORT

```

`efiXloader/3rd/uefitool/common/nvramparser.h`:

```h
/* nvramparser.h

Copyright (c) 2016, Nikolaj Schlej. All rights reserved.

This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php.

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

*/

#ifndef NVRAMPARSER_H
#define NVRAMPARSER_H

#include <vector>

#include "basetypes.h"
#include "ustring.h"
#include "ubytearray.h"
#include "treemodel.h"
#include "ffsparser.h"

#ifdef U_ENABLE_NVRAM_PARSING_SUPPORT
class NvramParser 
{
public:
    // Default constructor and destructor
    NvramParser(TreeModel* treeModel, FfsParser* parser) : model(treeModel), ffsParser(parser) {}
    ~NvramParser() {}

    // Returns messages 
    std::vector<std::pair<UString, UModelIndex> > getMessages() const { return messagesVector; }
    // Clears messages
    void clearMessages() { messagesVector.clear(); }

    // NVRAM parsing
    USTATUS parseNvramVolumeBody(const UModelIndex & index);
    USTATUS parseNvarStore(const UModelIndex & index);
    
private:
    TreeModel *model;
    FfsParser *ffsParser;
    std::vector<std::pair<UString, UModelIndex> > messagesVector;
    void msg(const UString & message, const UModelIndex & index = UModelIndex()) {
        messagesVector.push_back(std::pair<UString, UModelIndex>(message, index));
    };

    USTATUS findNextStore(const UModelIndex & index, const UByteArray & volume, const UINT32 localOffset, const UINT32 storeOffset, UINT32 & nextStoreOffset);
    USTATUS getStoreSize(const UByteArray & data, const UINT32 storeOffset, UINT32 & storeSize);
    USTATUS parseStoreHeader(const UByteArray & store, const UINT32 localOffset, const UModelIndex & parent, UModelIndex & index);

    USTATUS parseVssStoreHeader(const UByteArray & store, const UINT32 localOffset, const bool sizeOverride, const UModelIndex & parent, UModelIndex & index);
    USTATUS parseVss2StoreHeader(const UByteArray & store, const UINT32 localOffset, const bool sizeOverride, const UModelIndex & parent, UModelIndex & index);
    USTATUS parseFtwStoreHeader(const UByteArray & store, const UINT32 localOffset, const UModelIndex & parent, UModelIndex & index);
    USTATUS parseFdcStoreHeader(const UByteArray & store, const UINT32 localOffset, const UModelIndex & parent, UModelIndex & index);
    USTATUS parseFsysStoreHeader(const UByteArray & store, const UINT32 localOffset, const UModelIndex & parent, UModelIndex & index);
    USTATUS parseEvsaStoreHeader(const UByteArray & store, const UINT32 localOffset, const UModelIndex & parent, UModelIndex & index);
    USTATUS parseFlashMapStoreHeader(const UByteArray & store, const UINT32 localOffset, const UModelIndex & parent, UModelIndex & index);
    USTATUS parseCmdbStoreHeader(const UByteArray & store, const UINT32 localOffset, const UModelIndex & parent, UModelIndex & index);
    USTATUS parseSlicPubkeyHeader(const UByteArray & store, const UINT32 localOffset, const UModelIndex & parent, UModelIndex & index);
    USTATUS parseSlicMarkerHeader(const UByteArray & store, const UINT32 localOffset, const UModelIndex & parent, UModelIndex & index);

    USTATUS parseFdcStoreBody(const UModelIndex & index);
    USTATUS parseVssStoreBody(const UModelIndex & index, const UINT8 alignment);
    USTATUS parseFsysStoreBody(const UModelIndex & index);
    USTATUS parseEvsaStoreBody(const UModelIndex & index);
    USTATUS parseFlashMapBody(const UModelIndex & index);
};
#else
class NvramParser 
{
public:
    // Default constructor and destructor
    NvramParser(TreeModel* treeModel, FfsParser* parser) { U_UNUSED_PARAMETER(treeModel); U_UNUSED_PARAMETER(parser); }
    ~NvramParser() {}

    // Returns messages 
    std::vector<std::pair<UString, UModelIndex> > getMessages() const { return std::vector<std::pair<UString, UModelIndex> >(); }
    // Clears messages
    void clearMessages() {}

    // NVRAM parsing
    USTATUS parseNvramVolumeBody(const UModelIndex &) { return U_SUCCESS; }
    USTATUS parseNvarStore(const UModelIndex &)  { return U_SUCCESS; }
};
#endif // U_ENABLE_NVRAM_PARSING_SUPPORT
#endif // NVRAMPARSER_H

```

`efiXloader/3rd/uefitool/common/parsingdata.h`:

```h
/* parsingdata.h

Copyright (c) 2015, Nikolaj Schlej. All rights reserved.
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHWARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

Parsing data is an information needed for each level of image reconstruction
routines without the need of backward traversal

*/

#ifndef PARSINGDATA_H
#define PARSINGDATA_H

#include "basetypes.h"

typedef struct VOLUME_PARSING_DATA_ {
    EFI_GUID extendedHeaderGuid;
    UINT32   alignment;
    UINT32   usedSpace;
    BOOLEAN  hasValidUsedSpace;
    UINT8    ffsVersion;
    UINT8    emptyByte;
    UINT8    revision;
    BOOLEAN  hasExtendedHeader;
    BOOLEAN  hasAppleCrc32;
    BOOLEAN  isWeakAligned;
} VOLUME_PARSING_DATA;

typedef struct FILE_PARSING_DATA_ {
    UINT8    emptyByte;
    EFI_GUID guid;
} FILE_PARSING_DATA;

typedef struct GUIDED_SECTION_PARSING_DATA_ {
    EFI_GUID guid;
    UINT32   dictionarySize;
} GUIDED_SECTION_PARSING_DATA;

typedef struct FREEFORM_GUIDED_SECTION_PARSING_DATA_ {
    EFI_GUID guid;
} FREEFORM_GUIDED_SECTION_PARSING_DATA;

typedef struct COMPRESSED_SECTION_PARSING_DATA_ {
    UINT32 uncompressedSize;
    UINT8  compressionType;
    UINT8  algorithm;
    UINT32 dictionarySize;
} COMPRESSED_SECTION_PARSING_DATA;

typedef struct TE_IMAGE_SECTION_PARSING_DATA_ {
    UINT32 originalImageBase;
    UINT32 adjustedImageBase;
    UINT8  imageBaseType;
} TE_IMAGE_SECTION_PARSING_DATA;

typedef struct NVAR_ENTRY_PARSING_DATA_ {
    UINT8   emptyByte;
    BOOLEAN isValid;
    UINT32  next;
} NVAR_ENTRY_PARSING_DATA;

#endif // PARSINGDATA_H

```

`efiXloader/3rd/uefitool/common/peimage.cpp`:

```cpp
/* peimage.cpp

Copyright (c) 2015, Nikolaj Schlej. All rights reserved.
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php.

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

*/

#include "peimage.h"

UString machineTypeToUString(UINT16 machineType)
{
    switch (machineType) {
    case EFI_IMAGE_FILE_MACHINE_AMD64:       return UString("x86-64");
    case EFI_IMAGE_FILE_MACHINE_ARM:         return UString("ARM");
    case EFI_IMAGE_FILE_MACHINE_ARMNT:       return UString("ARMv7");
    case EFI_IMAGE_FILE_MACHINE_APPLE_ARM:   return UString("Apple ARM");
    case EFI_IMAGE_FILE_MACHINE_AARCH64:     return UString("AArch64");
    case EFI_IMAGE_FILE_MACHINE_EBC:         return UString("EBC");
    case EFI_IMAGE_FILE_MACHINE_I386:        return UString("x86");
    case EFI_IMAGE_FILE_MACHINE_IA64:        return UString("IA64");
    case EFI_IMAGE_FILE_MACHINE_POWERPC:     return UString("PowerPC");
    case EFI_IMAGE_FILE_MACHINE_POWERPCFP:   return UString("PowerPC FP");
    case EFI_IMAGE_FILE_MACHINE_THUMB:       return UString("ARM Thumb");
    case EFI_IMAGE_FILE_MACHINE_RISCV32:     return UString("RISC-V 32-bit");
    case EFI_IMAGE_FILE_MACHINE_RISCV64:     return UString("RISC-V 64-bit");
    case EFI_IMAGE_FILE_MACHINE_RISCV128:    return UString("RISC-V 128-bit");
    default:                                 return usprintf("Unknown (%04Xh)", machineType);
    }
}
```

`efiXloader/3rd/uefitool/common/peimage.h`:

```h
/* peimage.h

Copyright (c) 2015, Nikolaj Schlej. All rights reserved.
Copyright (c) 2006 - 2010, Intel Corporation. All rights reserved.
Portions copyright (c) 2008 - 2009, Apple Inc. All rights reserved.
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php.

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

*/

#ifndef PEIMAGE_H
#define PEIMAGE_H

#include "basetypes.h"
#include "ustring.h"

extern UString machineTypeToUString(UINT16 machineType);

// Make sure we use right packing rules
#pragma pack(push, 1)

//
// PE32+ Subsystem type for EFI images
//
#define EFI_IMAGE_SUBSYSTEM_EFI_APPLICATION         10
#define EFI_IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER 11
#define EFI_IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER      12
#define EFI_IMAGE_SUBSYSTEM_SAL_RUNTIME_DRIVER      13

//
// PE32+ Machine type for EFI images
//
#define EFI_IMAGE_FILE_MACHINE_I386           0x014c // x86
#define EFI_IMAGE_FILE_MACHINE_ARM            0x01c0 // ARM little endian
#define EFI_IMAGE_FILE_MACHINE_THUMB          0x01c2 // ARM or Thumb (interworking)
#define EFI_IMAGE_FILE_MACHINE_ARMNT          0x01c4 // ARMv7 (or higher) Thumb mode only
#define EFI_IMAGE_FILE_MACHINE_APPLE_ARM      0x01c6 // Apple ARM
#define EFI_IMAGE_FILE_MACHINE_POWERPC        0x01f0 // Power PC little endian
#define EFI_IMAGE_FILE_MACHINE_POWERPCFP      0x01f1 // Power PC with floating point support
#define EFI_IMAGE_FILE_MACHINE_IA64           0x0200 // Itanium
#define EFI_IMAGE_FILE_MACHINE_EBC            0x0ebc // EFI Byte Code
#define EFI_IMAGE_FILE_MACHINE_AMD64          0x8664 // x86-64
#define EFI_IMAGE_FILE_MACHINE_AARCH64        0xaa64 // ARMv8 in 64-bit mode 
#define EFI_IMAGE_FILE_MACHINE_RISCV32        0x5032 // RISC-V 32-bit
#define EFI_IMAGE_FILE_MACHINE_RISCV64        0x5064 // RISC-V 64-bit
#define EFI_IMAGE_FILE_MACHINE_RISCV128       0x5128 // RISC-V 128-bit

//
// EXE file formats
//
#define EFI_IMAGE_DOS_SIGNATURE     0x5A4D     // MZ
#define EFI_IMAGE_PE_SIGNATURE      0x00004550 // PE

//
// PE images can start with an optional DOS header, so if an image is run
// under DOS it can print an error message.
//
typedef struct {
    UINT16  e_magic;    // Magic number
    UINT16  e_cblp;     // Bytes on last page of file
    UINT16  e_cp;       // Pages in file
    UINT16  e_crlc;     // Relocations
    UINT16  e_cparhdr;  // Size of header in paragraphs
    UINT16  e_minalloc; // Minimum extra paragraphs needed
    UINT16  e_maxalloc; // Maximum extra paragraphs needed
    UINT16  e_ss;       // Initial (relative) SS value
    UINT16  e_sp;       // Initial SP value
    UINT16  e_csum;     // Checksum
    UINT16  e_ip;       // Initial IP value
    UINT16  e_cs;       // Initial (relative) CS value
    UINT16  e_lfarlc;   // File address of relocation table
    UINT16  e_ovno;     // Overlay number
    UINT16  e_res[4];   // Reserved words
    UINT16  e_oemid;    // OEM identifier (for e_oeminfo)
    UINT16  e_oeminfo;  // OEM information; e_oemid specific
    UINT16  e_res2[10]; // Reserved words
    UINT32  e_lfanew;   // File address of new header
} EFI_IMAGE_DOS_HEADER;

//
// COFF File Header (Object and Image)
//
typedef struct {
    UINT16  Machine;
    UINT16  NumberOfSections;
    UINT32  TimeDateStamp;
    UINT32  PointerToSymbolTable;
    UINT32  NumberOfSymbols;
    UINT16  SizeOfOptionalHeader;
    UINT16  Characteristics;
} EFI_IMAGE_FILE_HEADER;

//
// Size of EFI_IMAGE_FILE_HEADER.
//
#define EFI_IMAGE_SIZEOF_FILE_HEADER        20

//
// Characteristics
//
#define EFI_IMAGE_FILE_RELOCS_STRIPPED      0x0001  // Relocation info stripped from file
#define EFI_IMAGE_FILE_EXECUTABLE_IMAGE     0x0002  // File is executable  (i.e. no unresolved external references)
#define EFI_IMAGE_FILE_LINE_NUMS_STRIPPED   0x0004  // Line numbers stripped from file
#define EFI_IMAGE_FILE_LOCAL_SYMS_STRIPPED  0x0008  // Local symbols stripped from file
#define EFI_IMAGE_FILE_BYTES_REVERSED_LO    0x0080  // Bytes of machine word are reversed
#define EFI_IMAGE_FILE_32BIT_MACHINE        0x0100  // 32 bit word machine
#define EFI_IMAGE_FILE_DEBUG_STRIPPED       0x0200  // Debugging info stripped from file in .DBG file
#define EFI_IMAGE_FILE_SYSTEM               0x1000  // System File
#define EFI_IMAGE_FILE_DLL                  0x2000  // File is a DLL
#define EFI_IMAGE_FILE_BYTES_REVERSED_HI    0x8000  // Bytes of machine word are reversed

//
// Header Data Directories.
//
typedef struct {
    UINT32  VirtualAddress;
    UINT32  Size;
} EFI_IMAGE_DATA_DIRECTORY;

//
// Directory Entries
//
#define EFI_IMAGE_DIRECTORY_ENTRY_EXPORT      0
#define EFI_IMAGE_DIRECTORY_ENTRY_IMPORT      1
#define EFI_IMAGE_DIRECTORY_ENTRY_RESOURCE    2
#define EFI_IMAGE_DIRECTORY_ENTRY_EXCEPTION   3
#define EFI_IMAGE_DIRECTORY_ENTRY_SECURITY    4
#define EFI_IMAGE_DIRECTORY_ENTRY_BASERELOC   5
#define EFI_IMAGE_DIRECTORY_ENTRY_DEBUG       6
#define EFI_IMAGE_DIRECTORY_ENTRY_COPYRIGHT   7
#define EFI_IMAGE_DIRECTORY_ENTRY_GLOBALPTR   8
#define EFI_IMAGE_DIRECTORY_ENTRY_TLS         9
#define EFI_IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG 10

#define EFI_IMAGE_NUMBER_OF_DIRECTORY_ENTRIES 16

//
// EFI_IMAGE_NT_OPTIONAL_HDR32_MAGIC means PE32 and
// EFI_IMAGE_OPTIONAL_HEADER32 must be used.
// The data structures only vary after NT additional fields
//
#define EFI_IMAGE_PE_OPTIONAL_HDR32_MAGIC 0x10b

//
// Optional Header Standard Fields for PE32
//
typedef struct {
    //
    // Standard fields.
    //
    UINT16                    Magic;
    UINT8                     MajorLinkerVersion;
    UINT8                     MinorLinkerVersion;
    UINT32                    SizeOfCode;
    UINT32                    SizeOfInitializedData;
    UINT32                    SizeOfUninitializedData;
    UINT32                    AddressOfEntryPoint;
    UINT32                    BaseOfCode;
    UINT32                    BaseOfData;  // PE32 contains this additional field, which is absent in PE32+.
    //
    // Optional Header Windows-Specific Fields.
    //
    UINT32                    ImageBase;
    UINT32                    SectionAlignment;
    UINT32                    FileAlignment;
    UINT16                    MajorOperatingSystemVersion;
    UINT16                    MinorOperatingSystemVersion;
    UINT16                    MajorImageVersion;
    UINT16                    MinorImageVersion;
    UINT16                    MajorSubsystemVersion;
    UINT16                    MinorSubsystemVersion;
    UINT32                    Win32VersionValue;
    UINT32                    SizeOfImage;
    UINT32                    SizeOfHeaders;
    UINT32                    CheckSum;
    UINT16                    Subsystem;
    UINT16                    DllCharacteristics;
    UINT32                    SizeOfStackReserve;
    UINT32                    SizeOfStackCommit;
    UINT32                    SizeOfHeapReserve;
    UINT32                    SizeOfHeapCommit;
    UINT32                    LoaderFlags;
    UINT32                    NumberOfRvaAndSizes;
    EFI_IMAGE_DATA_DIRECTORY  DataDirectory[EFI_IMAGE_NUMBER_OF_DIRECTORY_ENTRIES];
} EFI_IMAGE_OPTIONAL_HEADER32;

//
// EFI_IMAGE_NT_OPTIONAL_HDR64_MAGIC means PE32+ and
// EFI_IMAGE_OPTIONAL_HEADER64 must be used.
// The data structures only vary after NT additional fields
//
#define EFI_IMAGE_PE_OPTIONAL_HDR64_MAGIC 0x20b

//
// Optional Header Standard Fields for PE32+.
//
typedef struct {
    //
    // Standard fields.
    //
    UINT16                    Magic;
    UINT8                     MajorLinkerVersion;
    UINT8                     MinorLinkerVersion;
    UINT32                    SizeOfCode;
    UINT32                    SizeOfInitializedData;
    UINT32                    SizeOfUninitializedData;
    UINT32                    AddressOfEntryPoint;
    UINT32                    BaseOfCode;
    //
    // Optional Header Windows-Specific Fields.
    //
    UINT64                    ImageBase;
    UINT32                    SectionAlignment;
    UINT32                    FileAlignment;
    UINT16                    MajorOperatingSystemVersion;
    UINT16                    MinorOperatingSystemVersion;
    UINT16                    MajorImageVersion;
    UINT16                    MinorImageVersion;
    UINT16                    MajorSubsystemVersion;
    UINT16                    MinorSubsystemVersion;
    UINT32                    Win32VersionValue;
    UINT32                    SizeOfImage;
    UINT32                    SizeOfHeaders;
    UINT32                    CheckSum;
    UINT16                    Subsystem;
    UINT16                    DllCharacteristics;
    UINT64                    SizeOfStackReserve;
    UINT64                    SizeOfStackCommit;
    UINT64                    SizeOfHeapReserve;
    UINT64                    SizeOfHeapCommit;
    UINT32                    LoaderFlags;
    UINT32                    NumberOfRvaAndSizes;
    EFI_IMAGE_DATA_DIRECTORY  DataDirectory[EFI_IMAGE_NUMBER_OF_DIRECTORY_ENTRIES];
} EFI_IMAGE_OPTIONAL_HEADER64;

// Union for pointers to either PE32 or PE32+ headers
typedef union _EFI_IMAGE_OPTIONAL_HEADER_POINTERS_UNION {
    const EFI_IMAGE_OPTIONAL_HEADER32* H32;
    const EFI_IMAGE_OPTIONAL_HEADER64* H64;
} EFI_IMAGE_OPTIONAL_HEADER_POINTERS_UNION;

typedef struct
{
    UINT32 Signature;
    //EFI_IMAGE_FILE_HEADER FileHeader;
    //EFI_IMAGE_OPTIONAL_HEADER OptionalHeader;
} EFI_IMAGE_PE_HEADER;

//
// Other Windows Subsystem Values
//
#define EFI_IMAGE_SUBSYSTEM_UNKNOWN     0
#define EFI_IMAGE_SUBSYSTEM_NATIVE      1
#define EFI_IMAGE_SUBSYSTEM_WINDOWS_GUI 2
#define EFI_IMAGE_SUBSYSTEM_WINDOWS_CUI 3
#define EFI_IMAGE_SUBSYSTEM_OS2_CUI     5
#define EFI_IMAGE_SUBSYSTEM_POSIX_CUI   7

//
// Length of ShortName
//
#define EFI_IMAGE_SIZEOF_SHORT_NAME 8

//
// Section Table. This table immediately follows the optional header.
//
typedef struct {
    UINT8 Name[EFI_IMAGE_SIZEOF_SHORT_NAME];
    union {
        UINT32  PhysicalAddress;
        UINT32  VirtualSize;
    } Misc;
    UINT32  VirtualAddress;
    UINT32  SizeOfRawData;
    UINT32  PointerToRawData;
    UINT32  PointerToRelocations;
    UINT32  PointerToLinenumbers;
    UINT16  NumberOfRelocations;
    UINT16  NumberOfLinenumbers;
    UINT32  Characteristics;
} EFI_IMAGE_SECTION_HEADER;

//
// Size of EFI_IMAGE_SECTION_HEADER
//
#define EFI_IMAGE_SIZEOF_SECTION_HEADER       40

//
// Section Flags Values
//
#define EFI_IMAGE_SCN_TYPE_NO_PAD                  0x00000008  // Reserved
#define EFI_IMAGE_SCN_CNT_CODE                     0x00000020
#define EFI_IMAGE_SCN_CNT_INITIALIZED_DATA         0x00000040
#define EFI_IMAGE_SCN_CNT_UNINITIALIZED_DATA       0x00000080

#define EFI_IMAGE_SCN_LNK_OTHER                    0x00000100  // Reserved
#define EFI_IMAGE_SCN_LNK_INFO                     0x00000200  // Section contains comments or some other type of information
#define EFI_IMAGE_SCN_LNK_REMOVE                   0x00000800  // Section contents will not become part of image
#define EFI_IMAGE_SCN_LNK_COMDAT                   0x00001000

#define EFI_IMAGE_SCN_ALIGN_1BYTES                 0x00100000
#define EFI_IMAGE_SCN_ALIGN_2BYTES                 0x00200000
#define EFI_IMAGE_SCN_ALIGN_4BYTES                 0x00300000
#define EFI_IMAGE_SCN_ALIGN_8BYTES                 0x00400000
#define EFI_IMAGE_SCN_ALIGN_16BYTES                0x00500000
#define EFI_IMAGE_SCN_ALIGN_32BYTES                0x00600000
#define EFI_IMAGE_SCN_ALIGN_64BYTES                0x00700000

#define EFI_IMAGE_SCN_MEM_DISCARDABLE              0x02000000
#define EFI_IMAGE_SCN_MEM_NOT_CACHED               0x04000000
#define EFI_IMAGE_SCN_MEM_NOT_PAGED                0x08000000
#define EFI_IMAGE_SCN_MEM_SHARED                   0x10000000
#define EFI_IMAGE_SCN_MEM_EXECUTE                  0x20000000
#define EFI_IMAGE_SCN_MEM_READ                     0x40000000
#define EFI_IMAGE_SCN_MEM_WRITE                    0x80000000

//
// Size of a Symbol Table Record
//
#define EFI_IMAGE_SIZEOF_SYMBOL 18

//
// Symbols have a section number of the section in which they are
// defined. Otherwise, section numbers have the following meanings:
//
#define EFI_IMAGE_SYM_UNDEFINED (UINT16) 0  ///< Symbol is undefined or is common
#define EFI_IMAGE_SYM_ABSOLUTE  (UINT16) -1 ///< Symbol is an absolute value
#define EFI_IMAGE_SYM_DEBUG     (UINT16) -2 ///< Symbol is a special debug item

//
// Symbol Type (fundamental) values.
//
#define EFI_IMAGE_SYM_TYPE_NULL   0   // no type
#define EFI_IMAGE_SYM_TYPE_VOID   1   // no valid type
#define EFI_IMAGE_SYM_TYPE_CHAR   2   // type character
#define EFI_IMAGE_SYM_TYPE_SHORT  3   // type short integer
#define EFI_IMAGE_SYM_TYPE_INT    4
#define EFI_IMAGE_SYM_TYPE_LONG   5
#define EFI_IMAGE_SYM_TYPE_FLOAT  6
#define EFI_IMAGE_SYM_TYPE_DOUBLE 7
#define EFI_IMAGE_SYM_TYPE_STRUCT 8
#define EFI_IMAGE_SYM_TYPE_UNION  9
#define EFI_IMAGE_SYM_TYPE_ENUM   10  // enumeration
#define EFI_IMAGE_SYM_TYPE_MOE    11  // member of enumeration
#define EFI_IMAGE_SYM_TYPE_BYTE   12
#define EFI_IMAGE_SYM_TYPE_WORD   13
#define EFI_IMAGE_SYM_TYPE_UINT   14
#define EFI_IMAGE_SYM_TYPE_DWORD  15

//
// Symbol Type (derived) values
//
#define EFI_IMAGE_SYM_DTYPE_NULL      0 // no derived type
#define EFI_IMAGE_SYM_DTYPE_POINTER   1
#define EFI_IMAGE_SYM_DTYPE_FUNCTION  2
#define EFI_IMAGE_SYM_DTYPE_ARRAY     3

//
// Storage classes
//
#define EFI_IMAGE_SYM_CLASS_END_OF_FUNCTION   ((UINT8) -1)
#define EFI_IMAGE_SYM_CLASS_NULL              0
#define EFI_IMAGE_SYM_CLASS_AUTOMATIC         1
#define EFI_IMAGE_SYM_CLASS_EXTERNAL          2
#define EFI_IMAGE_SYM_CLASS_STATIC            3
#define EFI_IMAGE_SYM_CLASS_REGISTER          4
#define EFI_IMAGE_SYM_CLASS_EXTERNAL_DEF      5
#define EFI_IMAGE_SYM_CLASS_LABEL             6
#define EFI_IMAGE_SYM_CLASS_UNDEFINED_LABEL   7
#define EFI_IMAGE_SYM_CLASS_MEMBER_OF_STRUCT  8
#define EFI_IMAGE_SYM_CLASS_ARGUMENT          9
#define EFI_IMAGE_SYM_CLASS_STRUCT_TAG        10
#define EFI_IMAGE_SYM_CLASS_MEMBER_OF_UNION   11
#define EFI_IMAGE_SYM_CLASS_UNION_TAG         12
#define EFI_IMAGE_SYM_CLASS_TYPE_DEFINITION   13
#define EFI_IMAGE_SYM_CLASS_UNDEFINED_STATIC  14
#define EFI_IMAGE_SYM_CLASS_ENUM_TAG          15
#define EFI_IMAGE_SYM_CLASS_MEMBER_OF_ENUM    16
#define EFI_IMAGE_SYM_CLASS_REGISTER_PARAM    17
#define EFI_IMAGE_SYM_CLASS_BIT_FIELD         18
#define EFI_IMAGE_SYM_CLASS_BLOCK             100
#define EFI_IMAGE_SYM_CLASS_FUNCTION          101
#define EFI_IMAGE_SYM_CLASS_END_OF_STRUCT     102
#define EFI_IMAGE_SYM_CLASS_FILE              103
#define EFI_IMAGE_SYM_CLASS_SECTION           104
#define EFI_IMAGE_SYM_CLASS_WEAK_EXTERNAL     105

//
// Type packing constants
//
#define EFI_IMAGE_N_BTMASK  017
#define EFI_IMAGE_N_TMASK   060
#define EFI_IMAGE_N_TMASK1  0300
#define EFI_IMAGE_N_TMASK2  0360
#define EFI_IMAGE_N_BTSHFT  4
#define EFI_IMAGE_N_TSHIFT  2

//
// Communal selection types
//
#define EFI_IMAGE_COMDAT_SELECT_NODUPLICATES    1
#define EFI_IMAGE_COMDAT_SELECT_ANY             2
#define EFI_IMAGE_COMDAT_SELECT_SAME_SIZE       3
#define EFI_IMAGE_COMDAT_SELECT_EXACT_MATCH     4
#define EFI_IMAGE_COMDAT_SELECT_ASSOCIATIVE     5

//
// The following values only be referred in PeCoff, not defined in PECOFF
//
#define EFI_IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY  1
#define EFI_IMAGE_WEAK_EXTERN_SEARCH_LIBRARY    2
#define EFI_IMAGE_WEAK_EXTERN_SEARCH_ALIAS      3

//
// Relocation format
//
typedef struct {
    UINT32  VirtualAddress;
    UINT32  SymbolTableIndex;
    UINT16  Type;
} EFI_IMAGE_RELOCATION;

//
// Size of EFI_IMAGE_RELOCATION
//
#define EFI_IMAGE_SIZEOF_RELOCATION 10

//
// I386 relocation types
//
#define EFI_IMAGE_REL_I386_ABSOLUTE    0x0000  // Reference is absolute, no relocation is necessary
#define EFI_IMAGE_REL_I386_DIR16       0x0001  // Direct 16-bit reference to the symbols virtual address
#define EFI_IMAGE_REL_I386_REL16       0x0002  // PC-relative 16-bit reference to the symbols virtual address
#define EFI_IMAGE_REL_I386_DIR32       0x0006  // Direct 32-bit reference to the symbols virtual address
#define EFI_IMAGE_REL_I386_DIR32NB     0x0007  // Direct 32-bit reference to the symbols virtual address, base not included
#define EFI_IMAGE_REL_I386_SEG12       0x0009  // Direct 16-bit reference to the segment-selector bits of a 32-bit virtual address
#define EFI_IMAGE_REL_I386_SECTION     0x000A
#define EFI_IMAGE_REL_I386_SECREL      0x000B
#define EFI_IMAGE_REL_I386_REL32       0x0014  // PC-relative 32-bit reference to the symbols virtual address


//
// x64 relocation types
//
#define EFI_IMAGE_REL_AMD64_ABSOLUTE  0x0000
#define EFI_IMAGE_REL_AMD64_ADDR64    0x0001
#define EFI_IMAGE_REL_AMD64_ADDR32    0x0002
#define EFI_IMAGE_REL_AMD64_ADDR32NB  0x0003
#define EFI_IMAGE_REL_AMD64_REL32     0x0004
#define EFI_IMAGE_REL_AMD64_REL32_1   0x0005
#define EFI_IMAGE_REL_AMD64_REL32_2   0x0006
#define EFI_IMAGE_REL_AMD64_REL32_3   0x0007
#define EFI_IMAGE_REL_AMD64_REL32_4   0x0008
#define EFI_IMAGE_REL_AMD64_REL32_5   0x0009
#define EFI_IMAGE_REL_AMD64_SECTION   0x000A
#define EFI_IMAGE_REL_AMD64_SECREL    0x000B
#define EFI_IMAGE_REL_AMD64_SECREL7   0x000C
#define EFI_IMAGE_REL_AMD64_TOKEN     0x000D
#define EFI_IMAGE_REL_AMD64_SREL32    0x000E
#define EFI_IMAGE_REL_AMD64_PAIR      0x000F
#define EFI_IMAGE_REL_AMD64_SSPAN32   0x0010

//
// RISC-V relocation types
//
#define EFI_IMAGE_REL_BASED_RISCV_HI20  0x0005
#define EFI_IMAGE_REL_BASED_RISCV_LO12I 0x0007
#define EFI_IMAGE_REL_BASED_RISCV_LO12S 0x0008


//
// Based relocation format
//
typedef struct {
    UINT32  VirtualAddress;
    UINT32  SizeOfBlock;
} EFI_IMAGE_BASE_RELOCATION;

//
// Size of EFI_IMAGE_BASE_RELOCATION
//
#define EFI_IMAGE_SIZEOF_BASE_RELOCATION  8

//
// Based relocation types
//
#define EFI_IMAGE_REL_BASED_ABSOLUTE        0
#define EFI_IMAGE_REL_BASED_HIGH            1
#define EFI_IMAGE_REL_BASED_LOW             2
#define EFI_IMAGE_REL_BASED_HIGHLOW         3
#define EFI_IMAGE_REL_BASED_HIGHADJ         4
#define EFI_IMAGE_REL_BASED_MIPS_JMPADDR    5
#define EFI_IMAGE_REL_BASED_ARM_MOV32A      5
#define EFI_IMAGE_REL_BASED_ARM_MOV32T      7
#define EFI_IMAGE_REL_BASED_IA64_IMM64      9
#define EFI_IMAGE_REL_BASED_MIPS_JMPADDR16  9
#define EFI_IMAGE_REL_BASED_DIR64           10

//
// Line number format
//
typedef struct {
    union {
        UINT32  SymbolTableIndex; // Symbol table index of function name if line number is 0
        UINT32  VirtualAddress;   // Virtual address of line number
    } Type;
    UINT16  Linenumber;         // Line number
} EFI_IMAGE_LINENUMBER;

//
// Size of EFI_IMAGE_LINENUMBER
//
#define EFI_IMAGE_SIZEOF_LINENUMBER 6

//
// Archive format
//
#define EFI_IMAGE_ARCHIVE_START_SIZE        8
#define EFI_IMAGE_ARCHIVE_START             "!<arch>\n"
#define EFI_IMAGE_ARCHIVE_END               "`\n"
#define EFI_IMAGE_ARCHIVE_PAD               "\n"
#define EFI_IMAGE_ARCHIVE_LINKER_MEMBER     "/               "
#define EFI_IMAGE_ARCHIVE_LONGNAMES_MEMBER  "//              "

//
// Archive Member Headers
//
typedef struct {
    UINT8 Name[16];     // File member name - `/' terminated
    UINT8 Date[12];     // File member date - decimal
    UINT8 UserID[6];    // File member user id - decimal
    UINT8 GroupID[6];   // File member group id - decimal
    UINT8 Mode[8];      // File member mode - octal
    UINT8 Size[10];     // File member size - decimal
    UINT8 EndHeader[2]; // String to end header. (0x60 0x0A)
} EFI_IMAGE_ARCHIVE_MEMBER_HEADER;

//
// Size of EFI_IMAGE_ARCHIVE_MEMBER_HEADER
//
#define EFI_IMAGE_SIZEOF_ARCHIVE_MEMBER_HDR 60

//
// DLL Support
//

//
// Export Directory Table
//
typedef struct {
    UINT32  Characteristics;
    UINT32  TimeDateStamp;
    UINT16  MajorVersion;
    UINT16  MinorVersion;
    UINT32  Name;
    UINT32  Base;
    UINT32  NumberOfFunctions;
    UINT32  NumberOfNames;
    UINT32  AddressOfFunctions;
    UINT32  AddressOfNames;
    UINT32  AddressOfNameOrdinals;
} EFI_IMAGE_EXPORT_DIRECTORY;

//
// Hint/Name Table
//
typedef struct {
    UINT16  Hint;
    UINT8   Name[1];
} EFI_IMAGE_IMPORT_BY_NAME;

//
// Import Address Table RVA (Thunk Table)
//
typedef struct {
    union {
        UINT32                    Function;
        UINT32                    Ordinal;
        EFI_IMAGE_IMPORT_BY_NAME  *AddressOfData;
    } u1;
} EFI_IMAGE_THUNK_DATA;

#define EFI_IMAGE_ORDINAL_FLAG              0x80000000 // Flag for PE32.
#define EFI_IMAGE_SNAP_BY_ORDINAL(Ordinal)  (((Ordinal) & EFI_IMAGE_ORDINAL_FLAG) != 0)
#define EFI_IMAGE_ORDINAL(Ordinal)          ((Ordinal) & 0xffff)

//
// Import Directory Table
//
typedef struct {
    UINT32                Characteristics;
    UINT32                TimeDateStamp;
    UINT32                ForwarderChain;
    UINT32                Name;
    EFI_IMAGE_THUNK_DATA  *FirstThunk;
} EFI_IMAGE_IMPORT_DESCRIPTOR;

//
// Debug Directory Format
//
typedef struct {
    UINT32  Characteristics;
    UINT32  TimeDateStamp;
    UINT16  MajorVersion;
    UINT16  MinorVersion;
    UINT32  Type;
    UINT32  SizeOfData;
    UINT32  RVA;           // The address of the debug data when loaded, relative to the image base
    UINT32  FileOffset;    // The file pointer to the debug data
} EFI_IMAGE_DEBUG_DIRECTORY_ENTRY;

#define EFI_IMAGE_DEBUG_TYPE_CODEVIEW 2     // The Visual C++ debug information.

//
// Debug Data Structure defined in Microsoft C++
//
#define CODEVIEW_SIGNATURE_NB10  0x3031424E // NB10
typedef struct {
    UINT32  Signature;
    UINT32  Unknown;
    UINT32  Unknown2;
    UINT32  Unknown3;
    //
    // Filename of .PDB goes here
    //
} EFI_IMAGE_DEBUG_CODEVIEW_NB10_ENTRY;

//
// Debug Data Structure defined in Microsoft C++
//
#define CODEVIEW_SIGNATURE_RSDS  0x53445352 // RSDS
typedef struct {
    UINT32  Signature;
    UINT32  Unknown;
    UINT32  Unknown2;
    UINT32  Unknown3;
    UINT32  Unknown4;
    UINT32  Unknown5;
    //
    // Filename of .PDB goes here
    //
} EFI_IMAGE_DEBUG_CODEVIEW_RSDS_ENTRY;

//
// Debug Data Structure defined by Apple Mach-O to COFF utility.
//
#define CODEVIEW_SIGNATURE_MTOC  0x434F544D // MTOC
typedef struct {
    UINT32    Signature;
    UINT8     MachOUuid[16];
    //
    //  Filename of .DLL (Mach-O with debug info) goes here
    //
} EFI_IMAGE_DEBUG_CODEVIEW_MTOC_ENTRY;

//
// Resource format
//
typedef struct {
    UINT32  Characteristics;
    UINT32  TimeDateStamp;
    UINT16  MajorVersion;
    UINT16  MinorVersion;
    UINT16  NumberOfNamedEntries;
    UINT16  NumberOfIdEntries;
    //
    // Array of EFI_IMAGE_RESOURCE_DIRECTORY_ENTRY entries goes here
    //
} EFI_IMAGE_RESOURCE_DIRECTORY;

//
// Resource directory entry format
//
typedef struct {
    union {
        struct {
            UINT32  NameOffset : 31;
            UINT32  NameIsString : 1;
        } s;
        UINT32  Id;
    } u1;
    union {
        UINT32  OffsetToData;
        struct {
            UINT32  OffsetToDirectory : 31;
            UINT32  DataIsDirectory : 1;
        } s;
    } u2;
} EFI_IMAGE_RESOURCE_DIRECTORY_ENTRY;

//
// Resource directory entry for string
//
typedef struct {
    UINT16  Length;
    CHAR16  String[1];
} EFI_IMAGE_RESOURCE_DIRECTORY_STRING;

//
// Resource directory entry for data array
//
typedef struct {
    UINT32  OffsetToData;
    UINT32  Size;
    UINT32  CodePage;
    UINT32  Reserved;
} EFI_IMAGE_RESOURCE_DATA_ENTRY;

//
// Header format for TE images, defined in the PI Specification 1.0.
//
typedef struct {
    UINT16                    Signature;            // The signature for TE format = "VZ"
    UINT16                    Machine;              // From original file header
    UINT8                     NumberOfSections;     // From original file header
    UINT8                     Subsystem;            // From original optional header
    UINT16                    StrippedSize;         // Number of bytes we removed from header
    UINT32                    AddressOfEntryPoint;  // Offset to entry point -- from original optional header
    UINT32                    BaseOfCode;           // From original image -- required for ITP debug
    UINT64                    ImageBase;            // From original file header
    EFI_IMAGE_DATA_DIRECTORY  DataDirectory[2];     // Only base relocation and debug directory
} EFI_IMAGE_TE_HEADER;

#define EFI_IMAGE_TE_SIGNATURE  0x5A56 // VZ

// Image base types
#define EFI_IMAGE_TE_BASE_OTHER    0
#define EFI_IMAGE_TE_BASE_ORIGINAL 1
#define EFI_IMAGE_TE_BASE_ADJUSTED 2

//
// Data directory indexes in our TE image header
//
#define EFI_IMAGE_TE_DIRECTORY_ENTRY_BASERELOC  0
#define EFI_IMAGE_TE_DIRECTORY_ENTRY_DEBUG      1

// Restore previous packing rules
#pragma pack(pop)
#endif // PEIMAGE_H

```

`efiXloader/3rd/uefitool/common/sha256.c`:

```c
/* sha256.c

Copyright (c) 2017, LongSoft. All rights reserved.
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

*/

#include "sha256.h"
#include <stdint.h>
#include <string.h>

struct sha256_state {
    uint64_t length;
    uint32_t state[8], curlen;
    uint8_t buf[SHA256_DIGEST_SIZE*2];
};

void sha256_init(struct sha256_state *md);
int sha256_process(struct sha256_state *md, const unsigned char *in, unsigned long inlen);
int sha256_done(struct sha256_state *md, uint8_t *out);

#define GET_BE32(a) ((((uint32_t) (a)[0]) << 24) | (((uint32_t) (a)[1]) << 16) | \
                          (((uint32_t) (a)[2]) << 8) | ((uint32_t) (a)[3]))

#define PUT_BE32(a, val)                                     \
         do {                                                    \
                 (a)[0] = (uint8_t) ((((uint32_t) (val)) >> 24) & 0xff);   \
                 (a)[1] = (uint8_t) ((((uint32_t) (val)) >> 16) & 0xff);   \
                 (a)[2] = (uint8_t) ((((uint32_t) (val)) >> 8) & 0xff);    \
                 (a)[3] = (uint8_t) (((uint32_t) (val)) & 0xff);           \
         } while (0)

#define PUT_BE64(a, val)                             \
         do {                                            \
                 (a)[0] = (uint8_t) (((uint64_t) (val)) >> 56);    \
                 (a)[1] = (uint8_t) (((uint64_t) (val)) >> 48);    \
                 (a)[2] = (uint8_t) (((uint64_t) (val)) >> 40);    \
                 (a)[3] = (uint8_t) (((uint64_t) (val)) >> 32);    \
                 (a)[4] = (uint8_t) (((uint64_t) (val)) >> 24);    \
                 (a)[5] = (uint8_t) (((uint64_t) (val)) >> 16);    \
                 (a)[6] = (uint8_t) (((uint64_t) (val)) >> 8);     \
                 (a)[7] = (uint8_t) (((uint64_t) (val)) & 0xff);   \
         } while (0)

void sha256(const void *in, unsigned long inlen, void* out)
{
    struct sha256_state ctx;
    sha256_init(&ctx);
    sha256_process(&ctx, (const unsigned char*)in, inlen);
    sha256_done(&ctx, (unsigned char *)out);
}

/* This is based on SHA256 implementation in LibTomCrypt that was released into
 * public domain by Tom St Denis. */
/* the K array */
static const unsigned long K[64] = {
    0x428a2f98UL, 0x71374491UL, 0xb5c0fbcfUL, 0xe9b5dba5UL, 0x3956c25bUL,
    0x59f111f1UL, 0x923f82a4UL, 0xab1c5ed5UL, 0xd807aa98UL, 0x12835b01UL,
    0x243185beUL, 0x550c7dc3UL, 0x72be5d74UL, 0x80deb1feUL, 0x9bdc06a7UL,
    0xc19bf174UL, 0xe49b69c1UL, 0xefbe4786UL, 0x0fc19dc6UL, 0x240ca1ccUL,
    0x2de92c6fUL, 0x4a7484aaUL, 0x5cb0a9dcUL, 0x76f988daUL, 0x983e5152UL,
    0xa831c66dUL, 0xb00327c8UL, 0xbf597fc7UL, 0xc6e00bf3UL, 0xd5a79147UL,
    0x06ca6351UL, 0x14292967UL, 0x27b70a85UL, 0x2e1b2138UL, 0x4d2c6dfcUL,
    0x53380d13UL, 0x650a7354UL, 0x766a0abbUL, 0x81c2c92eUL, 0x92722c85UL,
    0xa2bfe8a1UL, 0xa81a664bUL, 0xc24b8b70UL, 0xc76c51a3UL, 0xd192e819UL,
    0xd6990624UL, 0xf40e3585UL, 0x106aa070UL, 0x19a4c116UL, 0x1e376c08UL,
    0x2748774cUL, 0x34b0bcb5UL, 0x391c0cb3UL, 0x4ed8aa4aUL, 0x5b9cca4fUL,
    0x682e6ff3UL, 0x748f82eeUL, 0x78a5636fUL, 0x84c87814UL, 0x8cc70208UL,
    0x90befffaUL, 0xa4506cebUL, 0xbef9a3f7UL, 0xc67178f2UL
};
/* Various logical functions */
#define RORc(x, y) \
( ((((unsigned long) (x) & 0xFFFFFFFFUL) >> (unsigned long) ((y) & 31)) | \
((unsigned long) (x) << (unsigned long) (32 - ((y) & 31)))) & 0xFFFFFFFFUL)
#define Ch(x,y,z)       (z ^ (x & (y ^ z)))
#define Maj(x,y,z)      (((x | y) & z) | (x & y))
#define S(x, n)         RORc((x), (n))
#define R(x, n)         (((x)&0xFFFFFFFFUL)>>(n))
#define Sigma0(x)       (S(x, 2) ^ S(x, 13) ^ S(x, 22))
#define Sigma1(x)       (S(x, 6) ^ S(x, 11) ^ S(x, 25))
#define Gamma0(x)       (S(x, 7) ^ S(x, 18) ^ R(x, 3))
#define Gamma1(x)       (S(x, 17) ^ S(x, 19) ^ R(x, 10))
#ifndef MIN
#define MIN(x, y) (((x) < (y)) ? (x) : (y))
#endif
/* compress 512-bits */
static void sha256_compress(struct sha256_state *md, unsigned char *buf)
{
    uint32_t S[8], W[64], t0, t1;
    uint32_t t;
    int i;
    /* copy state into S */
    for (i = 0; i < 8; i++) {
        S[i] = md->state[i];
    }
    /* copy the state into 512-bits into W[0..15] */
    for (i = 0; i < 16; i++)
        W[i] = GET_BE32(buf + (4 * i));
    /* fill W[16..63] */
    for (i = 16; i < 64; i++) {
        W[i] = Gamma1(W[i - 2]) + W[i - 7] + Gamma0(W[i - 15]) +
        W[i - 16];
    }
    /* Compress */
#define RND(a,b,c,d,e,f,g,h,i)                          \
t0 = h + Sigma1(e) + Ch(e, f, g) + K[i] + W[i];	\
t1 = Sigma0(a) + Maj(a, b, c);			\
d += t0;					\
h  = t0 + t1;
    for (i = 0; i < 64; ++i) {
        RND(S[0], S[1], S[2], S[3], S[4], S[5], S[6], S[7], i);
        t = S[7]; S[7] = S[6]; S[6] = S[5]; S[5] = S[4];
        S[4] = S[3]; S[3] = S[2]; S[2] = S[1]; S[1] = S[0]; S[0] = t;
    }
    /* feedback */
    for (i = 0; i < 8; i++) {
        md->state[i] = md->state[i] + S[i];
    }
}
/* Initialize the hash state */
void sha256_init(struct sha256_state *md)
{
    md->curlen = 0;
    md->length = 0;
    md->state[0] = 0x6A09E667UL;
    md->state[1] = 0xBB67AE85UL;
    md->state[2] = 0x3C6EF372UL;
    md->state[3] = 0xA54FF53AUL;
    md->state[4] = 0x510E527FUL;
    md->state[5] = 0x9B05688CUL;
    md->state[6] = 0x1F83D9ABUL;
    md->state[7] = 0x5BE0CD19UL;
}
/**
 Process a block of memory though the hash
 @param md     The hash state
 @param in     The data to hash
 @param inlen  The length of the data (octets)
 @return CRYPT_OK if successful
 */
int sha256_process(struct sha256_state *md, const unsigned char *in,
                          unsigned long inlen)
{
    unsigned long n;
#define block_size 64
    if (md->curlen > sizeof(md->buf))
        return -1;
    while (inlen > 0) {
        if (md->curlen == 0 && inlen >= block_size) {
            sha256_compress(md, (unsigned char *) in);
            md->length += block_size * 8;
            in += block_size;
            inlen -= block_size;
        } else {
            n = MIN(inlen, (block_size - md->curlen));
            memcpy(md->buf + md->curlen, in, n);
            md->curlen += n;
            in += n;
            inlen -= n;
            if (md->curlen == block_size) {
                sha256_compress(md, md->buf);
                md->length += 8 * block_size;
                md->curlen = 0;
            }
        }
    }
    return 0;
}
/**
 Terminate the hash to get the digest
 @param md  The hash state
 @param out [out] The destination of the hash (32 bytes)
 @return CRYPT_OK if successful
 */
int sha256_done(struct sha256_state *md, unsigned char *out)
{
    int i;
    if (md->curlen >= sizeof(md->buf))
        return -1;
    /* increase the length of the message */
    md->length += (uint64_t)md->curlen * 8;
    /* append the '1' bit */
    md->buf[md->curlen++] = (unsigned char) 0x80;
    /* if the length is currently above 56 bytes we append zeros
     * then compress.  Then we can fall back to padding zeros and length
     * encoding like normal.
     */
    if (md->curlen > 56) {
        while (md->curlen < 64) {
            md->buf[md->curlen++] = (unsigned char) 0;
        }
        sha256_compress(md, md->buf);
        md->curlen = 0;
    }
    /* pad upto 56 bytes of zeroes */
    while (md->curlen < 56) {
        md->buf[md->curlen++] = (unsigned char) 0;
    }
    /* store length */
    PUT_BE64(md->buf + 56, md->length);
    sha256_compress(md, md->buf);
    /* copy output */
    for (i = 0; i < 8; i++)
        PUT_BE32(out + (4 * i), md->state[i]);
    return 0;
}

```

`efiXloader/3rd/uefitool/common/sha256.h`:

```h
/* sha256.h

Copyright (c) 2017, LongSoft. All rights reserved.
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

*/

#ifndef SHA256_H
#define SHA256_H
#ifdef __cplusplus
extern "C" {
#endif

#define SHA256_DIGEST_SIZE 32

void sha256(const void *in, unsigned long inlen, void* out);
    
#ifdef __cplusplus
}
#endif
#endif // SHA256_H

```

`efiXloader/3rd/uefitool/common/treeitem.cpp`:

```cpp
/* treeitem.cpp

Copyright (c) 2015, Nikolaj Schlej. All rights reserved.
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution. The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

*/

#include "treeitem.h"
#include "types.h"

TreeItem::TreeItem(const UINT32 offset, const UINT8 type, const UINT8 subtype, 
    const UString & name, const UString & text, const UString & info,
    const UByteArray & header, const UByteArray & body, const UByteArray & tail,
    const bool fixed, const bool compressed,
    TreeItem *parent) : 
    itemOffset(offset),
    itemAction(Actions::NoAction),
    itemType(type),
    itemSubtype(subtype),
    itemMarking(0),
    itemName(name),
    itemText(text),
    itemInfo(info),
    itemHeader(header),
    itemBody(body),
    itemTail(tail),
    itemFixed(fixed),
    itemCompressed(compressed),
    parentItem(parent)
{
}

TreeItem::~TreeItem() {
    std::list<TreeItem*>::iterator begin = childItems.begin();
    while (begin != childItems.end()) {
        delete *begin;
        ++begin;
    }
}

UINT8 TreeItem::insertChildBefore(TreeItem *item, TreeItem *newItem)
{
    std::list<TreeItem*>::iterator found = std::find(childItems.begin(), childItems.end(), item);
    if (found == childItems.end())
        return U_ITEM_NOT_FOUND;
    childItems.insert(found, newItem);
    return U_SUCCESS;
}

UINT8 TreeItem::insertChildAfter(TreeItem *item, TreeItem *newItem)
{
    std::list<TreeItem*>::iterator found = std::find(childItems.begin(), childItems.end(), item);
    if (found == childItems.end())
        return U_ITEM_NOT_FOUND;
    childItems.insert(++found, newItem);
    return U_SUCCESS;
}

UString TreeItem::data(int column) const
{
    switch (column)
    {
    case 0: // Name
        return itemName;
    case 1: // Action
        return actionTypeToUString(itemAction);
    case 2: // Type
        return itemTypeToUString(itemType);
    case 3: // Subtype
        return itemSubtypeToUString(itemType, itemSubtype);
    case 4: // Text
        return itemText;
    default:
        return UString();
    }
}

int TreeItem::row() const
{
    if (parentItem) {
        std::list<TreeItem*>::const_iterator iter = parentItem->childItems.begin();
        for (int i = 0; i < (int)parentItem->childItems.size(); ++i, ++iter) {
            if (const_cast<TreeItem*>(this) == *iter)
                return i;
        }
    }
    return 0;
}

TreeItem* TreeItem::child(int row)
{ 
    std::list<TreeItem*>::iterator child = childItems.begin();  
    std::advance(child, row); 
    return *child; 
}
```

`efiXloader/3rd/uefitool/common/treeitem.h`:

```h
/* treeitem.h

Copyright (c) 2015, Nikolaj Schlej. All rights reserved.
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

*/

#ifndef TREEITEM_H
#define TREEITEM_H

#include <list>
#include <iterator>

#include "basetypes.h"
#include "ubytearray.h"
#include "ustring.h"

class TreeItem
{
public:
    TreeItem(const UINT32 offset, const UINT8 type, const UINT8 subtype, const UString &name, const UString &text, const UString &info,
        const UByteArray & header, const UByteArray & body, const UByteArray & tail,
        const bool fixed, const bool compressed,
        TreeItem *parent = 0);
    ~TreeItem();                                                               // Non-trivial implementation in CPP file

    // Operations with items
    void appendChild(TreeItem *item) { childItems.push_back(item); }
    void prependChild(TreeItem *item) { childItems.push_front(item); };
    UINT8 insertChildBefore(TreeItem *item, TreeItem *newItem);                // Non-trivial implementation in CPP file
    UINT8 insertChildAfter(TreeItem *item, TreeItem *newItem);                 // Non-trivial implementation in CPP file

    // Model support operations
    TreeItem *child(int row);                                                  // Non-trivial implementation in CPP file
    int childCount() const {return (int)childItems.size(); }
    int columnCount() const { return 5; }
    UString data(int column) const;                                            // Non-trivial implementation in CPP file
    int row() const;                                                           // Non-trivial implementation in CPP file
    TreeItem *parent() { return parentItem; }

    // Getters and setters for item parameters
    UINT32 offset() const { return itemOffset; }
    void setOffset(const UINT32 offset) { itemOffset = offset; }

    UINT8 type() const  { return itemType; }
    void setType(const UINT8 type) { itemType = type; }

    UINT8 subtype() const { return itemSubtype; }
    void setSubtype(const UINT8 subtype) { itemSubtype = subtype; }

    UString name() const  { return itemName; }
    void setName(const UString &text) { itemName = text; }

    UString text() const { return itemText; }
    void setText(const UString &text) { itemText = text; }

    UByteArray header() const { return itemHeader; }
    bool hasEmptyHeader() const { return itemHeader.isEmpty(); }

    UByteArray body() const { return itemBody; };
    bool hasEmptyBody() const { return itemBody.isEmpty(); }

    UByteArray tail() const { return itemTail; };
    bool hasEmptyTail() const { return itemTail.isEmpty(); }

    UString info() const { return itemInfo; }
    void addInfo(const UString &info, const bool append) { if (append) itemInfo += info; else itemInfo = info + itemInfo; }
    void setInfo(const UString &info) { itemInfo = info; }
    
    UINT8 action() const {return itemAction; }
    void setAction(const UINT8 action) { itemAction = action; }

    bool fixed() const { return itemFixed; }
    void setFixed(const bool fixed) { itemFixed = fixed; }

    bool compressed() const { return itemCompressed; }
    void setCompressed(const bool compressed) { itemCompressed = compressed; }

    UByteArray parsingData() const { return itemParsingData; };
    bool hasEmptyParsingData() const { return itemParsingData.isEmpty(); }
    void setParsingData(const UByteArray & pdata) { itemParsingData = pdata; }

    UINT8 marking() const { return itemMarking; }
    void setMarking(const UINT8 marking) { itemMarking = marking; }

private:
    std::list<TreeItem*> childItems;
    UINT32     itemOffset;
    UINT8      itemAction;
    UINT8      itemType;
    UINT8      itemSubtype;
    UINT8      itemMarking;
    UString    itemName;
    UString    itemText;
    UString    itemInfo;
    UByteArray itemHeader;
    UByteArray itemBody;
    UByteArray itemTail;
    bool       itemFixed;
    bool       itemCompressed;
    UByteArray itemParsingData;
    TreeItem*  parentItem;
};

#endif // TREEITEM_H

```

`efiXloader/3rd/uefitool/common/treemodel.cpp`:

```cpp
/* treemodel.cpp

Copyright (c) 2015, Nikolaj Schlej. All rights reserved.
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

*/

#include "treemodel.h"

#include "stack"

#if defined(QT_CORE_LIB)
QVariant TreeModel::data(const UModelIndex &index, int role) const
{
    if (!index.isValid())
        return QVariant();

    TreeItem *item = static_cast<TreeItem*>(index.internalPointer());

    if (role == Qt::DisplayRole) {
        return item->data(index.column()).toLocal8Bit();
    }
#if defined (QT_GUI_LIB)
    else if (role == Qt::BackgroundRole) {
        if (markingEnabledFlag && marking(index) > 0) {
            return QBrush((Qt::GlobalColor)marking(index));
        }
    }
#endif
    else if (role == Qt::UserRole) {
        return item->info().toLocal8Bit();
    }

    return QVariant();
}

Qt::ItemFlags TreeModel::flags(const UModelIndex &index) const
{
    if (!index.isValid())
        return 0;

    return Qt::ItemIsEnabled | Qt::ItemIsSelectable;
}

QVariant TreeModel::headerData(int section, Qt::Orientation orientation,
    int role) const
{
    if (orientation == Qt::Horizontal && role == Qt::DisplayRole) {
        switch (section) {
        case 0: return tr("Name");
        case 1: return tr("Action");
        case 2: return tr("Type");
        case 3: return tr("Subtype");
        case 4: return tr("Text");
        }
    }

    return QVariant();
}
#else
UString TreeModel::data(const UModelIndex &index, int role) const
{
    if (!index.isValid())
        return UString();

    if (role != 0 && role != 0x0100)
        return UString();

    TreeItem *item = static_cast<TreeItem*>(index.internalPointer());

    if (role == 0)
        return item->data(index.column());
    else
        return item->info();
}

UString TreeModel::headerData(int section, int orientation,
    int role) const
{
    if (orientation == 1 && role == 0) {
        switch (section)
        {
        case 0: return UString("Name");
        case 1: return UString("Action");
        case 2: return UString("Type");
        case 3: return UString("Subtype");
        case 4: return UString("Text");
        }
    }

    return UString();
}
#endif

int TreeModel::columnCount(const UModelIndex &parent) const
{
    if (parent.isValid())
        return static_cast<TreeItem*>(parent.internalPointer())->columnCount();
    else
        return rootItem->columnCount();
}

UModelIndex TreeModel::index(int row, int column, const UModelIndex &parent) const
{
    if (!hasIndex(row, column, parent))
        return UModelIndex();

    TreeItem *parentItem;

    if (!parent.isValid())
        parentItem = rootItem;
    else
        parentItem = static_cast<TreeItem*>(parent.internalPointer());

    TreeItem *childItem = parentItem->child(row);
    if (childItem)
        return createIndex(row, column, childItem);
    else
        return UModelIndex();
}

UModelIndex TreeModel::parent(const UModelIndex &index) const
{
    if (!index.isValid())
        return UModelIndex();

    TreeItem *childItem = static_cast<TreeItem*>(index.internalPointer());
    if (childItem == rootItem)
        return UModelIndex();

    TreeItem *parentItem = childItem->parent();

    if (parentItem == rootItem)
        return UModelIndex();

    return createIndex(parentItem->row(), 0, parentItem);
}

int TreeModel::rowCount(const UModelIndex &parent) const
{
    TreeItem *parentItem;
    if (parent.column() > 0)
        return 0;

    if (!parent.isValid())
        parentItem = rootItem;
    else
        parentItem = static_cast<TreeItem*>(parent.internalPointer());

    return parentItem->childCount();
}

UINT32 TreeModel::base(const UModelIndex &current) const
{
    // TODO: rewrite this as loop if we ever see an image that is too deep for this naive implementation
    if (!current.isValid())
        return 0;

    UModelIndex parent = current.parent();
    if (!parent.isValid())
        return offset(current);
    else {
        return offset(current) + base(parent);
    }
}

UINT32 TreeModel::offset(const UModelIndex &index) const
{
    if (!index.isValid())
        return 0;
    TreeItem *item = static_cast<TreeItem*>(index.internalPointer());
    return item->offset();
}

UINT8 TreeModel::type(const UModelIndex &index) const
{
    if (!index.isValid())
        return 0;
    TreeItem *item = static_cast<TreeItem*>(index.internalPointer());
    return item->type();
}

UINT8 TreeModel::subtype(const UModelIndex &index) const
{
    if (!index.isValid())
        return 0;
    TreeItem *item = static_cast<TreeItem*>(index.internalPointer());
    return item->subtype();
}

UINT8 TreeModel::marking(const UModelIndex &index) const
{
    if (!index.isValid())
        return 0;
    TreeItem *item = static_cast<TreeItem*>(index.internalPointer());
    return item->marking();
}

UByteArray TreeModel::header(const UModelIndex &index) const
{
    if (!index.isValid())
        return UByteArray();
    TreeItem *item = static_cast<TreeItem*>(index.internalPointer());
    return item->header();
}

bool TreeModel::hasEmptyHeader(const UModelIndex &index) const
{
    if (!index.isValid())
        return true;
    TreeItem *item = static_cast<TreeItem*>(index.internalPointer());
    return item->hasEmptyHeader();
}

UByteArray TreeModel::body(const UModelIndex &index) const
{
    if (!index.isValid())
        return UByteArray();
    TreeItem *item = static_cast<TreeItem*>(index.internalPointer());
    return item->body();
}

bool TreeModel::hasEmptyBody(const UModelIndex &index) const
{
    if (!index.isValid())
        return true;
    TreeItem *item = static_cast<TreeItem*>(index.internalPointer());
    return item->hasEmptyBody();
}

UByteArray TreeModel::tail(const UModelIndex &index) const
{
    if (!index.isValid())
        return UByteArray();
    TreeItem *item = static_cast<TreeItem*>(index.internalPointer());
    return item->tail();
}

bool TreeModel::hasEmptyTail(const UModelIndex &index) const
{
    if (!index.isValid())
        return true;
    TreeItem *item = static_cast<TreeItem*>(index.internalPointer());
    return item->hasEmptyTail();
}

UString TreeModel::name(const UModelIndex &index) const
{
    if (!index.isValid())
        return UString();
    TreeItem *item = static_cast<TreeItem*>(index.internalPointer());
    return item->name();
}

UString TreeModel::text(const UModelIndex &index) const
{
    if (!index.isValid())
        return UString();
    TreeItem *item = static_cast<TreeItem*>(index.internalPointer());
    return item->text();
}

UString TreeModel::info(const UModelIndex &index) const
{
    if (!index.isValid())
        return UString();
    TreeItem *item = static_cast<TreeItem*>(index.internalPointer());
    return item->info();
}

UINT8 TreeModel::action(const UModelIndex &index) const
{
    if (!index.isValid())
        return Actions::NoAction;
    TreeItem *item = static_cast<TreeItem*>(index.internalPointer());
    return item->action();
}

bool TreeModel::fixed(const UModelIndex &index) const
{
    if (!index.isValid())
        return false;
    TreeItem *item = static_cast<TreeItem*>(index.internalPointer());
    return item->fixed();
}

bool TreeModel::compressed(const UModelIndex &index) const
{
    if (!index.isValid())
        return false;
    TreeItem *item = static_cast<TreeItem*>(index.internalPointer());
    return item->compressed();
}

void TreeModel::setFixed(const UModelIndex &index, const bool fixed)
{
    if (!index.isValid())
        return;

    TreeItem *item = static_cast<TreeItem*>(index.internalPointer());
    item->setFixed(fixed);

    if (!item->parent())
        return;

    if (fixed) {
        // Special handling for uncompressed to compressed boundary
        if (item->compressed() && item->parent()->compressed() == FALSE) {
            item->setFixed(item->parent()->fixed());
            return;
        }

        // Propagate fixed flag until root
        setFixed(index.parent(), true);
    }

    emit dataChanged(index, index);
}

void TreeModel::setCompressed(const UModelIndex &index, const bool compressed)
{
    if (!index.isValid())
        return;

    TreeItem *item = static_cast<TreeItem*>(index.internalPointer());
    item->setCompressed(compressed);

    emit dataChanged(index, index);
}

void TreeModel::TreeModel::setMarkingEnabled(const bool enabled) 
{ 
    markingEnabledFlag = enabled;
    
    emit dataChanged(UModelIndex(), UModelIndex());
}

void TreeModel::setMarking(const UModelIndex &index, const UINT8 marking)
{
    if (!index.isValid())
        return;

    TreeItem *item = static_cast<TreeItem*>(index.internalPointer());
    item->setMarking(marking);

    emit dataChanged(index, index);
}

void TreeModel::setOffset(const UModelIndex &index, const UINT32 offset)
{
    if (!index.isValid())
        return;

    TreeItem *item = static_cast<TreeItem*>(index.internalPointer());
    item->setOffset(offset);
    emit dataChanged(index, index);
}

void TreeModel::setType(const UModelIndex &index, const UINT8 data)
{
    if (!index.isValid())
        return;

    TreeItem *item = static_cast<TreeItem*>(index.internalPointer());
    item->setType(data);
    emit dataChanged(index, index);
}

void TreeModel::setSubtype(const UModelIndex & index, const UINT8 subtype)
{
    if (!index.isValid())
        return;

    TreeItem *item = static_cast<TreeItem*>(index.internalPointer());
    item->setSubtype(subtype);
    emit dataChanged(index, index);
}

void TreeModel::setName(const UModelIndex &index, const UString &data)
{
    if (!index.isValid())
        return;

    TreeItem *item = static_cast<TreeItem*>(index.internalPointer());
    item->setName(data);
    emit dataChanged(index, index);
}

void TreeModel::setText(const UModelIndex &index, const UString &data)
{
    if (!index.isValid())
        return;

    TreeItem *item = static_cast<TreeItem*>(index.internalPointer());
    item->setText(data);
    emit dataChanged(index, index);
}

void TreeModel::setInfo(const UModelIndex &index, const UString &data)
{
    if (!index.isValid())
        return;

    TreeItem *item = static_cast<TreeItem*>(index.internalPointer());
    item->setInfo(data);
    emit dataChanged(index, index);
}

void TreeModel::addInfo(const UModelIndex &index, const UString &data, const bool append)
{
    if (!index.isValid())
        return;

    TreeItem *item = static_cast<TreeItem*>(index.internalPointer());
    item->addInfo(data, append);
    emit dataChanged(index, index);
}

void TreeModel::setAction(const UModelIndex &index, const UINT8 action)
{
    if (!index.isValid())
        return;

    TreeItem *item = static_cast<TreeItem*>(index.internalPointer());
    item->setAction(action);
    emit dataChanged(index, index);
}

UByteArray TreeModel::parsingData(const UModelIndex &index) const
{
    if (!index.isValid())
        return UByteArray();

    TreeItem *item = static_cast<TreeItem*>(index.internalPointer());
    return item->parsingData();
}

bool TreeModel::hasEmptyParsingData(const UModelIndex &index) const
{
    if (!index.isValid())
        return true;

    TreeItem *item = static_cast<TreeItem*>(index.internalPointer());
    return item->hasEmptyParsingData();
}

void TreeModel::setParsingData(const UModelIndex &index, const UByteArray &data)
{
    if (!index.isValid())
        return;

    TreeItem *item = static_cast<TreeItem*>(index.internalPointer());
    item->setParsingData(data);
    emit dataChanged(this->index(0, 0), index);
}

UModelIndex TreeModel::addItem(const UINT32 offset, const UINT8 type, const UINT8 subtype,
    const UString & name, const UString & text, const UString & info,
    const UByteArray & header, const UByteArray & body, const UByteArray & tail,
    const ItemFixedState fixed,
    const UModelIndex & parent, const UINT8 mode)
{
    TreeItem *item = 0;
    TreeItem *parentItem = 0;
    int parentColumn = 0;

    if (!parent.isValid())
        parentItem = rootItem;
    else
    {
        if (mode == CREATE_MODE_BEFORE || mode == CREATE_MODE_AFTER) {
            item = static_cast<TreeItem*>(parent.internalPointer());
            parentItem = item->parent();
            parentColumn = parent.parent().column();
        }
        else {
            parentItem = static_cast<TreeItem*>(parent.internalPointer());
            parentColumn = parent.column();
        }
    }

    TreeItem *newItem = new TreeItem(offset, type, subtype, name, text, info, header, body, tail, Movable, this->compressed(parent), parentItem);
     
    if (mode == CREATE_MODE_APPEND) {
        emit layoutAboutToBeChanged();
        parentItem->appendChild(newItem);
    }
    else if (mode == CREATE_MODE_PREPEND) {
        emit layoutAboutToBeChanged();
        parentItem->prependChild(newItem);
    }
    else if (mode == CREATE_MODE_BEFORE) {
        emit layoutAboutToBeChanged();
        parentItem->insertChildBefore(item, newItem);
    }
    else if (mode == CREATE_MODE_AFTER) {
        emit layoutAboutToBeChanged();
        parentItem->insertChildAfter(item, newItem);
    }
    else {
        delete newItem;
        return UModelIndex();
    }

    emit layoutChanged();

    UModelIndex created = createIndex(newItem->row(), parentColumn, newItem);
    setFixed(created, (bool)fixed); // Non-trivial logic requires additional call
    return created;
}

UModelIndex TreeModel::findParentOfType(const UModelIndex& index, UINT8 type) const
{
    if (!index.isValid() || !index.parent().isValid())
        return UModelIndex();

    TreeItem *item;
    UModelIndex parent = index.parent();

    for (item = static_cast<TreeItem*>(parent.internalPointer());
        item != NULL && item != rootItem && item->type() != type;
        item = static_cast<TreeItem*>(parent.internalPointer()))
            parent = parent.parent();
    if (item != NULL && item != rootItem)
        return parent;

    return UModelIndex();
}

UModelIndex TreeModel::findLastParentOfType(const UModelIndex& index, UINT8 type) const
{
    if (!index.isValid())
        return UModelIndex();

    UModelIndex lastParentOfType = findParentOfType(index, type);

    if (!lastParentOfType.isValid())
        return UModelIndex();

    UModelIndex currentParentOfType = findParentOfType(lastParentOfType, type);
    while (currentParentOfType.isValid()) {
        lastParentOfType = currentParentOfType;
        currentParentOfType = findParentOfType(lastParentOfType, type);
    }

    return lastParentOfType;
}

UModelIndex TreeModel::findByBase(UINT32 base) const
{
    UModelIndex parentIndex = index(0,0);

goDeeper:
    int n = rowCount(parentIndex);
    for (int i = 0; i < n; i++) {
        UModelIndex currentIndex = parentIndex.child(i, 0);
        UINT32 currentBase = this->base(currentIndex);
        UINT32 fullSize = header(currentIndex).size() + body(currentIndex).size() + tail(currentIndex).size();
        if ((compressed(currentIndex) == false || (compressed(currentIndex) == true && compressed(currentIndex.parent()) == false)) // Base is meaningful only for true uncompressed items
            && currentBase <= base && base < currentBase + fullSize) { // Base must be in range [currentBase, currentBase + fullSize)
            // Found a better candidate
            parentIndex = currentIndex;
            goto goDeeper;
        }
    }

    return (parentIndex == index(0, 0) ? UModelIndex() : parentIndex);
}

```

`efiXloader/3rd/uefitool/common/treemodel.h`:

```h
/* treemodel.h

Copyright (c) 2016, Nikolaj Schlej. All rights reserved.
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

*/

#ifndef TREEMODEL_H
#define TREEMODEL_H

enum ItemFixedState {
    Movable,
    Fixed
};

#if defined(QT_CORE_LIB)
// Use Qt classes
#include <QAbstractItemModel>
#include <QModelIndex>
#include <QVariant>
#include <QObject>
#if defined(QT_GUI_LIB)
#include <QBrush>
#endif

#include "ustring.h"
#include "ubytearray.h"
#include "basetypes.h"
#include "types.h"
#include "treeitem.h"

#define UModelIndex QModelIndex
#else
// Use own implementation 
#include "ustring.h"
#include "ubytearray.h"
#include "basetypes.h"
#include "types.h"
#include "treeitem.h"

class TreeModel;

class UModelIndex
{
    friend class TreeModel;

public:
    inline UModelIndex() : r(-1), c(-1), i(0), m(0) {}
    // compiler-generated copy/move ctors/assignment operators are fine!
    inline int row() const { return r; }
    inline int column() const { return c; }
    inline uint64_t internalId() const { return i; }
    inline void *internalPointer() const { return reinterpret_cast<void*>(i); }
    inline UModelIndex parent() const;
    inline UModelIndex child(int row, int column) const;
    inline CBString data(int role) const;
    inline const TreeModel *model() const { return m; }
    inline bool isValid() const { return (r >= 0) && (c >= 0) && (m != 0); }
    inline bool operator==(const UModelIndex &other) const { return (other.r == r) && (other.i == i) && (other.c == c) && (other.m == m); }
    inline bool operator!=(const UModelIndex &other) const { return !(*this == other); }
    inline bool operator<(const UModelIndex &other) const
    {
        return  r <  other.r
            || (r == other.r && (c <  other.c
            || (c == other.c && (i <  other.i
            || (i == other.i && m < other.m)))));
    }

private:
    inline UModelIndex(int arow, int acolumn, void *ptr, const TreeModel *amodel)
        : r(arow), c(acolumn), i(reinterpret_cast<uint64_t>(ptr)), m(amodel) {}
    inline UModelIndex(int arow, int acolumn, uint64_t id, const TreeModel *amodel)
        : r(arow), c(acolumn), i(id), m(amodel) {}
    int r, c;
    uint64_t i;
    const TreeModel *m;
};
#endif

#if defined(QT_CORE_LIB)
class TreeModel : public QAbstractItemModel
{
    Q_OBJECT
private:
    TreeItem *rootItem;
    bool markingEnabledFlag;

public:
    QVariant data(const UModelIndex &index, int role) const;
    Qt::ItemFlags flags(const UModelIndex &index) const;
    QVariant headerData(int section, Qt::Orientation orientation,
        int role = Qt::DisplayRole) const;
    TreeModel(QObject *parent = 0) : QAbstractItemModel(parent), markingEnabledFlag(true) {
        rootItem = new TreeItem(0, Types::Root, 0, UString(), UString(), UString(), UByteArray(), UByteArray(), UByteArray(), true, false);
    }

#else
#define emit

class TreeModel
{
private:
    TreeItem *rootItem;
    bool markingEnabledFlag;

    void dataChanged(const UModelIndex &, const UModelIndex &) {}
    void layoutAboutToBeChanged() {}
    void layoutChanged() {}

public:
    UString data(const UModelIndex &index, int role) const;
    UString headerData(int section, int orientation, int role = 0) const;

    TreeModel() : markingEnabledFlag(false) {
        rootItem = new TreeItem(0, Types::Root, 0, UString(), UString(), UString(), UByteArray(), UByteArray(), UByteArray(), TRUE, FALSE);
    }

    bool hasIndex(int row, int column, const UModelIndex &parent = UModelIndex()) const {
        if (row < 0 || column < 0)
            return false;
        return row < rowCount(parent) && column < columnCount(parent);
    }

    UModelIndex createIndex(int row, int column, void *data) const { return UModelIndex(row, column, data, this); }
#endif

    ~TreeModel() {
        delete rootItem;
    }

    bool markingEnabled() { return markingEnabledFlag; }
    void setMarkingEnabled(const bool enabled);

    UModelIndex index(int row, int column, const UModelIndex &parent = UModelIndex()) const;
    UModelIndex parent(const UModelIndex &index) const;
    int rowCount(const UModelIndex &parent = UModelIndex()) const;
    int columnCount(const UModelIndex &parent = UModelIndex()) const;

    UINT8 action(const UModelIndex &index) const;
    void setAction(const UModelIndex &index, const UINT8 action);

    UINT32 base(const UModelIndex &index) const;
    UINT32 offset(const UModelIndex &index) const;
    void setOffset(const UModelIndex &index, const UINT32 offset);

    UINT8 type(const UModelIndex &index) const;
    void setType(const UModelIndex &index, const UINT8 type);

    UINT8 subtype(const UModelIndex &index) const;
    void setSubtype(const UModelIndex &index, const UINT8 subtype);

    UString name(const UModelIndex &index) const;
    void setName(const UModelIndex &index, const UString &name);

    UString text(const UModelIndex &index) const;
    void setText(const UModelIndex &index, const UString &text);

    UString info(const UModelIndex &index) const;
    void setInfo(const UModelIndex &index, const UString &info);
    void addInfo(const UModelIndex &index, const UString &info, const bool append = TRUE);

    bool fixed(const UModelIndex &index) const;
    void setFixed(const UModelIndex &index, const bool fixed);

    bool compressed(const UModelIndex &index) const;
    void setCompressed(const UModelIndex &index, const bool compressed);

    UINT8 marking(const UModelIndex &index) const;
    void setMarking(const UModelIndex &index, const UINT8 marking);

    UByteArray header(const UModelIndex &index) const;
    bool hasEmptyHeader(const UModelIndex &index) const;

    UByteArray body(const UModelIndex &index) const;
    bool hasEmptyBody(const UModelIndex &index) const;

    UByteArray tail(const UModelIndex &index) const;
    bool hasEmptyTail(const UModelIndex &index) const;

    UByteArray parsingData(const UModelIndex &index) const;
    bool hasEmptyParsingData(const UModelIndex &index) const;
    void setParsingData(const UModelIndex &index, const UByteArray &pdata);

    UModelIndex addItem(const UINT32 offset, const UINT8 type, const UINT8 subtype,
        const UString & name, const UString & text, const UString & info,
        const UByteArray & header, const UByteArray & body, const UByteArray & tail,
        const ItemFixedState fixed,
        const UModelIndex & parent = UModelIndex(), const UINT8 mode = CREATE_MODE_APPEND);

    UModelIndex findParentOfType(const UModelIndex & index, UINT8 type) const;
    UModelIndex findLastParentOfType(const UModelIndex & index, UINT8 type) const;
    UModelIndex findByBase(UINT32 base) const;
};

#if defined(QT_CORE_LIB)
// Nothing required here
#else
inline UModelIndex UModelIndex::parent() const { return m ? m->parent(*this) : UModelIndex(); }
inline UModelIndex UModelIndex::child(int row, int column) const { return m ? m->index(row, column, *this) : UModelIndex(); }
inline UString UModelIndex::data(int role) const { return m ? m->data(*this, role) : UString(); }
#endif

#endif // TREEMODEL_H

```

`efiXloader/3rd/uefitool/common/types.cpp`:

```cpp
/* types.cpp

Copyright (c) 2016, Nikolaj Schlej. All rights reserved.
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHWARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
*/

#include "ustring.h"
#include "types.h"
#include "ffs.h"
#include "fit.h"

UString regionTypeToUString(const UINT8 type)
{
    switch (type) {
    case Subtypes::DescriptorRegion:  return UString("Descriptor");
    case Subtypes::BiosRegion:        return UString("BIOS");
    case Subtypes::MeRegion:          return UString("ME");
    case Subtypes::GbeRegion:         return UString("GbE");
    case Subtypes::PdrRegion:         return UString("PDR");
    case Subtypes::DevExp1Region:     return UString("DevExp1");
    case Subtypes::Bios2Region:       return UString("BIOS2");
    case Subtypes::MicrocodeRegion:   return UString("Microcode");
    case Subtypes::EcRegion:          return UString("EC");
    case Subtypes::DevExp2Region:     return UString("DevExp2");
    case Subtypes::IeRegion:          return UString("IE");
    case Subtypes::Tgbe1Region:       return UString("10GbE1");
    case Subtypes::Tgbe2Region:       return UString("10GbE2");
    case Subtypes::Reserved1Region:   return UString("Reserved1");
    case Subtypes::Reserved2Region:   return UString("Reserved2");
    case Subtypes::PttRegion:         return UString("PTT");
    };

    return  UString("Unknown");
}

UString itemTypeToUString(const UINT8 type)
{
    switch (type) {
    case Types::Root:           return UString("Root");
    case Types::Image:          return UString("Image");
    case Types::Capsule:        return UString("Capsule");
    case Types::Region:         return UString("Region");
    case Types::Volume:         return UString("Volume");
    case Types::Padding:        return UString("Padding");
    case Types::File:           return UString("File");
    case Types::Section:        return UString("Section");
    case Types::FreeSpace:      return UString("Free space");
    case Types::VssStore:       return UString("VSS store");
    case Types::Vss2Store:      return UString("VSS2 store");
    case Types::FtwStore:       return UString("FTW store");
    case Types::FdcStore:       return UString("FDC store");
    case Types::FsysStore:      return UString("Fsys store");
    case Types::EvsaStore:      return UString("EVSA store");
    case Types::CmdbStore:      return UString("CMDB store");
    case Types::FlashMapStore:  return UString("FlashMap store");
    case Types::NvarEntry:      return UString("NVAR entry");
    case Types::VssEntry:       return UString("VSS entry");
    case Types::FsysEntry:      return UString("Fsys entry");
    case Types::EvsaEntry:      return UString("EVSA entry");
    case Types::FlashMapEntry:  return UString("FlashMap entry");
    case Types::Microcode:      return UString("Microcode");
    case Types::SlicData:       return UString("SLIC data");
    // ME-specific
    case Types::FptStore:       return UString("FPT store");
    case Types::FptEntry:       return UString("FPT entry");
    case Types::IfwiHeader:     return UString("IFWI header");
    case Types::IfwiPartition:  return UString("IFWI partition");
    case Types::FptPartition:   return UString("FPT partition");
    case Types::BpdtStore:      return UString("BPDT store");
    case Types::BpdtEntry:      return UString("BPDT entry");
    case Types::BpdtPartition:  return UString("BPDT partition");
    case Types::CpdStore:       return UString("CPD store");
    case Types::CpdEntry:       return UString("CPD entry");
    case Types::CpdPartition:   return UString("CPD partition");
    case Types::CpdExtension:   return UString("CPD extension");
    case Types::CpdSpiEntry:    return UString("CPD SPI entry");
    }

    return  UString("Unknown");
}

UString itemSubtypeToUString(const UINT8 type, const UINT8 subtype)
{
    switch (type) {
    case Types::Image:
        if (subtype == Subtypes::IntelImage)               return UString("Intel");
        if (subtype == Subtypes::UefiImage)                return UString("UEFI");
        break;
    case Types::Padding:
        if (subtype == Subtypes::ZeroPadding)              return UString("Empty (0x00)");
        if (subtype == Subtypes::OnePadding)               return UString("Empty (0xFF)");
        if (subtype == Subtypes::DataPadding)              return UString("Non-empty");
        break;
    case Types::Volume: 
        if (subtype == Subtypes::UnknownVolume)            return UString("Unknown");
        if (subtype == Subtypes::Ffs2Volume)               return UString("FFSv2");
        if (subtype == Subtypes::Ffs3Volume)               return UString("FFSv3");
        if (subtype == Subtypes::NvramVolume)              return UString("NVRAM");
        if (subtype == Subtypes::MicrocodeVolume)          return UString("Microcode");
        break;
    case Types::Capsule: 
        if (subtype == Subtypes::AptioSignedCapsule)       return UString("Aptio signed");
        if (subtype == Subtypes::AptioUnsignedCapsule)     return UString("Aptio unsigned");
        if (subtype == Subtypes::UefiCapsule)              return UString("UEFI 2.0");
        if (subtype == Subtypes::ToshibaCapsule)           return UString("Toshiba");
        break;
    case Types::Region:                                    return regionTypeToUString(subtype);
    case Types::File:                                      return fileTypeToUString(subtype);
    case Types::Section:                                   return sectionTypeToUString(subtype);
    case Types::NvarEntry:
        if (subtype == Subtypes::InvalidNvarEntry)         return UString("Invalid");
        if (subtype == Subtypes::InvalidLinkNvarEntry)     return UString("Invalid link");
        if (subtype == Subtypes::LinkNvarEntry)            return UString("Link");
        if (subtype == Subtypes::DataNvarEntry)            return UString("Data");
        if (subtype == Subtypes::FullNvarEntry)            return UString("Full");
        break;
    case Types::VssEntry:
        if (subtype == Subtypes::InvalidVssEntry)          return UString("Invalid");
        if (subtype == Subtypes::StandardVssEntry)         return UString("Standard");
        if (subtype == Subtypes::AppleVssEntry)            return UString("Apple");
        if (subtype == Subtypes::AuthVssEntry)             return UString("Auth");
        if (subtype == Subtypes::IntelVssEntry)            return UString("Intel");
        break;
    case Types::FsysEntry:
        if (subtype == Subtypes::InvalidFsysEntry)         return UString("Invalid");
        if (subtype == Subtypes::NormalFsysEntry)          return UString("Normal");
        break;
    case Types::EvsaEntry:
        if (subtype == Subtypes::InvalidEvsaEntry)         return UString("Invalid");
        if (subtype == Subtypes::UnknownEvsaEntry)         return UString("Unknown");
        if (subtype == Subtypes::GuidEvsaEntry)            return UString("GUID");
        if (subtype == Subtypes::NameEvsaEntry)            return UString("Name");
        if (subtype == Subtypes::DataEvsaEntry)            return UString("Data");
        break;
    case Types::FlashMapEntry:
        if (subtype == Subtypes::VolumeFlashMapEntry)      return UString("Volume");
        if (subtype == Subtypes::DataFlashMapEntry)        return UString("Data");
        break;
    case Types::Microcode:
        if (subtype == Subtypes::IntelMicrocode)           return UString("Intel");
        if (subtype == Subtypes::AmdMicrocode)             return UString("AMD");
        break;
	// ME-specific
    case Types::FptEntry:
        if (subtype == Subtypes::ValidFptEntry)            return UString("Valid");
        if (subtype == Subtypes::InvalidFptEntry)          return UString("Invalid");
        break;
    case Types::FptPartition:
        if (subtype == Subtypes::CodeFptPartition)         return UString("Code");
        if (subtype == Subtypes::DataFptPartition)         return UString("Data");
        if (subtype == Subtypes::GlutFptPartition)         return UString("GLUT");
        break;
    case Types::IfwiPartition:
        if (subtype == Subtypes::BootIfwiPartition)         return UString("Boot");
        if (subtype == Subtypes::DataIfwiPartition)         return UString("Data");
        break;
    case Types::CpdPartition:
        if (subtype == Subtypes::ManifestCpdPartition)         return UString("Manifest");
        if (subtype == Subtypes::MetadataCpdPartition)         return UString("Metadata");
        if (subtype == Subtypes::KeyCpdPartition)              return UString("Key");
        if (subtype == Subtypes::CodeCpdPartition)             return UString("Code");
        break;
    }

    return UString();
}

UString compressionTypeToUString(const UINT8 algorithm)
{
    switch (algorithm) {
    case COMPRESSION_ALGORITHM_NONE:                    return UString("None");
    case COMPRESSION_ALGORITHM_EFI11:                   return UString("EFI 1.1");
    case COMPRESSION_ALGORITHM_TIANO:                   return UString("Tiano");
    case COMPRESSION_ALGORITHM_UNDECIDED:               return UString("Undecided Tiano/EFI 1.1");
    case COMPRESSION_ALGORITHM_LZMA:                    return UString("LZMA");
    case COMPRESSION_ALGORITHM_LZMA_INTEL_LEGACY:       return UString("Intel legacy LZMA");
    }

    return UString("Unknown");
}

UString actionTypeToUString(const UINT8 action)
{
    switch (action) {
    case Actions::NoAction:      return UString();
    case Actions::Create:        return UString("Create");
    case Actions::Insert:        return UString("Insert");
    case Actions::Replace:       return UString("Replace");
    case Actions::Remove:        return UString("Remove");
    case Actions::Rebuild:       return UString("Rebuild");
    case Actions::Rebase:        return UString("Rebase");
    }

    return UString("Unknown");
}

UString fitEntryTypeToUString(const UINT8 type)
{
    switch (type & 0x7F) {
    case FIT_TYPE_HEADER:           return UString("FIT Header");
    case FIT_TYPE_MICROCODE:        return UString("Microcode");
    case FIT_TYPE_BIOS_AC_MODULE:   return UString("BIOS ACM");
    case FIT_TYPE_BIOS_INIT_MODULE: return UString("BIOS Init");
    case FIT_TYPE_TPM_POLICY:       return UString("TPM Policy");
    case FIT_TYPE_BIOS_POLICY_DATA: return UString("BIOS Policy Data");
    case FIT_TYPE_TXT_CONF_POLICY:  return UString("TXT Configuration Policy");
    case FIT_TYPE_AC_KEY_MANIFEST:  return UString("BootGuard Key Manifest");
    case FIT_TYPE_AC_BOOT_POLICY:   return UString("BootGuard Boot Policy");
    case FIT_TYPE_EMPTY:            return UString("Empty");
    }

    return UString("Unknown");
}
```

`efiXloader/3rd/uefitool/common/types.h`:

```h
/* types.h

Copyright (c) 2016, Nikolaj Schlej. All rights reserved.
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

*/

#ifndef TYPES_H
#define TYPES_H

#include "basetypes.h"

// Actions
namespace Actions
{
    enum ActionTypes {
        NoAction = 50,
        Erase,
        Create,
        Insert,
        Replace,
        Remove,
        Rebuild,
        Rebase
    };
}

// Types
namespace Types {
    enum ItemTypes {
        Root = 60,
        Capsule,
        Image,
        Region,
        Padding,
        Volume,
        File,
        Section,
        FreeSpace,
        VssStore,
        Vss2Store,
        FtwStore,
        FdcStore,
        FsysStore,
        EvsaStore,
        FlashMapStore,
        CmdbStore,
        NvarEntry,
        VssEntry,
        FsysEntry,
        EvsaEntry,
        FlashMapEntry,
        Microcode,
        SlicData,
        // ME-specific
        IfwiHeader,
        IfwiPartition,
        FptStore,
        FptEntry,
        FptPartition,
        BpdtStore,
        BpdtEntry,
        BpdtPartition,
        CpdStore,
        CpdEntry,
        CpdPartition,
        CpdExtension,
        CpdSpiEntry
    };
}

namespace Subtypes {
    enum ImageSubtypes{
        IntelImage = 90,
        UefiImage
    };

    enum CapsuleSubtypes {
        AptioSignedCapsule = 100,
        AptioUnsignedCapsule,
        UefiCapsule,
        ToshibaCapsule
    };

    enum VolumeSubtypes {
        UnknownVolume = 110,
        Ffs2Volume,
        Ffs3Volume,
        NvramVolume,
        MicrocodeVolume
    };

    enum RegionSubtypes {
        DescriptorRegion = 0,
        BiosRegion,
        MeRegion,
        GbeRegion,
        PdrRegion,
        DevExp1Region,
        Bios2Region,
        MicrocodeRegion,
        EcRegion,
        DevExp2Region,
        IeRegion,
        Tgbe1Region,
        Tgbe2Region,
        Reserved1Region,
        Reserved2Region,
        PttRegion
    };

    enum PaddingSubtypes {
        ZeroPadding = 120,
        OnePadding,
        DataPadding
    };

    enum NvarEntrySubtypes {
        InvalidNvarEntry = 130,
        InvalidLinkNvarEntry,
        LinkNvarEntry,
        DataNvarEntry,
        FullNvarEntry
    };

    enum VssEntrySubtypes {
        InvalidVssEntry = 140,
        StandardVssEntry,
        AppleVssEntry,
        AuthVssEntry,
        IntelVssEntry
    };

    enum FsysEntrySubtypes {
        InvalidFsysEntry = 150,
        NormalFsysEntry
    };
    
    enum EvsaEntrySubtypes {
        InvalidEvsaEntry = 160,
        UnknownEvsaEntry,
        GuidEvsaEntry,
        NameEvsaEntry,
        DataEvsaEntry,
    };

    enum FlashMapEntrySubtypes {
        VolumeFlashMapEntry = 170,
        DataFlashMapEntry
    };

    enum MicrocodeSubtypes {
        IntelMicrocode = 180,
        AmdMicrocode
    };

    enum SlicDataSubtypes {
        PubkeySlicData = 190,
        MarkerSlicData
    };

    // ME-specific
    enum IfwiPartitionSubtypes {
        DataIfwiPartition = 200,
        BootIfwiPartition
    };

    enum FptEntrySubtypes {
        ValidFptEntry = 210,
        InvalidFptEntry
    };

    enum FptPartitionSubtypes {
        CodeFptPartition = 220,
        DataFptPartition,
        GlutFptPartition
    };
	
    enum CpdPartitionSubtypes {
        ManifestCpdPartition = 230,
        MetadataCpdPartition,
        KeyCpdPartition,
        CodeCpdPartition
    };
}

// *ToUString conversion routines
extern UString actionTypeToUString(const UINT8 action);
extern UString itemTypeToUString(const UINT8 type);
extern UString itemSubtypeToUString(const UINT8 type, const UINT8 subtype);
extern UString compressionTypeToUString(const UINT8 algorithm);
extern UString regionTypeToUString(const UINT8 type);
extern UString fitEntryTypeToUString(const UINT8 type);

#endif // TYPES_H

```

`efiXloader/3rd/uefitool/common/ubytearray.h`:

```h
/* ubytearray.h

Copyright (c) 2016, Nikolaj Schlej. All rights reserved.
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
*/

#ifndef UBYTEARRAY_H
#define UBYTEARRAY_H

#if defined(QT_CORE_LIB)
// Use Qt class, if Qt is available
#include <QByteArray>
#define UByteArray QByteArray
#else
// Use own implementation
#include <stdint.h>
#include <string>
#include <vector>
#include <algorithm>

class UByteArray
{
public:
    UByteArray() : d() {}
    UByteArray(const UByteArray & ba) : d(ba.d) {}
    UByteArray(const std::basic_string<char> & bs) : d(bs) {}
    UByteArray(const std::vector<char> & bc) : d(bc.data(), bc.size()) {}
    UByteArray(const char* bytes, int32_t size) : d(bytes, size) {}
    UByteArray(const size_t n, char c) : d(n, c) {}
    ~UByteArray() {}

    bool isEmpty() const { return d.length() == 0; }
       
    char* data() { return d.length() == 0 ? NULL : &(d.at(0)); /* Feels dirty, but works for all basic_string implementations I know, is fully OK in C++11 and later*/ }
    const char* data() const { return d.c_str(); }
    const char* constData() const { return d.c_str(); }
    void clear() { d.clear(); }

    UByteArray toUpper() { std::basic_string<char> s = d; std::transform(s.begin(), s.end(), s.begin(), ::toupper); return UByteArray(s); }
    uint32_t toUInt(bool* ok = NULL, const uint8_t base = 10) { return (uint32_t)strtoul(d.c_str(), NULL, base); }

    int32_t size() const { return d.size();  }
    int32_t count(char ch) const { return std::count(d.begin(), d.end(), ch); }
    char at(uint32_t i) const { return d.at(i); }
    char operator[](uint32_t i) const { return d[i]; }
    char& operator[](uint32_t i) { return d[i]; }

    bool startsWith(const UByteArray & ba) const { return 0 == d.find(ba.d, 0); }
    int indexOf(const UByteArray & ba, int from = 0) const { return d.find(ba.d, from); }
    int lastIndexOf(const UByteArray & ba, int from = 0) const {
        size_t old_index = d.npos;
        size_t index = d.find(ba.d, from);
        while (index != d.npos) {
            old_index = index;
            index = d.find(ba.d, index + 1);
        }
        return old_index;
    }

    UByteArray left(int32_t len) const { return d.substr(0, len); }
    UByteArray right(int32_t len) const { return d.substr(d.size() - 1 - len, len); }
    UByteArray mid(int32_t pos, int32_t len = -1) const { return d.substr(pos, len); }

    UByteArray & operator=(const UByteArray & ba) { d = ba.d; return *this; }
    UByteArray & operator+=(const UByteArray & ba) { d += ba.d; return *this; }
    bool operator== (const UByteArray & ba) const { return d == ba.d; }
    bool operator!= (const UByteArray & ba) const { return d != ba.d; }
    inline void swap(UByteArray &other) { std::swap(d, other.d); }
    UByteArray toHex() {
        std::basic_string<char> hex(size() * 2, '\x00');
        for (int32_t i = 0; i < size(); i++) {
            uint8_t low  = d[i] & 0x0F;
            uint8_t high = (d[i] & 0xF0) >> 4;
            low += (low < 10 ? '0' : 'a');
            high += (high < 10 ? '0' : 'a');
            hex[2*i] = low;
            hex[2*i + 1] = high;
        }
        std::reverse(hex.begin(), hex.end());
        return UByteArray(hex);
    }

    std::basic_string<char>::iterator begin() {return d.begin();}
    std::basic_string<char>::iterator end() {return d.end();}
    std::basic_string<char>::const_iterator begin() const {return d.begin();}
    std::basic_string<char>::const_iterator end() const {return d.end();}
    
private:
    std::basic_string<char> d;
};

inline const UByteArray operator+(const UByteArray &a1, const UByteArray &a2)
{
    return UByteArray(a1) += a2;
}

#endif // QT_CORE_LIB
#endif // UBYTEARRAY_H


```

`efiXloader/3rd/uefitool/common/ustring.cpp`:

```cpp
/* ustring.cpp

Copyright (c) 2016, Nikolaj Schlej. All rights reserved.
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
*/

#include "ustring.h"
#include <stdarg.h>

#if defined(QT_CORE_LIB)
UString usprintf(const char* fmt, ...) 
{
    UString msg;
    va_list vl;
    va_start(vl, fmt);
    msg.vsprintf(fmt, vl);
    va_end(vl);
    return msg;
};

UString urepeated(char c, int len)
{
    return UString(len, c);
}
#else
/* Give WATCOM C/C++, MSVC some latitude for their non-support of vsnprintf */
#if defined(__WATCOMC__) || defined(_MSC_VER)
#define exvsnprintf(r,b,n,f,a) {r = _vsnprintf (b,n,f,a);}
#else
#ifdef BSTRLIB_NOVSNP
/* This is just a hack.  If you are using a system without a vsnprintf, it is
not recommended that bformat be used at all. */
#define exvsnprintf(r,b,n,f,a) {vsprintf (b,f,a); r = -1;}
#define START_VSNBUFF (256)
#else

#if defined (__GNUC__) && !defined (__PPC__) && !defined(__WIN32__)
/* Something is making gcc complain about this prototype not being here, so
I've just gone ahead and put it in. */
extern "C" {
    extern int vsnprintf(char *buf, size_t count, const char *format, va_list arg);
}
#endif

#define exvsnprintf(r,b,n,f,a) {r = vsnprintf (b,n,f,a);}
#endif
#endif

#ifndef START_VSNBUFF
#define START_VSNBUFF (16)
#endif

UString usprintf(const char* fmt, ...)
{
    UString msg;
    bstring b;
    va_list arglist;
    int r, n;

    if (fmt == NULL) {
        msg = "<NULL>";
    }
    else {

        if ((b = bfromcstr("")) == NULL) {
            msg = "<NULL>";
        }
        else {
            if ((n = (int)(2 * (strlen)(fmt))) < START_VSNBUFF) n = START_VSNBUFF;
            for (;;) {
                if (BSTR_OK != balloc(b, n + 2)) {
                    b = bformat("<NULL>");
                    break;
                }

                va_start(arglist, fmt);
                exvsnprintf(r, (char *)b->data, n + 1, fmt, arglist);
                va_end(arglist);

                b->data[n] = '\0';
                b->slen = (int)(strlen)((char *)b->data);

                if (b->slen < n) break;
                if (r > n) n = r; else n += n;
            }
            msg = *b;
            bdestroy(b);
        }
    }

    return msg;
}

UString urepeated(char c, int len)
{
    return UString(c, len);
}
#endif

```

`efiXloader/3rd/uefitool/common/ustring.h`:

```h
/* ustring.h

Copyright (c) 2016, Nikolaj Schlej. All rights reserved.
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
*/

#ifndef USTRING_H
#define USTRING_H

#if defined (QT_CORE_LIB)
// Use Qt class, if Qt is available
#include <QString>
#define UString QString
#define findreplace replace
#else
// Use Bstrlib
#define BSTRLIB_DOESNT_THROW_EXCEPTIONS
#include "bstrlib/bstrwrap.h"
#define UString CBString
#endif // QT_CORE_LIB

UString usprintf(const char* fmt, ...);
UString urepeated(char c, int len);

#endif // USTRING_H

```

`efiXloader/3rd/uefitool/common/utility.cpp`:

```cpp
/* utility.cpp

Copyright (c) 2016, Nikolaj Schlej. All rights reserved.
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

*/

#include <cstdio>
#include <cctype>
#include <cstring>

#include "treemodel.h"
#include "utility.h"
#include "ffs.h"
#include "Tiano/EfiTianoCompress.h"
#include "Tiano/EfiTianoDecompress.h"
#include "LZMA/LzmaCompress.h"
#include "LZMA/LzmaDecompress.h"

// Returns unique name string based for tree item
UString uniqueItemName(const UModelIndex & index)
{
    // Sanity check
    if (!index.isValid())
        return UString("Invalid_index");

    // Get model from index
    const TreeModel* model = (const TreeModel*)index.model();
    
    // Construct the name
    UString itemName = model->name(index);
    UString itemText = model->text(index);

    // Default name
    UString name = itemName;
    switch (model->type(index)) {
    case Types::NvarEntry:
    case Types::VssEntry:
    case Types::FsysEntry:
    case Types::EvsaEntry:
    case Types::FlashMapEntry:
    case Types::File:
        name = itemText.isEmpty() ? itemName : itemName + '_' + itemText;
        break;
    case Types::Section: {
        // Get parent file name
        UModelIndex fileIndex = model->findParentOfType(index, Types::File);
        UString fileText = model->text(fileIndex);
        name = fileText.isEmpty() ? model->name(fileIndex) : model->name(fileIndex) + '_' + fileText;

        // Special case of GUIDed sections
        if (model->subtype(index) == EFI_SECTION_GUID_DEFINED || model->subtype(index) == EFI_SECTION_FREEFORM_SUBTYPE_GUID) {
            name = model->name(index) +'_' + name;
        }
    } break;
    }

    // Populate subtypeString
    UString subtypeString = itemSubtypeToUString(model->type(index), model->subtype(index));

    // Create final name
    name = itemTypeToUString(model->type(index))
        + (subtypeString.length() ? ('_' + subtypeString) : UString())
        + '_' + name;

    // Replace some symbols with underscores for compatibility
    const char table[] = {
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, // ASCII control characters, banned in Windows, hard to work with in *nix
        '/', // Banned in *nix and Windows
        '<', '>', ':', '\"', '\\', '|', '?', '*', // Banned in Windows
        ' ' // Provides better readability
    };
    int nameLength = name.length(); // Note: Qt uses int for whatever reason.
    for (int i = 0; i < nameLength; i++) {
        for (size_t j = 0; j < sizeof(table); j++) {
            if (name[i] == table[j]) {
                name[i] = '_';
            }
        }
    }

    return name;
}

// Returns text representation of error code
UString errorCodeToUString(USTATUS errorCode)
{
    switch (errorCode) {
    case U_SUCCESS:                         return UString("Success");
    case U_NOT_IMPLEMENTED:                 return UString("Not implemented");
    case U_INVALID_PARAMETER:               return UString("Function called with invalid parameter");
    case U_BUFFER_TOO_SMALL:                return UString("Buffer too small");
    case U_OUT_OF_RESOURCES:                return UString("Out of resources");
    case U_OUT_OF_MEMORY:                   return UString("Out of memory");
    case U_FILE_OPEN:                       return UString("File can't be opened");
    case U_FILE_READ:                       return UString("File can't be read");
    case U_FILE_WRITE:                      return UString("File can't be written");
    case U_ITEM_NOT_FOUND:                  return UString("Item not found");
    case U_UNKNOWN_ITEM_TYPE:               return UString("Unknown item type");
    case U_INVALID_FLASH_DESCRIPTOR:        return UString("Invalid flash descriptor");
    case U_INVALID_REGION:                  return UString("Invalid region");
    case U_EMPTY_REGION:                    return UString("Empty region");
    case U_BIOS_REGION_NOT_FOUND:           return UString("BIOS region not found");
    case U_VOLUMES_NOT_FOUND:               return UString("UEFI volumes not found");
    case U_INVALID_VOLUME:                  return UString("Invalid UEFI volume");
    case U_VOLUME_REVISION_NOT_SUPPORTED:   return UString("Volume revision not supported");
    //case U_VOLUME_GROW_FAILED:              return UString("Volume grow failed");
    case U_UNKNOWN_FFS:                     return UString("Unknown file system");
    case U_INVALID_FILE:                    return UString("Invalid file");
    case U_INVALID_SECTION:                 return UString("Invalid section");
    case U_UNKNOWN_SECTION:                 return UString("Unknown section");
    case U_STANDARD_COMPRESSION_FAILED:     return UString("Standard compression failed");
    case U_CUSTOMIZED_COMPRESSION_FAILED:   return UString("Customized compression failed");
    case U_STANDARD_DECOMPRESSION_FAILED:   return UString("Standard decompression failed");
    case U_CUSTOMIZED_DECOMPRESSION_FAILED: return UString("Customized decompression failed");
    case U_UNKNOWN_COMPRESSION_TYPE:        return UString("Unknown compression type");
    case U_UNKNOWN_EXTRACT_MODE:            return UString("Unknown extract mode");
    case U_UNKNOWN_REPLACE_MODE:            return UString("Unknown replace mode");
    //case U_UNKNOWN_INSERT_MODE:             return UString("Unknown insert mode");
    case U_UNKNOWN_IMAGE_TYPE:              return UString("Unknown executable image type");
    case U_UNKNOWN_PE_OPTIONAL_HEADER_TYPE: return UString("Unknown PE optional header type");
    case U_UNKNOWN_RELOCATION_TYPE:         return UString("Unknown relocation type");
    //case U_GENERIC_CALL_NOT_SUPPORTED:      return UString("Generic call not supported");
    //case U_VOLUME_BASE_NOT_FOUND:           return UString("Volume base address not found");
    //case U_PEI_CORE_ENTRY_POINT_NOT_FOUND:  return UString("PEI core entry point not found");
    case U_COMPLEX_BLOCK_MAP:               return UString("Block map structure too complex for correct analysis");
    case U_DIR_ALREADY_EXIST:               return UString("Directory already exists");
    case U_DIR_CREATE:                      return UString("Directory can't be created");
    case U_DIR_CHANGE:                      return UString("Change directory failed");
    //case U_UNKNOWN_PATCH_TYPE:              return UString("Unknown patch type");
    //case U_PATCH_OFFSET_OUT_OF_BOUNDS:      return UString("Patch offset out of bounds");
    //case U_INVALID_SYMBOL:                  return UString("Invalid symbol");
    //case U_NOTHING_TO_PATCH:                return UString("Nothing to patch");
    case U_DEPEX_PARSE_FAILED:              return UString("Dependency expression parsing failed");
    case U_TRUNCATED_IMAGE:                 return UString("Image is truncated");
    case U_INVALID_CAPSULE:                 return UString("Invalid capsule");
    case U_STORES_NOT_FOUND:                return UString("Stores not found");
    case U_INVALID_STORE_SIZE:              return UString("Invalid store size");
    default:                                return usprintf("Unknown error %02X", errorCode);
    }
}

// Compression routines
USTATUS decompress(const UByteArray & compressedData, const UINT8 compressionType, UINT8 & algorithm, UINT32 & dictionarySize, UByteArray & decompressedData, UByteArray & efiDecompressedData)
{
    const UINT8* data;
    UINT32 dataSize;
    UINT8* decompressed;
    UINT8* efiDecompressed;
    UINT32 decompressedSize = 0;
    UINT8* scratch;
    UINT32 scratchSize = 0;
    const EFI_TIANO_HEADER* header;

    // For all but LZMA dictionary size is 0
    dictionarySize = 0;

    switch (compressionType)
    {
    case EFI_NOT_COMPRESSED: {
        decompressedData = compressedData;
        algorithm = COMPRESSION_ALGORITHM_NONE;
        return U_SUCCESS;
        }
    case EFI_STANDARD_COMPRESSION: {
        // Set default algorithm to unknown
        algorithm = COMPRESSION_ALGORITHM_UNKNOWN;

        // Get buffer sizes
        data = (UINT8*)compressedData.data();
        dataSize = compressedData.size();

        // Check header to be valid
        header = (const EFI_TIANO_HEADER*)data;
        if (header->CompSize + sizeof(EFI_TIANO_HEADER) != dataSize)
            return U_STANDARD_DECOMPRESSION_FAILED;

        // Get info function is the same for both algorithms
        if (U_SUCCESS != EfiTianoGetInfo(data, dataSize, &decompressedSize, &scratchSize))
            return U_STANDARD_DECOMPRESSION_FAILED;

        // Allocate memory
        decompressed = (UINT8*)malloc(decompressedSize);
        efiDecompressed = (UINT8*)malloc(decompressedSize);
        scratch = (UINT8*)malloc(scratchSize);
        if (!decompressed || !efiDecompressed || !scratch) {
            free(decompressed);
            free(efiDecompressed);
            free(scratch);
            return U_STANDARD_DECOMPRESSION_FAILED;
        }

        // Decompress section data using both algorithms
        USTATUS result = U_SUCCESS;
        // Try Tiano
        USTATUS TianoResult = TianoDecompress(data, dataSize, decompressed, decompressedSize, scratch, scratchSize);
        // Try EFI 1.1
        USTATUS EfiResult = EfiDecompress(data, dataSize, efiDecompressed, decompressedSize, scratch, scratchSize);

        if (decompressedSize > INT32_MAX) {
            result = U_STANDARD_DECOMPRESSION_FAILED;
        }
        else if (EfiResult == U_SUCCESS && TianoResult == U_SUCCESS) { // Both decompressions are OK
            algorithm = COMPRESSION_ALGORITHM_UNDECIDED;
            decompressedData = UByteArray((const char*)decompressed, (int)decompressedSize);
            efiDecompressedData = UByteArray((const char*)efiDecompressed, (int)decompressedSize);
        }
        else if (TianoResult == U_SUCCESS) { // Only Tiano is OK
            algorithm = COMPRESSION_ALGORITHM_TIANO;
            decompressedData = UByteArray((const char*)decompressed, (int)decompressedSize);
        }
        else if (EfiResult == U_SUCCESS) { // Only EFI 1.1 is OK
            algorithm = COMPRESSION_ALGORITHM_EFI11;
            decompressedData = UByteArray((const char*)efiDecompressed, (int)decompressedSize);
        }
        else { // Both decompressions failed
            result = U_STANDARD_DECOMPRESSION_FAILED;
        }

        free(decompressed);
        free(efiDecompressed);
        free(scratch);
        return result;
        }
    case EFI_CUSTOMIZED_COMPRESSION: {
        // Set default algorithm to unknown
        algorithm = COMPRESSION_ALGORITHM_UNKNOWN;

        // Get buffer sizes
        data = (const UINT8*)compressedData.constData();
        dataSize = compressedData.size();

        // Get info as normal LZMA section
        if (U_SUCCESS != LzmaGetInfo(data, dataSize, &decompressedSize)) {
            // Get info as Intel legacy LZMA section
            data += sizeof(UINT32);
            if (U_SUCCESS != LzmaGetInfo(data, dataSize, &decompressedSize)) {
                return U_CUSTOMIZED_DECOMPRESSION_FAILED;
            }
            else {
                algorithm = COMPRESSION_ALGORITHM_LZMA_INTEL_LEGACY;
            }
        }
        else {
            algorithm = COMPRESSION_ALGORITHM_LZMA;
        }

        // Allocate memory
        decompressed = (UINT8*)malloc(decompressedSize);
        if (!decompressed) {
            return U_OUT_OF_MEMORY;
        }

        // Decompress section data
        if (U_SUCCESS != LzmaDecompress(data, dataSize, decompressed)) {
            free(decompressed);
            return U_CUSTOMIZED_DECOMPRESSION_FAILED;
        }

        if (decompressedSize > INT32_MAX) {
            free(decompressed);
            return U_CUSTOMIZED_DECOMPRESSION_FAILED;
        }

        dictionarySize = readUnaligned((UINT32*)(data + 1)); // LZMA dictionary size is stored in bytes 1-4 of LZMA properties header
        decompressedData = UByteArray((const char*)decompressed, (int)decompressedSize);
        free(decompressed);
        return U_SUCCESS;
        }
    case EFI_CUSTOMIZED_COMPRESSION_LZMAF86: {
        // Set default algorithm to unknown
        algorithm = COMPRESSION_ALGORITHM_UNKNOWN;

        // Get buffer sizes
        data = (const UINT8*)compressedData.constData();
        dataSize = compressedData.size();

        // Get info as normal LZMA section
        if (U_SUCCESS != LzmaGetInfo(data, dataSize, &decompressedSize)) {
            return U_CUSTOMIZED_DECOMPRESSION_FAILED;
        }
        algorithm = COMPRESSION_ALGORITHM_LZMAF86;

        // Allocate memory
        decompressed = (UINT8*)malloc(decompressedSize);
        if (!decompressed) {
            return U_OUT_OF_MEMORY;
        }

        // Decompress section data
        if (U_SUCCESS != LzmaDecompress(data, dataSize, decompressed)) {
            free(decompressed);
            return U_CUSTOMIZED_DECOMPRESSION_FAILED;
        }

        if (decompressedSize > INT32_MAX) {
            free(decompressed);
            return U_CUSTOMIZED_DECOMPRESSION_FAILED;
        }

        // After LZMA decompression, the data need to be converted to the raw data.
        UINT32 state = 0;
        const UINT8 x86LookAhead = 4;
        if (decompressedSize != x86LookAhead + x86_Convert(decompressed, decompressedSize, 0, &state, 0)) {
            free(decompressed);
            return U_CUSTOMIZED_DECOMPRESSION_FAILED;
        }

        dictionarySize = readUnaligned((UINT32*)(data + 1)); // LZMA dictionary size is stored in bytes 1-4 of LZMA properties header
        decompressedData = UByteArray((const char*)decompressed, (int)decompressedSize);
        free(decompressed);
        return U_SUCCESS;
        }
    default: {
        algorithm = COMPRESSION_ALGORITHM_UNKNOWN;
        return U_UNKNOWN_COMPRESSION_TYPE;
        }
    }
}



// 8bit sum calculation routine
UINT8 calculateSum8(const UINT8* buffer, UINT32 bufferSize)
{
    if (!buffer)
        return 0;

    UINT8 counter = 0;

    while (bufferSize--)
        counter += buffer[bufferSize];

    return counter;
}

// 8bit checksum calculation routine
UINT8 calculateChecksum8(const UINT8* buffer, UINT32 bufferSize)
{
    if (!buffer)
        return 0;

    return (UINT8)(0x100U - calculateSum8(buffer, bufferSize));
}

// 16bit checksum calculation routine
UINT16 calculateChecksum16(const UINT16* buffer, UINT32 bufferSize)
{
    if (!buffer)
        return 0;

    UINT16 counter = 0;
    UINT32 index = 0;

    bufferSize /= sizeof(UINT16);

    for (; index < bufferSize; index++) {
        counter = (UINT16)(counter + buffer[index]);
    }

    return (UINT16)(0x10000 - counter);
}

// 32bit checksum calculation routine
UINT32 calculateChecksum32(const UINT32* buffer, UINT32 bufferSize)
{
    if (!buffer)
        return 0;
    
    UINT32 counter = 0;
    UINT32 index = 0;
    
    bufferSize /= sizeof(UINT32);
    
    for (; index < bufferSize; index++) {
        counter = (UINT32)(counter + buffer[index]);
    }
    
    return (UINT32)(0x100000000ULL - counter);
}

// Get padding type for a given padding
UINT8 getPaddingType(const UByteArray & padding)
{
    if (padding.count('\x00') == padding.size())
        return Subtypes::ZeroPadding;
    if (padding.count('\xFF') == padding.size())
        return Subtypes::OnePadding;
    return Subtypes::DataPadding;
}

static inline int char2hex(char c)
{
    if (c >= '0' && c <= '9')
        return c - '0';
    if (c >= 'A' && c <= 'F')
        return c - 'A' + 10;
    if (c == '.')
        return -2;
    return -1;
}

INTN findPattern(const UINT8 *pattern, const UINT8 *patternMask, UINTN patternSize,
    const UINT8 *data, UINTN dataSize, UINTN dataOff)
{
    if (patternSize == 0 || dataSize == 0 || dataOff >= dataSize || dataSize - dataOff < patternSize)
        return -1;

    while (dataOff + patternSize < dataSize) {
        BOOLEAN matches = TRUE;
        for (UINTN i = 0; i < patternSize; i++) {
            if ((data[dataOff + i] & patternMask[i]) != pattern[i]) {
                matches = FALSE;
                break;
            }
        }

        if (matches)
            return static_cast<INTN>(dataOff);

        dataOff++;
    }

    return -1;
}

BOOLEAN makePattern(const CHAR8 *textPattern, std::vector<UINT8> &pattern, std::vector<UINT8> &patternMask)
{
    UINTN len = std::strlen(textPattern);

    if (len == 0 || len % 2 != 0)
        return FALSE;

    len /= 2;

    pattern.resize(len);
    patternMask.resize(len);

    for (UINTN i = 0; i < len; i++) {
        int v1 = char2hex(std::toupper(textPattern[i * 2]));
        int v2 = char2hex(std::toupper(textPattern[i * 2 + 1]));

        if (v1 == -1 || v2 == -1)
            return FALSE;

        if (v1 != -2) {
            patternMask[i] = 0xF0;
            pattern[i] = static_cast<UINT8>(v1) << 4;
        }

        if (v2 != -2) {
            patternMask[i] |= 0x0F;
            pattern[i] |= static_cast<UINT8>(v2);
        }
    }

    return TRUE;
}

USTATUS gzipDecompress(const UByteArray & input, UByteArray & output)
{
    output.clear();

    if (input.size() == 0)
        return U_SUCCESS;

    z_stream stream;
    stream.next_in = (z_const Bytef *)input.data();
    stream.avail_in = input.size();
    stream.zalloc = Z_NULL;
    stream.zfree = Z_NULL;
    stream.opaque = Z_NULL;

    // 15 for the maximum history buffer, 16 for gzip only input.
    int ret = inflateInit2(&stream, 15U | 16U);
    if (ret != Z_OK)
        return U_GZIP_DECOMPRESSION_FAILED;

    while (ret == Z_OK) {
        Bytef out[4096];
        stream.next_out = out;
        stream.avail_out = sizeof(out);

        ret = inflate(&stream, Z_NO_FLUSH);
        if ((ret == Z_OK || ret == Z_STREAM_END) && stream.avail_out != sizeof(out))
            output += UByteArray((char *)out, sizeof(out) - stream.avail_out);
    }

    inflateEnd(&stream);
    return ret == Z_STREAM_END ? U_SUCCESS : U_GZIP_DECOMPRESSION_FAILED;
}

```

`efiXloader/3rd/uefitool/common/utility.h`:

```h
/* utility.h

Copyright (c) 2016, Nikolaj Schlej. All rights reserved.
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

*/

#ifndef UTILITY_H
#define UTILITY_H

#include <vector>

#include "../common/zlib/zlib.h"

#include "basetypes.h"
#include "ustring.h"
#include "treemodel.h"
#include "parsingdata.h"

// Returns unique name for tree item
UString uniqueItemName(const UModelIndex & index);

// Converts error code to UString
UString errorCodeToUString(USTATUS errorCode);

// EFI/Tiano/LZMA decompression routine
USTATUS decompress(const UByteArray & compressed, const UINT8 compressionType, UINT8 & algorithm, UINT32 & dictionarySize, UByteArray & decompressed, UByteArray & efiDecompressed);

// GZIP decompression routine
USTATUS gzipDecompress(const UByteArray & compressed, UByteArray & decompressed);

// 8bit sum calculation routine
UINT8 calculateSum8(const UINT8* buffer, UINT32 bufferSize);

// 8bit checksum calculation routine
UINT8 calculateChecksum8(const UINT8* buffer, UINT32 bufferSize);

// 16bit checksum calculation routine
UINT16 calculateChecksum16(const UINT16* buffer, UINT32 bufferSize);

// 32bit checksum calculation routine
UINT32 calculateChecksum32(const UINT32* buffer, UINT32 bufferSize);

// Return padding type from it's contents
UINT8 getPaddingType(const UByteArray & padding);

// Make pattern from a hexstring with an assumption of . being any char
BOOLEAN makePattern(const CHAR8 *textPattern, std::vector<UINT8> &pattern, std::vector<UINT8> &patternMask);

// Find pattern in a binary blob
INTN findPattern(const UINT8 *pattern, const UINT8 *patternMask, UINTN patternSize,
    const UINT8 *data, UINTN dataSize, UINTN dataOff);

// Safely dereferences misaligned pointers
template <typename T>
inline T readUnaligned(const T *v) {
	T tmp;
	memcpy(&tmp, v, sizeof(T));
	return tmp;
}

#endif // UTILITY_H

```

`efiXloader/3rd/uefitool/common/zlib/adler32.c`:

```c
/* adler32.c -- compute the Adler-32 checksum of a data stream
 * Copyright (C) 1995-2011, 2016 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/* @(#) $Id$ */

#include "zutil.h"

local uLong adler32_combine_ OF((uLong adler1, uLong adler2, z_off64_t len2));

#define BASE 65521U     /* largest prime smaller than 65536 */
#define NMAX 5552
/* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1 */

#define DO1(buf,i)  {adler += (buf)[i]; sum2 += adler;}
#define DO2(buf,i)  DO1(buf,i); DO1(buf,i+1);
#define DO4(buf,i)  DO2(buf,i); DO2(buf,i+2);
#define DO8(buf,i)  DO4(buf,i); DO4(buf,i+4);
#define DO16(buf)   DO8(buf,0); DO8(buf,8);

/* use NO_DIVIDE if your processor does not do division in hardware --
   try it both ways to see which is faster */
#ifdef NO_DIVIDE
/* note that this assumes BASE is 65521, where 65536 % 65521 == 15
   (thank you to John Reiser for pointing this out) */
#  define CHOP(a) \
    do { \
        unsigned long tmp = a >> 16; \
        a &= 0xffffUL; \
        a += (tmp << 4) - tmp; \
    } while (0)
#  define MOD28(a) \
    do { \
        CHOP(a); \
        if (a >= BASE) a -= BASE; \
    } while (0)
#  define MOD(a) \
    do { \
        CHOP(a); \
        MOD28(a); \
    } while (0)
#  define MOD63(a) \
    do { /* this assumes a is not negative */ \
        z_off64_t tmp = a >> 32; \
        a &= 0xffffffffL; \
        a += (tmp << 8) - (tmp << 5) + tmp; \
        tmp = a >> 16; \
        a &= 0xffffL; \
        a += (tmp << 4) - tmp; \
        tmp = a >> 16; \
        a &= 0xffffL; \
        a += (tmp << 4) - tmp; \
        if (a >= BASE) a -= BASE; \
    } while (0)
#else
#  define MOD(a) a %= BASE
#  define MOD28(a) a %= BASE
#  define MOD63(a) a %= BASE
#endif

/* ========================================================================= */
uLong ZEXPORT adler32_z(adler, buf, len)
    uLong adler;
    const Bytef *buf;
    z_size_t len;
{
    unsigned long sum2;
    unsigned n;

    /* split Adler-32 into component sums */
    sum2 = (adler >> 16) & 0xffff;
    adler &= 0xffff;

    /* in case user likes doing a byte at a time, keep it fast */
    if (len == 1) {
        adler += buf[0];
        if (adler >= BASE)
            adler -= BASE;
        sum2 += adler;
        if (sum2 >= BASE)
            sum2 -= BASE;
        return adler | (sum2 << 16);
    }

    /* initial Adler-32 value (deferred check for len == 1 speed) */
    if (buf == Z_NULL)
        return 1L;

    /* in case short lengths are provided, keep it somewhat fast */
    if (len < 16) {
        while (len--) {
            adler += *buf++;
            sum2 += adler;
        }
        if (adler >= BASE)
            adler -= BASE;
        MOD28(sum2);            /* only added so many BASE's */
        return adler | (sum2 << 16);
    }

    /* do length NMAX blocks -- requires just one modulo operation */
    while (len >= NMAX) {
        len -= NMAX;
        n = NMAX / 16;          /* NMAX is divisible by 16 */
        do {
            DO16(buf);          /* 16 sums unrolled */
            buf += 16;
        } while (--n);
        MOD(adler);
        MOD(sum2);
    }

    /* do remaining bytes (less than NMAX, still just one modulo) */
    if (len) {                  /* avoid modulos if none remaining */
        while (len >= 16) {
            len -= 16;
            DO16(buf);
            buf += 16;
        }
        while (len--) {
            adler += *buf++;
            sum2 += adler;
        }
        MOD(adler);
        MOD(sum2);
    }

    /* return recombined sums */
    return adler | (sum2 << 16);
}

/* ========================================================================= */
uLong ZEXPORT adler32(adler, buf, len)
    uLong adler;
    const Bytef *buf;
    uInt len;
{
    return adler32_z(adler, buf, len);
}

/* ========================================================================= */
local uLong adler32_combine_(adler1, adler2, len2)
    uLong adler1;
    uLong adler2;
    z_off64_t len2;
{
    unsigned long sum1;
    unsigned long sum2;
    unsigned rem;

    /* for negative len, return invalid adler32 as a clue for debugging */
    if (len2 < 0)
        return 0xffffffffUL;

    /* the derivation of this formula is left as an exercise for the reader */
    MOD63(len2);                /* assumes len2 >= 0 */
    rem = (unsigned)len2;
    sum1 = adler1 & 0xffff;
    sum2 = rem * sum1;
    MOD(sum2);
    sum1 += (adler2 & 0xffff) + BASE - 1;
    sum2 += ((adler1 >> 16) & 0xffff) + ((adler2 >> 16) & 0xffff) + BASE - rem;
    if (sum1 >= BASE) sum1 -= BASE;
    if (sum1 >= BASE) sum1 -= BASE;
    if (sum2 >= ((unsigned long)BASE << 1)) sum2 -= ((unsigned long)BASE << 1);
    if (sum2 >= BASE) sum2 -= BASE;
    return sum1 | (sum2 << 16);
}

/* ========================================================================= */
uLong ZEXPORT adler32_combine(adler1, adler2, len2)
    uLong adler1;
    uLong adler2;
    z_off_t len2;
{
    return adler32_combine_(adler1, adler2, len2);
}

uLong ZEXPORT adler32_combine64(adler1, adler2, len2)
    uLong adler1;
    uLong adler2;
    z_off64_t len2;
{
    return adler32_combine_(adler1, adler2, len2);
}

```

`efiXloader/3rd/uefitool/common/zlib/compress.c`:

```c
/* compress.c -- compress a memory buffer
 * Copyright (C) 1995-2005, 2014, 2016 Jean-loup Gailly, Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/* @(#) $Id$ */

#define ZLIB_INTERNAL
#include "zlib.h"

/* ===========================================================================
     Compresses the source buffer into the destination buffer. The level
   parameter has the same meaning as in deflateInit.  sourceLen is the byte
   length of the source buffer. Upon entry, destLen is the total size of the
   destination buffer, which must be at least 0.1% larger than sourceLen plus
   12 bytes. Upon exit, destLen is the actual size of the compressed buffer.

     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_BUF_ERROR if there was not enough room in the output buffer,
   Z_STREAM_ERROR if the level parameter is invalid.
*/
int ZEXPORT compress2 (dest, destLen, source, sourceLen, level)
    Bytef *dest;
    uLongf *destLen;
    const Bytef *source;
    uLong sourceLen;
    int level;
{
    z_stream stream;
    int err;
    const uInt max = (uInt)-1;
    uLong left;

    left = *destLen;
    *destLen = 0;

    stream.zalloc = (alloc_func)0;
    stream.zfree = (free_func)0;
    stream.opaque = (voidpf)0;

    err = deflateInit(&stream, level);
    if (err != Z_OK) return err;

    stream.next_out = dest;
    stream.avail_out = 0;
    stream.next_in = (z_const Bytef *)source;
    stream.avail_in = 0;

    do {
        if (stream.avail_out == 0) {
            stream.avail_out = left > (uLong)max ? max : (uInt)left;
            left -= stream.avail_out;
        }
        if (stream.avail_in == 0) {
            stream.avail_in = sourceLen > (uLong)max ? max : (uInt)sourceLen;
            sourceLen -= stream.avail_in;
        }
        err = deflate(&stream, sourceLen ? Z_NO_FLUSH : Z_FINISH);
    } while (err == Z_OK);

    *destLen = stream.total_out;
    deflateEnd(&stream);
    return err == Z_STREAM_END ? Z_OK : err;
}

/* ===========================================================================
 */
int ZEXPORT compress (dest, destLen, source, sourceLen)
    Bytef *dest;
    uLongf *destLen;
    const Bytef *source;
    uLong sourceLen;
{
    return compress2(dest, destLen, source, sourceLen, Z_DEFAULT_COMPRESSION);
}

/* ===========================================================================
     If the default memLevel or windowBits for deflateInit() is changed, then
   this function needs to be updated.
 */
uLong ZEXPORT compressBound (sourceLen)
    uLong sourceLen;
{
    return sourceLen + (sourceLen >> 12) + (sourceLen >> 14) +
           (sourceLen >> 25) + 13;
}

```

`efiXloader/3rd/uefitool/common/zlib/crc32.c`:

```c
/* crc32.c -- compute the CRC-32 of a data stream
 * Copyright (C) 1995-2006, 2010, 2011, 2012, 2016 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 *
 * Thanks to Rodney Brown <rbrown64@csc.com.au> for his contribution of faster
 * CRC methods: exclusive-oring 32 bits of data at a time, and pre-computing
 * tables for updating the shift register in one step with three exclusive-ors
 * instead of four steps with four exclusive-ors.  This results in about a
 * factor of two increase in speed on a Power PC G4 (PPC7455) using gcc -O3.
 */

/* @(#) $Id$ */

/*
  Note on the use of DYNAMIC_CRC_TABLE: there is no mutex or semaphore
  protection on the static variables used to control the first-use generation
  of the crc tables.  Therefore, if you #define DYNAMIC_CRC_TABLE, you should
  first call get_crc_table() to initialize the tables before allowing more than
  one thread to use crc32().

  DYNAMIC_CRC_TABLE and MAKECRCH can be #defined to write out crc32.h.
 */

#ifdef MAKECRCH
#  include <stdio.h>
#  ifndef DYNAMIC_CRC_TABLE
#    define DYNAMIC_CRC_TABLE
#  endif /* !DYNAMIC_CRC_TABLE */
#endif /* MAKECRCH */

#include "zutil.h"      /* for STDC and FAR definitions */

/* Definitions for doing the crc four data bytes at a time. */
#if !defined(NOBYFOUR) && defined(Z_U4)
#  define BYFOUR
#endif
#ifdef BYFOUR
   local unsigned long crc32_little OF((unsigned long,
                        const unsigned char FAR *, z_size_t));
   local unsigned long crc32_big OF((unsigned long,
                        const unsigned char FAR *, z_size_t));
#  define TBLS 8
#else
#  define TBLS 1
#endif /* BYFOUR */

/* Local functions for crc concatenation */
local unsigned long gf2_matrix_times OF((unsigned long *mat,
                                         unsigned long vec));
local void gf2_matrix_square OF((unsigned long *square, unsigned long *mat));
local uLong crc32_combine_ OF((uLong crc1, uLong crc2, z_off64_t len2));


#ifdef DYNAMIC_CRC_TABLE

local volatile int crc_table_empty = 1;
local z_crc_t FAR crc_table[TBLS][256];
local void make_crc_table OF((void));
#ifdef MAKECRCH
   local void write_table OF((FILE *, const z_crc_t FAR *));
#endif /* MAKECRCH */
/*
  Generate tables for a byte-wise 32-bit CRC calculation on the polynomial:
  x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.

  Polynomials over GF(2) are represented in binary, one bit per coefficient,
  with the lowest powers in the most significant bit.  Then adding polynomials
  is just exclusive-or, and multiplying a polynomial by x is a right shift by
  one.  If we call the above polynomial p, and represent a byte as the
  polynomial q, also with the lowest power in the most significant bit (so the
  byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,
  where a mod b means the remainder after dividing a by b.

  This calculation is done using the shift-register method of multiplying and
  taking the remainder.  The register is initialized to zero, and for each
  incoming bit, x^32 is added mod p to the register if the bit is a one (where
  x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by
  x (which is shifting right by one and adding x^32 mod p if the bit shifted
  out is a one).  We start with the highest power (least significant bit) of
  q and repeat for all eight bits of q.

  The first table is simply the CRC of all possible eight bit values.  This is
  all the information needed to generate CRCs on data a byte at a time for all
  combinations of CRC register values and incoming bytes.  The remaining tables
  allow for word-at-a-time CRC calculation for both big-endian and little-
  endian machines, where a word is four bytes.
*/
local void make_crc_table()
{
    z_crc_t c;
    int n, k;
    z_crc_t poly;                       /* polynomial exclusive-or pattern */
    /* terms of polynomial defining this crc (except x^32): */
    static volatile int first = 1;      /* flag to limit concurrent making */
    static const unsigned char p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};

    /* See if another task is already doing this (not thread-safe, but better
       than nothing -- significantly reduces duration of vulnerability in
       case the advice about DYNAMIC_CRC_TABLE is ignored) */
    if (first) {
        first = 0;

        /* make exclusive-or pattern from polynomial (0xedb88320UL) */
        poly = 0;
        for (n = 0; n < (int)(sizeof(p)/sizeof(unsigned char)); n++)
            poly |= (z_crc_t)1 << (31 - p[n]);

        /* generate a crc for every 8-bit value */
        for (n = 0; n < 256; n++) {
            c = (z_crc_t)n;
            for (k = 0; k < 8; k++)
                c = c & 1 ? poly ^ (c >> 1) : c >> 1;
            crc_table[0][n] = c;
        }

#ifdef BYFOUR
        /* generate crc for each value followed by one, two, and three zeros,
           and then the byte reversal of those as well as the first table */
        for (n = 0; n < 256; n++) {
            c = crc_table[0][n];
            crc_table[4][n] = ZSWAP32(c);
            for (k = 1; k < 4; k++) {
                c = crc_table[0][c & 0xff] ^ (c >> 8);
                crc_table[k][n] = c;
                crc_table[k + 4][n] = ZSWAP32(c);
            }
        }
#endif /* BYFOUR */

        crc_table_empty = 0;
    }
    else {      /* not first */
        /* wait for the other guy to finish (not efficient, but rare) */
        while (crc_table_empty)
            ;
    }

#ifdef MAKECRCH
    /* write out CRC tables to crc32.h */
    {
        FILE *out;

        out = fopen("crc32.h", "w");
        if (out == NULL) return;
        fprintf(out, "/* crc32.h -- tables for rapid CRC calculation\n");
        fprintf(out, " * Generated automatically by crc32.c\n */\n\n");
        fprintf(out, "local const z_crc_t FAR ");
        fprintf(out, "crc_table[TBLS][256] =\n{\n  {\n");
        write_table(out, crc_table[0]);
#  ifdef BYFOUR
        fprintf(out, "#ifdef BYFOUR\n");
        for (k = 1; k < 8; k++) {
            fprintf(out, "  },\n  {\n");
            write_table(out, crc_table[k]);
        }
        fprintf(out, "#endif\n");
#  endif /* BYFOUR */
        fprintf(out, "  }\n};\n");
        fclose(out);
    }
#endif /* MAKECRCH */
}

#ifdef MAKECRCH
local void write_table(out, table)
    FILE *out;
    const z_crc_t FAR *table;
{
    int n;

    for (n = 0; n < 256; n++)
        fprintf(out, "%s0x%08lxUL%s", n % 5 ? "" : "    ",
                (unsigned long)(table[n]),
                n == 255 ? "\n" : (n % 5 == 4 ? ",\n" : ", "));
}
#endif /* MAKECRCH */

#else /* !DYNAMIC_CRC_TABLE */
/* ========================================================================
 * Tables of CRC-32s of all single-byte values, made by make_crc_table().
 */
#include "crc32.h"
#endif /* DYNAMIC_CRC_TABLE */

/* =========================================================================
 * This function can be used by asm versions of crc32()
 */
const z_crc_t FAR * ZEXPORT get_crc_table()
{
#ifdef DYNAMIC_CRC_TABLE
    if (crc_table_empty)
        make_crc_table();
#endif /* DYNAMIC_CRC_TABLE */
    return (const z_crc_t FAR *)crc_table;
}

/* ========================================================================= */
#define DO1 crc = crc_table[0][((int)crc ^ (*buf++)) & 0xff] ^ (crc >> 8)
#define DO8 DO1; DO1; DO1; DO1; DO1; DO1; DO1; DO1

/* ========================================================================= */
unsigned long ZEXPORT crc32_z(crc, buf, len)
    unsigned long crc;
    const unsigned char FAR *buf;
    z_size_t len;
{
    if (buf == Z_NULL) return 0UL;

#ifdef DYNAMIC_CRC_TABLE
    if (crc_table_empty)
        make_crc_table();
#endif /* DYNAMIC_CRC_TABLE */

#ifdef BYFOUR
    if (sizeof(void *) == sizeof(ptrdiff_t)) {
        z_crc_t endian;

        endian = 1;
        if (*((unsigned char *)(&endian)))
            return crc32_little(crc, buf, len);
        else
            return crc32_big(crc, buf, len);
    }
#endif /* BYFOUR */
    crc = crc ^ 0xffffffffUL;
    while (len >= 8) {
        DO8;
        len -= 8;
    }
    if (len) do {
        DO1;
    } while (--len);
    return crc ^ 0xffffffffUL;
}

/* ========================================================================= */
unsigned long ZEXPORT crc32(crc, buf, len)
    unsigned long crc;
    const unsigned char FAR *buf;
    uInt len;
{
    return crc32_z(crc, buf, len);
}

#ifdef BYFOUR

/*
   This BYFOUR code accesses the passed unsigned char * buffer with a 32-bit
   integer pointer type. This violates the strict aliasing rule, where a
   compiler can assume, for optimization purposes, that two pointers to
   fundamentally different types won't ever point to the same memory. This can
   manifest as a problem only if one of the pointers is written to. This code
   only reads from those pointers. So long as this code remains isolated in
   this compilation unit, there won't be a problem. For this reason, this code
   should not be copied and pasted into a compilation unit in which other code
   writes to the buffer that is passed to these routines.
 */

/* ========================================================================= */
#define DOLIT4 c ^= *buf4++; \
        c = crc_table[3][c & 0xff] ^ crc_table[2][(c >> 8) & 0xff] ^ \
            crc_table[1][(c >> 16) & 0xff] ^ crc_table[0][c >> 24]
#define DOLIT32 DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4

/* ========================================================================= */
local unsigned long crc32_little(crc, buf, len)
    unsigned long crc;
    const unsigned char FAR *buf;
    z_size_t len;
{
    register z_crc_t c;
    register const z_crc_t FAR *buf4;

    c = (z_crc_t)crc;
    c = ~c;
    while (len && ((ptrdiff_t)buf & 3)) {
        c = crc_table[0][(c ^ *buf++) & 0xff] ^ (c >> 8);
        len--;
    }

    buf4 = (const z_crc_t FAR *)(const void FAR *)buf;
    while (len >= 32) {
        DOLIT32;
        len -= 32;
    }
    while (len >= 4) {
        DOLIT4;
        len -= 4;
    }
    buf = (const unsigned char FAR *)buf4;

    if (len) do {
        c = crc_table[0][(c ^ *buf++) & 0xff] ^ (c >> 8);
    } while (--len);
    c = ~c;
    return (unsigned long)c;
}

/* ========================================================================= */
#define DOBIG4 c ^= *buf4++; \
        c = crc_table[4][c & 0xff] ^ crc_table[5][(c >> 8) & 0xff] ^ \
            crc_table[6][(c >> 16) & 0xff] ^ crc_table[7][c >> 24]
#define DOBIG32 DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4

/* ========================================================================= */
local unsigned long crc32_big(crc, buf, len)
    unsigned long crc;
    const unsigned char FAR *buf;
    z_size_t len;
{
    register z_crc_t c;
    register const z_crc_t FAR *buf4;

    c = ZSWAP32((z_crc_t)crc);
    c = ~c;
    while (len && ((ptrdiff_t)buf & 3)) {
        c = crc_table[4][(c >> 24) ^ *buf++] ^ (c << 8);
        len--;
    }

    buf4 = (const z_crc_t FAR *)(const void FAR *)buf;
    while (len >= 32) {
        DOBIG32;
        len -= 32;
    }
    while (len >= 4) {
        DOBIG4;
        len -= 4;
    }
    buf = (const unsigned char FAR *)buf4;

    if (len) do {
        c = crc_table[4][(c >> 24) ^ *buf++] ^ (c << 8);
    } while (--len);
    c = ~c;
    return (unsigned long)(ZSWAP32(c));
}

#endif /* BYFOUR */

#define GF2_DIM 32      /* dimension of GF(2) vectors (length of CRC) */

/* ========================================================================= */
local unsigned long gf2_matrix_times(mat, vec)
    unsigned long *mat;
    unsigned long vec;
{
    unsigned long sum;

    sum = 0;
    while (vec) {
        if (vec & 1)
            sum ^= *mat;
        vec >>= 1;
        mat++;
    }
    return sum;
}

/* ========================================================================= */
local void gf2_matrix_square(square, mat)
    unsigned long *square;
    unsigned long *mat;
{
    int n;

    for (n = 0; n < GF2_DIM; n++)
        square[n] = gf2_matrix_times(mat, mat[n]);
}

/* ========================================================================= */
local uLong crc32_combine_(crc1, crc2, len2)
    uLong crc1;
    uLong crc2;
    z_off64_t len2;
{
    int n;
    unsigned long row;
    unsigned long even[GF2_DIM];    /* even-power-of-two zeros operator */
    unsigned long odd[GF2_DIM];     /* odd-power-of-two zeros operator */

    /* degenerate case (also disallow negative lengths) */
    if (len2 <= 0)
        return crc1;

    /* put operator for one zero bit in odd */
    odd[0] = 0xedb88320UL;          /* CRC-32 polynomial */
    row = 1;
    for (n = 1; n < GF2_DIM; n++) {
        odd[n] = row;
        row <<= 1;
    }

    /* put operator for two zero bits in even */
    gf2_matrix_square(even, odd);

    /* put operator for four zero bits in odd */
    gf2_matrix_square(odd, even);

    /* apply len2 zeros to crc1 (first square will put the operator for one
       zero byte, eight zero bits, in even) */
    do {
        /* apply zeros operator for this bit of len2 */
        gf2_matrix_square(even, odd);
        if (len2 & 1)
            crc1 = gf2_matrix_times(even, crc1);
        len2 >>= 1;

        /* if no more bits set, then done */
        if (len2 == 0)
            break;

        /* another iteration of the loop with odd and even swapped */
        gf2_matrix_square(odd, even);
        if (len2 & 1)
            crc1 = gf2_matrix_times(odd, crc1);
        len2 >>= 1;

        /* if no more bits set, then done */
    } while (len2 != 0);

    /* return combined crc */
    crc1 ^= crc2;
    return crc1;
}

/* ========================================================================= */
uLong ZEXPORT crc32_combine(crc1, crc2, len2)
    uLong crc1;
    uLong crc2;
    z_off_t len2;
{
    return crc32_combine_(crc1, crc2, len2);
}

uLong ZEXPORT crc32_combine64(crc1, crc2, len2)
    uLong crc1;
    uLong crc2;
    z_off64_t len2;
{
    return crc32_combine_(crc1, crc2, len2);
}

```

`efiXloader/3rd/uefitool/common/zlib/crc32.h`:

```h
/* crc32.h -- tables for rapid CRC calculation
 * Generated automatically by crc32.c
 */

local const z_crc_t FAR crc_table[TBLS][256] =
{
  {
    0x00000000UL, 0x77073096UL, 0xee0e612cUL, 0x990951baUL, 0x076dc419UL,
    0x706af48fUL, 0xe963a535UL, 0x9e6495a3UL, 0x0edb8832UL, 0x79dcb8a4UL,
    0xe0d5e91eUL, 0x97d2d988UL, 0x09b64c2bUL, 0x7eb17cbdUL, 0xe7b82d07UL,
    0x90bf1d91UL, 0x1db71064UL, 0x6ab020f2UL, 0xf3b97148UL, 0x84be41deUL,
    0x1adad47dUL, 0x6ddde4ebUL, 0xf4d4b551UL, 0x83d385c7UL, 0x136c9856UL,
    0x646ba8c0UL, 0xfd62f97aUL, 0x8a65c9ecUL, 0x14015c4fUL, 0x63066cd9UL,
    0xfa0f3d63UL, 0x8d080df5UL, 0x3b6e20c8UL, 0x4c69105eUL, 0xd56041e4UL,
    0xa2677172UL, 0x3c03e4d1UL, 0x4b04d447UL, 0xd20d85fdUL, 0xa50ab56bUL,
    0x35b5a8faUL, 0x42b2986cUL, 0xdbbbc9d6UL, 0xacbcf940UL, 0x32d86ce3UL,
    0x45df5c75UL, 0xdcd60dcfUL, 0xabd13d59UL, 0x26d930acUL, 0x51de003aUL,
    0xc8d75180UL, 0xbfd06116UL, 0x21b4f4b5UL, 0x56b3c423UL, 0xcfba9599UL,
    0xb8bda50fUL, 0x2802b89eUL, 0x5f058808UL, 0xc60cd9b2UL, 0xb10be924UL,
    0x2f6f7c87UL, 0x58684c11UL, 0xc1611dabUL, 0xb6662d3dUL, 0x76dc4190UL,
    0x01db7106UL, 0x98d220bcUL, 0xefd5102aUL, 0x71b18589UL, 0x06b6b51fUL,
    0x9fbfe4a5UL, 0xe8b8d433UL, 0x7807c9a2UL, 0x0f00f934UL, 0x9609a88eUL,
    0xe10e9818UL, 0x7f6a0dbbUL, 0x086d3d2dUL, 0x91646c97UL, 0xe6635c01UL,
    0x6b6b51f4UL, 0x1c6c6162UL, 0x856530d8UL, 0xf262004eUL, 0x6c0695edUL,
    0x1b01a57bUL, 0x8208f4c1UL, 0xf50fc457UL, 0x65b0d9c6UL, 0x12b7e950UL,
    0x8bbeb8eaUL, 0xfcb9887cUL, 0x62dd1ddfUL, 0x15da2d49UL, 0x8cd37cf3UL,
    0xfbd44c65UL, 0x4db26158UL, 0x3ab551ceUL, 0xa3bc0074UL, 0xd4bb30e2UL,
    0x4adfa541UL, 0x3dd895d7UL, 0xa4d1c46dUL, 0xd3d6f4fbUL, 0x4369e96aUL,
    0x346ed9fcUL, 0xad678846UL, 0xda60b8d0UL, 0x44042d73UL, 0x33031de5UL,
    0xaa0a4c5fUL, 0xdd0d7cc9UL, 0x5005713cUL, 0x270241aaUL, 0xbe0b1010UL,
    0xc90c2086UL, 0x5768b525UL, 0x206f85b3UL, 0xb966d409UL, 0xce61e49fUL,
    0x5edef90eUL, 0x29d9c998UL, 0xb0d09822UL, 0xc7d7a8b4UL, 0x59b33d17UL,
    0x2eb40d81UL, 0xb7bd5c3bUL, 0xc0ba6cadUL, 0xedb88320UL, 0x9abfb3b6UL,
    0x03b6e20cUL, 0x74b1d29aUL, 0xead54739UL, 0x9dd277afUL, 0x04db2615UL,
    0x73dc1683UL, 0xe3630b12UL, 0x94643b84UL, 0x0d6d6a3eUL, 0x7a6a5aa8UL,
    0xe40ecf0bUL, 0x9309ff9dUL, 0x0a00ae27UL, 0x7d079eb1UL, 0xf00f9344UL,
    0x8708a3d2UL, 0x1e01f268UL, 0x6906c2feUL, 0xf762575dUL, 0x806567cbUL,
    0x196c3671UL, 0x6e6b06e7UL, 0xfed41b76UL, 0x89d32be0UL, 0x10da7a5aUL,
    0x67dd4accUL, 0xf9b9df6fUL, 0x8ebeeff9UL, 0x17b7be43UL, 0x60b08ed5UL,
    0xd6d6a3e8UL, 0xa1d1937eUL, 0x38d8c2c4UL, 0x4fdff252UL, 0xd1bb67f1UL,
    0xa6bc5767UL, 0x3fb506ddUL, 0x48b2364bUL, 0xd80d2bdaUL, 0xaf0a1b4cUL,
    0x36034af6UL, 0x41047a60UL, 0xdf60efc3UL, 0xa867df55UL, 0x316e8eefUL,
    0x4669be79UL, 0xcb61b38cUL, 0xbc66831aUL, 0x256fd2a0UL, 0x5268e236UL,
    0xcc0c7795UL, 0xbb0b4703UL, 0x220216b9UL, 0x5505262fUL, 0xc5ba3bbeUL,
    0xb2bd0b28UL, 0x2bb45a92UL, 0x5cb36a04UL, 0xc2d7ffa7UL, 0xb5d0cf31UL,
    0x2cd99e8bUL, 0x5bdeae1dUL, 0x9b64c2b0UL, 0xec63f226UL, 0x756aa39cUL,
    0x026d930aUL, 0x9c0906a9UL, 0xeb0e363fUL, 0x72076785UL, 0x05005713UL,
    0x95bf4a82UL, 0xe2b87a14UL, 0x7bb12baeUL, 0x0cb61b38UL, 0x92d28e9bUL,
    0xe5d5be0dUL, 0x7cdcefb7UL, 0x0bdbdf21UL, 0x86d3d2d4UL, 0xf1d4e242UL,
    0x68ddb3f8UL, 0x1fda836eUL, 0x81be16cdUL, 0xf6b9265bUL, 0x6fb077e1UL,
    0x18b74777UL, 0x88085ae6UL, 0xff0f6a70UL, 0x66063bcaUL, 0x11010b5cUL,
    0x8f659effUL, 0xf862ae69UL, 0x616bffd3UL, 0x166ccf45UL, 0xa00ae278UL,
    0xd70dd2eeUL, 0x4e048354UL, 0x3903b3c2UL, 0xa7672661UL, 0xd06016f7UL,
    0x4969474dUL, 0x3e6e77dbUL, 0xaed16a4aUL, 0xd9d65adcUL, 0x40df0b66UL,
    0x37d83bf0UL, 0xa9bcae53UL, 0xdebb9ec5UL, 0x47b2cf7fUL, 0x30b5ffe9UL,
    0xbdbdf21cUL, 0xcabac28aUL, 0x53b39330UL, 0x24b4a3a6UL, 0xbad03605UL,
    0xcdd70693UL, 0x54de5729UL, 0x23d967bfUL, 0xb3667a2eUL, 0xc4614ab8UL,
    0x5d681b02UL, 0x2a6f2b94UL, 0xb40bbe37UL, 0xc30c8ea1UL, 0x5a05df1bUL,
    0x2d02ef8dUL
#ifdef BYFOUR
  },
  {
    0x00000000UL, 0x191b3141UL, 0x32366282UL, 0x2b2d53c3UL, 0x646cc504UL,
    0x7d77f445UL, 0x565aa786UL, 0x4f4196c7UL, 0xc8d98a08UL, 0xd1c2bb49UL,
    0xfaefe88aUL, 0xe3f4d9cbUL, 0xacb54f0cUL, 0xb5ae7e4dUL, 0x9e832d8eUL,
    0x87981ccfUL, 0x4ac21251UL, 0x53d92310UL, 0x78f470d3UL, 0x61ef4192UL,
    0x2eaed755UL, 0x37b5e614UL, 0x1c98b5d7UL, 0x05838496UL, 0x821b9859UL,
    0x9b00a918UL, 0xb02dfadbUL, 0xa936cb9aUL, 0xe6775d5dUL, 0xff6c6c1cUL,
    0xd4413fdfUL, 0xcd5a0e9eUL, 0x958424a2UL, 0x8c9f15e3UL, 0xa7b24620UL,
    0xbea97761UL, 0xf1e8e1a6UL, 0xe8f3d0e7UL, 0xc3de8324UL, 0xdac5b265UL,
    0x5d5daeaaUL, 0x44469febUL, 0x6f6bcc28UL, 0x7670fd69UL, 0x39316baeUL,
    0x202a5aefUL, 0x0b07092cUL, 0x121c386dUL, 0xdf4636f3UL, 0xc65d07b2UL,
    0xed705471UL, 0xf46b6530UL, 0xbb2af3f7UL, 0xa231c2b6UL, 0x891c9175UL,
    0x9007a034UL, 0x179fbcfbUL, 0x0e848dbaUL, 0x25a9de79UL, 0x3cb2ef38UL,
    0x73f379ffUL, 0x6ae848beUL, 0x41c51b7dUL, 0x58de2a3cUL, 0xf0794f05UL,
    0xe9627e44UL, 0xc24f2d87UL, 0xdb541cc6UL, 0x94158a01UL, 0x8d0ebb40UL,
    0xa623e883UL, 0xbf38d9c2UL, 0x38a0c50dUL, 0x21bbf44cUL, 0x0a96a78fUL,
    0x138d96ceUL, 0x5ccc0009UL, 0x45d73148UL, 0x6efa628bUL, 0x77e153caUL,
    0xbabb5d54UL, 0xa3a06c15UL, 0x888d3fd6UL, 0x91960e97UL, 0xded79850UL,
    0xc7cca911UL, 0xece1fad2UL, 0xf5facb93UL, 0x7262d75cUL, 0x6b79e61dUL,
    0x4054b5deUL, 0x594f849fUL, 0x160e1258UL, 0x0f152319UL, 0x243870daUL,
    0x3d23419bUL, 0x65fd6ba7UL, 0x7ce65ae6UL, 0x57cb0925UL, 0x4ed03864UL,
    0x0191aea3UL, 0x188a9fe2UL, 0x33a7cc21UL, 0x2abcfd60UL, 0xad24e1afUL,
    0xb43fd0eeUL, 0x9f12832dUL, 0x8609b26cUL, 0xc94824abUL, 0xd05315eaUL,
    0xfb7e4629UL, 0xe2657768UL, 0x2f3f79f6UL, 0x362448b7UL, 0x1d091b74UL,
    0x04122a35UL, 0x4b53bcf2UL, 0x52488db3UL, 0x7965de70UL, 0x607eef31UL,
    0xe7e6f3feUL, 0xfefdc2bfUL, 0xd5d0917cUL, 0xcccba03dUL, 0x838a36faUL,
    0x9a9107bbUL, 0xb1bc5478UL, 0xa8a76539UL, 0x3b83984bUL, 0x2298a90aUL,
    0x09b5fac9UL, 0x10aecb88UL, 0x5fef5d4fUL, 0x46f46c0eUL, 0x6dd93fcdUL,
    0x74c20e8cUL, 0xf35a1243UL, 0xea412302UL, 0xc16c70c1UL, 0xd8774180UL,
    0x9736d747UL, 0x8e2de606UL, 0xa500b5c5UL, 0xbc1b8484UL, 0x71418a1aUL,
    0x685abb5bUL, 0x4377e898UL, 0x5a6cd9d9UL, 0x152d4f1eUL, 0x0c367e5fUL,
    0x271b2d9cUL, 0x3e001cddUL, 0xb9980012UL, 0xa0833153UL, 0x8bae6290UL,
    0x92b553d1UL, 0xddf4c516UL, 0xc4eff457UL, 0xefc2a794UL, 0xf6d996d5UL,
    0xae07bce9UL, 0xb71c8da8UL, 0x9c31de6bUL, 0x852aef2aUL, 0xca6b79edUL,
    0xd37048acUL, 0xf85d1b6fUL, 0xe1462a2eUL, 0x66de36e1UL, 0x7fc507a0UL,
    0x54e85463UL, 0x4df36522UL, 0x02b2f3e5UL, 0x1ba9c2a4UL, 0x30849167UL,
    0x299fa026UL, 0xe4c5aeb8UL, 0xfdde9ff9UL, 0xd6f3cc3aUL, 0xcfe8fd7bUL,
    0x80a96bbcUL, 0x99b25afdUL, 0xb29f093eUL, 0xab84387fUL, 0x2c1c24b0UL,
    0x350715f1UL, 0x1e2a4632UL, 0x07317773UL, 0x4870e1b4UL, 0x516bd0f5UL,
    0x7a468336UL, 0x635db277UL, 0xcbfad74eUL, 0xd2e1e60fUL, 0xf9ccb5ccUL,
    0xe0d7848dUL, 0xaf96124aUL, 0xb68d230bUL, 0x9da070c8UL, 0x84bb4189UL,
    0x03235d46UL, 0x1a386c07UL, 0x31153fc4UL, 0x280e0e85UL, 0x674f9842UL,
    0x7e54a903UL, 0x5579fac0UL, 0x4c62cb81UL, 0x8138c51fUL, 0x9823f45eUL,
    0xb30ea79dUL, 0xaa1596dcUL, 0xe554001bUL, 0xfc4f315aUL, 0xd7626299UL,
    0xce7953d8UL, 0x49e14f17UL, 0x50fa7e56UL, 0x7bd72d95UL, 0x62cc1cd4UL,
    0x2d8d8a13UL, 0x3496bb52UL, 0x1fbbe891UL, 0x06a0d9d0UL, 0x5e7ef3ecUL,
    0x4765c2adUL, 0x6c48916eUL, 0x7553a02fUL, 0x3a1236e8UL, 0x230907a9UL,
    0x0824546aUL, 0x113f652bUL, 0x96a779e4UL, 0x8fbc48a5UL, 0xa4911b66UL,
    0xbd8a2a27UL, 0xf2cbbce0UL, 0xebd08da1UL, 0xc0fdde62UL, 0xd9e6ef23UL,
    0x14bce1bdUL, 0x0da7d0fcUL, 0x268a833fUL, 0x3f91b27eUL, 0x70d024b9UL,
    0x69cb15f8UL, 0x42e6463bUL, 0x5bfd777aUL, 0xdc656bb5UL, 0xc57e5af4UL,
    0xee530937UL, 0xf7483876UL, 0xb809aeb1UL, 0xa1129ff0UL, 0x8a3fcc33UL,
    0x9324fd72UL
  },
  {
    0x00000000UL, 0x01c26a37UL, 0x0384d46eUL, 0x0246be59UL, 0x0709a8dcUL,
    0x06cbc2ebUL, 0x048d7cb2UL, 0x054f1685UL, 0x0e1351b8UL, 0x0fd13b8fUL,
    0x0d9785d6UL, 0x0c55efe1UL, 0x091af964UL, 0x08d89353UL, 0x0a9e2d0aUL,
    0x0b5c473dUL, 0x1c26a370UL, 0x1de4c947UL, 0x1fa2771eUL, 0x1e601d29UL,
    0x1b2f0bacUL, 0x1aed619bUL, 0x18abdfc2UL, 0x1969b5f5UL, 0x1235f2c8UL,
    0x13f798ffUL, 0x11b126a6UL, 0x10734c91UL, 0x153c5a14UL, 0x14fe3023UL,
    0x16b88e7aUL, 0x177ae44dUL, 0x384d46e0UL, 0x398f2cd7UL, 0x3bc9928eUL,
    0x3a0bf8b9UL, 0x3f44ee3cUL, 0x3e86840bUL, 0x3cc03a52UL, 0x3d025065UL,
    0x365e1758UL, 0x379c7d6fUL, 0x35dac336UL, 0x3418a901UL, 0x3157bf84UL,
    0x3095d5b3UL, 0x32d36beaUL, 0x331101ddUL, 0x246be590UL, 0x25a98fa7UL,
    0x27ef31feUL, 0x262d5bc9UL, 0x23624d4cUL, 0x22a0277bUL, 0x20e69922UL,
    0x2124f315UL, 0x2a78b428UL, 0x2bbade1fUL, 0x29fc6046UL, 0x283e0a71UL,
    0x2d711cf4UL, 0x2cb376c3UL, 0x2ef5c89aUL, 0x2f37a2adUL, 0x709a8dc0UL,
    0x7158e7f7UL, 0x731e59aeUL, 0x72dc3399UL, 0x7793251cUL, 0x76514f2bUL,
    0x7417f172UL, 0x75d59b45UL, 0x7e89dc78UL, 0x7f4bb64fUL, 0x7d0d0816UL,
    0x7ccf6221UL, 0x798074a4UL, 0x78421e93UL, 0x7a04a0caUL, 0x7bc6cafdUL,
    0x6cbc2eb0UL, 0x6d7e4487UL, 0x6f38fadeUL, 0x6efa90e9UL, 0x6bb5866cUL,
    0x6a77ec5bUL, 0x68315202UL, 0x69f33835UL, 0x62af7f08UL, 0x636d153fUL,
    0x612bab66UL, 0x60e9c151UL, 0x65a6d7d4UL, 0x6464bde3UL, 0x662203baUL,
    0x67e0698dUL, 0x48d7cb20UL, 0x4915a117UL, 0x4b531f4eUL, 0x4a917579UL,
    0x4fde63fcUL, 0x4e1c09cbUL, 0x4c5ab792UL, 0x4d98dda5UL, 0x46c49a98UL,
    0x4706f0afUL, 0x45404ef6UL, 0x448224c1UL, 0x41cd3244UL, 0x400f5873UL,
    0x4249e62aUL, 0x438b8c1dUL, 0x54f16850UL, 0x55330267UL, 0x5775bc3eUL,
    0x56b7d609UL, 0x53f8c08cUL, 0x523aaabbUL, 0x507c14e2UL, 0x51be7ed5UL,
    0x5ae239e8UL, 0x5b2053dfUL, 0x5966ed86UL, 0x58a487b1UL, 0x5deb9134UL,
    0x5c29fb03UL, 0x5e6f455aUL, 0x5fad2f6dUL, 0xe1351b80UL, 0xe0f771b7UL,
    0xe2b1cfeeUL, 0xe373a5d9UL, 0xe63cb35cUL, 0xe7fed96bUL, 0xe5b86732UL,
    0xe47a0d05UL, 0xef264a38UL, 0xeee4200fUL, 0xeca29e56UL, 0xed60f461UL,
    0xe82fe2e4UL, 0xe9ed88d3UL, 0xebab368aUL, 0xea695cbdUL, 0xfd13b8f0UL,
    0xfcd1d2c7UL, 0xfe976c9eUL, 0xff5506a9UL, 0xfa1a102cUL, 0xfbd87a1bUL,
    0xf99ec442UL, 0xf85cae75UL, 0xf300e948UL, 0xf2c2837fUL, 0xf0843d26UL,
    0xf1465711UL, 0xf4094194UL, 0xf5cb2ba3UL, 0xf78d95faUL, 0xf64fffcdUL,
    0xd9785d60UL, 0xd8ba3757UL, 0xdafc890eUL, 0xdb3ee339UL, 0xde71f5bcUL,
    0xdfb39f8bUL, 0xddf521d2UL, 0xdc374be5UL, 0xd76b0cd8UL, 0xd6a966efUL,
    0xd4efd8b6UL, 0xd52db281UL, 0xd062a404UL, 0xd1a0ce33UL, 0xd3e6706aUL,
    0xd2241a5dUL, 0xc55efe10UL, 0xc49c9427UL, 0xc6da2a7eUL, 0xc7184049UL,
    0xc25756ccUL, 0xc3953cfbUL, 0xc1d382a2UL, 0xc011e895UL, 0xcb4dafa8UL,
    0xca8fc59fUL, 0xc8c97bc6UL, 0xc90b11f1UL, 0xcc440774UL, 0xcd866d43UL,
    0xcfc0d31aUL, 0xce02b92dUL, 0x91af9640UL, 0x906dfc77UL, 0x922b422eUL,
    0x93e92819UL, 0x96a63e9cUL, 0x976454abUL, 0x9522eaf2UL, 0x94e080c5UL,
    0x9fbcc7f8UL, 0x9e7eadcfUL, 0x9c381396UL, 0x9dfa79a1UL, 0x98b56f24UL,
    0x99770513UL, 0x9b31bb4aUL, 0x9af3d17dUL, 0x8d893530UL, 0x8c4b5f07UL,
    0x8e0de15eUL, 0x8fcf8b69UL, 0x8a809decUL, 0x8b42f7dbUL, 0x89044982UL,
    0x88c623b5UL, 0x839a6488UL, 0x82580ebfUL, 0x801eb0e6UL, 0x81dcdad1UL,
    0x8493cc54UL, 0x8551a663UL, 0x8717183aUL, 0x86d5720dUL, 0xa9e2d0a0UL,
    0xa820ba97UL, 0xaa6604ceUL, 0xaba46ef9UL, 0xaeeb787cUL, 0xaf29124bUL,
    0xad6fac12UL, 0xacadc625UL, 0xa7f18118UL, 0xa633eb2fUL, 0xa4755576UL,
    0xa5b73f41UL, 0xa0f829c4UL, 0xa13a43f3UL, 0xa37cfdaaUL, 0xa2be979dUL,
    0xb5c473d0UL, 0xb40619e7UL, 0xb640a7beUL, 0xb782cd89UL, 0xb2cddb0cUL,
    0xb30fb13bUL, 0xb1490f62UL, 0xb08b6555UL, 0xbbd72268UL, 0xba15485fUL,
    0xb853f606UL, 0xb9919c31UL, 0xbcde8ab4UL, 0xbd1ce083UL, 0xbf5a5edaUL,
    0xbe9834edUL
  },
  {
    0x00000000UL, 0xb8bc6765UL, 0xaa09c88bUL, 0x12b5afeeUL, 0x8f629757UL,
    0x37def032UL, 0x256b5fdcUL, 0x9dd738b9UL, 0xc5b428efUL, 0x7d084f8aUL,
    0x6fbde064UL, 0xd7018701UL, 0x4ad6bfb8UL, 0xf26ad8ddUL, 0xe0df7733UL,
    0x58631056UL, 0x5019579fUL, 0xe8a530faUL, 0xfa109f14UL, 0x42acf871UL,
    0xdf7bc0c8UL, 0x67c7a7adUL, 0x75720843UL, 0xcdce6f26UL, 0x95ad7f70UL,
    0x2d111815UL, 0x3fa4b7fbUL, 0x8718d09eUL, 0x1acfe827UL, 0xa2738f42UL,
    0xb0c620acUL, 0x087a47c9UL, 0xa032af3eUL, 0x188ec85bUL, 0x0a3b67b5UL,
    0xb28700d0UL, 0x2f503869UL, 0x97ec5f0cUL, 0x8559f0e2UL, 0x3de59787UL,
    0x658687d1UL, 0xdd3ae0b4UL, 0xcf8f4f5aUL, 0x7733283fUL, 0xeae41086UL,
    0x525877e3UL, 0x40edd80dUL, 0xf851bf68UL, 0xf02bf8a1UL, 0x48979fc4UL,
    0x5a22302aUL, 0xe29e574fUL, 0x7f496ff6UL, 0xc7f50893UL, 0xd540a77dUL,
    0x6dfcc018UL, 0x359fd04eUL, 0x8d23b72bUL, 0x9f9618c5UL, 0x272a7fa0UL,
    0xbafd4719UL, 0x0241207cUL, 0x10f48f92UL, 0xa848e8f7UL, 0x9b14583dUL,
    0x23a83f58UL, 0x311d90b6UL, 0x89a1f7d3UL, 0x1476cf6aUL, 0xaccaa80fUL,
    0xbe7f07e1UL, 0x06c36084UL, 0x5ea070d2UL, 0xe61c17b7UL, 0xf4a9b859UL,
    0x4c15df3cUL, 0xd1c2e785UL, 0x697e80e0UL, 0x7bcb2f0eUL, 0xc377486bUL,
    0xcb0d0fa2UL, 0x73b168c7UL, 0x6104c729UL, 0xd9b8a04cUL, 0x446f98f5UL,
    0xfcd3ff90UL, 0xee66507eUL, 0x56da371bUL, 0x0eb9274dUL, 0xb6054028UL,
    0xa4b0efc6UL, 0x1c0c88a3UL, 0x81dbb01aUL, 0x3967d77fUL, 0x2bd27891UL,
    0x936e1ff4UL, 0x3b26f703UL, 0x839a9066UL, 0x912f3f88UL, 0x299358edUL,
    0xb4446054UL, 0x0cf80731UL, 0x1e4da8dfUL, 0xa6f1cfbaUL, 0xfe92dfecUL,
    0x462eb889UL, 0x549b1767UL, 0xec277002UL, 0x71f048bbUL, 0xc94c2fdeUL,
    0xdbf98030UL, 0x6345e755UL, 0x6b3fa09cUL, 0xd383c7f9UL, 0xc1366817UL,
    0x798a0f72UL, 0xe45d37cbUL, 0x5ce150aeUL, 0x4e54ff40UL, 0xf6e89825UL,
    0xae8b8873UL, 0x1637ef16UL, 0x048240f8UL, 0xbc3e279dUL, 0x21e91f24UL,
    0x99557841UL, 0x8be0d7afUL, 0x335cb0caUL, 0xed59b63bUL, 0x55e5d15eUL,
    0x47507eb0UL, 0xffec19d5UL, 0x623b216cUL, 0xda874609UL, 0xc832e9e7UL,
    0x708e8e82UL, 0x28ed9ed4UL, 0x9051f9b1UL, 0x82e4565fUL, 0x3a58313aUL,
    0xa78f0983UL, 0x1f336ee6UL, 0x0d86c108UL, 0xb53aa66dUL, 0xbd40e1a4UL,
    0x05fc86c1UL, 0x1749292fUL, 0xaff54e4aUL, 0x322276f3UL, 0x8a9e1196UL,
    0x982bbe78UL, 0x2097d91dUL, 0x78f4c94bUL, 0xc048ae2eUL, 0xd2fd01c0UL,
    0x6a4166a5UL, 0xf7965e1cUL, 0x4f2a3979UL, 0x5d9f9697UL, 0xe523f1f2UL,
    0x4d6b1905UL, 0xf5d77e60UL, 0xe762d18eUL, 0x5fdeb6ebUL, 0xc2098e52UL,
    0x7ab5e937UL, 0x680046d9UL, 0xd0bc21bcUL, 0x88df31eaUL, 0x3063568fUL,
    0x22d6f961UL, 0x9a6a9e04UL, 0x07bda6bdUL, 0xbf01c1d8UL, 0xadb46e36UL,
    0x15080953UL, 0x1d724e9aUL, 0xa5ce29ffUL, 0xb77b8611UL, 0x0fc7e174UL,
    0x9210d9cdUL, 0x2aacbea8UL, 0x38191146UL, 0x80a57623UL, 0xd8c66675UL,
    0x607a0110UL, 0x72cfaefeUL, 0xca73c99bUL, 0x57a4f122UL, 0xef189647UL,
    0xfdad39a9UL, 0x45115eccUL, 0x764dee06UL, 0xcef18963UL, 0xdc44268dUL,
    0x64f841e8UL, 0xf92f7951UL, 0x41931e34UL, 0x5326b1daUL, 0xeb9ad6bfUL,
    0xb3f9c6e9UL, 0x0b45a18cUL, 0x19f00e62UL, 0xa14c6907UL, 0x3c9b51beUL,
    0x842736dbUL, 0x96929935UL, 0x2e2efe50UL, 0x2654b999UL, 0x9ee8defcUL,
    0x8c5d7112UL, 0x34e11677UL, 0xa9362eceUL, 0x118a49abUL, 0x033fe645UL,
    0xbb838120UL, 0xe3e09176UL, 0x5b5cf613UL, 0x49e959fdUL, 0xf1553e98UL,
    0x6c820621UL, 0xd43e6144UL, 0xc68bceaaUL, 0x7e37a9cfUL, 0xd67f4138UL,
    0x6ec3265dUL, 0x7c7689b3UL, 0xc4caeed6UL, 0x591dd66fUL, 0xe1a1b10aUL,
    0xf3141ee4UL, 0x4ba87981UL, 0x13cb69d7UL, 0xab770eb2UL, 0xb9c2a15cUL,
    0x017ec639UL, 0x9ca9fe80UL, 0x241599e5UL, 0x36a0360bUL, 0x8e1c516eUL,
    0x866616a7UL, 0x3eda71c2UL, 0x2c6fde2cUL, 0x94d3b949UL, 0x090481f0UL,
    0xb1b8e695UL, 0xa30d497bUL, 0x1bb12e1eUL, 0x43d23e48UL, 0xfb6e592dUL,
    0xe9dbf6c3UL, 0x516791a6UL, 0xccb0a91fUL, 0x740cce7aUL, 0x66b96194UL,
    0xde0506f1UL
  },
  {
    0x00000000UL, 0x96300777UL, 0x2c610eeeUL, 0xba510999UL, 0x19c46d07UL,
    0x8ff46a70UL, 0x35a563e9UL, 0xa395649eUL, 0x3288db0eUL, 0xa4b8dc79UL,
    0x1ee9d5e0UL, 0x88d9d297UL, 0x2b4cb609UL, 0xbd7cb17eUL, 0x072db8e7UL,
    0x911dbf90UL, 0x6410b71dUL, 0xf220b06aUL, 0x4871b9f3UL, 0xde41be84UL,
    0x7dd4da1aUL, 0xebe4dd6dUL, 0x51b5d4f4UL, 0xc785d383UL, 0x56986c13UL,
    0xc0a86b64UL, 0x7af962fdUL, 0xecc9658aUL, 0x4f5c0114UL, 0xd96c0663UL,
    0x633d0ffaUL, 0xf50d088dUL, 0xc8206e3bUL, 0x5e10694cUL, 0xe44160d5UL,
    0x727167a2UL, 0xd1e4033cUL, 0x47d4044bUL, 0xfd850dd2UL, 0x6bb50aa5UL,
    0xfaa8b535UL, 0x6c98b242UL, 0xd6c9bbdbUL, 0x40f9bcacUL, 0xe36cd832UL,
    0x755cdf45UL, 0xcf0dd6dcUL, 0x593dd1abUL, 0xac30d926UL, 0x3a00de51UL,
    0x8051d7c8UL, 0x1661d0bfUL, 0xb5f4b421UL, 0x23c4b356UL, 0x9995bacfUL,
    0x0fa5bdb8UL, 0x9eb80228UL, 0x0888055fUL, 0xb2d90cc6UL, 0x24e90bb1UL,
    0x877c6f2fUL, 0x114c6858UL, 0xab1d61c1UL, 0x3d2d66b6UL, 0x9041dc76UL,
    0x0671db01UL, 0xbc20d298UL, 0x2a10d5efUL, 0x8985b171UL, 0x1fb5b606UL,
    0xa5e4bf9fUL, 0x33d4b8e8UL, 0xa2c90778UL, 0x34f9000fUL, 0x8ea80996UL,
    0x18980ee1UL, 0xbb0d6a7fUL, 0x2d3d6d08UL, 0x976c6491UL, 0x015c63e6UL,
    0xf4516b6bUL, 0x62616c1cUL, 0xd8306585UL, 0x4e0062f2UL, 0xed95066cUL,
    0x7ba5011bUL, 0xc1f40882UL, 0x57c40ff5UL, 0xc6d9b065UL, 0x50e9b712UL,
    0xeab8be8bUL, 0x7c88b9fcUL, 0xdf1ddd62UL, 0x492dda15UL, 0xf37cd38cUL,
    0x654cd4fbUL, 0x5861b24dUL, 0xce51b53aUL, 0x7400bca3UL, 0xe230bbd4UL,
    0x41a5df4aUL, 0xd795d83dUL, 0x6dc4d1a4UL, 0xfbf4d6d3UL, 0x6ae96943UL,
    0xfcd96e34UL, 0x468867adUL, 0xd0b860daUL, 0x732d0444UL, 0xe51d0333UL,
    0x5f4c0aaaUL, 0xc97c0dddUL, 0x3c710550UL, 0xaa410227UL, 0x10100bbeUL,
    0x86200cc9UL, 0x25b56857UL, 0xb3856f20UL, 0x09d466b9UL, 0x9fe461ceUL,
    0x0ef9de5eUL, 0x98c9d929UL, 0x2298d0b0UL, 0xb4a8d7c7UL, 0x173db359UL,
    0x810db42eUL, 0x3b5cbdb7UL, 0xad6cbac0UL, 0x2083b8edUL, 0xb6b3bf9aUL,
    0x0ce2b603UL, 0x9ad2b174UL, 0x3947d5eaUL, 0xaf77d29dUL, 0x1526db04UL,
    0x8316dc73UL, 0x120b63e3UL, 0x843b6494UL, 0x3e6a6d0dUL, 0xa85a6a7aUL,
    0x0bcf0ee4UL, 0x9dff0993UL, 0x27ae000aUL, 0xb19e077dUL, 0x44930ff0UL,
    0xd2a30887UL, 0x68f2011eUL, 0xfec20669UL, 0x5d5762f7UL, 0xcb676580UL,
    0x71366c19UL, 0xe7066b6eUL, 0x761bd4feUL, 0xe02bd389UL, 0x5a7ada10UL,
    0xcc4add67UL, 0x6fdfb9f9UL, 0xf9efbe8eUL, 0x43beb717UL, 0xd58eb060UL,
    0xe8a3d6d6UL, 0x7e93d1a1UL, 0xc4c2d838UL, 0x52f2df4fUL, 0xf167bbd1UL,
    0x6757bca6UL, 0xdd06b53fUL, 0x4b36b248UL, 0xda2b0dd8UL, 0x4c1b0aafUL,
    0xf64a0336UL, 0x607a0441UL, 0xc3ef60dfUL, 0x55df67a8UL, 0xef8e6e31UL,
    0x79be6946UL, 0x8cb361cbUL, 0x1a8366bcUL, 0xa0d26f25UL, 0x36e26852UL,
    0x95770cccUL, 0x03470bbbUL, 0xb9160222UL, 0x2f260555UL, 0xbe3bbac5UL,
    0x280bbdb2UL, 0x925ab42bUL, 0x046ab35cUL, 0xa7ffd7c2UL, 0x31cfd0b5UL,
    0x8b9ed92cUL, 0x1daede5bUL, 0xb0c2649bUL, 0x26f263ecUL, 0x9ca36a75UL,
    0x0a936d02UL, 0xa906099cUL, 0x3f360eebUL, 0x85670772UL, 0x13570005UL,
    0x824abf95UL, 0x147ab8e2UL, 0xae2bb17bUL, 0x381bb60cUL, 0x9b8ed292UL,
    0x0dbed5e5UL, 0xb7efdc7cUL, 0x21dfdb0bUL, 0xd4d2d386UL, 0x42e2d4f1UL,
    0xf8b3dd68UL, 0x6e83da1fUL, 0xcd16be81UL, 0x5b26b9f6UL, 0xe177b06fUL,
    0x7747b718UL, 0xe65a0888UL, 0x706a0fffUL, 0xca3b0666UL, 0x5c0b0111UL,
    0xff9e658fUL, 0x69ae62f8UL, 0xd3ff6b61UL, 0x45cf6c16UL, 0x78e20aa0UL,
    0xeed20dd7UL, 0x5483044eUL, 0xc2b30339UL, 0x612667a7UL, 0xf71660d0UL,
    0x4d476949UL, 0xdb776e3eUL, 0x4a6ad1aeUL, 0xdc5ad6d9UL, 0x660bdf40UL,
    0xf03bd837UL, 0x53aebca9UL, 0xc59ebbdeUL, 0x7fcfb247UL, 0xe9ffb530UL,
    0x1cf2bdbdUL, 0x8ac2bacaUL, 0x3093b353UL, 0xa6a3b424UL, 0x0536d0baUL,
    0x9306d7cdUL, 0x2957de54UL, 0xbf67d923UL, 0x2e7a66b3UL, 0xb84a61c4UL,
    0x021b685dUL, 0x942b6f2aUL, 0x37be0bb4UL, 0xa18e0cc3UL, 0x1bdf055aUL,
    0x8def022dUL
  },
  {
    0x00000000UL, 0x41311b19UL, 0x82623632UL, 0xc3532d2bUL, 0x04c56c64UL,
    0x45f4777dUL, 0x86a75a56UL, 0xc796414fUL, 0x088ad9c8UL, 0x49bbc2d1UL,
    0x8ae8effaUL, 0xcbd9f4e3UL, 0x0c4fb5acUL, 0x4d7eaeb5UL, 0x8e2d839eUL,
    0xcf1c9887UL, 0x5112c24aUL, 0x1023d953UL, 0xd370f478UL, 0x9241ef61UL,
    0x55d7ae2eUL, 0x14e6b537UL, 0xd7b5981cUL, 0x96848305UL, 0x59981b82UL,
    0x18a9009bUL, 0xdbfa2db0UL, 0x9acb36a9UL, 0x5d5d77e6UL, 0x1c6c6cffUL,
    0xdf3f41d4UL, 0x9e0e5acdUL, 0xa2248495UL, 0xe3159f8cUL, 0x2046b2a7UL,
    0x6177a9beUL, 0xa6e1e8f1UL, 0xe7d0f3e8UL, 0x2483dec3UL, 0x65b2c5daUL,
    0xaaae5d5dUL, 0xeb9f4644UL, 0x28cc6b6fUL, 0x69fd7076UL, 0xae6b3139UL,
    0xef5a2a20UL, 0x2c09070bUL, 0x6d381c12UL, 0xf33646dfUL, 0xb2075dc6UL,
    0x715470edUL, 0x30656bf4UL, 0xf7f32abbUL, 0xb6c231a2UL, 0x75911c89UL,
    0x34a00790UL, 0xfbbc9f17UL, 0xba8d840eUL, 0x79dea925UL, 0x38efb23cUL,
    0xff79f373UL, 0xbe48e86aUL, 0x7d1bc541UL, 0x3c2ade58UL, 0x054f79f0UL,
    0x447e62e9UL, 0x872d4fc2UL, 0xc61c54dbUL, 0x018a1594UL, 0x40bb0e8dUL,
    0x83e823a6UL, 0xc2d938bfUL, 0x0dc5a038UL, 0x4cf4bb21UL, 0x8fa7960aUL,
    0xce968d13UL, 0x0900cc5cUL, 0x4831d745UL, 0x8b62fa6eUL, 0xca53e177UL,
    0x545dbbbaUL, 0x156ca0a3UL, 0xd63f8d88UL, 0x970e9691UL, 0x5098d7deUL,
    0x11a9ccc7UL, 0xd2fae1ecUL, 0x93cbfaf5UL, 0x5cd76272UL, 0x1de6796bUL,
    0xdeb55440UL, 0x9f844f59UL, 0x58120e16UL, 0x1923150fUL, 0xda703824UL,
    0x9b41233dUL, 0xa76bfd65UL, 0xe65ae67cUL, 0x2509cb57UL, 0x6438d04eUL,
    0xa3ae9101UL, 0xe29f8a18UL, 0x21cca733UL, 0x60fdbc2aUL, 0xafe124adUL,
    0xeed03fb4UL, 0x2d83129fUL, 0x6cb20986UL, 0xab2448c9UL, 0xea1553d0UL,
    0x29467efbUL, 0x687765e2UL, 0xf6793f2fUL, 0xb7482436UL, 0x741b091dUL,
    0x352a1204UL, 0xf2bc534bUL, 0xb38d4852UL, 0x70de6579UL, 0x31ef7e60UL,
    0xfef3e6e7UL, 0xbfc2fdfeUL, 0x7c91d0d5UL, 0x3da0cbccUL, 0xfa368a83UL,
    0xbb07919aUL, 0x7854bcb1UL, 0x3965a7a8UL, 0x4b98833bUL, 0x0aa99822UL,
    0xc9fab509UL, 0x88cbae10UL, 0x4f5def5fUL, 0x0e6cf446UL, 0xcd3fd96dUL,
    0x8c0ec274UL, 0x43125af3UL, 0x022341eaUL, 0xc1706cc1UL, 0x804177d8UL,
    0x47d73697UL, 0x06e62d8eUL, 0xc5b500a5UL, 0x84841bbcUL, 0x1a8a4171UL,
    0x5bbb5a68UL, 0x98e87743UL, 0xd9d96c5aUL, 0x1e4f2d15UL, 0x5f7e360cUL,
    0x9c2d1b27UL, 0xdd1c003eUL, 0x120098b9UL, 0x533183a0UL, 0x9062ae8bUL,
    0xd153b592UL, 0x16c5f4ddUL, 0x57f4efc4UL, 0x94a7c2efUL, 0xd596d9f6UL,
    0xe9bc07aeUL, 0xa88d1cb7UL, 0x6bde319cUL, 0x2aef2a85UL, 0xed796bcaUL,
    0xac4870d3UL, 0x6f1b5df8UL, 0x2e2a46e1UL, 0xe136de66UL, 0xa007c57fUL,
    0x6354e854UL, 0x2265f34dUL, 0xe5f3b202UL, 0xa4c2a91bUL, 0x67918430UL,
    0x26a09f29UL, 0xb8aec5e4UL, 0xf99fdefdUL, 0x3accf3d6UL, 0x7bfde8cfUL,
    0xbc6ba980UL, 0xfd5ab299UL, 0x3e099fb2UL, 0x7f3884abUL, 0xb0241c2cUL,
    0xf1150735UL, 0x32462a1eUL, 0x73773107UL, 0xb4e17048UL, 0xf5d06b51UL,
    0x3683467aUL, 0x77b25d63UL, 0x4ed7facbUL, 0x0fe6e1d2UL, 0xccb5ccf9UL,
    0x8d84d7e0UL, 0x4a1296afUL, 0x0b238db6UL, 0xc870a09dUL, 0x8941bb84UL,
    0x465d2303UL, 0x076c381aUL, 0xc43f1531UL, 0x850e0e28UL, 0x42984f67UL,
    0x03a9547eUL, 0xc0fa7955UL, 0x81cb624cUL, 0x1fc53881UL, 0x5ef42398UL,
    0x9da70eb3UL, 0xdc9615aaUL, 0x1b0054e5UL, 0x5a314ffcUL, 0x996262d7UL,
    0xd85379ceUL, 0x174fe149UL, 0x567efa50UL, 0x952dd77bUL, 0xd41ccc62UL,
    0x138a8d2dUL, 0x52bb9634UL, 0x91e8bb1fUL, 0xd0d9a006UL, 0xecf37e5eUL,
    0xadc26547UL, 0x6e91486cUL, 0x2fa05375UL, 0xe836123aUL, 0xa9070923UL,
    0x6a542408UL, 0x2b653f11UL, 0xe479a796UL, 0xa548bc8fUL, 0x661b91a4UL,
    0x272a8abdUL, 0xe0bccbf2UL, 0xa18dd0ebUL, 0x62defdc0UL, 0x23efe6d9UL,
    0xbde1bc14UL, 0xfcd0a70dUL, 0x3f838a26UL, 0x7eb2913fUL, 0xb924d070UL,
    0xf815cb69UL, 0x3b46e642UL, 0x7a77fd5bUL, 0xb56b65dcUL, 0xf45a7ec5UL,
    0x370953eeUL, 0x763848f7UL, 0xb1ae09b8UL, 0xf09f12a1UL, 0x33cc3f8aUL,
    0x72fd2493UL
  },
  {
    0x00000000UL, 0x376ac201UL, 0x6ed48403UL, 0x59be4602UL, 0xdca80907UL,
    0xebc2cb06UL, 0xb27c8d04UL, 0x85164f05UL, 0xb851130eUL, 0x8f3bd10fUL,
    0xd685970dUL, 0xe1ef550cUL, 0x64f91a09UL, 0x5393d808UL, 0x0a2d9e0aUL,
    0x3d475c0bUL, 0x70a3261cUL, 0x47c9e41dUL, 0x1e77a21fUL, 0x291d601eUL,
    0xac0b2f1bUL, 0x9b61ed1aUL, 0xc2dfab18UL, 0xf5b56919UL, 0xc8f23512UL,
    0xff98f713UL, 0xa626b111UL, 0x914c7310UL, 0x145a3c15UL, 0x2330fe14UL,
    0x7a8eb816UL, 0x4de47a17UL, 0xe0464d38UL, 0xd72c8f39UL, 0x8e92c93bUL,
    0xb9f80b3aUL, 0x3cee443fUL, 0x0b84863eUL, 0x523ac03cUL, 0x6550023dUL,
    0x58175e36UL, 0x6f7d9c37UL, 0x36c3da35UL, 0x01a91834UL, 0x84bf5731UL,
    0xb3d59530UL, 0xea6bd332UL, 0xdd011133UL, 0x90e56b24UL, 0xa78fa925UL,
    0xfe31ef27UL, 0xc95b2d26UL, 0x4c4d6223UL, 0x7b27a022UL, 0x2299e620UL,
    0x15f32421UL, 0x28b4782aUL, 0x1fdeba2bUL, 0x4660fc29UL, 0x710a3e28UL,
    0xf41c712dUL, 0xc376b32cUL, 0x9ac8f52eUL, 0xada2372fUL, 0xc08d9a70UL,
    0xf7e75871UL, 0xae591e73UL, 0x9933dc72UL, 0x1c259377UL, 0x2b4f5176UL,
    0x72f11774UL, 0x459bd575UL, 0x78dc897eUL, 0x4fb64b7fUL, 0x16080d7dUL,
    0x2162cf7cUL, 0xa4748079UL, 0x931e4278UL, 0xcaa0047aUL, 0xfdcac67bUL,
    0xb02ebc6cUL, 0x87447e6dUL, 0xdefa386fUL, 0xe990fa6eUL, 0x6c86b56bUL,
    0x5bec776aUL, 0x02523168UL, 0x3538f369UL, 0x087faf62UL, 0x3f156d63UL,
    0x66ab2b61UL, 0x51c1e960UL, 0xd4d7a665UL, 0xe3bd6464UL, 0xba032266UL,
    0x8d69e067UL, 0x20cbd748UL, 0x17a11549UL, 0x4e1f534bUL, 0x7975914aUL,
    0xfc63de4fUL, 0xcb091c4eUL, 0x92b75a4cUL, 0xa5dd984dUL, 0x989ac446UL,
    0xaff00647UL, 0xf64e4045UL, 0xc1248244UL, 0x4432cd41UL, 0x73580f40UL,
    0x2ae64942UL, 0x1d8c8b43UL, 0x5068f154UL, 0x67023355UL, 0x3ebc7557UL,
    0x09d6b756UL, 0x8cc0f853UL, 0xbbaa3a52UL, 0xe2147c50UL, 0xd57ebe51UL,
    0xe839e25aUL, 0xdf53205bUL, 0x86ed6659UL, 0xb187a458UL, 0x3491eb5dUL,
    0x03fb295cUL, 0x5a456f5eUL, 0x6d2fad5fUL, 0x801b35e1UL, 0xb771f7e0UL,
    0xeecfb1e2UL, 0xd9a573e3UL, 0x5cb33ce6UL, 0x6bd9fee7UL, 0x3267b8e5UL,
    0x050d7ae4UL, 0x384a26efUL, 0x0f20e4eeUL, 0x569ea2ecUL, 0x61f460edUL,
    0xe4e22fe8UL, 0xd388ede9UL, 0x8a36abebUL, 0xbd5c69eaUL, 0xf0b813fdUL,
    0xc7d2d1fcUL, 0x9e6c97feUL, 0xa90655ffUL, 0x2c101afaUL, 0x1b7ad8fbUL,
    0x42c49ef9UL, 0x75ae5cf8UL, 0x48e900f3UL, 0x7f83c2f2UL, 0x263d84f0UL,
    0x115746f1UL, 0x944109f4UL, 0xa32bcbf5UL, 0xfa958df7UL, 0xcdff4ff6UL,
    0x605d78d9UL, 0x5737bad8UL, 0x0e89fcdaUL, 0x39e33edbUL, 0xbcf571deUL,
    0x8b9fb3dfUL, 0xd221f5ddUL, 0xe54b37dcUL, 0xd80c6bd7UL, 0xef66a9d6UL,
    0xb6d8efd4UL, 0x81b22dd5UL, 0x04a462d0UL, 0x33cea0d1UL, 0x6a70e6d3UL,
    0x5d1a24d2UL, 0x10fe5ec5UL, 0x27949cc4UL, 0x7e2adac6UL, 0x494018c7UL,
    0xcc5657c2UL, 0xfb3c95c3UL, 0xa282d3c1UL, 0x95e811c0UL, 0xa8af4dcbUL,
    0x9fc58fcaUL, 0xc67bc9c8UL, 0xf1110bc9UL, 0x740744ccUL, 0x436d86cdUL,
    0x1ad3c0cfUL, 0x2db902ceUL, 0x4096af91UL, 0x77fc6d90UL, 0x2e422b92UL,
    0x1928e993UL, 0x9c3ea696UL, 0xab546497UL, 0xf2ea2295UL, 0xc580e094UL,
    0xf8c7bc9fUL, 0xcfad7e9eUL, 0x9613389cUL, 0xa179fa9dUL, 0x246fb598UL,
    0x13057799UL, 0x4abb319bUL, 0x7dd1f39aUL, 0x3035898dUL, 0x075f4b8cUL,
    0x5ee10d8eUL, 0x698bcf8fUL, 0xec9d808aUL, 0xdbf7428bUL, 0x82490489UL,
    0xb523c688UL, 0x88649a83UL, 0xbf0e5882UL, 0xe6b01e80UL, 0xd1dadc81UL,
    0x54cc9384UL, 0x63a65185UL, 0x3a181787UL, 0x0d72d586UL, 0xa0d0e2a9UL,
    0x97ba20a8UL, 0xce0466aaUL, 0xf96ea4abUL, 0x7c78ebaeUL, 0x4b1229afUL,
    0x12ac6fadUL, 0x25c6adacUL, 0x1881f1a7UL, 0x2feb33a6UL, 0x765575a4UL,
    0x413fb7a5UL, 0xc429f8a0UL, 0xf3433aa1UL, 0xaafd7ca3UL, 0x9d97bea2UL,
    0xd073c4b5UL, 0xe71906b4UL, 0xbea740b6UL, 0x89cd82b7UL, 0x0cdbcdb2UL,
    0x3bb10fb3UL, 0x620f49b1UL, 0x55658bb0UL, 0x6822d7bbUL, 0x5f4815baUL,
    0x06f653b8UL, 0x319c91b9UL, 0xb48adebcUL, 0x83e01cbdUL, 0xda5e5abfUL,
    0xed3498beUL
  },
  {
    0x00000000UL, 0x6567bcb8UL, 0x8bc809aaUL, 0xeeafb512UL, 0x5797628fUL,
    0x32f0de37UL, 0xdc5f6b25UL, 0xb938d79dUL, 0xef28b4c5UL, 0x8a4f087dUL,
    0x64e0bd6fUL, 0x018701d7UL, 0xb8bfd64aUL, 0xddd86af2UL, 0x3377dfe0UL,
    0x56106358UL, 0x9f571950UL, 0xfa30a5e8UL, 0x149f10faUL, 0x71f8ac42UL,
    0xc8c07bdfUL, 0xada7c767UL, 0x43087275UL, 0x266fcecdUL, 0x707fad95UL,
    0x1518112dUL, 0xfbb7a43fUL, 0x9ed01887UL, 0x27e8cf1aUL, 0x428f73a2UL,
    0xac20c6b0UL, 0xc9477a08UL, 0x3eaf32a0UL, 0x5bc88e18UL, 0xb5673b0aUL,
    0xd00087b2UL, 0x6938502fUL, 0x0c5fec97UL, 0xe2f05985UL, 0x8797e53dUL,
    0xd1878665UL, 0xb4e03addUL, 0x5a4f8fcfUL, 0x3f283377UL, 0x8610e4eaUL,
    0xe3775852UL, 0x0dd8ed40UL, 0x68bf51f8UL, 0xa1f82bf0UL, 0xc49f9748UL,
    0x2a30225aUL, 0x4f579ee2UL, 0xf66f497fUL, 0x9308f5c7UL, 0x7da740d5UL,
    0x18c0fc6dUL, 0x4ed09f35UL, 0x2bb7238dUL, 0xc518969fUL, 0xa07f2a27UL,
    0x1947fdbaUL, 0x7c204102UL, 0x928ff410UL, 0xf7e848a8UL, 0x3d58149bUL,
    0x583fa823UL, 0xb6901d31UL, 0xd3f7a189UL, 0x6acf7614UL, 0x0fa8caacUL,
    0xe1077fbeUL, 0x8460c306UL, 0xd270a05eUL, 0xb7171ce6UL, 0x59b8a9f4UL,
    0x3cdf154cUL, 0x85e7c2d1UL, 0xe0807e69UL, 0x0e2fcb7bUL, 0x6b4877c3UL,
    0xa20f0dcbUL, 0xc768b173UL, 0x29c70461UL, 0x4ca0b8d9UL, 0xf5986f44UL,
    0x90ffd3fcUL, 0x7e5066eeUL, 0x1b37da56UL, 0x4d27b90eUL, 0x284005b6UL,
    0xc6efb0a4UL, 0xa3880c1cUL, 0x1ab0db81UL, 0x7fd76739UL, 0x9178d22bUL,
    0xf41f6e93UL, 0x03f7263bUL, 0x66909a83UL, 0x883f2f91UL, 0xed589329UL,
    0x546044b4UL, 0x3107f80cUL, 0xdfa84d1eUL, 0xbacff1a6UL, 0xecdf92feUL,
    0x89b82e46UL, 0x67179b54UL, 0x027027ecUL, 0xbb48f071UL, 0xde2f4cc9UL,
    0x3080f9dbUL, 0x55e74563UL, 0x9ca03f6bUL, 0xf9c783d3UL, 0x176836c1UL,
    0x720f8a79UL, 0xcb375de4UL, 0xae50e15cUL, 0x40ff544eUL, 0x2598e8f6UL,
    0x73888baeUL, 0x16ef3716UL, 0xf8408204UL, 0x9d273ebcUL, 0x241fe921UL,
    0x41785599UL, 0xafd7e08bUL, 0xcab05c33UL, 0x3bb659edUL, 0x5ed1e555UL,
    0xb07e5047UL, 0xd519ecffUL, 0x6c213b62UL, 0x094687daUL, 0xe7e932c8UL,
    0x828e8e70UL, 0xd49eed28UL, 0xb1f95190UL, 0x5f56e482UL, 0x3a31583aUL,
    0x83098fa7UL, 0xe66e331fUL, 0x08c1860dUL, 0x6da63ab5UL, 0xa4e140bdUL,
    0xc186fc05UL, 0x2f294917UL, 0x4a4ef5afUL, 0xf3762232UL, 0x96119e8aUL,
    0x78be2b98UL, 0x1dd99720UL, 0x4bc9f478UL, 0x2eae48c0UL, 0xc001fdd2UL,
    0xa566416aUL, 0x1c5e96f7UL, 0x79392a4fUL, 0x97969f5dUL, 0xf2f123e5UL,
    0x05196b4dUL, 0x607ed7f5UL, 0x8ed162e7UL, 0xebb6de5fUL, 0x528e09c2UL,
    0x37e9b57aUL, 0xd9460068UL, 0xbc21bcd0UL, 0xea31df88UL, 0x8f566330UL,
    0x61f9d622UL, 0x049e6a9aUL, 0xbda6bd07UL, 0xd8c101bfUL, 0x366eb4adUL,
    0x53090815UL, 0x9a4e721dUL, 0xff29cea5UL, 0x11867bb7UL, 0x74e1c70fUL,
    0xcdd91092UL, 0xa8beac2aUL, 0x46111938UL, 0x2376a580UL, 0x7566c6d8UL,
    0x10017a60UL, 0xfeaecf72UL, 0x9bc973caUL, 0x22f1a457UL, 0x479618efUL,
    0xa939adfdUL, 0xcc5e1145UL, 0x06ee4d76UL, 0x6389f1ceUL, 0x8d2644dcUL,
    0xe841f864UL, 0x51792ff9UL, 0x341e9341UL, 0xdab12653UL, 0xbfd69aebUL,
    0xe9c6f9b3UL, 0x8ca1450bUL, 0x620ef019UL, 0x07694ca1UL, 0xbe519b3cUL,
    0xdb362784UL, 0x35999296UL, 0x50fe2e2eUL, 0x99b95426UL, 0xfcdee89eUL,
    0x12715d8cUL, 0x7716e134UL, 0xce2e36a9UL, 0xab498a11UL, 0x45e63f03UL,
    0x208183bbUL, 0x7691e0e3UL, 0x13f65c5bUL, 0xfd59e949UL, 0x983e55f1UL,
    0x2106826cUL, 0x44613ed4UL, 0xaace8bc6UL, 0xcfa9377eUL, 0x38417fd6UL,
    0x5d26c36eUL, 0xb389767cUL, 0xd6eecac4UL, 0x6fd61d59UL, 0x0ab1a1e1UL,
    0xe41e14f3UL, 0x8179a84bUL, 0xd769cb13UL, 0xb20e77abUL, 0x5ca1c2b9UL,
    0x39c67e01UL, 0x80fea99cUL, 0xe5991524UL, 0x0b36a036UL, 0x6e511c8eUL,
    0xa7166686UL, 0xc271da3eUL, 0x2cde6f2cUL, 0x49b9d394UL, 0xf0810409UL,
    0x95e6b8b1UL, 0x7b490da3UL, 0x1e2eb11bUL, 0x483ed243UL, 0x2d596efbUL,
    0xc3f6dbe9UL, 0xa6916751UL, 0x1fa9b0ccUL, 0x7ace0c74UL, 0x9461b966UL,
    0xf10605deUL
#endif
  }
};

```

`efiXloader/3rd/uefitool/common/zlib/deflate.c`:

```c
/* deflate.c -- compress data using the deflation algorithm
 * Copyright (C) 1995-2017 Jean-loup Gailly and Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/*
 *  ALGORITHM
 *
 *      The "deflation" process depends on being able to identify portions
 *      of the input text which are identical to earlier input (within a
 *      sliding window trailing behind the input currently being processed).
 *
 *      The most straightforward technique turns out to be the fastest for
 *      most input files: try all possible matches and select the longest.
 *      The key feature of this algorithm is that insertions into the string
 *      dictionary are very simple and thus fast, and deletions are avoided
 *      completely. Insertions are performed at each input character, whereas
 *      string matches are performed only when the previous match ends. So it
 *      is preferable to spend more time in matches to allow very fast string
 *      insertions and avoid deletions. The matching algorithm for small
 *      strings is inspired from that of Rabin & Karp. A brute force approach
 *      is used to find longer strings when a small match has been found.
 *      A similar algorithm is used in comic (by Jan-Mark Wams) and freeze
 *      (by Leonid Broukhis).
 *         A previous version of this file used a more sophisticated algorithm
 *      (by Fiala and Greene) which is guaranteed to run in linear amortized
 *      time, but has a larger average cost, uses more memory and is patented.
 *      However the F&G algorithm may be faster for some highly redundant
 *      files if the parameter max_chain_length (described below) is too large.
 *
 *  ACKNOWLEDGEMENTS
 *
 *      The idea of lazy evaluation of matches is due to Jan-Mark Wams, and
 *      I found it in 'freeze' written by Leonid Broukhis.
 *      Thanks to many people for bug reports and testing.
 *
 *  REFERENCES
 *
 *      Deutsch, L.P.,"DEFLATE Compressed Data Format Specification".
 *      Available in http://tools.ietf.org/html/rfc1951
 *
 *      A description of the Rabin and Karp algorithm is given in the book
 *         "Algorithms" by R. Sedgewick, Addison-Wesley, p252.
 *
 *      Fiala,E.R., and Greene,D.H.
 *         Data Compression with Finite Windows, Comm.ACM, 32,4 (1989) 490-595
 *
 */

/* @(#) $Id$ */

#include "deflate.h"

const char deflate_copyright[] =
   " deflate 1.2.11 Copyright 1995-2017 Jean-loup Gailly and Mark Adler ";
/*
  If you use the zlib library in a product, an acknowledgment is welcome
  in the documentation of your product. If for some reason you cannot
  include such an acknowledgment, I would appreciate that you keep this
  copyright string in the executable of your product.
 */

/* ===========================================================================
 *  Function prototypes.
 */
typedef enum {
    need_more,      /* block not completed, need more input or more output */
    block_done,     /* block flush performed */
    finish_started, /* finish started, need only more output at next deflate */
    finish_done     /* finish done, accept no more input or output */
} block_state;

typedef block_state (*compress_func) OF((deflate_state *s, int flush));
/* Compression function. Returns the block state after the call. */

local int deflateStateCheck      OF((z_streamp strm));
local void slide_hash     OF((deflate_state *s));
local void fill_window    OF((deflate_state *s));
local block_state deflate_stored OF((deflate_state *s, int flush));
local block_state deflate_fast   OF((deflate_state *s, int flush));
#ifndef FASTEST
local block_state deflate_slow   OF((deflate_state *s, int flush));
#endif
local block_state deflate_rle    OF((deflate_state *s, int flush));
local block_state deflate_huff   OF((deflate_state *s, int flush));
local void lm_init        OF((deflate_state *s));
local void putShortMSB    OF((deflate_state *s, uInt b));
local void flush_pending  OF((z_streamp strm));
local unsigned read_buf   OF((z_streamp strm, Bytef *buf, unsigned size));
#ifdef ASMV
#  pragma message("Assembler code may have bugs -- use at your own risk")
      void match_init OF((void)); /* asm code initialization */
      uInt longest_match  OF((deflate_state *s, IPos cur_match));
#else
local uInt longest_match  OF((deflate_state *s, IPos cur_match));
#endif

#ifdef ZLIB_DEBUG
local  void check_match OF((deflate_state *s, IPos start, IPos match,
                            int length));
#endif

/* ===========================================================================
 * Local data
 */

#define NIL 0
/* Tail of hash chains */

#ifndef TOO_FAR
#  define TOO_FAR 4096
#endif
/* Matches of length 3 are discarded if their distance exceeds TOO_FAR */

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
typedef struct config_s {
   ush good_length; /* reduce lazy search above this match length */
   ush max_lazy;    /* do not perform lazy search above this match length */
   ush nice_length; /* quit search above this match length */
   ush max_chain;
   compress_func func;
} config;

#ifdef FASTEST
local const config configuration_table[2] = {
/*      good lazy nice chain */
/* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */
/* 1 */ {4,    4,  8,    4, deflate_fast}}; /* max speed, no lazy matches */
#else
local const config configuration_table[10] = {
/*      good lazy nice chain */
/* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */
/* 1 */ {4,    4,  8,    4, deflate_fast}, /* max speed, no lazy matches */
/* 2 */ {4,    5, 16,    8, deflate_fast},
/* 3 */ {4,    6, 32,   32, deflate_fast},

/* 4 */ {4,    4, 16,   16, deflate_slow},  /* lazy matches */
/* 5 */ {8,   16, 32,   32, deflate_slow},
/* 6 */ {8,   16, 128, 128, deflate_slow},
/* 7 */ {8,   32, 128, 256, deflate_slow},
/* 8 */ {32, 128, 258, 1024, deflate_slow},
/* 9 */ {32, 258, 258, 4096, deflate_slow}}; /* max compression */
#endif

/* Note: the deflate() code requires max_lazy >= MIN_MATCH and max_chain >= 4
 * For deflate_fast() (levels <= 3) good is ignored and lazy has a different
 * meaning.
 */

/* rank Z_BLOCK between Z_NO_FLUSH and Z_PARTIAL_FLUSH */
#define RANK(f) (((f) * 2) - ((f) > 4 ? 9 : 0))

/* ===========================================================================
 * Update a hash value with the given input byte
 * IN  assertion: all calls to UPDATE_HASH are made with consecutive input
 *    characters, so that a running hash key can be computed from the previous
 *    key instead of complete recalculation each time.
 */
#define UPDATE_HASH(s,h,c) (h = (((h)<<s->hash_shift) ^ (c)) & s->hash_mask)


/* ===========================================================================
 * Insert string str in the dictionary and set match_head to the previous head
 * of the hash chain (the most recent string with same hash key). Return
 * the previous length of the hash chain.
 * If this file is compiled with -DFASTEST, the compression level is forced
 * to 1, and no hash chains are maintained.
 * IN  assertion: all calls to INSERT_STRING are made with consecutive input
 *    characters and the first MIN_MATCH bytes of str are valid (except for
 *    the last MIN_MATCH-1 bytes of the input file).
 */
#ifdef FASTEST
#define INSERT_STRING(s, str, match_head) \
   (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \
    match_head = s->head[s->ins_h], \
    s->head[s->ins_h] = (Pos)(str))
#else
#define INSERT_STRING(s, str, match_head) \
   (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \
    match_head = s->prev[(str) & s->w_mask] = s->head[s->ins_h], \
    s->head[s->ins_h] = (Pos)(str))
#endif

/* ===========================================================================
 * Initialize the hash table (avoiding 64K overflow for 16 bit systems).
 * prev[] will be initialized on the fly.
 */
#define CLEAR_HASH(s) \
    do { \
        s->head[s->hash_size-1] = NIL; \
        zmemzero((Bytef *)s->head, \
                 (unsigned)(s->hash_size-1)*sizeof(*s->head)); \
    } while (0)

/* ===========================================================================
 * Slide the hash table when sliding the window down (could be avoided with 32
 * bit values at the expense of memory usage). We slide even when level == 0 to
 * keep the hash table consistent if we switch back to level > 0 later.
 */
local void slide_hash(s)
    deflate_state *s;
{
    unsigned n, m;
    Posf *p;
    uInt wsize = s->w_size;

    n = s->hash_size;
    p = &s->head[n];
    do {
        m = *--p;
        *p = (Pos)(m >= wsize ? m - wsize : NIL);
    } while (--n);
    n = wsize;
#ifndef FASTEST
    p = &s->prev[n];
    do {
        m = *--p;
        *p = (Pos)(m >= wsize ? m - wsize : NIL);
        /* If n is not on any hash chain, prev[n] is garbage but
         * its value will never be used.
         */
    } while (--n);
#endif
}

/* ========================================================================= */
int ZEXPORT deflateInit_(strm, level, version, stream_size)
    z_streamp strm;
    int level;
    const char *version;
    int stream_size;
{
    return deflateInit2_(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL,
                         Z_DEFAULT_STRATEGY, version, stream_size);
    /* To do: ignore strm->next_in if we use it as window */
}

/* ========================================================================= */
int ZEXPORT deflateInit2_(strm, level, method, windowBits, memLevel, strategy,
                  version, stream_size)
    z_streamp strm;
    int  level;
    int  method;
    int  windowBits;
    int  memLevel;
    int  strategy;
    const char *version;
    int stream_size;
{
    deflate_state *s;
    int wrap = 1;
    static const char my_version[] = ZLIB_VERSION;

    ushf *overlay;
    /* We overlay pending_buf and d_buf+l_buf. This works since the average
     * output size for (length,distance) codes is <= 24 bits.
     */

    if (version == Z_NULL || version[0] != my_version[0] ||
        stream_size != sizeof(z_stream)) {
        return Z_VERSION_ERROR;
    }
    if (strm == Z_NULL) return Z_STREAM_ERROR;

    strm->msg = Z_NULL;
    if (strm->zalloc == (alloc_func)0) {
#ifdef Z_SOLO
        return Z_STREAM_ERROR;
#else
        strm->zalloc = zcalloc;
        strm->opaque = (voidpf)0;
#endif
    }
    if (strm->zfree == (free_func)0)
#ifdef Z_SOLO
        return Z_STREAM_ERROR;
#else
        strm->zfree = zcfree;
#endif

#ifdef FASTEST
    if (level != 0) level = 1;
#else
    if (level == Z_DEFAULT_COMPRESSION) level = 6;
#endif

    if (windowBits < 0) { /* suppress zlib wrapper */
        wrap = 0;
        windowBits = -windowBits;
    }
#ifdef GZIP
    else if (windowBits > 15) {
        wrap = 2;       /* write gzip wrapper instead */
        windowBits -= 16;
    }
#endif
    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED ||
        windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
        strategy < 0 || strategy > Z_FIXED || (windowBits == 8 && wrap != 1)) {
        return Z_STREAM_ERROR;
    }
    if (windowBits == 8) windowBits = 9;  /* until 256-byte window bug fixed */
    s = (deflate_state *) ZALLOC(strm, 1, sizeof(deflate_state));
    if (s == Z_NULL) return Z_MEM_ERROR;
    strm->state = (struct internal_state FAR *)s;
    s->strm = strm;
    s->status = INIT_STATE;     /* to pass state test in deflateReset() */

    s->wrap = wrap;
    s->gzhead = Z_NULL;
    s->w_bits = (uInt)windowBits;
    s->w_size = 1 << s->w_bits;
    s->w_mask = s->w_size - 1;

    s->hash_bits = (uInt)memLevel + 7;
    s->hash_size = 1 << s->hash_bits;
    s->hash_mask = s->hash_size - 1;
    s->hash_shift =  ((s->hash_bits+MIN_MATCH-1)/MIN_MATCH);

    s->window = (Bytef *) ZALLOC(strm, s->w_size, 2*sizeof(Byte));
    s->prev   = (Posf *)  ZALLOC(strm, s->w_size, sizeof(Pos));
    s->head   = (Posf *)  ZALLOC(strm, s->hash_size, sizeof(Pos));

    s->high_water = 0;      /* nothing written to s->window yet */

    s->lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

    overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
    s->pending_buf = (uchf *) overlay;
    s->pending_buf_size = (ulg)s->lit_bufsize * (sizeof(ush)+2L);

    if (s->window == Z_NULL || s->prev == Z_NULL || s->head == Z_NULL ||
        s->pending_buf == Z_NULL) {
        s->status = FINISH_STATE;
        strm->msg = ERR_MSG(Z_MEM_ERROR);
        deflateEnd (strm);
        return Z_MEM_ERROR;
    }
    s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
    s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;

    s->level = level;
    s->strategy = strategy;
    s->method = (Byte)method;

    return deflateReset(strm);
}

/* =========================================================================
 * Check for a valid deflate stream state. Return 0 if ok, 1 if not.
 */
local int deflateStateCheck (strm)
    z_streamp strm;
{
    deflate_state *s;
    if (strm == Z_NULL ||
        strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0)
        return 1;
    s = strm->state;
    if (s == Z_NULL || s->strm != strm || (s->status != INIT_STATE &&
#ifdef GZIP
                                           s->status != GZIP_STATE &&
#endif
                                           s->status != EXTRA_STATE &&
                                           s->status != NAME_STATE &&
                                           s->status != COMMENT_STATE &&
                                           s->status != HCRC_STATE &&
                                           s->status != BUSY_STATE &&
                                           s->status != FINISH_STATE))
        return 1;
    return 0;
}

/* ========================================================================= */
int ZEXPORT deflateSetDictionary (strm, dictionary, dictLength)
    z_streamp strm;
    const Bytef *dictionary;
    uInt  dictLength;
{
    deflate_state *s;
    uInt str, n;
    int wrap;
    unsigned avail;
    z_const unsigned char *next;

    if (deflateStateCheck(strm) || dictionary == Z_NULL)
        return Z_STREAM_ERROR;
    s = strm->state;
    wrap = s->wrap;
    if (wrap == 2 || (wrap == 1 && s->status != INIT_STATE) || s->lookahead)
        return Z_STREAM_ERROR;

    /* when using zlib wrappers, compute Adler-32 for provided dictionary */
    if (wrap == 1)
        strm->adler = adler32(strm->adler, dictionary, dictLength);
    s->wrap = 0;                    /* avoid computing Adler-32 in read_buf */

    /* if dictionary would fill window, just replace the history */
    if (dictLength >= s->w_size) {
        if (wrap == 0) {            /* already empty otherwise */
            CLEAR_HASH(s);
            s->strstart = 0;
            s->block_start = 0L;
            s->insert = 0;
        }
        dictionary += dictLength - s->w_size;  /* use the tail */
        dictLength = s->w_size;
    }

    /* insert dictionary into window and hash */
    avail = strm->avail_in;
    next = strm->next_in;
    strm->avail_in = dictLength;
    strm->next_in = (z_const Bytef *)dictionary;
    fill_window(s);
    while (s->lookahead >= MIN_MATCH) {
        str = s->strstart;
        n = s->lookahead - (MIN_MATCH-1);
        do {
            UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]);
#ifndef FASTEST
            s->prev[str & s->w_mask] = s->head[s->ins_h];
#endif
            s->head[s->ins_h] = (Pos)str;
            str++;
        } while (--n);
        s->strstart = str;
        s->lookahead = MIN_MATCH-1;
        fill_window(s);
    }
    s->strstart += s->lookahead;
    s->block_start = (long)s->strstart;
    s->insert = s->lookahead;
    s->lookahead = 0;
    s->match_length = s->prev_length = MIN_MATCH-1;
    s->match_available = 0;
    strm->next_in = next;
    strm->avail_in = avail;
    s->wrap = wrap;
    return Z_OK;
}

/* ========================================================================= */
int ZEXPORT deflateGetDictionary (strm, dictionary, dictLength)
    z_streamp strm;
    Bytef *dictionary;
    uInt  *dictLength;
{
    deflate_state *s;
    uInt len;

    if (deflateStateCheck(strm))
        return Z_STREAM_ERROR;
    s = strm->state;
    len = s->strstart + s->lookahead;
    if (len > s->w_size)
        len = s->w_size;
    if (dictionary != Z_NULL && len)
        zmemcpy(dictionary, s->window + s->strstart + s->lookahead - len, len);
    if (dictLength != Z_NULL)
        *dictLength = len;
    return Z_OK;
}

/* ========================================================================= */
int ZEXPORT deflateResetKeep (strm)
    z_streamp strm;
{
    deflate_state *s;

    if (deflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
    }

    strm->total_in = strm->total_out = 0;
    strm->msg = Z_NULL; /* use zfree if we ever allocate msg dynamically */
    strm->data_type = Z_UNKNOWN;

    s = (deflate_state *)strm->state;
    s->pending = 0;
    s->pending_out = s->pending_buf;

    if (s->wrap < 0) {
        s->wrap = -s->wrap; /* was made negative by deflate(..., Z_FINISH); */
    }
    s->status =
#ifdef GZIP
        s->wrap == 2 ? GZIP_STATE :
#endif
        s->wrap ? INIT_STATE : BUSY_STATE;
    strm->adler =
#ifdef GZIP
        s->wrap == 2 ? crc32(0L, Z_NULL, 0) :
#endif
        adler32(0L, Z_NULL, 0);
    s->last_flush = Z_NO_FLUSH;

    _tr_init(s);

    return Z_OK;
}

/* ========================================================================= */
int ZEXPORT deflateReset (strm)
    z_streamp strm;
{
    int ret;

    ret = deflateResetKeep(strm);
    if (ret == Z_OK)
        lm_init(strm->state);
    return ret;
}

/* ========================================================================= */
int ZEXPORT deflateSetHeader (strm, head)
    z_streamp strm;
    gz_headerp head;
{
    if (deflateStateCheck(strm) || strm->state->wrap != 2)
        return Z_STREAM_ERROR;
    strm->state->gzhead = head;
    return Z_OK;
}

/* ========================================================================= */
int ZEXPORT deflatePending (strm, pending, bits)
    unsigned *pending;
    int *bits;
    z_streamp strm;
{
    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;
    if (pending != Z_NULL)
        *pending = strm->state->pending;
    if (bits != Z_NULL)
        *bits = strm->state->bi_valid;
    return Z_OK;
}

/* ========================================================================= */
int ZEXPORT deflatePrime (strm, bits, value)
    z_streamp strm;
    int bits;
    int value;
{
    deflate_state *s;
    int put;

    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;
    s = strm->state;
    if ((Bytef *)(s->d_buf) < s->pending_out + ((Buf_size + 7) >> 3))
        return Z_BUF_ERROR;
    do {
        put = Buf_size - s->bi_valid;
        if (put > bits)
            put = bits;
        s->bi_buf |= (ush)((value & ((1 << put) - 1)) << s->bi_valid);
        s->bi_valid += put;
        _tr_flush_bits(s);
        value >>= put;
        bits -= put;
    } while (bits);
    return Z_OK;
}

/* ========================================================================= */
int ZEXPORT deflateParams(strm, level, strategy)
    z_streamp strm;
    int level;
    int strategy;
{
    deflate_state *s;
    compress_func func;

    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;
    s = strm->state;

#ifdef FASTEST
    if (level != 0) level = 1;
#else
    if (level == Z_DEFAULT_COMPRESSION) level = 6;
#endif
    if (level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
        return Z_STREAM_ERROR;
    }
    func = configuration_table[s->level].func;

    if ((strategy != s->strategy || func != configuration_table[level].func) &&
        s->high_water) {
        /* Flush the last buffer: */
        int err = deflate(strm, Z_BLOCK);
        if (err == Z_STREAM_ERROR)
            return err;
        if (strm->avail_out == 0)
            return Z_BUF_ERROR;
    }
    if (s->level != level) {
        if (s->level == 0 && s->matches != 0) {
            if (s->matches == 1)
                slide_hash(s);
            else
                CLEAR_HASH(s);
            s->matches = 0;
        }
        s->level = level;
        s->max_lazy_match   = configuration_table[level].max_lazy;
        s->good_match       = configuration_table[level].good_length;
        s->nice_match       = configuration_table[level].nice_length;
        s->max_chain_length = configuration_table[level].max_chain;
    }
    s->strategy = strategy;
    return Z_OK;
}

/* ========================================================================= */
int ZEXPORT deflateTune(strm, good_length, max_lazy, nice_length, max_chain)
    z_streamp strm;
    int good_length;
    int max_lazy;
    int nice_length;
    int max_chain;
{
    deflate_state *s;

    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;
    s = strm->state;
    s->good_match = (uInt)good_length;
    s->max_lazy_match = (uInt)max_lazy;
    s->nice_match = nice_length;
    s->max_chain_length = (uInt)max_chain;
    return Z_OK;
}

/* =========================================================================
 * For the default windowBits of 15 and memLevel of 8, this function returns
 * a close to exact, as well as small, upper bound on the compressed size.
 * They are coded as constants here for a reason--if the #define's are
 * changed, then this function needs to be changed as well.  The return
 * value for 15 and 8 only works for those exact settings.
 *
 * For any setting other than those defaults for windowBits and memLevel,
 * the value returned is a conservative worst case for the maximum expansion
 * resulting from using fixed blocks instead of stored blocks, which deflate
 * can emit on compressed data for some combinations of the parameters.
 *
 * This function could be more sophisticated to provide closer upper bounds for
 * every combination of windowBits and memLevel.  But even the conservative
 * upper bound of about 14% expansion does not seem onerous for output buffer
 * allocation.
 */
uLong ZEXPORT deflateBound(strm, sourceLen)
    z_streamp strm;
    uLong sourceLen;
{
    deflate_state *s;
    uLong complen, wraplen;

    /* conservative upper bound for compressed data */
    complen = sourceLen +
              ((sourceLen + 7) >> 3) + ((sourceLen + 63) >> 6) + 5;

    /* if can't get parameters, return conservative bound plus zlib wrapper */
    if (deflateStateCheck(strm))
        return complen + 6;

    /* compute wrapper length */
    s = strm->state;
    switch (s->wrap) {
    case 0:                                 /* raw deflate */
        wraplen = 0;
        break;
    case 1:                                 /* zlib wrapper */
        wraplen = 6 + (s->strstart ? 4 : 0);
        break;
#ifdef GZIP
    case 2:                                 /* gzip wrapper */
        wraplen = 18;
        if (s->gzhead != Z_NULL) {          /* user-supplied gzip header */
            Bytef *str;
            if (s->gzhead->extra != Z_NULL)
                wraplen += 2 + s->gzhead->extra_len;
            str = s->gzhead->name;
            if (str != Z_NULL)
                do {
                    wraplen++;
                } while (*str++);
            str = s->gzhead->comment;
            if (str != Z_NULL)
                do {
                    wraplen++;
                } while (*str++);
            if (s->gzhead->hcrc)
                wraplen += 2;
        }
        break;
#endif
    default:                                /* for compiler happiness */
        wraplen = 6;
    }

    /* if not default parameters, return conservative bound */
    if (s->w_bits != 15 || s->hash_bits != 8 + 7)
        return complen + wraplen;

    /* default settings: return tight bound for that case */
    return sourceLen + (sourceLen >> 12) + (sourceLen >> 14) +
           (sourceLen >> 25) + 13 - 6 + wraplen;
}

/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
local void putShortMSB (s, b)
    deflate_state *s;
    uInt b;
{
    put_byte(s, (Byte)(b >> 8));
    put_byte(s, (Byte)(b & 0xff));
}

/* =========================================================================
 * Flush as much pending output as possible. All deflate() output, except for
 * some deflate_stored() output, goes through this function so some
 * applications may wish to modify it to avoid allocating a large
 * strm->next_out buffer and copying into it. (See also read_buf()).
 */
local void flush_pending(strm)
    z_streamp strm;
{
    unsigned len;
    deflate_state *s = strm->state;

    _tr_flush_bits(s);
    len = s->pending;
    if (len > strm->avail_out) len = strm->avail_out;
    if (len == 0) return;

    zmemcpy(strm->next_out, s->pending_out, len);
    strm->next_out  += len;
    s->pending_out  += len;
    strm->total_out += len;
    strm->avail_out -= len;
    s->pending      -= len;
    if (s->pending == 0) {
        s->pending_out = s->pending_buf;
    }
}

/* ===========================================================================
 * Update the header CRC with the bytes s->pending_buf[beg..s->pending - 1].
 */
#define HCRC_UPDATE(beg) \
    do { \
        if (s->gzhead->hcrc && s->pending > (beg)) \
            strm->adler = crc32(strm->adler, s->pending_buf + (beg), \
                                s->pending - (beg)); \
    } while (0)

/* ========================================================================= */
int ZEXPORT deflate (strm, flush)
    z_streamp strm;
    int flush;
{
    int old_flush; /* value of flush param for previous deflate call */
    deflate_state *s;

    if (deflateStateCheck(strm) || flush > Z_BLOCK || flush < 0) {
        return Z_STREAM_ERROR;
    }
    s = strm->state;

    if (strm->next_out == Z_NULL ||
        (strm->avail_in != 0 && strm->next_in == Z_NULL) ||
        (s->status == FINISH_STATE && flush != Z_FINISH)) {
        ERR_RETURN(strm, Z_STREAM_ERROR);
    }
    if (strm->avail_out == 0) ERR_RETURN(strm, Z_BUF_ERROR);

    old_flush = s->last_flush;
    s->last_flush = flush;

    /* Flush as much pending output as possible */
    if (s->pending != 0) {
        flush_pending(strm);
        if (strm->avail_out == 0) {
            /* Since avail_out is 0, deflate will be called again with
             * more output space, but possibly with both pending and
             * avail_in equal to zero. There won't be anything to do,
             * but this is not an error situation so make sure we
             * return OK instead of BUF_ERROR at next call of deflate:
             */
            s->last_flush = -1;
            return Z_OK;
        }

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
    } else if (strm->avail_in == 0 && RANK(flush) <= RANK(old_flush) &&
               flush != Z_FINISH) {
        ERR_RETURN(strm, Z_BUF_ERROR);
    }

    /* User must not provide more input after the first FINISH: */
    if (s->status == FINISH_STATE && strm->avail_in != 0) {
        ERR_RETURN(strm, Z_BUF_ERROR);
    }

    /* Write the header */
    if (s->status == INIT_STATE) {
        /* zlib header */
        uInt header = (Z_DEFLATED + ((s->w_bits-8)<<4)) << 8;
        uInt level_flags;

        if (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2)
            level_flags = 0;
        else if (s->level < 6)
            level_flags = 1;
        else if (s->level == 6)
            level_flags = 2;
        else
            level_flags = 3;
        header |= (level_flags << 6);
        if (s->strstart != 0) header |= PRESET_DICT;
        header += 31 - (header % 31);

        putShortMSB(s, header);

        /* Save the adler32 of the preset dictionary: */
        if (s->strstart != 0) {
            putShortMSB(s, (uInt)(strm->adler >> 16));
            putShortMSB(s, (uInt)(strm->adler & 0xffff));
        }
        strm->adler = adler32(0L, Z_NULL, 0);
        s->status = BUSY_STATE;

        /* Compression must start with an empty pending buffer */
        flush_pending(strm);
        if (s->pending != 0) {
            s->last_flush = -1;
            return Z_OK;
        }
    }
#ifdef GZIP
    if (s->status == GZIP_STATE) {
        /* gzip header */
        strm->adler = crc32(0L, Z_NULL, 0);
        put_byte(s, 31);
        put_byte(s, 139);
        put_byte(s, 8);
        if (s->gzhead == Z_NULL) {
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, s->level == 9 ? 2 :
                     (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
                      4 : 0));
            put_byte(s, OS_CODE);
            s->status = BUSY_STATE;

            /* Compression must start with an empty pending buffer */
            flush_pending(strm);
            if (s->pending != 0) {
                s->last_flush = -1;
                return Z_OK;
            }
        }
        else {
            put_byte(s, (s->gzhead->text ? 1 : 0) +
                     (s->gzhead->hcrc ? 2 : 0) +
                     (s->gzhead->extra == Z_NULL ? 0 : 4) +
                     (s->gzhead->name == Z_NULL ? 0 : 8) +
                     (s->gzhead->comment == Z_NULL ? 0 : 16)
                     );
            put_byte(s, (Byte)(s->gzhead->time & 0xff));
            put_byte(s, (Byte)((s->gzhead->time >> 8) & 0xff));
            put_byte(s, (Byte)((s->gzhead->time >> 16) & 0xff));
            put_byte(s, (Byte)((s->gzhead->time >> 24) & 0xff));
            put_byte(s, s->level == 9 ? 2 :
                     (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
                      4 : 0));
            put_byte(s, s->gzhead->os & 0xff);
            if (s->gzhead->extra != Z_NULL) {
                put_byte(s, s->gzhead->extra_len & 0xff);
                put_byte(s, (s->gzhead->extra_len >> 8) & 0xff);
            }
            if (s->gzhead->hcrc)
                strm->adler = crc32(strm->adler, s->pending_buf,
                                    s->pending);
            s->gzindex = 0;
            s->status = EXTRA_STATE;
        }
    }
    if (s->status == EXTRA_STATE) {
        if (s->gzhead->extra != Z_NULL) {
            ulg beg = s->pending;   /* start of bytes to update crc */
            uInt left = (s->gzhead->extra_len & 0xffff) - s->gzindex;
            while (s->pending + left > s->pending_buf_size) {
                uInt copy = s->pending_buf_size - s->pending;
                zmemcpy(s->pending_buf + s->pending,
                        s->gzhead->extra + s->gzindex, copy);
                s->pending = s->pending_buf_size;
                HCRC_UPDATE(beg);
                s->gzindex += copy;
                flush_pending(strm);
                if (s->pending != 0) {
                    s->last_flush = -1;
                    return Z_OK;
                }
                beg = 0;
                left -= copy;
            }
            zmemcpy(s->pending_buf + s->pending,
                    s->gzhead->extra + s->gzindex, left);
            s->pending += left;
            HCRC_UPDATE(beg);
            s->gzindex = 0;
        }
        s->status = NAME_STATE;
    }
    if (s->status == NAME_STATE) {
        if (s->gzhead->name != Z_NULL) {
            ulg beg = s->pending;   /* start of bytes to update crc */
            int val;
            do {
                if (s->pending == s->pending_buf_size) {
                    HCRC_UPDATE(beg);
                    flush_pending(strm);
                    if (s->pending != 0) {
                        s->last_flush = -1;
                        return Z_OK;
                    }
                    beg = 0;
                }
                val = s->gzhead->name[s->gzindex++];
                put_byte(s, val);
            } while (val != 0);
            HCRC_UPDATE(beg);
            s->gzindex = 0;
        }
        s->status = COMMENT_STATE;
    }
    if (s->status == COMMENT_STATE) {
        if (s->gzhead->comment != Z_NULL) {
            ulg beg = s->pending;   /* start of bytes to update crc */
            int val;
            do {
                if (s->pending == s->pending_buf_size) {
                    HCRC_UPDATE(beg);
                    flush_pending(strm);
                    if (s->pending != 0) {
                        s->last_flush = -1;
                        return Z_OK;
                    }
                    beg = 0;
                }
                val = s->gzhead->comment[s->gzindex++];
                put_byte(s, val);
            } while (val != 0);
            HCRC_UPDATE(beg);
        }
        s->status = HCRC_STATE;
    }
    if (s->status == HCRC_STATE) {
        if (s->gzhead->hcrc) {
            if (s->pending + 2 > s->pending_buf_size) {
                flush_pending(strm);
                if (s->pending != 0) {
                    s->last_flush = -1;
                    return Z_OK;
                }
            }
            put_byte(s, (Byte)(strm->adler & 0xff));
            put_byte(s, (Byte)((strm->adler >> 8) & 0xff));
            strm->adler = crc32(0L, Z_NULL, 0);
        }
        s->status = BUSY_STATE;

        /* Compression must start with an empty pending buffer */
        flush_pending(strm);
        if (s->pending != 0) {
            s->last_flush = -1;
            return Z_OK;
        }
    }
#endif

    /* Start a new block or continue the current one.
     */
    if (strm->avail_in != 0 || s->lookahead != 0 ||
        (flush != Z_NO_FLUSH && s->status != FINISH_STATE)) {
        block_state bstate;

        bstate = s->level == 0 ? deflate_stored(s, flush) :
                 s->strategy == Z_HUFFMAN_ONLY ? deflate_huff(s, flush) :
                 s->strategy == Z_RLE ? deflate_rle(s, flush) :
                 (*(configuration_table[s->level].func))(s, flush);

        if (bstate == finish_started || bstate == finish_done) {
            s->status = FINISH_STATE;
        }
        if (bstate == need_more || bstate == finish_started) {
            if (strm->avail_out == 0) {
                s->last_flush = -1; /* avoid BUF_ERROR next call, see above */
            }
            return Z_OK;
            /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
             * of deflate should use the same flush parameter to make sure
             * that the flush is complete. So we don't have to output an
             * empty block here, this will be done at next call. This also
             * ensures that for a very small output buffer, we emit at most
             * one empty block.
             */
        }
        if (bstate == block_done) {
            if (flush == Z_PARTIAL_FLUSH) {
                _tr_align(s);
            } else if (flush != Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */
                _tr_stored_block(s, (char*)0, 0L, 0);
                /* For a full flush, this empty block will be recognized
                 * as a special marker by inflate_sync().
                 */
                if (flush == Z_FULL_FLUSH) {
                    CLEAR_HASH(s);             /* forget history */
                    if (s->lookahead == 0) {
                        s->strstart = 0;
                        s->block_start = 0L;
                        s->insert = 0;
                    }
                }
            }
            flush_pending(strm);
            if (strm->avail_out == 0) {
              s->last_flush = -1; /* avoid BUF_ERROR at next call, see above */
              return Z_OK;
            }
        }
    }

    if (flush != Z_FINISH) return Z_OK;
    if (s->wrap <= 0) return Z_STREAM_END;

    /* Write the trailer */
#ifdef GZIP
    if (s->wrap == 2) {
        put_byte(s, (Byte)(strm->adler & 0xff));
        put_byte(s, (Byte)((strm->adler >> 8) & 0xff));
        put_byte(s, (Byte)((strm->adler >> 16) & 0xff));
        put_byte(s, (Byte)((strm->adler >> 24) & 0xff));
        put_byte(s, (Byte)(strm->total_in & 0xff));
        put_byte(s, (Byte)((strm->total_in >> 8) & 0xff));
        put_byte(s, (Byte)((strm->total_in >> 16) & 0xff));
        put_byte(s, (Byte)((strm->total_in >> 24) & 0xff));
    }
    else
#endif
    {
        putShortMSB(s, (uInt)(strm->adler >> 16));
        putShortMSB(s, (uInt)(strm->adler & 0xffff));
    }
    flush_pending(strm);
    /* If avail_out is zero, the application will call deflate again
     * to flush the rest.
     */
    if (s->wrap > 0) s->wrap = -s->wrap; /* write the trailer only once! */
    return s->pending != 0 ? Z_OK : Z_STREAM_END;
}

/* ========================================================================= */
int ZEXPORT deflateEnd (strm)
    z_streamp strm;
{
    int status;

    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;

    status = strm->state->status;

    /* Deallocate in reverse order of allocations: */
    TRY_FREE(strm, strm->state->pending_buf);
    TRY_FREE(strm, strm->state->head);
    TRY_FREE(strm, strm->state->prev);
    TRY_FREE(strm, strm->state->window);

    ZFREE(strm, strm->state);
    strm->state = Z_NULL;

    return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;
}

/* =========================================================================
 * Copy the source state to the destination state.
 * To simplify the source, this is not supported for 16-bit MSDOS (which
 * doesn't have enough memory anyway to duplicate compression states).
 */
int ZEXPORT deflateCopy (dest, source)
    z_streamp dest;
    z_streamp source;
{
#ifdef MAXSEG_64K
    return Z_STREAM_ERROR;
#else
    deflate_state *ds;
    deflate_state *ss;
    ushf *overlay;


    if (deflateStateCheck(source) || dest == Z_NULL) {
        return Z_STREAM_ERROR;
    }

    ss = source->state;

    zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));

    ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));
    if (ds == Z_NULL) return Z_MEM_ERROR;
    dest->state = (struct internal_state FAR *) ds;
    zmemcpy((voidpf)ds, (voidpf)ss, sizeof(deflate_state));
    ds->strm = dest;

    ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));
    ds->prev   = (Posf *)  ZALLOC(dest, ds->w_size, sizeof(Pos));
    ds->head   = (Posf *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));
    overlay = (ushf *) ZALLOC(dest, ds->lit_bufsize, sizeof(ush)+2);
    ds->pending_buf = (uchf *) overlay;

    if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL ||
        ds->pending_buf == Z_NULL) {
        deflateEnd (dest);
        return Z_MEM_ERROR;
    }
    /* following zmemcpy do not work for 16-bit MSDOS */
    zmemcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(Byte));
    zmemcpy((voidpf)ds->prev, (voidpf)ss->prev, ds->w_size * sizeof(Pos));
    zmemcpy((voidpf)ds->head, (voidpf)ss->head, ds->hash_size * sizeof(Pos));
    zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);

    ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);
    ds->d_buf = overlay + ds->lit_bufsize/sizeof(ush);
    ds->l_buf = ds->pending_buf + (1+sizeof(ush))*ds->lit_bufsize;

    ds->l_desc.dyn_tree = ds->dyn_ltree;
    ds->d_desc.dyn_tree = ds->dyn_dtree;
    ds->bl_desc.dyn_tree = ds->bl_tree;

    return Z_OK;
#endif /* MAXSEG_64K */
}

/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->next_in buffer and copying from it.
 * (See also flush_pending()).
 */
local unsigned read_buf(strm, buf, size)
    z_streamp strm;
    Bytef *buf;
    unsigned size;
{
    unsigned len = strm->avail_in;

    if (len > size) len = size;
    if (len == 0) return 0;

    strm->avail_in  -= len;

    zmemcpy(buf, strm->next_in, len);
    if (strm->state->wrap == 1) {
        strm->adler = adler32(strm->adler, buf, len);
    }
#ifdef GZIP
    else if (strm->state->wrap == 2) {
        strm->adler = crc32(strm->adler, buf, len);
    }
#endif
    strm->next_in  += len;
    strm->total_in += len;

    return len;
}

/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
local void lm_init (s)
    deflate_state *s;
{
    s->window_size = (ulg)2L*s->w_size;

    CLEAR_HASH(s);

    /* Set the default configuration parameters:
     */
    s->max_lazy_match   = configuration_table[s->level].max_lazy;
    s->good_match       = configuration_table[s->level].good_length;
    s->nice_match       = configuration_table[s->level].nice_length;
    s->max_chain_length = configuration_table[s->level].max_chain;

    s->strstart = 0;
    s->block_start = 0L;
    s->lookahead = 0;
    s->insert = 0;
    s->match_length = s->prev_length = MIN_MATCH-1;
    s->match_available = 0;
    s->ins_h = 0;
#ifndef FASTEST
#ifdef ASMV
    match_init(); /* initialize the asm code */
#endif
#endif
}

#ifndef FASTEST
/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
#ifndef ASMV
/* For 80x86 and 680x0, an optimized version will be provided in match.asm or
 * match.S. The code will be functionally equivalent.
 */
local uInt longest_match(s, cur_match)
    deflate_state *s;
    IPos cur_match;                             /* current match */
{
    unsigned chain_length = s->max_chain_length;/* max hash chain length */
    register Bytef *scan = s->window + s->strstart; /* current string */
    register Bytef *match;                      /* matched string */
    register int len;                           /* length of current match */
    int best_len = (int)s->prev_length;         /* best match length so far */
    int nice_match = s->nice_match;             /* stop if match long enough */
    IPos limit = s->strstart > (IPos)MAX_DIST(s) ?
        s->strstart - (IPos)MAX_DIST(s) : NIL;
    /* Stop when cur_match becomes <= limit. To simplify the code,
     * we prevent matches with the string of window index 0.
     */
    Posf *prev = s->prev;
    uInt wmask = s->w_mask;

#ifdef UNALIGNED_OK
    /* Compare two bytes at a time. Note: this is not always beneficial.
     * Try with and without -DUNALIGNED_OK to check.
     */
    register Bytef *strend = s->window + s->strstart + MAX_MATCH - 1;
    register ush scan_start = *(ushf*)scan;
    register ush scan_end   = *(ushf*)(scan+best_len-1);
#else
    register Bytef *strend = s->window + s->strstart + MAX_MATCH;
    register Byte scan_end1  = scan[best_len-1];
    register Byte scan_end   = scan[best_len];
#endif

    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
     * It is easy to get rid of this optimization if necessary.
     */
    Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

    /* Do not waste too much time if we already have a good match: */
    if (s->prev_length >= s->good_match) {
        chain_length >>= 2;
    }
    /* Do not look for matches beyond the end of the input. This is necessary
     * to make deflate deterministic.
     */
    if ((uInt)nice_match > s->lookahead) nice_match = (int)s->lookahead;

    Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

    do {
        Assert(cur_match < s->strstart, "no future");
        match = s->window + cur_match;

        /* Skip to next match if the match length cannot increase
         * or if the match length is less than 2.  Note that the checks below
         * for insufficient lookahead only occur occasionally for performance
         * reasons.  Therefore uninitialized memory will be accessed, and
         * conditional jumps will be made that depend on those values.
         * However the length of the match is limited to the lookahead, so
         * the output of deflate is not affected by the uninitialized values.
         */
#if (defined(UNALIGNED_OK) && MAX_MATCH == 258)
        /* This code assumes sizeof(unsigned short) == 2. Do not use
         * UNALIGNED_OK if your compiler uses a different size.
         */
        if (*(ushf*)(match+best_len-1) != scan_end ||
            *(ushf*)match != scan_start) continue;

        /* It is not necessary to compare scan[2] and match[2] since they are
         * always equal when the other bytes match, given that the hash keys
         * are equal and that HASH_BITS >= 8. Compare 2 bytes at a time at
         * strstart+3, +5, ... up to strstart+257. We check for insufficient
         * lookahead only every 4th comparison; the 128th check will be made
         * at strstart+257. If MAX_MATCH-2 is not a multiple of 8, it is
         * necessary to put more guard bytes at the end of the window, or
         * to check more often for insufficient lookahead.
         */
        Assert(scan[2] == match[2], "scan[2]?");
        scan++, match++;
        do {
        } while (*(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
                 scan < strend);
        /* The funny "do {}" generates better code on most compilers */

        /* Here, scan <= window+strstart+257 */
        Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
        if (*scan == *match) scan++;

        len = (MAX_MATCH - 1) - (int)(strend-scan);
        scan = strend - (MAX_MATCH-1);

#else /* UNALIGNED_OK */

        if (match[best_len]   != scan_end  ||
            match[best_len-1] != scan_end1 ||
            *match            != *scan     ||
            *++match          != scan[1])      continue;

        /* The check at best_len-1 can be removed because it will be made
         * again later. (This heuristic is not always a win.)
         * It is not necessary to compare scan[2] and match[2] since they
         * are always equal when the other bytes match, given that
         * the hash keys are equal and that HASH_BITS >= 8.
         */
        scan += 2, match++;
        Assert(*scan == *match, "match[2]?");

        /* We check for insufficient lookahead only every 8th comparison;
         * the 256th check will be made at strstart+258.
         */
        do {
        } while (*++scan == *++match && *++scan == *++match &&
                 *++scan == *++match && *++scan == *++match &&
                 *++scan == *++match && *++scan == *++match &&
                 *++scan == *++match && *++scan == *++match &&
                 scan < strend);

        Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

        len = MAX_MATCH - (int)(strend - scan);
        scan = strend - MAX_MATCH;

#endif /* UNALIGNED_OK */

        if (len > best_len) {
            s->match_start = cur_match;
            best_len = len;
            if (len >= nice_match) break;
#ifdef UNALIGNED_OK
            scan_end = *(ushf*)(scan+best_len-1);
#else
            scan_end1  = scan[best_len-1];
            scan_end   = scan[best_len];
#endif
        }
    } while ((cur_match = prev[cur_match & wmask]) > limit
             && --chain_length != 0);

    if ((uInt)best_len <= s->lookahead) return (uInt)best_len;
    return s->lookahead;
}
#endif /* ASMV */

#else /* FASTEST */

/* ---------------------------------------------------------------------------
 * Optimized version for FASTEST only
 */
local uInt longest_match(s, cur_match)
    deflate_state *s;
    IPos cur_match;                             /* current match */
{
    register Bytef *scan = s->window + s->strstart; /* current string */
    register Bytef *match;                       /* matched string */
    register int len;                           /* length of current match */
    register Bytef *strend = s->window + s->strstart + MAX_MATCH;

    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
     * It is easy to get rid of this optimization if necessary.
     */
    Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

    Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

    Assert(cur_match < s->strstart, "no future");

    match = s->window + cur_match;

    /* Return failure if the match length is less than 2:
     */
    if (match[0] != scan[0] || match[1] != scan[1]) return MIN_MATCH-1;

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2, match += 2;
    Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
    } while (*++scan == *++match && *++scan == *++match &&
             *++scan == *++match && *++scan == *++match &&
             *++scan == *++match && *++scan == *++match &&
             *++scan == *++match && *++scan == *++match &&
             scan < strend);

    Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH - (int)(strend - scan);

    if (len < MIN_MATCH) return MIN_MATCH - 1;

    s->match_start = cur_match;
    return (uInt)len <= s->lookahead ? (uInt)len : s->lookahead;
}

#endif /* FASTEST */

#ifdef ZLIB_DEBUG

#define EQUAL 0
/* result of memcmp for equal strings */

/* ===========================================================================
 * Check that the match at match_start is indeed a match.
 */
local void check_match(s, start, match, length)
    deflate_state *s;
    IPos start, match;
    int length;
{
    /* check that the match is indeed a match */
    if (zmemcmp(s->window + match,
                s->window + start, length) != EQUAL) {
        fprintf(stderr, " start %u, match %u, length %d\n",
                start, match, length);
        do {
            fprintf(stderr, "%c%c", s->window[match++], s->window[start++]);
        } while (--length != 0);
        z_error("invalid match");
    }
    if (z_verbose > 1) {
        fprintf(stderr,"\\[%d,%d]", start-match, length);
        do { putc(s->window[start++], stderr); } while (--length != 0);
    }
}
#else
#  define check_match(s, start, match, length)
#endif /* ZLIB_DEBUG */

/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
local void fill_window(s)
    deflate_state *s;
{
    unsigned n;
    unsigned more;    /* Amount of free space at the end of the window. */
    uInt wsize = s->w_size;

    Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

    do {
        more = (unsigned)(s->window_size -(ulg)s->lookahead -(ulg)s->strstart);

        /* Deal with !@#$% 64K limit: */
        if (sizeof(int) <= 2) {
            if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
                more = wsize;

            } else if (more == (unsigned)(-1)) {
                /* Very unlikely, but possible on 16 bit machine if
                 * strstart == 0 && lookahead == 1 (input done a byte at time)
                 */
                more--;
            }
        }

        /* If the window is almost full and there is insufficient lookahead,
         * move the upper half to the lower one to make room in the upper half.
         */
        if (s->strstart >= wsize+MAX_DIST(s)) {

            zmemcpy(s->window, s->window+wsize, (unsigned)wsize - more);
            s->match_start -= wsize;
            s->strstart    -= wsize; /* we now have strstart >= MAX_DIST */
            s->block_start -= (long) wsize;
            slide_hash(s);
            more += wsize;
        }
        if (s->strm->avail_in == 0) break;

        /* If there was no sliding:
         *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
         *    more == window_size - lookahead - strstart
         * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
         * => more >= window_size - 2*WSIZE + 2
         * In the BIG_MEM or MMAP case (not yet supported),
         *   window_size == input_size + MIN_LOOKAHEAD  &&
         *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
         * Otherwise, window_size == 2*WSIZE so more >= 2.
         * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
         */
        Assert(more >= 2, "more < 2");

        n = read_buf(s->strm, s->window + s->strstart + s->lookahead, more);
        s->lookahead += n;

        /* Initialize the hash value now that we have some input: */
        if (s->lookahead + s->insert >= MIN_MATCH) {
            uInt str = s->strstart - s->insert;
            s->ins_h = s->window[str];
            UPDATE_HASH(s, s->ins_h, s->window[str + 1]);
#if MIN_MATCH != 3
            Call UPDATE_HASH() MIN_MATCH-3 more times
#endif
            while (s->insert) {
                UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]);
#ifndef FASTEST
                s->prev[str & s->w_mask] = s->head[s->ins_h];
#endif
                s->head[s->ins_h] = (Pos)str;
                str++;
                s->insert--;
                if (s->lookahead + s->insert < MIN_MATCH)
                    break;
            }
        }
        /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
         * but this is not important since only literal bytes will be emitted.
         */

    } while (s->lookahead < MIN_LOOKAHEAD && s->strm->avail_in != 0);

    /* If the WIN_INIT bytes after the end of the current data have never been
     * written, then zero those bytes in order to avoid memory check reports of
     * the use of uninitialized (or uninitialised as Julian writes) bytes by
     * the longest match routines.  Update the high water mark for the next
     * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
     * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
     */
    if (s->high_water < s->window_size) {
        ulg curr = s->strstart + (ulg)(s->lookahead);
        ulg init;

        if (s->high_water < curr) {
            /* Previous high water mark below current data -- zero WIN_INIT
             * bytes or up to end of window, whichever is less.
             */
            init = s->window_size - curr;
            if (init > WIN_INIT)
                init = WIN_INIT;
            zmemzero(s->window + curr, (unsigned)init);
            s->high_water = curr + init;
        }
        else if (s->high_water < (ulg)curr + WIN_INIT) {
            /* High water mark at or above current data, but below current data
             * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
             * to end of window, whichever is less.
             */
            init = (ulg)curr + WIN_INIT - s->high_water;
            if (init > s->window_size - s->high_water)
                init = s->window_size - s->high_water;
            zmemzero(s->window + s->high_water, (unsigned)init);
            s->high_water += init;
        }
    }

    Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
           "not enough room for search");
}

/* ===========================================================================
 * Flush the current block, with given end-of-file flag.
 * IN assertion: strstart is set to the end of the current match.
 */
#define FLUSH_BLOCK_ONLY(s, last) { \
   _tr_flush_block(s, (s->block_start >= 0L ? \
                   (charf *)&s->window[(unsigned)s->block_start] : \
                   (charf *)Z_NULL), \
                (ulg)((long)s->strstart - s->block_start), \
                (last)); \
   s->block_start = s->strstart; \
   flush_pending(s->strm); \
   Tracev((stderr,"[FLUSH]")); \
}

/* Same but force premature exit if necessary. */
#define FLUSH_BLOCK(s, last) { \
   FLUSH_BLOCK_ONLY(s, last); \
   if (s->strm->avail_out == 0) return (last) ? finish_started : need_more; \
}

/* Maximum stored block length in deflate format (not including header). */
#define MAX_STORED 65535

/* Minimum of a and b. */
#define MIN(a, b) ((a) > (b) ? (b) : (a))

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 *
 * In case deflateParams() is used to later switch to a non-zero compression
 * level, s->matches (otherwise unused when storing) keeps track of the number
 * of hash table slides to perform. If s->matches is 1, then one hash table
 * slide will be done when switching. If s->matches is 2, the maximum value
 * allowed here, then the hash table will be cleared, since two or more slides
 * is the same as a clear.
 *
 * deflate_stored() is written to minimize the number of times an input byte is
 * copied. It is most efficient with large input and output buffers, which
 * maximizes the opportunites to have a single copy from next_in to next_out.
 */
local block_state deflate_stored(s, flush)
    deflate_state *s;
    int flush;
{
    /* Smallest worthy block size when not flushing or finishing. By default
     * this is 32K. This can be as small as 507 bytes for memLevel == 1. For
     * large input and output buffers, the stored block size will be larger.
     */
    unsigned min_block = MIN(s->pending_buf_size - 5, s->w_size);

    /* Copy as many min_block or larger stored blocks directly to next_out as
     * possible. If flushing, copy the remaining available input to next_out as
     * stored blocks, if there is enough space.
     */
    unsigned len, left, have, last = 0;
    unsigned used = s->strm->avail_in;
    do {
        /* Set len to the maximum size block that we can copy directly with the
         * available input data and output space. Set left to how much of that
         * would be copied from what's left in the window.
         */
        len = MAX_STORED;       /* maximum deflate stored block length */
        have = (s->bi_valid + 42) >> 3;         /* number of header bytes */
        if (s->strm->avail_out < have)          /* need room for header */
            break;
            /* maximum stored block length that will fit in avail_out: */
        have = s->strm->avail_out - have;
        left = s->strstart - s->block_start;    /* bytes left in window */
        if (len > (ulg)left + s->strm->avail_in)
            len = left + s->strm->avail_in;     /* limit len to the input */
        if (len > have)
            len = have;                         /* limit len to the output */

        /* If the stored block would be less than min_block in length, or if
         * unable to copy all of the available input when flushing, then try
         * copying to the window and the pending buffer instead. Also don't
         * write an empty block when flushing -- deflate() does that.
         */
        if (len < min_block && ((len == 0 && flush != Z_FINISH) ||
                                flush == Z_NO_FLUSH ||
                                len != left + s->strm->avail_in))
            break;

        /* Make a dummy stored block in pending to get the header bytes,
         * including any pending bits. This also updates the debugging counts.
         */
        last = flush == Z_FINISH && len == left + s->strm->avail_in ? 1 : 0;
        _tr_stored_block(s, (char *)0, 0L, last);

        /* Replace the lengths in the dummy stored block with len. */
        s->pending_buf[s->pending - 4] = len;
        s->pending_buf[s->pending - 3] = len >> 8;
        s->pending_buf[s->pending - 2] = ~len;
        s->pending_buf[s->pending - 1] = ~len >> 8;

        /* Write the stored block header bytes. */
        flush_pending(s->strm);

#ifdef ZLIB_DEBUG
        /* Update debugging counts for the data about to be copied. */
        s->compressed_len += len << 3;
        s->bits_sent += len << 3;
#endif

        /* Copy uncompressed bytes from the window to next_out. */
        if (left) {
            if (left > len)
                left = len;
            zmemcpy(s->strm->next_out, s->window + s->block_start, left);
            s->strm->next_out += left;
            s->strm->avail_out -= left;
            s->strm->total_out += left;
            s->block_start += left;
            len -= left;
        }

        /* Copy uncompressed bytes directly from next_in to next_out, updating
         * the check value.
         */
        if (len) {
            read_buf(s->strm, s->strm->next_out, len);
            s->strm->next_out += len;
            s->strm->avail_out -= len;
            s->strm->total_out += len;
        }
    } while (last == 0);

    /* Update the sliding window with the last s->w_size bytes of the copied
     * data, or append all of the copied data to the existing window if less
     * than s->w_size bytes were copied. Also update the number of bytes to
     * insert in the hash tables, in the event that deflateParams() switches to
     * a non-zero compression level.
     */
    used -= s->strm->avail_in;      /* number of input bytes directly copied */
    if (used) {
        /* If any input was used, then no unused input remains in the window,
         * therefore s->block_start == s->strstart.
         */
        if (used >= s->w_size) {    /* supplant the previous history */
            s->matches = 2;         /* clear hash */
            zmemcpy(s->window, s->strm->next_in - s->w_size, s->w_size);
            s->strstart = s->w_size;
        }
        else {
            if (s->window_size - s->strstart <= used) {
                /* Slide the window down. */
                s->strstart -= s->w_size;
                zmemcpy(s->window, s->window + s->w_size, s->strstart);
                if (s->matches < 2)
                    s->matches++;   /* add a pending slide_hash() */
            }
            zmemcpy(s->window + s->strstart, s->strm->next_in - used, used);
            s->strstart += used;
        }
        s->block_start = s->strstart;
        s->insert += MIN(used, s->w_size - s->insert);
    }
    if (s->high_water < s->strstart)
        s->high_water = s->strstart;

    /* If the last block was written to next_out, then done. */
    if (last)
        return finish_done;

    /* If flushing and all input has been consumed, then done. */
    if (flush != Z_NO_FLUSH && flush != Z_FINISH &&
        s->strm->avail_in == 0 && (long)s->strstart == s->block_start)
        return block_done;

    /* Fill the window with any remaining input. */
    have = s->window_size - s->strstart - 1;
    if (s->strm->avail_in > have && s->block_start >= (long)s->w_size) {
        /* Slide the window down. */
        s->block_start -= s->w_size;
        s->strstart -= s->w_size;
        zmemcpy(s->window, s->window + s->w_size, s->strstart);
        if (s->matches < 2)
            s->matches++;           /* add a pending slide_hash() */
        have += s->w_size;          /* more space now */
    }
    if (have > s->strm->avail_in)
        have = s->strm->avail_in;
    if (have) {
        read_buf(s->strm, s->window + s->strstart, have);
        s->strstart += have;
    }
    if (s->high_water < s->strstart)
        s->high_water = s->strstart;

    /* There was not enough avail_out to write a complete worthy or flushed
     * stored block to next_out. Write a stored block to pending instead, if we
     * have enough input for a worthy block, or if flushing and there is enough
     * room for the remaining input as a stored block in the pending buffer.
     */
    have = (s->bi_valid + 42) >> 3;         /* number of header bytes */
        /* maximum stored block length that will fit in pending: */
    have = MIN(s->pending_buf_size - have, MAX_STORED);
    min_block = MIN(have, s->w_size);
    left = s->strstart - s->block_start;
    if (left >= min_block ||
        ((left || flush == Z_FINISH) && flush != Z_NO_FLUSH &&
         s->strm->avail_in == 0 && left <= have)) {
        len = MIN(left, have);
        last = flush == Z_FINISH && s->strm->avail_in == 0 &&
               len == left ? 1 : 0;
        _tr_stored_block(s, (charf *)s->window + s->block_start, len, last);
        s->block_start += len;
        flush_pending(s->strm);
    }

    /* We've done all we can with the available input and output. */
    return last ? finish_started : need_more;
}

/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
local block_state deflate_fast(s, flush)
    deflate_state *s;
    int flush;
{
    IPos hash_head;       /* head of the hash chain */
    int bflush;           /* set if current block must be flushed */

    for (;;) {
        /* Make sure that we always have enough lookahead, except
         * at the end of the input file. We need MAX_MATCH bytes
         * for the next match, plus MIN_MATCH bytes to insert the
         * string following the next match.
         */
        if (s->lookahead < MIN_LOOKAHEAD) {
            fill_window(s);
            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
                return need_more;
            }
            if (s->lookahead == 0) break; /* flush the current block */
        }

        /* Insert the string window[strstart .. strstart+2] in the
         * dictionary, and set hash_head to the head of the hash chain:
         */
        hash_head = NIL;
        if (s->lookahead >= MIN_MATCH) {
            INSERT_STRING(s, s->strstart, hash_head);
        }

        /* Find the longest match, discarding those <= prev_length.
         * At this point we have always match_length < MIN_MATCH
         */
        if (hash_head != NIL && s->strstart - hash_head <= MAX_DIST(s)) {
            /* To simplify the code, we prevent matches with the string
             * of window index 0 (in particular we have to avoid a match
             * of the string with itself at the start of the input file).
             */
            s->match_length = longest_match (s, hash_head);
            /* longest_match() sets match_start */
        }
        if (s->match_length >= MIN_MATCH) {
            check_match(s, s->strstart, s->match_start, s->match_length);

            _tr_tally_dist(s, s->strstart - s->match_start,
                           s->match_length - MIN_MATCH, bflush);

            s->lookahead -= s->match_length;

            /* Insert new strings in the hash table only if the match length
             * is not too large. This saves time but degrades compression.
             */
#ifndef FASTEST
            if (s->match_length <= s->max_insert_length &&
                s->lookahead >= MIN_MATCH) {
                s->match_length--; /* string at strstart already in table */
                do {
                    s->strstart++;
                    INSERT_STRING(s, s->strstart, hash_head);
                    /* strstart never exceeds WSIZE-MAX_MATCH, so there are
                     * always MIN_MATCH bytes ahead.
                     */
                } while (--s->match_length != 0);
                s->strstart++;
            } else
#endif
            {
                s->strstart += s->match_length;
                s->match_length = 0;
                s->ins_h = s->window[s->strstart];
                UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);
#if MIN_MATCH != 3
                Call UPDATE_HASH() MIN_MATCH-3 more times
#endif
                /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
                 * matter since it will be recomputed at next deflate call.
                 */
            }
        } else {
            /* No match, output a literal byte */
            Tracevv((stderr,"%c", s->window[s->strstart]));
            _tr_tally_lit (s, s->window[s->strstart], bflush);
            s->lookahead--;
            s->strstart++;
        }
        if (bflush) FLUSH_BLOCK(s, 0);
    }
    s->insert = s->strstart < MIN_MATCH-1 ? s->strstart : MIN_MATCH-1;
    if (flush == Z_FINISH) {
        FLUSH_BLOCK(s, 1);
        return finish_done;
    }
    if (s->last_lit)
        FLUSH_BLOCK(s, 0);
    return block_done;
}

#ifndef FASTEST
/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
local block_state deflate_slow(s, flush)
    deflate_state *s;
    int flush;
{
    IPos hash_head;          /* head of hash chain */
    int bflush;              /* set if current block must be flushed */

    /* Process the input block. */
    for (;;) {
        /* Make sure that we always have enough lookahead, except
         * at the end of the input file. We need MAX_MATCH bytes
         * for the next match, plus MIN_MATCH bytes to insert the
         * string following the next match.
         */
        if (s->lookahead < MIN_LOOKAHEAD) {
            fill_window(s);
            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
                return need_more;
            }
            if (s->lookahead == 0) break; /* flush the current block */
        }

        /* Insert the string window[strstart .. strstart+2] in the
         * dictionary, and set hash_head to the head of the hash chain:
         */
        hash_head = NIL;
        if (s->lookahead >= MIN_MATCH) {
            INSERT_STRING(s, s->strstart, hash_head);
        }

        /* Find the longest match, discarding those <= prev_length.
         */
        s->prev_length = s->match_length, s->prev_match = s->match_start;
        s->match_length = MIN_MATCH-1;

        if (hash_head != NIL && s->prev_length < s->max_lazy_match &&
            s->strstart - hash_head <= MAX_DIST(s)) {
            /* To simplify the code, we prevent matches with the string
             * of window index 0 (in particular we have to avoid a match
             * of the string with itself at the start of the input file).
             */
            s->match_length = longest_match (s, hash_head);
            /* longest_match() sets match_start */

            if (s->match_length <= 5 && (s->strategy == Z_FILTERED
#if TOO_FAR <= 32767
                || (s->match_length == MIN_MATCH &&
                    s->strstart - s->match_start > TOO_FAR)
#endif
                )) {

                /* If prev_match is also MIN_MATCH, match_start is garbage
                 * but we will ignore the current match anyway.
                 */
                s->match_length = MIN_MATCH-1;
            }
        }
        /* If there was a match at the previous step and the current
         * match is not better, output the previous match:
         */
        if (s->prev_length >= MIN_MATCH && s->match_length <= s->prev_length) {
            uInt max_insert = s->strstart + s->lookahead - MIN_MATCH;
            /* Do not insert strings in hash table beyond this. */

            check_match(s, s->strstart-1, s->prev_match, s->prev_length);

            _tr_tally_dist(s, s->strstart -1 - s->prev_match,
                           s->prev_length - MIN_MATCH, bflush);

            /* Insert in hash table all strings up to the end of the match.
             * strstart-1 and strstart are already inserted. If there is not
             * enough lookahead, the last two strings are not inserted in
             * the hash table.
             */
            s->lookahead -= s->prev_length-1;
            s->prev_length -= 2;
            do {
                if (++s->strstart <= max_insert) {
                    INSERT_STRING(s, s->strstart, hash_head);
                }
            } while (--s->prev_length != 0);
            s->match_available = 0;
            s->match_length = MIN_MATCH-1;
            s->strstart++;

            if (bflush) FLUSH_BLOCK(s, 0);

        } else if (s->match_available) {
            /* If there was no match at the previous position, output a
             * single literal. If there was a match but the current match
             * is longer, truncate the previous match to a single literal.
             */
            Tracevv((stderr,"%c", s->window[s->strstart-1]));
            _tr_tally_lit(s, s->window[s->strstart-1], bflush);
            if (bflush) {
                FLUSH_BLOCK_ONLY(s, 0);
            }
            s->strstart++;
            s->lookahead--;
            if (s->strm->avail_out == 0) return need_more;
        } else {
            /* There is no previous match to compare with, wait for
             * the next step to decide.
             */
            s->match_available = 1;
            s->strstart++;
            s->lookahead--;
        }
    }
    Assert (flush != Z_NO_FLUSH, "no flush?");
    if (s->match_available) {
        Tracevv((stderr,"%c", s->window[s->strstart-1]));
        _tr_tally_lit(s, s->window[s->strstart-1], bflush);
        s->match_available = 0;
    }
    s->insert = s->strstart < MIN_MATCH-1 ? s->strstart : MIN_MATCH-1;
    if (flush == Z_FINISH) {
        FLUSH_BLOCK(s, 1);
        return finish_done;
    }
    if (s->last_lit)
        FLUSH_BLOCK(s, 0);
    return block_done;
}
#endif /* FASTEST */

/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
local block_state deflate_rle(s, flush)
    deflate_state *s;
    int flush;
{
    int bflush;             /* set if current block must be flushed */
    uInt prev;              /* byte at distance one to match */
    Bytef *scan, *strend;   /* scan goes up to strend for length of run */

    for (;;) {
        /* Make sure that we always have enough lookahead, except
         * at the end of the input file. We need MAX_MATCH bytes
         * for the longest run, plus one for the unrolled loop.
         */
        if (s->lookahead <= MAX_MATCH) {
            fill_window(s);
            if (s->lookahead <= MAX_MATCH && flush == Z_NO_FLUSH) {
                return need_more;
            }
            if (s->lookahead == 0) break; /* flush the current block */
        }

        /* See how many times the previous byte repeats */
        s->match_length = 0;
        if (s->lookahead >= MIN_MATCH && s->strstart > 0) {
            scan = s->window + s->strstart - 1;
            prev = *scan;
            if (prev == *++scan && prev == *++scan && prev == *++scan) {
                strend = s->window + s->strstart + MAX_MATCH;
                do {
                } while (prev == *++scan && prev == *++scan &&
                         prev == *++scan && prev == *++scan &&
                         prev == *++scan && prev == *++scan &&
                         prev == *++scan && prev == *++scan &&
                         scan < strend);
                s->match_length = MAX_MATCH - (uInt)(strend - scan);
                if (s->match_length > s->lookahead)
                    s->match_length = s->lookahead;
            }
            Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
        }

        /* Emit match if have run of MIN_MATCH or longer, else emit literal */
        if (s->match_length >= MIN_MATCH) {
            check_match(s, s->strstart, s->strstart - 1, s->match_length);

            _tr_tally_dist(s, 1, s->match_length - MIN_MATCH, bflush);

            s->lookahead -= s->match_length;
            s->strstart += s->match_length;
            s->match_length = 0;
        } else {
            /* No match, output a literal byte */
            Tracevv((stderr,"%c", s->window[s->strstart]));
            _tr_tally_lit (s, s->window[s->strstart], bflush);
            s->lookahead--;
            s->strstart++;
        }
        if (bflush) FLUSH_BLOCK(s, 0);
    }
    s->insert = 0;
    if (flush == Z_FINISH) {
        FLUSH_BLOCK(s, 1);
        return finish_done;
    }
    if (s->last_lit)
        FLUSH_BLOCK(s, 0);
    return block_done;
}

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
local block_state deflate_huff(s, flush)
    deflate_state *s;
    int flush;
{
    int bflush;             /* set if current block must be flushed */

    for (;;) {
        /* Make sure that we have a literal to write. */
        if (s->lookahead == 0) {
            fill_window(s);
            if (s->lookahead == 0) {
                if (flush == Z_NO_FLUSH)
                    return need_more;
                break;      /* flush the current block */
            }
        }

        /* Output a literal byte */
        s->match_length = 0;
        Tracevv((stderr,"%c", s->window[s->strstart]));
        _tr_tally_lit (s, s->window[s->strstart], bflush);
        s->lookahead--;
        s->strstart++;
        if (bflush) FLUSH_BLOCK(s, 0);
    }
    s->insert = 0;
    if (flush == Z_FINISH) {
        FLUSH_BLOCK(s, 1);
        return finish_done;
    }
    if (s->last_lit)
        FLUSH_BLOCK(s, 0);
    return block_done;
}

```

`efiXloader/3rd/uefitool/common/zlib/deflate.h`:

```h
/* deflate.h -- internal compression state
 * Copyright (C) 1995-2016 Jean-loup Gailly
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

/* @(#) $Id$ */

#ifndef DEFLATE_H
#define DEFLATE_H

#include "zutil.h"

/* define NO_GZIP when compiling if you want to disable gzip header and
   trailer creation by deflate().  NO_GZIP would be used to avoid linking in
   the crc code when it is not needed.  For shared libraries, gzip encoding
   should be left enabled. */
#ifndef NO_GZIP
#  define GZIP
#endif

/* ===========================================================================
 * Internal compression state.
 */

#define LENGTH_CODES 29
/* number of length codes, not counting the special END_BLOCK code */

#define LITERALS  256
/* number of literal bytes 0..255 */

#define L_CODES (LITERALS+1+LENGTH_CODES)
/* number of Literal or Length codes, including the END_BLOCK code */

#define D_CODES   30
/* number of distance codes */

#define BL_CODES  19
/* number of codes used to transfer the bit lengths */

#define HEAP_SIZE (2*L_CODES+1)
/* maximum heap size */

#define MAX_BITS 15
/* All codes must not exceed MAX_BITS bits */

#define Buf_size 16
/* size of bit buffer in bi_buf */

#define INIT_STATE    42    /* zlib header -> BUSY_STATE */
#ifdef GZIP
#  define GZIP_STATE  57    /* gzip header -> BUSY_STATE | EXTRA_STATE */
#endif
#define EXTRA_STATE   69    /* gzip extra block -> NAME_STATE */
#define NAME_STATE    73    /* gzip file name -> COMMENT_STATE */
#define COMMENT_STATE 91    /* gzip comment -> HCRC_STATE */
#define HCRC_STATE   103    /* gzip header CRC -> BUSY_STATE */
#define BUSY_STATE   113    /* deflate -> FINISH_STATE */
#define FINISH_STATE 666    /* stream complete */
/* Stream status */


/* Data structure describing a single value and its code string. */
typedef struct ct_data_s {
    union {
        ush  freq;       /* frequency count */
        ush  code;       /* bit string */
    } fc;
    union {
        ush  dad;        /* father node in Huffman tree */
        ush  len;        /* length of bit string */
    } dl;
} FAR ct_data;

#define Freq fc.freq
#define Code fc.code
#define Dad  dl.dad
#define Len  dl.len

typedef struct static_tree_desc_s  static_tree_desc;

typedef struct tree_desc_s {
    ct_data *dyn_tree;           /* the dynamic tree */
    int     max_code;            /* largest code with non zero frequency */
    const static_tree_desc *stat_desc;  /* the corresponding static tree */
} FAR tree_desc;

typedef ush Pos;
typedef Pos FAR Posf;
typedef unsigned IPos;

/* A Pos is an index in the character window. We use short instead of int to
 * save space in the various tables. IPos is used only for parameter passing.
 */

typedef struct internal_state {
    z_streamp strm;      /* pointer back to this zlib stream */
    int   status;        /* as the name implies */
    Bytef *pending_buf;  /* output still pending */
    ulg   pending_buf_size; /* size of pending_buf */
    Bytef *pending_out;  /* next pending byte to output to the stream */
    ulg   pending;       /* nb of bytes in the pending buffer */
    int   wrap;          /* bit 0 true for zlib, bit 1 true for gzip */
    gz_headerp  gzhead;  /* gzip header information to write */
    ulg   gzindex;       /* where in extra, name, or comment */
    Byte  method;        /* can only be DEFLATED */
    int   last_flush;    /* value of flush param for previous deflate call */

                /* used by deflate.c: */

    uInt  w_size;        /* LZ77 window size (32K by default) */
    uInt  w_bits;        /* log2(w_size)  (8..16) */
    uInt  w_mask;        /* w_size - 1 */

    Bytef *window;
    /* Sliding window. Input bytes are read into the second half of the window,
     * and move to the first half later to keep a dictionary of at least wSize
     * bytes. With this organization, matches are limited to a distance of
     * wSize-MAX_MATCH bytes, but this ensures that IO is always
     * performed with a length multiple of the block size. Also, it limits
     * the window size to 64K, which is quite useful on MSDOS.
     * To do: use the user input buffer as sliding window.
     */

    ulg window_size;
    /* Actual size of window: 2*wSize, except when the user input buffer
     * is directly used as sliding window.
     */

    Posf *prev;
    /* Link to older string with same hash index. To limit the size of this
     * array to 64K, this link is maintained only for the last 32K strings.
     * An index in this array is thus a window index modulo 32K.
     */

    Posf *head; /* Heads of the hash chains or NIL. */

    uInt  ins_h;          /* hash index of string to be inserted */
    uInt  hash_size;      /* number of elements in hash table */
    uInt  hash_bits;      /* log2(hash_size) */
    uInt  hash_mask;      /* hash_size-1 */

    uInt  hash_shift;
    /* Number of bits by which ins_h must be shifted at each input
     * step. It must be such that after MIN_MATCH steps, the oldest
     * byte no longer takes part in the hash key, that is:
     *   hash_shift * MIN_MATCH >= hash_bits
     */

    long block_start;
    /* Window position at the beginning of the current output block. Gets
     * negative when the window is moved backwards.
     */

    uInt match_length;           /* length of best match */
    IPos prev_match;             /* previous match */
    int match_available;         /* set if previous match exists */
    uInt strstart;               /* start of string to insert */
    uInt match_start;            /* start of matching string */
    uInt lookahead;              /* number of valid bytes ahead in window */

    uInt prev_length;
    /* Length of the best match at previous step. Matches not greater than this
     * are discarded. This is used in the lazy match evaluation.
     */

    uInt max_chain_length;
    /* To speed up deflation, hash chains are never searched beyond this
     * length.  A higher limit improves compression ratio but degrades the
     * speed.
     */

    uInt max_lazy_match;
    /* Attempt to find a better match only when the current match is strictly
     * smaller than this value. This mechanism is used only for compression
     * levels >= 4.
     */
#   define max_insert_length  max_lazy_match
    /* Insert new strings in the hash table only if the match length is not
     * greater than this length. This saves time but degrades compression.
     * max_insert_length is used only for compression levels <= 3.
     */

    int level;    /* compression level (1..9) */
    int strategy; /* favor or force Huffman coding*/

    uInt good_match;
    /* Use a faster search when the previous match is longer than this */

    int nice_match; /* Stop searching when current match exceeds this */

                /* used by trees.c: */
    /* Didn't use ct_data typedef below to suppress compiler warning */
    struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
    struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
    struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

    struct tree_desc_s l_desc;               /* desc. for literal tree */
    struct tree_desc_s d_desc;               /* desc. for distance tree */
    struct tree_desc_s bl_desc;              /* desc. for bit length tree */

    ush bl_count[MAX_BITS+1];
    /* number of codes at each bit length for an optimal tree */

    int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
    int heap_len;               /* number of elements in the heap */
    int heap_max;               /* element of largest frequency */
    /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
     * The same heap array is used to build all trees.
     */

    uch depth[2*L_CODES+1];
    /* Depth of each subtree used as tie breaker for trees of equal frequency
     */

    uchf *l_buf;          /* buffer for literals or lengths */

    uInt  lit_bufsize;
    /* Size of match buffer for literals/lengths.  There are 4 reasons for
     * limiting lit_bufsize to 64K:
     *   - frequencies can be kept in 16 bit counters
     *   - if compression is not successful for the first block, all input
     *     data is still in the window so we can still emit a stored block even
     *     when input comes from standard input.  (This can also be done for
     *     all blocks if lit_bufsize is not greater than 32K.)
     *   - if compression is not successful for a file smaller than 64K, we can
     *     even emit a stored file instead of a stored block (saving 5 bytes).
     *     This is applicable only for zip (not gzip or zlib).
     *   - creating new Huffman trees less frequently may not provide fast
     *     adaptation to changes in the input data statistics. (Take for
     *     example a binary file with poorly compressible code followed by
     *     a highly compressible string table.) Smaller buffer sizes give
     *     fast adaptation but have of course the overhead of transmitting
     *     trees more frequently.
     *   - I can't count above 4
     */

    uInt last_lit;      /* running index in l_buf */

    ushf *d_buf;
    /* Buffer for distances. To simplify the code, d_buf and l_buf have
     * the same number of elements. To use different lengths, an extra flag
     * array would be necessary.
     */

    ulg opt_len;        /* bit length of current block with optimal trees */
    ulg static_len;     /* bit length of current block with static trees */
    uInt matches;       /* number of string matches in current block */
    uInt insert;        /* bytes at end of window left to insert */

#ifdef ZLIB_DEBUG
    ulg compressed_len; /* total bit length of compressed file mod 2^32 */
    ulg bits_sent;      /* bit length of compressed data sent mod 2^32 */
#endif

    ush bi_buf;
    /* Output buffer. bits are inserted starting at the bottom (least
     * significant bits).
     */
    int bi_valid;
    /* Number of valid bits in bi_buf.  All bits above the last valid bit
     * are always zero.
     */

    ulg high_water;
    /* High water mark offset in window for initialized bytes -- bytes above
     * this are set to zero in order to avoid memory check warnings when
     * longest match routines access bytes past the input.  This is then
     * updated to the new high water mark.
     */

} FAR deflate_state;

/* Output a byte on the stream.
 * IN assertion: there is enough room in pending_buf.
 */
#define put_byte(s, c) {s->pending_buf[s->pending++] = (Bytef)(c);}


#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)
/* Minimum amount of lookahead, except at the end of the input file.
 * See deflate.c for comments about the MIN_MATCH+1.
 */

#define MAX_DIST(s)  ((s)->w_size-MIN_LOOKAHEAD)
/* In order to simplify the code, particularly on 16 bit machines, match
 * distances are limited to MAX_DIST instead of WSIZE.
 */

#define WIN_INIT MAX_MATCH
/* Number of bytes after end of data in window to initialize in order to avoid
   memory checker errors from longest match routines */

        /* in trees.c */
void ZLIB_INTERNAL _tr_init OF((deflate_state *s));
int ZLIB_INTERNAL _tr_tally OF((deflate_state *s, unsigned dist, unsigned lc));
void ZLIB_INTERNAL _tr_flush_block OF((deflate_state *s, charf *buf,
                        ulg stored_len, int last));
void ZLIB_INTERNAL _tr_flush_bits OF((deflate_state *s));
void ZLIB_INTERNAL _tr_align OF((deflate_state *s));
void ZLIB_INTERNAL _tr_stored_block OF((deflate_state *s, charf *buf,
                        ulg stored_len, int last));

#define d_code(dist) \
   ((dist) < 256 ? _dist_code[dist] : _dist_code[256+((dist)>>7)])
/* Mapping from a distance to a distance code. dist is the distance - 1 and
 * must not have side effects. _dist_code[256] and _dist_code[257] are never
 * used.
 */

#ifndef ZLIB_DEBUG
/* Inline versions of _tr_tally for speed: */

#if defined(GEN_TREES_H) || !defined(STDC)
  extern uch ZLIB_INTERNAL _length_code[];
  extern uch ZLIB_INTERNAL _dist_code[];
#else
  extern const uch ZLIB_INTERNAL _length_code[];
  extern const uch ZLIB_INTERNAL _dist_code[];
#endif

# define _tr_tally_lit(s, c, flush) \
  { uch cc = (c); \
    s->d_buf[s->last_lit] = 0; \
    s->l_buf[s->last_lit++] = cc; \
    s->dyn_ltree[cc].Freq++; \
    flush = (s->last_lit == s->lit_bufsize-1); \
   }
# define _tr_tally_dist(s, distance, length, flush) \
  { uch len = (uch)(length); \
    ush dist = (ush)(distance); \
    s->d_buf[s->last_lit] = dist; \
    s->l_buf[s->last_lit++] = len; \
    dist--; \
    s->dyn_ltree[_length_code[len]+LITERALS+1].Freq++; \
    s->dyn_dtree[d_code(dist)].Freq++; \
    flush = (s->last_lit == s->lit_bufsize-1); \
  }
#else
# define _tr_tally_lit(s, c, flush) flush = _tr_tally(s, 0, c)
# define _tr_tally_dist(s, distance, length, flush) \
              flush = _tr_tally(s, distance, length)
#endif

#endif /* DEFLATE_H */

```

`efiXloader/3rd/uefitool/common/zlib/gzclose.c`:

```c
/* gzclose.c -- zlib gzclose() function
 * Copyright (C) 2004, 2010 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

#include "gzguts.h"

/* gzclose() is in a separate file so that it is linked in only if it is used.
   That way the other gzclose functions can be used instead to avoid linking in
   unneeded compression or decompression routines. */
int ZEXPORT gzclose(file)
    gzFile file;
{
#ifndef NO_GZCOMPRESS
    gz_statep state;

    if (file == NULL)
        return Z_STREAM_ERROR;
    state = (gz_statep)file;

    return state->mode == GZ_READ ? gzclose_r(file) : gzclose_w(file);
#else
    return gzclose_r(file);
#endif
}

```

`efiXloader/3rd/uefitool/common/zlib/gzguts.h`:

```h
/* gzguts.h -- zlib internal header definitions for gz* operations
 * Copyright (C) 2004, 2005, 2010, 2011, 2012, 2013, 2016 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

#ifdef _LARGEFILE64_SOURCE
#  ifndef _LARGEFILE_SOURCE
#    define _LARGEFILE_SOURCE 1
#  endif
#  ifdef _FILE_OFFSET_BITS
#    undef _FILE_OFFSET_BITS
#  endif
#endif

#ifdef HAVE_HIDDEN
#  define ZLIB_INTERNAL __attribute__((visibility ("hidden")))
#else
#  define ZLIB_INTERNAL
#endif

#include <stdio.h>
#include "zlib.h"
#ifdef STDC
#  include <string.h>
#  include <stdlib.h>
#  include <limits.h>
#endif

#ifndef _POSIX_SOURCE
#  define _POSIX_SOURCE
#endif
#include <fcntl.h>

#ifdef _WIN32
#  include <stddef.h>
#endif

#if defined(__TURBOC__) || defined(_MSC_VER) || defined(_WIN32)
#  include <io.h>
#endif

#if defined(_WIN32) || defined(__CYGWIN__)
#  define WIDECHAR
#endif

#ifdef WINAPI_FAMILY
#  define open _open
#  define read _read
#  define write _write
#  define close _close
#endif

#ifdef NO_DEFLATE       /* for compatibility with old definition */
#  define NO_GZCOMPRESS
#endif

#if defined(STDC99) || (defined(__TURBOC__) && __TURBOC__ >= 0x550)
#  ifndef HAVE_VSNPRINTF
#    define HAVE_VSNPRINTF
#  endif
#endif

#if defined(__CYGWIN__)
#  ifndef HAVE_VSNPRINTF
#    define HAVE_VSNPRINTF
#  endif
#endif

#if defined(MSDOS) && defined(__BORLANDC__) && (BORLANDC > 0x410)
#  ifndef HAVE_VSNPRINTF
#    define HAVE_VSNPRINTF
#  endif
#endif

#ifndef HAVE_VSNPRINTF
#  ifdef MSDOS
/* vsnprintf may exist on some MS-DOS compilers (DJGPP?),
   but for now we just assume it doesn't. */
#    define NO_vsnprintf
#  endif
#  ifdef __TURBOC__
#    define NO_vsnprintf
#  endif
#  ifdef WIN32
/* In Win32, vsnprintf is available as the "non-ANSI" _vsnprintf. */
#    if !defined(vsnprintf) && !defined(NO_vsnprintf)
#      if !defined(_MSC_VER) || ( defined(_MSC_VER) && _MSC_VER < 1500 )
#         define vsnprintf _vsnprintf
#      endif
#    endif
#  endif
#  ifdef __SASC
#    define NO_vsnprintf
#  endif
#  ifdef VMS
#    define NO_vsnprintf
#  endif
#  ifdef __OS400__
#    define NO_vsnprintf
#  endif
#  ifdef __MVS__
#    define NO_vsnprintf
#  endif
#endif

/* unlike snprintf (which is required in C99), _snprintf does not guarantee
   null termination of the result -- however this is only used in gzlib.c where
   the result is assured to fit in the space provided */
#if defined(_MSC_VER) && _MSC_VER < 1900
#  define snprintf _snprintf
#endif

#ifndef local
#  define local static
#endif
/* since "static" is used to mean two completely different things in C, we
   define "local" for the non-static meaning of "static", for readability
   (compile with -Dlocal if your debugger can't find static symbols) */

/* gz* functions always use library allocation functions */
#ifndef STDC
  extern voidp  malloc OF((uInt size));
  extern void   free   OF((voidpf ptr));
#endif

/* get errno and strerror definition */
#if defined UNDER_CE
#  include <windows.h>
#  define zstrerror() gz_strwinerror((DWORD)GetLastError())
#else
#  ifndef NO_STRERROR
#    include <errno.h>
#    define zstrerror() strerror(errno)
#  else
#    define zstrerror() "stdio error (consult errno)"
#  endif
#endif

/* provide prototypes for these when building zlib without LFS */
#if !defined(_LARGEFILE64_SOURCE) || _LFS64_LARGEFILE-0 == 0
    ZEXTERN gzFile ZEXPORT gzopen64 OF((const char *, const char *));
    ZEXTERN z_off64_t ZEXPORT gzseek64 OF((gzFile, z_off64_t, int));
    ZEXTERN z_off64_t ZEXPORT gztell64 OF((gzFile));
    ZEXTERN z_off64_t ZEXPORT gzoffset64 OF((gzFile));
#endif

/* default memLevel */
#if MAX_MEM_LEVEL >= 8
#  define DEF_MEM_LEVEL 8
#else
#  define DEF_MEM_LEVEL  MAX_MEM_LEVEL
#endif

/* default i/o buffer size -- double this for output when reading (this and
   twice this must be able to fit in an unsigned type) */
#define GZBUFSIZE 8192

/* gzip modes, also provide a little integrity check on the passed structure */
#define GZ_NONE 0
#define GZ_READ 7247
#define GZ_WRITE 31153
#define GZ_APPEND 1     /* mode set to GZ_WRITE after the file is opened */

/* values for gz_state how */
#define LOOK 0      /* look for a gzip header */
#define COPY 1      /* copy input directly */
#define GZIP 2      /* decompress a gzip stream */

/* internal gzip file state data structure */
typedef struct {
        /* exposed contents for gzgetc() macro */
    struct gzFile_s x;      /* "x" for exposed */
                            /* x.have: number of bytes available at x.next */
                            /* x.next: next output data to deliver or write */
                            /* x.pos: current position in uncompressed data */
        /* used for both reading and writing */
    int mode;               /* see gzip modes above */
    int fd;                 /* file descriptor */
    char *path;             /* path or fd for error messages */
    unsigned size;          /* buffer size, zero if not allocated yet */
    unsigned want;          /* requested buffer size, default is GZBUFSIZE */
    unsigned char *in;      /* input buffer (double-sized when writing) */
    unsigned char *out;     /* output buffer (double-sized when reading) */
    int direct;             /* 0 if processing gzip, 1 if transparent */
        /* just for reading */
    int how;                /* 0: get header, 1: copy, 2: decompress */
    z_off64_t start;        /* where the gzip data started, for rewinding */
    int eof;                /* true if end of input file reached */
    int past;               /* true if read requested past end */
        /* just for writing */
    int level;              /* compression level */
    int strategy;           /* compression strategy */
        /* seek request */
    z_off64_t skip;         /* amount to skip (already rewound if backwards) */
    int seek;               /* true if seek request pending */
        /* error information */
    int err;                /* error code */
    char *msg;              /* error message */
        /* zlib inflate or deflate stream */
    z_stream strm;          /* stream structure in-place (not a pointer) */
} gz_state;
typedef gz_state FAR *gz_statep;

/* shared functions */
void ZLIB_INTERNAL gz_error OF((gz_statep, int, const char *));
#if defined UNDER_CE
char ZLIB_INTERNAL *gz_strwinerror OF((DWORD error));
#endif

/* GT_OFF(x), where x is an unsigned value, is true if x > maximum z_off64_t
   value -- needed when comparing unsigned to z_off64_t, which is signed
   (possible z_off64_t types off_t, off64_t, and long are all signed) */
#ifdef INT_MAX
#  define GT_OFF(x) (sizeof(int) == sizeof(z_off64_t) && (x) > INT_MAX)
#else
unsigned ZLIB_INTERNAL gz_intmax OF((void));
#  define GT_OFF(x) (sizeof(int) == sizeof(z_off64_t) && (x) > gz_intmax())
#endif

/* UEFITool change, fixes undefined lseek, open, read prototypes. */
#ifndef _WIN32
#  include <unistd.h>
#endif

```

`efiXloader/3rd/uefitool/common/zlib/gzlib.c`:

```c
/* gzlib.c -- zlib functions common to reading and writing gzip files
 * Copyright (C) 2004-2017 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

#include "gzguts.h"

#if defined(_WIN32) && !defined(__BORLANDC__) && !defined(__MINGW32__)
#  define LSEEK _lseeki64
#else
#if defined(_LARGEFILE64_SOURCE) && _LFS64_LARGEFILE-0
#  define LSEEK lseek64
#else
#  define LSEEK lseek
#endif
#endif

/* Local functions */
local void gz_reset OF((gz_statep));
local gzFile gz_open OF((const void *, int, const char *));

#if defined UNDER_CE

/* Map the Windows error number in ERROR to a locale-dependent error message
   string and return a pointer to it.  Typically, the values for ERROR come
   from GetLastError.

   The string pointed to shall not be modified by the application, but may be
   overwritten by a subsequent call to gz_strwinerror

   The gz_strwinerror function does not change the current setting of
   GetLastError. */
char ZLIB_INTERNAL *gz_strwinerror (error)
     DWORD error;
{
    static char buf[1024];

    wchar_t *msgbuf;
    DWORD lasterr = GetLastError();
    DWORD chars = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM
        | FORMAT_MESSAGE_ALLOCATE_BUFFER,
        NULL,
        error,
        0, /* Default language */
        (LPVOID)&msgbuf,
        0,
        NULL);
    if (chars != 0) {
        /* If there is an \r\n appended, zap it.  */
        if (chars >= 2
            && msgbuf[chars - 2] == '\r' && msgbuf[chars - 1] == '\n') {
            chars -= 2;
            msgbuf[chars] = 0;
        }

        if (chars > sizeof (buf) - 1) {
            chars = sizeof (buf) - 1;
            msgbuf[chars] = 0;
        }

        wcstombs(buf, msgbuf, chars + 1);
        LocalFree(msgbuf);
    }
    else {
        sprintf(buf, "unknown win32 error (%ld)", error);
    }

    SetLastError(lasterr);
    return buf;
}

#endif /* UNDER_CE */

/* Reset gzip file state */
local void gz_reset(state)
    gz_statep state;
{
    state->x.have = 0;              /* no output data available */
    if (state->mode == GZ_READ) {   /* for reading ... */
        state->eof = 0;             /* not at end of file */
        state->past = 0;            /* have not read past end yet */
        state->how = LOOK;          /* look for gzip header */
    }
    state->seek = 0;                /* no seek request pending */
    gz_error(state, Z_OK, NULL);    /* clear error */
    state->x.pos = 0;               /* no uncompressed data yet */
    state->strm.avail_in = 0;       /* no input data yet */
}

/* Open a gzip file either by name or file descriptor. */
local gzFile gz_open(path, fd, mode)
    const void *path;
    int fd;
    const char *mode;
{
    gz_statep state;
    z_size_t len;
    int oflag;
#ifdef O_CLOEXEC
    int cloexec = 0;
#endif
#ifdef O_EXCL
    int exclusive = 0;
#endif

    /* check input */
    if (path == NULL)
        return NULL;

    /* allocate gzFile structure to return */
    state = (gz_statep)malloc(sizeof(gz_state));
    if (state == NULL)
        return NULL;
    state->size = 0;            /* no buffers allocated yet */
    state->want = GZBUFSIZE;    /* requested buffer size */
    state->msg = NULL;          /* no error message yet */

    /* interpret mode */
    state->mode = GZ_NONE;
    state->level = Z_DEFAULT_COMPRESSION;
    state->strategy = Z_DEFAULT_STRATEGY;
    state->direct = 0;
    while (*mode) {
        if (*mode >= '0' && *mode <= '9')
            state->level = *mode - '0';
        else
            switch (*mode) {
            case 'r':
                state->mode = GZ_READ;
                break;
#ifndef NO_GZCOMPRESS
            case 'w':
                state->mode = GZ_WRITE;
                break;
            case 'a':
                state->mode = GZ_APPEND;
                break;
#endif
            case '+':       /* can't read and write at the same time */
                free(state);
                return NULL;
            case 'b':       /* ignore -- will request binary anyway */
                break;
#ifdef O_CLOEXEC
            case 'e':
                cloexec = 1;
                break;
#endif
#ifdef O_EXCL
            case 'x':
                exclusive = 1;
                break;
#endif
            case 'f':
                state->strategy = Z_FILTERED;
                break;
            case 'h':
                state->strategy = Z_HUFFMAN_ONLY;
                break;
            case 'R':
                state->strategy = Z_RLE;
                break;
            case 'F':
                state->strategy = Z_FIXED;
                break;
            case 'T':
                state->direct = 1;
                break;
            default:        /* could consider as an error, but just ignore */
                ;
            }
        mode++;
    }

    /* must provide an "r", "w", or "a" */
    if (state->mode == GZ_NONE) {
        free(state);
        return NULL;
    }

    /* can't force transparent read */
    if (state->mode == GZ_READ) {
        if (state->direct) {
            free(state);
            return NULL;
        }
        state->direct = 1;      /* for empty file */
    }

    /* save the path name for error messages */
#ifdef WIDECHAR
    if (fd == -2) {
        len = wcstombs(NULL, path, 0);
        if (len == (z_size_t)-1)
            len = 0;
    }
    else
#endif
        len = strlen((const char *)path);
    state->path = (char *)malloc(len + 1);
    if (state->path == NULL) {
        free(state);
        return NULL;
    }
#ifdef WIDECHAR
    if (fd == -2)
        if (len)
            wcstombs(state->path, path, len + 1);
        else
            *(state->path) = 0;
    else
#endif
#if !defined(NO_snprintf) && !defined(NO_vsnprintf)
        (void)snprintf(state->path, len + 1, "%s", (const char *)path);
#else
        strcpy(state->path, path);
#endif

    /* compute the flags for open() */
    oflag =
#ifdef O_LARGEFILE
        O_LARGEFILE |
#endif
#ifdef O_BINARY
        O_BINARY |
#endif
#ifdef O_CLOEXEC
        (cloexec ? O_CLOEXEC : 0) |
#endif
        (state->mode == GZ_READ ?
         O_RDONLY :
         (O_WRONLY | O_CREAT |
#ifdef O_EXCL
          (exclusive ? O_EXCL : 0) |
#endif
          (state->mode == GZ_WRITE ?
           O_TRUNC :
           O_APPEND)));

    /* open the file with the appropriate flags (or just use fd) */
    state->fd = fd > -1 ? fd : (
#ifdef WIDECHAR
        fd == -2 ? _wopen(path, oflag, 0666) :
#endif
        open((const char *)path, oflag, 0666));
    if (state->fd == -1) {
        free(state->path);
        free(state);
        return NULL;
    }
    if (state->mode == GZ_APPEND) {
        LSEEK(state->fd, 0, SEEK_END);  /* so gzoffset() is correct */
        state->mode = GZ_WRITE;         /* simplify later checks */
    }

    /* save the current position for rewinding (only if reading) */
    if (state->mode == GZ_READ) {
        state->start = LSEEK(state->fd, 0, SEEK_CUR);
        if (state->start == -1) state->start = 0;
    }

    /* initialize stream */
    gz_reset(state);

    /* return stream */
    return (gzFile)state;
}

/* -- see zlib.h -- */
gzFile ZEXPORT gzopen(path, mode)
    const char *path;
    const char *mode;
{
    return gz_open(path, -1, mode);
}

/* -- see zlib.h -- */
gzFile ZEXPORT gzopen64(path, mode)
    const char *path;
    const char *mode;
{
    return gz_open(path, -1, mode);
}

/* -- see zlib.h -- */
gzFile ZEXPORT gzdopen(fd, mode)
    int fd;
    const char *mode;
{
    char *path;         /* identifier for error messages */
    gzFile gz;

    if (fd == -1 || (path = (char *)malloc(7 + 3 * sizeof(int))) == NULL)
        return NULL;
#if !defined(NO_snprintf) && !defined(NO_vsnprintf)
    (void)snprintf(path, 7 + 3 * sizeof(int), "<fd:%d>", fd);
#else
    sprintf(path, "<fd:%d>", fd);   /* for debugging */
#endif
    gz = gz_open(path, fd, mode);
    free(path);
    return gz;
}

/* -- see zlib.h -- */
#ifdef WIDECHAR
gzFile ZEXPORT gzopen_w(path, mode)
    const wchar_t *path;
    const char *mode;
{
    return gz_open(path, -2, mode);
}
#endif

/* -- see zlib.h -- */
int ZEXPORT gzbuffer(file, size)
    gzFile file;
    unsigned size;
{
    gz_statep state;

    /* get internal structure and check integrity */
    if (file == NULL)
        return -1;
    state = (gz_statep)file;
    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
        return -1;

    /* make sure we haven't already allocated memory */
    if (state->size != 0)
        return -1;

    /* check and set requested size */
    if ((size << 1) < size)
        return -1;              /* need to be able to double it */
    if (size < 2)
        size = 2;               /* need two bytes to check magic header */
    state->want = size;
    return 0;
}

/* -- see zlib.h -- */
int ZEXPORT gzrewind(file)
    gzFile file;
{
    gz_statep state;

    /* get internal structure */
    if (file == NULL)
        return -1;
    state = (gz_statep)file;

    /* check that we're reading and that there's no error */
    if (state->mode != GZ_READ ||
            (state->err != Z_OK && state->err != Z_BUF_ERROR))
        return -1;

    /* back up and start over */
    if (LSEEK(state->fd, state->start, SEEK_SET) == -1)
        return -1;
    gz_reset(state);
    return 0;
}

/* -- see zlib.h -- */
z_off64_t ZEXPORT gzseek64(file, offset, whence)
    gzFile file;
    z_off64_t offset;
    int whence;
{
    unsigned n;
    z_off64_t ret;
    gz_statep state;

    /* get internal structure and check integrity */
    if (file == NULL)
        return -1;
    state = (gz_statep)file;
    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
        return -1;

    /* check that there's no error */
    if (state->err != Z_OK && state->err != Z_BUF_ERROR)
        return -1;

    /* can only seek from start or relative to current position */
    if (whence != SEEK_SET && whence != SEEK_CUR)
        return -1;

    /* normalize offset to a SEEK_CUR specification */
    if (whence == SEEK_SET)
        offset -= state->x.pos;
    else if (state->seek)
        offset += state->skip;
    state->seek = 0;

    /* if within raw area while reading, just go there */
    if (state->mode == GZ_READ && state->how == COPY &&
            state->x.pos + offset >= 0) {
        ret = LSEEK(state->fd, offset - state->x.have, SEEK_CUR);
        if (ret == -1)
            return -1;
        state->x.have = 0;
        state->eof = 0;
        state->past = 0;
        state->seek = 0;
        gz_error(state, Z_OK, NULL);
        state->strm.avail_in = 0;
        state->x.pos += offset;
        return state->x.pos;
    }

    /* calculate skip amount, rewinding if needed for back seek when reading */
    if (offset < 0) {
        if (state->mode != GZ_READ)         /* writing -- can't go backwards */
            return -1;
        offset += state->x.pos;
        if (offset < 0)                     /* before start of file! */
            return -1;
        if (gzrewind(file) == -1)           /* rewind, then skip to offset */
            return -1;
    }

    /* if reading, skip what's in output buffer (one less gzgetc() check) */
    if (state->mode == GZ_READ) {
        n = GT_OFF(state->x.have) || (z_off64_t)state->x.have > offset ?
            (unsigned)offset : state->x.have;
        state->x.have -= n;
        state->x.next += n;
        state->x.pos += n;
        offset -= n;
    }

    /* request skip (if not zero) */
    if (offset) {
        state->seek = 1;
        state->skip = offset;
    }
    return state->x.pos + offset;
}

/* -- see zlib.h -- */
z_off_t ZEXPORT gzseek(file, offset, whence)
    gzFile file;
    z_off_t offset;
    int whence;
{
    z_off64_t ret;

    ret = gzseek64(file, (z_off64_t)offset, whence);
    return ret == (z_off_t)ret ? (z_off_t)ret : -1;
}

/* -- see zlib.h -- */
z_off64_t ZEXPORT gztell64(file)
    gzFile file;
{
    gz_statep state;

    /* get internal structure and check integrity */
    if (file == NULL)
        return -1;
    state = (gz_statep)file;
    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
        return -1;

    /* return position */
    return state->x.pos + (state->seek ? state->skip : 0);
}

/* -- see zlib.h -- */
z_off_t ZEXPORT gztell(file)
    gzFile file;
{
    z_off64_t ret;

    ret = gztell64(file);
    return ret == (z_off_t)ret ? (z_off_t)ret : -1;
}

/* -- see zlib.h -- */
z_off64_t ZEXPORT gzoffset64(file)
    gzFile file;
{
    z_off64_t offset;
    gz_statep state;

    /* get internal structure and check integrity */
    if (file == NULL)
        return -1;
    state = (gz_statep)file;
    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
        return -1;

    /* compute and return effective offset in file */
    offset = LSEEK(state->fd, 0, SEEK_CUR);
    if (offset == -1)
        return -1;
    if (state->mode == GZ_READ)             /* reading */
        offset -= state->strm.avail_in;     /* don't count buffered input */
    return offset;
}

/* -- see zlib.h -- */
z_off_t ZEXPORT gzoffset(file)
    gzFile file;
{
    z_off64_t ret;

    ret = gzoffset64(file);
    return ret == (z_off_t)ret ? (z_off_t)ret : -1;
}

/* -- see zlib.h -- */
int ZEXPORT gzeof(file)
    gzFile file;
{
    gz_statep state;

    /* get internal structure and check integrity */
    if (file == NULL)
        return 0;
    state = (gz_statep)file;
    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
        return 0;

    /* return end-of-file state */
    return state->mode == GZ_READ ? state->past : 0;
}

/* -- see zlib.h -- */
const char * ZEXPORT gzerror(file, errnum)
    gzFile file;
    int *errnum;
{
    gz_statep state;

    /* get internal structure and check integrity */
    if (file == NULL)
        return NULL;
    state = (gz_statep)file;
    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
        return NULL;

    /* return error information */
    if (errnum != NULL)
        *errnum = state->err;
    return state->err == Z_MEM_ERROR ? "out of memory" :
                                       (state->msg == NULL ? "" : state->msg);
}

/* -- see zlib.h -- */
void ZEXPORT gzclearerr(file)
    gzFile file;
{
    gz_statep state;

    /* get internal structure and check integrity */
    if (file == NULL)
        return;
    state = (gz_statep)file;
    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
        return;

    /* clear error and end-of-file */
    if (state->mode == GZ_READ) {
        state->eof = 0;
        state->past = 0;
    }
    gz_error(state, Z_OK, NULL);
}

/* Create an error message in allocated memory and set state->err and
   state->msg accordingly.  Free any previous error message already there.  Do
   not try to free or allocate space if the error is Z_MEM_ERROR (out of
   memory).  Simply save the error message as a static string.  If there is an
   allocation failure constructing the error message, then convert the error to
   out of memory. */
void ZLIB_INTERNAL gz_error(state, err, msg)
    gz_statep state;
    int err;
    const char *msg;
{
    /* free previously allocated message and clear */
    if (state->msg != NULL) {
        if (state->err != Z_MEM_ERROR)
            free(state->msg);
        state->msg = NULL;
    }

    /* if fatal, set state->x.have to 0 so that the gzgetc() macro fails */
    if (err != Z_OK && err != Z_BUF_ERROR)
        state->x.have = 0;

    /* set error code, and if no message, then done */
    state->err = err;
    if (msg == NULL)
        return;

    /* for an out of memory error, return literal string when requested */
    if (err == Z_MEM_ERROR)
        return;

    /* construct error message with path */
    if ((state->msg = (char *)malloc(strlen(state->path) + strlen(msg) + 3)) ==
            NULL) {
        state->err = Z_MEM_ERROR;
        return;
    }
#if !defined(NO_snprintf) && !defined(NO_vsnprintf)
    (void)snprintf(state->msg, strlen(state->path) + strlen(msg) + 3,
                   "%s%s%s", state->path, ": ", msg);
#else
    strcpy(state->msg, state->path);
    strcat(state->msg, ": ");
    strcat(state->msg, msg);
#endif
}

#ifndef INT_MAX
/* portably return maximum value for an int (when limits.h presumed not
   available) -- we need to do this to cover cases where 2's complement not
   used, since C standard permits 1's complement and sign-bit representations,
   otherwise we could just use ((unsigned)-1) >> 1 */
unsigned ZLIB_INTERNAL gz_intmax()
{
    unsigned p, q;

    p = 1;
    do {
        q = p;
        p <<= 1;
        p++;
    } while (p > q);
    return q >> 1;
}
#endif

```

`efiXloader/3rd/uefitool/common/zlib/gzread.c`:

```c
/* gzread.c -- zlib functions for reading gzip files
 * Copyright (C) 2004, 2005, 2010, 2011, 2012, 2013, 2016 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

#include "gzguts.h"

/* Local functions */
local int gz_load OF((gz_statep, unsigned char *, unsigned, unsigned *));
local int gz_avail OF((gz_statep));
local int gz_look OF((gz_statep));
local int gz_decomp OF((gz_statep));
local int gz_fetch OF((gz_statep));
local int gz_skip OF((gz_statep, z_off64_t));
local z_size_t gz_read OF((gz_statep, voidp, z_size_t));

/* Use read() to load a buffer -- return -1 on error, otherwise 0.  Read from
   state->fd, and update state->eof, state->err, and state->msg as appropriate.
   This function needs to loop on read(), since read() is not guaranteed to
   read the number of bytes requested, depending on the type of descriptor. */
local int gz_load(state, buf, len, have)
    gz_statep state;
    unsigned char *buf;
    unsigned len;
    unsigned *have;
{
    int ret;
    unsigned get, max = ((unsigned)-1 >> 2) + 1;

    *have = 0;
    do {
        get = len - *have;
        if (get > max)
            get = max;
        ret = read(state->fd, buf + *have, get);
        if (ret <= 0)
            break;
        *have += (unsigned)ret;
    } while (*have < len);
    if (ret < 0) {
        gz_error(state, Z_ERRNO, zstrerror());
        return -1;
    }
    if (ret == 0)
        state->eof = 1;
    return 0;
}

/* Load up input buffer and set eof flag if last data loaded -- return -1 on
   error, 0 otherwise.  Note that the eof flag is set when the end of the input
   file is reached, even though there may be unused data in the buffer.  Once
   that data has been used, no more attempts will be made to read the file.
   If strm->avail_in != 0, then the current data is moved to the beginning of
   the input buffer, and then the remainder of the buffer is loaded with the
   available data from the input file. */
local int gz_avail(state)
    gz_statep state;
{
    unsigned got;
    z_streamp strm = &(state->strm);

    if (state->err != Z_OK && state->err != Z_BUF_ERROR)
        return -1;
    if (state->eof == 0) {
        if (strm->avail_in) {       /* copy what's there to the start */
            unsigned char *p = state->in;
            unsigned const char *q = strm->next_in;
            unsigned n = strm->avail_in;
            do {
                *p++ = *q++;
            } while (--n);
        }
        if (gz_load(state, state->in + strm->avail_in,
                    state->size - strm->avail_in, &got) == -1)
            return -1;
        strm->avail_in += got;
        strm->next_in = state->in;
    }
    return 0;
}

/* Look for gzip header, set up for inflate or copy.  state->x.have must be 0.
   If this is the first time in, allocate required memory.  state->how will be
   left unchanged if there is no more input data available, will be set to COPY
   if there is no gzip header and direct copying will be performed, or it will
   be set to GZIP for decompression.  If direct copying, then leftover input
   data from the input buffer will be copied to the output buffer.  In that
   case, all further file reads will be directly to either the output buffer or
   a user buffer.  If decompressing, the inflate state will be initialized.
   gz_look() will return 0 on success or -1 on failure. */
local int gz_look(state)
    gz_statep state;
{
    z_streamp strm = &(state->strm);

    /* allocate read buffers and inflate memory */
    if (state->size == 0) {
        /* allocate buffers */
        state->in = (unsigned char *)malloc(state->want);
        state->out = (unsigned char *)malloc(state->want << 1);
        if (state->in == NULL || state->out == NULL) {
            free(state->out);
            free(state->in);
            gz_error(state, Z_MEM_ERROR, "out of memory");
            return -1;
        }
        state->size = state->want;

        /* allocate inflate memory */
        state->strm.zalloc = Z_NULL;
        state->strm.zfree = Z_NULL;
        state->strm.opaque = Z_NULL;
        state->strm.avail_in = 0;
        state->strm.next_in = Z_NULL;
        if (inflateInit2(&(state->strm), 15 + 16) != Z_OK) {    /* gunzip */
            free(state->out);
            free(state->in);
            state->size = 0;
            gz_error(state, Z_MEM_ERROR, "out of memory");
            return -1;
        }
    }

    /* get at least the magic bytes in the input buffer */
    if (strm->avail_in < 2) {
        if (gz_avail(state) == -1)
            return -1;
        if (strm->avail_in == 0)
            return 0;
    }

    /* look for gzip magic bytes -- if there, do gzip decoding (note: there is
       a logical dilemma here when considering the case of a partially written
       gzip file, to wit, if a single 31 byte is written, then we cannot tell
       whether this is a single-byte file, or just a partially written gzip
       file -- for here we assume that if a gzip file is being written, then
       the header will be written in a single operation, so that reading a
       single byte is sufficient indication that it is not a gzip file) */
    if (strm->avail_in > 1 &&
            strm->next_in[0] == 31 && strm->next_in[1] == 139) {
        inflateReset(strm);
        state->how = GZIP;
        state->direct = 0;
        return 0;
    }

    /* no gzip header -- if we were decoding gzip before, then this is trailing
       garbage.  Ignore the trailing garbage and finish. */
    if (state->direct == 0) {
        strm->avail_in = 0;
        state->eof = 1;
        state->x.have = 0;
        return 0;
    }

    /* doing raw i/o, copy any leftover input to output -- this assumes that
       the output buffer is larger than the input buffer, which also assures
       space for gzungetc() */
    state->x.next = state->out;
    if (strm->avail_in) {
        memcpy(state->x.next, strm->next_in, strm->avail_in);
        state->x.have = strm->avail_in;
        strm->avail_in = 0;
    }
    state->how = COPY;
    state->direct = 1;
    return 0;
}

/* Decompress from input to the provided next_out and avail_out in the state.
   On return, state->x.have and state->x.next point to the just decompressed
   data.  If the gzip stream completes, state->how is reset to LOOK to look for
   the next gzip stream or raw data, once state->x.have is depleted.  Returns 0
   on success, -1 on failure. */
local int gz_decomp(state)
    gz_statep state;
{
    int ret = Z_OK;
    unsigned had;
    z_streamp strm = &(state->strm);

    /* fill output buffer up to end of deflate stream */
    had = strm->avail_out;
    do {
        /* get more input for inflate() */
        if (strm->avail_in == 0 && gz_avail(state) == -1)
            return -1;
        if (strm->avail_in == 0) {
            gz_error(state, Z_BUF_ERROR, "unexpected end of file");
            break;
        }

        /* decompress and handle errors */
        ret = inflate(strm, Z_NO_FLUSH);
        if (ret == Z_STREAM_ERROR || ret == Z_NEED_DICT) {
            gz_error(state, Z_STREAM_ERROR,
                     "internal error: inflate stream corrupt");
            return -1;
        }
        if (ret == Z_MEM_ERROR) {
            gz_error(state, Z_MEM_ERROR, "out of memory");
            return -1;
        }
        if (ret == Z_DATA_ERROR) {              /* deflate stream invalid */
            gz_error(state, Z_DATA_ERROR,
                     strm->msg == NULL ? "compressed data error" : strm->msg);
            return -1;
        }
    } while (strm->avail_out && ret != Z_STREAM_END);

    /* update available output */
    state->x.have = had - strm->avail_out;
    state->x.next = strm->next_out - state->x.have;

    /* if the gzip stream completed successfully, look for another */
    if (ret == Z_STREAM_END)
        state->how = LOOK;

    /* good decompression */
    return 0;
}

/* Fetch data and put it in the output buffer.  Assumes state->x.have is 0.
   Data is either copied from the input file or decompressed from the input
   file depending on state->how.  If state->how is LOOK, then a gzip header is
   looked for to determine whether to copy or decompress.  Returns -1 on error,
   otherwise 0.  gz_fetch() will leave state->how as COPY or GZIP unless the
   end of the input file has been reached and all data has been processed.  */
local int gz_fetch(state)
    gz_statep state;
{
    z_streamp strm = &(state->strm);

    do {
        switch(state->how) {
        case LOOK:      /* -> LOOK, COPY (only if never GZIP), or GZIP */
            if (gz_look(state) == -1)
                return -1;
            if (state->how == LOOK)
                return 0;
            break;
        case COPY:      /* -> COPY */
            if (gz_load(state, state->out, state->size << 1, &(state->x.have))
                    == -1)
                return -1;
            state->x.next = state->out;
            return 0;
        case GZIP:      /* -> GZIP or LOOK (if end of gzip stream) */
            strm->avail_out = state->size << 1;
            strm->next_out = state->out;
            if (gz_decomp(state) == -1)
                return -1;
        }
    } while (state->x.have == 0 && (!state->eof || strm->avail_in));
    return 0;
}

/* Skip len uncompressed bytes of output.  Return -1 on error, 0 on success. */
local int gz_skip(state, len)
    gz_statep state;
    z_off64_t len;
{
    unsigned n;

    /* skip over len bytes or reach end-of-file, whichever comes first */
    while (len)
        /* skip over whatever is in output buffer */
        if (state->x.have) {
            n = GT_OFF(state->x.have) || (z_off64_t)state->x.have > len ?
                (unsigned)len : state->x.have;
            state->x.have -= n;
            state->x.next += n;
            state->x.pos += n;
            len -= n;
        }

        /* output buffer empty -- return if we're at the end of the input */
        else if (state->eof && state->strm.avail_in == 0)
            break;

        /* need more data to skip -- load up output buffer */
        else {
            /* get more output, looking for header if required */
            if (gz_fetch(state) == -1)
                return -1;
        }
    return 0;
}

/* Read len bytes into buf from file, or less than len up to the end of the
   input.  Return the number of bytes read.  If zero is returned, either the
   end of file was reached, or there was an error.  state->err must be
   consulted in that case to determine which. */
local z_size_t gz_read(state, buf, len)
    gz_statep state;
    voidp buf;
    z_size_t len;
{
    z_size_t got;
    unsigned n;

    /* if len is zero, avoid unnecessary operations */
    if (len == 0)
        return 0;

    /* process a skip request */
    if (state->seek) {
        state->seek = 0;
        if (gz_skip(state, state->skip) == -1)
            return 0;
    }

    /* get len bytes to buf, or less than len if at the end */
    got = 0;
    do {
        /* set n to the maximum amount of len that fits in an unsigned int */
        n = -1;
        if (n > len)
            n = len;

        /* first just try copying data from the output buffer */
        if (state->x.have) {
            if (state->x.have < n)
                n = state->x.have;
            memcpy(buf, state->x.next, n);
            state->x.next += n;
            state->x.have -= n;
        }

        /* output buffer empty -- return if we're at the end of the input */
        else if (state->eof && state->strm.avail_in == 0) {
            state->past = 1;        /* tried to read past end */
            break;
        }

        /* need output data -- for small len or new stream load up our output
           buffer */
        else if (state->how == LOOK || n < (state->size << 1)) {
            /* get more output, looking for header if required */
            if (gz_fetch(state) == -1)
                return 0;
            continue;       /* no progress yet -- go back to copy above */
            /* the copy above assures that we will leave with space in the
               output buffer, allowing at least one gzungetc() to succeed */
        }

        /* large len -- read directly into user buffer */
        else if (state->how == COPY) {      /* read directly */
            if (gz_load(state, (unsigned char *)buf, n, &n) == -1)
                return 0;
        }

        /* large len -- decompress directly into user buffer */
        else {  /* state->how == GZIP */
            state->strm.avail_out = n;
            state->strm.next_out = (unsigned char *)buf;
            if (gz_decomp(state) == -1)
                return 0;
            n = state->x.have;
            state->x.have = 0;
        }

        /* update progress */
        len -= n;
        buf = (char *)buf + n;
        got += n;
        state->x.pos += n;
    } while (len);

    /* return number of bytes read into user buffer */
    return got;
}

/* -- see zlib.h -- */
int ZEXPORT gzread(file, buf, len)
    gzFile file;
    voidp buf;
    unsigned len;
{
    gz_statep state;

    /* get internal structure */
    if (file == NULL)
        return -1;
    state = (gz_statep)file;

    /* check that we're reading and that there's no (serious) error */
    if (state->mode != GZ_READ ||
            (state->err != Z_OK && state->err != Z_BUF_ERROR))
        return -1;

    /* since an int is returned, make sure len fits in one, otherwise return
       with an error (this avoids a flaw in the interface) */
    if ((int)len < 0) {
        gz_error(state, Z_STREAM_ERROR, "request does not fit in an int");
        return -1;
    }

    /* read len or fewer bytes to buf */
    len = gz_read(state, buf, len);

    /* check for an error */
    if (len == 0 && state->err != Z_OK && state->err != Z_BUF_ERROR)
        return -1;

    /* return the number of bytes read (this is assured to fit in an int) */
    return (int)len;
}

/* -- see zlib.h -- */
z_size_t ZEXPORT gzfread(buf, size, nitems, file)
    voidp buf;
    z_size_t size;
    z_size_t nitems;
    gzFile file;
{
    z_size_t len;
    gz_statep state;

    if (nitems == 0 || size == 0)
        return 0;
    
    /* get internal structure */
    if (file == NULL)
        return 0;
    state = (gz_statep)file;

    /* check that we're reading and that there's no (serious) error */
    if (state->mode != GZ_READ ||
            (state->err != Z_OK && state->err != Z_BUF_ERROR))
        return 0;

    /* compute bytes to read -- error on overflow */
    len = nitems * size;
    if (size && len / size != nitems) {
        gz_error(state, Z_STREAM_ERROR, "request does not fit in a size_t");
        return 0;
    }

    /* read len or fewer bytes to buf, return the number of full items read */
    return len ? gz_read(state, buf, len) / size : 0;
}

/* -- see zlib.h -- */
#ifdef Z_PREFIX_SET
#  undef z_gzgetc
#else
#  undef gzgetc
#endif
int ZEXPORT gzgetc(file)
    gzFile file;
{
    int ret;
    unsigned char buf[1];
    gz_statep state;

    /* get internal structure */
    if (file == NULL)
        return -1;
    state = (gz_statep)file;

    /* check that we're reading and that there's no (serious) error */
    if (state->mode != GZ_READ ||
        (state->err != Z_OK && state->err != Z_BUF_ERROR))
        return -1;

    /* try output buffer (no need to check for skip request) */
    if (state->x.have) {
        state->x.have--;
        state->x.pos++;
        return *(state->x.next)++;
    }

    /* nothing there -- try gz_read() */
    ret = gz_read(state, buf, 1);
    return ret < 1 ? -1 : buf[0];
}

int ZEXPORT gzgetc_(file)
gzFile file;
{
    return gzgetc(file);
}

/* -- see zlib.h -- */
int ZEXPORT gzungetc(c, file)
    int c;
    gzFile file;
{
    gz_statep state;

    /* get internal structure */
    if (file == NULL)
        return -1;
    state = (gz_statep)file;

    /* check that we're reading and that there's no (serious) error */
    if (state->mode != GZ_READ ||
        (state->err != Z_OK && state->err != Z_BUF_ERROR))
        return -1;

    /* process a skip request */
    if (state->seek) {
        state->seek = 0;
        if (gz_skip(state, state->skip) == -1)
            return -1;
    }

    /* can't push EOF */
    if (c < 0)
        return -1;

    /* if output buffer empty, put byte at end (allows more pushing) */
    if (state->x.have == 0) {
        state->x.have = 1;
        state->x.next = state->out + (state->size << 1) - 1;
        state->x.next[0] = (unsigned char)c;
        state->x.pos--;
        state->past = 0;
        return c;
    }

    /* if no room, give up (must have already done a gzungetc()) */
    if (state->x.have == (state->size << 1)) {
        gz_error(state, Z_DATA_ERROR, "out of room to push characters");
        return -1;
    }

    /* slide output data if needed and insert byte before existing data */
    if (state->x.next == state->out) {
        unsigned char *src = state->out + state->x.have;
        unsigned char *dest = state->out + (state->size << 1);
        while (src > state->out)
            *--dest = *--src;
        state->x.next = dest;
    }
    state->x.have++;
    state->x.next--;
    state->x.next[0] = (unsigned char)c;
    state->x.pos--;
    state->past = 0;
    return c;
}

/* -- see zlib.h -- */
char * ZEXPORT gzgets(file, buf, len)
    gzFile file;
    char *buf;
    int len;
{
    unsigned left, n;
    char *str;
    unsigned char *eol;
    gz_statep state;

    /* check parameters and get internal structure */
    if (file == NULL || buf == NULL || len < 1)
        return NULL;
    state = (gz_statep)file;

    /* check that we're reading and that there's no (serious) error */
    if (state->mode != GZ_READ ||
        (state->err != Z_OK && state->err != Z_BUF_ERROR))
        return NULL;

    /* process a skip request */
    if (state->seek) {
        state->seek = 0;
        if (gz_skip(state, state->skip) == -1)
            return NULL;
    }

    /* copy output bytes up to new line or len - 1, whichever comes first --
       append a terminating zero to the string (we don't check for a zero in
       the contents, let the user worry about that) */
    str = buf;
    left = (unsigned)len - 1;
    if (left) do {
        /* assure that something is in the output buffer */
        if (state->x.have == 0 && gz_fetch(state) == -1)
            return NULL;                /* error */
        if (state->x.have == 0) {       /* end of file */
            state->past = 1;            /* read past end */
            break;                      /* return what we have */
        }

        /* look for end-of-line in current output buffer */
        n = state->x.have > left ? left : state->x.have;
        eol = (unsigned char *)memchr(state->x.next, '\n', n);
        if (eol != NULL)
            n = (unsigned)(eol - state->x.next) + 1;

        /* copy through end-of-line, or remainder if not found */
        memcpy(buf, state->x.next, n);
        state->x.have -= n;
        state->x.next += n;
        state->x.pos += n;
        left -= n;
        buf += n;
    } while (left && eol == NULL);

    /* return terminated string, or if nothing, end of file */
    if (buf == str)
        return NULL;
    buf[0] = 0;
    return str;
}

/* -- see zlib.h -- */
int ZEXPORT gzdirect(file)
    gzFile file;
{
    gz_statep state;

    /* get internal structure */
    if (file == NULL)
        return 0;
    state = (gz_statep)file;

    /* if the state is not known, but we can find out, then do so (this is
       mainly for right after a gzopen() or gzdopen()) */
    if (state->mode == GZ_READ && state->how == LOOK && state->x.have == 0)
        (void)gz_look(state);

    /* return 1 if transparent, 0 if processing a gzip stream */
    return state->direct;
}

/* -- see zlib.h -- */
int ZEXPORT gzclose_r(file)
    gzFile file;
{
    int ret, err;
    gz_statep state;

    /* get internal structure */
    if (file == NULL)
        return Z_STREAM_ERROR;
    state = (gz_statep)file;

    /* check that we're reading */
    if (state->mode != GZ_READ)
        return Z_STREAM_ERROR;

    /* free memory and close file */
    if (state->size) {
        inflateEnd(&(state->strm));
        free(state->out);
        free(state->in);
    }
    err = state->err == Z_BUF_ERROR ? Z_BUF_ERROR : Z_OK;
    gz_error(state, Z_OK, NULL);
    free(state->path);
    ret = close(state->fd);
    free(state);
    return ret ? Z_ERRNO : err;
}

```

`efiXloader/3rd/uefitool/common/zlib/gzwrite.c`:

```c
/* gzwrite.c -- zlib functions for writing gzip files
 * Copyright (C) 2004-2017 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

#include "gzguts.h"

/* Local functions */
local int gz_init OF((gz_statep));
local int gz_comp OF((gz_statep, int));
local int gz_zero OF((gz_statep, z_off64_t));
local z_size_t gz_write OF((gz_statep, voidpc, z_size_t));

/* Initialize state for writing a gzip file.  Mark initialization by setting
   state->size to non-zero.  Return -1 on a memory allocation failure, or 0 on
   success. */
local int gz_init(state)
    gz_statep state;
{
    int ret;
    z_streamp strm = &(state->strm);

    /* allocate input buffer (double size for gzprintf) */
    state->in = (unsigned char *)malloc(state->want << 1);
    if (state->in == NULL) {
        gz_error(state, Z_MEM_ERROR, "out of memory");
        return -1;
    }

    /* only need output buffer and deflate state if compressing */
    if (!state->direct) {
        /* allocate output buffer */
        state->out = (unsigned char *)malloc(state->want);
        if (state->out == NULL) {
            free(state->in);
            gz_error(state, Z_MEM_ERROR, "out of memory");
            return -1;
        }

        /* allocate deflate memory, set up for gzip compression */
        strm->zalloc = Z_NULL;
        strm->zfree = Z_NULL;
        strm->opaque = Z_NULL;
        ret = deflateInit2(strm, state->level, Z_DEFLATED,
                           MAX_WBITS + 16, DEF_MEM_LEVEL, state->strategy);
        if (ret != Z_OK) {
            free(state->out);
            free(state->in);
            gz_error(state, Z_MEM_ERROR, "out of memory");
            return -1;
        }
        strm->next_in = NULL;
    }

    /* mark state as initialized */
    state->size = state->want;

    /* initialize write buffer if compressing */
    if (!state->direct) {
        strm->avail_out = state->size;
        strm->next_out = state->out;
        state->x.next = strm->next_out;
    }
    return 0;
}

/* Compress whatever is at avail_in and next_in and write to the output file.
   Return -1 if there is an error writing to the output file or if gz_init()
   fails to allocate memory, otherwise 0.  flush is assumed to be a valid
   deflate() flush value.  If flush is Z_FINISH, then the deflate() state is
   reset to start a new gzip stream.  If gz->direct is true, then simply write
   to the output file without compressing, and ignore flush. */
local int gz_comp(state, flush)
    gz_statep state;
    int flush;
{
    int ret, writ;
    unsigned have, put, max = ((unsigned)-1 >> 2) + 1;
    z_streamp strm = &(state->strm);

    /* allocate memory if this is the first time through */
    if (state->size == 0 && gz_init(state) == -1)
        return -1;

    /* write directly if requested */
    if (state->direct) {
        while (strm->avail_in) {
            put = strm->avail_in > max ? max : strm->avail_in;
            writ = write(state->fd, strm->next_in, put);
            if (writ < 0) {
                gz_error(state, Z_ERRNO, zstrerror());
                return -1;
            }
            strm->avail_in -= (unsigned)writ;
            strm->next_in += writ;
        }
        return 0;
    }

    /* run deflate() on provided input until it produces no more output */
    ret = Z_OK;
    do {
        /* write out current buffer contents if full, or if flushing, but if
           doing Z_FINISH then don't write until we get to Z_STREAM_END */
        if (strm->avail_out == 0 || (flush != Z_NO_FLUSH &&
            (flush != Z_FINISH || ret == Z_STREAM_END))) {
            while (strm->next_out > state->x.next) {
                put = strm->next_out - state->x.next > (int)max ? max :
                      (unsigned)(strm->next_out - state->x.next);
                writ = write(state->fd, state->x.next, put);
                if (writ < 0) {
                    gz_error(state, Z_ERRNO, zstrerror());
                    return -1;
                }
                state->x.next += writ;
            }
            if (strm->avail_out == 0) {
                strm->avail_out = state->size;
                strm->next_out = state->out;
                state->x.next = state->out;
            }
        }

        /* compress */
        have = strm->avail_out;
        ret = deflate(strm, flush);
        if (ret == Z_STREAM_ERROR) {
            gz_error(state, Z_STREAM_ERROR,
                      "internal error: deflate stream corrupt");
            return -1;
        }
        have -= strm->avail_out;
    } while (have);

    /* if that completed a deflate stream, allow another to start */
    if (flush == Z_FINISH)
        deflateReset(strm);

    /* all done, no errors */
    return 0;
}

/* Compress len zeros to output.  Return -1 on a write error or memory
   allocation failure by gz_comp(), or 0 on success. */
local int gz_zero(state, len)
    gz_statep state;
    z_off64_t len;
{
    int first;
    unsigned n;
    z_streamp strm = &(state->strm);

    /* consume whatever's left in the input buffer */
    if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)
        return -1;

    /* compress len zeros (len guaranteed > 0) */
    first = 1;
    while (len) {
        n = GT_OFF(state->size) || (z_off64_t)state->size > len ?
            (unsigned)len : state->size;
        if (first) {
            memset(state->in, 0, n);
            first = 0;
        }
        strm->avail_in = n;
        strm->next_in = state->in;
        state->x.pos += n;
        if (gz_comp(state, Z_NO_FLUSH) == -1)
            return -1;
        len -= n;
    }
    return 0;
}

/* Write len bytes from buf to file.  Return the number of bytes written.  If
   the returned value is less than len, then there was an error. */
local z_size_t gz_write(state, buf, len)
    gz_statep state;
    voidpc buf;
    z_size_t len;
{
    z_size_t put = len;

    /* if len is zero, avoid unnecessary operations */
    if (len == 0)
        return 0;

    /* allocate memory if this is the first time through */
    if (state->size == 0 && gz_init(state) == -1)
        return 0;

    /* check for seek request */
    if (state->seek) {
        state->seek = 0;
        if (gz_zero(state, state->skip) == -1)
            return 0;
    }

    /* for small len, copy to input buffer, otherwise compress directly */
    if (len < state->size) {
        /* copy to input buffer, compress when full */
        do {
            unsigned have, copy;

            if (state->strm.avail_in == 0)
                state->strm.next_in = state->in;
            have = (unsigned)((state->strm.next_in + state->strm.avail_in) -
                              state->in);
            copy = state->size - have;
            if (copy > len)
                copy = len;
            memcpy(state->in + have, buf, copy);
            state->strm.avail_in += copy;
            state->x.pos += copy;
            buf = (const char *)buf + copy;
            len -= copy;
            if (len && gz_comp(state, Z_NO_FLUSH) == -1)
                return 0;
        } while (len);
    }
    else {
        /* consume whatever's left in the input buffer */
        if (state->strm.avail_in && gz_comp(state, Z_NO_FLUSH) == -1)
            return 0;

        /* directly compress user buffer to file */
        state->strm.next_in = (z_const Bytef *)buf;
        do {
            unsigned n = (unsigned)-1;
            if (n > len)
                n = len;
            state->strm.avail_in = n;
            state->x.pos += n;
            if (gz_comp(state, Z_NO_FLUSH) == -1)
                return 0;
            len -= n;
        } while (len);
    }

    /* input was all buffered or compressed */
    return put;
}

/* -- see zlib.h -- */
int ZEXPORT gzwrite(file, buf, len)
    gzFile file;
    voidpc buf;
    unsigned len;
{
    gz_statep state;

    /* get internal structure */
    if (file == NULL)
        return 0;
    state = (gz_statep)file;

    /* check that we're writing and that there's no error */
    if (state->mode != GZ_WRITE || state->err != Z_OK)
        return 0;

    /* since an int is returned, make sure len fits in one, otherwise return
       with an error (this avoids a flaw in the interface) */
    if ((int)len < 0) {
        gz_error(state, Z_DATA_ERROR, "requested length does not fit in int");
        return 0;
    }

    /* write len bytes from buf (the return value will fit in an int) */
    return (int)gz_write(state, buf, len);
}

/* -- see zlib.h -- */
z_size_t ZEXPORT gzfwrite(buf, size, nitems, file)
    voidpc buf;
    z_size_t size;
    z_size_t nitems;
    gzFile file;
{
    z_size_t len;
    gz_statep state;

    if (nitems == 0 || size == 0)
        return 0;
    
    /* get internal structure */
    if (file == NULL)
        return 0;
    state = (gz_statep)file;

    /* check that we're writing and that there's no error */
    if (state->mode != GZ_WRITE || state->err != Z_OK)
        return 0;

    /* compute bytes to read -- error on overflow */
    len = nitems * size;
    if (size && len / size != nitems) {
        gz_error(state, Z_STREAM_ERROR, "request does not fit in a size_t");
        return 0;
    }

    /* write len bytes to buf, return the number of full items written */
    return len ? gz_write(state, buf, len) / size : 0;
}

/* -- see zlib.h -- */
int ZEXPORT gzputc(file, c)
    gzFile file;
    int c;
{
    unsigned have;
    unsigned char buf[1];
    gz_statep state;
    z_streamp strm;

    /* get internal structure */
    if (file == NULL)
        return -1;
    state = (gz_statep)file;
    strm = &(state->strm);

    /* check that we're writing and that there's no error */
    if (state->mode != GZ_WRITE || state->err != Z_OK)
        return -1;

    /* check for seek request */
    if (state->seek) {
        state->seek = 0;
        if (gz_zero(state, state->skip) == -1)
            return -1;
    }

    /* try writing to input buffer for speed (state->size == 0 if buffer not
       initialized) */
    if (state->size) {
        if (strm->avail_in == 0)
            strm->next_in = state->in;
        have = (unsigned)((strm->next_in + strm->avail_in) - state->in);
        if (have < state->size) {
            state->in[have] = (unsigned char)c;
            strm->avail_in++;
            state->x.pos++;
            return c & 0xff;
        }
    }

    /* no room in buffer or not initialized, use gz_write() */
    buf[0] = (unsigned char)c;
    if (gz_write(state, buf, 1) != 1)
        return -1;
    return c & 0xff;
}

/* -- see zlib.h -- */
int ZEXPORT gzputs(file, str)
    gzFile file;
    const char *str;
{
    int ret;
    z_size_t len;
    gz_statep state;

    /* get internal structure */
    if (file == NULL)
        return -1;
    state = (gz_statep)file;

    /* check that we're writing and that there's no error */
    if (state->mode != GZ_WRITE || state->err != Z_OK)
        return -1;

    /* write string */
    len = strlen(str);
    ret = gz_write(state, str, len);
    return ret == 0 && len != 0 ? -1 : ret;
}

#if defined(STDC) || defined(Z_HAVE_STDARG_H)
#include <stdarg.h>

/* -- see zlib.h -- */
int ZEXPORTVA gzvprintf(gzFile file, const char *format, va_list va)
{
    int len;
    unsigned left;
    char *next;
    gz_statep state;
    z_streamp strm;

    /* get internal structure */
    if (file == NULL)
        return Z_STREAM_ERROR;
    state = (gz_statep)file;
    strm = &(state->strm);

    /* check that we're writing and that there's no error */
    if (state->mode != GZ_WRITE || state->err != Z_OK)
        return Z_STREAM_ERROR;

    /* make sure we have some buffer space */
    if (state->size == 0 && gz_init(state) == -1)
        return state->err;

    /* check for seek request */
    if (state->seek) {
        state->seek = 0;
        if (gz_zero(state, state->skip) == -1)
            return state->err;
    }

    /* do the printf() into the input buffer, put length in len -- the input
       buffer is double-sized just for this function, so there is guaranteed to
       be state->size bytes available after the current contents */
    if (strm->avail_in == 0)
        strm->next_in = state->in;
    next = (char *)(state->in + (strm->next_in - state->in) + strm->avail_in);
    next[state->size - 1] = 0;
#ifdef NO_vsnprintf
#  ifdef HAS_vsprintf_void
    (void)vsprintf(next, format, va);
    for (len = 0; len < state->size; len++)
        if (next[len] == 0) break;
#  else
    len = vsprintf(next, format, va);
#  endif
#else
#  ifdef HAS_vsnprintf_void
    (void)vsnprintf(next, state->size, format, va);
    len = strlen(next);
#  else
    len = vsnprintf(next, state->size, format, va);
#  endif
#endif

    /* check that printf() results fit in buffer */
    if (len == 0 || (unsigned)len >= state->size || next[state->size - 1] != 0)
        return 0;

    /* update buffer and position, compress first half if past that */
    strm->avail_in += (unsigned)len;
    state->x.pos += len;
    if (strm->avail_in >= state->size) {
        left = strm->avail_in - state->size;
        strm->avail_in = state->size;
        if (gz_comp(state, Z_NO_FLUSH) == -1)
            return state->err;
        memcpy(state->in, state->in + state->size, left);
        strm->next_in = state->in;
        strm->avail_in = left;
    }
    return len;
}

int ZEXPORTVA gzprintf(gzFile file, const char *format, ...)
{
    va_list va;
    int ret;

    va_start(va, format);
    ret = gzvprintf(file, format, va);
    va_end(va);
    return ret;
}

#else /* !STDC && !Z_HAVE_STDARG_H */

/* -- see zlib.h -- */
int ZEXPORTVA gzprintf (file, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,
                       a11, a12, a13, a14, a15, a16, a17, a18, a19, a20)
    gzFile file;
    const char *format;
    int a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,
        a11, a12, a13, a14, a15, a16, a17, a18, a19, a20;
{
    unsigned len, left;
    char *next;
    gz_statep state;
    z_streamp strm;

    /* get internal structure */
    if (file == NULL)
        return Z_STREAM_ERROR;
    state = (gz_statep)file;
    strm = &(state->strm);

    /* check that can really pass pointer in ints */
    if (sizeof(int) != sizeof(void *))
        return Z_STREAM_ERROR;

    /* check that we're writing and that there's no error */
    if (state->mode != GZ_WRITE || state->err != Z_OK)
        return Z_STREAM_ERROR;

    /* make sure we have some buffer space */
    if (state->size == 0 && gz_init(state) == -1)
        return state->error;

    /* check for seek request */
    if (state->seek) {
        state->seek = 0;
        if (gz_zero(state, state->skip) == -1)
            return state->error;
    }

    /* do the printf() into the input buffer, put length in len -- the input
       buffer is double-sized just for this function, so there is guaranteed to
       be state->size bytes available after the current contents */
    if (strm->avail_in == 0)
        strm->next_in = state->in;
    next = (char *)(strm->next_in + strm->avail_in);
    next[state->size - 1] = 0;
#ifdef NO_snprintf
#  ifdef HAS_sprintf_void
    sprintf(next, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12,
            a13, a14, a15, a16, a17, a18, a19, a20);
    for (len = 0; len < size; len++)
        if (next[len] == 0)
            break;
#  else
    len = sprintf(next, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11,
                  a12, a13, a14, a15, a16, a17, a18, a19, a20);
#  endif
#else
#  ifdef HAS_snprintf_void
    snprintf(next, state->size, format, a1, a2, a3, a4, a5, a6, a7, a8, a9,
             a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
    len = strlen(next);
#  else
    len = snprintf(next, state->size, format, a1, a2, a3, a4, a5, a6, a7, a8,
                   a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
#  endif
#endif

    /* check that printf() results fit in buffer */
    if (len == 0 || len >= state->size || next[state->size - 1] != 0)
        return 0;

    /* update buffer and position, compress first half if past that */
    strm->avail_in += len;
    state->x.pos += len;
    if (strm->avail_in >= state->size) {
        left = strm->avail_in - state->size;
        strm->avail_in = state->size;
        if (gz_comp(state, Z_NO_FLUSH) == -1)
            return state->err;
        memcpy(state->in, state->in + state->size, left);
        strm->next_in = state->in;
        strm->avail_in = left;
    }
    return (int)len;
}

#endif

/* -- see zlib.h -- */
int ZEXPORT gzflush(file, flush)
    gzFile file;
    int flush;
{
    gz_statep state;

    /* get internal structure */
    if (file == NULL)
        return Z_STREAM_ERROR;
    state = (gz_statep)file;

    /* check that we're writing and that there's no error */
    if (state->mode != GZ_WRITE || state->err != Z_OK)
        return Z_STREAM_ERROR;

    /* check flush parameter */
    if (flush < 0 || flush > Z_FINISH)
        return Z_STREAM_ERROR;

    /* check for seek request */
    if (state->seek) {
        state->seek = 0;
        if (gz_zero(state, state->skip) == -1)
            return state->err;
    }

    /* compress remaining data with requested flush */
    (void)gz_comp(state, flush);
    return state->err;
}

/* -- see zlib.h -- */
int ZEXPORT gzsetparams(file, level, strategy)
    gzFile file;
    int level;
    int strategy;
{
    gz_statep state;
    z_streamp strm;

    /* get internal structure */
    if (file == NULL)
        return Z_STREAM_ERROR;
    state = (gz_statep)file;
    strm = &(state->strm);

    /* check that we're writing and that there's no error */
    if (state->mode != GZ_WRITE || state->err != Z_OK)
        return Z_STREAM_ERROR;

    /* if no change is requested, then do nothing */
    if (level == state->level && strategy == state->strategy)
        return Z_OK;

    /* check for seek request */
    if (state->seek) {
        state->seek = 0;
        if (gz_zero(state, state->skip) == -1)
            return state->err;
    }

    /* change compression parameters for subsequent input */
    if (state->size) {
        /* flush previous input with previous parameters before changing */
        if (strm->avail_in && gz_comp(state, Z_BLOCK) == -1)
            return state->err;
        deflateParams(strm, level, strategy);
    }
    state->level = level;
    state->strategy = strategy;
    return Z_OK;
}

/* -- see zlib.h -- */
int ZEXPORT gzclose_w(file)
    gzFile file;
{
    int ret = Z_OK;
    gz_statep state;

    /* get internal structure */
    if (file == NULL)
        return Z_STREAM_ERROR;
    state = (gz_statep)file;

    /* check that we're writing */
    if (state->mode != GZ_WRITE)
        return Z_STREAM_ERROR;

    /* check for seek request */
    if (state->seek) {
        state->seek = 0;
        if (gz_zero(state, state->skip) == -1)
            ret = state->err;
    }

    /* flush, free memory, and close file */
    if (gz_comp(state, Z_FINISH) == -1)
        ret = state->err;
    if (state->size) {
        if (!state->direct) {
            (void)deflateEnd(&(state->strm));
            free(state->out);
        }
        free(state->in);
    }
    gz_error(state, Z_OK, NULL);
    free(state->path);
    if (close(state->fd) == -1)
        ret = Z_ERRNO;
    free(state);
    return ret;
}

```

`efiXloader/3rd/uefitool/common/zlib/infback.c`:

```c
/* infback.c -- inflate using a call-back interface
 * Copyright (C) 1995-2016 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/*
   This code is largely copied from inflate.c.  Normally either infback.o or
   inflate.o would be linked into an application--not both.  The interface
   with inffast.c is retained so that optimized assembler-coded versions of
   inflate_fast() can be used with either inflate.c or infback.c.
 */

#include "zutil.h"
#include "inftrees.h"
#include "inflate.h"
#include "inffast.h"

/* function prototypes */
local void fixedtables OF((struct inflate_state FAR *state));

/*
   strm provides memory allocation functions in zalloc and zfree, or
   Z_NULL to use the library memory allocation functions.

   windowBits is in the range 8..15, and window is a user-supplied
   window and output buffer that is 2**windowBits bytes.
 */
int ZEXPORT inflateBackInit_(strm, windowBits, window, version, stream_size)
z_streamp strm;
int windowBits;
unsigned char FAR *window;
const char *version;
int stream_size;
{
    struct inflate_state FAR *state;

    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
        stream_size != (int)(sizeof(z_stream)))
        return Z_VERSION_ERROR;
    if (strm == Z_NULL || window == Z_NULL ||
        windowBits < 8 || windowBits > 15)
        return Z_STREAM_ERROR;
    strm->msg = Z_NULL;                 /* in case we return an error */
    if (strm->zalloc == (alloc_func)0) {
#ifdef Z_SOLO
        return Z_STREAM_ERROR;
#else
        strm->zalloc = zcalloc;
        strm->opaque = (voidpf)0;
#endif
    }
    if (strm->zfree == (free_func)0)
#ifdef Z_SOLO
        return Z_STREAM_ERROR;
#else
    strm->zfree = zcfree;
#endif
    state = (struct inflate_state FAR *)ZALLOC(strm, 1,
                                               sizeof(struct inflate_state));
    if (state == Z_NULL) return Z_MEM_ERROR;
    Tracev((stderr, "inflate: allocated\n"));
    strm->state = (struct internal_state FAR *)state;
    state->dmax = 32768U;
    state->wbits = (uInt)windowBits;
    state->wsize = 1U << windowBits;
    state->window = window;
    state->wnext = 0;
    state->whave = 0;
    return Z_OK;
}

/*
   Return state with length and distance decoding tables and index sizes set to
   fixed code decoding.  Normally this returns fixed tables from inffixed.h.
   If BUILDFIXED is defined, then instead this routine builds the tables the
   first time it's called, and returns those tables the first time and
   thereafter.  This reduces the size of the code by about 2K bytes, in
   exchange for a little execution time.  However, BUILDFIXED should not be
   used for threaded applications, since the rewriting of the tables and virgin
   may not be thread-safe.
 */
local void fixedtables(state)
struct inflate_state FAR *state;
{
#ifdef BUILDFIXED
    static int virgin = 1;
    static code *lenfix, *distfix;
    static code fixed[544];

    /* build fixed huffman tables if first call (may not be thread safe) */
    if (virgin) {
        unsigned sym, bits;
        static code *next;

        /* literal/length table */
        sym = 0;
        while (sym < 144) state->lens[sym++] = 8;
        while (sym < 256) state->lens[sym++] = 9;
        while (sym < 280) state->lens[sym++] = 7;
        while (sym < 288) state->lens[sym++] = 8;
        next = fixed;
        lenfix = next;
        bits = 9;
        inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);

        /* distance table */
        sym = 0;
        while (sym < 32) state->lens[sym++] = 5;
        distfix = next;
        bits = 5;
        inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);

        /* do this just once */
        virgin = 0;
    }
#else /* !BUILDFIXED */
#   include "inffixed.h"
#endif /* BUILDFIXED */
    state->lencode = lenfix;
    state->lenbits = 9;
    state->distcode = distfix;
    state->distbits = 5;
}

/* Macros for inflateBack(): */

/* Load returned state from inflate_fast() */
#define LOAD() \
    do { \
        put = strm->next_out; \
        left = strm->avail_out; \
        next = strm->next_in; \
        have = strm->avail_in; \
        hold = state->hold; \
        bits = state->bits; \
    } while (0)

/* Set state from registers for inflate_fast() */
#define RESTORE() \
    do { \
        strm->next_out = put; \
        strm->avail_out = left; \
        strm->next_in = next; \
        strm->avail_in = have; \
        state->hold = hold; \
        state->bits = bits; \
    } while (0)

/* Clear the input bit accumulator */
#define INITBITS() \
    do { \
        hold = 0; \
        bits = 0; \
    } while (0)

/* Assure that some input is available.  If input is requested, but denied,
   then return a Z_BUF_ERROR from inflateBack(). */
#define PULL() \
    do { \
        if (have == 0) { \
            have = in(in_desc, &next); \
            if (have == 0) { \
                next = Z_NULL; \
                ret = Z_BUF_ERROR; \
                goto inf_leave; \
            } \
        } \
    } while (0)

/* Get a byte of input into the bit accumulator, or return from inflateBack()
   with an error if there is no input available. */
#define PULLBYTE() \
    do { \
        PULL(); \
        have--; \
        hold += (unsigned long)(*next++) << bits; \
        bits += 8; \
    } while (0)

/* Assure that there are at least n bits in the bit accumulator.  If there is
   not enough available input to do that, then return from inflateBack() with
   an error. */
#define NEEDBITS(n) \
    do { \
        while (bits < (unsigned)(n)) \
            PULLBYTE(); \
    } while (0)

/* Return the low n bits of the bit accumulator (n < 16) */
#define BITS(n) \
    ((unsigned)hold & ((1U << (n)) - 1))

/* Remove n bits from the bit accumulator */
#define DROPBITS(n) \
    do { \
        hold >>= (n); \
        bits -= (unsigned)(n); \
    } while (0)

/* Remove zero to seven bits as needed to go to a byte boundary */
#define BYTEBITS() \
    do { \
        hold >>= bits & 7; \
        bits -= bits & 7; \
    } while (0)

/* Assure that some output space is available, by writing out the window
   if it's full.  If the write fails, return from inflateBack() with a
   Z_BUF_ERROR. */
#define ROOM() \
    do { \
        if (left == 0) { \
            put = state->window; \
            left = state->wsize; \
            state->whave = left; \
            if (out(out_desc, put, left)) { \
                ret = Z_BUF_ERROR; \
                goto inf_leave; \
            } \
        } \
    } while (0)

/*
   strm provides the memory allocation functions and window buffer on input,
   and provides information on the unused input on return.  For Z_DATA_ERROR
   returns, strm will also provide an error message.

   in() and out() are the call-back input and output functions.  When
   inflateBack() needs more input, it calls in().  When inflateBack() has
   filled the window with output, or when it completes with data in the
   window, it calls out() to write out the data.  The application must not
   change the provided input until in() is called again or inflateBack()
   returns.  The application must not change the window/output buffer until
   inflateBack() returns.

   in() and out() are called with a descriptor parameter provided in the
   inflateBack() call.  This parameter can be a structure that provides the
   information required to do the read or write, as well as accumulated
   information on the input and output such as totals and check values.

   in() should return zero on failure.  out() should return non-zero on
   failure.  If either in() or out() fails, than inflateBack() returns a
   Z_BUF_ERROR.  strm->next_in can be checked for Z_NULL to see whether it
   was in() or out() that caused in the error.  Otherwise,  inflateBack()
   returns Z_STREAM_END on success, Z_DATA_ERROR for an deflate format
   error, or Z_MEM_ERROR if it could not allocate memory for the state.
   inflateBack() can also return Z_STREAM_ERROR if the input parameters
   are not correct, i.e. strm is Z_NULL or the state was not initialized.
 */
int ZEXPORT inflateBack(strm, in, in_desc, out, out_desc)
z_streamp strm;
in_func in;
void FAR *in_desc;
out_func out;
void FAR *out_desc;
{
    struct inflate_state FAR *state;
    z_const unsigned char FAR *next;    /* next input */
    unsigned char FAR *put;     /* next output */
    unsigned have, left;        /* available input and output */
    unsigned long hold;         /* bit buffer */
    unsigned bits;              /* bits in bit buffer */
    unsigned copy;              /* number of stored or match bytes to copy */
    unsigned char FAR *from;    /* where to copy match bytes from */
    code here;                  /* current decoding table entry */
    code last;                  /* parent table entry */
    unsigned len;               /* length to copy for repeats, bits to drop */
    int ret;                    /* return code */
    static const unsigned short order[19] = /* permutation of code lengths */
        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};

    /* Check that the strm exists and that the state was initialized */
    if (strm == Z_NULL || strm->state == Z_NULL)
        return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;

    /* Reset the state */
    strm->msg = Z_NULL;
    state->mode = TYPE;
    state->last = 0;
    state->whave = 0;
    next = strm->next_in;
    have = next != Z_NULL ? strm->avail_in : 0;
    hold = 0;
    bits = 0;
    put = state->window;
    left = state->wsize;

    /* Inflate until end of block marked as last */
    for (;;)
        switch (state->mode) {
        case TYPE:
            /* determine and dispatch block type */
            if (state->last) {
                BYTEBITS();
                state->mode = DONE;
                break;
            }
            NEEDBITS(3);
            state->last = BITS(1);
            DROPBITS(1);
            switch (BITS(2)) {
            case 0:                             /* stored block */
                Tracev((stderr, "inflate:     stored block%s\n",
                        state->last ? " (last)" : ""));
                state->mode = STORED;
                break;
            case 1:                             /* fixed block */
                fixedtables(state);
                Tracev((stderr, "inflate:     fixed codes block%s\n",
                        state->last ? " (last)" : ""));
                state->mode = LEN;              /* decode codes */
                break;
            case 2:                             /* dynamic block */
                Tracev((stderr, "inflate:     dynamic codes block%s\n",
                        state->last ? " (last)" : ""));
                state->mode = TABLE;
                break;
            case 3:
                strm->msg = (char *)"invalid block type";
                state->mode = BAD;
            }
            DROPBITS(2);
            break;

        case STORED:
            /* get and verify stored block length */
            BYTEBITS();                         /* go to byte boundary */
            NEEDBITS(32);
            if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {
                strm->msg = (char *)"invalid stored block lengths";
                state->mode = BAD;
                break;
            }
            state->length = (unsigned)hold & 0xffff;
            Tracev((stderr, "inflate:       stored length %u\n",
                    state->length));
            INITBITS();

            /* copy stored block from input to output */
            while (state->length != 0) {
                copy = state->length;
                PULL();
                ROOM();
                if (copy > have) copy = have;
                if (copy > left) copy = left;
                zmemcpy(put, next, copy);
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
                state->length -= copy;
            }
            Tracev((stderr, "inflate:       stored end\n"));
            state->mode = TYPE;
            break;

        case TABLE:
            /* get dynamic table entries descriptor */
            NEEDBITS(14);
            state->nlen = BITS(5) + 257;
            DROPBITS(5);
            state->ndist = BITS(5) + 1;
            DROPBITS(5);
            state->ncode = BITS(4) + 4;
            DROPBITS(4);
#ifndef PKZIP_BUG_WORKAROUND
            if (state->nlen > 286 || state->ndist > 30) {
                strm->msg = (char *)"too many length or distance symbols";
                state->mode = BAD;
                break;
            }
#endif
            Tracev((stderr, "inflate:       table sizes ok\n"));

            /* get code length code lengths (not a typo) */
            state->have = 0;
            while (state->have < state->ncode) {
                NEEDBITS(3);
                state->lens[order[state->have++]] = (unsigned short)BITS(3);
                DROPBITS(3);
            }
            while (state->have < 19)
                state->lens[order[state->have++]] = 0;
            state->next = state->codes;
            state->lencode = (code const FAR *)(state->next);
            state->lenbits = 7;
            ret = inflate_table(CODES, state->lens, 19, &(state->next),
                                &(state->lenbits), state->work);
            if (ret) {
                strm->msg = (char *)"invalid code lengths set";
                state->mode = BAD;
                break;
            }
            Tracev((stderr, "inflate:       code lengths ok\n"));

            /* get length and distance code code lengths */
            state->have = 0;
            while (state->have < state->nlen + state->ndist) {
                for (;;) {
                    here = state->lencode[BITS(state->lenbits)];
                    if ((unsigned)(here.bits) <= bits) break;
                    PULLBYTE();
                }
                if (here.val < 16) {
                    DROPBITS(here.bits);
                    state->lens[state->have++] = here.val;
                }
                else {
                    if (here.val == 16) {
                        NEEDBITS(here.bits + 2);
                        DROPBITS(here.bits);
                        if (state->have == 0) {
                            strm->msg = (char *)"invalid bit length repeat";
                            state->mode = BAD;
                            break;
                        }
                        len = (unsigned)(state->lens[state->have - 1]);
                        copy = 3 + BITS(2);
                        DROPBITS(2);
                    }
                    else if (here.val == 17) {
                        NEEDBITS(here.bits + 3);
                        DROPBITS(here.bits);
                        len = 0;
                        copy = 3 + BITS(3);
                        DROPBITS(3);
                    }
                    else {
                        NEEDBITS(here.bits + 7);
                        DROPBITS(here.bits);
                        len = 0;
                        copy = 11 + BITS(7);
                        DROPBITS(7);
                    }
                    if (state->have + copy > state->nlen + state->ndist) {
                        strm->msg = (char *)"invalid bit length repeat";
                        state->mode = BAD;
                        break;
                    }
                    while (copy--)
                        state->lens[state->have++] = (unsigned short)len;
                }
            }

            /* handle error breaks in while */
            if (state->mode == BAD) break;

            /* check for end-of-block code (better have one) */
            if (state->lens[256] == 0) {
                strm->msg = (char *)"invalid code -- missing end-of-block";
                state->mode = BAD;
                break;
            }

            /* build code tables -- note: do not change the lenbits or distbits
               values here (9 and 6) without reading the comments in inftrees.h
               concerning the ENOUGH constants, which depend on those values */
            state->next = state->codes;
            state->lencode = (code const FAR *)(state->next);
            state->lenbits = 9;
            ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
                                &(state->lenbits), state->work);
            if (ret) {
                strm->msg = (char *)"invalid literal/lengths set";
                state->mode = BAD;
                break;
            }
            state->distcode = (code const FAR *)(state->next);
            state->distbits = 6;
            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
                            &(state->next), &(state->distbits), state->work);
            if (ret) {
                strm->msg = (char *)"invalid distances set";
                state->mode = BAD;
                break;
            }
            Tracev((stderr, "inflate:       codes ok\n"));
            state->mode = LEN;

        case LEN:
            /* use inflate_fast() if we have enough input and output */
            if (have >= 6 && left >= 258) {
                RESTORE();
                if (state->whave < state->wsize)
                    state->whave = state->wsize - left;
                inflate_fast(strm, state->wsize);
                LOAD();
                break;
            }

            /* get a literal, length, or end-of-block code */
            for (;;) {
                here = state->lencode[BITS(state->lenbits)];
                if ((unsigned)(here.bits) <= bits) break;
                PULLBYTE();
            }
            if (here.op && (here.op & 0xf0) == 0) {
                last = here;
                for (;;) {
                    here = state->lencode[last.val +
                            (BITS(last.bits + last.op) >> last.bits)];
                    if ((unsigned)(last.bits + here.bits) <= bits) break;
                    PULLBYTE();
                }
                DROPBITS(last.bits);
            }
            DROPBITS(here.bits);
            state->length = (unsigned)here.val;

            /* process literal */
            if (here.op == 0) {
                Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
                        "inflate:         literal '%c'\n" :
                        "inflate:         literal 0x%02x\n", here.val));
                ROOM();
                *put++ = (unsigned char)(state->length);
                left--;
                state->mode = LEN;
                break;
            }

            /* process end of block */
            if (here.op & 32) {
                Tracevv((stderr, "inflate:         end of block\n"));
                state->mode = TYPE;
                break;
            }

            /* invalid code */
            if (here.op & 64) {
                strm->msg = (char *)"invalid literal/length code";
                state->mode = BAD;
                break;
            }

            /* length code -- get extra bits, if any */
            state->extra = (unsigned)(here.op) & 15;
            if (state->extra != 0) {
                NEEDBITS(state->extra);
                state->length += BITS(state->extra);
                DROPBITS(state->extra);
            }
            Tracevv((stderr, "inflate:         length %u\n", state->length));

            /* get distance code */
            for (;;) {
                here = state->distcode[BITS(state->distbits)];
                if ((unsigned)(here.bits) <= bits) break;
                PULLBYTE();
            }
            if ((here.op & 0xf0) == 0) {
                last = here;
                for (;;) {
                    here = state->distcode[last.val +
                            (BITS(last.bits + last.op) >> last.bits)];
                    if ((unsigned)(last.bits + here.bits) <= bits) break;
                    PULLBYTE();
                }
                DROPBITS(last.bits);
            }
            DROPBITS(here.bits);
            if (here.op & 64) {
                strm->msg = (char *)"invalid distance code";
                state->mode = BAD;
                break;
            }
            state->offset = (unsigned)here.val;

            /* get distance extra bits, if any */
            state->extra = (unsigned)(here.op) & 15;
            if (state->extra != 0) {
                NEEDBITS(state->extra);
                state->offset += BITS(state->extra);
                DROPBITS(state->extra);
            }
            if (state->offset > state->wsize - (state->whave < state->wsize ?
                                                left : 0)) {
                strm->msg = (char *)"invalid distance too far back";
                state->mode = BAD;
                break;
            }
            Tracevv((stderr, "inflate:         distance %u\n", state->offset));

            /* copy match from window to output */
            do {
                ROOM();
                copy = state->wsize - state->offset;
                if (copy < left) {
                    from = put + copy;
                    copy = left - copy;
                }
                else {
                    from = put - state->offset;
                    copy = left;
                }
                if (copy > state->length) copy = state->length;
                state->length -= copy;
                left -= copy;
                do {
                    *put++ = *from++;
                } while (--copy);
            } while (state->length != 0);
            break;

        case DONE:
            /* inflate stream terminated properly -- write leftover output */
            ret = Z_STREAM_END;
            if (left < state->wsize) {
                if (out(out_desc, state->window, state->wsize - left))
                    ret = Z_BUF_ERROR;
            }
            goto inf_leave;

        case BAD:
            ret = Z_DATA_ERROR;
            goto inf_leave;

        default:                /* can't happen, but makes compilers happy */
            ret = Z_STREAM_ERROR;
            goto inf_leave;
        }

    /* Return unused input */
  inf_leave:
    strm->next_in = next;
    strm->avail_in = have;
    return ret;
}

int ZEXPORT inflateBackEnd(strm)
z_streamp strm;
{
    if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)
        return Z_STREAM_ERROR;
    ZFREE(strm, strm->state);
    strm->state = Z_NULL;
    Tracev((stderr, "inflate: end\n"));
    return Z_OK;
}

```

`efiXloader/3rd/uefitool/common/zlib/inffast.c`:

```c
/* inffast.c -- fast decoding
 * Copyright (C) 1995-2017 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

#include "zutil.h"
#include "inftrees.h"
#include "inflate.h"
#include "inffast.h"

#ifdef ASMINF
#  pragma message("Assembler code may have bugs -- use at your own risk")
#else

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state->mode == LEN
        strm->avail_in >= 6
        strm->avail_out >= 258
        start >= strm->avail_out
        state->bits < 8

   On return, state->mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm->avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm->avail_out >= 258 for each loop to avoid checking for
      output space.
 */
void ZLIB_INTERNAL inflate_fast(strm, start)
z_streamp strm;
unsigned start;         /* inflate()'s starting value for strm->avail_out */
{
    struct inflate_state FAR *state;
    z_const unsigned char FAR *in;      /* local strm->next_in */
    z_const unsigned char FAR *last;    /* have enough input while in < last */
    unsigned char FAR *out;     /* local strm->next_out */
    unsigned char FAR *beg;     /* inflate()'s initial strm->next_out */
    unsigned char FAR *end;     /* while out < end, enough space available */
#ifdef INFLATE_STRICT
    unsigned dmax;              /* maximum distance from zlib header */
#endif
    unsigned wsize;             /* window size or zero if not using window */
    unsigned whave;             /* valid bytes in the window */
    unsigned wnext;             /* window write index */
    unsigned char FAR *window;  /* allocated sliding window, if wsize != 0 */
    unsigned long hold;         /* local strm->hold */
    unsigned bits;              /* local strm->bits */
    code const FAR *lcode;      /* local strm->lencode */
    code const FAR *dcode;      /* local strm->distcode */
    unsigned lmask;             /* mask for first level of length codes */
    unsigned dmask;             /* mask for first level of distance codes */
    code here;                  /* retrieved table entry */
    unsigned op;                /* code bits, operation, extra bits, or */
                                /*  window position, window bytes to copy */
    unsigned len;               /* match length, unused bytes */
    unsigned dist;              /* match distance */
    unsigned char FAR *from;    /* where to copy match from */

    /* copy state to local variables */
    state = (struct inflate_state FAR *)strm->state;
    in = strm->next_in;
    last = in + (strm->avail_in - 5);
    out = strm->next_out;
    beg = out - (start - strm->avail_out);
    end = out + (strm->avail_out - 257);
#ifdef INFLATE_STRICT
    dmax = state->dmax;
#endif
    wsize = state->wsize;
    whave = state->whave;
    wnext = state->wnext;
    window = state->window;
    hold = state->hold;
    bits = state->bits;
    lcode = state->lencode;
    dcode = state->distcode;
    lmask = (1U << state->lenbits) - 1;
    dmask = (1U << state->distbits) - 1;

    /* decode literals and length/distances until end-of-block or not enough
       input data or output space */
    do {
        if (bits < 15) {
            hold += (unsigned long)(*in++) << bits;
            bits += 8;
            hold += (unsigned long)(*in++) << bits;
            bits += 8;
        }
        here = lcode[hold & lmask];
      dolen:
        op = (unsigned)(here.bits);
        hold >>= op;
        bits -= op;
        op = (unsigned)(here.op);
        if (op == 0) {                          /* literal */
            Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
                    "inflate:         literal '%c'\n" :
                    "inflate:         literal 0x%02x\n", here.val));
            *out++ = (unsigned char)(here.val);
        }
        else if (op & 16) {                     /* length base */
            len = (unsigned)(here.val);
            op &= 15;                           /* number of extra bits */
            if (op) {
                if (bits < op) {
                    hold += (unsigned long)(*in++) << bits;
                    bits += 8;
                }
                len += (unsigned)hold & ((1U << op) - 1);
                hold >>= op;
                bits -= op;
            }
            Tracevv((stderr, "inflate:         length %u\n", len));
            if (bits < 15) {
                hold += (unsigned long)(*in++) << bits;
                bits += 8;
                hold += (unsigned long)(*in++) << bits;
                bits += 8;
            }
            here = dcode[hold & dmask];
          dodist:
            op = (unsigned)(here.bits);
            hold >>= op;
            bits -= op;
            op = (unsigned)(here.op);
            if (op & 16) {                      /* distance base */
                dist = (unsigned)(here.val);
                op &= 15;                       /* number of extra bits */
                if (bits < op) {
                    hold += (unsigned long)(*in++) << bits;
                    bits += 8;
                    if (bits < op) {
                        hold += (unsigned long)(*in++) << bits;
                        bits += 8;
                    }
                }
                dist += (unsigned)hold & ((1U << op) - 1);
#ifdef INFLATE_STRICT
                if (dist > dmax) {
                    strm->msg = (char *)"invalid distance too far back";
                    state->mode = BAD;
                    break;
                }
#endif
                hold >>= op;
                bits -= op;
                Tracevv((stderr, "inflate:         distance %u\n", dist));
                op = (unsigned)(out - beg);     /* max distance in output */
                if (dist > op) {                /* see if copy from window */
                    op = dist - op;             /* distance back in window */
                    if (op > whave) {
                        if (state->sane) {
                            strm->msg =
                                (char *)"invalid distance too far back";
                            state->mode = BAD;
                            break;
                        }
#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
                        if (len <= op - whave) {
                            do {
                                *out++ = 0;
                            } while (--len);
                            continue;
                        }
                        len -= op - whave;
                        do {
                            *out++ = 0;
                        } while (--op > whave);
                        if (op == 0) {
                            from = out - dist;
                            do {
                                *out++ = *from++;
                            } while (--len);
                            continue;
                        }
#endif
                    }
                    from = window;
                    if (wnext == 0) {           /* very common case */
                        from += wsize - op;
                        if (op < len) {         /* some from window */
                            len -= op;
                            do {
                                *out++ = *from++;
                            } while (--op);
                            from = out - dist;  /* rest from output */
                        }
                    }
                    else if (wnext < op) {      /* wrap around window */
                        from += wsize + wnext - op;
                        op -= wnext;
                        if (op < len) {         /* some from end of window */
                            len -= op;
                            do {
                                *out++ = *from++;
                            } while (--op);
                            from = window;
                            if (wnext < len) {  /* some from start of window */
                                op = wnext;
                                len -= op;
                                do {
                                    *out++ = *from++;
                                } while (--op);
                                from = out - dist;      /* rest from output */
                            }
                        }
                    }
                    else {                      /* contiguous in window */
                        from += wnext - op;
                        if (op < len) {         /* some from window */
                            len -= op;
                            do {
                                *out++ = *from++;
                            } while (--op);
                            from = out - dist;  /* rest from output */
                        }
                    }
                    while (len > 2) {
                        *out++ = *from++;
                        *out++ = *from++;
                        *out++ = *from++;
                        len -= 3;
                    }
                    if (len) {
                        *out++ = *from++;
                        if (len > 1)
                            *out++ = *from++;
                    }
                }
                else {
                    from = out - dist;          /* copy direct from output */
                    do {                        /* minimum length is three */
                        *out++ = *from++;
                        *out++ = *from++;
                        *out++ = *from++;
                        len -= 3;
                    } while (len > 2);
                    if (len) {
                        *out++ = *from++;
                        if (len > 1)
                            *out++ = *from++;
                    }
                }
            }
            else if ((op & 64) == 0) {          /* 2nd level distance code */
                here = dcode[here.val + (hold & ((1U << op) - 1))];
                goto dodist;
            }
            else {
                strm->msg = (char *)"invalid distance code";
                state->mode = BAD;
                break;
            }
        }
        else if ((op & 64) == 0) {              /* 2nd level length code */
            here = lcode[here.val + (hold & ((1U << op) - 1))];
            goto dolen;
        }
        else if (op & 32) {                     /* end-of-block */
            Tracevv((stderr, "inflate:         end of block\n"));
            state->mode = TYPE;
            break;
        }
        else {
            strm->msg = (char *)"invalid literal/length code";
            state->mode = BAD;
            break;
        }
    } while (in < last && out < end);

    /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
    len = bits >> 3;
    in -= len;
    bits -= len << 3;
    hold &= (1U << bits) - 1;

    /* update state and return */
    strm->next_in = in;
    strm->next_out = out;
    strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));
    strm->avail_out = (unsigned)(out < end ?
                                 257 + (end - out) : 257 - (out - end));
    state->hold = hold;
    state->bits = bits;
    return;
}

/*
   inflate_fast() speedups that turned out slower (on a PowerPC G3 750CXe):
   - Using bit fields for code structure
   - Different op definition to avoid & for extra bits (do & for table bits)
   - Three separate decoding do-loops for direct, window, and wnext == 0
   - Special case for distance > 1 copies to do overlapped load and store copy
   - Explicit branch predictions (based on measured branch probabilities)
   - Deferring match copy and interspersed it with decoding subsequent codes
   - Swapping literal/length else
   - Swapping window/direct else
   - Larger unrolled copy loops (three is about right)
   - Moving len -= 3 statement into middle of loop
 */

#endif /* !ASMINF */

```

`efiXloader/3rd/uefitool/common/zlib/inffast.h`:

```h
/* inffast.h -- header to use inffast.c
 * Copyright (C) 1995-2003, 2010 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

void ZLIB_INTERNAL inflate_fast OF((z_streamp strm, unsigned start));

```

`efiXloader/3rd/uefitool/common/zlib/inffixed.h`:

```h
    /* inffixed.h -- table for decoding fixed codes
     * Generated automatically by makefixed().
     */

    /* WARNING: this file should *not* be used by applications.
       It is part of the implementation of this library and is
       subject to change. Applications should only use zlib.h.
     */

    static const code lenfix[512] = {
        {96,7,0},{0,8,80},{0,8,16},{20,8,115},{18,7,31},{0,8,112},{0,8,48},
        {0,9,192},{16,7,10},{0,8,96},{0,8,32},{0,9,160},{0,8,0},{0,8,128},
        {0,8,64},{0,9,224},{16,7,6},{0,8,88},{0,8,24},{0,9,144},{19,7,59},
        {0,8,120},{0,8,56},{0,9,208},{17,7,17},{0,8,104},{0,8,40},{0,9,176},
        {0,8,8},{0,8,136},{0,8,72},{0,9,240},{16,7,4},{0,8,84},{0,8,20},
        {21,8,227},{19,7,43},{0,8,116},{0,8,52},{0,9,200},{17,7,13},{0,8,100},
        {0,8,36},{0,9,168},{0,8,4},{0,8,132},{0,8,68},{0,9,232},{16,7,8},
        {0,8,92},{0,8,28},{0,9,152},{20,7,83},{0,8,124},{0,8,60},{0,9,216},
        {18,7,23},{0,8,108},{0,8,44},{0,9,184},{0,8,12},{0,8,140},{0,8,76},
        {0,9,248},{16,7,3},{0,8,82},{0,8,18},{21,8,163},{19,7,35},{0,8,114},
        {0,8,50},{0,9,196},{17,7,11},{0,8,98},{0,8,34},{0,9,164},{0,8,2},
        {0,8,130},{0,8,66},{0,9,228},{16,7,7},{0,8,90},{0,8,26},{0,9,148},
        {20,7,67},{0,8,122},{0,8,58},{0,9,212},{18,7,19},{0,8,106},{0,8,42},
        {0,9,180},{0,8,10},{0,8,138},{0,8,74},{0,9,244},{16,7,5},{0,8,86},
        {0,8,22},{64,8,0},{19,7,51},{0,8,118},{0,8,54},{0,9,204},{17,7,15},
        {0,8,102},{0,8,38},{0,9,172},{0,8,6},{0,8,134},{0,8,70},{0,9,236},
        {16,7,9},{0,8,94},{0,8,30},{0,9,156},{20,7,99},{0,8,126},{0,8,62},
        {0,9,220},{18,7,27},{0,8,110},{0,8,46},{0,9,188},{0,8,14},{0,8,142},
        {0,8,78},{0,9,252},{96,7,0},{0,8,81},{0,8,17},{21,8,131},{18,7,31},
        {0,8,113},{0,8,49},{0,9,194},{16,7,10},{0,8,97},{0,8,33},{0,9,162},
        {0,8,1},{0,8,129},{0,8,65},{0,9,226},{16,7,6},{0,8,89},{0,8,25},
        {0,9,146},{19,7,59},{0,8,121},{0,8,57},{0,9,210},{17,7,17},{0,8,105},
        {0,8,41},{0,9,178},{0,8,9},{0,8,137},{0,8,73},{0,9,242},{16,7,4},
        {0,8,85},{0,8,21},{16,8,258},{19,7,43},{0,8,117},{0,8,53},{0,9,202},
        {17,7,13},{0,8,101},{0,8,37},{0,9,170},{0,8,5},{0,8,133},{0,8,69},
        {0,9,234},{16,7,8},{0,8,93},{0,8,29},{0,9,154},{20,7,83},{0,8,125},
        {0,8,61},{0,9,218},{18,7,23},{0,8,109},{0,8,45},{0,9,186},{0,8,13},
        {0,8,141},{0,8,77},{0,9,250},{16,7,3},{0,8,83},{0,8,19},{21,8,195},
        {19,7,35},{0,8,115},{0,8,51},{0,9,198},{17,7,11},{0,8,99},{0,8,35},
        {0,9,166},{0,8,3},{0,8,131},{0,8,67},{0,9,230},{16,7,7},{0,8,91},
        {0,8,27},{0,9,150},{20,7,67},{0,8,123},{0,8,59},{0,9,214},{18,7,19},
        {0,8,107},{0,8,43},{0,9,182},{0,8,11},{0,8,139},{0,8,75},{0,9,246},
        {16,7,5},{0,8,87},{0,8,23},{64,8,0},{19,7,51},{0,8,119},{0,8,55},
        {0,9,206},{17,7,15},{0,8,103},{0,8,39},{0,9,174},{0,8,7},{0,8,135},
        {0,8,71},{0,9,238},{16,7,9},{0,8,95},{0,8,31},{0,9,158},{20,7,99},
        {0,8,127},{0,8,63},{0,9,222},{18,7,27},{0,8,111},{0,8,47},{0,9,190},
        {0,8,15},{0,8,143},{0,8,79},{0,9,254},{96,7,0},{0,8,80},{0,8,16},
        {20,8,115},{18,7,31},{0,8,112},{0,8,48},{0,9,193},{16,7,10},{0,8,96},
        {0,8,32},{0,9,161},{0,8,0},{0,8,128},{0,8,64},{0,9,225},{16,7,6},
        {0,8,88},{0,8,24},{0,9,145},{19,7,59},{0,8,120},{0,8,56},{0,9,209},
        {17,7,17},{0,8,104},{0,8,40},{0,9,177},{0,8,8},{0,8,136},{0,8,72},
        {0,9,241},{16,7,4},{0,8,84},{0,8,20},{21,8,227},{19,7,43},{0,8,116},
        {0,8,52},{0,9,201},{17,7,13},{0,8,100},{0,8,36},{0,9,169},{0,8,4},
        {0,8,132},{0,8,68},{0,9,233},{16,7,8},{0,8,92},{0,8,28},{0,9,153},
        {20,7,83},{0,8,124},{0,8,60},{0,9,217},{18,7,23},{0,8,108},{0,8,44},
        {0,9,185},{0,8,12},{0,8,140},{0,8,76},{0,9,249},{16,7,3},{0,8,82},
        {0,8,18},{21,8,163},{19,7,35},{0,8,114},{0,8,50},{0,9,197},{17,7,11},
        {0,8,98},{0,8,34},{0,9,165},{0,8,2},{0,8,130},{0,8,66},{0,9,229},
        {16,7,7},{0,8,90},{0,8,26},{0,9,149},{20,7,67},{0,8,122},{0,8,58},
        {0,9,213},{18,7,19},{0,8,106},{0,8,42},{0,9,181},{0,8,10},{0,8,138},
        {0,8,74},{0,9,245},{16,7,5},{0,8,86},{0,8,22},{64,8,0},{19,7,51},
        {0,8,118},{0,8,54},{0,9,205},{17,7,15},{0,8,102},{0,8,38},{0,9,173},
        {0,8,6},{0,8,134},{0,8,70},{0,9,237},{16,7,9},{0,8,94},{0,8,30},
        {0,9,157},{20,7,99},{0,8,126},{0,8,62},{0,9,221},{18,7,27},{0,8,110},
        {0,8,46},{0,9,189},{0,8,14},{0,8,142},{0,8,78},{0,9,253},{96,7,0},
        {0,8,81},{0,8,17},{21,8,131},{18,7,31},{0,8,113},{0,8,49},{0,9,195},
        {16,7,10},{0,8,97},{0,8,33},{0,9,163},{0,8,1},{0,8,129},{0,8,65},
        {0,9,227},{16,7,6},{0,8,89},{0,8,25},{0,9,147},{19,7,59},{0,8,121},
        {0,8,57},{0,9,211},{17,7,17},{0,8,105},{0,8,41},{0,9,179},{0,8,9},
        {0,8,137},{0,8,73},{0,9,243},{16,7,4},{0,8,85},{0,8,21},{16,8,258},
        {19,7,43},{0,8,117},{0,8,53},{0,9,203},{17,7,13},{0,8,101},{0,8,37},
        {0,9,171},{0,8,5},{0,8,133},{0,8,69},{0,9,235},{16,7,8},{0,8,93},
        {0,8,29},{0,9,155},{20,7,83},{0,8,125},{0,8,61},{0,9,219},{18,7,23},
        {0,8,109},{0,8,45},{0,9,187},{0,8,13},{0,8,141},{0,8,77},{0,9,251},
        {16,7,3},{0,8,83},{0,8,19},{21,8,195},{19,7,35},{0,8,115},{0,8,51},
        {0,9,199},{17,7,11},{0,8,99},{0,8,35},{0,9,167},{0,8,3},{0,8,131},
        {0,8,67},{0,9,231},{16,7,7},{0,8,91},{0,8,27},{0,9,151},{20,7,67},
        {0,8,123},{0,8,59},{0,9,215},{18,7,19},{0,8,107},{0,8,43},{0,9,183},
        {0,8,11},{0,8,139},{0,8,75},{0,9,247},{16,7,5},{0,8,87},{0,8,23},
        {64,8,0},{19,7,51},{0,8,119},{0,8,55},{0,9,207},{17,7,15},{0,8,103},
        {0,8,39},{0,9,175},{0,8,7},{0,8,135},{0,8,71},{0,9,239},{16,7,9},
        {0,8,95},{0,8,31},{0,9,159},{20,7,99},{0,8,127},{0,8,63},{0,9,223},
        {18,7,27},{0,8,111},{0,8,47},{0,9,191},{0,8,15},{0,8,143},{0,8,79},
        {0,9,255}
    };

    static const code distfix[32] = {
        {16,5,1},{23,5,257},{19,5,17},{27,5,4097},{17,5,5},{25,5,1025},
        {21,5,65},{29,5,16385},{16,5,3},{24,5,513},{20,5,33},{28,5,8193},
        {18,5,9},{26,5,2049},{22,5,129},{64,5,0},{16,5,2},{23,5,385},
        {19,5,25},{27,5,6145},{17,5,7},{25,5,1537},{21,5,97},{29,5,24577},
        {16,5,4},{24,5,769},{20,5,49},{28,5,12289},{18,5,13},{26,5,3073},
        {22,5,193},{64,5,0}
    };

```

`efiXloader/3rd/uefitool/common/zlib/inflate.c`:

```c
/* inflate.c -- zlib decompression
 * Copyright (C) 1995-2016 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/*
 * Change history:
 *
 * 1.2.beta0    24 Nov 2002
 * - First version -- complete rewrite of inflate to simplify code, avoid
 *   creation of window when not needed, minimize use of window when it is
 *   needed, make inffast.c even faster, implement gzip decoding, and to
 *   improve code readability and style over the previous zlib inflate code
 *
 * 1.2.beta1    25 Nov 2002
 * - Use pointers for available input and output checking in inffast.c
 * - Remove input and output counters in inffast.c
 * - Change inffast.c entry and loop from avail_in >= 7 to >= 6
 * - Remove unnecessary second byte pull from length extra in inffast.c
 * - Unroll direct copy to three copies per loop in inffast.c
 *
 * 1.2.beta2    4 Dec 2002
 * - Change external routine names to reduce potential conflicts
 * - Correct filename to inffixed.h for fixed tables in inflate.c
 * - Make hbuf[] unsigned char to match parameter type in inflate.c
 * - Change strm->next_out[-state->offset] to *(strm->next_out - state->offset)
 *   to avoid negation problem on Alphas (64 bit) in inflate.c
 *
 * 1.2.beta3    22 Dec 2002
 * - Add comments on state->bits assertion in inffast.c
 * - Add comments on op field in inftrees.h
 * - Fix bug in reuse of allocated window after inflateReset()
 * - Remove bit fields--back to byte structure for speed
 * - Remove distance extra == 0 check in inflate_fast()--only helps for lengths
 * - Change post-increments to pre-increments in inflate_fast(), PPC biased?
 * - Add compile time option, POSTINC, to use post-increments instead (Intel?)
 * - Make MATCH copy in inflate() much faster for when inflate_fast() not used
 * - Use local copies of stream next and avail values, as well as local bit
 *   buffer and bit count in inflate()--for speed when inflate_fast() not used
 *
 * 1.2.beta4    1 Jan 2003
 * - Split ptr - 257 statements in inflate_table() to avoid compiler warnings
 * - Move a comment on output buffer sizes from inffast.c to inflate.c
 * - Add comments in inffast.c to introduce the inflate_fast() routine
 * - Rearrange window copies in inflate_fast() for speed and simplification
 * - Unroll last copy for window match in inflate_fast()
 * - Use local copies of window variables in inflate_fast() for speed
 * - Pull out common wnext == 0 case for speed in inflate_fast()
 * - Make op and len in inflate_fast() unsigned for consistency
 * - Add FAR to lcode and dcode declarations in inflate_fast()
 * - Simplified bad distance check in inflate_fast()
 * - Added inflateBackInit(), inflateBack(), and inflateBackEnd() in new
 *   source file infback.c to provide a call-back interface to inflate for
 *   programs like gzip and unzip -- uses window as output buffer to avoid
 *   window copying
 *
 * 1.2.beta5    1 Jan 2003
 * - Improved inflateBack() interface to allow the caller to provide initial
 *   input in strm.
 * - Fixed stored blocks bug in inflateBack()
 *
 * 1.2.beta6    4 Jan 2003
 * - Added comments in inffast.c on effectiveness of POSTINC
 * - Typecasting all around to reduce compiler warnings
 * - Changed loops from while (1) or do {} while (1) to for (;;), again to
 *   make compilers happy
 * - Changed type of window in inflateBackInit() to unsigned char *
 *
 * 1.2.beta7    27 Jan 2003
 * - Changed many types to unsigned or unsigned short to avoid warnings
 * - Added inflateCopy() function
 *
 * 1.2.0        9 Mar 2003
 * - Changed inflateBack() interface to provide separate opaque descriptors
 *   for the in() and out() functions
 * - Changed inflateBack() argument and in_func typedef to swap the length
 *   and buffer address return values for the input function
 * - Check next_in and next_out for Z_NULL on entry to inflate()
 *
 * The history for versions after 1.2.0 are in ChangeLog in zlib distribution.
 */

#include "zutil.h"
#include "inftrees.h"
#include "inflate.h"
#include "inffast.h"

#ifdef MAKEFIXED
#  ifndef BUILDFIXED
#    define BUILDFIXED
#  endif
#endif

/* function prototypes */
local int inflateStateCheck OF((z_streamp strm));
local void fixedtables OF((struct inflate_state FAR *state));
local int updatewindow OF((z_streamp strm, const unsigned char FAR *end,
                           unsigned copy));
#ifdef BUILDFIXED
   void makefixed OF((void));
#endif
local unsigned syncsearch OF((unsigned FAR *have, const unsigned char FAR *buf,
                              unsigned len));

local int inflateStateCheck(strm)
z_streamp strm;
{
    struct inflate_state FAR *state;
    if (strm == Z_NULL ||
        strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0)
        return 1;
    state = (struct inflate_state FAR *)strm->state;
    if (state == Z_NULL || state->strm != strm ||
        state->mode < HEAD || state->mode > SYNC)
        return 1;
    return 0;
}

int ZEXPORT inflateResetKeep(strm)
z_streamp strm;
{
    struct inflate_state FAR *state;

    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
    strm->total_in = strm->total_out = state->total = 0;
    strm->msg = Z_NULL;
    if (state->wrap)        /* to support ill-conceived Java test suite */
        strm->adler = state->wrap & 1;
    state->mode = HEAD;
    state->last = 0;
    state->havedict = 0;
    state->dmax = 32768U;
    state->head = Z_NULL;
    state->hold = 0;
    state->bits = 0;
    state->lencode = state->distcode = state->next = state->codes;
    state->sane = 1;
    state->back = -1;
    Tracev((stderr, "inflate: reset\n"));
    return Z_OK;
}

int ZEXPORT inflateReset(strm)
z_streamp strm;
{
    struct inflate_state FAR *state;

    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
    state->wsize = 0;
    state->whave = 0;
    state->wnext = 0;
    return inflateResetKeep(strm);
}

int ZEXPORT inflateReset2(strm, windowBits)
z_streamp strm;
int windowBits;
{
    int wrap;
    struct inflate_state FAR *state;

    /* get the state */
    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;

    /* extract wrap request from windowBits parameter */
    if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
    }
    else {
        wrap = (windowBits >> 4) + 5;
#ifdef GUNZIP
        if (windowBits < 48)
            windowBits &= 15;
#endif
    }

    /* set number of window bits, free window if different */
    if (windowBits && (windowBits < 8 || windowBits > 15))
        return Z_STREAM_ERROR;
    if (state->window != Z_NULL && state->wbits != (unsigned)windowBits) {
        ZFREE(strm, state->window);
        state->window = Z_NULL;
    }

    /* update state and reset the rest of it */
    state->wrap = wrap;
    state->wbits = (unsigned)windowBits;
    return inflateReset(strm);
}

int ZEXPORT inflateInit2_(strm, windowBits, version, stream_size)
z_streamp strm;
int windowBits;
const char *version;
int stream_size;
{
    int ret;
    struct inflate_state FAR *state;

    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
        stream_size != (int)(sizeof(z_stream)))
        return Z_VERSION_ERROR;
    if (strm == Z_NULL) return Z_STREAM_ERROR;
    strm->msg = Z_NULL;                 /* in case we return an error */
    if (strm->zalloc == (alloc_func)0) {
#ifdef Z_SOLO
        return Z_STREAM_ERROR;
#else
        strm->zalloc = zcalloc;
        strm->opaque = (voidpf)0;
#endif
    }
    if (strm->zfree == (free_func)0)
#ifdef Z_SOLO
        return Z_STREAM_ERROR;
#else
        strm->zfree = zcfree;
#endif
    state = (struct inflate_state FAR *)
            ZALLOC(strm, 1, sizeof(struct inflate_state));
    if (state == Z_NULL) return Z_MEM_ERROR;
    Tracev((stderr, "inflate: allocated\n"));
    strm->state = (struct internal_state FAR *)state;
    state->strm = strm;
    state->window = Z_NULL;
    state->mode = HEAD;     /* to pass state test in inflateReset2() */
    ret = inflateReset2(strm, windowBits);
    if (ret != Z_OK) {
        ZFREE(strm, state);
        strm->state = Z_NULL;
    }
    return ret;
}

int ZEXPORT inflateInit_(strm, version, stream_size)
z_streamp strm;
const char *version;
int stream_size;
{
    return inflateInit2_(strm, DEF_WBITS, version, stream_size);
}

int ZEXPORT inflatePrime(strm, bits, value)
z_streamp strm;
int bits;
int value;
{
    struct inflate_state FAR *state;

    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
    if (bits < 0) {
        state->hold = 0;
        state->bits = 0;
        return Z_OK;
    }
    if (bits > 16 || state->bits + (uInt)bits > 32) return Z_STREAM_ERROR;
    value &= (1L << bits) - 1;
    state->hold += (unsigned)value << state->bits;
    state->bits += (uInt)bits;
    return Z_OK;
}

/*
   Return state with length and distance decoding tables and index sizes set to
   fixed code decoding.  Normally this returns fixed tables from inffixed.h.
   If BUILDFIXED is defined, then instead this routine builds the tables the
   first time it's called, and returns those tables the first time and
   thereafter.  This reduces the size of the code by about 2K bytes, in
   exchange for a little execution time.  However, BUILDFIXED should not be
   used for threaded applications, since the rewriting of the tables and virgin
   may not be thread-safe.
 */
local void fixedtables(state)
struct inflate_state FAR *state;
{
#ifdef BUILDFIXED
    static int virgin = 1;
    static code *lenfix, *distfix;
    static code fixed[544];

    /* build fixed huffman tables if first call (may not be thread safe) */
    if (virgin) {
        unsigned sym, bits;
        static code *next;

        /* literal/length table */
        sym = 0;
        while (sym < 144) state->lens[sym++] = 8;
        while (sym < 256) state->lens[sym++] = 9;
        while (sym < 280) state->lens[sym++] = 7;
        while (sym < 288) state->lens[sym++] = 8;
        next = fixed;
        lenfix = next;
        bits = 9;
        inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);

        /* distance table */
        sym = 0;
        while (sym < 32) state->lens[sym++] = 5;
        distfix = next;
        bits = 5;
        inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);

        /* do this just once */
        virgin = 0;
    }
#else /* !BUILDFIXED */
#   include "inffixed.h"
#endif /* BUILDFIXED */
    state->lencode = lenfix;
    state->lenbits = 9;
    state->distcode = distfix;
    state->distbits = 5;
}

#ifdef MAKEFIXED
#include <stdio.h>

/*
   Write out the inffixed.h that is #include'd above.  Defining MAKEFIXED also
   defines BUILDFIXED, so the tables are built on the fly.  makefixed() writes
   those tables to stdout, which would be piped to inffixed.h.  A small program
   can simply call makefixed to do this:

    void makefixed(void);

    int main(void)
    {
        makefixed();
        return 0;
    }

   Then that can be linked with zlib built with MAKEFIXED defined and run:

    a.out > inffixed.h
 */
void makefixed()
{
    unsigned low, size;
    struct inflate_state state;

    fixedtables(&state);
    puts("    /* inffixed.h -- table for decoding fixed codes");
    puts("     * Generated automatically by makefixed().");
    puts("     */");
    puts("");
    puts("    /* WARNING: this file should *not* be used by applications.");
    puts("       It is part of the implementation of this library and is");
    puts("       subject to change. Applications should only use zlib.h.");
    puts("     */");
    puts("");
    size = 1U << 9;
    printf("    static const code lenfix[%u] = {", size);
    low = 0;
    for (;;) {
        if ((low % 7) == 0) printf("\n        ");
        printf("{%u,%u,%d}", (low & 127) == 99 ? 64 : state.lencode[low].op,
               state.lencode[low].bits, state.lencode[low].val);
        if (++low == size) break;
        putchar(',');
    }
    puts("\n    };");
    size = 1U << 5;
    printf("\n    static const code distfix[%u] = {", size);
    low = 0;
    for (;;) {
        if ((low % 6) == 0) printf("\n        ");
        printf("{%u,%u,%d}", state.distcode[low].op, state.distcode[low].bits,
               state.distcode[low].val);
        if (++low == size) break;
        putchar(',');
    }
    puts("\n    };");
}
#endif /* MAKEFIXED */

/*
   Update the window with the last wsize (normally 32K) bytes written before
   returning.  If window does not exist yet, create it.  This is only called
   when a window is already in use, or when output has been written during this
   inflate call, but the end of the deflate stream has not been reached yet.
   It is also called to create a window for dictionary data when a dictionary
   is loaded.

   Providing output buffers larger than 32K to inflate() should provide a speed
   advantage, since only the last 32K of output is copied to the sliding window
   upon return from inflate(), and since all distances after the first 32K of
   output will fall in the output data, making match copies simpler and faster.
   The advantage may be dependent on the size of the processor's data caches.
 */
local int updatewindow(strm, end, copy)
z_streamp strm;
const Bytef *end;
unsigned copy;
{
    struct inflate_state FAR *state;
    unsigned dist;

    state = (struct inflate_state FAR *)strm->state;

    /* if it hasn't been done already, allocate space for the window */
    if (state->window == Z_NULL) {
        state->window = (unsigned char FAR *)
                        ZALLOC(strm, 1U << state->wbits,
                               sizeof(unsigned char));
        if (state->window == Z_NULL) return 1;
    }

    /* if window not in use yet, initialize */
    if (state->wsize == 0) {
        state->wsize = 1U << state->wbits;
        state->wnext = 0;
        state->whave = 0;
    }

    /* copy state->wsize or less output bytes into the circular window */
    if (copy >= state->wsize) {
        zmemcpy(state->window, end - state->wsize, state->wsize);
        state->wnext = 0;
        state->whave = state->wsize;
    }
    else {
        dist = state->wsize - state->wnext;
        if (dist > copy) dist = copy;
        zmemcpy(state->window + state->wnext, end - copy, dist);
        copy -= dist;
        if (copy) {
            zmemcpy(state->window, end - copy, copy);
            state->wnext = copy;
            state->whave = state->wsize;
        }
        else {
            state->wnext += dist;
            if (state->wnext == state->wsize) state->wnext = 0;
            if (state->whave < state->wsize) state->whave += dist;
        }
    }
    return 0;
}

/* Macros for inflate(): */

/* check function to use adler32() for zlib or crc32() for gzip */
#ifdef GUNZIP
#  define UPDATE(check, buf, len) \
    (state->flags ? crc32(check, buf, len) : adler32(check, buf, len))
#else
#  define UPDATE(check, buf, len) adler32(check, buf, len)
#endif

/* check macros for header crc */
#ifdef GUNZIP
#  define CRC2(check, word) \
    do { \
        hbuf[0] = (unsigned char)(word); \
        hbuf[1] = (unsigned char)((word) >> 8); \
        check = crc32(check, hbuf, 2); \
    } while (0)

#  define CRC4(check, word) \
    do { \
        hbuf[0] = (unsigned char)(word); \
        hbuf[1] = (unsigned char)((word) >> 8); \
        hbuf[2] = (unsigned char)((word) >> 16); \
        hbuf[3] = (unsigned char)((word) >> 24); \
        check = crc32(check, hbuf, 4); \
    } while (0)
#endif

/* Load registers with state in inflate() for speed */
#define LOAD() \
    do { \
        put = strm->next_out; \
        left = strm->avail_out; \
        next = strm->next_in; \
        have = strm->avail_in; \
        hold = state->hold; \
        bits = state->bits; \
    } while (0)

/* Restore state from registers in inflate() */
#define RESTORE() \
    do { \
        strm->next_out = put; \
        strm->avail_out = left; \
        strm->next_in = next; \
        strm->avail_in = have; \
        state->hold = hold; \
        state->bits = bits; \
    } while (0)

/* Clear the input bit accumulator */
#define INITBITS() \
    do { \
        hold = 0; \
        bits = 0; \
    } while (0)

/* Get a byte of input into the bit accumulator, or return from inflate()
   if there is no input available. */
#define PULLBYTE() \
    do { \
        if (have == 0) goto inf_leave; \
        have--; \
        hold += (unsigned long)(*next++) << bits; \
        bits += 8; \
    } while (0)

/* Assure that there are at least n bits in the bit accumulator.  If there is
   not enough available input to do that, then return from inflate(). */
#define NEEDBITS(n) \
    do { \
        while (bits < (unsigned)(n)) \
            PULLBYTE(); \
    } while (0)

/* Return the low n bits of the bit accumulator (n < 16) */
#define BITS(n) \
    ((unsigned)hold & ((1U << (n)) - 1))

/* Remove n bits from the bit accumulator */
#define DROPBITS(n) \
    do { \
        hold >>= (n); \
        bits -= (unsigned)(n); \
    } while (0)

/* Remove zero to seven bits as needed to go to a byte boundary */
#define BYTEBITS() \
    do { \
        hold >>= bits & 7; \
        bits -= bits & 7; \
    } while (0)

/*
   inflate() uses a state machine to process as much input data and generate as
   much output data as possible before returning.  The state machine is
   structured roughly as follows:

    for (;;) switch (state) {
    ...
    case STATEn:
        if (not enough input data or output space to make progress)
            return;
        ... make progress ...
        state = STATEm;
        break;
    ...
    }

   so when inflate() is called again, the same case is attempted again, and
   if the appropriate resources are provided, the machine proceeds to the
   next state.  The NEEDBITS() macro is usually the way the state evaluates
   whether it can proceed or should return.  NEEDBITS() does the return if
   the requested bits are not available.  The typical use of the BITS macros
   is:

        NEEDBITS(n);
        ... do something with BITS(n) ...
        DROPBITS(n);

   where NEEDBITS(n) either returns from inflate() if there isn't enough
   input left to load n bits into the accumulator, or it continues.  BITS(n)
   gives the low n bits in the accumulator.  When done, DROPBITS(n) drops
   the low n bits off the accumulator.  INITBITS() clears the accumulator
   and sets the number of available bits to zero.  BYTEBITS() discards just
   enough bits to put the accumulator on a byte boundary.  After BYTEBITS()
   and a NEEDBITS(8), then BITS(8) would return the next byte in the stream.

   NEEDBITS(n) uses PULLBYTE() to get an available byte of input, or to return
   if there is no input available.  The decoding of variable length codes uses
   PULLBYTE() directly in order to pull just enough bytes to decode the next
   code, and no more.

   Some states loop until they get enough input, making sure that enough
   state information is maintained to continue the loop where it left off
   if NEEDBITS() returns in the loop.  For example, want, need, and keep
   would all have to actually be part of the saved state in case NEEDBITS()
   returns:

    case STATEw:
        while (want < need) {
            NEEDBITS(n);
            keep[want++] = BITS(n);
            DROPBITS(n);
        }
        state = STATEx;
    case STATEx:

   As shown above, if the next state is also the next case, then the break
   is omitted.

   A state may also return if there is not enough output space available to
   complete that state.  Those states are copying stored data, writing a
   literal byte, and copying a matching string.

   When returning, a "goto inf_leave" is used to update the total counters,
   update the check value, and determine whether any progress has been made
   during that inflate() call in order to return the proper return code.
   Progress is defined as a change in either strm->avail_in or strm->avail_out.
   When there is a window, goto inf_leave will update the window with the last
   output written.  If a goto inf_leave occurs in the middle of decompression
   and there is no window currently, goto inf_leave will create one and copy
   output to the window for the next call of inflate().

   In this implementation, the flush parameter of inflate() only affects the
   return code (per zlib.h).  inflate() always writes as much as possible to
   strm->next_out, given the space available and the provided input--the effect
   documented in zlib.h of Z_SYNC_FLUSH.  Furthermore, inflate() always defers
   the allocation of and copying into a sliding window until necessary, which
   provides the effect documented in zlib.h for Z_FINISH when the entire input
   stream available.  So the only thing the flush parameter actually does is:
   when flush is set to Z_FINISH, inflate() cannot return Z_OK.  Instead it
   will return Z_BUF_ERROR if it has not reached the end of the stream.
 */

int ZEXPORT inflate(strm, flush)
z_streamp strm;
int flush;
{
    struct inflate_state FAR *state;
    z_const unsigned char FAR *next;    /* next input */
    unsigned char FAR *put;     /* next output */
    unsigned have, left;        /* available input and output */
    unsigned long hold;         /* bit buffer */
    unsigned bits;              /* bits in bit buffer */
    unsigned in, out;           /* save starting available input and output */
    unsigned copy;              /* number of stored or match bytes to copy */
    unsigned char FAR *from;    /* where to copy match bytes from */
    code here;                  /* current decoding table entry */
    code last;                  /* parent table entry */
    unsigned len;               /* length to copy for repeats, bits to drop */
    int ret;                    /* return code */
#ifdef GUNZIP
    unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
#endif
    static const unsigned short order[19] = /* permutation of code lengths */
        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};

    if (inflateStateCheck(strm) || strm->next_out == Z_NULL ||
        (strm->next_in == Z_NULL && strm->avail_in != 0))
        return Z_STREAM_ERROR;

    state = (struct inflate_state FAR *)strm->state;
    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */
    LOAD();
    in = have;
    out = left;
    ret = Z_OK;
    for (;;)
        switch (state->mode) {
        case HEAD:
            if (state->wrap == 0) {
                state->mode = TYPEDO;
                break;
            }
            NEEDBITS(16);
#ifdef GUNZIP
            if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */
                if (state->wbits == 0)
                    state->wbits = 15;
                state->check = crc32(0L, Z_NULL, 0);
                CRC2(state->check, hold);
                INITBITS();
                state->mode = FLAGS;
                break;
            }
            state->flags = 0;           /* expect zlib header */
            if (state->head != Z_NULL)
                state->head->done = -1;
            if (!(state->wrap & 1) ||   /* check if zlib header allowed */
#else
            if (
#endif
                ((BITS(8) << 8) + (hold >> 8)) % 31) {
                strm->msg = (char *)"incorrect header check";
                state->mode = BAD;
                break;
            }
            if (BITS(4) != Z_DEFLATED) {
                strm->msg = (char *)"unknown compression method";
                state->mode = BAD;
                break;
            }
            DROPBITS(4);
            len = BITS(4) + 8;
            if (state->wbits == 0)
                state->wbits = len;
            if (len > 15 || len > state->wbits) {
                strm->msg = (char *)"invalid window size";
                state->mode = BAD;
                break;
            }
            state->dmax = 1U << len;
            Tracev((stderr, "inflate:   zlib header ok\n"));
            strm->adler = state->check = adler32(0L, Z_NULL, 0);
            state->mode = hold & 0x200 ? DICTID : TYPE;
            INITBITS();
            break;
#ifdef GUNZIP
        case FLAGS:
            NEEDBITS(16);
            state->flags = (int)(hold);
            if ((state->flags & 0xff) != Z_DEFLATED) {
                strm->msg = (char *)"unknown compression method";
                state->mode = BAD;
                break;
            }
            if (state->flags & 0xe000) {
                strm->msg = (char *)"unknown header flags set";
                state->mode = BAD;
                break;
            }
            if (state->head != Z_NULL)
                state->head->text = (int)((hold >> 8) & 1);
            if ((state->flags & 0x0200) && (state->wrap & 4))
                CRC2(state->check, hold);
            INITBITS();
            state->mode = TIME;
        case TIME:
            NEEDBITS(32);
            if (state->head != Z_NULL)
                state->head->time = hold;
            if ((state->flags & 0x0200) && (state->wrap & 4))
                CRC4(state->check, hold);
            INITBITS();
            state->mode = OS;
        case OS:
            NEEDBITS(16);
            if (state->head != Z_NULL) {
                state->head->xflags = (int)(hold & 0xff);
                state->head->os = (int)(hold >> 8);
            }
            if ((state->flags & 0x0200) && (state->wrap & 4))
                CRC2(state->check, hold);
            INITBITS();
            state->mode = EXLEN;
        case EXLEN:
            if (state->flags & 0x0400) {
                NEEDBITS(16);
                state->length = (unsigned)(hold);
                if (state->head != Z_NULL)
                    state->head->extra_len = (unsigned)hold;
                if ((state->flags & 0x0200) && (state->wrap & 4))
                    CRC2(state->check, hold);
                INITBITS();
            }
            else if (state->head != Z_NULL)
                state->head->extra = Z_NULL;
            state->mode = EXTRA;
        case EXTRA:
            if (state->flags & 0x0400) {
                copy = state->length;
                if (copy > have) copy = have;
                if (copy) {
                    if (state->head != Z_NULL &&
                        state->head->extra != Z_NULL) {
                        len = state->head->extra_len - state->length;
                        zmemcpy(state->head->extra + len, next,
                                len + copy > state->head->extra_max ?
                                state->head->extra_max - len : copy);
                    }
                    if ((state->flags & 0x0200) && (state->wrap & 4))
                        state->check = crc32(state->check, next, copy);
                    have -= copy;
                    next += copy;
                    state->length -= copy;
                }
                if (state->length) goto inf_leave;
            }
            state->length = 0;
            state->mode = NAME;
        case NAME:
            if (state->flags & 0x0800) {
                if (have == 0) goto inf_leave;
                copy = 0;
                do {
                    len = (unsigned)(next[copy++]);
                    if (state->head != Z_NULL &&
                            state->head->name != Z_NULL &&
                            state->length < state->head->name_max)
                        state->head->name[state->length++] = (Bytef)len;
                } while (len && copy < have);
                if ((state->flags & 0x0200) && (state->wrap & 4))
                    state->check = crc32(state->check, next, copy);
                have -= copy;
                next += copy;
                if (len) goto inf_leave;
            }
            else if (state->head != Z_NULL)
                state->head->name = Z_NULL;
            state->length = 0;
            state->mode = COMMENT;
        case COMMENT:
            if (state->flags & 0x1000) {
                if (have == 0) goto inf_leave;
                copy = 0;
                do {
                    len = (unsigned)(next[copy++]);
                    if (state->head != Z_NULL &&
                            state->head->comment != Z_NULL &&
                            state->length < state->head->comm_max)
                        state->head->comment[state->length++] = (Bytef)len;
                } while (len && copy < have);
                if ((state->flags & 0x0200) && (state->wrap & 4))
                    state->check = crc32(state->check, next, copy);
                have -= copy;
                next += copy;
                if (len) goto inf_leave;
            }
            else if (state->head != Z_NULL)
                state->head->comment = Z_NULL;
            state->mode = HCRC;
        case HCRC:
            if (state->flags & 0x0200) {
                NEEDBITS(16);
                if ((state->wrap & 4) && hold != (state->check & 0xffff)) {
                    strm->msg = (char *)"header crc mismatch";
                    state->mode = BAD;
                    break;
                }
                INITBITS();
            }
            if (state->head != Z_NULL) {
                state->head->hcrc = (int)((state->flags >> 9) & 1);
                state->head->done = 1;
            }
            strm->adler = state->check = crc32(0L, Z_NULL, 0);
            state->mode = TYPE;
            break;
#endif
        case DICTID:
            NEEDBITS(32);
            strm->adler = state->check = ZSWAP32(hold);
            INITBITS();
            state->mode = DICT;
        case DICT:
            if (state->havedict == 0) {
                RESTORE();
                return Z_NEED_DICT;
            }
            strm->adler = state->check = adler32(0L, Z_NULL, 0);
            state->mode = TYPE;
        case TYPE:
            if (flush == Z_BLOCK || flush == Z_TREES) goto inf_leave;
        case TYPEDO:
            if (state->last) {
                BYTEBITS();
                state->mode = CHECK;
                break;
            }
            NEEDBITS(3);
            state->last = BITS(1);
            DROPBITS(1);
            switch (BITS(2)) {
            case 0:                             /* stored block */
                Tracev((stderr, "inflate:     stored block%s\n",
                        state->last ? " (last)" : ""));
                state->mode = STORED;
                break;
            case 1:                             /* fixed block */
                fixedtables(state);
                Tracev((stderr, "inflate:     fixed codes block%s\n",
                        state->last ? " (last)" : ""));
                state->mode = LEN_;             /* decode codes */
                if (flush == Z_TREES) {
                    DROPBITS(2);
                    goto inf_leave;
                }
                break;
            case 2:                             /* dynamic block */
                Tracev((stderr, "inflate:     dynamic codes block%s\n",
                        state->last ? " (last)" : ""));
                state->mode = TABLE;
                break;
            case 3:
                strm->msg = (char *)"invalid block type";
                state->mode = BAD;
            }
            DROPBITS(2);
            break;
        case STORED:
            BYTEBITS();                         /* go to byte boundary */
            NEEDBITS(32);
            if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {
                strm->msg = (char *)"invalid stored block lengths";
                state->mode = BAD;
                break;
            }
            state->length = (unsigned)hold & 0xffff;
            Tracev((stderr, "inflate:       stored length %u\n",
                    state->length));
            INITBITS();
            state->mode = COPY_;
            if (flush == Z_TREES) goto inf_leave;
        case COPY_:
            state->mode = COPY;
        case COPY:
            copy = state->length;
            if (copy) {
                if (copy > have) copy = have;
                if (copy > left) copy = left;
                if (copy == 0) goto inf_leave;
                zmemcpy(put, next, copy);
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
                state->length -= copy;
                break;
            }
            Tracev((stderr, "inflate:       stored end\n"));
            state->mode = TYPE;
            break;
        case TABLE:
            NEEDBITS(14);
            state->nlen = BITS(5) + 257;
            DROPBITS(5);
            state->ndist = BITS(5) + 1;
            DROPBITS(5);
            state->ncode = BITS(4) + 4;
            DROPBITS(4);
#ifndef PKZIP_BUG_WORKAROUND
            if (state->nlen > 286 || state->ndist > 30) {
                strm->msg = (char *)"too many length or distance symbols";
                state->mode = BAD;
                break;
            }
#endif
            Tracev((stderr, "inflate:       table sizes ok\n"));
            state->have = 0;
            state->mode = LENLENS;
        case LENLENS:
            while (state->have < state->ncode) {
                NEEDBITS(3);
                state->lens[order[state->have++]] = (unsigned short)BITS(3);
                DROPBITS(3);
            }
            while (state->have < 19)
                state->lens[order[state->have++]] = 0;
            state->next = state->codes;
            state->lencode = (const code FAR *)(state->next);
            state->lenbits = 7;
            ret = inflate_table(CODES, state->lens, 19, &(state->next),
                                &(state->lenbits), state->work);
            if (ret) {
                strm->msg = (char *)"invalid code lengths set";
                state->mode = BAD;
                break;
            }
            Tracev((stderr, "inflate:       code lengths ok\n"));
            state->have = 0;
            state->mode = CODELENS;
        case CODELENS:
            while (state->have < state->nlen + state->ndist) {
                for (;;) {
                    here = state->lencode[BITS(state->lenbits)];
                    if ((unsigned)(here.bits) <= bits) break;
                    PULLBYTE();
                }
                if (here.val < 16) {
                    DROPBITS(here.bits);
                    state->lens[state->have++] = here.val;
                }
                else {
                    if (here.val == 16) {
                        NEEDBITS(here.bits + 2);
                        DROPBITS(here.bits);
                        if (state->have == 0) {
                            strm->msg = (char *)"invalid bit length repeat";
                            state->mode = BAD;
                            break;
                        }
                        len = state->lens[state->have - 1];
                        copy = 3 + BITS(2);
                        DROPBITS(2);
                    }
                    else if (here.val == 17) {
                        NEEDBITS(here.bits + 3);
                        DROPBITS(here.bits);
                        len = 0;
                        copy = 3 + BITS(3);
                        DROPBITS(3);
                    }
                    else {
                        NEEDBITS(here.bits + 7);
                        DROPBITS(here.bits);
                        len = 0;
                        copy = 11 + BITS(7);
                        DROPBITS(7);
                    }
                    if (state->have + copy > state->nlen + state->ndist) {
                        strm->msg = (char *)"invalid bit length repeat";
                        state->mode = BAD;
                        break;
                    }
                    while (copy--)
                        state->lens[state->have++] = (unsigned short)len;
                }
            }

            /* handle error breaks in while */
            if (state->mode == BAD) break;

            /* check for end-of-block code (better have one) */
            if (state->lens[256] == 0) {
                strm->msg = (char *)"invalid code -- missing end-of-block";
                state->mode = BAD;
                break;
            }

            /* build code tables -- note: do not change the lenbits or distbits
               values here (9 and 6) without reading the comments in inftrees.h
               concerning the ENOUGH constants, which depend on those values */
            state->next = state->codes;
            state->lencode = (const code FAR *)(state->next);
            state->lenbits = 9;
            ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
                                &(state->lenbits), state->work);
            if (ret) {
                strm->msg = (char *)"invalid literal/lengths set";
                state->mode = BAD;
                break;
            }
            state->distcode = (const code FAR *)(state->next);
            state->distbits = 6;
            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
                            &(state->next), &(state->distbits), state->work);
            if (ret) {
                strm->msg = (char *)"invalid distances set";
                state->mode = BAD;
                break;
            }
            Tracev((stderr, "inflate:       codes ok\n"));
            state->mode = LEN_;
            if (flush == Z_TREES) goto inf_leave;
        case LEN_:
            state->mode = LEN;
        case LEN:
            if (have >= 6 && left >= 258) {
                RESTORE();
                inflate_fast(strm, out);
                LOAD();
                if (state->mode == TYPE)
                    state->back = -1;
                break;
            }
            state->back = 0;
            for (;;) {
                here = state->lencode[BITS(state->lenbits)];
                if ((unsigned)(here.bits) <= bits) break;
                PULLBYTE();
            }
            if (here.op && (here.op & 0xf0) == 0) {
                last = here;
                for (;;) {
                    here = state->lencode[last.val +
                            (BITS(last.bits + last.op) >> last.bits)];
                    if ((unsigned)(last.bits + here.bits) <= bits) break;
                    PULLBYTE();
                }
                DROPBITS(last.bits);
                state->back += last.bits;
            }
            DROPBITS(here.bits);
            state->back += here.bits;
            state->length = (unsigned)here.val;
            if ((int)(here.op) == 0) {
                Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
                        "inflate:         literal '%c'\n" :
                        "inflate:         literal 0x%02x\n", here.val));
                state->mode = LIT;
                break;
            }
            if (here.op & 32) {
                Tracevv((stderr, "inflate:         end of block\n"));
                state->back = -1;
                state->mode = TYPE;
                break;
            }
            if (here.op & 64) {
                strm->msg = (char *)"invalid literal/length code";
                state->mode = BAD;
                break;
            }
            state->extra = (unsigned)(here.op) & 15;
            state->mode = LENEXT;
        case LENEXT:
            if (state->extra) {
                NEEDBITS(state->extra);
                state->length += BITS(state->extra);
                DROPBITS(state->extra);
                state->back += state->extra;
            }
            Tracevv((stderr, "inflate:         length %u\n", state->length));
            state->was = state->length;
            state->mode = DIST;
        case DIST:
            for (;;) {
                here = state->distcode[BITS(state->distbits)];
                if ((unsigned)(here.bits) <= bits) break;
                PULLBYTE();
            }
            if ((here.op & 0xf0) == 0) {
                last = here;
                for (;;) {
                    here = state->distcode[last.val +
                            (BITS(last.bits + last.op) >> last.bits)];
                    if ((unsigned)(last.bits + here.bits) <= bits) break;
                    PULLBYTE();
                }
                DROPBITS(last.bits);
                state->back += last.bits;
            }
            DROPBITS(here.bits);
            state->back += here.bits;
            if (here.op & 64) {
                strm->msg = (char *)"invalid distance code";
                state->mode = BAD;
                break;
            }
            state->offset = (unsigned)here.val;
            state->extra = (unsigned)(here.op) & 15;
            state->mode = DISTEXT;
        case DISTEXT:
            if (state->extra) {
                NEEDBITS(state->extra);
                state->offset += BITS(state->extra);
                DROPBITS(state->extra);
                state->back += state->extra;
            }
#ifdef INFLATE_STRICT
            if (state->offset > state->dmax) {
                strm->msg = (char *)"invalid distance too far back";
                state->mode = BAD;
                break;
            }
#endif
            Tracevv((stderr, "inflate:         distance %u\n", state->offset));
            state->mode = MATCH;
        case MATCH:
            if (left == 0) goto inf_leave;
            copy = out - left;
            if (state->offset > copy) {         /* copy from window */
                copy = state->offset - copy;
                if (copy > state->whave) {
                    if (state->sane) {
                        strm->msg = (char *)"invalid distance too far back";
                        state->mode = BAD;
                        break;
                    }
#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
                    Trace((stderr, "inflate.c too far\n"));
                    copy -= state->whave;
                    if (copy > state->length) copy = state->length;
                    if (copy > left) copy = left;
                    left -= copy;
                    state->length -= copy;
                    do {
                        *put++ = 0;
                    } while (--copy);
                    if (state->length == 0) state->mode = LEN;
                    break;
#endif
                }
                if (copy > state->wnext) {
                    copy -= state->wnext;
                    from = state->window + (state->wsize - copy);
                }
                else
                    from = state->window + (state->wnext - copy);
                if (copy > state->length) copy = state->length;
            }
            else {                              /* copy from output */
                from = put - state->offset;
                copy = state->length;
            }
            if (copy > left) copy = left;
            left -= copy;
            state->length -= copy;
            do {
                *put++ = *from++;
            } while (--copy);
            if (state->length == 0) state->mode = LEN;
            break;
        case LIT:
            if (left == 0) goto inf_leave;
            *put++ = (unsigned char)(state->length);
            left--;
            state->mode = LEN;
            break;
        case CHECK:
            if (state->wrap) {
                NEEDBITS(32);
                out -= left;
                strm->total_out += out;
                state->total += out;
                if ((state->wrap & 4) && out)
                    strm->adler = state->check =
                        UPDATE(state->check, put - out, out);
                out = left;
                if ((state->wrap & 4) && (
#ifdef GUNZIP
                     state->flags ? hold :
#endif
                     ZSWAP32(hold)) != state->check) {
                    strm->msg = (char *)"incorrect data check";
                    state->mode = BAD;
                    break;
                }
                INITBITS();
                Tracev((stderr, "inflate:   check matches trailer\n"));
            }
#ifdef GUNZIP
            state->mode = LENGTH;
        case LENGTH:
            if (state->wrap && state->flags) {
                NEEDBITS(32);
                if (hold != (state->total & 0xffffffffUL)) {
                    strm->msg = (char *)"incorrect length check";
                    state->mode = BAD;
                    break;
                }
                INITBITS();
                Tracev((stderr, "inflate:   length matches trailer\n"));
            }
#endif
            state->mode = DONE;
        case DONE:
            ret = Z_STREAM_END;
            goto inf_leave;
        case BAD:
            ret = Z_DATA_ERROR;
            goto inf_leave;
        case MEM:
            return Z_MEM_ERROR;
        case SYNC:
        default:
            return Z_STREAM_ERROR;
        }

    /*
       Return from inflate(), updating the total counts and the check value.
       If there was no progress during the inflate() call, return a buffer
       error.  Call updatewindow() to create and/or update the window state.
       Note: a memory error from inflate() is non-recoverable.
     */
  inf_leave:
    RESTORE();
    if (state->wsize || (out != strm->avail_out && state->mode < BAD &&
            (state->mode < CHECK || flush != Z_FINISH)))
        if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {
            state->mode = MEM;
            return Z_MEM_ERROR;
        }
    in -= strm->avail_in;
    out -= strm->avail_out;
    strm->total_in += in;
    strm->total_out += out;
    state->total += out;
    if ((state->wrap & 4) && out)
        strm->adler = state->check =
            UPDATE(state->check, strm->next_out - out, out);
    strm->data_type = (int)state->bits + (state->last ? 64 : 0) +
                      (state->mode == TYPE ? 128 : 0) +
                      (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);
    if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)
        ret = Z_BUF_ERROR;
    return ret;
}

int ZEXPORT inflateEnd(strm)
z_streamp strm;
{
    struct inflate_state FAR *state;
    if (inflateStateCheck(strm))
        return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
    if (state->window != Z_NULL) ZFREE(strm, state->window);
    ZFREE(strm, strm->state);
    strm->state = Z_NULL;
    Tracev((stderr, "inflate: end\n"));
    return Z_OK;
}

int ZEXPORT inflateGetDictionary(strm, dictionary, dictLength)
z_streamp strm;
Bytef *dictionary;
uInt *dictLength;
{
    struct inflate_state FAR *state;

    /* check state */
    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;

    /* copy dictionary */
    if (state->whave && dictionary != Z_NULL) {
        zmemcpy(dictionary, state->window + state->wnext,
                state->whave - state->wnext);
        zmemcpy(dictionary + state->whave - state->wnext,
                state->window, state->wnext);
    }
    if (dictLength != Z_NULL)
        *dictLength = state->whave;
    return Z_OK;
}

int ZEXPORT inflateSetDictionary(strm, dictionary, dictLength)
z_streamp strm;
const Bytef *dictionary;
uInt dictLength;
{
    struct inflate_state FAR *state;
    unsigned long dictid;
    int ret;

    /* check state */
    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
    if (state->wrap != 0 && state->mode != DICT)
        return Z_STREAM_ERROR;

    /* check for correct dictionary identifier */
    if (state->mode == DICT) {
        dictid = adler32(0L, Z_NULL, 0);
        dictid = adler32(dictid, dictionary, dictLength);
        if (dictid != state->check)
            return Z_DATA_ERROR;
    }

    /* copy dictionary to window using updatewindow(), which will amend the
       existing dictionary if appropriate */
    ret = updatewindow(strm, dictionary + dictLength, dictLength);
    if (ret) {
        state->mode = MEM;
        return Z_MEM_ERROR;
    }
    state->havedict = 1;
    Tracev((stderr, "inflate:   dictionary set\n"));
    return Z_OK;
}

int ZEXPORT inflateGetHeader(strm, head)
z_streamp strm;
gz_headerp head;
{
    struct inflate_state FAR *state;

    /* check state */
    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
    if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;

    /* save header structure */
    state->head = head;
    head->done = 0;
    return Z_OK;
}

/*
   Search buf[0..len-1] for the pattern: 0, 0, 0xff, 0xff.  Return when found
   or when out of input.  When called, *have is the number of pattern bytes
   found in order so far, in 0..3.  On return *have is updated to the new
   state.  If on return *have equals four, then the pattern was found and the
   return value is how many bytes were read including the last byte of the
   pattern.  If *have is less than four, then the pattern has not been found
   yet and the return value is len.  In the latter case, syncsearch() can be
   called again with more data and the *have state.  *have is initialized to
   zero for the first call.
 */
local unsigned syncsearch(have, buf, len)
unsigned FAR *have;
const unsigned char FAR *buf;
unsigned len;
{
    unsigned got;
    unsigned next;

    got = *have;
    next = 0;
    while (next < len && got < 4) {
        if ((int)(buf[next]) == (got < 2 ? 0 : 0xff))
            got++;
        else if (buf[next])
            got = 0;
        else
            got = 4 - got;
        next++;
    }
    *have = got;
    return next;
}

int ZEXPORT inflateSync(strm)
z_streamp strm;
{
    unsigned len;               /* number of bytes to look at or looked at */
    unsigned long in, out;      /* temporary to save total_in and total_out */
    unsigned char buf[4];       /* to restore bit buffer to byte string */
    struct inflate_state FAR *state;

    /* check parameters */
    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
    if (strm->avail_in == 0 && state->bits < 8) return Z_BUF_ERROR;

    /* if first time, start search in bit buffer */
    if (state->mode != SYNC) {
        state->mode = SYNC;
        state->hold <<= state->bits & 7;
        state->bits -= state->bits & 7;
        len = 0;
        while (state->bits >= 8) {
            buf[len++] = (unsigned char)(state->hold);
            state->hold >>= 8;
            state->bits -= 8;
        }
        state->have = 0;
        syncsearch(&(state->have), buf, len);
    }

    /* search available input */
    len = syncsearch(&(state->have), strm->next_in, strm->avail_in);
    strm->avail_in -= len;
    strm->next_in += len;
    strm->total_in += len;

    /* return no joy or set up to restart inflate() on a new block */
    if (state->have != 4) return Z_DATA_ERROR;
    in = strm->total_in;  out = strm->total_out;
    inflateReset(strm);
    strm->total_in = in;  strm->total_out = out;
    state->mode = TYPE;
    return Z_OK;
}

/*
   Returns true if inflate is currently at the end of a block generated by
   Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP
   implementation to provide an additional safety check. PPP uses
   Z_SYNC_FLUSH but removes the length bytes of the resulting empty stored
   block. When decompressing, PPP checks that at the end of input packet,
   inflate is waiting for these length bytes.
 */
int ZEXPORT inflateSyncPoint(strm)
z_streamp strm;
{
    struct inflate_state FAR *state;

    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
    return state->mode == STORED && state->bits == 0;
}

int ZEXPORT inflateCopy(dest, source)
z_streamp dest;
z_streamp source;
{
    struct inflate_state FAR *state;
    struct inflate_state FAR *copy;
    unsigned char FAR *window;
    unsigned wsize;

    /* check input */
    if (inflateStateCheck(source) || dest == Z_NULL)
        return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)source->state;

    /* allocate space */
    copy = (struct inflate_state FAR *)
           ZALLOC(source, 1, sizeof(struct inflate_state));
    if (copy == Z_NULL) return Z_MEM_ERROR;
    window = Z_NULL;
    if (state->window != Z_NULL) {
        window = (unsigned char FAR *)
                 ZALLOC(source, 1U << state->wbits, sizeof(unsigned char));
        if (window == Z_NULL) {
            ZFREE(source, copy);
            return Z_MEM_ERROR;
        }
    }

    /* copy state */
    zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));
    zmemcpy((voidpf)copy, (voidpf)state, sizeof(struct inflate_state));
    copy->strm = dest;
    if (state->lencode >= state->codes &&
        state->lencode <= state->codes + ENOUGH - 1) {
        copy->lencode = copy->codes + (state->lencode - state->codes);
        copy->distcode = copy->codes + (state->distcode - state->codes);
    }
    copy->next = copy->codes + (state->next - state->codes);
    if (window != Z_NULL) {
        wsize = 1U << state->wbits;
        zmemcpy(window, state->window, wsize);
    }
    copy->window = window;
    dest->state = (struct internal_state FAR *)copy;
    return Z_OK;
}

int ZEXPORT inflateUndermine(strm, subvert)
z_streamp strm;
int subvert;
{
    struct inflate_state FAR *state;

    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
    state->sane = !subvert;
    return Z_OK;
#else
    (void)subvert;
    state->sane = 1;
    return Z_DATA_ERROR;
#endif
}

int ZEXPORT inflateValidate(strm, check)
z_streamp strm;
int check;
{
    struct inflate_state FAR *state;

    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
    if (check)
        state->wrap |= 4;
    else
        state->wrap &= ~4;
    return Z_OK;
}

long ZEXPORT inflateMark(strm)
z_streamp strm;
{
    struct inflate_state FAR *state;

    if (inflateStateCheck(strm))
        return -(1L << 16);
    state = (struct inflate_state FAR *)strm->state;
    return (long)(((unsigned long)((long)state->back)) << 16) +
        (state->mode == COPY ? state->length :
            (state->mode == MATCH ? state->was - state->length : 0));
}

unsigned long ZEXPORT inflateCodesUsed(strm)
z_streamp strm;
{
    struct inflate_state FAR *state;
    if (inflateStateCheck(strm)) return (unsigned long)-1;
    state = (struct inflate_state FAR *)strm->state;
    return (unsigned long)(state->next - state->codes);
}

```

`efiXloader/3rd/uefitool/common/zlib/inflate.h`:

```h
/* inflate.h -- internal inflate state definition
 * Copyright (C) 1995-2016 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

/* define NO_GZIP when compiling if you want to disable gzip header and
   trailer decoding by inflate().  NO_GZIP would be used to avoid linking in
   the crc code when it is not needed.  For shared libraries, gzip decoding
   should be left enabled. */
#ifndef NO_GZIP
#  define GUNZIP
#endif

/* Possible inflate modes between inflate() calls */
typedef enum {
    HEAD = 16180,   /* i: waiting for magic header */
    FLAGS,      /* i: waiting for method and flags (gzip) */
    TIME,       /* i: waiting for modification time (gzip) */
    OS,         /* i: waiting for extra flags and operating system (gzip) */
    EXLEN,      /* i: waiting for extra length (gzip) */
    EXTRA,      /* i: waiting for extra bytes (gzip) */
    NAME,       /* i: waiting for end of file name (gzip) */
    COMMENT,    /* i: waiting for end of comment (gzip) */
    HCRC,       /* i: waiting for header crc (gzip) */
    DICTID,     /* i: waiting for dictionary check value */
    DICT,       /* waiting for inflateSetDictionary() call */
        TYPE,       /* i: waiting for type bits, including last-flag bit */
        TYPEDO,     /* i: same, but skip check to exit inflate on new block */
        STORED,     /* i: waiting for stored size (length and complement) */
        COPY_,      /* i/o: same as COPY below, but only first time in */
        COPY,       /* i/o: waiting for input or output to copy stored block */
        TABLE,      /* i: waiting for dynamic block table lengths */
        LENLENS,    /* i: waiting for code length code lengths */
        CODELENS,   /* i: waiting for length/lit and distance code lengths */
            LEN_,       /* i: same as LEN below, but only first time in */
            LEN,        /* i: waiting for length/lit/eob code */
            LENEXT,     /* i: waiting for length extra bits */
            DIST,       /* i: waiting for distance code */
            DISTEXT,    /* i: waiting for distance extra bits */
            MATCH,      /* o: waiting for output space to copy string */
            LIT,        /* o: waiting for output space to write literal */
    CHECK,      /* i: waiting for 32-bit check value */
    LENGTH,     /* i: waiting for 32-bit length (gzip) */
    DONE,       /* finished check, done -- remain here until reset */
    BAD,        /* got a data error -- remain here until reset */
    MEM,        /* got an inflate() memory error -- remain here until reset */
    SYNC        /* looking for synchronization bytes to restart inflate() */
} inflate_mode;

/*
    State transitions between above modes -

    (most modes can go to BAD or MEM on error -- not shown for clarity)

    Process header:
        HEAD -> (gzip) or (zlib) or (raw)
        (gzip) -> FLAGS -> TIME -> OS -> EXLEN -> EXTRA -> NAME -> COMMENT ->
                  HCRC -> TYPE
        (zlib) -> DICTID or TYPE
        DICTID -> DICT -> TYPE
        (raw) -> TYPEDO
    Read deflate blocks:
            TYPE -> TYPEDO -> STORED or TABLE or LEN_ or CHECK
            STORED -> COPY_ -> COPY -> TYPE
            TABLE -> LENLENS -> CODELENS -> LEN_
            LEN_ -> LEN
    Read deflate codes in fixed or dynamic block:
                LEN -> LENEXT or LIT or TYPE
                LENEXT -> DIST -> DISTEXT -> MATCH -> LEN
                LIT -> LEN
    Process trailer:
        CHECK -> LENGTH -> DONE
 */

/* State maintained between inflate() calls -- approximately 7K bytes, not
   including the allocated sliding window, which is up to 32K bytes. */
struct inflate_state {
    z_streamp strm;             /* pointer back to this zlib stream */
    inflate_mode mode;          /* current inflate mode */
    int last;                   /* true if processing last block */
    int wrap;                   /* bit 0 true for zlib, bit 1 true for gzip,
                                   bit 2 true to validate check value */
    int havedict;               /* true if dictionary provided */
    int flags;                  /* gzip header method and flags (0 if zlib) */
    unsigned dmax;              /* zlib header max distance (INFLATE_STRICT) */
    unsigned long check;        /* protected copy of check value */
    unsigned long total;        /* protected copy of output count */
    gz_headerp head;            /* where to save gzip header information */
        /* sliding window */
    unsigned wbits;             /* log base 2 of requested window size */
    unsigned wsize;             /* window size or zero if not using window */
    unsigned whave;             /* valid bytes in the window */
    unsigned wnext;             /* window write index */
    unsigned char FAR *window;  /* allocated sliding window, if needed */
        /* bit accumulator */
    unsigned long hold;         /* input bit accumulator */
    unsigned bits;              /* number of bits in "in" */
        /* for string and stored block copying */
    unsigned length;            /* literal or length of data to copy */
    unsigned offset;            /* distance back to copy string from */
        /* for table and code decoding */
    unsigned extra;             /* extra bits needed */
        /* fixed and dynamic code tables */
    code const FAR *lencode;    /* starting table for length/literal codes */
    code const FAR *distcode;   /* starting table for distance codes */
    unsigned lenbits;           /* index bits for lencode */
    unsigned distbits;          /* index bits for distcode */
        /* dynamic table building */
    unsigned ncode;             /* number of code length code lengths */
    unsigned nlen;              /* number of length code lengths */
    unsigned ndist;             /* number of distance code lengths */
    unsigned have;              /* number of code lengths in lens[] */
    code FAR *next;             /* next available space in codes[] */
    unsigned short lens[320];   /* temporary storage for code lengths */
    unsigned short work[288];   /* work area for code table building */
    code codes[ENOUGH];         /* space for code tables */
    int sane;                   /* if false, allow invalid distance too far */
    int back;                   /* bits back of last unprocessed length/lit */
    unsigned was;               /* initial length of match */
};

```

`efiXloader/3rd/uefitool/common/zlib/inftrees.c`:

```c
/* inftrees.c -- generate Huffman trees for efficient decoding
 * Copyright (C) 1995-2017 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

#include "zutil.h"
#include "inftrees.h"

#define MAXBITS 15

const char inflate_copyright[] =
   " inflate 1.2.11 Copyright 1995-2017 Mark Adler ";
/*
  If you use the zlib library in a product, an acknowledgment is welcome
  in the documentation of your product. If for some reason you cannot
  include such an acknowledgment, I would appreciate that you keep this
  copyright string in the executable of your product.
 */

/*
   Build a set of tables to decode the provided canonical Huffman code.
   The code lengths are lens[0..codes-1].  The result starts at *table,
   whose indices are 0..2^bits-1.  work is a writable array of at least
   lens shorts, which is used as a work area.  type is the type of code
   to be generated, CODES, LENS, or DISTS.  On return, zero is success,
   -1 is an invalid code, and +1 means that ENOUGH isn't enough.  table
   on return points to the next available entry's address.  bits is the
   requested root table index bits, and on return it is the actual root
   table index bits.  It will differ if the request is greater than the
   longest code or if it is less than the shortest code.
 */
int ZLIB_INTERNAL inflate_table(type, lens, codes, table, bits, work)
codetype type;
unsigned short FAR *lens;
unsigned codes;
code FAR * FAR *table;
unsigned FAR *bits;
unsigned short FAR *work;
{
    unsigned len;               /* a code's length in bits */
    unsigned sym;               /* index of code symbols */
    unsigned min, max;          /* minimum and maximum code lengths */
    unsigned root;              /* number of index bits for root table */
    unsigned curr;              /* number of index bits for current table */
    unsigned drop;              /* code bits to drop for sub-table */
    int left;                   /* number of prefix codes available */
    unsigned used;              /* code entries in table used */
    unsigned huff;              /* Huffman code */
    unsigned incr;              /* for incrementing code, index */
    unsigned fill;              /* index for replicating entries */
    unsigned low;               /* low bits for current root entry */
    unsigned mask;              /* mask for low root bits */
    code here;                  /* table entry for duplication */
    code FAR *next;             /* next available space in table */
    const unsigned short FAR *base;     /* base value table to use */
    const unsigned short FAR *extra;    /* extra bits table to use */
    unsigned match;             /* use base and extra for symbol >= match */
    unsigned short count[MAXBITS+1];    /* number of codes of each length */
    unsigned short offs[MAXBITS+1];     /* offsets in table for each length */
    static const unsigned short lbase[31] = { /* Length codes 257..285 base */
        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
    static const unsigned short lext[31] = { /* Length codes 257..285 extra */
        16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
        19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 77, 202};
    static const unsigned short dbase[32] = { /* Distance codes 0..29 base */
        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
        8193, 12289, 16385, 24577, 0, 0};
    static const unsigned short dext[32] = { /* Distance codes 0..29 extra */
        16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
        23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
        28, 28, 29, 29, 64, 64};

    /*
       Process a set of code lengths to create a canonical Huffman code.  The
       code lengths are lens[0..codes-1].  Each length corresponds to the
       symbols 0..codes-1.  The Huffman code is generated by first sorting the
       symbols by length from short to long, and retaining the symbol order
       for codes with equal lengths.  Then the code starts with all zero bits
       for the first code of the shortest length, and the codes are integer
       increments for the same length, and zeros are appended as the length
       increases.  For the deflate format, these bits are stored backwards
       from their more natural integer increment ordering, and so when the
       decoding tables are built in the large loop below, the integer codes
       are incremented backwards.

       This routine assumes, but does not check, that all of the entries in
       lens[] are in the range 0..MAXBITS.  The caller must assure this.
       1..MAXBITS is interpreted as that code length.  zero means that that
       symbol does not occur in this code.

       The codes are sorted by computing a count of codes for each length,
       creating from that a table of starting indices for each length in the
       sorted table, and then entering the symbols in order in the sorted
       table.  The sorted table is work[], with that space being provided by
       the caller.

       The length counts are used for other purposes as well, i.e. finding
       the minimum and maximum length codes, determining if there are any
       codes at all, checking for a valid set of lengths, and looking ahead
       at length counts to determine sub-table sizes when building the
       decoding tables.
     */

    /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
    for (len = 0; len <= MAXBITS; len++)
        count[len] = 0;
    for (sym = 0; sym < codes; sym++)
        count[lens[sym]]++;

    /* bound code lengths, force root to be within code lengths */
    root = *bits;
    for (max = MAXBITS; max >= 1; max--)
        if (count[max] != 0) break;
    if (root > max) root = max;
    if (max == 0) {                     /* no symbols to code at all */
        here.op = (unsigned char)64;    /* invalid code marker */
        here.bits = (unsigned char)1;
        here.val = (unsigned short)0;
        *(*table)++ = here;             /* make a table to force an error */
        *(*table)++ = here;
        *bits = 1;
        return 0;     /* no symbols, but wait for decoding to report error */
    }
    for (min = 1; min < max; min++)
        if (count[min] != 0) break;
    if (root < min) root = min;

    /* check for an over-subscribed or incomplete set of lengths */
    left = 1;
    for (len = 1; len <= MAXBITS; len++) {
        left <<= 1;
        left -= count[len];
        if (left < 0) return -1;        /* over-subscribed */
    }
    if (left > 0 && (type == CODES || max != 1))
        return -1;                      /* incomplete set */

    /* generate offsets into symbol table for each length for sorting */
    offs[1] = 0;
    for (len = 1; len < MAXBITS; len++)
        offs[len + 1] = offs[len] + count[len];

    /* sort symbols by length, by symbol order within each length */
    for (sym = 0; sym < codes; sym++)
        if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;

    /*
       Create and fill in decoding tables.  In this loop, the table being
       filled is at next and has curr index bits.  The code being used is huff
       with length len.  That code is converted to an index by dropping drop
       bits off of the bottom.  For codes where len is less than drop + curr,
       those top drop + curr - len bits are incremented through all values to
       fill the table with replicated entries.

       root is the number of index bits for the root table.  When len exceeds
       root, sub-tables are created pointed to by the root entry with an index
       of the low root bits of huff.  This is saved in low to check for when a
       new sub-table should be started.  drop is zero when the root table is
       being filled, and drop is root when sub-tables are being filled.

       When a new sub-table is needed, it is necessary to look ahead in the
       code lengths to determine what size sub-table is needed.  The length
       counts are used for this, and so count[] is decremented as codes are
       entered in the tables.

       used keeps track of how many table entries have been allocated from the
       provided *table space.  It is checked for LENS and DIST tables against
       the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
       the initial root table size constants.  See the comments in inftrees.h
       for more information.

       sym increments through all symbols, and the loop terminates when
       all codes of length max, i.e. all codes, have been processed.  This
       routine permits incomplete codes, so another loop after this one fills
       in the rest of the decoding tables with invalid code markers.
     */

    /* set up for code type */
    switch (type) {
    case CODES:
        base = extra = work;    /* dummy value--not used */
        match = 20;
        break;
    case LENS:
        base = lbase;
        extra = lext;
        match = 257;
        break;
    default:    /* DISTS */
        base = dbase;
        extra = dext;
        match = 0;
    }

    /* initialize state for loop */
    huff = 0;                   /* starting code */
    sym = 0;                    /* starting code symbol */
    len = min;                  /* starting code length */
    next = *table;              /* current table to fill in */
    curr = root;                /* current table index bits */
    drop = 0;                   /* current bits to drop from code for index */
    low = (unsigned)(-1);       /* trigger new sub-table when len > root */
    used = 1U << root;          /* use root table entries */
    mask = used - 1;            /* mask for comparing low */

    /* check available table space */
    if ((type == LENS && used > ENOUGH_LENS) ||
        (type == DISTS && used > ENOUGH_DISTS))
        return 1;

    /* process all codes and make table entries */
    for (;;) {
        /* create table entry */
        here.bits = (unsigned char)(len - drop);
        if (work[sym] + 1U < match) {
            here.op = (unsigned char)0;
            here.val = work[sym];
        }
        else if (work[sym] >= match) {
            here.op = (unsigned char)(extra[work[sym] - match]);
            here.val = base[work[sym] - match];
        }
        else {
            here.op = (unsigned char)(32 + 64);         /* end of block */
            here.val = 0;
        }

        /* replicate for those indices with low len bits equal to huff */
        incr = 1U << (len - drop);
        fill = 1U << curr;
        min = fill;                 /* save offset to next table */
        do {
            fill -= incr;
            next[(huff >> drop) + fill] = here;
        } while (fill != 0);

        /* backwards increment the len-bit code huff */
        incr = 1U << (len - 1);
        while (huff & incr)
            incr >>= 1;
        if (incr != 0) {
            huff &= incr - 1;
            huff += incr;
        }
        else
            huff = 0;

        /* go to next symbol, update count, len */
        sym++;
        if (--(count[len]) == 0) {
            if (len == max) break;
            len = lens[work[sym]];
        }

        /* create new sub-table if needed */
        if (len > root && (huff & mask) != low) {
            /* if first time, transition to sub-tables */
            if (drop == 0)
                drop = root;

            /* increment past last table */
            next += min;            /* here min is 1 << curr */

            /* determine length of next table */
            curr = len - drop;
            left = (int)(1 << curr);
            while (curr + drop < max) {
                left -= count[curr + drop];
                if (left <= 0) break;
                curr++;
                left <<= 1;
            }

            /* check for enough space */
            used += 1U << curr;
            if ((type == LENS && used > ENOUGH_LENS) ||
                (type == DISTS && used > ENOUGH_DISTS))
                return 1;

            /* point entry in root table to sub-table */
            low = huff & mask;
            (*table)[low].op = (unsigned char)curr;
            (*table)[low].bits = (unsigned char)root;
            (*table)[low].val = (unsigned short)(next - *table);
        }
    }

    /* fill in remaining table entry if code is incomplete (guaranteed to have
       at most one remaining entry, since if the code is incomplete, the
       maximum code length that was allowed to get this far is one bit) */
    if (huff != 0) {
        here.op = (unsigned char)64;            /* invalid code marker */
        here.bits = (unsigned char)(len - drop);
        here.val = (unsigned short)0;
        next[huff] = here;
    }

    /* set return parameters */
    *table += used;
    *bits = root;
    return 0;
}

```

`efiXloader/3rd/uefitool/common/zlib/inftrees.h`:

```h
/* inftrees.h -- header to use inftrees.c
 * Copyright (C) 1995-2005, 2010 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

/* Structure for decoding tables.  Each entry provides either the
   information needed to do the operation requested by the code that
   indexed that table entry, or it provides a pointer to another
   table that indexes more bits of the code.  op indicates whether
   the entry is a pointer to another table, a literal, a length or
   distance, an end-of-block, or an invalid code.  For a table
   pointer, the low four bits of op is the number of index bits of
   that table.  For a length or distance, the low four bits of op
   is the number of extra bits to get after the code.  bits is
   the number of bits in this code or part of the code to drop off
   of the bit buffer.  val is the actual byte to output in the case
   of a literal, the base length or distance, or the offset from
   the current table to the next table.  Each entry is four bytes. */
typedef struct {
    unsigned char op;           /* operation, extra bits, table bits */
    unsigned char bits;         /* bits in this part of the code */
    unsigned short val;         /* offset in table or code value */
} code;

/* op values as set by inflate_table():
    00000000 - literal
    0000tttt - table link, tttt != 0 is the number of table index bits
    0001eeee - length or distance, eeee is the number of extra bits
    01100000 - end of block
    01000000 - invalid code
 */

/* Maximum size of the dynamic table.  The maximum number of code structures is
   1444, which is the sum of 852 for literal/length codes and 592 for distance
   codes.  These values were found by exhaustive searches using the program
   examples/enough.c found in the zlib distribtution.  The arguments to that
   program are the number of symbols, the initial root table size, and the
   maximum bit length of a code.  "enough 286 9 15" for literal/length codes
   returns returns 852, and "enough 30 6 15" for distance codes returns 592.
   The initial root table size (9 or 6) is found in the fifth argument of the
   inflate_table() calls in inflate.c and infback.c.  If the root table size is
   changed, then these maximum sizes would be need to be recalculated and
   updated. */
#define ENOUGH_LENS 852
#define ENOUGH_DISTS 592
#define ENOUGH (ENOUGH_LENS+ENOUGH_DISTS)

/* Type of code to build for inflate_table() */
typedef enum {
    CODES,
    LENS,
    DISTS
} codetype;

int ZLIB_INTERNAL inflate_table OF((codetype type, unsigned short FAR *lens,
                             unsigned codes, code FAR * FAR *table,
                             unsigned FAR *bits, unsigned short FAR *work));

```

`efiXloader/3rd/uefitool/common/zlib/trees.c`:

```c
/* trees.c -- output deflated data using Huffman coding
 * Copyright (C) 1995-2017 Jean-loup Gailly
 * detect_data_type() function provided freely by Cosmin Truta, 2006
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/*
 *  ALGORITHM
 *
 *      The "deflation" process uses several Huffman trees. The more
 *      common source values are represented by shorter bit sequences.
 *
 *      Each code tree is stored in a compressed form which is itself
 * a Huffman encoding of the lengths of all the code strings (in
 * ascending order by source values).  The actual code strings are
 * reconstructed from the lengths in the inflate process, as described
 * in the deflate specification.
 *
 *  REFERENCES
 *
 *      Deutsch, L.P.,"'Deflate' Compressed Data Format Specification".
 *      Available in ftp.uu.net:/pub/archiving/zip/doc/deflate-1.1.doc
 *
 *      Storer, James A.
 *          Data Compression:  Methods and Theory, pp. 49-50.
 *          Computer Science Press, 1988.  ISBN 0-7167-8156-5.
 *
 *      Sedgewick, R.
 *          Algorithms, p290.
 *          Addison-Wesley, 1983. ISBN 0-201-06672-6.
 */

/* @(#) $Id$ */

/* #define GEN_TREES_H */

#include "deflate.h"

#ifdef ZLIB_DEBUG
#  include <ctype.h>
#endif

/* ===========================================================================
 * Constants
 */

#define MAX_BL_BITS 7
/* Bit length codes must not exceed MAX_BL_BITS bits */

#define END_BLOCK 256
/* end of block literal code */

#define REP_3_6      16
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

#define REPZ_3_10    17
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

#define REPZ_11_138  18
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

local const int extra_lbits[LENGTH_CODES] /* extra bits for each length code */
   = {0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0};

local const int extra_dbits[D_CODES] /* extra bits for each distance code */
   = {0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};

local const int extra_blbits[BL_CODES]/* extra bits for each bit length code */
   = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7};

local const uch bl_order[BL_CODES]
   = {16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15};
/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

#define DIST_CODE_LEN  512 /* see definition of array dist_code below */

#if defined(GEN_TREES_H) || !defined(STDC)
/* non ANSI compilers may not accept trees.h */

local ct_data static_ltree[L_CODES+2];
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

local ct_data static_dtree[D_CODES];
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

uch _dist_code[DIST_CODE_LEN];
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

uch _length_code[MAX_MATCH-MIN_MATCH+1];
/* length code for each normalized match length (0 == MIN_MATCH) */

local int base_length[LENGTH_CODES];
/* First normalized length for each code (0 = MIN_MATCH) */

local int base_dist[D_CODES];
/* First normalized distance for each code (0 = distance of 1) */

#else
#  include "trees.h"
#endif /* GEN_TREES_H */

struct static_tree_desc_s {
    const ct_data *static_tree;  /* static tree or NULL */
    const intf *extra_bits;      /* extra bits for each code or NULL */
    int     extra_base;          /* base index for extra_bits */
    int     elems;               /* max number of elements in the tree */
    int     max_length;          /* max bit length for the codes */
};

local const static_tree_desc  static_l_desc =
{static_ltree, extra_lbits, LITERALS+1, L_CODES, MAX_BITS};

local const static_tree_desc  static_d_desc =
{static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS};

local const static_tree_desc  static_bl_desc =
{(const ct_data *)0, extra_blbits, 0,   BL_CODES, MAX_BL_BITS};

/* ===========================================================================
 * Local (static) routines in this file.
 */

local void tr_static_init OF((void));
local void init_block     OF((deflate_state *s));
local void pqdownheap     OF((deflate_state *s, ct_data *tree, int k));
local void gen_bitlen     OF((deflate_state *s, tree_desc *desc));
local void gen_codes      OF((ct_data *tree, int max_code, ushf *bl_count));
local void build_tree     OF((deflate_state *s, tree_desc *desc));
local void scan_tree      OF((deflate_state *s, ct_data *tree, int max_code));
local void send_tree      OF((deflate_state *s, ct_data *tree, int max_code));
local int  build_bl_tree  OF((deflate_state *s));
local void send_all_trees OF((deflate_state *s, int lcodes, int dcodes,
                              int blcodes));
local void compress_block OF((deflate_state *s, const ct_data *ltree,
                              const ct_data *dtree));
local int  detect_data_type OF((deflate_state *s));
local unsigned bi_reverse OF((unsigned value, int length));
local void bi_windup      OF((deflate_state *s));
local void bi_flush       OF((deflate_state *s));

#ifdef GEN_TREES_H
local void gen_trees_header OF((void));
#endif

#ifndef ZLIB_DEBUG
#  define send_code(s, c, tree) send_bits(s, tree[c].Code, tree[c].Len)
   /* Send a code of the given tree. c and tree must not have side effects */

#else /* !ZLIB_DEBUG */
#  define send_code(s, c, tree) \
     { if (z_verbose>2) fprintf(stderr,"\ncd %3d ",(c)); \
       send_bits(s, tree[c].Code, tree[c].Len); }
#endif

/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
#define put_short(s, w) { \
    put_byte(s, (uch)((w) & 0xff)); \
    put_byte(s, (uch)((ush)(w) >> 8)); \
}

/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
#ifdef ZLIB_DEBUG
local void send_bits      OF((deflate_state *s, int value, int length));

local void send_bits(s, value, length)
    deflate_state *s;
    int value;  /* value to send */
    int length; /* number of bits */
{
    Tracevv((stderr," l %2d v %4x ", length, value));
    Assert(length > 0 && length <= 15, "invalid length");
    s->bits_sent += (ulg)length;

    /* If not enough room in bi_buf, use (valid) bits from bi_buf and
     * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))
     * unused bits in value.
     */
    if (s->bi_valid > (int)Buf_size - length) {
        s->bi_buf |= (ush)value << s->bi_valid;
        put_short(s, s->bi_buf);
        s->bi_buf = (ush)value >> (Buf_size - s->bi_valid);
        s->bi_valid += length - Buf_size;
    } else {
        s->bi_buf |= (ush)value << s->bi_valid;
        s->bi_valid += length;
    }
}
#else /* !ZLIB_DEBUG */

#define send_bits(s, value, length) \
{ int len = length;\
  if (s->bi_valid > (int)Buf_size - len) {\
    int val = (int)value;\
    s->bi_buf |= (ush)val << s->bi_valid;\
    put_short(s, s->bi_buf);\
    s->bi_buf = (ush)val >> (Buf_size - s->bi_valid);\
    s->bi_valid += len - Buf_size;\
  } else {\
    s->bi_buf |= (ush)(value) << s->bi_valid;\
    s->bi_valid += len;\
  }\
}
#endif /* ZLIB_DEBUG */


/* the arguments must not have side effects */

/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
local void tr_static_init()
{
#if defined(GEN_TREES_H) || !defined(STDC)
    static int static_init_done = 0;
    int n;        /* iterates over tree elements */
    int bits;     /* bit counter */
    int length;   /* length value */
    int code;     /* code value */
    int dist;     /* distance index */
    ush bl_count[MAX_BITS+1];
    /* number of codes at each bit length for an optimal tree */

    if (static_init_done) return;

    /* For some embedded targets, global variables are not initialized: */
#ifdef NO_INIT_GLOBAL_POINTERS
    static_l_desc.static_tree = static_ltree;
    static_l_desc.extra_bits = extra_lbits;
    static_d_desc.static_tree = static_dtree;
    static_d_desc.extra_bits = extra_dbits;
    static_bl_desc.extra_bits = extra_blbits;
#endif

    /* Initialize the mapping length (0..255) -> length code (0..28) */
    length = 0;
    for (code = 0; code < LENGTH_CODES-1; code++) {
        base_length[code] = length;
        for (n = 0; n < (1<<extra_lbits[code]); n++) {
            _length_code[length++] = (uch)code;
        }
    }
    Assert (length == 256, "tr_static_init: length != 256");
    /* Note that the length 255 (match length 258) can be represented
     * in two different ways: code 284 + 5 bits or code 285, so we
     * overwrite length_code[255] to use the best encoding:
     */
    _length_code[length-1] = (uch)code;

    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
    dist = 0;
    for (code = 0 ; code < 16; code++) {
        base_dist[code] = dist;
        for (n = 0; n < (1<<extra_dbits[code]); n++) {
            _dist_code[dist++] = (uch)code;
        }
    }
    Assert (dist == 256, "tr_static_init: dist != 256");
    dist >>= 7; /* from now on, all distances are divided by 128 */
    for ( ; code < D_CODES; code++) {
        base_dist[code] = dist << 7;
        for (n = 0; n < (1<<(extra_dbits[code]-7)); n++) {
            _dist_code[256 + dist++] = (uch)code;
        }
    }
    Assert (dist == 256, "tr_static_init: 256+dist != 512");

    /* Construct the codes of the static literal tree */
    for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;
    n = 0;
    while (n <= 143) static_ltree[n++].Len = 8, bl_count[8]++;
    while (n <= 255) static_ltree[n++].Len = 9, bl_count[9]++;
    while (n <= 279) static_ltree[n++].Len = 7, bl_count[7]++;
    while (n <= 287) static_ltree[n++].Len = 8, bl_count[8]++;
    /* Codes 286 and 287 do not exist, but we must include them in the
     * tree construction to get a canonical Huffman tree (longest code
     * all ones)
     */
    gen_codes((ct_data *)static_ltree, L_CODES+1, bl_count);

    /* The static distance tree is trivial: */
    for (n = 0; n < D_CODES; n++) {
        static_dtree[n].Len = 5;
        static_dtree[n].Code = bi_reverse((unsigned)n, 5);
    }
    static_init_done = 1;

#  ifdef GEN_TREES_H
    gen_trees_header();
#  endif
#endif /* defined(GEN_TREES_H) || !defined(STDC) */
}

/* ===========================================================================
 * Genererate the file trees.h describing the static trees.
 */
#ifdef GEN_TREES_H
#  ifndef ZLIB_DEBUG
#    include <stdio.h>
#  endif

#  define SEPARATOR(i, last, width) \
      ((i) == (last)? "\n};\n\n" :    \
       ((i) % (width) == (width)-1 ? ",\n" : ", "))

void gen_trees_header()
{
    FILE *header = fopen("trees.h", "w");
    int i;

    Assert (header != NULL, "Can't open trees.h");
    fprintf(header,
            "/* header created automatically with -DGEN_TREES_H */\n\n");

    fprintf(header, "local const ct_data static_ltree[L_CODES+2] = {\n");
    for (i = 0; i < L_CODES+2; i++) {
        fprintf(header, "{{%3u},{%3u}}%s", static_ltree[i].Code,
                static_ltree[i].Len, SEPARATOR(i, L_CODES+1, 5));
    }

    fprintf(header, "local const ct_data static_dtree[D_CODES] = {\n");
    for (i = 0; i < D_CODES; i++) {
        fprintf(header, "{{%2u},{%2u}}%s", static_dtree[i].Code,
                static_dtree[i].Len, SEPARATOR(i, D_CODES-1, 5));
    }

    fprintf(header, "const uch ZLIB_INTERNAL _dist_code[DIST_CODE_LEN] = {\n");
    for (i = 0; i < DIST_CODE_LEN; i++) {
        fprintf(header, "%2u%s", _dist_code[i],
                SEPARATOR(i, DIST_CODE_LEN-1, 20));
    }

    fprintf(header,
        "const uch ZLIB_INTERNAL _length_code[MAX_MATCH-MIN_MATCH+1]= {\n");
    for (i = 0; i < MAX_MATCH-MIN_MATCH+1; i++) {
        fprintf(header, "%2u%s", _length_code[i],
                SEPARATOR(i, MAX_MATCH-MIN_MATCH, 20));
    }

    fprintf(header, "local const int base_length[LENGTH_CODES] = {\n");
    for (i = 0; i < LENGTH_CODES; i++) {
        fprintf(header, "%1u%s", base_length[i],
                SEPARATOR(i, LENGTH_CODES-1, 20));
    }

    fprintf(header, "local const int base_dist[D_CODES] = {\n");
    for (i = 0; i < D_CODES; i++) {
        fprintf(header, "%5u%s", base_dist[i],
                SEPARATOR(i, D_CODES-1, 10));
    }

    fclose(header);
}
#endif /* GEN_TREES_H */

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
void ZLIB_INTERNAL _tr_init(s)
    deflate_state *s;
{
    tr_static_init();

    s->l_desc.dyn_tree = s->dyn_ltree;
    s->l_desc.stat_desc = &static_l_desc;

    s->d_desc.dyn_tree = s->dyn_dtree;
    s->d_desc.stat_desc = &static_d_desc;

    s->bl_desc.dyn_tree = s->bl_tree;
    s->bl_desc.stat_desc = &static_bl_desc;

    s->bi_buf = 0;
    s->bi_valid = 0;
#ifdef ZLIB_DEBUG
    s->compressed_len = 0L;
    s->bits_sent = 0L;
#endif

    /* Initialize the first block of the first file: */
    init_block(s);
}

/* ===========================================================================
 * Initialize a new block.
 */
local void init_block(s)
    deflate_state *s;
{
    int n; /* iterates over tree elements */

    /* Initialize the trees. */
    for (n = 0; n < L_CODES;  n++) s->dyn_ltree[n].Freq = 0;
    for (n = 0; n < D_CODES;  n++) s->dyn_dtree[n].Freq = 0;
    for (n = 0; n < BL_CODES; n++) s->bl_tree[n].Freq = 0;

    s->dyn_ltree[END_BLOCK].Freq = 1;
    s->opt_len = s->static_len = 0L;
    s->last_lit = s->matches = 0;
}

#define SMALLEST 1
/* Index within the heap array of least frequent node in the Huffman tree */


/* ===========================================================================
 * Remove the smallest element from the heap and recreate the heap with
 * one less element. Updates heap and heap_len.
 */
#define pqremove(s, tree, top) \
{\
    top = s->heap[SMALLEST]; \
    s->heap[SMALLEST] = s->heap[s->heap_len--]; \
    pqdownheap(s, tree, SMALLEST); \
}

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
#define smaller(tree, n, m, depth) \
   (tree[n].Freq < tree[m].Freq || \
   (tree[n].Freq == tree[m].Freq && depth[n] <= depth[m]))

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
local void pqdownheap(s, tree, k)
    deflate_state *s;
    ct_data *tree;  /* the tree to restore */
    int k;               /* node to move down */
{
    int v = s->heap[k];
    int j = k << 1;  /* left son of k */
    while (j <= s->heap_len) {
        /* Set j to the smallest of the two sons: */
        if (j < s->heap_len &&
            smaller(tree, s->heap[j+1], s->heap[j], s->depth)) {
            j++;
        }
        /* Exit if v is smaller than both sons */
        if (smaller(tree, v, s->heap[j], s->depth)) break;

        /* Exchange v with the smallest son */
        s->heap[k] = s->heap[j];  k = j;

        /* And continue down the tree, setting j to the left son of k */
        j <<= 1;
    }
    s->heap[k] = v;
}

/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
local void gen_bitlen(s, desc)
    deflate_state *s;
    tree_desc *desc;    /* the tree descriptor */
{
    ct_data *tree        = desc->dyn_tree;
    int max_code         = desc->max_code;
    const ct_data *stree = desc->stat_desc->static_tree;
    const intf *extra    = desc->stat_desc->extra_bits;
    int base             = desc->stat_desc->extra_base;
    int max_length       = desc->stat_desc->max_length;
    int h;              /* heap index */
    int n, m;           /* iterate over the tree elements */
    int bits;           /* bit length */
    int xbits;          /* extra bits */
    ush f;              /* frequency */
    int overflow = 0;   /* number of elements with bit length too large */

    for (bits = 0; bits <= MAX_BITS; bits++) s->bl_count[bits] = 0;

    /* In a first pass, compute the optimal bit lengths (which may
     * overflow in the case of the bit length tree).
     */
    tree[s->heap[s->heap_max]].Len = 0; /* root of the heap */

    for (h = s->heap_max+1; h < HEAP_SIZE; h++) {
        n = s->heap[h];
        bits = tree[tree[n].Dad].Len + 1;
        if (bits > max_length) bits = max_length, overflow++;
        tree[n].Len = (ush)bits;
        /* We overwrite tree[n].Dad which is no longer needed */

        if (n > max_code) continue; /* not a leaf node */

        s->bl_count[bits]++;
        xbits = 0;
        if (n >= base) xbits = extra[n-base];
        f = tree[n].Freq;
        s->opt_len += (ulg)f * (unsigned)(bits + xbits);
        if (stree) s->static_len += (ulg)f * (unsigned)(stree[n].Len + xbits);
    }
    if (overflow == 0) return;

    Tracev((stderr,"\nbit length overflow\n"));
    /* This happens for example on obj2 and pic of the Calgary corpus */

    /* Find the first bit length which could increase: */
    do {
        bits = max_length-1;
        while (s->bl_count[bits] == 0) bits--;
        s->bl_count[bits]--;      /* move one leaf down the tree */
        s->bl_count[bits+1] += 2; /* move one overflow item as its brother */
        s->bl_count[max_length]--;
        /* The brother of the overflow item also moves one step up,
         * but this does not affect bl_count[max_length]
         */
        overflow -= 2;
    } while (overflow > 0);

    /* Now recompute all bit lengths, scanning in increasing frequency.
     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
     * lengths instead of fixing only the wrong ones. This idea is taken
     * from 'ar' written by Haruhiko Okumura.)
     */
    for (bits = max_length; bits != 0; bits--) {
        n = s->bl_count[bits];
        while (n != 0) {
            m = s->heap[--h];
            if (m > max_code) continue;
            if ((unsigned) tree[m].Len != (unsigned) bits) {
                Tracev((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
                s->opt_len += ((ulg)bits - tree[m].Len) * tree[m].Freq;
                tree[m].Len = (ush)bits;
            }
            n--;
        }
    }
}

/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
local void gen_codes (tree, max_code, bl_count)
    ct_data *tree;             /* the tree to decorate */
    int max_code;              /* largest code with non zero frequency */
    ushf *bl_count;            /* number of codes at each bit length */
{
    ush next_code[MAX_BITS+1]; /* next code value for each bit length */
    unsigned code = 0;         /* running code value */
    int bits;                  /* bit index */
    int n;                     /* code index */

    /* The distribution counts are first used to generate the code values
     * without bit reversal.
     */
    for (bits = 1; bits <= MAX_BITS; bits++) {
        code = (code + bl_count[bits-1]) << 1;
        next_code[bits] = (ush)code;
    }
    /* Check that the bit counts in bl_count are consistent. The last code
     * must be all ones.
     */
    Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
            "inconsistent bit counts");
    Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

    for (n = 0;  n <= max_code; n++) {
        int len = tree[n].Len;
        if (len == 0) continue;
        /* Now reverse the bits */
        tree[n].Code = (ush)bi_reverse(next_code[len]++, len);

        Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
             n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
    }
}

/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
local void build_tree(s, desc)
    deflate_state *s;
    tree_desc *desc; /* the tree descriptor */
{
    ct_data *tree         = desc->dyn_tree;
    const ct_data *stree  = desc->stat_desc->static_tree;
    int elems             = desc->stat_desc->elems;
    int n, m;          /* iterate over heap elements */
    int max_code = -1; /* largest code with non zero frequency */
    int node;          /* new node being created */

    /* Construct the initial heap, with least frequent element in
     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
     * heap[0] is not used.
     */
    s->heap_len = 0, s->heap_max = HEAP_SIZE;

    for (n = 0; n < elems; n++) {
        if (tree[n].Freq != 0) {
            s->heap[++(s->heap_len)] = max_code = n;
            s->depth[n] = 0;
        } else {
            tree[n].Len = 0;
        }
    }

    /* The pkzip format requires that at least one distance code exists,
     * and that at least one bit should be sent even if there is only one
     * possible code. So to avoid special checks later on we force at least
     * two codes of non zero frequency.
     */
    while (s->heap_len < 2) {
        node = s->heap[++(s->heap_len)] = (max_code < 2 ? ++max_code : 0);
        tree[node].Freq = 1;
        s->depth[node] = 0;
        s->opt_len--; if (stree) s->static_len -= stree[node].Len;
        /* node is 0 or 1 so it does not have extra bits */
    }
    desc->max_code = max_code;

    /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
     * establish sub-heaps of increasing lengths:
     */
    for (n = s->heap_len/2; n >= 1; n--) pqdownheap(s, tree, n);

    /* Construct the Huffman tree by repeatedly combining the least two
     * frequent nodes.
     */
    node = elems;              /* next internal node of the tree */
    do {
        pqremove(s, tree, n);  /* n = node of least frequency */
        m = s->heap[SMALLEST]; /* m = node of next least frequency */

        s->heap[--(s->heap_max)] = n; /* keep the nodes sorted by frequency */
        s->heap[--(s->heap_max)] = m;

        /* Create a new node father of n and m */
        tree[node].Freq = tree[n].Freq + tree[m].Freq;
        s->depth[node] = (uch)((s->depth[n] >= s->depth[m] ?
                                s->depth[n] : s->depth[m]) + 1);
        tree[n].Dad = tree[m].Dad = (ush)node;
#ifdef DUMP_BL_TREE
        if (tree == s->bl_tree) {
            fprintf(stderr,"\nnode %d(%d), sons %d(%d) %d(%d)",
                    node, tree[node].Freq, n, tree[n].Freq, m, tree[m].Freq);
        }
#endif
        /* and insert the new node in the heap */
        s->heap[SMALLEST] = node++;
        pqdownheap(s, tree, SMALLEST);

    } while (s->heap_len >= 2);

    s->heap[--(s->heap_max)] = s->heap[SMALLEST];

    /* At this point, the fields freq and dad are set. We can now
     * generate the bit lengths.
     */
    gen_bitlen(s, (tree_desc *)desc);

    /* The field len is now set, we can generate the bit codes */
    gen_codes ((ct_data *)tree, max_code, s->bl_count);
}

/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
local void scan_tree (s, tree, max_code)
    deflate_state *s;
    ct_data *tree;   /* the tree to be scanned */
    int max_code;    /* and its largest code of non zero frequency */
{
    int n;                     /* iterates over all tree elements */
    int prevlen = -1;          /* last emitted length */
    int curlen;                /* length of current code */
    int nextlen = tree[0].Len; /* length of next code */
    int count = 0;             /* repeat count of the current code */
    int max_count = 7;         /* max repeat count */
    int min_count = 4;         /* min repeat count */

    if (nextlen == 0) max_count = 138, min_count = 3;
    tree[max_code+1].Len = (ush)0xffff; /* guard */

    for (n = 0; n <= max_code; n++) {
        curlen = nextlen; nextlen = tree[n+1].Len;
        if (++count < max_count && curlen == nextlen) {
            continue;
        } else if (count < min_count) {
            s->bl_tree[curlen].Freq += count;
        } else if (curlen != 0) {
            if (curlen != prevlen) s->bl_tree[curlen].Freq++;
            s->bl_tree[REP_3_6].Freq++;
        } else if (count <= 10) {
            s->bl_tree[REPZ_3_10].Freq++;
        } else {
            s->bl_tree[REPZ_11_138].Freq++;
        }
        count = 0; prevlen = curlen;
        if (nextlen == 0) {
            max_count = 138, min_count = 3;
        } else if (curlen == nextlen) {
            max_count = 6, min_count = 3;
        } else {
            max_count = 7, min_count = 4;
        }
    }
}

/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
local void send_tree (s, tree, max_code)
    deflate_state *s;
    ct_data *tree; /* the tree to be scanned */
    int max_code;       /* and its largest code of non zero frequency */
{
    int n;                     /* iterates over all tree elements */
    int prevlen = -1;          /* last emitted length */
    int curlen;                /* length of current code */
    int nextlen = tree[0].Len; /* length of next code */
    int count = 0;             /* repeat count of the current code */
    int max_count = 7;         /* max repeat count */
    int min_count = 4;         /* min repeat count */

    /* tree[max_code+1].Len = -1; */  /* guard already set */
    if (nextlen == 0) max_count = 138, min_count = 3;

    for (n = 0; n <= max_code; n++) {
        curlen = nextlen; nextlen = tree[n+1].Len;
        if (++count < max_count && curlen == nextlen) {
            continue;
        } else if (count < min_count) {
            do { send_code(s, curlen, s->bl_tree); } while (--count != 0);

        } else if (curlen != 0) {
            if (curlen != prevlen) {
                send_code(s, curlen, s->bl_tree); count--;
            }
            Assert(count >= 3 && count <= 6, " 3_6?");
            send_code(s, REP_3_6, s->bl_tree); send_bits(s, count-3, 2);

        } else if (count <= 10) {
            send_code(s, REPZ_3_10, s->bl_tree); send_bits(s, count-3, 3);

        } else {
            send_code(s, REPZ_11_138, s->bl_tree); send_bits(s, count-11, 7);
        }
        count = 0; prevlen = curlen;
        if (nextlen == 0) {
            max_count = 138, min_count = 3;
        } else if (curlen == nextlen) {
            max_count = 6, min_count = 3;
        } else {
            max_count = 7, min_count = 4;
        }
    }
}

/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
local int build_bl_tree(s)
    deflate_state *s;
{
    int max_blindex;  /* index of last bit length code of non zero freq */

    /* Determine the bit length frequencies for literal and distance trees */
    scan_tree(s, (ct_data *)s->dyn_ltree, s->l_desc.max_code);
    scan_tree(s, (ct_data *)s->dyn_dtree, s->d_desc.max_code);

    /* Build the bit length tree: */
    build_tree(s, (tree_desc *)(&(s->bl_desc)));
    /* opt_len now includes the length of the tree representations, except
     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
     */

    /* Determine the number of bit length codes to send. The pkzip format
     * requires that at least 4 bit length codes be sent. (appnote.txt says
     * 3 but the actual value used is 4.)
     */
    for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {
        if (s->bl_tree[bl_order[max_blindex]].Len != 0) break;
    }
    /* Update opt_len to include the bit length tree and counts */
    s->opt_len += 3*((ulg)max_blindex+1) + 5+5+4;
    Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
            s->opt_len, s->static_len));

    return max_blindex;
}

/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
local void send_all_trees(s, lcodes, dcodes, blcodes)
    deflate_state *s;
    int lcodes, dcodes, blcodes; /* number of codes for each tree */
{
    int rank;                    /* index in bl_order */

    Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
    Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
            "too many codes");
    Tracev((stderr, "\nbl counts: "));
    send_bits(s, lcodes-257, 5); /* not +255 as stated in appnote.txt */
    send_bits(s, dcodes-1,   5);
    send_bits(s, blcodes-4,  4); /* not -3 as stated in appnote.txt */
    for (rank = 0; rank < blcodes; rank++) {
        Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
        send_bits(s, s->bl_tree[bl_order[rank]].Len, 3);
    }
    Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

    send_tree(s, (ct_data *)s->dyn_ltree, lcodes-1); /* literal tree */
    Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

    send_tree(s, (ct_data *)s->dyn_dtree, dcodes-1); /* distance tree */
    Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
}

/* ===========================================================================
 * Send a stored block
 */
void ZLIB_INTERNAL _tr_stored_block(s, buf, stored_len, last)
    deflate_state *s;
    charf *buf;       /* input block */
    ulg stored_len;   /* length of input block */
    int last;         /* one if this is the last block for a file */
{
    send_bits(s, (STORED_BLOCK<<1)+last, 3);    /* send block type */
    bi_windup(s);        /* align on byte boundary */
    put_short(s, (ush)stored_len);
    put_short(s, (ush)~stored_len);
    zmemcpy(s->pending_buf + s->pending, (Bytef *)buf, stored_len);
    s->pending += stored_len;
#ifdef ZLIB_DEBUG
    s->compressed_len = (s->compressed_len + 3 + 7) & (ulg)~7L;
    s->compressed_len += (stored_len + 4) << 3;
    s->bits_sent += 2*16;
    s->bits_sent += stored_len<<3;
#endif
}

/* ===========================================================================
 * Flush the bits in the bit buffer to pending output (leaves at most 7 bits)
 */
void ZLIB_INTERNAL _tr_flush_bits(s)
    deflate_state *s;
{
    bi_flush(s);
}

/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */
void ZLIB_INTERNAL _tr_align(s)
    deflate_state *s;
{
    send_bits(s, STATIC_TREES<<1, 3);
    send_code(s, END_BLOCK, static_ltree);
#ifdef ZLIB_DEBUG
    s->compressed_len += 10L; /* 3 for block type, 7 for EOB */
#endif
    bi_flush(s);
}

/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and write out the encoded block.
 */
void ZLIB_INTERNAL _tr_flush_block(s, buf, stored_len, last)
    deflate_state *s;
    charf *buf;       /* input block, or NULL if too old */
    ulg stored_len;   /* length of input block */
    int last;         /* one if this is the last block for a file */
{
    ulg opt_lenb, static_lenb; /* opt_len and static_len in bytes */
    int max_blindex = 0;  /* index of last bit length code of non zero freq */

    /* Build the Huffman trees unless a stored block is forced */
    if (s->level > 0) {

        /* Check if the file is binary or text */
        if (s->strm->data_type == Z_UNKNOWN)
            s->strm->data_type = detect_data_type(s);

        /* Construct the literal and distance trees */
        build_tree(s, (tree_desc *)(&(s->l_desc)));
        Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
                s->static_len));

        build_tree(s, (tree_desc *)(&(s->d_desc)));
        Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
                s->static_len));
        /* At this point, opt_len and static_len are the total bit lengths of
         * the compressed block data, excluding the tree representations.
         */

        /* Build the bit length tree for the above two trees, and get the index
         * in bl_order of the last bit length code to send.
         */
        max_blindex = build_bl_tree(s);

        /* Determine the best encoding. Compute the block lengths in bytes. */
        opt_lenb = (s->opt_len+3+7)>>3;
        static_lenb = (s->static_len+3+7)>>3;

        Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
                opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
                s->last_lit));

        if (static_lenb <= opt_lenb) opt_lenb = static_lenb;

    } else {
        Assert(buf != (char*)0, "lost buf");
        opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
    }

#ifdef FORCE_STORED
    if (buf != (char*)0) { /* force stored block */
#else
    if (stored_len+4 <= opt_lenb && buf != (char*)0) {
                       /* 4: two words for the lengths */
#endif
        /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
         * Otherwise we can't have processed more than WSIZE input bytes since
         * the last block flush, because compression would have been
         * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
         * transform a block into a stored block.
         */
        _tr_stored_block(s, buf, stored_len, last);

#ifdef FORCE_STATIC
    } else if (static_lenb >= 0) { /* force static trees */
#else
    } else if (s->strategy == Z_FIXED || static_lenb == opt_lenb) {
#endif
        send_bits(s, (STATIC_TREES<<1)+last, 3);
        compress_block(s, (const ct_data *)static_ltree,
                       (const ct_data *)static_dtree);
#ifdef ZLIB_DEBUG
        s->compressed_len += 3 + s->static_len;
#endif
    } else {
        send_bits(s, (DYN_TREES<<1)+last, 3);
        send_all_trees(s, s->l_desc.max_code+1, s->d_desc.max_code+1,
                       max_blindex+1);
        compress_block(s, (const ct_data *)s->dyn_ltree,
                       (const ct_data *)s->dyn_dtree);
#ifdef ZLIB_DEBUG
        s->compressed_len += 3 + s->opt_len;
#endif
    }
    Assert (s->compressed_len == s->bits_sent, "bad compressed size");
    /* The above check is made mod 2^32, for files larger than 512 MB
     * and uLong implemented on 32 bits.
     */
    init_block(s);

    if (last) {
        bi_windup(s);
#ifdef ZLIB_DEBUG
        s->compressed_len += 7;  /* align on byte boundary */
#endif
    }
    Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
           s->compressed_len-7*last));
}

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
int ZLIB_INTERNAL _tr_tally (s, dist, lc)
    deflate_state *s;
    unsigned dist;  /* distance of matched string */
    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
    s->d_buf[s->last_lit] = (ush)dist;
    s->l_buf[s->last_lit++] = (uch)lc;
    if (dist == 0) {
        /* lc is the unmatched char */
        s->dyn_ltree[lc].Freq++;
    } else {
        s->matches++;
        /* Here, lc is the match length - MIN_MATCH */
        dist--;             /* dist = match distance - 1 */
        Assert((ush)dist < (ush)MAX_DIST(s) &&
               (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
               (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

        s->dyn_ltree[_length_code[lc]+LITERALS+1].Freq++;
        s->dyn_dtree[d_code(dist)].Freq++;
    }

#ifdef TRUNCATE_BLOCK
    /* Try to guess if it is profitable to stop the current block here */
    if ((s->last_lit & 0x1fff) == 0 && s->level > 2) {
        /* Compute an upper bound for the compressed length */
        ulg out_length = (ulg)s->last_lit*8L;
        ulg in_length = (ulg)((long)s->strstart - s->block_start);
        int dcode;
        for (dcode = 0; dcode < D_CODES; dcode++) {
            out_length += (ulg)s->dyn_dtree[dcode].Freq *
                (5L+extra_dbits[dcode]);
        }
        out_length >>= 3;
        Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
               s->last_lit, in_length, out_length,
               100L - out_length*100L/in_length));
        if (s->matches < s->last_lit/2 && out_length < in_length/2) return 1;
    }
#endif
    return (s->last_lit == s->lit_bufsize-1);
    /* We avoid equality with lit_bufsize because of wraparound at 64K
     * on 16 bit machines and because stored blocks are restricted to
     * 64K-1 bytes.
     */
}

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
local void compress_block(s, ltree, dtree)
    deflate_state *s;
    const ct_data *ltree; /* literal tree */
    const ct_data *dtree; /* distance tree */
{
    unsigned dist;      /* distance of matched string */
    int lc;             /* match length or unmatched char (if dist == 0) */
    unsigned lx = 0;    /* running index in l_buf */
    unsigned code;      /* the code to send */
    int extra;          /* number of extra bits to send */

    if (s->last_lit != 0) do {
        dist = s->d_buf[lx];
        lc = s->l_buf[lx++];
        if (dist == 0) {
            send_code(s, lc, ltree); /* send a literal byte */
            Tracecv(isgraph(lc), (stderr," '%c' ", lc));
        } else {
            /* Here, lc is the match length - MIN_MATCH */
            code = _length_code[lc];
            send_code(s, code+LITERALS+1, ltree); /* send the length code */
            extra = extra_lbits[code];
            if (extra != 0) {
                lc -= base_length[code];
                send_bits(s, lc, extra);       /* send the extra length bits */
            }
            dist--; /* dist is now the match distance - 1 */
            code = d_code(dist);
            Assert (code < D_CODES, "bad d_code");

            send_code(s, code, dtree);       /* send the distance code */
            extra = extra_dbits[code];
            if (extra != 0) {
                dist -= (unsigned)base_dist[code];
                send_bits(s, dist, extra);   /* send the extra distance bits */
            }
        } /* literal or match pair ? */

        /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
        Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
               "pendingBuf overflow");

    } while (lx < s->last_lit);

    send_code(s, END_BLOCK, ltree);
}

/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "black list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */
local int detect_data_type(s)
    deflate_state *s;
{
    /* black_mask is the bit mask of black-listed bytes
     * set bits 0..6, 14..25, and 28..31
     * 0xf3ffc07f = binary 11110011111111111100000001111111
     */
    unsigned long black_mask = 0xf3ffc07fUL;
    int n;

    /* Check for non-textual ("black-listed") bytes. */
    for (n = 0; n <= 31; n++, black_mask >>= 1)
        if ((black_mask & 1) && (s->dyn_ltree[n].Freq != 0))
            return Z_BINARY;

    /* Check for textual ("white-listed") bytes. */
    if (s->dyn_ltree[9].Freq != 0 || s->dyn_ltree[10].Freq != 0
            || s->dyn_ltree[13].Freq != 0)
        return Z_TEXT;
    for (n = 32; n < LITERALS; n++)
        if (s->dyn_ltree[n].Freq != 0)
            return Z_TEXT;

    /* There are no "black-listed" or "white-listed" bytes:
     * this stream either is empty or has tolerated ("gray-listed") bytes only.
     */
    return Z_BINARY;
}

/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
local unsigned bi_reverse(code, len)
    unsigned code; /* the value to invert */
    int len;       /* its bit length */
{
    register unsigned res = 0;
    do {
        res |= code & 1;
        code >>= 1, res <<= 1;
    } while (--len > 0);
    return res >> 1;
}

/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
local void bi_flush(s)
    deflate_state *s;
{
    if (s->bi_valid == 16) {
        put_short(s, s->bi_buf);
        s->bi_buf = 0;
        s->bi_valid = 0;
    } else if (s->bi_valid >= 8) {
        put_byte(s, (Byte)s->bi_buf);
        s->bi_buf >>= 8;
        s->bi_valid -= 8;
    }
}

/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
local void bi_windup(s)
    deflate_state *s;
{
    if (s->bi_valid > 8) {
        put_short(s, s->bi_buf);
    } else if (s->bi_valid > 0) {
        put_byte(s, (Byte)s->bi_buf);
    }
    s->bi_buf = 0;
    s->bi_valid = 0;
#ifdef ZLIB_DEBUG
    s->bits_sent = (s->bits_sent+7) & ~7;
#endif
}

```

`efiXloader/3rd/uefitool/common/zlib/trees.h`:

```h
/* header created automatically with -DGEN_TREES_H */

local const ct_data static_ltree[L_CODES+2] = {
{{ 12},{  8}}, {{140},{  8}}, {{ 76},{  8}}, {{204},{  8}}, {{ 44},{  8}},
{{172},{  8}}, {{108},{  8}}, {{236},{  8}}, {{ 28},{  8}}, {{156},{  8}},
{{ 92},{  8}}, {{220},{  8}}, {{ 60},{  8}}, {{188},{  8}}, {{124},{  8}},
{{252},{  8}}, {{  2},{  8}}, {{130},{  8}}, {{ 66},{  8}}, {{194},{  8}},
{{ 34},{  8}}, {{162},{  8}}, {{ 98},{  8}}, {{226},{  8}}, {{ 18},{  8}},
{{146},{  8}}, {{ 82},{  8}}, {{210},{  8}}, {{ 50},{  8}}, {{178},{  8}},
{{114},{  8}}, {{242},{  8}}, {{ 10},{  8}}, {{138},{  8}}, {{ 74},{  8}},
{{202},{  8}}, {{ 42},{  8}}, {{170},{  8}}, {{106},{  8}}, {{234},{  8}},
{{ 26},{  8}}, {{154},{  8}}, {{ 90},{  8}}, {{218},{  8}}, {{ 58},{  8}},
{{186},{  8}}, {{122},{  8}}, {{250},{  8}}, {{  6},{  8}}, {{134},{  8}},
{{ 70},{  8}}, {{198},{  8}}, {{ 38},{  8}}, {{166},{  8}}, {{102},{  8}},
{{230},{  8}}, {{ 22},{  8}}, {{150},{  8}}, {{ 86},{  8}}, {{214},{  8}},
{{ 54},{  8}}, {{182},{  8}}, {{118},{  8}}, {{246},{  8}}, {{ 14},{  8}},
{{142},{  8}}, {{ 78},{  8}}, {{206},{  8}}, {{ 46},{  8}}, {{174},{  8}},
{{110},{  8}}, {{238},{  8}}, {{ 30},{  8}}, {{158},{  8}}, {{ 94},{  8}},
{{222},{  8}}, {{ 62},{  8}}, {{190},{  8}}, {{126},{  8}}, {{254},{  8}},
{{  1},{  8}}, {{129},{  8}}, {{ 65},{  8}}, {{193},{  8}}, {{ 33},{  8}},
{{161},{  8}}, {{ 97},{  8}}, {{225},{  8}}, {{ 17},{  8}}, {{145},{  8}},
{{ 81},{  8}}, {{209},{  8}}, {{ 49},{  8}}, {{177},{  8}}, {{113},{  8}},
{{241},{  8}}, {{  9},{  8}}, {{137},{  8}}, {{ 73},{  8}}, {{201},{  8}},
{{ 41},{  8}}, {{169},{  8}}, {{105},{  8}}, {{233},{  8}}, {{ 25},{  8}},
{{153},{  8}}, {{ 89},{  8}}, {{217},{  8}}, {{ 57},{  8}}, {{185},{  8}},
{{121},{  8}}, {{249},{  8}}, {{  5},{  8}}, {{133},{  8}}, {{ 69},{  8}},
{{197},{  8}}, {{ 37},{  8}}, {{165},{  8}}, {{101},{  8}}, {{229},{  8}},
{{ 21},{  8}}, {{149},{  8}}, {{ 85},{  8}}, {{213},{  8}}, {{ 53},{  8}},
{{181},{  8}}, {{117},{  8}}, {{245},{  8}}, {{ 13},{  8}}, {{141},{  8}},
{{ 77},{  8}}, {{205},{  8}}, {{ 45},{  8}}, {{173},{  8}}, {{109},{  8}},
{{237},{  8}}, {{ 29},{  8}}, {{157},{  8}}, {{ 93},{  8}}, {{221},{  8}},
{{ 61},{  8}}, {{189},{  8}}, {{125},{  8}}, {{253},{  8}}, {{ 19},{  9}},
{{275},{  9}}, {{147},{  9}}, {{403},{  9}}, {{ 83},{  9}}, {{339},{  9}},
{{211},{  9}}, {{467},{  9}}, {{ 51},{  9}}, {{307},{  9}}, {{179},{  9}},
{{435},{  9}}, {{115},{  9}}, {{371},{  9}}, {{243},{  9}}, {{499},{  9}},
{{ 11},{  9}}, {{267},{  9}}, {{139},{  9}}, {{395},{  9}}, {{ 75},{  9}},
{{331},{  9}}, {{203},{  9}}, {{459},{  9}}, {{ 43},{  9}}, {{299},{  9}},
{{171},{  9}}, {{427},{  9}}, {{107},{  9}}, {{363},{  9}}, {{235},{  9}},
{{491},{  9}}, {{ 27},{  9}}, {{283},{  9}}, {{155},{  9}}, {{411},{  9}},
{{ 91},{  9}}, {{347},{  9}}, {{219},{  9}}, {{475},{  9}}, {{ 59},{  9}},
{{315},{  9}}, {{187},{  9}}, {{443},{  9}}, {{123},{  9}}, {{379},{  9}},
{{251},{  9}}, {{507},{  9}}, {{  7},{  9}}, {{263},{  9}}, {{135},{  9}},
{{391},{  9}}, {{ 71},{  9}}, {{327},{  9}}, {{199},{  9}}, {{455},{  9}},
{{ 39},{  9}}, {{295},{  9}}, {{167},{  9}}, {{423},{  9}}, {{103},{  9}},
{{359},{  9}}, {{231},{  9}}, {{487},{  9}}, {{ 23},{  9}}, {{279},{  9}},
{{151},{  9}}, {{407},{  9}}, {{ 87},{  9}}, {{343},{  9}}, {{215},{  9}},
{{471},{  9}}, {{ 55},{  9}}, {{311},{  9}}, {{183},{  9}}, {{439},{  9}},
{{119},{  9}}, {{375},{  9}}, {{247},{  9}}, {{503},{  9}}, {{ 15},{  9}},
{{271},{  9}}, {{143},{  9}}, {{399},{  9}}, {{ 79},{  9}}, {{335},{  9}},
{{207},{  9}}, {{463},{  9}}, {{ 47},{  9}}, {{303},{  9}}, {{175},{  9}},
{{431},{  9}}, {{111},{  9}}, {{367},{  9}}, {{239},{  9}}, {{495},{  9}},
{{ 31},{  9}}, {{287},{  9}}, {{159},{  9}}, {{415},{  9}}, {{ 95},{  9}},
{{351},{  9}}, {{223},{  9}}, {{479},{  9}}, {{ 63},{  9}}, {{319},{  9}},
{{191},{  9}}, {{447},{  9}}, {{127},{  9}}, {{383},{  9}}, {{255},{  9}},
{{511},{  9}}, {{  0},{  7}}, {{ 64},{  7}}, {{ 32},{  7}}, {{ 96},{  7}},
{{ 16},{  7}}, {{ 80},{  7}}, {{ 48},{  7}}, {{112},{  7}}, {{  8},{  7}},
{{ 72},{  7}}, {{ 40},{  7}}, {{104},{  7}}, {{ 24},{  7}}, {{ 88},{  7}},
{{ 56},{  7}}, {{120},{  7}}, {{  4},{  7}}, {{ 68},{  7}}, {{ 36},{  7}},
{{100},{  7}}, {{ 20},{  7}}, {{ 84},{  7}}, {{ 52},{  7}}, {{116},{  7}},
{{  3},{  8}}, {{131},{  8}}, {{ 67},{  8}}, {{195},{  8}}, {{ 35},{  8}},
{{163},{  8}}, {{ 99},{  8}}, {{227},{  8}}
};

local const ct_data static_dtree[D_CODES] = {
{{ 0},{ 5}}, {{16},{ 5}}, {{ 8},{ 5}}, {{24},{ 5}}, {{ 4},{ 5}},
{{20},{ 5}}, {{12},{ 5}}, {{28},{ 5}}, {{ 2},{ 5}}, {{18},{ 5}},
{{10},{ 5}}, {{26},{ 5}}, {{ 6},{ 5}}, {{22},{ 5}}, {{14},{ 5}},
{{30},{ 5}}, {{ 1},{ 5}}, {{17},{ 5}}, {{ 9},{ 5}}, {{25},{ 5}},
{{ 5},{ 5}}, {{21},{ 5}}, {{13},{ 5}}, {{29},{ 5}}, {{ 3},{ 5}},
{{19},{ 5}}, {{11},{ 5}}, {{27},{ 5}}, {{ 7},{ 5}}, {{23},{ 5}}
};

const uch ZLIB_INTERNAL _dist_code[DIST_CODE_LEN] = {
 0,  1,  2,  3,  4,  4,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  8,
 8,  8,  8,  8,  9,  9,  9,  9,  9,  9,  9,  9, 10, 10, 10, 10, 10, 10, 10, 10,
10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13,
13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15,
15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,  0,  0, 16, 17,
18, 18, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22,
23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27,
27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29
};

const uch ZLIB_INTERNAL _length_code[MAX_MATCH-MIN_MATCH+1]= {
 0,  1,  2,  3,  4,  5,  6,  7,  8,  8,  9,  9, 10, 10, 11, 11, 12, 12, 12, 12,
13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16,
17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19,
19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22,
22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23,
23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26,
26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28
};

local const int base_length[LENGTH_CODES] = {
0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56,
64, 80, 96, 112, 128, 160, 192, 224, 0
};

local const int base_dist[D_CODES] = {
    0,     1,     2,     3,     4,     6,     8,    12,    16,    24,
   32,    48,    64,    96,   128,   192,   256,   384,   512,   768,
 1024,  1536,  2048,  3072,  4096,  6144,  8192, 12288, 16384, 24576
};


```

`efiXloader/3rd/uefitool/common/zlib/uncompr.c`:

```c
/* uncompr.c -- decompress a memory buffer
 * Copyright (C) 1995-2003, 2010, 2014, 2016 Jean-loup Gailly, Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/* @(#) $Id$ */

#define ZLIB_INTERNAL
#include "zlib.h"

/* ===========================================================================
     Decompresses the source buffer into the destination buffer.  *sourceLen is
   the byte length of the source buffer. Upon entry, *destLen is the total size
   of the destination buffer, which must be large enough to hold the entire
   uncompressed data. (The size of the uncompressed data must have been saved
   previously by the compressor and transmitted to the decompressor by some
   mechanism outside the scope of this compression library.) Upon exit,
   *destLen is the size of the decompressed data and *sourceLen is the number
   of source bytes consumed. Upon return, source + *sourceLen points to the
   first unused input byte.

     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_BUF_ERROR if there was not enough room in the output buffer, or
   Z_DATA_ERROR if the input data was corrupted, including if the input data is
   an incomplete zlib stream.
*/
int ZEXPORT uncompress2 (dest, destLen, source, sourceLen)
    Bytef *dest;
    uLongf *destLen;
    const Bytef *source;
    uLong *sourceLen;
{
    z_stream stream;
    int err;
    const uInt max = (uInt)-1;
    uLong len, left;
    Byte buf[1];    /* for detection of incomplete stream when *destLen == 0 */

    len = *sourceLen;
    if (*destLen) {
        left = *destLen;
        *destLen = 0;
    }
    else {
        left = 1;
        dest = buf;
    }

    stream.next_in = (z_const Bytef *)source;
    stream.avail_in = 0;
    stream.zalloc = (alloc_func)0;
    stream.zfree = (free_func)0;
    stream.opaque = (voidpf)0;

    err = inflateInit(&stream);
    if (err != Z_OK) return err;

    stream.next_out = dest;
    stream.avail_out = 0;

    do {
        if (stream.avail_out == 0) {
            stream.avail_out = left > (uLong)max ? max : (uInt)left;
            left -= stream.avail_out;
        }
        if (stream.avail_in == 0) {
            stream.avail_in = len > (uLong)max ? max : (uInt)len;
            len -= stream.avail_in;
        }
        err = inflate(&stream, Z_NO_FLUSH);
    } while (err == Z_OK);

    *sourceLen -= len + stream.avail_in;
    if (dest != buf)
        *destLen = stream.total_out;
    else if (stream.total_out && err == Z_BUF_ERROR)
        left = 1;

    inflateEnd(&stream);
    return err == Z_STREAM_END ? Z_OK :
           err == Z_NEED_DICT ? Z_DATA_ERROR  :
           err == Z_BUF_ERROR && left + stream.avail_out ? Z_DATA_ERROR :
           err;
}

int ZEXPORT uncompress (dest, destLen, source, sourceLen)
    Bytef *dest;
    uLongf *destLen;
    const Bytef *source;
    uLong sourceLen;
{
    return uncompress2(dest, destLen, source, &sourceLen);
}

```

`efiXloader/3rd/uefitool/common/zlib/zconf.h`:

```h
/* zconf.h -- configuration of the zlib compression library
 * Copyright (C) 1995-2016 Jean-loup Gailly, Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/* @(#) $Id$ */

#ifndef ZCONF_H
#define ZCONF_H

/*
 * If you *really* need a unique prefix for all types and library functions,
 * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
 * Even better than compiling with -DZ_PREFIX would be to use configure to set
 * this permanently in zconf.h using "./configure --zprefix".
 */
#ifdef Z_PREFIX     /* may be set to #if 1 by ./configure */
#  define Z_PREFIX_SET

/* all linked symbols and init macros */
#  define _dist_code            z__dist_code
#  define _length_code          z__length_code
#  define _tr_align             z__tr_align
#  define _tr_flush_bits        z__tr_flush_bits
#  define _tr_flush_block       z__tr_flush_block
#  define _tr_init              z__tr_init
#  define _tr_stored_block      z__tr_stored_block
#  define _tr_tally             z__tr_tally
#  define adler32               z_adler32
#  define adler32_combine       z_adler32_combine
#  define adler32_combine64     z_adler32_combine64
#  define adler32_z             z_adler32_z
#  ifndef Z_SOLO
#    define compress              z_compress
#    define compress2             z_compress2
#    define compressBound         z_compressBound
#  endif
#  define crc32                 z_crc32
#  define crc32_combine         z_crc32_combine
#  define crc32_combine64       z_crc32_combine64
#  define crc32_z               z_crc32_z
#  define deflate               z_deflate
#  define deflateBound          z_deflateBound
#  define deflateCopy           z_deflateCopy
#  define deflateEnd            z_deflateEnd
#  define deflateGetDictionary  z_deflateGetDictionary
#  define deflateInit           z_deflateInit
#  define deflateInit2          z_deflateInit2
#  define deflateInit2_         z_deflateInit2_
#  define deflateInit_          z_deflateInit_
#  define deflateParams         z_deflateParams
#  define deflatePending        z_deflatePending
#  define deflatePrime          z_deflatePrime
#  define deflateReset          z_deflateReset
#  define deflateResetKeep      z_deflateResetKeep
#  define deflateSetDictionary  z_deflateSetDictionary
#  define deflateSetHeader      z_deflateSetHeader
#  define deflateTune           z_deflateTune
#  define deflate_copyright     z_deflate_copyright
#  define get_crc_table         z_get_crc_table
#  ifndef Z_SOLO
#    define gz_error              z_gz_error
#    define gz_intmax             z_gz_intmax
#    define gz_strwinerror        z_gz_strwinerror
#    define gzbuffer              z_gzbuffer
#    define gzclearerr            z_gzclearerr
#    define gzclose               z_gzclose
#    define gzclose_r             z_gzclose_r
#    define gzclose_w             z_gzclose_w
#    define gzdirect              z_gzdirect
#    define gzdopen               z_gzdopen
#    define gzeof                 z_gzeof
#    define gzerror               z_gzerror
#    define gzflush               z_gzflush
#    define gzfread               z_gzfread
#    define gzfwrite              z_gzfwrite
#    define gzgetc                z_gzgetc
#    define gzgetc_               z_gzgetc_
#    define gzgets                z_gzgets
#    define gzoffset              z_gzoffset
#    define gzoffset64            z_gzoffset64
#    define gzopen                z_gzopen
#    define gzopen64              z_gzopen64
#    ifdef _WIN32
#      define gzopen_w              z_gzopen_w
#    endif
#    define gzprintf              z_gzprintf
#    define gzputc                z_gzputc
#    define gzputs                z_gzputs
#    define gzread                z_gzread
#    define gzrewind              z_gzrewind
#    define gzseek                z_gzseek
#    define gzseek64              z_gzseek64
#    define gzsetparams           z_gzsetparams
#    define gztell                z_gztell
#    define gztell64              z_gztell64
#    define gzungetc              z_gzungetc
#    define gzvprintf             z_gzvprintf
#    define gzwrite               z_gzwrite
#  endif
#  define inflate               z_inflate
#  define inflateBack           z_inflateBack
#  define inflateBackEnd        z_inflateBackEnd
#  define inflateBackInit       z_inflateBackInit
#  define inflateBackInit_      z_inflateBackInit_
#  define inflateCodesUsed      z_inflateCodesUsed
#  define inflateCopy           z_inflateCopy
#  define inflateEnd            z_inflateEnd
#  define inflateGetDictionary  z_inflateGetDictionary
#  define inflateGetHeader      z_inflateGetHeader
#  define inflateInit           z_inflateInit
#  define inflateInit2          z_inflateInit2
#  define inflateInit2_         z_inflateInit2_
#  define inflateInit_          z_inflateInit_
#  define inflateMark           z_inflateMark
#  define inflatePrime          z_inflatePrime
#  define inflateReset          z_inflateReset
#  define inflateReset2         z_inflateReset2
#  define inflateResetKeep      z_inflateResetKeep
#  define inflateSetDictionary  z_inflateSetDictionary
#  define inflateSync           z_inflateSync
#  define inflateSyncPoint      z_inflateSyncPoint
#  define inflateUndermine      z_inflateUndermine
#  define inflateValidate       z_inflateValidate
#  define inflate_copyright     z_inflate_copyright
#  define inflate_fast          z_inflate_fast
#  define inflate_table         z_inflate_table
#  ifndef Z_SOLO
#    define uncompress            z_uncompress
#    define uncompress2           z_uncompress2
#  endif
#  define zError                z_zError
#  ifndef Z_SOLO
#    define zcalloc               z_zcalloc
#    define zcfree                z_zcfree
#  endif
#  define zlibCompileFlags      z_zlibCompileFlags
#  define zlibVersion           z_zlibVersion

/* all zlib typedefs in zlib.h and zconf.h */
#  define Byte                  z_Byte
#  define Bytef                 z_Bytef
#  define alloc_func            z_alloc_func
#  define charf                 z_charf
#  define free_func             z_free_func
#  ifndef Z_SOLO
#    define gzFile                z_gzFile
#  endif
#  define gz_header             z_gz_header
#  define gz_headerp            z_gz_headerp
#  define in_func               z_in_func
#  define intf                  z_intf
#  define out_func              z_out_func
#  define uInt                  z_uInt
#  define uIntf                 z_uIntf
#  define uLong                 z_uLong
#  define uLongf                z_uLongf
#  define voidp                 z_voidp
#  define voidpc                z_voidpc
#  define voidpf                z_voidpf

/* all zlib structs in zlib.h and zconf.h */
#  define gz_header_s           z_gz_header_s
#  define internal_state        z_internal_state

#endif

#if defined(__MSDOS__) && !defined(MSDOS)
#  define MSDOS
#endif
#if (defined(OS_2) || defined(__OS2__)) && !defined(OS2)
#  define OS2
#endif
#if defined(_WINDOWS) && !defined(WINDOWS)
#  define WINDOWS
#endif
#if defined(_WIN32) || defined(_WIN32_WCE) || defined(__WIN32__)
#  ifndef WIN32
#    define WIN32
#  endif
#endif
#if (defined(MSDOS) || defined(OS2) || defined(WINDOWS)) && !defined(WIN32)
#  if !defined(__GNUC__) && !defined(__FLAT__) && !defined(__386__)
#    ifndef SYS16BIT
#      define SYS16BIT
#    endif
#  endif
#endif

/*
 * Compile with -DMAXSEG_64K if the alloc function cannot allocate more
 * than 64k bytes at a time (needed on systems with 16-bit int).
 */
#ifdef SYS16BIT
#  define MAXSEG_64K
#endif
#ifdef MSDOS
#  define UNALIGNED_OK
#endif

#ifdef __STDC_VERSION__
#  ifndef STDC
#    define STDC
#  endif
#  if __STDC_VERSION__ >= 199901L
#    ifndef STDC99
#      define STDC99
#    endif
#  endif
#endif
#if !defined(STDC) && (defined(__STDC__) || defined(__cplusplus))
#  define STDC
#endif
#if !defined(STDC) && (defined(__GNUC__) || defined(__BORLANDC__))
#  define STDC
#endif
#if !defined(STDC) && (defined(MSDOS) || defined(WINDOWS) || defined(WIN32))
#  define STDC
#endif
#if !defined(STDC) && (defined(OS2) || defined(__HOS_AIX__))
#  define STDC
#endif

#if defined(__OS400__) && !defined(STDC)    /* iSeries (formerly AS/400). */
#  define STDC
#endif

#ifndef STDC
#  ifndef const /* cannot use !defined(STDC) && !defined(const) on Mac */
#    define const       /* note: need a more gentle solution here */
#  endif
#endif

#if defined(ZLIB_CONST) && !defined(z_const)
#  define z_const const
#else
#  define z_const
#endif

#ifdef Z_SOLO
   typedef unsigned long z_size_t;
#else
#  define z_longlong long long
#  if defined(NO_SIZE_T)
     typedef unsigned NO_SIZE_T z_size_t;
#  elif defined(STDC)
#    include <stddef.h>
     typedef size_t z_size_t;
#  else
     typedef unsigned long z_size_t;
#  endif
#  undef z_longlong
#endif

/* Maximum value for memLevel in deflateInit2 */
#ifndef MAX_MEM_LEVEL
#  ifdef MAXSEG_64K
#    define MAX_MEM_LEVEL 8
#  else
#    define MAX_MEM_LEVEL 9
#  endif
#endif

/* Maximum value for windowBits in deflateInit2 and inflateInit2.
 * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files
 * created by gzip. (Files created by minigzip can still be extracted by
 * gzip.)
 */
#ifndef MAX_WBITS
#  define MAX_WBITS   15 /* 32K LZ77 window */
#endif

/* The memory requirements for deflate are (in bytes):
            (1 << (windowBits+2)) +  (1 << (memLevel+9))
 that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
 plus a few kilobytes for small objects. For example, if you want to reduce
 the default memory requirements from 256K to 128K, compile with
     make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
 Of course this will generally degrade compression (there's no free lunch).

   The memory requirements for inflate are (in bytes) 1 << windowBits
 that is, 32K for windowBits=15 (default value) plus about 7 kilobytes
 for small objects.
*/

                        /* Type declarations */

#ifndef OF /* function prototypes */
#  ifdef STDC
#    define OF(args)  args
#  else
#    define OF(args)  ()
#  endif
#endif

#ifndef Z_ARG /* function prototypes for stdarg */
#  if defined(STDC) || defined(Z_HAVE_STDARG_H)
#    define Z_ARG(args)  args
#  else
#    define Z_ARG(args)  ()
#  endif
#endif

/* The following definitions for FAR are needed only for MSDOS mixed
 * model programming (small or medium model with some far allocations).
 * This was tested only with MSC; for other MSDOS compilers you may have
 * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
 * just define FAR to be empty.
 */
#ifdef SYS16BIT
#  if defined(M_I86SM) || defined(M_I86MM)
     /* MSC small or medium model */
#    define SMALL_MEDIUM
#    ifdef _MSC_VER
#      define FAR _far
#    else
#      define FAR far
#    endif
#  endif
#  if (defined(__SMALL__) || defined(__MEDIUM__))
     /* Turbo C small or medium model */
#    define SMALL_MEDIUM
#    ifdef __BORLANDC__
#      define FAR _far
#    else
#      define FAR far
#    endif
#  endif
#endif

#if defined(WINDOWS) || defined(WIN32)
   /* If building or using zlib as a DLL, define ZLIB_DLL.
    * This is not mandatory, but it offers a little performance increase.
    */
#  ifdef ZLIB_DLL
#    if defined(WIN32) && (!defined(__BORLANDC__) || (__BORLANDC__ >= 0x500))
#      ifdef ZLIB_INTERNAL
#        define ZEXTERN extern __declspec(dllexport)
#      else
#        define ZEXTERN extern __declspec(dllimport)
#      endif
#    endif
#  endif  /* ZLIB_DLL */
   /* If building or using zlib with the WINAPI/WINAPIV calling convention,
    * define ZLIB_WINAPI.
    * Caution: the standard ZLIB1.DLL is NOT compiled using ZLIB_WINAPI.
    */
#  ifdef ZLIB_WINAPI
#    ifdef FAR
#      undef FAR
#    endif
#    include <windows.h>
     /* No need for _export, use ZLIB.DEF instead. */
     /* For complete Windows compatibility, use WINAPI, not __stdcall. */
#    define ZEXPORT WINAPI
#    ifdef WIN32
#      define ZEXPORTVA WINAPIV
#    else
#      define ZEXPORTVA FAR CDECL
#    endif
#  endif
#endif

#if defined (__BEOS__)
#  ifdef ZLIB_DLL
#    ifdef ZLIB_INTERNAL
#      define ZEXPORT   __declspec(dllexport)
#      define ZEXPORTVA __declspec(dllexport)
#    else
#      define ZEXPORT   __declspec(dllimport)
#      define ZEXPORTVA __declspec(dllimport)
#    endif
#  endif
#endif

#ifndef ZEXTERN
#  define ZEXTERN extern
#endif
#ifndef ZEXPORT
#  define ZEXPORT
#endif
#ifndef ZEXPORTVA
#  define ZEXPORTVA
#endif

#ifndef FAR
#  define FAR
#endif

#if !defined(__MACTYPES__)
typedef unsigned char  Byte;  /* 8 bits */
#endif
typedef unsigned int   uInt;  /* 16 bits or more */
typedef unsigned long  uLong; /* 32 bits or more */

#ifdef SMALL_MEDIUM
   /* Borland C/C++ and some old MSC versions ignore FAR inside typedef */
#  define Bytef Byte FAR
#else
   typedef Byte  FAR Bytef;
#endif
typedef char  FAR charf;
typedef int   FAR intf;
typedef uInt  FAR uIntf;
typedef uLong FAR uLongf;

#ifdef STDC
   typedef void const *voidpc;
   typedef void FAR   *voidpf;
   typedef void       *voidp;
#else
   typedef Byte const *voidpc;
   typedef Byte FAR   *voidpf;
   typedef Byte       *voidp;
#endif

#if !defined(Z_U4) && !defined(Z_SOLO) && defined(STDC)
#  include <limits.h>
#  if (UINT_MAX == 0xffffffffUL)
#    define Z_U4 unsigned
#  elif (ULONG_MAX == 0xffffffffUL)
#    define Z_U4 unsigned long
#  elif (USHRT_MAX == 0xffffffffUL)
#    define Z_U4 unsigned short
#  endif
#endif

#ifdef Z_U4
   typedef Z_U4 z_crc_t;
#else
   typedef unsigned long z_crc_t;
#endif

#ifdef HAVE_UNISTD_H    /* may be set to #if 1 by ./configure */
#  define Z_HAVE_UNISTD_H
#endif

#ifdef HAVE_STDARG_H    /* may be set to #if 1 by ./configure */
#  define Z_HAVE_STDARG_H
#endif

#ifdef STDC
#  ifndef Z_SOLO
#    include <sys/types.h>      /* for off_t */
#  endif
#endif

#if defined(STDC) || defined(Z_HAVE_STDARG_H)
#  ifndef Z_SOLO
#    include <stdarg.h>         /* for va_list */
#  endif
#endif

#ifdef _WIN32
#  ifndef Z_SOLO
#    include <stddef.h>         /* for wchar_t */
#  endif
#endif

/* a little trick to accommodate both "#define _LARGEFILE64_SOURCE" and
 * "#define _LARGEFILE64_SOURCE 1" as requesting 64-bit operations, (even
 * though the former does not conform to the LFS document), but considering
 * both "#undef _LARGEFILE64_SOURCE" and "#define _LARGEFILE64_SOURCE 0" as
 * equivalently requesting no 64-bit operations
 */
#if defined(_LARGEFILE64_SOURCE) && -_LARGEFILE64_SOURCE - -1 == 1
#  undef _LARGEFILE64_SOURCE
#endif

#if defined(__WATCOMC__) && !defined(Z_HAVE_UNISTD_H)
#  define Z_HAVE_UNISTD_H
#endif
#ifndef Z_SOLO
#  if defined(Z_HAVE_UNISTD_H) || defined(_LARGEFILE64_SOURCE)
#    include <unistd.h>         /* for SEEK_*, off_t, and _LFS64_LARGEFILE */
#    ifdef VMS
#      include <unixio.h>       /* for off_t */
#    endif
#    ifndef z_off_t
#      define z_off_t off_t
#    endif
#  endif
#endif

#if defined(_LFS64_LARGEFILE) && _LFS64_LARGEFILE-0
#  define Z_LFS64
#endif

#if defined(_LARGEFILE64_SOURCE) && defined(Z_LFS64)
#  define Z_LARGE64
#endif

#if defined(_FILE_OFFSET_BITS) && _FILE_OFFSET_BITS-0 == 64 && defined(Z_LFS64)
#  define Z_WANT64
#endif

#if !defined(SEEK_SET) && !defined(Z_SOLO)
#  define SEEK_SET        0       /* Seek from beginning of file.  */
#  define SEEK_CUR        1       /* Seek from current position.  */
#  define SEEK_END        2       /* Set file pointer to EOF plus "offset" */
#endif

#ifndef z_off_t
#  define z_off_t long
#endif

#if !defined(_WIN32) && defined(Z_LARGE64)
#  define z_off64_t off64_t
#else
#  if defined(_WIN32) && !defined(__GNUC__) && !defined(Z_SOLO)
#    define z_off64_t __int64
#  else
#    define z_off64_t z_off_t
#  endif
#endif

/* MVS linker does not support external names larger than 8 bytes */
#if defined(__MVS__)
  #pragma map(deflateInit_,"DEIN")
  #pragma map(deflateInit2_,"DEIN2")
  #pragma map(deflateEnd,"DEEND")
  #pragma map(deflateBound,"DEBND")
  #pragma map(inflateInit_,"ININ")
  #pragma map(inflateInit2_,"ININ2")
  #pragma map(inflateEnd,"INEND")
  #pragma map(inflateSync,"INSY")
  #pragma map(inflateSetDictionary,"INSEDI")
  #pragma map(compressBound,"CMBND")
  #pragma map(inflate_table,"INTABL")
  #pragma map(inflate_fast,"INFA")
  #pragma map(inflate_copyright,"INCOPY")
#endif

#endif /* ZCONF_H */

```

`efiXloader/3rd/uefitool/common/zlib/zlib.h`:

```h
/* zlib.h -- interface of the 'zlib' general purpose compression library
  version 1.2.11, January 15th, 2017

  Copyright (C) 1995-2017 Jean-loup Gailly and Mark Adler

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jean-loup Gailly        Mark Adler
  jloup@gzip.org          madler@alumni.caltech.edu


  The data format used by the zlib library is described by RFCs (Request for
  Comments) 1950 to 1952 in the files http://tools.ietf.org/html/rfc1950
  (zlib format), rfc1951 (deflate format) and rfc1952 (gzip format).
*/

#ifndef ZLIB_H
#define ZLIB_H

#include "zconf.h"

#ifdef __cplusplus
extern "C" {
#endif

#define ZLIB_VERSION "1.2.11"
#define ZLIB_VERNUM 0x12b0
#define ZLIB_VER_MAJOR 1
#define ZLIB_VER_MINOR 2
#define ZLIB_VER_REVISION 11
#define ZLIB_VER_SUBREVISION 0

/*
    The 'zlib' compression library provides in-memory compression and
  decompression functions, including integrity checks of the uncompressed data.
  This version of the library supports only one compression method (deflation)
  but other algorithms will be added later and will have the same stream
  interface.

    Compression can be done in a single step if the buffers are large enough,
  or can be done by repeated calls of the compression function.  In the latter
  case, the application must provide more input and/or consume the output
  (providing more output space) before each call.

    The compressed data format used by default by the in-memory functions is
  the zlib format, which is a zlib wrapper documented in RFC 1950, wrapped
  around a deflate stream, which is itself documented in RFC 1951.

    The library also supports reading and writing files in gzip (.gz) format
  with an interface similar to that of stdio using the functions that start
  with "gz".  The gzip format is different from the zlib format.  gzip is a
  gzip wrapper, documented in RFC 1952, wrapped around a deflate stream.

    This library can optionally read and write gzip and raw deflate streams in
  memory as well.

    The zlib format was designed to be compact and fast for use in memory
  and on communications channels.  The gzip format was designed for single-
  file compression on file systems, has a larger header than zlib to maintain
  directory information, and uses a different, slower check method than zlib.

    The library does not install any signal handler.  The decoder checks
  the consistency of the compressed data, so the library should never crash
  even in the case of corrupted input.
*/

typedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));
typedef void   (*free_func)  OF((voidpf opaque, voidpf address));

struct internal_state;

typedef struct z_stream_s {
    z_const Bytef *next_in;     /* next input byte */
    uInt     avail_in;  /* number of bytes available at next_in */
    uLong    total_in;  /* total number of input bytes read so far */

    Bytef    *next_out; /* next output byte will go here */
    uInt     avail_out; /* remaining free space at next_out */
    uLong    total_out; /* total number of bytes output so far */

    z_const char *msg;  /* last error message, NULL if no error */
    struct internal_state FAR *state; /* not visible by applications */

    alloc_func zalloc;  /* used to allocate the internal state */
    free_func  zfree;   /* used to free the internal state */
    voidpf     opaque;  /* private data object passed to zalloc and zfree */

    int     data_type;  /* best guess about the data type: binary or text
                           for deflate, or the decoding state for inflate */
    uLong   adler;      /* Adler-32 or CRC-32 value of the uncompressed data */
    uLong   reserved;   /* reserved for future use */
} z_stream;

typedef z_stream FAR *z_streamp;

/*
     gzip header information passed to and from zlib routines.  See RFC 1952
  for more details on the meanings of these fields.
*/
typedef struct gz_header_s {
    int     text;       /* true if compressed data believed to be text */
    uLong   time;       /* modification time */
    int     xflags;     /* extra flags (not used when writing a gzip file) */
    int     os;         /* operating system */
    Bytef   *extra;     /* pointer to extra field or Z_NULL if none */
    uInt    extra_len;  /* extra field length (valid if extra != Z_NULL) */
    uInt    extra_max;  /* space at extra (only when reading header) */
    Bytef   *name;      /* pointer to zero-terminated file name or Z_NULL */
    uInt    name_max;   /* space at name (only when reading header) */
    Bytef   *comment;   /* pointer to zero-terminated comment or Z_NULL */
    uInt    comm_max;   /* space at comment (only when reading header) */
    int     hcrc;       /* true if there was or will be a header crc */
    int     done;       /* true when done reading gzip header (not used
                           when writing a gzip file) */
} gz_header;

typedef gz_header FAR *gz_headerp;

/*
     The application must update next_in and avail_in when avail_in has dropped
   to zero.  It must update next_out and avail_out when avail_out has dropped
   to zero.  The application must initialize zalloc, zfree and opaque before
   calling the init function.  All other fields are set by the compression
   library and must not be updated by the application.

     The opaque value provided by the application will be passed as the first
   parameter for calls of zalloc and zfree.  This can be useful for custom
   memory management.  The compression library attaches no meaning to the
   opaque value.

     zalloc must return Z_NULL if there is not enough memory for the object.
   If zlib is used in a multi-threaded application, zalloc and zfree must be
   thread safe.  In that case, zlib is thread-safe.  When zalloc and zfree are
   Z_NULL on entry to the initialization function, they are set to internal
   routines that use the standard library functions malloc() and free().

     On 16-bit systems, the functions zalloc and zfree must be able to allocate
   exactly 65536 bytes, but will not be required to allocate more than this if
   the symbol MAXSEG_64K is defined (see zconf.h).  WARNING: On MSDOS, pointers
   returned by zalloc for objects of exactly 65536 bytes *must* have their
   offset normalized to zero.  The default allocation function provided by this
   library ensures this (see zutil.c).  To reduce memory requirements and avoid
   any allocation of 64K objects, at the expense of compression ratio, compile
   the library with -DMAX_WBITS=14 (see zconf.h).

     The fields total_in and total_out can be used for statistics or progress
   reports.  After compression, total_in holds the total size of the
   uncompressed data and may be saved for use by the decompressor (particularly
   if the decompressor wants to decompress everything in a single step).
*/

                        /* constants */

#define Z_NO_FLUSH      0
#define Z_PARTIAL_FLUSH 1
#define Z_SYNC_FLUSH    2
#define Z_FULL_FLUSH    3
#define Z_FINISH        4
#define Z_BLOCK         5
#define Z_TREES         6
/* Allowed flush values; see deflate() and inflate() below for details */

#define Z_OK            0
#define Z_STREAM_END    1
#define Z_NEED_DICT     2
#define Z_ERRNO        (-1)
#define Z_STREAM_ERROR (-2)
#define Z_DATA_ERROR   (-3)
#define Z_MEM_ERROR    (-4)
#define Z_BUF_ERROR    (-5)
#define Z_VERSION_ERROR (-6)
/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */

#define Z_NO_COMPRESSION         0
#define Z_BEST_SPEED             1
#define Z_BEST_COMPRESSION       9
#define Z_DEFAULT_COMPRESSION  (-1)
/* compression levels */

#define Z_FILTERED            1
#define Z_HUFFMAN_ONLY        2
#define Z_RLE                 3
#define Z_FIXED               4
#define Z_DEFAULT_STRATEGY    0
/* compression strategy; see deflateInit2() below for details */

#define Z_BINARY   0
#define Z_TEXT     1
#define Z_ASCII    Z_TEXT   /* for compatibility with 1.2.2 and earlier */
#define Z_UNKNOWN  2
/* Possible values of the data_type field for deflate() */

#define Z_DEFLATED   8
/* The deflate compression method (the only one supported in this version) */

#define Z_NULL  0  /* for initializing zalloc, zfree, opaque */

#define zlib_version zlibVersion()
/* for compatibility with versions < 1.0.2 */


                        /* basic functions */

ZEXTERN const char * ZEXPORT zlibVersion OF((void));
/* The application can compare zlibVersion and ZLIB_VERSION for consistency.
   If the first character differs, the library code actually used is not
   compatible with the zlib.h header file used by the application.  This check
   is automatically made by deflateInit and inflateInit.
 */

/*
ZEXTERN int ZEXPORT deflateInit OF((z_streamp strm, int level));

     Initializes the internal stream state for compression.  The fields
   zalloc, zfree and opaque must be initialized before by the caller.  If
   zalloc and zfree are set to Z_NULL, deflateInit updates them to use default
   allocation functions.

     The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:
   1 gives best speed, 9 gives best compression, 0 gives no compression at all
   (the input data is simply copied a block at a time).  Z_DEFAULT_COMPRESSION
   requests a default compromise between speed and compression (currently
   equivalent to level 6).

     deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_STREAM_ERROR if level is not a valid compression level, or
   Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible
   with the version assumed by the caller (ZLIB_VERSION).  msg is set to null
   if there is no error message.  deflateInit does not perform any compression:
   this will be done by deflate().
*/


ZEXTERN int ZEXPORT deflate OF((z_streamp strm, int flush));
/*
    deflate compresses as much data as possible, and stops when the input
  buffer becomes empty or the output buffer becomes full.  It may introduce
  some output latency (reading input without producing any output) except when
  forced to flush.

    The detailed semantics are as follows.  deflate performs one or both of the
  following actions:

  - Compress more input starting at next_in and update next_in and avail_in
    accordingly.  If not all input can be processed (because there is not
    enough room in the output buffer), next_in and avail_in are updated and
    processing will resume at this point for the next call of deflate().

  - Generate more output starting at next_out and update next_out and avail_out
    accordingly.  This action is forced if the parameter flush is non zero.
    Forcing flush frequently degrades the compression ratio, so this parameter
    should be set only when necessary.  Some output may be provided even if
    flush is zero.

    Before the call of deflate(), the application should ensure that at least
  one of the actions is possible, by providing more input and/or consuming more
  output, and updating avail_in or avail_out accordingly; avail_out should
  never be zero before the call.  The application can consume the compressed
  output when it wants, for example when the output buffer is full (avail_out
  == 0), or after each call of deflate().  If deflate returns Z_OK and with
  zero avail_out, it must be called again after making room in the output
  buffer because there might be more output pending. See deflatePending(),
  which can be used if desired to determine whether or not there is more ouput
  in that case.

    Normally the parameter flush is set to Z_NO_FLUSH, which allows deflate to
  decide how much data to accumulate before producing output, in order to
  maximize compression.

    If the parameter flush is set to Z_SYNC_FLUSH, all pending output is
  flushed to the output buffer and the output is aligned on a byte boundary, so
  that the decompressor can get all input data available so far.  (In
  particular avail_in is zero after the call if enough output space has been
  provided before the call.) Flushing may degrade compression for some
  compression algorithms and so it should be used only when necessary.  This
  completes the current deflate block and follows it with an empty stored block
  that is three bits plus filler bits to the next byte, followed by four bytes
  (00 00 ff ff).

    If flush is set to Z_PARTIAL_FLUSH, all pending output is flushed to the
  output buffer, but the output is not aligned to a byte boundary.  All of the
  input data so far will be available to the decompressor, as for Z_SYNC_FLUSH.
  This completes the current deflate block and follows it with an empty fixed
  codes block that is 10 bits long.  This assures that enough bytes are output
  in order for the decompressor to finish the block before the empty fixed
  codes block.

    If flush is set to Z_BLOCK, a deflate block is completed and emitted, as
  for Z_SYNC_FLUSH, but the output is not aligned on a byte boundary, and up to
  seven bits of the current block are held to be written as the next byte after
  the next deflate block is completed.  In this case, the decompressor may not
  be provided enough bits at this point in order to complete decompression of
  the data provided so far to the compressor.  It may need to wait for the next
  block to be emitted.  This is for advanced applications that need to control
  the emission of deflate blocks.

    If flush is set to Z_FULL_FLUSH, all output is flushed as with
  Z_SYNC_FLUSH, and the compression state is reset so that decompression can
  restart from this point if previous compressed data has been damaged or if
  random access is desired.  Using Z_FULL_FLUSH too often can seriously degrade
  compression.

    If deflate returns with avail_out == 0, this function must be called again
  with the same value of the flush parameter and more output space (updated
  avail_out), until the flush is complete (deflate returns with non-zero
  avail_out).  In the case of a Z_FULL_FLUSH or Z_SYNC_FLUSH, make sure that
  avail_out is greater than six to avoid repeated flush markers due to
  avail_out == 0 on return.

    If the parameter flush is set to Z_FINISH, pending input is processed,
  pending output is flushed and deflate returns with Z_STREAM_END if there was
  enough output space.  If deflate returns with Z_OK or Z_BUF_ERROR, this
  function must be called again with Z_FINISH and more output space (updated
  avail_out) but no more input data, until it returns with Z_STREAM_END or an
  error.  After deflate has returned Z_STREAM_END, the only possible operations
  on the stream are deflateReset or deflateEnd.

    Z_FINISH can be used in the first deflate call after deflateInit if all the
  compression is to be done in a single step.  In order to complete in one
  call, avail_out must be at least the value returned by deflateBound (see
  below).  Then deflate is guaranteed to return Z_STREAM_END.  If not enough
  output space is provided, deflate will not return Z_STREAM_END, and it must
  be called again as described above.

    deflate() sets strm->adler to the Adler-32 checksum of all input read
  so far (that is, total_in bytes).  If a gzip stream is being generated, then
  strm->adler will be the CRC-32 checksum of the input read so far.  (See
  deflateInit2 below.)

    deflate() may update strm->data_type if it can make a good guess about
  the input data type (Z_BINARY or Z_TEXT).  If in doubt, the data is
  considered binary.  This field is only for information purposes and does not
  affect the compression algorithm in any manner.

    deflate() returns Z_OK if some progress has been made (more input
  processed or more output produced), Z_STREAM_END if all input has been
  consumed and all output has been produced (only when flush is set to
  Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example
  if next_in or next_out was Z_NULL or the state was inadvertently written over
  by the application), or Z_BUF_ERROR if no progress is possible (for example
  avail_in or avail_out was zero).  Note that Z_BUF_ERROR is not fatal, and
  deflate() can be called again with more input and more output space to
  continue compressing.
*/


ZEXTERN int ZEXPORT deflateEnd OF((z_streamp strm));
/*
     All dynamically allocated data structures for this stream are freed.
   This function discards any unprocessed input and does not flush any pending
   output.

     deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the
   stream state was inconsistent, Z_DATA_ERROR if the stream was freed
   prematurely (some input or output was discarded).  In the error case, msg
   may be set but then points to a static string (which must not be
   deallocated).
*/


/*
ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));

     Initializes the internal stream state for decompression.  The fields
   next_in, avail_in, zalloc, zfree and opaque must be initialized before by
   the caller.  In the current version of inflate, the provided input is not
   read or consumed.  The allocation of a sliding window will be deferred to
   the first call of inflate (if the decompression does not complete on the
   first call).  If zalloc and zfree are set to Z_NULL, inflateInit updates
   them to use default allocation functions.

     inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
   version assumed by the caller, or Z_STREAM_ERROR if the parameters are
   invalid, such as a null pointer to the structure.  msg is set to null if
   there is no error message.  inflateInit does not perform any decompression.
   Actual decompression will be done by inflate().  So next_in, and avail_in,
   next_out, and avail_out are unused and unchanged.  The current
   implementation of inflateInit() does not process any header information --
   that is deferred until inflate() is called.
*/


ZEXTERN int ZEXPORT inflate OF((z_streamp strm, int flush));
/*
    inflate decompresses as much data as possible, and stops when the input
  buffer becomes empty or the output buffer becomes full.  It may introduce
  some output latency (reading input without producing any output) except when
  forced to flush.

  The detailed semantics are as follows.  inflate performs one or both of the
  following actions:

  - Decompress more input starting at next_in and update next_in and avail_in
    accordingly.  If not all input can be processed (because there is not
    enough room in the output buffer), then next_in and avail_in are updated
    accordingly, and processing will resume at this point for the next call of
    inflate().

  - Generate more output starting at next_out and update next_out and avail_out
    accordingly.  inflate() provides as much output as possible, until there is
    no more input data or no more space in the output buffer (see below about
    the flush parameter).

    Before the call of inflate(), the application should ensure that at least
  one of the actions is possible, by providing more input and/or consuming more
  output, and updating the next_* and avail_* values accordingly.  If the
  caller of inflate() does not provide both available input and available
  output space, it is possible that there will be no progress made.  The
  application can consume the uncompressed output when it wants, for example
  when the output buffer is full (avail_out == 0), or after each call of
  inflate().  If inflate returns Z_OK and with zero avail_out, it must be
  called again after making room in the output buffer because there might be
  more output pending.

    The flush parameter of inflate() can be Z_NO_FLUSH, Z_SYNC_FLUSH, Z_FINISH,
  Z_BLOCK, or Z_TREES.  Z_SYNC_FLUSH requests that inflate() flush as much
  output as possible to the output buffer.  Z_BLOCK requests that inflate()
  stop if and when it gets to the next deflate block boundary.  When decoding
  the zlib or gzip format, this will cause inflate() to return immediately
  after the header and before the first block.  When doing a raw inflate,
  inflate() will go ahead and process the first block, and will return when it
  gets to the end of that block, or when it runs out of data.

    The Z_BLOCK option assists in appending to or combining deflate streams.
  To assist in this, on return inflate() always sets strm->data_type to the
  number of unused bits in the last byte taken from strm->next_in, plus 64 if
  inflate() is currently decoding the last block in the deflate stream, plus
  128 if inflate() returned immediately after decoding an end-of-block code or
  decoding the complete header up to just before the first byte of the deflate
  stream.  The end-of-block will not be indicated until all of the uncompressed
  data from that block has been written to strm->next_out.  The number of
  unused bits may in general be greater than seven, except when bit 7 of
  data_type is set, in which case the number of unused bits will be less than
  eight.  data_type is set as noted here every time inflate() returns for all
  flush options, and so can be used to determine the amount of currently
  consumed input in bits.

    The Z_TREES option behaves as Z_BLOCK does, but it also returns when the
  end of each deflate block header is reached, before any actual data in that
  block is decoded.  This allows the caller to determine the length of the
  deflate block header for later use in random access within a deflate block.
  256 is added to the value of strm->data_type when inflate() returns
  immediately after reaching the end of the deflate block header.

    inflate() should normally be called until it returns Z_STREAM_END or an
  error.  However if all decompression is to be performed in a single step (a
  single call of inflate), the parameter flush should be set to Z_FINISH.  In
  this case all pending input is processed and all pending output is flushed;
  avail_out must be large enough to hold all of the uncompressed data for the
  operation to complete.  (The size of the uncompressed data may have been
  saved by the compressor for this purpose.)  The use of Z_FINISH is not
  required to perform an inflation in one step.  However it may be used to
  inform inflate that a faster approach can be used for the single inflate()
  call.  Z_FINISH also informs inflate to not maintain a sliding window if the
  stream completes, which reduces inflate's memory footprint.  If the stream
  does not complete, either because not all of the stream is provided or not
  enough output space is provided, then a sliding window will be allocated and
  inflate() can be called again to continue the operation as if Z_NO_FLUSH had
  been used.

     In this implementation, inflate() always flushes as much output as
  possible to the output buffer, and always uses the faster approach on the
  first call.  So the effects of the flush parameter in this implementation are
  on the return value of inflate() as noted below, when inflate() returns early
  when Z_BLOCK or Z_TREES is used, and when inflate() avoids the allocation of
  memory for a sliding window when Z_FINISH is used.

     If a preset dictionary is needed after this call (see inflateSetDictionary
  below), inflate sets strm->adler to the Adler-32 checksum of the dictionary
  chosen by the compressor and returns Z_NEED_DICT; otherwise it sets
  strm->adler to the Adler-32 checksum of all output produced so far (that is,
  total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described
  below.  At the end of the stream, inflate() checks that its computed Adler-32
  checksum is equal to that saved by the compressor and returns Z_STREAM_END
  only if the checksum is correct.

    inflate() can decompress and check either zlib-wrapped or gzip-wrapped
  deflate data.  The header type is detected automatically, if requested when
  initializing with inflateInit2().  Any information contained in the gzip
  header is not retained unless inflateGetHeader() is used.  When processing
  gzip-wrapped deflate data, strm->adler32 is set to the CRC-32 of the output
  produced so far.  The CRC-32 is checked against the gzip trailer, as is the
  uncompressed length, modulo 2^32.

    inflate() returns Z_OK if some progress has been made (more input processed
  or more output produced), Z_STREAM_END if the end of the compressed data has
  been reached and all uncompressed output has been produced, Z_NEED_DICT if a
  preset dictionary is needed at this point, Z_DATA_ERROR if the input data was
  corrupted (input stream not conforming to the zlib format or incorrect check
  value, in which case strm->msg points to a string with a more specific
  error), Z_STREAM_ERROR if the stream structure was inconsistent (for example
  next_in or next_out was Z_NULL, or the state was inadvertently written over
  by the application), Z_MEM_ERROR if there was not enough memory, Z_BUF_ERROR
  if no progress was possible or if there was not enough room in the output
  buffer when Z_FINISH is used.  Note that Z_BUF_ERROR is not fatal, and
  inflate() can be called again with more input and more output space to
  continue decompressing.  If Z_DATA_ERROR is returned, the application may
  then call inflateSync() to look for a good compression block if a partial
  recovery of the data is to be attempted.
*/


ZEXTERN int ZEXPORT inflateEnd OF((z_streamp strm));
/*
     All dynamically allocated data structures for this stream are freed.
   This function discards any unprocessed input and does not flush any pending
   output.

     inflateEnd returns Z_OK if success, or Z_STREAM_ERROR if the stream state
   was inconsistent.
*/


                        /* Advanced functions */

/*
    The following functions are needed only in some special applications.
*/

/*
ZEXTERN int ZEXPORT deflateInit2 OF((z_streamp strm,
                                     int  level,
                                     int  method,
                                     int  windowBits,
                                     int  memLevel,
                                     int  strategy));

     This is another version of deflateInit with more compression options.  The
   fields next_in, zalloc, zfree and opaque must be initialized before by the
   caller.

     The method parameter is the compression method.  It must be Z_DEFLATED in
   this version of the library.

     The windowBits parameter is the base two logarithm of the window size
   (the size of the history buffer).  It should be in the range 8..15 for this
   version of the library.  Larger values of this parameter result in better
   compression at the expense of memory usage.  The default value is 15 if
   deflateInit is used instead.

     For the current implementation of deflate(), a windowBits value of 8 (a
   window size of 256 bytes) is not supported.  As a result, a request for 8
   will result in 9 (a 512-byte window).  In that case, providing 8 to
   inflateInit2() will result in an error when the zlib header with 9 is
   checked against the initialization of inflate().  The remedy is to not use 8
   with deflateInit2() with this initialization, or at least in that case use 9
   with inflateInit2().

     windowBits can also be -8..-15 for raw deflate.  In this case, -windowBits
   determines the window size.  deflate() will then generate raw deflate data
   with no zlib header or trailer, and will not compute a check value.

     windowBits can also be greater than 15 for optional gzip encoding.  Add
   16 to windowBits to write a simple gzip header and trailer around the
   compressed data instead of a zlib wrapper.  The gzip header will have no
   file name, no extra data, no comment, no modification time (set to zero), no
   header crc, and the operating system will be set to the appropriate value,
   if the operating system was determined at compile time.  If a gzip stream is
   being written, strm->adler is a CRC-32 instead of an Adler-32.

     For raw deflate or gzip encoding, a request for a 256-byte window is
   rejected as invalid, since only the zlib header provides a means of
   transmitting the window size to the decompressor.

     The memLevel parameter specifies how much memory should be allocated
   for the internal compression state.  memLevel=1 uses minimum memory but is
   slow and reduces compression ratio; memLevel=9 uses maximum memory for
   optimal speed.  The default value is 8.  See zconf.h for total memory usage
   as a function of windowBits and memLevel.

     The strategy parameter is used to tune the compression algorithm.  Use the
   value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a
   filter (or predictor), Z_HUFFMAN_ONLY to force Huffman encoding only (no
   string match), or Z_RLE to limit match distances to one (run-length
   encoding).  Filtered data consists mostly of small values with a somewhat
   random distribution.  In this case, the compression algorithm is tuned to
   compress them better.  The effect of Z_FILTERED is to force more Huffman
   coding and less string matching; it is somewhat intermediate between
   Z_DEFAULT_STRATEGY and Z_HUFFMAN_ONLY.  Z_RLE is designed to be almost as
   fast as Z_HUFFMAN_ONLY, but give better compression for PNG image data.  The
   strategy parameter only affects the compression ratio but not the
   correctness of the compressed output even if it is not set appropriately.
   Z_FIXED prevents the use of dynamic Huffman codes, allowing for a simpler
   decoder for special applications.

     deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_STREAM_ERROR if any parameter is invalid (such as an invalid
   method), or Z_VERSION_ERROR if the zlib library version (zlib_version) is
   incompatible with the version assumed by the caller (ZLIB_VERSION).  msg is
   set to null if there is no error message.  deflateInit2 does not perform any
   compression: this will be done by deflate().
*/

ZEXTERN int ZEXPORT deflateSetDictionary OF((z_streamp strm,
                                             const Bytef *dictionary,
                                             uInt  dictLength));
/*
     Initializes the compression dictionary from the given byte sequence
   without producing any compressed output.  When using the zlib format, this
   function must be called immediately after deflateInit, deflateInit2 or
   deflateReset, and before any call of deflate.  When doing raw deflate, this
   function must be called either before any call of deflate, or immediately
   after the completion of a deflate block, i.e. after all input has been
   consumed and all output has been delivered when using any of the flush
   options Z_BLOCK, Z_PARTIAL_FLUSH, Z_SYNC_FLUSH, or Z_FULL_FLUSH.  The
   compressor and decompressor must use exactly the same dictionary (see
   inflateSetDictionary).

     The dictionary should consist of strings (byte sequences) that are likely
   to be encountered later in the data to be compressed, with the most commonly
   used strings preferably put towards the end of the dictionary.  Using a
   dictionary is most useful when the data to be compressed is short and can be
   predicted with good accuracy; the data can then be compressed better than
   with the default empty dictionary.

     Depending on the size of the compression data structures selected by
   deflateInit or deflateInit2, a part of the dictionary may in effect be
   discarded, for example if the dictionary is larger than the window size
   provided in deflateInit or deflateInit2.  Thus the strings most likely to be
   useful should be put at the end of the dictionary, not at the front.  In
   addition, the current implementation of deflate will use at most the window
   size minus 262 bytes of the provided dictionary.

     Upon return of this function, strm->adler is set to the Adler-32 value
   of the dictionary; the decompressor may later use this value to determine
   which dictionary has been used by the compressor.  (The Adler-32 value
   applies to the whole dictionary even if only a subset of the dictionary is
   actually used by the compressor.) If a raw deflate was requested, then the
   Adler-32 value is not computed and strm->adler is not set.

     deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a
   parameter is invalid (e.g.  dictionary being Z_NULL) or the stream state is
   inconsistent (for example if deflate has already been called for this stream
   or if not at a block boundary for raw deflate).  deflateSetDictionary does
   not perform any compression: this will be done by deflate().
*/

ZEXTERN int ZEXPORT deflateGetDictionary OF((z_streamp strm,
                                             Bytef *dictionary,
                                             uInt  *dictLength));
/*
     Returns the sliding dictionary being maintained by deflate.  dictLength is
   set to the number of bytes in the dictionary, and that many bytes are copied
   to dictionary.  dictionary must have enough space, where 32768 bytes is
   always enough.  If deflateGetDictionary() is called with dictionary equal to
   Z_NULL, then only the dictionary length is returned, and nothing is copied.
   Similary, if dictLength is Z_NULL, then it is not set.

     deflateGetDictionary() may return a length less than the window size, even
   when more than the window size in input has been provided. It may return up
   to 258 bytes less in that case, due to how zlib's implementation of deflate
   manages the sliding window and lookahead for matches, where matches can be
   up to 258 bytes long. If the application needs the last window-size bytes of
   input, then that would need to be saved by the application outside of zlib.

     deflateGetDictionary returns Z_OK on success, or Z_STREAM_ERROR if the
   stream state is inconsistent.
*/

ZEXTERN int ZEXPORT deflateCopy OF((z_streamp dest,
                                    z_streamp source));
/*
     Sets the destination stream as a complete copy of the source stream.

     This function can be useful when several compression strategies will be
   tried, for example when there are several ways of pre-processing the input
   data with a filter.  The streams that will be discarded should then be freed
   by calling deflateEnd.  Note that deflateCopy duplicates the internal
   compression state which can be quite large, so this strategy is slow and can
   consume lots of memory.

     deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
   (such as zalloc being Z_NULL).  msg is left unchanged in both source and
   destination.
*/

ZEXTERN int ZEXPORT deflateReset OF((z_streamp strm));
/*
     This function is equivalent to deflateEnd followed by deflateInit, but
   does not free and reallocate the internal compression state.  The stream
   will leave the compression level and any other attributes that may have been
   set unchanged.

     deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent (such as zalloc or state being Z_NULL).
*/

ZEXTERN int ZEXPORT deflateParams OF((z_streamp strm,
                                      int level,
                                      int strategy));
/*
     Dynamically update the compression level and compression strategy.  The
   interpretation of level and strategy is as in deflateInit2().  This can be
   used to switch between compression and straight copy of the input data, or
   to switch to a different kind of input data requiring a different strategy.
   If the compression approach (which is a function of the level) or the
   strategy is changed, and if any input has been consumed in a previous
   deflate() call, then the input available so far is compressed with the old
   level and strategy using deflate(strm, Z_BLOCK).  There are three approaches
   for the compression levels 0, 1..3, and 4..9 respectively.  The new level
   and strategy will take effect at the next call of deflate().

     If a deflate(strm, Z_BLOCK) is performed by deflateParams(), and it does
   not have enough output space to complete, then the parameter change will not
   take effect.  In this case, deflateParams() can be called again with the
   same parameters and more output space to try again.

     In order to assure a change in the parameters on the first try, the
   deflate stream should be flushed using deflate() with Z_BLOCK or other flush
   request until strm.avail_out is not zero, before calling deflateParams().
   Then no more input data should be provided before the deflateParams() call.
   If this is done, the old level and strategy will be applied to the data
   compressed before deflateParams(), and the new level and strategy will be
   applied to the the data compressed after deflateParams().

     deflateParams returns Z_OK on success, Z_STREAM_ERROR if the source stream
   state was inconsistent or if a parameter was invalid, or Z_BUF_ERROR if
   there was not enough output space to complete the compression of the
   available input data before a change in the strategy or approach.  Note that
   in the case of a Z_BUF_ERROR, the parameters are not changed.  A return
   value of Z_BUF_ERROR is not fatal, in which case deflateParams() can be
   retried with more output space.
*/

ZEXTERN int ZEXPORT deflateTune OF((z_streamp strm,
                                    int good_length,
                                    int max_lazy,
                                    int nice_length,
                                    int max_chain));
/*
     Fine tune deflate's internal compression parameters.  This should only be
   used by someone who understands the algorithm used by zlib's deflate for
   searching for the best matching string, and even then only by the most
   fanatic optimizer trying to squeeze out the last compressed bit for their
   specific input data.  Read the deflate.c source code for the meaning of the
   max_lazy, good_length, nice_length, and max_chain parameters.

     deflateTune() can be called after deflateInit() or deflateInit2(), and
   returns Z_OK on success, or Z_STREAM_ERROR for an invalid deflate stream.
 */

ZEXTERN uLong ZEXPORT deflateBound OF((z_streamp strm,
                                       uLong sourceLen));
/*
     deflateBound() returns an upper bound on the compressed size after
   deflation of sourceLen bytes.  It must be called after deflateInit() or
   deflateInit2(), and after deflateSetHeader(), if used.  This would be used
   to allocate an output buffer for deflation in a single pass, and so would be
   called before deflate().  If that first deflate() call is provided the
   sourceLen input bytes, an output buffer allocated to the size returned by
   deflateBound(), and the flush value Z_FINISH, then deflate() is guaranteed
   to return Z_STREAM_END.  Note that it is possible for the compressed size to
   be larger than the value returned by deflateBound() if flush options other
   than Z_FINISH or Z_NO_FLUSH are used.
*/

ZEXTERN int ZEXPORT deflatePending OF((z_streamp strm,
                                       unsigned *pending,
                                       int *bits));
/*
     deflatePending() returns the number of bytes and bits of output that have
   been generated, but not yet provided in the available output.  The bytes not
   provided would be due to the available output space having being consumed.
   The number of bits of output not provided are between 0 and 7, where they
   await more bits to join them in order to fill out a full byte.  If pending
   or bits are Z_NULL, then those values are not set.

     deflatePending returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent.
 */

ZEXTERN int ZEXPORT deflatePrime OF((z_streamp strm,
                                     int bits,
                                     int value));
/*
     deflatePrime() inserts bits in the deflate output stream.  The intent
   is that this function is used to start off the deflate output with the bits
   leftover from a previous deflate stream when appending to it.  As such, this
   function can only be used for raw deflate, and must be used before the first
   deflate() call after a deflateInit2() or deflateReset().  bits must be less
   than or equal to 16, and that many of the least significant bits of value
   will be inserted in the output.

     deflatePrime returns Z_OK if success, Z_BUF_ERROR if there was not enough
   room in the internal buffer to insert the bits, or Z_STREAM_ERROR if the
   source stream state was inconsistent.
*/

ZEXTERN int ZEXPORT deflateSetHeader OF((z_streamp strm,
                                         gz_headerp head));
/*
     deflateSetHeader() provides gzip header information for when a gzip
   stream is requested by deflateInit2().  deflateSetHeader() may be called
   after deflateInit2() or deflateReset() and before the first call of
   deflate().  The text, time, os, extra field, name, and comment information
   in the provided gz_header structure are written to the gzip header (xflag is
   ignored -- the extra flags are set according to the compression level).  The
   caller must assure that, if not Z_NULL, name and comment are terminated with
   a zero byte, and that if extra is not Z_NULL, that extra_len bytes are
   available there.  If hcrc is true, a gzip header crc is included.  Note that
   the current versions of the command-line version of gzip (up through version
   1.3.x) do not support header crc's, and will report that it is a "multi-part
   gzip file" and give up.

     If deflateSetHeader is not used, the default gzip header has text false,
   the time set to zero, and os set to 255, with no extra, name, or comment
   fields.  The gzip header is returned to the default state by deflateReset().

     deflateSetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent.
*/

/*
ZEXTERN int ZEXPORT inflateInit2 OF((z_streamp strm,
                                     int  windowBits));

     This is another version of inflateInit with an extra parameter.  The
   fields next_in, avail_in, zalloc, zfree and opaque must be initialized
   before by the caller.

     The windowBits parameter is the base two logarithm of the maximum window
   size (the size of the history buffer).  It should be in the range 8..15 for
   this version of the library.  The default value is 15 if inflateInit is used
   instead.  windowBits must be greater than or equal to the windowBits value
   provided to deflateInit2() while compressing, or it must be equal to 15 if
   deflateInit2() was not used.  If a compressed stream with a larger window
   size is given as input, inflate() will return with the error code
   Z_DATA_ERROR instead of trying to allocate a larger window.

     windowBits can also be zero to request that inflate use the window size in
   the zlib header of the compressed stream.

     windowBits can also be -8..-15 for raw inflate.  In this case, -windowBits
   determines the window size.  inflate() will then process raw deflate data,
   not looking for a zlib or gzip header, not generating a check value, and not
   looking for any check values for comparison at the end of the stream.  This
   is for use with other formats that use the deflate compressed data format
   such as zip.  Those formats provide their own check values.  If a custom
   format is developed using the raw deflate format for compressed data, it is
   recommended that a check value such as an Adler-32 or a CRC-32 be applied to
   the uncompressed data as is done in the zlib, gzip, and zip formats.  For
   most applications, the zlib format should be used as is.  Note that comments
   above on the use in deflateInit2() applies to the magnitude of windowBits.

     windowBits can also be greater than 15 for optional gzip decoding.  Add
   32 to windowBits to enable zlib and gzip decoding with automatic header
   detection, or add 16 to decode only the gzip format (the zlib format will
   return a Z_DATA_ERROR).  If a gzip stream is being decoded, strm->adler is a
   CRC-32 instead of an Adler-32.  Unlike the gunzip utility and gzread() (see
   below), inflate() will not automatically decode concatenated gzip streams.
   inflate() will return Z_STREAM_END at the end of the gzip stream.  The state
   would need to be reset to continue decoding a subsequent gzip stream.

     inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
   version assumed by the caller, or Z_STREAM_ERROR if the parameters are
   invalid, such as a null pointer to the structure.  msg is set to null if
   there is no error message.  inflateInit2 does not perform any decompression
   apart from possibly reading the zlib header if present: actual decompression
   will be done by inflate().  (So next_in and avail_in may be modified, but
   next_out and avail_out are unused and unchanged.) The current implementation
   of inflateInit2() does not process any header information -- that is
   deferred until inflate() is called.
*/

ZEXTERN int ZEXPORT inflateSetDictionary OF((z_streamp strm,
                                             const Bytef *dictionary,
                                             uInt  dictLength));
/*
     Initializes the decompression dictionary from the given uncompressed byte
   sequence.  This function must be called immediately after a call of inflate,
   if that call returned Z_NEED_DICT.  The dictionary chosen by the compressor
   can be determined from the Adler-32 value returned by that call of inflate.
   The compressor and decompressor must use exactly the same dictionary (see
   deflateSetDictionary).  For raw inflate, this function can be called at any
   time to set the dictionary.  If the provided dictionary is smaller than the
   window and there is already data in the window, then the provided dictionary
   will amend what's there.  The application must insure that the dictionary
   that was used for compression is provided.

     inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a
   parameter is invalid (e.g.  dictionary being Z_NULL) or the stream state is
   inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the
   expected one (incorrect Adler-32 value).  inflateSetDictionary does not
   perform any decompression: this will be done by subsequent calls of
   inflate().
*/

ZEXTERN int ZEXPORT inflateGetDictionary OF((z_streamp strm,
                                             Bytef *dictionary,
                                             uInt  *dictLength));
/*
     Returns the sliding dictionary being maintained by inflate.  dictLength is
   set to the number of bytes in the dictionary, and that many bytes are copied
   to dictionary.  dictionary must have enough space, where 32768 bytes is
   always enough.  If inflateGetDictionary() is called with dictionary equal to
   Z_NULL, then only the dictionary length is returned, and nothing is copied.
   Similary, if dictLength is Z_NULL, then it is not set.

     inflateGetDictionary returns Z_OK on success, or Z_STREAM_ERROR if the
   stream state is inconsistent.
*/

ZEXTERN int ZEXPORT inflateSync OF((z_streamp strm));
/*
     Skips invalid compressed data until a possible full flush point (see above
   for the description of deflate with Z_FULL_FLUSH) can be found, or until all
   available input is skipped.  No output is provided.

     inflateSync searches for a 00 00 FF FF pattern in the compressed data.
   All full flush points have this pattern, but not all occurrences of this
   pattern are full flush points.

     inflateSync returns Z_OK if a possible full flush point has been found,
   Z_BUF_ERROR if no more input was provided, Z_DATA_ERROR if no flush point
   has been found, or Z_STREAM_ERROR if the stream structure was inconsistent.
   In the success case, the application may save the current current value of
   total_in which indicates where valid compressed data was found.  In the
   error case, the application may repeatedly call inflateSync, providing more
   input each time, until success or end of the input data.
*/

ZEXTERN int ZEXPORT inflateCopy OF((z_streamp dest,
                                    z_streamp source));
/*
     Sets the destination stream as a complete copy of the source stream.

     This function can be useful when randomly accessing a large stream.  The
   first pass through the stream can periodically record the inflate state,
   allowing restarting inflate at those points when randomly accessing the
   stream.

     inflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
   (such as zalloc being Z_NULL).  msg is left unchanged in both source and
   destination.
*/

ZEXTERN int ZEXPORT inflateReset OF((z_streamp strm));
/*
     This function is equivalent to inflateEnd followed by inflateInit,
   but does not free and reallocate the internal decompression state.  The
   stream will keep attributes that may have been set by inflateInit2.

     inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent (such as zalloc or state being Z_NULL).
*/

ZEXTERN int ZEXPORT inflateReset2 OF((z_streamp strm,
                                      int windowBits));
/*
     This function is the same as inflateReset, but it also permits changing
   the wrap and window size requests.  The windowBits parameter is interpreted
   the same as it is for inflateInit2.  If the window size is changed, then the
   memory allocated for the window is freed, and the window will be reallocated
   by inflate() if needed.

     inflateReset2 returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent (such as zalloc or state being Z_NULL), or if
   the windowBits parameter is invalid.
*/

ZEXTERN int ZEXPORT inflatePrime OF((z_streamp strm,
                                     int bits,
                                     int value));
/*
     This function inserts bits in the inflate input stream.  The intent is
   that this function is used to start inflating at a bit position in the
   middle of a byte.  The provided bits will be used before any bytes are used
   from next_in.  This function should only be used with raw inflate, and
   should be used before the first inflate() call after inflateInit2() or
   inflateReset().  bits must be less than or equal to 16, and that many of the
   least significant bits of value will be inserted in the input.

     If bits is negative, then the input stream bit buffer is emptied.  Then
   inflatePrime() can be called again to put bits in the buffer.  This is used
   to clear out bits leftover after feeding inflate a block description prior
   to feeding inflate codes.

     inflatePrime returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent.
*/

ZEXTERN long ZEXPORT inflateMark OF((z_streamp strm));
/*
     This function returns two values, one in the lower 16 bits of the return
   value, and the other in the remaining upper bits, obtained by shifting the
   return value down 16 bits.  If the upper value is -1 and the lower value is
   zero, then inflate() is currently decoding information outside of a block.
   If the upper value is -1 and the lower value is non-zero, then inflate is in
   the middle of a stored block, with the lower value equaling the number of
   bytes from the input remaining to copy.  If the upper value is not -1, then
   it is the number of bits back from the current bit position in the input of
   the code (literal or length/distance pair) currently being processed.  In
   that case the lower value is the number of bytes already emitted for that
   code.

     A code is being processed if inflate is waiting for more input to complete
   decoding of the code, or if it has completed decoding but is waiting for
   more output space to write the literal or match data.

     inflateMark() is used to mark locations in the input data for random
   access, which may be at bit positions, and to note those cases where the
   output of a code may span boundaries of random access blocks.  The current
   location in the input stream can be determined from avail_in and data_type
   as noted in the description for the Z_BLOCK flush parameter for inflate.

     inflateMark returns the value noted above, or -65536 if the provided
   source stream state was inconsistent.
*/

ZEXTERN int ZEXPORT inflateGetHeader OF((z_streamp strm,
                                         gz_headerp head));
/*
     inflateGetHeader() requests that gzip header information be stored in the
   provided gz_header structure.  inflateGetHeader() may be called after
   inflateInit2() or inflateReset(), and before the first call of inflate().
   As inflate() processes the gzip stream, head->done is zero until the header
   is completed, at which time head->done is set to one.  If a zlib stream is
   being decoded, then head->done is set to -1 to indicate that there will be
   no gzip header information forthcoming.  Note that Z_BLOCK or Z_TREES can be
   used to force inflate() to return immediately after header processing is
   complete and before any actual data is decompressed.

     The text, time, xflags, and os fields are filled in with the gzip header
   contents.  hcrc is set to true if there is a header CRC.  (The header CRC
   was valid if done is set to one.) If extra is not Z_NULL, then extra_max
   contains the maximum number of bytes to write to extra.  Once done is true,
   extra_len contains the actual extra field length, and extra contains the
   extra field, or that field truncated if extra_max is less than extra_len.
   If name is not Z_NULL, then up to name_max characters are written there,
   terminated with a zero unless the length is greater than name_max.  If
   comment is not Z_NULL, then up to comm_max characters are written there,
   terminated with a zero unless the length is greater than comm_max.  When any
   of extra, name, or comment are not Z_NULL and the respective field is not
   present in the header, then that field is set to Z_NULL to signal its
   absence.  This allows the use of deflateSetHeader() with the returned
   structure to duplicate the header.  However if those fields are set to
   allocated memory, then the application will need to save those pointers
   elsewhere so that they can be eventually freed.

     If inflateGetHeader is not used, then the header information is simply
   discarded.  The header is always checked for validity, including the header
   CRC if present.  inflateReset() will reset the process to discard the header
   information.  The application would need to call inflateGetHeader() again to
   retrieve the header from the next gzip stream.

     inflateGetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent.
*/

/*
ZEXTERN int ZEXPORT inflateBackInit OF((z_streamp strm, int windowBits,
                                        unsigned char FAR *window));

     Initialize the internal stream state for decompression using inflateBack()
   calls.  The fields zalloc, zfree and opaque in strm must be initialized
   before the call.  If zalloc and zfree are Z_NULL, then the default library-
   derived memory allocation routines are used.  windowBits is the base two
   logarithm of the window size, in the range 8..15.  window is a caller
   supplied buffer of that size.  Except for special applications where it is
   assured that deflate was used with small window sizes, windowBits must be 15
   and a 32K byte window must be supplied to be able to decompress general
   deflate streams.

     See inflateBack() for the usage of these routines.

     inflateBackInit will return Z_OK on success, Z_STREAM_ERROR if any of
   the parameters are invalid, Z_MEM_ERROR if the internal state could not be
   allocated, or Z_VERSION_ERROR if the version of the library does not match
   the version of the header file.
*/

typedef unsigned (*in_func) OF((void FAR *,
                                z_const unsigned char FAR * FAR *));
typedef int (*out_func) OF((void FAR *, unsigned char FAR *, unsigned));

ZEXTERN int ZEXPORT inflateBack OF((z_streamp strm,
                                    in_func in, void FAR *in_desc,
                                    out_func out, void FAR *out_desc));
/*
     inflateBack() does a raw inflate with a single call using a call-back
   interface for input and output.  This is potentially more efficient than
   inflate() for file i/o applications, in that it avoids copying between the
   output and the sliding window by simply making the window itself the output
   buffer.  inflate() can be faster on modern CPUs when used with large
   buffers.  inflateBack() trusts the application to not change the output
   buffer passed by the output function, at least until inflateBack() returns.

     inflateBackInit() must be called first to allocate the internal state
   and to initialize the state with the user-provided window buffer.
   inflateBack() may then be used multiple times to inflate a complete, raw
   deflate stream with each call.  inflateBackEnd() is then called to free the
   allocated state.

     A raw deflate stream is one with no zlib or gzip header or trailer.
   This routine would normally be used in a utility that reads zip or gzip
   files and writes out uncompressed files.  The utility would decode the
   header and process the trailer on its own, hence this routine expects only
   the raw deflate stream to decompress.  This is different from the default
   behavior of inflate(), which expects a zlib header and trailer around the
   deflate stream.

     inflateBack() uses two subroutines supplied by the caller that are then
   called by inflateBack() for input and output.  inflateBack() calls those
   routines until it reads a complete deflate stream and writes out all of the
   uncompressed data, or until it encounters an error.  The function's
   parameters and return types are defined above in the in_func and out_func
   typedefs.  inflateBack() will call in(in_desc, &buf) which should return the
   number of bytes of provided input, and a pointer to that input in buf.  If
   there is no input available, in() must return zero -- buf is ignored in that
   case -- and inflateBack() will return a buffer error.  inflateBack() will
   call out(out_desc, buf, len) to write the uncompressed data buf[0..len-1].
   out() should return zero on success, or non-zero on failure.  If out()
   returns non-zero, inflateBack() will return with an error.  Neither in() nor
   out() are permitted to change the contents of the window provided to
   inflateBackInit(), which is also the buffer that out() uses to write from.
   The length written by out() will be at most the window size.  Any non-zero
   amount of input may be provided by in().

     For convenience, inflateBack() can be provided input on the first call by
   setting strm->next_in and strm->avail_in.  If that input is exhausted, then
   in() will be called.  Therefore strm->next_in must be initialized before
   calling inflateBack().  If strm->next_in is Z_NULL, then in() will be called
   immediately for input.  If strm->next_in is not Z_NULL, then strm->avail_in
   must also be initialized, and then if strm->avail_in is not zero, input will
   initially be taken from strm->next_in[0 ..  strm->avail_in - 1].

     The in_desc and out_desc parameters of inflateBack() is passed as the
   first parameter of in() and out() respectively when they are called.  These
   descriptors can be optionally used to pass any information that the caller-
   supplied in() and out() functions need to do their job.

     On return, inflateBack() will set strm->next_in and strm->avail_in to
   pass back any unused input that was provided by the last in() call.  The
   return values of inflateBack() can be Z_STREAM_END on success, Z_BUF_ERROR
   if in() or out() returned an error, Z_DATA_ERROR if there was a format error
   in the deflate stream (in which case strm->msg is set to indicate the nature
   of the error), or Z_STREAM_ERROR if the stream was not properly initialized.
   In the case of Z_BUF_ERROR, an input or output error can be distinguished
   using strm->next_in which will be Z_NULL only if in() returned an error.  If
   strm->next_in is not Z_NULL, then the Z_BUF_ERROR was due to out() returning
   non-zero.  (in() will always be called before out(), so strm->next_in is
   assured to be defined if out() returns non-zero.)  Note that inflateBack()
   cannot return Z_OK.
*/

ZEXTERN int ZEXPORT inflateBackEnd OF((z_streamp strm));
/*
     All memory allocated by inflateBackInit() is freed.

     inflateBackEnd() returns Z_OK on success, or Z_STREAM_ERROR if the stream
   state was inconsistent.
*/

ZEXTERN uLong ZEXPORT zlibCompileFlags OF((void));
/* Return flags indicating compile-time options.

    Type sizes, two bits each, 00 = 16 bits, 01 = 32, 10 = 64, 11 = other:
     1.0: size of uInt
     3.2: size of uLong
     5.4: size of voidpf (pointer)
     7.6: size of z_off_t

    Compiler, assembler, and debug options:
     8: ZLIB_DEBUG
     9: ASMV or ASMINF -- use ASM code
     10: ZLIB_WINAPI -- exported functions use the WINAPI calling convention
     11: 0 (reserved)

    One-time table building (smaller code, but not thread-safe if true):
     12: BUILDFIXED -- build static block decoding tables when needed
     13: DYNAMIC_CRC_TABLE -- build CRC calculation tables when needed
     14,15: 0 (reserved)

    Library content (indicates missing functionality):
     16: NO_GZCOMPRESS -- gz* functions cannot compress (to avoid linking
                          deflate code when not needed)
     17: NO_GZIP -- deflate can't write gzip streams, and inflate can't detect
                    and decode gzip streams (to avoid linking crc code)
     18-19: 0 (reserved)

    Operation variations (changes in library functionality):
     20: PKZIP_BUG_WORKAROUND -- slightly more permissive inflate
     21: FASTEST -- deflate algorithm with only one, lowest compression level
     22,23: 0 (reserved)

    The sprintf variant used by gzprintf (zero is best):
     24: 0 = vs*, 1 = s* -- 1 means limited to 20 arguments after the format
     25: 0 = *nprintf, 1 = *printf -- 1 means gzprintf() not secure!
     26: 0 = returns value, 1 = void -- 1 means inferred string length returned

    Remainder:
     27-31: 0 (reserved)
 */

#ifndef Z_SOLO

                        /* utility functions */

/*
     The following utility functions are implemented on top of the basic
   stream-oriented functions.  To simplify the interface, some default options
   are assumed (compression level and memory usage, standard memory allocation
   functions).  The source code of these utility functions can be modified if
   you need special options.
*/

ZEXTERN int ZEXPORT compress OF((Bytef *dest,   uLongf *destLen,
                                 const Bytef *source, uLong sourceLen));
/*
     Compresses the source buffer into the destination buffer.  sourceLen is
   the byte length of the source buffer.  Upon entry, destLen is the total size
   of the destination buffer, which must be at least the value returned by
   compressBound(sourceLen).  Upon exit, destLen is the actual size of the
   compressed data.  compress() is equivalent to compress2() with a level
   parameter of Z_DEFAULT_COMPRESSION.

     compress returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_BUF_ERROR if there was not enough room in the output
   buffer.
*/

ZEXTERN int ZEXPORT compress2 OF((Bytef *dest,   uLongf *destLen,
                                  const Bytef *source, uLong sourceLen,
                                  int level));
/*
     Compresses the source buffer into the destination buffer.  The level
   parameter has the same meaning as in deflateInit.  sourceLen is the byte
   length of the source buffer.  Upon entry, destLen is the total size of the
   destination buffer, which must be at least the value returned by
   compressBound(sourceLen).  Upon exit, destLen is the actual size of the
   compressed data.

     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_BUF_ERROR if there was not enough room in the output buffer,
   Z_STREAM_ERROR if the level parameter is invalid.
*/

ZEXTERN uLong ZEXPORT compressBound OF((uLong sourceLen));
/*
     compressBound() returns an upper bound on the compressed size after
   compress() or compress2() on sourceLen bytes.  It would be used before a
   compress() or compress2() call to allocate the destination buffer.
*/

ZEXTERN int ZEXPORT uncompress OF((Bytef *dest,   uLongf *destLen,
                                   const Bytef *source, uLong sourceLen));
/*
     Decompresses the source buffer into the destination buffer.  sourceLen is
   the byte length of the source buffer.  Upon entry, destLen is the total size
   of the destination buffer, which must be large enough to hold the entire
   uncompressed data.  (The size of the uncompressed data must have been saved
   previously by the compressor and transmitted to the decompressor by some
   mechanism outside the scope of this compression library.) Upon exit, destLen
   is the actual size of the uncompressed data.

     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_BUF_ERROR if there was not enough room in the output
   buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete.  In
   the case where there is not enough room, uncompress() will fill the output
   buffer with the uncompressed data up to that point.
*/

ZEXTERN int ZEXPORT uncompress2 OF((Bytef *dest,   uLongf *destLen,
                                    const Bytef *source, uLong *sourceLen));
/*
     Same as uncompress, except that sourceLen is a pointer, where the
   length of the source is *sourceLen.  On return, *sourceLen is the number of
   source bytes consumed.
*/

                        /* gzip file access functions */

/*
     This library supports reading and writing files in gzip (.gz) format with
   an interface similar to that of stdio, using the functions that start with
   "gz".  The gzip format is different from the zlib format.  gzip is a gzip
   wrapper, documented in RFC 1952, wrapped around a deflate stream.
*/

typedef struct gzFile_s *gzFile;    /* semi-opaque gzip file descriptor */

/*
ZEXTERN gzFile ZEXPORT gzopen OF((const char *path, const char *mode));

     Opens a gzip (.gz) file for reading or writing.  The mode parameter is as
   in fopen ("rb" or "wb") but can also include a compression level ("wb9") or
   a strategy: 'f' for filtered data as in "wb6f", 'h' for Huffman-only
   compression as in "wb1h", 'R' for run-length encoding as in "wb1R", or 'F'
   for fixed code compression as in "wb9F".  (See the description of
   deflateInit2 for more information about the strategy parameter.)  'T' will
   request transparent writing or appending with no compression and not using
   the gzip format.

     "a" can be used instead of "w" to request that the gzip stream that will
   be written be appended to the file.  "+" will result in an error, since
   reading and writing to the same gzip file is not supported.  The addition of
   "x" when writing will create the file exclusively, which fails if the file
   already exists.  On systems that support it, the addition of "e" when
   reading or writing will set the flag to close the file on an execve() call.

     These functions, as well as gzip, will read and decode a sequence of gzip
   streams in a file.  The append function of gzopen() can be used to create
   such a file.  (Also see gzflush() for another way to do this.)  When
   appending, gzopen does not test whether the file begins with a gzip stream,
   nor does it look for the end of the gzip streams to begin appending.  gzopen
   will simply append a gzip stream to the existing file.

     gzopen can be used to read a file which is not in gzip format; in this
   case gzread will directly read from the file without decompression.  When
   reading, this will be detected automatically by looking for the magic two-
   byte gzip header.

     gzopen returns NULL if the file could not be opened, if there was
   insufficient memory to allocate the gzFile state, or if an invalid mode was
   specified (an 'r', 'w', or 'a' was not provided, or '+' was provided).
   errno can be checked to determine if the reason gzopen failed was that the
   file could not be opened.
*/

ZEXTERN gzFile ZEXPORT gzdopen OF((int fd, const char *mode));
/*
     gzdopen associates a gzFile with the file descriptor fd.  File descriptors
   are obtained from calls like open, dup, creat, pipe or fileno (if the file
   has been previously opened with fopen).  The mode parameter is as in gzopen.

     The next call of gzclose on the returned gzFile will also close the file
   descriptor fd, just like fclose(fdopen(fd, mode)) closes the file descriptor
   fd.  If you want to keep fd open, use fd = dup(fd_keep); gz = gzdopen(fd,
   mode);.  The duplicated descriptor should be saved to avoid a leak, since
   gzdopen does not close fd if it fails.  If you are using fileno() to get the
   file descriptor from a FILE *, then you will have to use dup() to avoid
   double-close()ing the file descriptor.  Both gzclose() and fclose() will
   close the associated file descriptor, so they need to have different file
   descriptors.

     gzdopen returns NULL if there was insufficient memory to allocate the
   gzFile state, if an invalid mode was specified (an 'r', 'w', or 'a' was not
   provided, or '+' was provided), or if fd is -1.  The file descriptor is not
   used until the next gz* read, write, seek, or close operation, so gzdopen
   will not detect if fd is invalid (unless fd is -1).
*/

ZEXTERN int ZEXPORT gzbuffer OF((gzFile file, unsigned size));
/*
     Set the internal buffer size used by this library's functions.  The
   default buffer size is 8192 bytes.  This function must be called after
   gzopen() or gzdopen(), and before any other calls that read or write the
   file.  The buffer memory allocation is always deferred to the first read or
   write.  Three times that size in buffer space is allocated.  A larger buffer
   size of, for example, 64K or 128K bytes will noticeably increase the speed
   of decompression (reading).

     The new buffer size also affects the maximum length for gzprintf().

     gzbuffer() returns 0 on success, or -1 on failure, such as being called
   too late.
*/

ZEXTERN int ZEXPORT gzsetparams OF((gzFile file, int level, int strategy));
/*
     Dynamically update the compression level or strategy.  See the description
   of deflateInit2 for the meaning of these parameters.  Previously provided
   data is flushed before the parameter change.

     gzsetparams returns Z_OK if success, Z_STREAM_ERROR if the file was not
   opened for writing, Z_ERRNO if there is an error writing the flushed data,
   or Z_MEM_ERROR if there is a memory allocation error.
*/

ZEXTERN int ZEXPORT gzread OF((gzFile file, voidp buf, unsigned len));
/*
     Reads the given number of uncompressed bytes from the compressed file.  If
   the input file is not in gzip format, gzread copies the given number of
   bytes into the buffer directly from the file.

     After reaching the end of a gzip stream in the input, gzread will continue
   to read, looking for another gzip stream.  Any number of gzip streams may be
   concatenated in the input file, and will all be decompressed by gzread().
   If something other than a gzip stream is encountered after a gzip stream,
   that remaining trailing garbage is ignored (and no error is returned).

     gzread can be used to read a gzip file that is being concurrently written.
   Upon reaching the end of the input, gzread will return with the available
   data.  If the error code returned by gzerror is Z_OK or Z_BUF_ERROR, then
   gzclearerr can be used to clear the end of file indicator in order to permit
   gzread to be tried again.  Z_OK indicates that a gzip stream was completed
   on the last gzread.  Z_BUF_ERROR indicates that the input file ended in the
   middle of a gzip stream.  Note that gzread does not return -1 in the event
   of an incomplete gzip stream.  This error is deferred until gzclose(), which
   will return Z_BUF_ERROR if the last gzread ended in the middle of a gzip
   stream.  Alternatively, gzerror can be used before gzclose to detect this
   case.

     gzread returns the number of uncompressed bytes actually read, less than
   len for end of file, or -1 for error.  If len is too large to fit in an int,
   then nothing is read, -1 is returned, and the error state is set to
   Z_STREAM_ERROR.
*/

ZEXTERN z_size_t ZEXPORT gzfread OF((voidp buf, z_size_t size, z_size_t nitems,
                                     gzFile file));
/*
     Read up to nitems items of size size from file to buf, otherwise operating
   as gzread() does.  This duplicates the interface of stdio's fread(), with
   size_t request and return types.  If the library defines size_t, then
   z_size_t is identical to size_t.  If not, then z_size_t is an unsigned
   integer type that can contain a pointer.

     gzfread() returns the number of full items read of size size, or zero if
   the end of the file was reached and a full item could not be read, or if
   there was an error.  gzerror() must be consulted if zero is returned in
   order to determine if there was an error.  If the multiplication of size and
   nitems overflows, i.e. the product does not fit in a z_size_t, then nothing
   is read, zero is returned, and the error state is set to Z_STREAM_ERROR.

     In the event that the end of file is reached and only a partial item is
   available at the end, i.e. the remaining uncompressed data length is not a
   multiple of size, then the final partial item is nevetheless read into buf
   and the end-of-file flag is set.  The length of the partial item read is not
   provided, but could be inferred from the result of gztell().  This behavior
   is the same as the behavior of fread() implementations in common libraries,
   but it prevents the direct use of gzfread() to read a concurrently written
   file, reseting and retrying on end-of-file, when size is not 1.
*/

ZEXTERN int ZEXPORT gzwrite OF((gzFile file,
                                voidpc buf, unsigned len));
/*
     Writes the given number of uncompressed bytes into the compressed file.
   gzwrite returns the number of uncompressed bytes written or 0 in case of
   error.
*/

ZEXTERN z_size_t ZEXPORT gzfwrite OF((voidpc buf, z_size_t size,
                                      z_size_t nitems, gzFile file));
/*
     gzfwrite() writes nitems items of size size from buf to file, duplicating
   the interface of stdio's fwrite(), with size_t request and return types.  If
   the library defines size_t, then z_size_t is identical to size_t.  If not,
   then z_size_t is an unsigned integer type that can contain a pointer.

     gzfwrite() returns the number of full items written of size size, or zero
   if there was an error.  If the multiplication of size and nitems overflows,
   i.e. the product does not fit in a z_size_t, then nothing is written, zero
   is returned, and the error state is set to Z_STREAM_ERROR.
*/

ZEXTERN int ZEXPORTVA gzprintf Z_ARG((gzFile file, const char *format, ...));
/*
     Converts, formats, and writes the arguments to the compressed file under
   control of the format string, as in fprintf.  gzprintf returns the number of
   uncompressed bytes actually written, or a negative zlib error code in case
   of error.  The number of uncompressed bytes written is limited to 8191, or
   one less than the buffer size given to gzbuffer().  The caller should assure
   that this limit is not exceeded.  If it is exceeded, then gzprintf() will
   return an error (0) with nothing written.  In this case, there may also be a
   buffer overflow with unpredictable consequences, which is possible only if
   zlib was compiled with the insecure functions sprintf() or vsprintf()
   because the secure snprintf() or vsnprintf() functions were not available.
   This can be determined using zlibCompileFlags().
*/

ZEXTERN int ZEXPORT gzputs OF((gzFile file, const char *s));
/*
     Writes the given null-terminated string to the compressed file, excluding
   the terminating null character.

     gzputs returns the number of characters written, or -1 in case of error.
*/

ZEXTERN char * ZEXPORT gzgets OF((gzFile file, char *buf, int len));
/*
     Reads bytes from the compressed file until len-1 characters are read, or a
   newline character is read and transferred to buf, or an end-of-file
   condition is encountered.  If any characters are read or if len == 1, the
   string is terminated with a null character.  If no characters are read due
   to an end-of-file or len < 1, then the buffer is left untouched.

     gzgets returns buf which is a null-terminated string, or it returns NULL
   for end-of-file or in case of error.  If there was an error, the contents at
   buf are indeterminate.
*/

ZEXTERN int ZEXPORT gzputc OF((gzFile file, int c));
/*
     Writes c, converted to an unsigned char, into the compressed file.  gzputc
   returns the value that was written, or -1 in case of error.
*/

ZEXTERN int ZEXPORT gzgetc OF((gzFile file));
/*
     Reads one byte from the compressed file.  gzgetc returns this byte or -1
   in case of end of file or error.  This is implemented as a macro for speed.
   As such, it does not do all of the checking the other functions do.  I.e.
   it does not check to see if file is NULL, nor whether the structure file
   points to has been clobbered or not.
*/

ZEXTERN int ZEXPORT gzungetc OF((int c, gzFile file));
/*
     Push one character back onto the stream to be read as the first character
   on the next read.  At least one character of push-back is allowed.
   gzungetc() returns the character pushed, or -1 on failure.  gzungetc() will
   fail if c is -1, and may fail if a character has been pushed but not read
   yet.  If gzungetc is used immediately after gzopen or gzdopen, at least the
   output buffer size of pushed characters is allowed.  (See gzbuffer above.)
   The pushed character will be discarded if the stream is repositioned with
   gzseek() or gzrewind().
*/

ZEXTERN int ZEXPORT gzflush OF((gzFile file, int flush));
/*
     Flushes all pending output into the compressed file.  The parameter flush
   is as in the deflate() function.  The return value is the zlib error number
   (see function gzerror below).  gzflush is only permitted when writing.

     If the flush parameter is Z_FINISH, the remaining data is written and the
   gzip stream is completed in the output.  If gzwrite() is called again, a new
   gzip stream will be started in the output.  gzread() is able to read such
   concatenated gzip streams.

     gzflush should be called only when strictly necessary because it will
   degrade compression if called too often.
*/

/*
ZEXTERN z_off_t ZEXPORT gzseek OF((gzFile file,
                                   z_off_t offset, int whence));

     Sets the starting position for the next gzread or gzwrite on the given
   compressed file.  The offset represents a number of bytes in the
   uncompressed data stream.  The whence parameter is defined as in lseek(2);
   the value SEEK_END is not supported.

     If the file is opened for reading, this function is emulated but can be
   extremely slow.  If the file is opened for writing, only forward seeks are
   supported; gzseek then compresses a sequence of zeroes up to the new
   starting position.

     gzseek returns the resulting offset location as measured in bytes from
   the beginning of the uncompressed stream, or -1 in case of error, in
   particular if the file is opened for writing and the new starting position
   would be before the current position.
*/

ZEXTERN int ZEXPORT    gzrewind OF((gzFile file));
/*
     Rewinds the given file. This function is supported only for reading.

     gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK_SET)
*/

/*
ZEXTERN z_off_t ZEXPORT    gztell OF((gzFile file));

     Returns the starting position for the next gzread or gzwrite on the given
   compressed file.  This position represents a number of bytes in the
   uncompressed data stream, and is zero when starting, even if appending or
   reading a gzip stream from the middle of a file using gzdopen().

     gztell(file) is equivalent to gzseek(file, 0L, SEEK_CUR)
*/

/*
ZEXTERN z_off_t ZEXPORT gzoffset OF((gzFile file));

     Returns the current offset in the file being read or written.  This offset
   includes the count of bytes that precede the gzip stream, for example when
   appending or when using gzdopen() for reading.  When reading, the offset
   does not include as yet unused buffered input.  This information can be used
   for a progress indicator.  On error, gzoffset() returns -1.
*/

ZEXTERN int ZEXPORT gzeof OF((gzFile file));
/*
     Returns true (1) if the end-of-file indicator has been set while reading,
   false (0) otherwise.  Note that the end-of-file indicator is set only if the
   read tried to go past the end of the input, but came up short.  Therefore,
   just like feof(), gzeof() may return false even if there is no more data to
   read, in the event that the last read request was for the exact number of
   bytes remaining in the input file.  This will happen if the input file size
   is an exact multiple of the buffer size.

     If gzeof() returns true, then the read functions will return no more data,
   unless the end-of-file indicator is reset by gzclearerr() and the input file
   has grown since the previous end of file was detected.
*/

ZEXTERN int ZEXPORT gzdirect OF((gzFile file));
/*
     Returns true (1) if file is being copied directly while reading, or false
   (0) if file is a gzip stream being decompressed.

     If the input file is empty, gzdirect() will return true, since the input
   does not contain a gzip stream.

     If gzdirect() is used immediately after gzopen() or gzdopen() it will
   cause buffers to be allocated to allow reading the file to determine if it
   is a gzip file.  Therefore if gzbuffer() is used, it should be called before
   gzdirect().

     When writing, gzdirect() returns true (1) if transparent writing was
   requested ("wT" for the gzopen() mode), or false (0) otherwise.  (Note:
   gzdirect() is not needed when writing.  Transparent writing must be
   explicitly requested, so the application already knows the answer.  When
   linking statically, using gzdirect() will include all of the zlib code for
   gzip file reading and decompression, which may not be desired.)
*/

ZEXTERN int ZEXPORT    gzclose OF((gzFile file));
/*
     Flushes all pending output if necessary, closes the compressed file and
   deallocates the (de)compression state.  Note that once file is closed, you
   cannot call gzerror with file, since its structures have been deallocated.
   gzclose must not be called more than once on the same file, just as free
   must not be called more than once on the same allocation.

     gzclose will return Z_STREAM_ERROR if file is not valid, Z_ERRNO on a
   file operation error, Z_MEM_ERROR if out of memory, Z_BUF_ERROR if the
   last read ended in the middle of a gzip stream, or Z_OK on success.
*/

ZEXTERN int ZEXPORT gzclose_r OF((gzFile file));
ZEXTERN int ZEXPORT gzclose_w OF((gzFile file));
/*
     Same as gzclose(), but gzclose_r() is only for use when reading, and
   gzclose_w() is only for use when writing or appending.  The advantage to
   using these instead of gzclose() is that they avoid linking in zlib
   compression or decompression code that is not used when only reading or only
   writing respectively.  If gzclose() is used, then both compression and
   decompression code will be included the application when linking to a static
   zlib library.
*/

ZEXTERN const char * ZEXPORT gzerror OF((gzFile file, int *errnum));
/*
     Returns the error message for the last error which occurred on the given
   compressed file.  errnum is set to zlib error number.  If an error occurred
   in the file system and not in the compression library, errnum is set to
   Z_ERRNO and the application may consult errno to get the exact error code.

     The application must not modify the returned string.  Future calls to
   this function may invalidate the previously returned string.  If file is
   closed, then the string previously returned by gzerror will no longer be
   available.

     gzerror() should be used to distinguish errors from end-of-file for those
   functions above that do not distinguish those cases in their return values.
*/

ZEXTERN void ZEXPORT gzclearerr OF((gzFile file));
/*
     Clears the error and end-of-file flags for file.  This is analogous to the
   clearerr() function in stdio.  This is useful for continuing to read a gzip
   file that is being written concurrently.
*/

#endif /* !Z_SOLO */

                        /* checksum functions */

/*
     These functions are not related to compression but are exported
   anyway because they might be useful in applications using the compression
   library.
*/

ZEXTERN uLong ZEXPORT adler32 OF((uLong adler, const Bytef *buf, uInt len));
/*
     Update a running Adler-32 checksum with the bytes buf[0..len-1] and
   return the updated checksum.  If buf is Z_NULL, this function returns the
   required initial value for the checksum.

     An Adler-32 checksum is almost as reliable as a CRC-32 but can be computed
   much faster.

   Usage example:

     uLong adler = adler32(0L, Z_NULL, 0);

     while (read_buffer(buffer, length) != EOF) {
       adler = adler32(adler, buffer, length);
     }
     if (adler != original_adler) error();
*/

ZEXTERN uLong ZEXPORT adler32_z OF((uLong adler, const Bytef *buf,
                                    z_size_t len));
/*
     Same as adler32(), but with a size_t length.
*/

/*
ZEXTERN uLong ZEXPORT adler32_combine OF((uLong adler1, uLong adler2,
                                          z_off_t len2));

     Combine two Adler-32 checksums into one.  For two sequences of bytes, seq1
   and seq2 with lengths len1 and len2, Adler-32 checksums were calculated for
   each, adler1 and adler2.  adler32_combine() returns the Adler-32 checksum of
   seq1 and seq2 concatenated, requiring only adler1, adler2, and len2.  Note
   that the z_off_t type (like off_t) is a signed integer.  If len2 is
   negative, the result has no meaning or utility.
*/

ZEXTERN uLong ZEXPORT crc32   OF((uLong crc, const Bytef *buf, uInt len));
/*
     Update a running CRC-32 with the bytes buf[0..len-1] and return the
   updated CRC-32.  If buf is Z_NULL, this function returns the required
   initial value for the crc.  Pre- and post-conditioning (one's complement) is
   performed within this function so it shouldn't be done by the application.

   Usage example:

     uLong crc = crc32(0L, Z_NULL, 0);

     while (read_buffer(buffer, length) != EOF) {
       crc = crc32(crc, buffer, length);
     }
     if (crc != original_crc) error();
*/

ZEXTERN uLong ZEXPORT crc32_z OF((uLong adler, const Bytef *buf,
                                  z_size_t len));
/*
     Same as crc32(), but with a size_t length.
*/

/*
ZEXTERN uLong ZEXPORT crc32_combine OF((uLong crc1, uLong crc2, z_off_t len2));

     Combine two CRC-32 check values into one.  For two sequences of bytes,
   seq1 and seq2 with lengths len1 and len2, CRC-32 check values were
   calculated for each, crc1 and crc2.  crc32_combine() returns the CRC-32
   check value of seq1 and seq2 concatenated, requiring only crc1, crc2, and
   len2.
*/


                        /* various hacks, don't look :) */

/* deflateInit and inflateInit are macros to allow checking the zlib version
 * and the compiler's view of z_stream:
 */
ZEXTERN int ZEXPORT deflateInit_ OF((z_streamp strm, int level,
                                     const char *version, int stream_size));
ZEXTERN int ZEXPORT inflateInit_ OF((z_streamp strm,
                                     const char *version, int stream_size));
ZEXTERN int ZEXPORT deflateInit2_ OF((z_streamp strm, int  level, int  method,
                                      int windowBits, int memLevel,
                                      int strategy, const char *version,
                                      int stream_size));
ZEXTERN int ZEXPORT inflateInit2_ OF((z_streamp strm, int  windowBits,
                                      const char *version, int stream_size));
ZEXTERN int ZEXPORT inflateBackInit_ OF((z_streamp strm, int windowBits,
                                         unsigned char FAR *window,
                                         const char *version,
                                         int stream_size));
#ifdef Z_PREFIX_SET
#  define z_deflateInit(strm, level) \
          deflateInit_((strm), (level), ZLIB_VERSION, (int)sizeof(z_stream))
#  define z_inflateInit(strm) \
          inflateInit_((strm), ZLIB_VERSION, (int)sizeof(z_stream))
#  define z_deflateInit2(strm, level, method, windowBits, memLevel, strategy) \
          deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\
                        (strategy), ZLIB_VERSION, (int)sizeof(z_stream))
#  define z_inflateInit2(strm, windowBits) \
          inflateInit2_((strm), (windowBits), ZLIB_VERSION, \
                        (int)sizeof(z_stream))
#  define z_inflateBackInit(strm, windowBits, window) \
          inflateBackInit_((strm), (windowBits), (window), \
                           ZLIB_VERSION, (int)sizeof(z_stream))
#else
#  define deflateInit(strm, level) \
          deflateInit_((strm), (level), ZLIB_VERSION, (int)sizeof(z_stream))
#  define inflateInit(strm) \
          inflateInit_((strm), ZLIB_VERSION, (int)sizeof(z_stream))
#  define deflateInit2(strm, level, method, windowBits, memLevel, strategy) \
          deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\
                        (strategy), ZLIB_VERSION, (int)sizeof(z_stream))
#  define inflateInit2(strm, windowBits) \
          inflateInit2_((strm), (windowBits), ZLIB_VERSION, \
                        (int)sizeof(z_stream))
#  define inflateBackInit(strm, windowBits, window) \
          inflateBackInit_((strm), (windowBits), (window), \
                           ZLIB_VERSION, (int)sizeof(z_stream))
#endif

#ifndef Z_SOLO

/* gzgetc() macro and its supporting function and exposed data structure.  Note
 * that the real internal state is much larger than the exposed structure.
 * This abbreviated structure exposes just enough for the gzgetc() macro.  The
 * user should not mess with these exposed elements, since their names or
 * behavior could change in the future, perhaps even capriciously.  They can
 * only be used by the gzgetc() macro.  You have been warned.
 */
struct gzFile_s {
    unsigned have;
    unsigned char *next;
    z_off64_t pos;
};
ZEXTERN int ZEXPORT gzgetc_ OF((gzFile file));  /* backward compatibility */
#ifdef Z_PREFIX_SET
#  undef z_gzgetc
#  define z_gzgetc(g) \
          ((g)->have ? ((g)->have--, (g)->pos++, *((g)->next)++) : (gzgetc)(g))
#else
#  define gzgetc(g) \
          ((g)->have ? ((g)->have--, (g)->pos++, *((g)->next)++) : (gzgetc)(g))
#endif

/* provide 64-bit offset functions if _LARGEFILE64_SOURCE defined, and/or
 * change the regular functions to 64 bits if _FILE_OFFSET_BITS is 64 (if
 * both are true, the application gets the *64 functions, and the regular
 * functions are changed to 64 bits) -- in case these are set on systems
 * without large file support, _LFS64_LARGEFILE must also be true
 */
#ifdef Z_LARGE64
   ZEXTERN gzFile ZEXPORT gzopen64 OF((const char *, const char *));
   ZEXTERN z_off64_t ZEXPORT gzseek64 OF((gzFile, z_off64_t, int));
   ZEXTERN z_off64_t ZEXPORT gztell64 OF((gzFile));
   ZEXTERN z_off64_t ZEXPORT gzoffset64 OF((gzFile));
   ZEXTERN uLong ZEXPORT adler32_combine64 OF((uLong, uLong, z_off64_t));
   ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off64_t));
#endif

#if !defined(ZLIB_INTERNAL) && defined(Z_WANT64)
#  ifdef Z_PREFIX_SET
#    define z_gzopen z_gzopen64
#    define z_gzseek z_gzseek64
#    define z_gztell z_gztell64
#    define z_gzoffset z_gzoffset64
#    define z_adler32_combine z_adler32_combine64
#    define z_crc32_combine z_crc32_combine64
#  else
#    define gzopen gzopen64
#    define gzseek gzseek64
#    define gztell gztell64
#    define gzoffset gzoffset64
#    define adler32_combine adler32_combine64
#    define crc32_combine crc32_combine64
#  endif
#  ifndef Z_LARGE64
     ZEXTERN gzFile ZEXPORT gzopen64 OF((const char *, const char *));
     ZEXTERN z_off_t ZEXPORT gzseek64 OF((gzFile, z_off_t, int));
     ZEXTERN z_off_t ZEXPORT gztell64 OF((gzFile));
     ZEXTERN z_off_t ZEXPORT gzoffset64 OF((gzFile));
     ZEXTERN uLong ZEXPORT adler32_combine64 OF((uLong, uLong, z_off_t));
     ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off_t));
#  endif
#else
   ZEXTERN gzFile ZEXPORT gzopen OF((const char *, const char *));
   ZEXTERN z_off_t ZEXPORT gzseek OF((gzFile, z_off_t, int));
   ZEXTERN z_off_t ZEXPORT gztell OF((gzFile));
   ZEXTERN z_off_t ZEXPORT gzoffset OF((gzFile));
   ZEXTERN uLong ZEXPORT adler32_combine OF((uLong, uLong, z_off_t));
   ZEXTERN uLong ZEXPORT crc32_combine OF((uLong, uLong, z_off_t));
#endif

#else /* Z_SOLO */

   ZEXTERN uLong ZEXPORT adler32_combine OF((uLong, uLong, z_off_t));
   ZEXTERN uLong ZEXPORT crc32_combine OF((uLong, uLong, z_off_t));

#endif /* !Z_SOLO */

/* undocumented functions */
ZEXTERN const char   * ZEXPORT zError           OF((int));
ZEXTERN int            ZEXPORT inflateSyncPoint OF((z_streamp));
ZEXTERN const z_crc_t FAR * ZEXPORT get_crc_table    OF((void));
ZEXTERN int            ZEXPORT inflateUndermine OF((z_streamp, int));
ZEXTERN int            ZEXPORT inflateValidate OF((z_streamp, int));
ZEXTERN unsigned long  ZEXPORT inflateCodesUsed OF ((z_streamp));
ZEXTERN int            ZEXPORT inflateResetKeep OF((z_streamp));
ZEXTERN int            ZEXPORT deflateResetKeep OF((z_streamp));
#if (defined(_WIN32) || defined(__CYGWIN__)) && !defined(Z_SOLO)
ZEXTERN gzFile         ZEXPORT gzopen_w OF((const wchar_t *path,
                                            const char *mode));
#endif
#if defined(STDC) || defined(Z_HAVE_STDARG_H)
#  ifndef Z_SOLO
ZEXTERN int            ZEXPORTVA gzvprintf Z_ARG((gzFile file,
                                                  const char *format,
                                                  va_list va));
#  endif
#endif

#ifdef __cplusplus
}
#endif

#endif /* ZLIB_H */

```

`efiXloader/3rd/uefitool/common/zlib/zutil.c`:

```c
/* zutil.c -- target dependent utility functions for the compression library
 * Copyright (C) 1995-2017 Jean-loup Gailly
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/* @(#) $Id$ */

#include "zutil.h"
#ifndef Z_SOLO
#  include "gzguts.h"
#endif

z_const char * const z_errmsg[10] = {
    (z_const char *)"need dictionary",     /* Z_NEED_DICT       2  */
    (z_const char *)"stream end",          /* Z_STREAM_END      1  */
    (z_const char *)"",                    /* Z_OK              0  */
    (z_const char *)"file error",          /* Z_ERRNO         (-1) */
    (z_const char *)"stream error",        /* Z_STREAM_ERROR  (-2) */
    (z_const char *)"data error",          /* Z_DATA_ERROR    (-3) */
    (z_const char *)"insufficient memory", /* Z_MEM_ERROR     (-4) */
    (z_const char *)"buffer error",        /* Z_BUF_ERROR     (-5) */
    (z_const char *)"incompatible version",/* Z_VERSION_ERROR (-6) */
    (z_const char *)""
};


const char * ZEXPORT zlibVersion()
{
    return ZLIB_VERSION;
}

uLong ZEXPORT zlibCompileFlags()
{
    uLong flags;

    flags = 0;
    switch ((int)(sizeof(uInt))) {
    case 2:     break;
    case 4:     flags += 1;     break;
    case 8:     flags += 2;     break;
    default:    flags += 3;
    }
    switch ((int)(sizeof(uLong))) {
    case 2:     break;
    case 4:     flags += 1 << 2;        break;
    case 8:     flags += 2 << 2;        break;
    default:    flags += 3 << 2;
    }
    switch ((int)(sizeof(voidpf))) {
    case 2:     break;
    case 4:     flags += 1 << 4;        break;
    case 8:     flags += 2 << 4;        break;
    default:    flags += 3 << 4;
    }
    switch ((int)(sizeof(z_off_t))) {
    case 2:     break;
    case 4:     flags += 1 << 6;        break;
    case 8:     flags += 2 << 6;        break;
    default:    flags += 3 << 6;
    }
#ifdef ZLIB_DEBUG
    flags += 1 << 8;
#endif
#if defined(ASMV) || defined(ASMINF)
    flags += 1 << 9;
#endif
#ifdef ZLIB_WINAPI
    flags += 1 << 10;
#endif
#ifdef BUILDFIXED
    flags += 1 << 12;
#endif
#ifdef DYNAMIC_CRC_TABLE
    flags += 1 << 13;
#endif
#ifdef NO_GZCOMPRESS
    flags += 1L << 16;
#endif
#ifdef NO_GZIP
    flags += 1L << 17;
#endif
#ifdef PKZIP_BUG_WORKAROUND
    flags += 1L << 20;
#endif
#ifdef FASTEST
    flags += 1L << 21;
#endif
#if defined(STDC) || defined(Z_HAVE_STDARG_H)
#  ifdef NO_vsnprintf
    flags += 1L << 25;
#    ifdef HAS_vsprintf_void
    flags += 1L << 26;
#    endif
#  else
#    ifdef HAS_vsnprintf_void
    flags += 1L << 26;
#    endif
#  endif
#else
    flags += 1L << 24;
#  ifdef NO_snprintf
    flags += 1L << 25;
#    ifdef HAS_sprintf_void
    flags += 1L << 26;
#    endif
#  else
#    ifdef HAS_snprintf_void
    flags += 1L << 26;
#    endif
#  endif
#endif
    return flags;
}

#ifdef ZLIB_DEBUG
#include <stdlib.h>
#  ifndef verbose
#    define verbose 0
#  endif
int ZLIB_INTERNAL z_verbose = verbose;

void ZLIB_INTERNAL z_error (m)
    char *m;
{
    fprintf(stderr, "%s\n", m);
    exit(1);
}
#endif

/* exported to allow conversion of error code to string for compress() and
 * uncompress()
 */
const char * ZEXPORT zError(err)
    int err;
{
    return ERR_MSG(err);
}

#if defined(_WIN32_WCE)
    /* The Microsoft C Run-Time Library for Windows CE doesn't have
     * errno.  We define it as a global variable to simplify porting.
     * Its value is always 0 and should not be used.
     */
    int errno = 0;
#endif

#ifndef HAVE_MEMCPY

void ZLIB_INTERNAL zmemcpy(dest, source, len)
    Bytef* dest;
    const Bytef* source;
    uInt  len;
{
    if (len == 0) return;
    do {
        *dest++ = *source++; /* ??? to be unrolled */
    } while (--len != 0);
}

int ZLIB_INTERNAL zmemcmp(s1, s2, len)
    const Bytef* s1;
    const Bytef* s2;
    uInt  len;
{
    uInt j;

    for (j = 0; j < len; j++) {
        if (s1[j] != s2[j]) return 2*(s1[j] > s2[j])-1;
    }
    return 0;
}

void ZLIB_INTERNAL zmemzero(dest, len)
    Bytef* dest;
    uInt  len;
{
    if (len == 0) return;
    do {
        *dest++ = 0;  /* ??? to be unrolled */
    } while (--len != 0);
}
#endif

#ifndef Z_SOLO

#ifdef SYS16BIT

#ifdef __TURBOC__
/* Turbo C in 16-bit mode */

#  define MY_ZCALLOC

/* Turbo C malloc() does not allow dynamic allocation of 64K bytes
 * and farmalloc(64K) returns a pointer with an offset of 8, so we
 * must fix the pointer. Warning: the pointer must be put back to its
 * original form in order to free it, use zcfree().
 */

#define MAX_PTR 10
/* 10*64K = 640K */

local int next_ptr = 0;

typedef struct ptr_table_s {
    voidpf org_ptr;
    voidpf new_ptr;
} ptr_table;

local ptr_table table[MAX_PTR];
/* This table is used to remember the original form of pointers
 * to large buffers (64K). Such pointers are normalized with a zero offset.
 * Since MSDOS is not a preemptive multitasking OS, this table is not
 * protected from concurrent access. This hack doesn't work anyway on
 * a protected system like OS/2. Use Microsoft C instead.
 */

voidpf ZLIB_INTERNAL zcalloc (voidpf opaque, unsigned items, unsigned size)
{
    voidpf buf;
    ulg bsize = (ulg)items*size;

    (void)opaque;

    /* If we allocate less than 65520 bytes, we assume that farmalloc
     * will return a usable pointer which doesn't have to be normalized.
     */
    if (bsize < 65520L) {
        buf = farmalloc(bsize);
        if (*(ush*)&buf != 0) return buf;
    } else {
        buf = farmalloc(bsize + 16L);
    }
    if (buf == NULL || next_ptr >= MAX_PTR) return NULL;
    table[next_ptr].org_ptr = buf;

    /* Normalize the pointer to seg:0 */
    *((ush*)&buf+1) += ((ush)((uch*)buf-0) + 15) >> 4;
    *(ush*)&buf = 0;
    table[next_ptr++].new_ptr = buf;
    return buf;
}

void ZLIB_INTERNAL zcfree (voidpf opaque, voidpf ptr)
{
    int n;

    (void)opaque;

    if (*(ush*)&ptr != 0) { /* object < 64K */
        farfree(ptr);
        return;
    }
    /* Find the original pointer */
    for (n = 0; n < next_ptr; n++) {
        if (ptr != table[n].new_ptr) continue;

        farfree(table[n].org_ptr);
        while (++n < next_ptr) {
            table[n-1] = table[n];
        }
        next_ptr--;
        return;
    }
    Assert(0, "zcfree: ptr not found");
}

#endif /* __TURBOC__ */


#ifdef M_I86
/* Microsoft C in 16-bit mode */

#  define MY_ZCALLOC

#if (!defined(_MSC_VER) || (_MSC_VER <= 600))
#  define _halloc  halloc
#  define _hfree   hfree
#endif

voidpf ZLIB_INTERNAL zcalloc (voidpf opaque, uInt items, uInt size)
{
    (void)opaque;
    return _halloc((long)items, size);
}

void ZLIB_INTERNAL zcfree (voidpf opaque, voidpf ptr)
{
    (void)opaque;
    _hfree(ptr);
}

#endif /* M_I86 */

#endif /* SYS16BIT */


#ifndef MY_ZCALLOC /* Any system without a special alloc function */

#ifndef STDC
extern voidp  malloc OF((uInt size));
extern voidp  calloc OF((uInt items, uInt size));
extern void   free   OF((voidpf ptr));
#endif

voidpf ZLIB_INTERNAL zcalloc (opaque, items, size)
    voidpf opaque;
    unsigned items;
    unsigned size;
{
    (void)opaque;
    return sizeof(uInt) > 2 ? (voidpf)malloc(items * size) :
                              (voidpf)calloc(items, size);
}

void ZLIB_INTERNAL zcfree (opaque, ptr)
    voidpf opaque;
    voidpf ptr;
{
    (void)opaque;
    free(ptr);
}

#endif /* MY_ZCALLOC */

#endif /* !Z_SOLO */

```

`efiXloader/3rd/uefitool/common/zlib/zutil.h`:

```h
/* zutil.h -- internal interface and configuration of the compression library
 * Copyright (C) 1995-2016 Jean-loup Gailly, Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

/* @(#) $Id$ */

#ifndef ZUTIL_H
#define ZUTIL_H

#ifdef HAVE_HIDDEN
#  define ZLIB_INTERNAL __attribute__((visibility ("hidden")))
#else
#  define ZLIB_INTERNAL
#endif

#include "zlib.h"

#if defined(STDC) && !defined(Z_SOLO)
#  if !(defined(_WIN32_WCE) && defined(_MSC_VER))
#    include <stddef.h>
#  endif
#  include <string.h>
#  include <stdlib.h>
#endif

#ifdef Z_SOLO
   typedef long ptrdiff_t;  /* guess -- will be caught if guess is wrong */
#endif

#ifndef local
#  define local static
#endif
/* since "static" is used to mean two completely different things in C, we
   define "local" for the non-static meaning of "static", for readability
   (compile with -Dlocal if your debugger can't find static symbols) */

typedef unsigned char  uch;
typedef uch FAR uchf;
typedef unsigned short ush;
typedef ush FAR ushf;
typedef unsigned long  ulg;

extern z_const char * const z_errmsg[10]; /* indexed by 2-zlib_error */
/* (size given to avoid silly warnings with Visual C++) */

#define ERR_MSG(err) z_errmsg[Z_NEED_DICT-(err)]

#define ERR_RETURN(strm,err) \
  return (strm->msg = ERR_MSG(err), (err))
/* To be used only when the state is known to be valid */

        /* common constants */

#ifndef DEF_WBITS
#  define DEF_WBITS MAX_WBITS
#endif
/* default windowBits for decompression. MAX_WBITS is for compression only */

#if MAX_MEM_LEVEL >= 8
#  define DEF_MEM_LEVEL 8
#else
#  define DEF_MEM_LEVEL  MAX_MEM_LEVEL
#endif
/* default memLevel */

#define STORED_BLOCK 0
#define STATIC_TREES 1
#define DYN_TREES    2
/* The three kinds of block type */

#define MIN_MATCH  3
#define MAX_MATCH  258
/* The minimum and maximum match lengths */

#define PRESET_DICT 0x20 /* preset dictionary flag in zlib header */

        /* target dependencies */

#if defined(MSDOS) || (defined(WINDOWS) && !defined(WIN32))
#  define OS_CODE  0x00
#  ifndef Z_SOLO
#    if defined(__TURBOC__) || defined(__BORLANDC__)
#      if (__STDC__ == 1) && (defined(__LARGE__) || defined(__COMPACT__))
         /* Allow compilation with ANSI keywords only enabled */
         void _Cdecl farfree( void *block );
         void *_Cdecl farmalloc( unsigned long nbytes );
#      else
#        include <alloc.h>
#      endif
#    else /* MSC or DJGPP */
#      include <malloc.h>
#    endif
#  endif
#endif

#ifdef AMIGA
#  define OS_CODE  1
#endif

#if defined(VAXC) || defined(VMS)
#  define OS_CODE  2
#  define F_OPEN(name, mode) \
     fopen((name), (mode), "mbc=60", "ctx=stm", "rfm=fix", "mrs=512")
#endif

#ifdef __370__
#  if __TARGET_LIB__ < 0x20000000
#    define OS_CODE 4
#  elif __TARGET_LIB__ < 0x40000000
#    define OS_CODE 11
#  else
#    define OS_CODE 8
#  endif
#endif

#if defined(ATARI) || defined(atarist)
#  define OS_CODE  5
#endif

#ifdef OS2
#  define OS_CODE  6
#  if defined(M_I86) && !defined(Z_SOLO)
#    include <malloc.h>
#  endif
#endif

#if defined(MACOS) || defined(TARGET_OS_MAC)
#  define OS_CODE  7
#  ifndef Z_SOLO
#    if defined(__MWERKS__) && __dest_os != __be_os && __dest_os != __win32_os
#      include <unix.h> /* for fdopen */
#    else
#      ifndef fdopen
#        define fdopen(fd,mode) NULL /* No fdopen() */
#      endif
#    endif
#  endif
#endif

#ifdef __acorn
#  define OS_CODE 13
#endif

#if defined(WIN32) && !defined(__CYGWIN__)
#  define OS_CODE  10
#endif

#ifdef _BEOS_
#  define OS_CODE  16
#endif

#ifdef __TOS_OS400__
#  define OS_CODE 18
#endif

#ifdef __APPLE__
#  define OS_CODE 19
#endif

#if defined(_BEOS_) || defined(RISCOS)
#  define fdopen(fd,mode) NULL /* No fdopen() */
#endif

#if (defined(_MSC_VER) && (_MSC_VER > 600)) && !defined __INTERIX
#  if defined(_WIN32_WCE)
#    define fdopen(fd,mode) NULL /* No fdopen() */
#    ifndef _PTRDIFF_T_DEFINED
       typedef int ptrdiff_t;
#      define _PTRDIFF_T_DEFINED
#    endif
#  else
#    define fdopen(fd,type)  _fdopen(fd,type)
#  endif
#endif

#if defined(__BORLANDC__) && !defined(MSDOS)
  #pragma warn -8004
  #pragma warn -8008
  #pragma warn -8066
#endif

/* provide prototypes for these when building zlib without LFS */
#if !defined(_WIN32) && \
    (!defined(_LARGEFILE64_SOURCE) || _LFS64_LARGEFILE-0 == 0)
    ZEXTERN uLong ZEXPORT adler32_combine64 OF((uLong, uLong, z_off_t));
    ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off_t));
#endif

        /* common defaults */

#ifndef OS_CODE
#  define OS_CODE  3     /* assume Unix */
#endif

#ifndef F_OPEN
#  define F_OPEN(name, mode) fopen((name), (mode))
#endif

         /* functions */

#if defined(pyr) || defined(Z_SOLO)
#  define NO_MEMCPY
#endif
#if defined(SMALL_MEDIUM) && !defined(_MSC_VER) && !defined(__SC__)
 /* Use our own functions for small and medium model with MSC <= 5.0.
  * You may have to use the same strategy for Borland C (untested).
  * The __SC__ check is for Symantec.
  */
#  define NO_MEMCPY
#endif
#if defined(STDC) && !defined(HAVE_MEMCPY) && !defined(NO_MEMCPY)
#  define HAVE_MEMCPY
#endif
#ifdef HAVE_MEMCPY
#  ifdef SMALL_MEDIUM /* MSDOS small or medium model */
#    define zmemcpy _fmemcpy
#    define zmemcmp _fmemcmp
#    define zmemzero(dest, len) _fmemset(dest, 0, len)
#  else
#    define zmemcpy memcpy
#    define zmemcmp memcmp
#    define zmemzero(dest, len) memset(dest, 0, len)
#  endif
#else
   void ZLIB_INTERNAL zmemcpy OF((Bytef* dest, const Bytef* source, uInt len));
   int ZLIB_INTERNAL zmemcmp OF((const Bytef* s1, const Bytef* s2, uInt len));
   void ZLIB_INTERNAL zmemzero OF((Bytef* dest, uInt len));
#endif

/* Diagnostic functions */
#ifdef ZLIB_DEBUG
#  include <stdio.h>
   extern int ZLIB_INTERNAL z_verbose;
   extern void ZLIB_INTERNAL z_error OF((char *m));
#  define Assert(cond,msg) {if(!(cond)) z_error(msg);}
#  define Trace(x) {if (z_verbose>=0) fprintf x ;}
#  define Tracev(x) {if (z_verbose>0) fprintf x ;}
#  define Tracevv(x) {if (z_verbose>1) fprintf x ;}
#  define Tracec(c,x) {if (z_verbose>0 && (c)) fprintf x ;}
#  define Tracecv(c,x) {if (z_verbose>1 && (c)) fprintf x ;}
#else
#  define Assert(cond,msg)
#  define Trace(x)
#  define Tracev(x)
#  define Tracevv(x)
#  define Tracec(c,x)
#  define Tracecv(c,x)
#endif

#ifndef Z_SOLO
   voidpf ZLIB_INTERNAL zcalloc OF((voidpf opaque, unsigned items,
                                    unsigned size));
   void ZLIB_INTERNAL zcfree  OF((voidpf opaque, voidpf ptr));
#endif

#define ZALLOC(strm, items, size) \
           (*((strm)->zalloc))((strm)->opaque, (items), (size))
#define ZFREE(strm, addr)  (*((strm)->zfree))((strm)->opaque, (voidpf)(addr))
#define TRY_FREE(s, p) {if (p) ZFREE(s, p);}

/* Reverse the bytes in a 32-bit value */
#define ZSWAP32(q) ((((q) >> 24) & 0xff) + (((q) >> 8) & 0xff00) + \
                    (((q) & 0xff00) << 8) + (((q) & 0xff) << 24))

#endif /* ZUTIL_H */

```

`efiXloader/3rd/uefitool/unixbuild.sh`:

```sh
#!/bin/bash

UTARGET=$(uname)
BINSUFFIX=""

if [ "$1" = "--configure" ]; then
  export NOBUILD=1
elif [ "$1" = "--build" ]; then
  export PRECONFIGURED=1
fi

if [ "$UTARGET" = "Darwin" ]; then
  export UPLATFORM="mac"
elif [ "$UTARGET" = "Linux" ]; then
  export UPLATFORM="linux_$(uname -m)"
elif [ "${UTARGET/MINGW32/}" != "$UTARGET" ]; then
  export UPLATFORM="win32"
  export BINSUFFIX=".exe"
else
  # Fallback to something...
  export UPLATFORM="$UTARGET"
fi

if [ "$UPLATFORM" = "mac" ]; then
  if [ ! -d /opt/qt56sm ]; then
    curl -L -o /tmp/qt-5.6.3-static-mac.zip https://github.com/distdb/qtbuilds/blob/master/qt-5.6.3-static-mac.zip?raw=true || exit 1
    qtsum=$(shasum -a 256 /tmp/qt-5.6.3-static-mac.zip | cut -f1 -d' ')
    qtexpsum="214d22d8572ea6162753c8dd251d79275f3b22d49204718c637d722409e0cfcb"
    if [ "$qtsum" != "$qtexpsum" ]; then
      echo "Qt hash $qtsum does not match $qtexpsum"
      exit 1
    fi
    sudo mkdir -p /opt || exit 1
    cd /opt || exit 1
    sudo unzip -q /tmp/qt-5.6.3-static-mac.zip || exit 1
    cd - || exit 1
  fi

  export PATH="/opt/qt56sm/bin:$PATH"
elif [ "$UPLATFORM" = "win32" ]; then
  # Install missing dependencies
  pacman -S --noconfirm --needed zip unzip curl perl mingw-w64-i686-toolchain mingw-w64-i686-cmake || exit 1

  # Fix PATH to support running shasum.
  export PATH="/usr/bin/core_perl:$PATH"

  if [ ! -d "/c/Qt/5.6/mingw49_32_release_static/" ]; then
    curl -L -o /tmp/qt-5.6.3-static-win32.zip https://github.com/distdb/qtbuilds/blob/master/qt-5.6.3-static-win32.zip?raw=true || exit 1
    qtsum=$(shasum -a 256 /tmp/qt-5.6.3-static-win32.zip | cut -f1 -d' ')
    qtexpsum="bcd85145d6fed00da37498c08c49d763c6fa883337f754880b5c786899e6bb1d"
    if [ "$qtsum" != "$qtexpsum" ]; then
      echo "Qt hash $qtsum does not match $qtexpsum"
      exit 1
    fi
    mkdir -p /c/Qt/5.6 || exit 1
    cd /c/Qt/5.6 || exit 1
    unzip -q /tmp/qt-5.6.3-static-win32.zip || exit 1
    cd - || exit 1
  fi

  export PATH="/c/Qt/5.6/mingw49_32_release_static/bin:$PATH"
fi

echo "Attempting to build UEFITool NE for ${UPLATFORM}..."

UEFITOOL_VER=$(cat version.h | grep PROGRAM_VERSION | cut -d'"' -f2 | sed 's/NE alpha /A/')

build_tool() {
  echo "Building $1 $2"
  # Check version
  if [ "$(echo "$2" | grep '^[0-9]*\.[0-9]*\.[0-9]*$')" != "$2" ] && [ "$(echo "$2" | grep '^A[0-9]*$')" != "$2" ]; then
    echo "Invalid $1 version!"
    exit 1
  fi
  # Tools are in subdirectories
  cd "$1" || exit 1

  # Build
  if [ "$PRECONFIGURED" != "1" ]; then
    if [ "$3" != "" ]; then
      # -flto is flawed on CI atm
      if [ "$UPLATFORM" = "mac" ]; then
        qmake $3 QMAKE_CXXFLAGS+=-flto QMAKE_LFLAGS+=-flto CONFIG+=optimize_size || exit 1
      elif [ "$UPLATFORM" = "win32" ]; then
        qmake $3 QMAKE_CXXFLAGS="-static -flto -Os" QMAKE_LFLAGS="-static -flto -Os" CONFIG+=optimize_size CONFIG+=staticlib CONFIG+=static || exit 1
      else
        qmake $3 CONFIG+=optimize_size || exit 1
      fi
    else
      if [ "$UPLATFORM" = "mac" ]; then
        cmake -G "Unix Makefiles" -DCMAKE_CXX_FLAGS="-stdlib=libc++ -flto -Os -mmacosx-version-min=10.7" -DCMAKE_C_FLAGS="-flto -Os -mmacosx-version-min=10.7" . || exit 1
      elif [ "$UPLATFORM" = "win32" ]; then
        cmake -G "Unix Makefiles" -DCMAKE_CXX_FLAGS="-static -Os" -DCMAKE_C_FLAGS="-static -Os" . || exit 1
      else
        cmake -G "Unix Makefiles" -DCMAKE_CXX_FLAGS="-Os" -DCMAKE_C_FLAGS="-Os" . || exit 1
      fi
    fi
  fi

  if [ "$NOBUILD" != "1" ]; then
    make || exit 1

    # Move the binary out of the dir
    if [ "$UPLATFORM" = "win32" ] && [ -f "release/${1}${BINSUFFIX}" ]; then
      mv "release/${1}${BINSUFFIX}" "${1}${BINSUFFIX}" || exit 1
    fi

    # Archive
    if [ "$1" = "UEFITool" ] && [ "$UPLATFORM" = "mac" ]; then
      strip -x UEFITool.app/Contents/MacOS/UEFITool || exit 1
      zip -qry ../dist/"${1}_NE_${2}_${UPLATFORM}.zip" UEFITool.app ${4} || exit 1
    else
      strip -x "${1}${BINSUFFIX}" || exit 1
      zip -qry ../dist/"${1}_NE_${2}_${UPLATFORM}.zip" "${1}${BINSUFFIX}" ${4} || exit 1
    fi
  fi

  # Return to parent
  cd - || exit 1
}

rm -rf dist
mkdir -p dist || exit 1

build_tool UEFITool    "$UEFITOOL_VER"  uefitool.pro
build_tool UEFIExtract "$UEFITOOL_VER"  ""
build_tool UEFIFind    "$UEFITOOL_VER"  ""

exit 0

```

`efiXloader/3rd/uefitool/version.h`:

```h
/* version.h

Copyright (c) 2019, Nikolaj Schlej. All rights reserved.
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

*/

#ifndef VERSION_H
#define VERSION_H

#define PROGRAM_VERSION "NE alpha 57" " (" __DATE__ ")"

#endif // VERSION_H

```

`efiXloader/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.7)

project(efiXloader)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

if(APPLE)
  # to build Mach-O universal binaries with 2 architectures
  set(CMAKE_CXX_FLAGS ${CMAKE_CXX_FLAGS} "-fPIC -arch x86_64")
else()
  set(CMAKE_CXX_FLAGS ${CMAKE_CXX_FLAGS} "-fPIC")
endif()

list(APPEND CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/../cmake)

find_package(IdaSdk REQUIRED)

include_directories(${PROJECT_SOURCE_DIR}/../efiXplorer/3rd/nlohmann_json)

file(
  GLOB
  uefitool_src
  "3rd/uefitool/common/*.h"
  "3rd/uefitool/common/*.c"
  "3rd/uefitool/common/*.cpp"
  "3rd/uefitool/common/LZMA/*.cpp"
  "3rd/uefitool/common/LZMA/*.c"
  "3rd/uefitool/common/LZMA/*.h"
  "3rd/uefitool/common/LZMA/SDK/C/*.c"
  "3rd/uefitool/common/LZMA/SDK/C/*.cpp"
  "3rd/uefitool/common/LZMA/SDK/C/*.h"
  "3rd/uefitool/common/Tiano/*.c"
  "3rd/uefitool/common/Tiano/*.cpp"
  "3rd/uefitool/common/Tiano/*.h"
  "3rd/uefitool/common/bstrlib/*.c"
  "3rd/uefitool/common/bstrlib/*.cpp"
  "3rd/uefitool/common/bstrlib/*.h"
  "3rd/uefitool/common/zlib/*.c"
  "3rd/uefitool/common/zlib/*.cpp"
  "3rd/uefitool/common/zlib/*.h"
  "3rd/uefitool/version.h"
  "3rd/uefitool/ffsdumper.cpp"
  "3rd/uefitool/ffsdumper.h"
  "3rd/uefitool/uefidump.cpp"
  "3rd/uefitool/uefidump.h")

# efiLoader sources
file(GLOB efiloader_src "*.h" "*.c" "*.cpp")

add_ida_loader(efiXloader NOEA32 ${PROJECT_SOURCE_DIR}/efiLoader.cpp)

set_ida_target_properties(efiXloader PROPERTIES CXX_STANDARD 17)
ida_target_include_directories(efiXloader PRIVATE ${IdaSdk_INCLUDE_DIRS})

add_ida_library(efiXloader_lib ${efiloader_src} ${uefitool_src} uefitool.cpp
                uefitool.h)
ida_target_link_libraries(efiXloader efiXloader_lib)

```

`efiXloader/efiLoader.cpp`:

```cpp
/*
 * efiXloader
 * Copyright (C) 2020-2022 Binarly
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * efiLoader.cpp
 */

#include "efiLoader.h"
#include "uefitool.h"
#include "utils.h"

#define USE_UEFITOOL_PARSER

bool first_uefi_image = true;

//------------------------
// IDA wrappers
//------------------------

void idaapi load_binary(const char *fname) {
    load_info_t *ld = NULL;
    linput_t *li = NULL;
    ushort nflags = NEF_SEGS | NEF_RSCS | NEF_NAME | NEF_IMPS | NEF_LALL | NEF_FLAT;
    if (first_uefi_image) {
        nflags |= NEF_FIRST;
    }
    first_uefi_image = false;
    // linput
    li = open_linput(fname, false);
    if (li == NULL) {
        error("failed to process input source: %s", fname);
    }
    // get loaders
    ld = build_loaders_list(li, fname);
    msg("[efiXloader] using %s to load %s\n", ld->dllname.c_str(), fname);
    // load EFI binary into database
    if ((load_nonbinary_file(fname, li, ".", nflags, ld))) {
        msg("[efiXloader] successfully loaded %s\n", fname);
    } else {
        loader_failure("[efiXloader] 'load_nonbinary_file' failed");
    }
    close_linput(li);
    free_loaders_list(ld);
    return;
}

void idaapi wait(void) {
    while (!auto_is_ok()) {
        auto_wait();
    }
}

//------------------------
// IDA analyzing
//------------------------

void inline idaapi reanalyze_all(void) {
    plan_range(inf_get_min_ea(), inf_get_max_ea());
    auto_wait();
    auto_make_proc(inf_get_min_ea());
}

void efi_til_init(const char *til_name) {
    qstring err;
    til_t *res;
    res = load_til(til_name, &err);
    if (!res) {
        loader_failure("failed to load %s", til_name);
    } else {
        msg("[efiXloader] lib %s is ready\n", til_name);
    }
}

//------------------------
// IDA loader
//------------------------

static int idaapi accept_file(qstring *fileformatname, qstring *processor, linput_t *li,
                              const char *filename) {
    efiloader::Utils utils;
    bytevec_t data;
    data.resize(qlsize(li));
    qlseek(li, 0);
    qlread(li, data.begin(), qlsize(li));
    *fileformatname = "UEFI firmware image";
    return utils.find_vol_test(data) != std::string::npos;
}

void idaapi load_file(linput_t *li, ushort neflag, const char *fileformatname) {
    bool ok = true;
    bool is_pe;
    Ui ui;
    bytevec_t data;
    data.resize(qlsize(li));
    qlread(li, data.begin(), qlsize(li));
    efiloader::Uefitool uefiParser(data);
    if (uefiParser.messages_occurs()) {
        uefiParser.show_messages();
    }
    uefiParser.dump();
    uefiParser.dump_jsons();
    efiloader::PeManager peManager;
    add_til("uefi.til", ADDTIL_DEFAULT);
    add_til("uefi64.til", ADDTIL_DEFAULT);
    qstring err;
    const til_t *idati = get_idati();
    if (!idati) {
        loader_failure("failed to load IDA types");
    } else {
        msg("[efiXloader] loaded IDA types: %#x\n", idati);
    }
    tid_t struct_err = import_type(idati, -1, "EFI_GUID");
    if (struct_err == BADNODE) {
        loader_failure("failed to import \"EFI_GUID\"");
    }
    msg("processing UEFI binaries:\n");
    if (uefiParser.files.size()) {
        for (int i = 0; i < uefiParser.files.size(); i++) {
            if (uefiParser.files[i]->is_te) {
                continue;
            }
            auto inf = open_linput(uefiParser.files[i]->dump_name.c_str(), false);
            if (!inf) {
                msg("Unable to open file %s\n", uefiParser.files[i]->dump_name.c_str());
                continue;
            }
            peManager.process(inf, uefiParser.files[i]->dump_name.c_str(), i);
        }
    } else {
        msg("[efiXloader] Can not parse input firmware\n");
    }
}

static int idaapi move_segm(ea_t from, ea_t to, asize_t, const char *) { return 1; }

//----------------------------------------------------------------------
//
//      LOADER DESCRIPTION BLOCK
//
//----------------------------------------------------------------------
loader_t LDSC = {
    IDP_INTERFACE_VERSION,
    // loader flags
    0,
    // check input file format. if recognized, then return 1
    // and fill 'fileformatname'.
    // otherwise return 0
    accept_file,
    // load file into the database.
    load_file,
    // create output file from the database.
    // this function may be absent.
    NULL,
    // take care of a moved segment (fix up relocations, for example)
    NULL,
    NULL,
};

```

`efiXloader/efiLoader.h`:

```h
/*
 * efiXloader
 * Copyright (C) 2020-2022 Binarly
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * efiLoader.h
 */

#ifndef EFILOADER_EFILOADER_H
#define EFILOADER_EFILOADER_H

#include "ida_core.h"
#include "pe.h"
#include "pe_manager.h"
#include "uefitool.h"

extern loader_t LDSC;

//-----------------------
// definitions
//-----------------------

void idaapi load_binary(const char *fname);
void idaapi close_and_save_db(const char *fname);
void idaapi reanalyze_all(void);
void idaapi wait(void);
void idaapi idb_to_asm(const char *fname);
void idaapi clean_db(void);

void idaapi efi_til_init();

// UI

class Ui {
  public:
    Ui() { ; }
    int ask_for_single_image();
};

class driver_chooser_t : public chooser_t {
  protected:
    static const int widths_drivers[];
    static const char *const drivers_headers[];

  public:
    /* remember the addresses in this qvector */
    qvector<qstring> drivers_names;

    /* this object must be allocated using `new` */
    driver_chooser_t(const char *title, bool ok, std::vector<efiloader::File *> drivers);

    /* function that is used to decide whether a new chooser should be opened or
     * we can use the existing one. The contents of the window are completely
     * determined by its title */
    virtual const void *get_obj_id(size_t *len) const {
        *len = strlen(title);
        return title;
    }

    /* function that returns number of lines in the list */
    virtual size_t idaapi get_count() const { return drivers_names.size(); }

    /* function that generates the list line */
    virtual void idaapi get_row(qstrvec_t *cols, int *icon_, chooser_item_attrs_t *attrs,
                                size_t n) const;

    /* function that is called when the user hits Enter */
    virtual cbret_t idaapi enter(size_t n) {
        if (n < drivers_names.size())
            // jumpto(list[n]);
            return cbret_t();
    }

  protected:
    void build_list(bool ok, std::vector<efiloader::File *> files) {
        size_t n = 0;
        for (auto file : files) {
            drivers_names.push_back(qstring(file->qname));
            n++;
        }
        ok = true;
    };
};

#endif // EFILOADER_EFILOADER_H

```

`efiXloader/ida_core.h`:

```h
/*
 * efiXloader
 * Copyright (C) 2020-2022 Binarly
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * ida_core.h
 */

#ifndef EFILOADER_IDA_CORE_H
#define EFILOADER_IDA_CORE_H

#define USE_STANDARD_FILE_FUNCTIONS 1

#include <auto.hpp>
#include <bytes.hpp>
#include <diskio.hpp>
#include <entry.hpp>
#include <fixup.hpp>
#include <fpro.h>
#include <ida.hpp>
#include <idp.hpp>
#include <kernwin.hpp>
#include <loader.hpp>
#include <name.hpp>
#include <offset.hpp>
#include <pro.h>
#include <segment.hpp>
#include <segregs.hpp>

//----------------------------------

#define CLASS_CODE "CODE"
#define NAME_CODE ".text"
#define CLASS_DATA "DATA"
#define CLASS_CONST "CONST"
#define NAME_DATA ".data"
#define CLASS_BSS "BSS"
#define NAME_BSS ".bss"
#define NAME_EXTERN "extern"
#define NAME_COMMON "common"
#define NAME_ABS "abs"
#define NAME_UNDEF "UNDEF"
#define CLASS_STACK "STACK"
#define CLASS_RES16 "RESOURCE"
#define LDR_NODE "$ IDALDR node for ids loading $"
#define LDR_INFO_NODE "$ IDALDR node for unload $"

//--------------------------------------------------------------------------
template <class T>
bool _validate_array_count(linput_t *li, T *p_cnt, size_t elsize,
                           int64 current_offset = -1, int64 max_offset = -1) {
    if (current_offset == -1)
        current_offset = qltell(li);
    if (max_offset == -1)
        max_offset = qlsize(li);
    int64 rest = max_offset - current_offset;
    T cnt = *p_cnt;
    if (current_offset >= 0 && rest >= 0) {
#ifndef __X86__
        typedef size_t biggest_t;
#else
        typedef ea_t biggest_t;
#endif
        if (is_mul_ok<biggest_t>(elsize, cnt)) {
            biggest_t needed = elsize * cnt;
#ifdef __X86__
            if (needed == size_t(needed))
#endif
                if (rest >= needed)
                    return true; // all ok
        }
        cnt = rest / elsize;
    } else {
        cnt = 0;
    }
    *p_cnt = cnt;
    return false;
}

//--------------------------------------------------------------------------
// Validate a counter taken from the input file. If there are not enough bytes
// in the input file, ask the user if we may continue and fix the counter.
template <class T>
void validate_array_count(linput_t *li, T *p_cnt, size_t elsize, const char *counter_name,
                          int64 curoff = -1, int64 maxoff = -1) {
    T old = *p_cnt;
    if (!_validate_array_count(li, p_cnt, elsize, curoff, maxoff)) {
        static const char *const format =
            "AUTOHIDE SESSION\n"
            "HIDECANCEL\n"
            "%s %" FMT_64 "u is incorrect, maximum possible value is %" FMT_64 "u%s";
#ifndef __KERNEL__
        if (ask_yn(ASKBTN_YES, format, counter_name, uint64(old), uint64(*p_cnt),
                   ". Do you want to continue with the new value?") != ASKBTN_YES) {
            loader_failure(NULL);
        }
#else
        warning(format, counter_name, uint64(old), uint64(*p_cnt), "");
#endif
    }
}

//--------------------------------------------------------------------------
// Validate a counter taken from the input file. If there are not enough bytes
// in the input file, die.
template <class T>
void validate_array_count_or_die(linput_t *li, T cnt, size_t elsize,
                                 const char *counter_name, int64 curoff = -1,
                                 int64 maxoff = -1) {
    if (!_validate_array_count(li, &cnt, elsize, curoff, maxoff)) {
        static const char *const format =
            "%s is incorrect, maximum possible value is %u%s";
#ifndef __KERNEL__
        loader_failure(format, counter_name, uint(cnt), "");
#else
        error(format, counter_name, uint(cnt), "");
#endif
    }
}

//----------------------------------
inline uchar readchar(linput_t *li) {
    uchar x;
    lread(li, &x, sizeof(x));
    return x;
}

//----------------------------------
inline uint16 readshort(linput_t *li) {
    uint16 x;
    lread(li, &x, sizeof(x));
    return x;
}

//----------------------------------
inline uint32 readlong(linput_t *li) {
    uint32 x;
    lread(li, &x, sizeof(x));
    return x;
}

inline uint32 mf_readlong(linput_t *li) { return swap32(readlong(li)); }
inline uint16 mf_readshort(linput_t *li) { return swap16(readshort(li)); }

#endif // EFILOADER_IDA_CORE_H

```

`efiXloader/pe.cpp`:

```cpp
/*
 * efiXloader
 * Copyright (C) 2020-2022 Binarly
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * pe.cpp
 */

#include "pe.h"

#include <bytes.hpp>
#include <fixup.hpp>
#include <idp.hpp>
#include <map>
#include <pro.h>
#include <segregs.hpp>

#define DEBUG

#define DIRECTORIES_MAX_ID 15

std::map<uint32_t, const char *> DIRECTORIES = {
    {0, "Export Directory"},
    {1, "Import Directory"},
    {2, "Resource Directory"},
    {3, "Exception Directory"},
    {4, "Security Directory"},
    {5, "Base Relocation Table"},
    {6, "Debug Directory"},
    {7, "Architecture Specific Data"},
    {8, "RVA of GP"},
    {9, "TLS Directory"},
    {10, "Load Configuration Directory"},
    {11, "Bound Import Directory in headers"},
    {12, "Import Address Table"},
    {13, "Delay Load Import Descriptors"},
    {14, "COM Runtime descriptor"},
    {15, "Image data directory"},
};

//
// efiLoader core routines
//

qoff64_t efiloader::PE::head_start() {
    qoff64_t off = 0;
    qlseek(li, 0x3c);
    off = readshort(li);
    reset();
    return off;
}

//
// Functions to extract PE features
//

bool efiloader::PE::good() {
    uint16_t mz = 0;
    qlread(li, &mz, sizeof(uint16_t));
    if (mz != MZ_SIGN) {
        return false;
    }
    _pe_header_off = head_start();
    if (is_p32_plus()) {
        _bits = 64;
    } else if (!is_p32()) {
        loader_failure("[efiXloader] failed to guess PE bitness");
    } else {
        _bits = 32;
    }
    return is_pe();
}

bool efiloader::PE::is_p32() {
    uint16_t magic = 0;
    qlseek(li, _pe_header_off + sizeof(uint32_t));
    qlread(li, &magic, sizeof(uint16_t));
    reset();
    return magic == I386;
}

bool efiloader::PE::is_p32_plus() {
    uint16_t magic = 0;
    qlseek(li, _pe_header_off + sizeof(uint32_t));
    qlread(li, &magic, sizeof(uint16_t));
    reset();
    return magic == AMD64;
}

bool efiloader::PE::is_pe() {
    uint16_t pe_sign = 0;
    qlseek(li, _pe_header_off);
    pe_sign = readshort(li);
    reset();
    return pe_sign == PE_SIGN;
}

uint16_t efiloader::PE::arch() {
    qlseek(li, head_off + sizeof(uint32_t));
    qlread(li, &pe, sizeof(peheader_t));
    return pe.machine;
}

bool efiloader::PE::process() {
    preprocess();
    *pe_base = image_base + image_size;
    return true;
}

const char *efiloader::PE::_machine_name() {
    switch (pe64.machine) {
    case PECPU_80386:
        return "80386";
    case PECPU_80486:
        return "80486";
    case PECPU_80586:
        return "80586";
    case PECPU_SH3:
        return "SH3";
    case PECPU_SH3DSP:
        return "SH3DSP";
    case PECPU_SH3E:
        return "SH3E";
    case PECPU_SH4:
        return "SH4";
    case PECPU_SH5:
        return "SH5";
    case PECPU_ARM:
        return "ARM";
    case PECPU_ARMI:
        return "ARMI";
    case PECPU_ARMV7:
        return "ARMv7";
    case PECPU_EPOC:
        return "ARM EPOC";
    case PECPU_PPC:
        return "PPC";
    case PECPU_PPCFP:
        return "PPC FP";
    case PECPU_PPCBE:
        return "PPC BE";
    case PECPU_IA64:
        return "IA64";
    case PECPU_R3000:
        return "MIPS R3000";
    case PECPU_R4000:
        return "MIPS R4000";
    case PECPU_R6000:
        return "MIPS R6000";
    case PECPU_R10000:
        return "MIPS R10000";
    case PECPU_MIPS16:
        return "MIPS16";
    case PECPU_WCEMIPSV2:
        return "MIPS WCEv2";
    case PECPU_ALPHA:
        return "ALPHA";
    case PECPU_ALPHA64:
        return "ALPHA 64";
    case PECPU_AMD64:
        return "AMD64";
    case PECPU_ARM64:
        return "ARM64";
    case PECPU_M68K:
        return "M68K";
    case PECPU_MIPSFPU:
        return "MIPS FPU";
    case PECPU_MIPSFPU16:
        return "MIPS16 FPU";
    case PECPU_EBC:
        return "EFI Bytecode";
    case PECPU_AM33:
        return "AM33";
    case PECPU_M32R:
        return "M32R";
    case PECPU_CEF:
        return "CEF";
    case PECPU_CEE:
        return "CEE";
    case PECPU_TRICORE:
        return "TRICORE";
    }
    return NULL;
}

//
// Functions processing
//

void efiloader::PE::make_entry(ea_t ea) {
    char func_name[MAXNAMESIZE] = {0};
    ea_t new_ea = image_base + ea;
    qsnprintf(func_name, sizeof(func_name), "%s_entry_%08X", _image_name.c_str(),
              calc_file_crc32(li));
    add_entry(new_ea, new_ea, func_name, true);
    memset(func_name, 0, sizeof(func_name));
}

//
// PE image pre-processing
//

inline size_t efiloader::PE::make_named_word(ea_t ea, const char *name, const char *extra,
                                             size_t count) {
    if (extra) {
        add_extra_cmt(ea, true, extra);
    }
    create_word(ea, 2 * count);
    set_cmt(ea, name, 0);
    op_hex(ea, 0);
    return 2 * count;
}

inline size_t efiloader::PE::make_named_dword(ea_t ea, const char *name,
                                              const char *extra, size_t count) {
    if (extra) {
        add_extra_cmt(ea, true, extra);
    }
    create_word(ea, 4 * count);
    set_cmt(ea, name, 0);
    op_hex(ea, 0);
    return 4 * count;
}

inline size_t efiloader::PE::make_named_qword(ea_t ea, const char *name,
                                              const char *extra, size_t count) {
    if (extra) {
        add_extra_cmt(ea, true, extra);
    }
    create_word(ea, 8 * count);
    set_cmt(ea, name, 0);
    op_hex(ea, 0);
    return 8 * count;
}

//
// Segments processing
//

segment_t *efiloader::PE::make_head_segment(ea_t start, ea_t end,
                                            const char *section_name) {
    segment_t *seg = new segment_t;
    seg->bitness = 2;
    seg->perm = SEG_DATA;
    seg->sel = allocate_selector(0x0);
    seg->start_ea = start;
    seg->end_ea = end;
    add_segm_ex(seg, section_name, "DATA", ADDSEG_NOAA | ADDSEG_NOSREG);
    return seg;
}

segment_t *efiloader::PE::make_generic_segment(ea_t seg_ea, ea_t seg_ea_end,
                                               const char *section_name, uint32_t flags) {
    segment_t *generic_segm = new segment_t;
    generic_segm->sel = allocate_selector(0x0);
    generic_segm->start_ea = seg_ea;
    generic_segm->end_ea = seg_ea_end;
    generic_segm->bitness = 2;
    generic_segm->perm = SEGPERM_READ;
    if (flags & PEST_EXEC)
        generic_segm->perm |= SEGPERM_EXEC;
    if (flags & PEST_WRITE)
        generic_segm->perm |= SEGPERM_WRITE;

    qstring name(section_name);

    if (name.find('.') == qstring::npos) {
        name += qstring(".unkn");
    }

    if (flags & PEST_EXEC) {
        generic_segm->type = SEG_CODE;
        add_segm_ex(generic_segm, name.c_str(), "CODE", ADDSEG_NOAA);
    } else {
        generic_segm->type = SEG_DATA;
        add_segm_ex(generic_segm, name.c_str(), "DATA", ADDSEG_NOAA);
    }

    if (name == ".text") {
        code_segm_name.insert(name);
    } else if (name == ".data") {
        data_segm_name.insert(name);
        data_segment_sel = get_segm_by_name(data_segm_name.c_str())->sel;
    }

    secs_names.push_back(name);
    return generic_segm;
}

int efiloader::PE::preprocess_sections() {
    qlseek(li, _pe_header_off);
    qlread(li, &pe, sizeof(peheader_t));

    // x86
    number_of_sections = pe.nobjs;
    int section_headers_offset = pe.first_section_pos(_pe_header_off);
    headers_size = pe.allhdrsize;

    if (pe.machine == PECPU_AMD64) { // x64
        qlseek(li, _pe_header_off);
        qlread(li, &pe64, sizeof(peheader64_t));
        number_of_sections = pe64.nobjs;
        section_headers_offset = pe64.first_section_pos(_pe_header_off);
        headers_size = pe64.allhdrsize;
    }

    _sec_headers.resize(number_of_sections);
    qlseek(li, section_headers_offset);
    for (int i = 0; i < number_of_sections; i++) {
        qlread(li, &_sec_headers[i], sizeof(pesection_t));
    }

    return 0;
}

ea_t efiloader::PE::process_section_entry(ea_t next_ea) {
    create_strlit(next_ea, 8, STRTYPE_C);
    set_cmt(next_ea, "Name", 0);
    op_hex(next_ea, 0);
    size_t segm_name_len = get_max_strlit_length(next_ea, STRTYPE_C);

    if (segm_name_len) {
        get_strlit_contents(&segm_names.push_back(), next_ea, segm_name_len, STRTYPE_C);
    } else {
        // if the segm_name_len is 0, it will trigger a crash on segm_names.pop_back()
        // later.
        segm_names.push_back("UNKNOWN");
    }

    next_ea += 8;
    create_dword(next_ea, 4);
    set_cmt(next_ea, "Virtual size", 0);
    op_hex(next_ea, 0);
    segm_sizes.push_back(get_dword(next_ea));
    next_ea += 4;
    create_dword(next_ea, 4);
    set_cmt(next_ea, "Virtual address", 0);
    op_hex(next_ea, 0);
    segm_entries.push_back(get_dword(next_ea));
    next_ea += 4;
    create_dword(next_ea, 4);
    set_cmt(next_ea, "Size of raw data", 0);
    op_hex(next_ea, 0);
    segm_raw_sizes.push_back(get_dword(next_ea));
    next_ea += 4;
    create_dword(next_ea, 4);
    set_cmt(next_ea, "Pointer to raw data", 0);
    op_hex(next_ea, 0);
    next_ea += 4;
    create_dword(next_ea, 4);
    set_cmt(next_ea, "Pointer to relocations", 0);
    op_hex(next_ea, 0);
    next_ea += 4;
    create_dword(next_ea, 4);
    set_cmt(next_ea, "Pointer to line numbers", 0);
    op_hex(next_ea, 0);
    next_ea += 4;
    create_word(next_ea, 2);
    set_cmt(next_ea, "Number of relocations", 0);
    op_hex(next_ea, 0);
    next_ea += 2;
    create_word(next_ea, 2);
    set_cmt(next_ea, "Number of linenumbers", 0);
    op_hex(next_ea, 0);
    next_ea += 2;
    create_dword(next_ea, 4);
    set_cmt(next_ea, "Characteristics", 0);
    op_hex(next_ea, 0);
    uint32_t section_characteristics = get_dword(next_ea);
    next_ea += 4;

    qstring section_name = qstring(_image_name.c_str());
    section_name += qstring("_") + qstring(segm_names[0].c_str());

    ea_t seg_ea = image_base + segm_entries[0];
    ea_t seg_ea_end = seg_ea + segm_raw_sizes[0];
    msg("[efiXloader]\tprocessing: %s\n", segm_names[0].c_str());

    segments.push_back(make_generic_segment(seg_ea, seg_ea_end, section_name.c_str(),
                                            section_characteristics));
    segm_names.pop_back();
    segm_sizes.pop_back();
    segm_raw_sizes.pop_back();
    segm_entries.pop_back();
    return next_ea;
}

void efiloader::PE::setup_ds_selector() {
    for (; !secs_names.empty(); secs_names.pop_back()) {
        msg("[efiXloader]\tsetting DS ( %#x ) for %s segment\n", data_segment_sel,
            secs_names[secs_names.size() - 1].c_str());
        segment_t *seg = get_segm_by_name(secs_names[secs_names.size() - 1].c_str());
        set_default_sreg_value(seg, str2reg("DS"), data_segment_sel);
    }
}

//
// PE core processing
//

void efiloader::PE::preprocess() {
    char seg_name[MAXNAMESIZE] = {0};
    char seg_header_name[MAXNAMESIZE] = {0};
    char image_base_name[MAXNAMESIZE] = {0};
    char section_name[MAXNAMESIZE] = {0};
    ea_t next_ea = 0;
    ea_t ea = align_up(*pe_base, PAGE_SIZE);
    image_base = ea;
    ea_t start = ea;
    ea_t end = ea + qlsize(li);
    qsnprintf(seg_name, sizeof(seg_name), "%s_%08X", _image_name.c_str(),
              calc_file_crc32(li));
    qsnprintf(seg_header_name, sizeof(seg_header_name), "%s_HEADER", _image_name.c_str());
    qsnprintf(image_base_name, sizeof(image_base_name), "%s_IMAGE_BASE",
              _image_name.c_str());

    preprocess_sections();
    push_to_idb(start, end);
    segments.push_back(
        make_head_segment(image_base, image_base + headers_size, seg_header_name));
    secs_names.push_back(qstring(seg_header_name));
    create_word(ea, 2);
    set_cmt(ea, "PE magic number", 0);
    op_hex(ea, 0);
    create_word(ea + 2, 2);
    set_cmt(ea + 2, "Bytes on last page of file", 0);
    op_hex(ea + 2, 0);
    create_word(ea + 4, 2);
    set_cmt(ea + 4, "Pages in file", 0);
    op_hex(ea + 4, 0);
    create_word(ea + 6, 2);
    set_cmt(ea + 6, "Relocations", 0);
    op_hex(ea + 6, 0);
    create_word(ea + 8, 2);
    set_cmt(ea + 8, "Size of header in paragraphs", 0);
    op_hex(ea + 8, 0);
    create_word(ea + 10, 2);
    set_cmt(ea + 10, "Minimum extra paragraphs needed", 0);
    op_hex(ea + 10, 0);
    create_word(ea + 10, 2);
    set_cmt(ea + 12, "Maximum extra paragraphs needed", 0);
    op_hex(ea + 12, 0);
    create_word(ea + 14, 2);
    set_cmt(ea + 14, "Initial (relative) SS value", 0);
    op_hex(ea + 12, 0);
    create_word(ea + 16, 2);
    set_cmt(ea + 16, "Initial SP value", 0);
    op_hex(ea + 16, 0);
    create_word(ea + 18, 2);
    set_cmt(ea + 18, "Checksum", 0);
    op_hex(ea + 18, 0);
    create_word(ea + 20, 2);
    set_cmt(ea + 20, "Initial IP value", 0);
    op_hex(ea + 20, 0);
    create_word(ea + 22, 2);
    set_cmt(ea + 22, "Initial (relative) CS value", 0);
    op_hex(ea + 22, 0);
    create_word(ea + 24, 2);
    set_cmt(ea + 24, "File address of relocation table", 0);
    op_hex(ea + 24, 0);
    op_offset(ea + 24, 0, REF_OFF64, BADADDR, image_base);
    create_word(ea + 26, 2);
    set_cmt(ea + 26, "Overlay number", 0);
    op_hex(ea + 26, 0);
    create_word(ea + 28, 8);
    set_cmt(ea + 28, "Reserved words", 0);
    op_hex(ea + 28, 0);
    create_word(ea + 36, 2);
    set_cmt(ea + 36, "OEM identifier (for e_oeminfo)", 0);
    op_hex(ea + 36, 0);
    create_word(ea + 38, 2);
    set_cmt(ea + 38, "OEM information; e_oemid specific", 0);
    op_hex(ea + 38, 0);
    create_word(ea + 40, 2);
    set_cmt(ea + 40, "Reserved words", 0);
    op_hex(ea + 38, 0);
    ea_t old_ea = ea;
    ea = ea + 0x3c;
    create_dword(ea, 4);
    if (is_loaded(ea) && get_dword(ea)) {
        msg("[efiXloader] making relative offset: %#x\n", ea);
        op_plain_offset(ea, 0, *pe_base);
    }
    set_cmt(ea, "File address of new exe header", 0);
    uint32_t nt_headers_off = get_dword(ea);
    create_byte(old_ea + 0x40, nt_headers_off - 0x40);
    set_cmt(old_ea + 0x40, "DOS Stub code", 0);
    ea_t nt_headers_ea = old_ea + nt_headers_off;
    add_extra_cmt(nt_headers_ea, 1, "IMAGE_NT_HEADERS");
    switch (get_word(old_ea)) {
    case 0x20B:
        del_items(nt_headers_ea, 3, 0x108);
        break;
    default:
        del_items(nt_headers_ea, 3, 0xf8);
        break;
    }
    create_dword(nt_headers_ea, 4);
    set_cmt(nt_headers_ea, "Signature", 0);
    op_hex(nt_headers_ea, 0);
    ea_t image_file_header_ea = nt_headers_ea + 4;
    add_extra_cmt(image_file_header_ea, 1, "IMAGE_FILE_HEADER");
    create_word(image_file_header_ea, 2);
    set_cmt(image_file_header_ea, "Machine", 0);
    op_hex(image_file_header_ea, 0);
    image_file_header_ea += 2;
    create_word(image_file_header_ea, 2);
    set_cmt(image_file_header_ea, "Number of sections", 0);
    number_of_sections = get_word(image_file_header_ea);
    op_hex(image_file_header_ea, 0);
    ea_t timestamp_ea = image_file_header_ea + 2;
    create_dword(timestamp_ea, 4);
    set_cmt(timestamp_ea, "Time stamp", 0);
    ea_t pointer_to_symbol_table = timestamp_ea + 4;
    create_dword(pointer_to_symbol_table, 4);
    set_cmt(pointer_to_symbol_table, "Pointer to symbol table", 0);
    op_hex(pointer_to_symbol_table, 0);
    next_ea = pointer_to_symbol_table + 4;
    create_dword(next_ea, 4);
    set_cmt(next_ea, "Number of symbols", 0);
    op_hex(next_ea, 0);
    next_ea += 4;
    uint16_t size_of_optional_header = get_word(next_ea);
    create_word(next_ea, 2);
    set_cmt(next_ea, "Size of optional header", 0);
    op_hex(next_ea, 0);
    next_ea += 2;
    create_word(next_ea, 2);
    set_cmt(next_ea, "Characteristics", 0);
    op_hex(next_ea, 0);
    next_ea += 2;
    add_extra_cmt(next_ea, 1, "IMAGE_OPTIONAL_HEADER");
    ea_t image_optional_header = next_ea;
    create_word(next_ea, 2);
    set_cmt(next_ea, "Magic number", 0);
    op_hex(next_ea, 0);
    next_ea += 2;
    create_byte(next_ea, 1);
    set_cmt(next_ea, "Major linker version", 0);
    op_hex(next_ea, 0);
    next_ea += 1;
    create_byte(next_ea, 1);
    set_cmt(next_ea, "Minor linker version", 0);
    op_hex(next_ea, 0);
    next_ea += 1;
    create_dword(next_ea, 4);
    set_cmt(next_ea, "Size of code", 0);
    op_hex(next_ea, 0);
    next_ea += 4;
    create_dword(next_ea, 4);
    set_cmt(next_ea, "Size of initialized data", 0);
    op_hex(next_ea, 0);
    next_ea += 4;
    create_dword(next_ea, 4);
    set_cmt(next_ea, "Size of uninitialized data", 0);
    op_hex(next_ea, 0);
    next_ea += 4;
    create_dword(next_ea, 4);
    set_cmt(next_ea, "Address of entry point", 0);
    make_entry(get_dword(next_ea));
    refinfo_t ri;
    ri.init(REF_OFF64, image_base);
    if (is_loaded(next_ea) && get_dword(next_ea)) {
        op_offset_ex(next_ea, 0, &ri);
    }
    next_ea += 4;
    create_dword(next_ea, 4);
    if (is_loaded(next_ea) && get_dword(next_ea)) {
        op_offset_ex(next_ea, 0, &ri);
    }
    set_cmt(next_ea, "Base of code", 0);
    next_ea += 4;
    uint64_t default_image_base = get_qword(next_ea);
    create_qword(next_ea, 8);
    set_cmt(next_ea, "Image base", 0);
    op_hex(next_ea, 0);
    op_plain_offset(next_ea, 0, *pe_base);
    next_ea += 8;
    create_dword(next_ea, 4);
    set_cmt(next_ea, "Section alignment", 0);
    op_hex(next_ea, 0);
    next_ea += 4;
    create_dword(next_ea, 4);
    set_cmt(next_ea, "File alignment", 0);
    op_hex(next_ea, 0);
    next_ea += 4;
    create_word(next_ea, 2);
    set_cmt(next_ea, "Major operating system version", 0);
    op_hex(next_ea, 0);
    next_ea += 2;
    create_word(next_ea, 2);
    set_cmt(next_ea, "Minor operating system version", 0);
    op_hex(next_ea, 0);
    next_ea += 2;
    create_word(next_ea, 2);
    set_cmt(next_ea, "Major image version", 0);
    op_hex(next_ea, 0);
    next_ea += 2;
    create_word(next_ea, 2);
    set_cmt(next_ea, "Minor image version", 0);
    op_hex(next_ea, 0);
    next_ea += 2;
    create_word(next_ea, 2);
    set_cmt(next_ea, "Major subsystem version", 0);
    op_hex(next_ea, 0);
    next_ea += 2;
    create_word(next_ea, 2);
    set_cmt(next_ea, "Minor subsystem version", 0);
    op_hex(next_ea, 0);
    next_ea += 2;
    create_dword(next_ea, 4);
    set_cmt(next_ea, "Win32 Version value", 0);
    op_hex(next_ea, 0);
    next_ea += 4;
    create_dword(next_ea, 4);
    set_cmt(next_ea, "Size of image", 0);
    op_hex(next_ea, 0);
    image_size = get_dword(next_ea);
    next_ea += 4;
    create_dword(next_ea, 4);
    set_cmt(next_ea, "Size of headers", 0);
    op_hex(next_ea, 0);
    next_ea += 4;
    create_dword(next_ea, 4);
    set_cmt(next_ea, "Checksum", 0);
    op_hex(next_ea, 0);
    next_ea += 4;
    create_word(next_ea, 2);
    set_cmt(next_ea, "Subsystem", 0);
    op_hex(next_ea, 0);
    next_ea += 2;
    create_word(next_ea, 2);
    set_cmt(next_ea, "Dll characteristics", 0);
    op_hex(next_ea, 0);
    next_ea += 2;
    create_qword(next_ea, 8);
    set_cmt(next_ea, "Size of stack reserve", 0);
    op_hex(next_ea, 0);
    next_ea += 8;
    create_qword(next_ea, 8);
    set_cmt(next_ea, "Size of stack commit", 0);
    op_hex(next_ea, 0);
    next_ea += 8;
    create_qword(next_ea, 8);
    set_cmt(next_ea, "Size of heap reserve", 0);
    op_hex(next_ea, 0);
    next_ea += 8;
    create_qword(next_ea, 8);
    set_cmt(next_ea, "Size of heap commit", 0);
    op_hex(next_ea, 0);
    next_ea += 8;
    create_dword(next_ea, 4);
    set_cmt(next_ea, "Loader flag", 0);
    op_hex(next_ea, 0);
    next_ea += 4;
    create_dword(next_ea, 4);
    set_cmt(next_ea, "Number of data directories", 0);
    op_hex(next_ea, 0);
    while (!is_loaded(next_ea)) {
        continue;
    }
    number_of_dirs = get_dword(next_ea);
    uint32_t va = 0;
    uint32_t size = 0;
    next_ea += 4;
    for (int i = 0; i < number_of_dirs; i++) {
        if (is_reloc_dir(i)) {
            uint32_t relocs_rva = get_dword(next_ea);
            uint32_t relocs_size = get_dword(next_ea + 4);
            if (relocs_rva && relocs_size) {
                ea_t relocs_va = image_base + relocs_rva;
                ea_t relocs_va_end = relocs_va + relocs_size;
                ea_t delta = image_base - default_image_base;
                ea_t block_addr = get_dword(relocs_va);
                ea_t block_size = get_dword(relocs_va + 4);
                while (block_size && relocs_va < relocs_va_end) {
                    ea_t block_base = image_base + block_addr;
                    int block_reloc_count = (block_size - 8) / 2;

                    ea_t block_ptr = relocs_va + 8;
                    while (block_reloc_count--) {
                        uint16_t reloc_value = get_word(block_ptr);
                        uint16_t type = reloc_value & PER_TYPE;
                        uint16_t offset = reloc_value & PER_OFF;
                        if (type == PER_DIR64)
                            add_qword(block_base + offset, delta);
                        else if (type == PER_HIGHLOW)
                            add_dword(block_base + offset, (uint32_t)delta);
                        else if (type == PER_HIGH)
                            add_word(block_base + offset, (uint16_t)(delta >> 16));
                        else if (type == PER_LOW)
                            add_word(block_base + offset, (uint16_t)delta);
                        block_ptr += 2;
                    }
                    relocs_va += block_size;

                    block_addr = get_dword(relocs_va);
                    block_size = get_dword(relocs_va + 4);
                }
            }
        }
        if (is_reloc_dir(i) || is_debug_dir(i)) {
            add_extra_cmt(next_ea, true, DIRECTORIES[i]);
            create_dword(next_ea, 4);
            create_dword(next_ea + 4, 4);
            ;
            op_hex(next_ea, 0);
            op_hex(next_ea + 4, 0);
            set_cmt(next_ea, "Virtual address", 0);
            set_cmt(next_ea + 4, "Size", 0);
        } else {
            create_qword(next_ea, 8);
            set_cmt(next_ea, DIRECTORIES[i], 0);
        }
        next_ea += 8;
    }
    del_items(next_ea, DELIT_EXPAND | DELIT_DELNAMES, 0x28 * number_of_sections);
    for (int i = 0; i < number_of_sections; i++) {
        next_ea = process_section_entry(next_ea);
        memset(seg_name, 0, sizeof(seg_name));
        memset(seg_header_name, 0, sizeof(seg_name));
        memset(image_base_name, 0, sizeof(seg_name));
        memset(section_name, 0, sizeof(seg_name));
    }
}

```

`efiXloader/pe.h`:

```h
/*
 * efiXloader
 * Copyright (C) 2020-2022 Binarly
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * pe.h
 */

#ifndef EFILOADER_PE_H
#define EFILOADER_PE_H

//
// IDA header
//
#include "ida_core.h"
#include "pe_ida.h"
//
// Utilities
//
#include "utils.h"

#include <typeinf.hpp>

#define PAGE_SIZE 0x1000

#define MZ_SIGN 0x5A4D       // MZ header
#define MAGIC_P32 0x10B      // Normal PE file
#define MAGIC_P32_PLUS 0x20B // 64-bit image
#define PE_SIGN 0x4550       // PE signature

namespace efiloader {

class PE {
  public:
    PE(linput_t *i_li, std::basic_string<char> fname, ea_t *base, ushort *sel_base,
       int ord) {
        _image_name = fname.substr(fname.find_last_of("/\\") + 1);
        msg("[efiXloader] image name is %s\n", _image_name.c_str());
        pe_base = base;
        pe_sel_base = sel_base;
        li = i_li;
        utils = new Utils;
        _sec_off = 0;
        _sec_ea = 0;
        _sel = 0;
        _ord = ord;
        inf_set_64bit();
        set_processor_type("metapc", SETPROC_LOADER);
        if (default_compiler() == COMP_UNK)
            set_compiler_id(COMP_MS);
        reset();
    };
    ~PE() {
        close_linput(li);
        delete utils;
    }
    uint32_t number_of_sections;
    uint32_t number_of_dirs;
    char *name;
    bool is_reloc_dir(uint32_t i) { return i == 5; };
    bool is_debug_dir(uint32_t i) { return i == 6; };
    void set_64_bit_segm_and_rabase(ea_t ea) {
        segment_t *tmp_seg = getseg(ea);
        set_segm_addressing(tmp_seg, 2);
        set_segm_base(tmp_seg, *pe_base);
    }
    void set_64_bit(ea_t ea) {
        segment_t *tmp_seg = getseg(ea);
        set_segm_addressing(tmp_seg, 2);
    };
    bool is_p32();
    bool is_p32_plus();
    bool is_pe();
    bool good();
    bool process();
    uint16_t arch();
    // data processing
    inline size_t make_named_byte(ea_t ea, const char *name, const char *extra = NULL,
                                  size_t count = 1);
    inline size_t make_named_word(ea_t ea, const char *name, const char *extra = NULL,
                                  size_t count = 1);
    inline size_t make_named_dword(ea_t ea, const char *name, const char *extra = NULL,
                                   size_t count = 1);
    inline size_t make_named_qword(ea_t ea, const char *name, const char *extra = NULL,
                                   size_t count = 1);
    inline ea_t skip(ea_t ea, qoff64_t off) { return ea + off; };
    // ida db processing
    void push_to_idb(ea_t start, ea_t end) {
        // Map header
        file2base(li, 0x0, start, start + headers_size, FILEREG_PATCHABLE);
        // Map sections
        for (int i = 0; i < number_of_sections; i++) {
            file2base(li, _sec_headers[i].s_scnptr, start + _sec_headers[i].s_vaddr,
                      start + _sec_headers[i].s_vaddr + _sec_headers[i].s_psize,
                      FILEREG_PATCHABLE);
        }
    };

  private:
    qvector<ea_t> segments_ea;
    std::basic_string<char> _full_path;
    std::basic_string<char> _image_name;
    efiloader::Utils *utils;
    linput_t *li;
    qoff64_t head_start();
    qoff64_t head_off;
    qoff64_t _pe_header_off;
    uint16_t headers_size;
    peheader_t pe;
    peheader64_t pe64;
    uint16_t _sec_num;
    uint16_t _bits;
    qvector<sel_t> selectors;
    qvector<sel_t> data_selectors;
    qvector<qstring> ds_seg_names;
    qvector<qstring> cs_seg_names;
    void reset() { qlseek(li, 0); };
    const char *_machine_name();
    //
    // PE image preprocessing
    //
    void preprocess();
    //
    // sections processing
    //
    qvector<pesection_t> _sec_headers;
    ea_t *pe_base;
    ushort *pe_sel_base;
    ushort _sel;
    ea_t _sec_off;
    ea_t _sec_ea;
    // pe ord
    uval_t _ord;
    ea_t image_base;
    uint32_t image_size;
    qvector<size_t> segm_sizes;
    qvector<size_t> segm_raw_sizes;
    qvector<ea_t> segm_entries;

    int preprocess_sections();
    //
    // functions processing
    //
    void make_entry(ea_t ea);
    void make_code(ea_t ea);
    //
    // segments processing
    //
    qstring code_segm_name;
    qstring data_segm_name;
    sel_t data_segment_sel;
    qvector<segment_t *> segments;
    qvector<qstring> segm_names;
    qvector<qstring> secs_names;
    ea_t process_section_entry(ea_t ea);
    segment_t *make_generic_segment(ea_t seg_ea, ea_t seg_ea_end,
                                    const char *section_name, uint32_t flags);
    segment_t *make_head_segment(ea_t start, ea_t end, const char *name);
    void setup_ds_selector();
};
} // namespace efiloader

enum machine_type { AMD64 = 0x8664, I386 = 0x014C };

#endif // EFILOADER_PE_H

```

`efiXloader/pe_ida.h`:

```h
/*
 * efiXloader
 * Copyright (C) 2020-2022 Binarly
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * pe_ida.h
 */

#ifndef EFILOADER_PE_IDA_H
#define EFILOADER_PE_IDA_H

/*
 *      Interactive disassembler (IDA).
 *      Version 3.05
 *      Copyright (c) 1990-95 by Ilfak Guilfanov. (2:5020/209@fidonet)
 *      ALL RIGHTS RESERVED.
 *
 */

//
//      Portable Executable file format (MS Windows 95, MS Windows NT)
//

#include "ida_core.h"
#include <stddef.h>
#include <time.h>

#pragma pack(push, 1)
//-----------------------------------------------------------------------
//
// 32-bit Portable EXE Header
//
//-----------------------------------------------------------------------
struct petab_t {
    uint32 rva;  // relative virtual address
    uint32 size; // size
};               // PE va/size array element

template <class pointer_t> struct peheader_tpl {
    int32 signature; // 00 Current value is "PE/0/0".

#define PEEXE_ID 0x4550    // 'PE' followed by two zeroes
#define BPEEXE_ID 0x455042 // Borland's extenson for DPMI'host
#define PLEXE_ID                                                                         \
    0x4C50 // 'PL', PharLap TNT DOS-Extender Lite file that uses real mode APIs
#define TEEXE_ID 0x5A56      // 'VZ', EFI Terse Executable
    uint16 machine;          // 04 This field specifies the type of CPU
                             // compatibility required by this image to run.
                             // The values are:
#define PECPU_UNKNOWN 0x0000 // unknown

#define PECPU_80386 0x014C // 80386
#define PECPU_80486 0x014D // 80486
#define PECPU_80586 0x014E // 80586

#define PECPU_R3000 0x0162     // MIPS Mark I (R2000, R3000)
#define PECPU_R6000 0x0163     // MIPS Mark II (R6000)
#define PECPU_R4000 0x0166     // MIPS Mark III (R4000)
#define PECPU_R10000 0x0168    // MIPS Mark IV (R10000)
#define PECPU_WCEMIPSV2 0x0169 // MIPS little-endian WCE v2
#define PECPU_MIPS16 0x0266    // MIPS16
#define PECPU_MIPSFPU 0x0366   // MIPS with FPU
#define PECPU_MIPSFPU16 0x0466 // MIPS16 with FPU

#define PECPU_ALPHA 0x0184   // DEC Alpha
#define PECPU_ALPHA64 0x0284 // Dec Alpha 64-bit

#define PECPU_SH3 0x01A2    // SH3
#define PECPU_SH3DSP 0x01A3 // SH3DSP
#define PECPU_SH3E 0x01A4   // SH3E
#define PECPU_SH4 0x01A6    // SH4
#define PECPU_SH5 0x01A8    // SH5

#define PECPU_ARM 0x01C0   // ARM
#define PECPU_ARMI 0x01C2  // ARM with Thumb
#define PECPU_ARMV7 0x01C4 // ARMv7 (or higher) Thumb mode only

#define PECPU_AM33 0x01D3 // Matsushita (Panasonic) AM33/MN10300

#define PECPU_PPC 0x01F0   // PowerPC
#define PECPU_PPCFP 0x01F1 // PowerPC with floating-point
#define PECPU_PPCBE 0x01F2 // PowerPC Big-Endian

#define PECPU_M32R 0x9041 // M32R little-endian

#define PECPU_IA64 0x0200    // Intel Itanium IA64
#define PECPU_EPOC 0x0A00    // ARM EPOC
#define PECPU_AMD64 0x8664   // AMD64 (x64)
#define PECPU_ARM64 0xaa64   // ARMv8 in 64-bit mode
#define PECPU_M68K 0x0268    // Motorola 68000 series
#define PECPU_EBC 0x0EBC     // EFI Bytecode
#define PECPU_CEF 0x0CEF     // ?
#define PECPU_CEE 0xC0EE     // ?
#define PECPU_TRICORE 0x0520 // TRICORE (Infineon)

    bool is_64bit_cpu(void) const {
        return machine == PECPU_AMD64 || machine == PECPU_IA64 || machine == PECPU_ARM64;
    }
    bool is_pc(void) const {
        return machine == PECPU_80386 || machine == PECPU_80486 ||
               machine == PECPU_80586 || machine == PECPU_AMD64;
    }
    bool is_mips(void) const {
        return machine == PECPU_R3000 || machine == PECPU_R6000 ||
               machine == PECPU_R4000 || machine == PECPU_R10000 ||
               machine == PECPU_WCEMIPSV2 || machine == PECPU_MIPS16 ||
               machine == PECPU_MIPSFPU || machine == PECPU_MIPSFPU16;
    }

    bool is_arm(void) const {
        return machine == PECPU_ARM || machine == PECPU_ARMI || machine == PECPU_ARMV7;
    }

    bool has_code16_bit(void) const { return is_arm() || is_mips(); }

    uint16 nobjs; // 06 This field specifies the number of entries
    // in the Object Table.
    qtime32_t datetime; // 08 Used to store the time and date the file was
    // created or modified by the linker.
    uint32 symtof;  // 0C Symbol Table Offset
    uint32 nsyms;   // 10 Number of Symbols in Symbol Table
    uint16 hdrsize; // 14 This is the number of remaining bytes in the NT
    // header that follow the FLAGS field.
    uint16 flags;        // 16 Flag bits for the image.  0000h Program image.
#define PEF_BRVHI 0x8000 // Big endian: MSB precedes LSB in memory
#define PEF_UP 0x4000    // File should be run only on a UP machine
#define PEF_DLL 0x2000   // Dynamic Link Library (DLL)
#define PEF_SYS 0x1000   // System file
#define PEF_NSWAP                                                                        \
    0x0800 // If the image is on network media, fully load it and copy it to the
           // swap file.
#define PEF_SWAP                                                                         \
    0x0400               // If image is on removable media,
                         // copy and run from swap file
#define PEF_NODEB 0x0200 // Debugging info stripped
#define PEF_32BIT 0x0100 // 32-bit word machine
#define PEF_BRVLO 0x0080 // Little endian: LSB precedes MSB in memory
#define PEF_16BIT 0x0040 // 16-bit word machine
#define PEF_2GB 0x0020   // App can handle > 2gb addresses
#define PEF_TMWKS 0x0010 // Aggressively trim working set
#define PEF_NOSYM 0x0008 // Local symbols stripped
#define PEF_NOLIN 0x0004 // Line numbers stripped
#define PEF_EXEC 0x0002  // Image is executable
#define PEF_NOFIX 0x0001 // Relocation info stripped

    int32 first_section_pos(int32 peoff) const {
        return peoff + offsetof(peheader_tpl, magic) + hdrsize;
    }

    // COFF fields:

    uint16 magic;            // 18 Magic
#define MAGIC_ROM 0x107      // ROM image
#define MAGIC_P32 0x10B      // Normal PE file
#define MAGIC_P32_PLUS 0x20B // 64-bit image
    bool is_pe_plus(void) const { return magic == MAGIC_P32_PLUS; }
    uchar vstamp_major; // 1A Major Linker Version
    uchar vstamp_minor; // 1B Minor Linker Version
    uint32 tsize;       // 1C TEXT size (padded)
    uint32 dsize;       // 20 DATA size (padded)
    uint32 bsize;       // 24 BSS  size (padded)
    uint32 entry;       // 28 Entry point
    uint32 text_start;  // 2C Base of text
    union {
        struct {
            uint32 data_start; // 30 Base of data

            // Win32/NT extensions:

            uint32 imagebase32; // 34 Virtual base of the image.
        };
        uint64 imagebase64;
    };
    uint64 imagebase() const {
        if (is_pe_plus())
            return imagebase64;
        else
            return imagebase32;
    }
    // This will be the virtual address of the first
    // byte of the file (Dos Header).  This must be
    // a multiple of 64K.
    uint32 objalign; // 38 The alignment of the objects. This must be a power
    // of 2 between 512 and 256M inclusive. The default
    // is 64K.
    uint32 filealign; // 3C Alignment factor used to align image pages.
                      // The alignment factor (in bytes) used to align the
                      // base of the image pages and to determine the
                      // granularity of per-object trailing zero pad.
                      // Larger alignment factors will cost more file space;
                      // smaller alignment factors will impact demand load
                      // performance, perhaps significantly. Of the two,
                      // wasting file space is preferable.  This value
                      // should be a power of 2 between 512 and 64K inclusive.
                      // Get the file position aligned:
#define FILEALIGN 512 // IDA5.1: it seems that for standard object alignment (if 4096)
    // the Windows kernel does not use filealign
    // (just checks that it is in the valid range) but uses 512
    uint32 get_align_mask(void) const {
        return ((objalign == 4096 || filealign == 0) ? FILEALIGN : filealign) - 1;
    }
    uint32 align_up_in_file(uint32 pos) const {
        if (is_efi()) // apparently EFI images are not aligned
            return pos;
        uint32 mask = get_align_mask();
        return (pos + mask) & ~mask;
    }
    uint32 align_down_in_file(uint32 pos) const {
        return is_efi() ? pos : (pos & ~get_align_mask());
    }
    uint16 osmajor;     // 40 OS version number required to run this image.
    uint16 osminor;     // 42 OS version number required to run this image.
    uint16 imagemajor;  // 44 User major version number.
    uint16 imageminor;  // 46 User minor version number.
    uint16 subsysmajor; // 48 Subsystem major version number.
    uint16 subsysminor; // 4A Subsystem minor version number.

    uint32 subsystem_version(void) const { return (subsysmajor << 16) | subsysminor; }

    uint32 reserved;  // 4C
    uint32 imagesize; // 50 The virtual size (in bytes) of the image.
    // This includes all headers.  The total image size
    // must be a multiple of Object Align.
    uint32 allhdrsize; // 54 Total header size. The combined size of the Dos
    // Header, PE Header and Object Table.
    uint32 checksum;       // 58 Checksum for entire file.  Set to 0 by the linker.
    uint16 subsys;         // 5C NT Subsystem required to run this image.
#define PES_UNKNOWN 0x0000 // Unknown
#define PES_NATIVE 0x0001  // Native
#define PES_WINGUI 0x0002  // Windows GUI
#define PES_WINCHAR 0x0003 // Windows Character
#define PES_OS2CHAR 0x0005 // OS/2 Character
#define PES_POSIX 0x0007   // Posix Character
#define PES_NAT9x 0x0008   // image is a native Win9x driver
#define PES_WINCE 0x0009   // Runs on Windows CE.
#define PES_EFI_APP 0x000A // EFI application.
#define PES_EFI_BDV 0x000B // EFI driver that provides boot services.
#define PES_EFI_RDV 0x000C // EFI driver that provides runtime services.
#define PES_EFI_ROM 0x000D // EFI ROM image
#define PES_XBOX 0x000E    // Xbox system
#define PES_BOOTAPP 0x0010 // Windows Boot Application

    bool is_efi(void) const {
        return subsys == PES_EFI_APP || subsys == PES_EFI_BDV || subsys == PES_EFI_RDV ||
               subsys == PES_EFI_ROM;
    }
    bool is_console_app(void) const {
        return subsys == PES_WINCHAR || subsys == PES_OS2CHAR || subsys == PES_POSIX;
    }
    bool is_userland(void) const {
        return subsys == PES_WINGUI || subsys == PES_WINCHAR || subsys == PES_OS2CHAR ||
               subsys == PES_POSIX || subsys == PES_WINCE;
    }
    uint16 dllflags;     // 5E Indicates special loader requirements.
#define PEL_PINIT 0x0001 // Per-Process Library Initialization.
#define PEL_PTERM 0x0002 // Per-Process Library Termination.
#define PEL_TINIT 0x0004 // Per-Thread Library Initialization.
#define PEL_TTERM 0x0008 // Per-Thread Library Termination.
#define PEL_HIGH_ENT                                                                     \
    0x0020 // Image can handle a high entropy 64-bit virtual address space.
#define PEL_DYNAMIC_BASE 0x0040    // The DLL can be relocated at load time.
#define PEL_FORCE_INTEGRITY 0x0080 // Code integrity checks are forced.
#define PEF_NX 0x0100 // The image is compatible with data execution prevention (DEP).
#define PEF_NO_ISOLATION                                                                 \
    0x0200 // The image is isolation aware, but should not be isolated.
#define PEF_NO_SEH                                                                       \
    0x0400 // The image does not use structured exception handling (SEH). No
           // handlers can be called in this image.
#define PEL_NO_BIND 0x0800      // Do not bind image
#define PEL_APPCONTAINER 0x1000 // Image should execute in an AppContainer
#define PEL_WDM_DRV 0x2000      // Driver is a WDM Driver
#define PEL_GUARDCF 0x4000      // Image supports Control Flow Guard checking
#define PEL_TSRVAWA 0x8000      // Image is Terminal Server aware

    pointer_t stackres; // 60 Stack size needed for image. The memory is
    // reserved, but only the STACK COMMIT SIZE is
    // committed. The next page of the stack is a
    // 'guarded page'. When the application hits the
    // guarded page, the guarded page becomes valid,
    // and the next page becomes the guarded page.
    // This continues until the RESERVE SIZE is reached.
    pointer_t stackcom; // 64 Stack commit size.
    pointer_t heapres;  // 68 Size of local heap to reserve.
    pointer_t heapcom;  // 6C Amount to commit in local heap.
    uint32 loaderflags; // 70 ?
    uint32 nrvas;       // 74 Indicates the size of the VA/SIZE array
    // that follows.
    petab_t expdir; // 0 78 Export Directory
    petab_t impdir; // 1 80 Import Directory
    petab_t resdir; // 2 88 Resource Directory
    petab_t excdir; // 3 90 Exception Directory
    petab_t secdir; // 4 98 Security Directory
    //      The Certificate Table entry points to a table of
    //      attribute certificates. These certificates are not
    //      loaded into memory as part of the image. As such,
    //      the first field of this entry, which is normally
    //      an RVA, is a File Pointer instead
    petab_t reltab; // 5 A0 Relocation Table
    petab_t debdir; // 6 A8 Debug Directory
    petab_t desstr; // 7 B0 Description String
    petab_t cputab; // 8 B8 Machine Value
    petab_t tlsdir; // 9 C0 TLS Directory
    petab_t loddir; // 10 Load Configuration Directory
    petab_t bimtab; // 11 Bound Import Table address and size.
    petab_t iat;    // 12 Import Address Table address and size.
    petab_t didtab; // 13 Address and size of the Delay Import Descriptor.
    petab_t comhdr; // 14 COM+ Runtime Header address and size
    petab_t x00tab; // 15 Reserved

    bool is_te() const { return signature == TEEXE_ID; }
    inline bool has_debdir() const;
};

typedef peheader_tpl<uint32> peheader_t;
typedef peheader_tpl<uint64> peheader64_t;

const size_t total_rvatab_size = sizeof(peheader_t) - offsetof(peheader_t, expdir);
const size_t total_rvatab_count = total_rvatab_size / sizeof(petab_t);

//-----------------------------------------------------------------------
struct diheader_t {
    uint16 signature; // 00 Current value is "DI"
#define DBG_ID 0x4944
    uint16 flags2; // 02 ?? pedump mentions about this
    //    I've never seen something other than 0
    uint16 machine; // 04 This field specifies the type of CPU
    //    compatibility required by this image to run.
    uint16 flags;       // 06 Flag bits for the image.
    qtime32_t datetime; // 08 Used to store the time and date the file was
    //    created or modified by the linker.
    uint32 checksum;  // 12 Checksum
    uint32 imagebase; // 16 Virtual base of the image.
    //    This will be the virtual address of the first
    //    byte of the file (Dos Header).  This must be
    //    a multiple of 64K.
    uint32 imagesize; // 20 The virtual size (in bytes) of the image.
    //    This includes all headers.  The total image size
    //    must be a multiple of Object Align.
    uint32 n_secs;        // 24 Number of sections
    uint32 exp_name_size; // 28 Exported Names Size
    uint32 dbg_dir_size;  // 32 Debug Directory Size
    uint32 reserved[3];   // 36 Reserved fields
};

//-------------------------------------------------------------------------
//
//      S E C T I O N S
//
struct pesection_t {
    char s_name[8];            /* section name */
    uint32 s_vsize;            /* virtual size */
    uint32 s_vaddr;            /* virtual address */
    uint32 s_psize;            /* physical size */
    int32 s_scnptr;            /* file ptr to raw data for section */
    int32 s_relptr;            /* file ptr to relocation */
    int32 s_lnnoptr;           /* file ptr to line numbers */
    uint16 s_nreloc;           /* number of relocation entries */
    uint16 s_nlnno;            /* number of line number entries */
    int32 s_flags;             /* flags */
#define PEST_REG 0x00000000    // obsolete: regular: allocated, relocated, loaded
#define PEST_DUMMY 0x00000001  // obsolete: dummy: not allocated, relocated, not loaded
#define PEST_NOLOAD 0x00000002 // obsolete: noload: allocated, relocated, not loaded
#define PEST_GROUP 0x00000004  // obsolete: grouped: formed of input sections
#define PEST_PAD 0x00000008    // obsolete: padding: not allocated, not relocated, loaded
#define PEST_COPY                                                                        \
    0x00000010                  // obsolete: copy: for decision function used
                                //    by field update; not
                                //    allocated, not relocated,
                                //    loaded; reloc & lineno
                                //    entries processed normally */
#define PEST_TEXT 0x00000020L   // section contains text only
#define PEST_DATA 0x00000040L   // section contains data only
#define PEST_BSS 0x00000080L    // section contains bss only
#define PEST_EXCEPT 0x00000100L // obsolete: Exception section
#define PEST_INFO 0x00000200L   // Comment: not allocated, not relocated, not loaded
#define PEST_OVER 0x00000400L   // obsolete: Overlay: not allocated, relocated, not loaded
#define PEST_LIB 0x00000800L    // ".lib" section: treated like PEST_INFO

#define PEST_LOADER 0x00001000L // Loader section: COMDAT
#define PEST_DEBUG 0x00002000L  // Debug section:
#define PEST_TYPCHK 0x00004000L // Type check section:
#define PEST_OVRFLO 0x00008000L // obsolete: RLD and line number overflow sec hdr
#define PEST_F0000 0x000F0000L  // Unknown
#define PEST_ALIGN 0x00F00000L  // Alignment 2^(x-1):
    uint32 get_sect_alignment(void) const {
        int align = ((s_flags >> 20) & 15);
        return align == 0 ? 0 : (1 << (align - 1));
    }

    asize_t get_vsize(const peheader_t &pe) const {
        return align_up(s_vsize ? s_vsize : s_psize, pe.objalign ? pe.objalign : 1);
    }

    asize_t get_psize(const peheader_t &pe) const { return qmin(s_psize, get_vsize(pe)); }

#define PEST_1000000 0x01000000L // Unknown
#define PEST_DISCARD 0x02000000L // Discardable
#define PEST_NOCACHE 0x04000000L // Not cachable
#define PEST_NOPAGE 0x08000000L  // Not pageable
#define PEST_SHARED 0x10000000L  // Shareable
#define PEST_EXEC 0x20000000L    // Executable
#define PEST_READ 0x40000000L    // Readable
#define PEST_WRITE 0x80000000L   // Writable
};

//-------------------------------------------------------------------------
//
//      E X P O R T S
//
struct peexpdir_t {
    uint32 flags;       // Currently set to zero.
    qtime32_t datetime; // Time/Date the export data was created.
    uint16 major;       // A user settable major/minor version number.
    uint16 minor;
    uint32 dllname; // Relative Virtual Address of the Dll asciiz Name.
    // This is the address relative to the Image Base.
    uint32 ordbase; // First valid exported ordinal. This field specifies
    // the starting ordinal number for the export
    // address table for this image. Normally set to 1.
    uint32 naddrs; // Indicates number of entries in the Export Address
    // Table.
    uint32 nnames; // This indicates the number of entries in the Name
    // Ptr Table (and parallel Ordinal Table).
    uint32 adrtab; // Relative Virtual Address of the Export Address
    // Table. This address is relative to the Image Base.
    uint32 namtab; // Relative Virtual Address of the Export Name Table
    // Pointers. This address is relative to the
    // beginning of the Image Base. This table is an
    // array of RVA's with # NAMES entries.
    uint32 ordtab; // Relative Virtual Address of Export Ordinals
                   // Table Entry. This address is relative to the
                   // beginning of the Image Base.
};

//-------------------------------------------------------------------------
//
//      I M P O R T S
//
struct peimpdir_t {
    uint32 table1;      // aka OriginalFirstThunk
    qtime32_t datetime; // Time/Date the import data was pre-snapped or
    // zero if not pre-snapped.
    uint32 fchain;  // Forwarder chain
    uint32 dllname; // Relative Virtual Address of the Dll asciiz Name.
    // This is the address relative to the Image Base.
    uint32 looktab; // aka FirstThunk
                    // This field contains the address of the start of
                    // the import lookup table for this image. The address
                    // is relative to the beginning of the Image Base.
#define hibit(type) ((type(-1) >> 1) ^ type(-1))
#define IMP_BY_ORD32 hibit(uint32) // Import by ordinal, otherwise by name
#define IMP_BY_ORD64 hibit(uint64) // Import by ordinal, otherwise by name

    peimpdir_t(void) { memset(this, 0, sizeof(peimpdir_t)); }
};

struct dimpdir_t // delayed load import table
{
    uint32 attrs;          // Attributes.
#define DIMP_NOBASE 0x0001 // pe.imagebase was not added to addresses
    uint32 dllname;        // Relative virtual address of the name of the DLL
    // to be loaded. The name resides in the read-only
    // data section of the image.
    uint32 handle; // Relative virtual address of the module handle
    // (in the data section of the image) of the DLL to
    // be delay-loaded. Used for storage by the routine
    // supplied to manage delay-loading.
    uint32 diat; // Relative virtual address of the delay-load import
    // address table. See below for further details.
    uint32 dint; // Relative virtual address of the delay-load name
    // table, which contains the names of the imports
    // that may need to be loaded. Matches the layout of
    // the Import Name Table, Section 6.4.3. Hint/Name Table.
    uint32 dbiat; // Bound Delay Import Table. Relative virtual address
    // of the bound delay-load address table, if it exists.
    uint32 duiat; // Unload Delay Import Table. Relative virtual address
    // of the unload delay-load address table, if it exists.
    // This is an exact copy of the Delay Import Address
    // Table. In the event that the caller unloads the DLL,
    // this table should be copied back over the Delay IAT
    // such that subsequent calls to the DLL continue to
    // use the thunking mechanism correctly.
    qtime32_t datetime; // Time stamp of DLL to which this image has been bound.
};

// Bound Import Table format:

struct BOUND_IMPORT_DESCRIPTOR {
    qtime32_t TimeDateStamp;
    uint16 OffsetModuleName;
    uint16 NumberOfModuleForwarderRefs;
    // Array of zero or more IMAGE_BOUND_FORWARDER_REF follows
};

struct BOUND_FORWARDER_REF {
    qtime32_t TimeDateStamp;
    uint16 OffsetModuleName;
    uint16 Reserved;
};

//-------------------------------------------------------------------------
//
//      T H R E A D   L O C A L   D A T A
//

struct image_tls_directory64 {
    uint64 StartAddressOfRawData;
    uint64 EndAddressOfRawData;
    uint64 AddressOfIndex;     // PDWORD
    uint64 AddressOfCallBacks; // PIMAGE_TLS_CALLBACK *;
    uint32 SizeOfZeroFill;
    uint32 Characteristics;
};

struct image_tls_directory32 {
    uint32 StartAddressOfRawData;
    uint32 EndAddressOfRawData;
    uint32 AddressOfIndex;     // PDWORD
    uint32 AddressOfCallBacks; // PIMAGE_TLS_CALLBACK *
    uint32 SizeOfZeroFill;
    uint32 Characteristics;
};

//-------------------------------------------------------------------------
//
//      Exception Tables (.pdata)
//

// ARM, PowerPC, SH3 and SH4 WindowsCE platforms
struct function_entry_ce {
    uint32 FuncStart;         // Virtual address of the corresponding function.
    uint32 PrologLen : 8;     // Number of instructions in the function's prolog.
    uint32 FuncLen : 22;      // Number of instructions in the function.
    uint32 ThirtyTwoBit : 1;  // Set if the function is comprised of 32-bit
                              // instructions, cleared for a 16-bit function.
    uint32 ExceptionFlag : 1; // Set if an exception handler exists for the
                              // function.
};

// ARMv7
struct function_entry_armv7 {
    uint32 BeginAddress; // The RVA of the corresponding function
    uint32 UnwindInfo;   // The RVA of the unwind information, including function
                         // length.
    // If the low 2 bits are non-zero, then this word represents a
    // compacted inline form of the unwind information,
    // including function length.
};

// for MIPS and 32-bit Alpha
struct function_entry_alpha {
    uint32 BeginAddress;     // Virtual address of the corresponding function.
    uint32 EndAddress;       // Virtual address of the end of the function.
    uint32 ExceptionHandler; // Pointer to the exception handler to be executed.
    uint32 HandlerData;      // Pointer to additional information to be passed to the
                             // handler.
    uint32 PrologEndAddress; // Virtual address of the end of the function's
                             // prolog.
};

// x64
typedef enum _UNWIND_OP_CODES {
    UWOP_PUSH_NONVOL = 0,     // info == register number
    UWOP_ALLOC_LARGE = 1,     // alloc size/8 in next 1(info=0) or 2(info=1) slots
    UWOP_ALLOC_SMALL = 2,     // info == size of allocation / 8 - 1
    UWOP_SET_FPREG = 3,       // FP = RSP + UNWIND_INFO.FPRegOffset*16
    UWOP_SAVE_NONVOL = 4,     // info == register number, offset/8 in next slot
    UWOP_SAVE_NONVOL_FAR = 5, // info == register number, offset/8 in next 2 slots
    UWOP_SAVE_XMM = 6,        // Version 1: info == XMM reg number, offset/8 in next slot
    UWOP_EPILOG = 6,          // Version 2; code offset is epilog size;
    UWOP_SAVE_XMM_FAR = 7, // version 1:info == XMM reg number, offset/8 in next 2 slots
    UWOP_SPARE_CODE = 7,   // unused ("previously 64-bit UWOP_SAVE_XMM_FAR"); skip 2 slots
    UWOP_SAVE_XMM128 = 8,  // info == XMM reg number, offset/16 in next slot
    UWOP_SAVE_XMM128_FAR = 9, // info == XMM reg number, offset/16 in next 2 slots
    UWOP_PUSH_MACHFRAME = 10, // info == 0: no error-code, 1: with error code
} UNWIND_CODE_OPS;

// Define unwind information flags.
//

#define UNW_FLAG_NHANDLER 0x0
#define UNW_FLAG_EHANDLER 0x1
#define UNW_FLAG_UHANDLER 0x2
#define UNW_FLAG_CHAININFO 0x4

//-------------------------------------------------------------------------
//
//      F I X U P S
//
struct pefixup_t {
    uint32 page; // The image base plus the page rva is added to each offset
    // to create the virtual address of where the fixup needs to
    // be applied.
    uint32 size; // Number of bytes in the fixup block. This includes the
                 // PAGE RVA and SIZE fields.
};

#define PER_OFF 0x0FFF
#define PER_TYPE 0xF000
#define PER_ABS 0x0000  // This is a NOP. The fixup is skipped.
#define PER_HIGH 0x1000 // Add the high 16-bits of the delta to the
// 16-bit field at Offset. The 16-bit field
// represents the high value of a 32-bit word.
#define PER_LOW 0x2000 // Add the low 16-bits of the delta to the
// 16-bit field at Offset. The 16-bit field
// represents the low half value of a
// 32-bit word.  This fixup will only be
// emitted for a RISC machine when the image
// Object Align isn't the default of 64K.
#define PER_HIGHLOW 0x3000 // Apply the 32-bit delta to the 32-bit field
// at Offset.
#define PER_HIGHADJUST 0x4000 // This fixup requires a full 32-bit value.
// The high 16-bits is located at Offset, and
// the low 16-bits is located in the next
// Offset array element (this array element
// is included in the SIZE field). The two
// need to be combined into a signed variable.
// Add the 32-bit delta. Then add 0x8000 and
// store the high 16-bits of the signed
// variable to the 16-bit field at Offset.
#define PER_REL5000 0x5000 // Machine-specific
#define PER_SECTION 0x6000 // Reserved for future use
#define PER_REL32 0x7000   // Relative intrasection
#define PER_REL7000 0x7000 // Machine-specific
#define PER_REL8000 0x8000 // Machine-specific
#define PER_REL9000 0x9000 // Machine-specific
#define PER_DIR64 0xA000   // This fixup applies the delta to the 64-bit
// field at Offset
#define PER_HIGH3ADJ 0xB000 // The fixup adds the high 16 bits of the delta
// to the 16-bit field at Offset. The 16-bit
// field represents the high value of a 48-bit
// word. The low 32 bits of the 48-bit value are
// stored in the 32-bit word that follows this
// base relocation. This means that this base
// relocation occupies three slots.

// Platform-specific based relocation types.

#define PER_IA64_IMM64 0x9000

#define PER_MIPS_JMPADDR 0x5000   // base relocation applies to a MIPS jump instruction.
#define PER_MIPS_JMPADDR16 0x9000 // base relocation applies to a MIPS16 jump instruction.

#define PER_ARM_MOV32A 0x5000 // base relocation applies the difference to the
// 32-bit value encoded in the immediate fields of
// a contiguous MOVW+MOVT pair in ARM mode at offset.
#define PER_ARM_MOV32T 0x7000 // base relocation applies the difference to the
// 32-bit value encoded in the immediate fields of
// a contiguous MOVW+MOVT pair in Thumb mode at offset.

//-------------------------------------------------------------------------
//
//      DBG file debug entry format
//
struct debug_entry_t {
    uint32 flags; // usually zero
    qtime32_t datetime;
    uint16 major;
    uint16 minor;
    int32 type;
#define DBG_COFF 1
#define DBG_CV 2
#define DBG_FPO 3
#define DBG_MISC 4
#define DBG_EXCEPTION 5
#define DBG_FIXUP 6
#define DBG_OMAP_TO_SRC 7
#define DBG_OMAP_FROM_SRC 8
#define DBG_BORLAND 9
#define DBG_RES10 10
#define DBG_CLSID 11
#define DBG_VCFEATURE 12
#define DBG_POGO 13
#define DBG_ILTCG 14
#define DBG_MPX 15
    uint32 size;
    uint32 rva;  // virtual address
    uint32 seek; // ptr to data in the file
};

// now we can define has_debdir() because we have debug_entry_t defined
template <> inline bool peheader_t::has_debdir() const {
    return debdir.size >= sizeof(debug_entry_t) && debdir.rva != 0;
}

//-------------------------------------------------------------------------
//
//      DBG file COFF debug information header
//
struct coff_debug_t {
    uint32 NumberOfSymbols;
    uint32 LvaToFirstSymbol;
    uint32 NumberOfLinenumbers;
    uint32 LvaToFirstLinenumber;
    uint32 RvaToFirstByteOfCode;
    uint32 RvaToLastByteOfCode;
    uint32 RvaToFirstByteOfData;
    uint32 RvaToLastByteOfData;
};

//-------------------------------------------------------------------------
//
//      DBG file FPO debug information
//
struct fpo_t {
    uint32 address;
    uint32 size;
    uint32 locals;
    uint16 params;
    uchar prolog;
    uchar regs;
#define FPO_REGS 0x07 // register number
#define FPO_SEH 0x08  //
#define FPO_BP 0x10   // has BP frame?
#define FPO_TYPE 0xC0
#define FPO_T_FPO 0x00
#define FPO_T_TRAP 0x40
#define FPO_T_TSS 0x80
#define FPO_T_NONFPO 0xC0
};

//      DBG file OMAP debug information

struct omap_t {
    uint32 a1;
    uint32 a2;
};

// misc entry format
struct misc_debug_t {
    uint32 type; // type of misc data, see defines
#define MISC_EXENAME 1
    uint32 length; // total length of record, rounded to four
    // byte multiple.
    uchar unicode;     // TRUE if data is unicode string
    uchar reserved[3]; // padding
    uchar data[1];     // Actual data
};

//----------------------------------------------------------------------
// Resource information
struct rsc_dir_t {
    uint32 Characteristics;
    uint32 TimeDateStamp;
    uint16 MajorVersion;
    uint16 MinorVersion;
    uint16 NumberOfNamedEntries;
    uint16 NumberOfIdEntries;
};

struct rsc_dir_entry_t {
    union {
        struct {
            uint32 NameOffset : 31;
            uint32 NameIsString : 1;
        };
        uint32 Name;
        uint16 Id;
    };
    union {
        uint32 OffsetToData;
        struct {
            uint32 OffsetToDirectory : 31;
            uint32 DataIsDirectory : 1;
        };
    };
};

struct rsc_data_entry_t {
    uint32 OffsetToData;
    uint32 Size;
    uint32 CodePage;
    uint32 Reserved;
};

// Resource types
#define PE_RT_CURSOR 1
#define PE_RT_BITMAP 2
#define PE_RT_ICON 3
#define PE_RT_MENU 4
#define PE_RT_DIALOG 5
#define PE_RT_STRING 6
#define PE_RT_FONTDIR 7
#define PE_RT_FONT 8
#define PE_RT_ACCELERATOR 9
#define PE_RT_RCDATA 10
#define PE_RT_MESSAGETABLE 11
#define PE_RT_GROUP_CURSOR 12
#define PE_RT_GROUP_ICON 14
#define PE_RT_VERSION 16
#define PE_RT_DLGINCLUDE 17
#define PE_RT_PLUGPLAY 19
#define PE_RT_VXD 20
#define PE_RT_ANICURSOR 21
#define PE_RT_ANIICON 22
#define PE_RT_HTML 23
#define PE_RT_MANIFEST 24

// Language codes
#define PE_LANG_NEUTRAL 0x00
#define PE_LANG_INVARIANT 0x7f

#define PE_LANG_AFRIKAANS 0x36
#define PE_LANG_ALBANIAN 0x1c
#define PE_LANG_ARABIC 0x01
#define PE_LANG_ARMENIAN 0x2b
#define PE_LANG_ASSAMESE 0x4d
#define PE_LANG_AZERI 0x2c
#define PE_LANG_BASQUE 0x2d
#define PE_LANG_BELARUSIAN 0x23
#define PE_LANG_BENGALI 0x45
#define PE_LANG_BULGARIAN 0x02
#define PE_LANG_CATALAN 0x03
#define PE_LANG_CHINESE 0x04
#define PE_LANG_CROATIAN 0x1a
#define PE_LANG_CZECH 0x05
#define PE_LANG_DANISH 0x06
#define PE_LANG_DIVEHI 0x65
#define PE_LANG_DUTCH 0x13
#define PE_LANG_ENGLISH 0x09
#define PE_LANG_ESTONIAN 0x25
#define PE_LANG_FAEROESE 0x38
#define PE_LANG_FARSI 0x29
#define PE_LANG_FINNISH 0x0b
#define PE_LANG_FRENCH 0x0c
#define PE_LANG_GALICIAN 0x56
#define PE_LANG_GEORGIAN 0x37
#define PE_LANG_GERMAN 0x07
#define PE_LANG_GREEK 0x08
#define PE_LANG_GUJARATI 0x47
#define PE_LANG_HEBREW 0x0d
#define PE_LANG_HINDI 0x39
#define PE_LANG_HUNGARIAN 0x0e
#define PE_LANG_ICELANDIC 0x0f
#define PE_LANG_INDONESIAN 0x21
#define PE_LANG_ITALIAN 0x10
#define PE_LANG_JAPANESE 0x11
#define PE_LANG_KANNADA 0x4b
#define PE_LANG_KASHMIRI 0x60
#define PE_LANG_KAZAK 0x3f
#define PE_LANG_KONKANI 0x57
#define PE_LANG_KOREAN 0x12
#define PE_LANG_KYRGYZ 0x40
#define PE_LANG_LATVIAN 0x26
#define PE_LANG_LITHUANIAN 0x27
#define PE_LANG_MACEDONIAN 0x2f // the Former Yugoslav Republic of Macedonia
#define PE_LANG_MALAY 0x3e
#define PE_LANG_MALAYALAM 0x4c
#define PE_LANG_MANIPURI 0x58
#define PE_LANG_MARATHI 0x4e
#define PE_LANG_MONGOLIAN 0x50
#define PE_LANG_NEPALI 0x61
#define PE_LANG_NORWEGIAN 0x14
#define PE_LANG_ORIYA 0x48
#define PE_LANG_POLISH 0x15
#define PE_LANG_PORTUGUESE 0x16
#define PE_LANG_PUNJABI 0x46
#define PE_LANG_ROMANIAN 0x18
#define PE_LANG_RUSSIAN 0x19
#define PE_LANG_SANSKRIT 0x4f
#define PE_LANG_SINDHI 0x59
#define PE_LANG_SLOVAK 0x1b
#define PE_LANG_SLOVENIAN 0x24
#define PE_LANG_SPANISH 0x0a
#define PE_LANG_SWAHILI 0x41
#define PE_LANG_SWEDISH 0x1d
#define PE_LANG_SYRIAC 0x5a
#define PE_LANG_TAMIL 0x49
#define PE_LANG_TATAR 0x44
#define PE_LANG_TELUGU 0x4a
#define PE_LANG_THAI 0x1e
#define PE_LANG_TURKISH 0x1f
#define PE_LANG_UKRAINIAN 0x22
#define PE_LANG_URDU 0x20
#define PE_LANG_UZBEK 0x43
#define PE_LANG_VIETNAMESE 0x2a

//----------------------------------------------------------------------

#define PE_NODE "$ PE header" // netnode name for PE header
// value()        -> peheader_t
// altval(segnum) -> s->start_ea
#define PE_ALT_DBG_FPOS nodeidx_t(-1) // altval() -> translated fpos of debuginfo
#define PE_ALT_IMAGEBASE                                                                 \
    nodeidx_t(-2) // altval() -> loading address (usually pe.imagebase)
#define PE_ALT_PEHDR_OFF nodeidx_t(-3) // altval() -> offset of PE header
#define PE_ALT_NEFLAGS nodeidx_t(-4)   // altval() -> neflags
#define PE_ALT_TDS_LOADED                                                                \
    nodeidx_t(-5) // altval() -> tds already loaded(1) or invalid(-1)
#define PE_ALT_PSXDLL                                                                    \
    nodeidx_t(-6) // altval() -> if POSIX(x86) imports from PSXDLL netnode
#define PE_ALT_OVRVA nodeidx_t(-7)    // altval() -> overlay rva (if present)
#define PE_ALT_OVRSZ nodeidx_t(-8)    // altval() -> overlay size (if present)
#define PE_SUPSTR_PDBNM nodeidx_t(-9) // supstr() -> pdb file name
// supval(segnum) -> pesection_t
// blob(0, PE_NODE_RELOC)  -> relocation info
// blob(0, RSDS_TAG)  -> rsds_t structure
// blob(0, NB10_TAG)  -> cv_info_pdb20_t structure
#define PE_ALT_NTAPI nodeidx_t(-10) // altval() -> uses Native API
#define PE_NODE_RELOC 'r'
#define RSDS_TAG 's'
#define NB10_TAG 'n'
#define UTDS_TAG 't'

struct load_config_t {
    uint32 Size;
    uint32 TimeDateStamp;
    uint16 MajorVersion;
    uint16 MinorVersion;
    uint32 GlobalFlagsClear;
    uint32 GlobalFlagsSet;
    uint32 CriticalSectionDefaultTimeout;
    uint32 DeCommitFreeBlockThreshold;
    uint32 DeCommitTotalFreeThreshold;
    uint32 LockPrefixTable; // VA
    uint32 MaximumAllocationSize;
    uint32 VirtualMemoryThreshold;
    uint32 ProcessHeapFlags;
    uint32 ProcessAffinityMask;
    uint16 CSDVersion;
    uint16 Reserved1;
    uint32 EditList;       // VA
    uint32 SecurityCookie; // VA
    // Version 2
    uint32 SEHandlerTable; // VA
    uint32 SEHandlerCount;
    // Version 3
    uint32 GuardCFCheckFunctionPointer;    // VA
    uint32 GuardCFDispatchFunctionPointer; // VA
    uint32 GuardCFFunctionTable;           // VA
    uint32 GuardCFFunctionCount;
    uint32 GuardFlags;
};

struct load_config64_t {
    uint32 Size;
    uint32 TimeDateStamp;
    uint16 MajorVersion;
    uint16 MinorVersion;
    uint32 GlobalFlagsClear;
    uint32 GlobalFlagsSet;
    uint32 CriticalSectionDefaultTimeout;
    uint64 DeCommitFreeBlockThreshold;
    uint64 DeCommitTotalFreeThreshold;
    uint64 LockPrefixTable; // VA
    uint64 MaximumAllocationSize;
    uint64 VirtualMemoryThreshold;
    uint64 ProcessAffinityMask;
    uint32 ProcessHeapFlags;
    uint16 CSDVersion;
    uint16 Reserved1;
    uint64 EditList;       // VA
    uint64 SecurityCookie; // VA
    // Version 2
    uint64 SEHandlerTable; // VA
    uint64 SEHandlerCount;
    // Version 3
    uint64 GuardCFCheckFunctionPointer;    // VA
    uint64 GuardCFDispatchFunctionPointer; // VA
    uint64 GuardCFFunctionTable;           // VA
    uint64 GuardCFFunctionCount;
    uint32 GuardFlags;
};

#ifndef IMAGE_GUARD_CF_INSTRUMENTED
#define IMAGE_GUARD_CF_INSTRUMENTED                                                      \
    0x000000100 // Module performs control flow integrity checks using
                // system-supplied support
#define IMAGE_GUARD_CFW_INSTRUMENTED                                                     \
    0x000000200 // Module performs control flow and write integrity checks
#define IMAGE_GUARD_CF_FUNCTION_TABLE_PRESENT                                            \
    0x000000400 // Module contains valid control flow target metadata
#define IMAGE_GUARD_SECURITY_COOKIE_UNUSED                                               \
    0x000000800 // Module does not make use of the /GS security cookie
#define IMAGE_GUARD_PROTECT_DELAYLOAD_IAT                                                \
    0x00001000 // Module supports read only delay load IAT
#define IMAGE_GUARD_DELAYLOAD_IAT_IN_ITS_OWN_SECTION                                     \
    0x00002000 // Delayload import table in its own .didat section (with nothing
               // else in it) that can be freely reprotected
#define IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK                                          \
    0xF0000000 // Stride of Guard CF function table encoded in these bits
               // (additional count of bytes per element)
#define IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_SHIFT                                         \
    28 // Shift to right-justify Guard CF function table stride
#endif

//----------------------------------------------------------------------
// MS Windows CLSID, GUID
struct clsid_t {
    uint32 id1;
    uint16 id2;
    uint16 id3;
    uchar id4[8];
    bool operator==(const struct clsid_t &r) const {
        return memcmp(this, &r, sizeof(r)) == 0;
    }
};

//----------------------------------------------------------------------
// RSDS debug information
struct rsds_t {
    uint32 magic;
#define RSDS_MAGIC MC4('R', 'S', 'D', 'S')
#define UTDS_MAGIC MC4('u', 'T', 'D', 'S')
    clsid_t guid;
    uint32 age;
    //  char name[];  // followed by a zero-terminated UTF8 file name
};

//----------------------------------------------------------------------
// NB10 debug information
struct cv_info_pdb20_t {
    uint32 magic; // 'NB10'
#define NB10_MAGIC MC4('N', 'B', '1', '0')
    uint32 offset;
    uint32 signature;
    uint32 age;
    // char pdb_file_name[];
};

//----------------------------------------------------------------------
// MTOC debug information.
// denotes EFI binaries that were built on OSX as Mach-O, then converted to PE
// by the 'mtoc' utility. see
// https://opensource.apple.com/source/cctools/cctools-921/efitools/mtoc.c.auto.html
struct mtoc_info_t {
    uint32 magic; // 'MTOC'
#define MTOC_MAGIC MC4('M', 'T', 'O', 'C')
    uchar uuid[16]; // UUID of original Mach-O file
                    // char debug_filename[];
};

// TE (Terse Executable)
struct teheader_t {
    uint16 signature; // 00
    uint16 machine;   // 02 same as in PE

    bool is_64bit_cpu(void) const {
        return machine == PECPU_AMD64 || machine == PECPU_IA64 || machine == PECPU_ARM64;
    }

    uint8 nobjs;         // 04 number of sections
    uint8 subsys;        // 05 target subsystem
    uint16 strippedsize; // 06 number of bytes removed from the base of the
                         // original image

    int32 first_section_pos(int32 peoff) const { return peoff + sizeof(teheader_t); }

    // value which should be added to the sections' file offsets and RVAs
    int32 te_adjust() const { return sizeof(teheader_t) - strippedsize; }

    uint32 entry;       // 08 Entry point
    uint32 text_start;  // 0C Base of code
    uint64 imagebase64; // 10 Virtual base of the image.
    uint64 imagebase() const { return imagebase64; }
    petab_t reltab; // 18 Relocation Table
    petab_t debdir; // 20 Debug Directory
};

const char *get_pe_machine_name(uint16 machine);
void print_pe_flags(uint16 flags);

#pragma pack(pop)

#endif // EFILOADER_PE_IDA_H

```

`efiXloader/pe_manager.cpp`:

```cpp
/*
 * efiXloader
 * Copyright (C) 2020-2022 Binarly
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * pe_manager.cpp
 */

#include "pe_manager.h"

void efiloader::PeManager::process(linput_t *li, std::basic_string<char> fname, int ord) {
    efiloader::PE pe(li, fname, &pe_base, &pe_sel_base, ord);
    if (pe.good() && pe.is_p32_plus()) {
        msg("[efiXloader] PE detected\n");
        pe.process();
    } else if (pe.is_p32()) {
        msg("[efiXloader] this loader is not ready for PE32\n");
    } else {
        warning("[efiXloader] not PE\n");
    }
}

```

`efiXloader/pe_manager.h`:

```h
/*
 * efiXloader
 * Copyright (C) 2020-2022 Binarly
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * pe_manager.h
 */

#ifndef EFILOADER_PE_MANAGER_H
#define EFILOADER_PE_MANAGER_H

#include "ida_core.h"
#include "pe.h"

namespace efiloader {
class PeManager {
  public:
    PeManager() {
        inf_set_64bit();
        set_imagebase(0x0);
        set_processor_type("metapc", SETPROC_LOADER);
        pe_base = 0;
        pe_sel_base = 0;
    };
    void process(linput_t *li, std::basic_string<char> fname, int ord);

  private:
    void to_base(linput_t *);
    efiloader::PE *pe;
    qvector<efiloader::PE *> pe_files;
    ushort pe_sel_base;
    ea_t pe_base;
    // head processing
    void pe_head_to_base(linput_t *li);
};
} // namespace efiloader

#endif // EFILOADER_PE_MANAGER_H

```

`efiXloader/uefitool.cpp`:

```cpp
/*
 * efiXloader
 * Copyright (C) 2020-2022 Binarly
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * uefitool.cpp
 */

#include "uefitool.h"
#include <codecvt>
#include <filesystem>
#include <vector>

void efiloader::File::print() {
    msg("[UEFITOOL PARSER] file ( %s )  \n", qname.c_str());
    for (int i = 0; i < 0x10; i++) {
        msg("%02X ", ubytes[i]);
    };
    msg("\n");
}

void efiloader::Uefitool::show_messages() {
    for (size_t i = 0; i < messages.size(); i++) {
        msg("[UEFITOOL PARSER] %s\n", messages[i].first.toLocal8Bit());
    }
}

void efiloader::Uefitool::get_unique_name(qstring &name) {
    // If the given name is already in use, create a new one
    qstring new_name = name;
    std::string suf;
    int index = 0;
    while (!(unique_names.insert(new_name).second)) {
        suf = "_" + std::to_string(++index);
        new_name = name + static_cast<qstring>(suf.c_str());
    }
    name = new_name;
}

void efiloader::Uefitool::get_image_guid(qstring &image_guid, UModelIndex index) {
    UString guid;
    UModelIndex guid_index;
    switch (model.subtype(model.parent(index))) {
    case EFI_SECTION_COMPRESSION:
        guid_index = model.parent(model.parent(index));
        break;
    default:
        guid_index = model.parent(index);
    }
    // get parent header and read GUID
    guid = guidToUString(
        readUnaligned((const EFI_GUID *)(model.header(guid_index).constData())));
    image_guid = reinterpret_cast<char *>(guid.data);
}

std::vector<std::string>
efiloader::Uefitool::parseDepexSectionBody(const UModelIndex &index, UString &parsed) {
    // Adopted from FfsParser::parseDepexSectionBody
    std::vector<std::string> res;

    if (!index.isValid())
        return res;

    UByteArray body = model.body(index);

    // Check data to be present
    if (body.size() < 2) { // 2 is a minimal sane value, i.e TRUE + END
        return res;
    }

    const EFI_GUID *guid;
    const UINT8 *current = (const UINT8 *)body.constData();

    // Special cases of first opcode
    switch (*current) {
    case EFI_DEP_BEFORE:
        if (body.size() != 2 * EFI_DEP_OPCODE_SIZE + sizeof(EFI_GUID)) {
            return res;
        }
        guid = (const EFI_GUID *)(current + EFI_DEP_OPCODE_SIZE);
        parsed += UString("\nBEFORE ") + guidToUString(readUnaligned(guid));
        current += EFI_DEP_OPCODE_SIZE + sizeof(EFI_GUID);
        if (*current != EFI_DEP_END) {
            return res;
        }
        return res;
    case EFI_DEP_AFTER:
        if (body.size() != 2 * EFI_DEP_OPCODE_SIZE + sizeof(EFI_GUID)) {
            return res;
        }
        guid = (const EFI_GUID *)(current + EFI_DEP_OPCODE_SIZE);
        parsed += UString("\nAFTER ") + guidToUString(readUnaligned(guid));
        current += EFI_DEP_OPCODE_SIZE + sizeof(EFI_GUID);
        if (*current != EFI_DEP_END) {
            return res;
        }
        return res;
    case EFI_DEP_SOR:
        if (body.size() <= 2 * EFI_DEP_OPCODE_SIZE) {
            return res;
        }
        parsed += UString("\nSOR");
        current += EFI_DEP_OPCODE_SIZE;
        break;
    }

    // Parse the rest of depex
    while (current - (const UINT8 *)body.constData() < body.size()) {
        switch (*current) {
        case EFI_DEP_BEFORE: {
            return res;
        }
        case EFI_DEP_AFTER: {
            return res;
        }
        case EFI_DEP_SOR: {
            return res;
        }
        case EFI_DEP_PUSH:
            // Check that the rest of depex has correct size
            if ((UINT32)body.size() -
                    (UINT32)(current - (const UINT8 *)body.constData()) <=
                EFI_DEP_OPCODE_SIZE + sizeof(EFI_GUID)) {
                parsed.clear();
                return res;
            }
            guid = (const EFI_GUID *)(current + EFI_DEP_OPCODE_SIZE);
            parsed += UString("\nPUSH ") + guidToUString(readUnaligned(guid));
            // Add protocol GUID to result vector
            res.push_back(
                reinterpret_cast<char *>(guidToUString(readUnaligned(guid)).data));
            current += EFI_DEP_OPCODE_SIZE + sizeof(EFI_GUID);
            break;
        case EFI_DEP_AND:
            parsed += UString("\nAND");
            current += EFI_DEP_OPCODE_SIZE;
            break;
        case EFI_DEP_OR:
            parsed += UString("\nOR");
            current += EFI_DEP_OPCODE_SIZE;
            break;
        case EFI_DEP_NOT:
            parsed += UString("\nNOT");
            current += EFI_DEP_OPCODE_SIZE;
            break;
        case EFI_DEP_TRUE:
            parsed += UString("\nTRUE");
            current += EFI_DEP_OPCODE_SIZE;
            break;
        case EFI_DEP_FALSE:
            parsed += UString("\nFALSE");
            current += EFI_DEP_OPCODE_SIZE;
            break;
        case EFI_DEP_END:
            parsed += UString("\nEND");
            current += EFI_DEP_OPCODE_SIZE;
            // Check that END is the last opcode
            if (current - (const UINT8 *)body.constData() < body.size()) {
                parsed.clear();
            }
            break;
        default:
            return res;
            break;
        }
    }

    return res;
}

void efiloader::Uefitool::dump(const UModelIndex &index, uint8_t el_type,
                               efiloader::File *file) {
    qstring module_name("");
    qstring guid("");

    switch (model.subtype(index)) {
    case EFI_SECTION_TE:
        file->is_te = true;
        file->ubytes = model.body(index);
        break;
    case EFI_SECTION_PE32:
        file->is_pe = true;
        file->ubytes = model.body(index);
        break;
    case EFI_SECTION_USER_INTERFACE:
        file->has_ui = true;
        if (file->is_pe || file->is_te) {
            file->uname = model.body(index);
            utf16_utf8(&module_name,
                       reinterpret_cast<const wchar16_t *>(file->uname.data()));
            if (module_name.size()) {
                // save image to the images_guids
                get_image_guid(guid, index);
                if (images_guids[guid.c_str()]
                        .is_null()) { // check if GUID already exists
                    get_unique_name(module_name);
                    images_guids[guid.c_str()] = module_name.c_str();
                    file->qname.swap(module_name);
                    file->write();
                    files.push_back(file);
                }
            }
        }
        break;
    case EFI_SECTION_COMPRESSION:
        for (int i = 0; i < model.rowCount(index); i++) {
            dump(index.child(i, 0), i, file);
        }
        break;
    // Get DEPEX information
    case EFI_SECTION_DXE_DEPEX:
        get_deps(index, "EFI_SECTION_DXE_DEPEX");
        break;
    case EFI_SECTION_MM_DEPEX:
        get_deps(index, "EFI_SECTION_MM_DEPEX");
        break;
    case EFI_SECTION_PEI_DEPEX:
        get_deps(index, "EFI_SECTION_PEI_DEPEX");
        break;
    default:
        // if there is no UI section, then the image name is GUID
        if ((file->is_pe || file->is_te) && !file->has_ui) {
            get_image_guid(module_name, index);
            file->qname.swap(module_name);
            file->write();
            files.push_back(file);
            if (module_name.size()) {
                // save image to the images_guids
                images_guids[module_name.c_str()] = module_name.c_str();
            }
        }
        break;
    }

    return dump(index);
}

void efiloader::Uefitool::dump(const UModelIndex &index) {
    USTATUS err;
    msg("[UEFITOOL PARSER] file (%s, %s)\n", itemTypeToUString(model.type(index)).data,
        itemSubtypeToUString(model.type(index), model.subtype(index)).data);
    msg("[UEFITOOL PARSER] number of items: %#x\n", model.rowCount(index));
    if (is_file_index(index)) {
        efiloader::File *file = new File;
        for (int i = 0; i < model.rowCount(index); i++) {
            dump(index.child(i, 0), i, file);
        }
    } else {
        for (int i = 0; i < model.rowCount(index); i++) {
            dump(index.child(i, 0));
        }
    }
}

void efiloader::Uefitool::dump() { return dump(model.index(0, 0)); }

void efiloader::Uefitool::get_deps(UModelIndex index, std::string key) {
    UString parsed;
    std::vector<std::string> deps;
    qstring image_guid("");

    get_image_guid(image_guid, index);
    deps = parseDepexSectionBody(index, parsed);
    if (deps.size()) {
        msg("[efiXloader] dependency section for image with GUID %s: %s\n",
            image_guid.c_str(), parsed.data);
        all_deps[key][image_guid.c_str()] = deps;
    }
}

void efiloader::Uefitool::dump_jsons() {
    // Dump deps
    std::filesystem::path out;
    out /= get_path(PATH_TYPE_IDB);
    out.replace_extension(".deps.json");
    std::ofstream out_deps(out);
    out_deps << std::setw(4) << all_deps << std::endl;
    // Dump images
    out.replace_extension("").replace_extension(".images.json");
    std::ofstream out_guids(out);
    out_guids << std::setw(4) << images_guids << std::endl;
}

```

`efiXloader/uefitool.h`:

```h
/*
 * efiXloader
 * Copyright (C) 2020-2022 Binarly
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * uefitool.h
 */

#ifndef EFILOADER_UEFITOOL_H
#define EFILOADER_UEFITOOL_H

#include "3rd/uefitool/common/LZMA/LzmaCompress.h"
#include "3rd/uefitool/common/LZMA/LzmaDecompress.h"
#include "3rd/uefitool/common/Tiano/EfiTianoCompress.h"
#include "3rd/uefitool/common/Tiano/EfiTianoDecompress.h"
#include "3rd/uefitool/common/basetypes.h"
#include "3rd/uefitool/common/ffs.h"
#include "3rd/uefitool/common/ffsparser.h"
#include "3rd/uefitool/common/ffsreport.h"
#include "3rd/uefitool/common/filesystem.h"
#include "3rd/uefitool/common/guiddatabase.h"
#include "3rd/uefitool/common/treeitem.h"
#include "3rd/uefitool/common/treemodel.h"
#include "3rd/uefitool/common/ustring.h"
#include "3rd/uefitool/version.h"

#include "3rd/uefitool/UEFIExtract/ffsdumper.h"
#include "3rd/uefitool/UEFIExtract/uefidump.h"
#include "json.hpp"

#include "ida_core.h"

#include <set>
#ifdef _WIN32
#include <direct.h>
#else
#include <sys/stat.h>
#endif

using namespace nlohmann;

enum FILE_SECTION_TYPE {
    PE_DEPENDENCY_SECTION = 0,
    PE_TE_IMAGE_SECTION = 1,
    UI_SECTION = 2,
    VERSION_SECTION = 3
};

namespace efiloader {
class File {
  public:
    File() {}
    void set_data(char *data_in, uint32_t size_in) {
        qname.qclear();
        bytes.resize(size_in);
        memcpy(&bytes[0], data_in, size_in);
    };
    void write() {
        qstring idb_path(get_path(PATH_TYPE_IDB));
        qstring images_path = idb_path + qstring(".efiloader");
#ifdef WIN32
        _mkdir(images_path.c_str());
#else
        mkdir(images_path.c_str(), S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);
#endif
        if (!qname.empty()) {
            qstring image_path = images_path + qstring("/") + qstring(qname.c_str());
            std::ofstream file;
            file.open(image_path.c_str(), std::ios::out | std::ios::binary);
            file.write(ubytes.constData(), ubytes.size());
            file.close();
            dump_name.swap(image_path);
        }
    }
    void print();
    UByteArray ubytes;
    UByteArray uname;
    bytevec_t bytes;
    char *data = NULL;
    uint32_t size = 0;
    std::string name_utf8;
    std::string name_utf16;
    qstring qname;
    qstring dump_name;
    bool is_pe = false;
    bool is_te = false;
    bool has_ui = false;
};

class Uefitool {
  public:
    Uefitool(bytevec_t &data) {
        buffer = (const char *)&data[0];
        buffer_size = data.size();
        UByteArray ubuffer(buffer, buffer_size);
        FfsParser ffs(&model);
        if (ffs.parse(ubuffer)) {
            loader_failure("failed to parse data via UEFITool");
        }
        messages = ffs.getMessages();
    }
    ~Uefitool(){};
    void show_messages();
    bool messages_occurs() { return !messages.empty(); };
    void dump();
    void dump(const UModelIndex &index);
    void dump(const UModelIndex &index, uint8_t el_type, File *pe_file);
    bool is_pe_index(const UModelIndex &index) { return model.rowCount(index) == 4; };
    bool is_file_index(const UModelIndex &index) {
        return model.type(index) == Types::File;
    };
    void get_unique_name(qstring &image_name);
    void get_image_guid(qstring &image_guid, UModelIndex index);
    std::vector<std::string> parseDepexSectionBody(const UModelIndex &index,
                                                   UString &parsed);
    void get_deps(UModelIndex index, std::string key);
    void dump_jsons(); // dump JSON with DEPEX and GUIDs information for each image
    json all_deps;     // DEPEX information for each image
    json images_guids; // matching the modules to the parent's GUIDs
    TreeModel model;
    const char *buffer;
    uint32_t buffer_size;
    std::vector<std::pair<UString, UModelIndex>> messages;
    std::set<qstring> unique_names;
    std::vector<efiloader::File *> files;
    USTATUS err;
};
} // namespace efiloader

#endif // EFILOADER_UEFITOOL_H

```

`efiXloader/utils.cpp`:

```cpp
/*
 * efiXloader
 * Copyright (C) 2020-2022 Binarly
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * utils.cpp
 */

#include "utils.h"

void efiloader::Utils::show_hex(void *buffer, size_t length, const char *prefix) {
    uint8_t *buf = (uint8_t *)buffer;
    msg("[efiXloader] %s = ", prefix);
    for (int i = 0; i < length; i++) {
        msg("%02x", buf[i]);
    }
    msg("\n");
}

bool efiloader::Utils::find_vol(bytevec_t &frm, std::string &sig, qoff64_t &vol_off) {
    auto found = std::search(frm.begin(), frm.end(), sig.begin(), sig.end());
    if (found != frm.end()) {
        vol_off = std::distance(frm.begin(), found);
        return true;
    } else {
        return false;
    }
}

qoff64_t efiloader::Utils::find_vol_new(linput_t *li, char *sig) {
    qoff64_t sig_off;
    char buf[5] = {0};
    while (qltell(li) != qlsize(li)) {
        qlread(li, &buf, 4);
        if (strneq(buf, sig, 4)) {
#ifdef DEBUG
            msg("[efiloader:PARSER] found FV sign %s: %#x\n", buf, qltell(li) - 4);
#endif
            return qltell(li) - 4 - 0x28;
        }
    }
    return -1;
}

qoff64_t efiloader::Utils::find_vol_test(bytevec_t &data) {
    std::string tmp(data.begin(), data.end());
    std::size_t res = tmp.find("_FVH");
    if (res != std::string::npos) {
        return res - 0x28;
    }
    return res;
}

void efiloader::Utils::skip(memory_deserializer_t *ser, size_t size, size_t count) {
    switch (size) {
    case 1:
        for (int i = 0; i < count; i++) {
            ser->unpack_db();
        }
        break;
    case 2:
        for (int i = 0; i < count; i++) {
            ser->unpack_dw();
        }
        break;
    case 4:
        for (int i = 0; i < count; i++) {
            ser->unpack_dd();
        }
        break;
    case 8:
        for (int i = 0; i < count; i++) {
            ser->unpack_dq();
        }
        break;
    default:
        break;
    }
}

```

`efiXloader/utils.h`:

```h
/*
 * efiXloader
 * Copyright (C) 2020-2022 Binarly
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * utils.h
 */

#ifndef EFILOADER_UTILS_H
#define EFILOADER_UTILS_H

#include "ida_core.h"
#include <algorithm>
#include <cstdint>
#include <string>
#include <vector>

namespace efiloader {

class Utils {
  public:
    Utils() { ; };
    void show_hex(void *buffer, size_t length, const char *prefix);
    bool find_vol(bytevec_t &frm, std::string &sig, qoff64_t &vol_off);
    qoff64_t find_vol_new(linput_t *li, char *sig);
    qoff64_t find_vol_test(bytevec_t &data);
    void skip(memory_deserializer_t *ser, size_t size, size_t count);
};
} // namespace efiloader

#endif // EFILOADER_UTILS_H

```

`efiXplorer/3rd/nlohmann_json/json.hpp`:

```hpp
/*
    __ _____ _____ _____
 __|  |   __|     |   | |  JSON for Modern C++
|  |  |__   |  |  | | | |  version 3.9.1
|_____|_____|_____|_|___|  https://github.com/nlohmann/json

Licensed under the MIT License <http://opensource.org/licenses/MIT>.
SPDX-License-Identifier: MIT
Copyright (c) 2013-2019 Niels Lohmann <http://nlohmann.me>.

Permission is hereby  granted, free of charge, to any  person obtaining a copy
of this software and associated  documentation files (the "Software"), to deal
in the Software  without restriction, including without  limitation the rights
to  use, copy,  modify, merge,  publish, distribute,  sublicense, and/or  sell
copies  of  the Software,  and  to  permit persons  to  whom  the Software  is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE  IS PROVIDED "AS  IS", WITHOUT WARRANTY  OF ANY KIND,  EXPRESS OR
IMPLIED,  INCLUDING BUT  NOT  LIMITED TO  THE  WARRANTIES OF  MERCHANTABILITY,
FITNESS FOR  A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT  SHALL THE
AUTHORS  OR COPYRIGHT  HOLDERS  BE  LIABLE FOR  ANY  CLAIM,  DAMAGES OR  OTHER
LIABILITY, WHETHER IN AN ACTION OF  CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE  OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#ifndef INCLUDE_NLOHMANN_JSON_HPP_
#define INCLUDE_NLOHMANN_JSON_HPP_

#define NLOHMANN_JSON_VERSION_MAJOR 3
#define NLOHMANN_JSON_VERSION_MINOR 9
#define NLOHMANN_JSON_VERSION_PATCH 1

#include <algorithm> // all_of, find, for_each
#include <cstddef> // nullptr_t, ptrdiff_t, size_t
#include <functional> // hash, less
#include <initializer_list> // initializer_list
#include <iosfwd> // istream, ostream
#include <iterator> // random_access_iterator_tag
#include <memory> // unique_ptr
#include <numeric> // accumulate
#include <string> // string, stoi, to_string
#include <utility> // declval, forward, move, pair, swap
#include <vector> // vector

// #include <nlohmann/adl_serializer.hpp>


#include <utility>

// #include <nlohmann/detail/conversions/from_json.hpp>


#include <algorithm> // transform
#include <array> // array
#include <forward_list> // forward_list
#include <iterator> // inserter, front_inserter, end
#include <map> // map
#include <string> // string
#include <tuple> // tuple, make_tuple
#include <type_traits> // is_arithmetic, is_same, is_enum, underlying_type, is_convertible
#include <unordered_map> // unordered_map
#include <utility> // pair, declval
#include <valarray> // valarray

// #include <nlohmann/detail/exceptions.hpp>


#include <exception> // exception
#include <stdexcept> // runtime_error
#include <string> // to_string

// #include <nlohmann/detail/input/position_t.hpp>


#include <cstddef> // size_t

namespace nlohmann
{
namespace detail
{
/// struct to capture the start position of the current token
struct position_t
{
    /// the total number of characters read
    std::size_t chars_read_total = 0;
    /// the number of characters read in the current line
    std::size_t chars_read_current_line = 0;
    /// the number of lines read
    std::size_t lines_read = 0;

    /// conversion to size_t to preserve SAX interface
    constexpr operator size_t() const
    {
        return chars_read_total;
    }
};

} // namespace detail
} // namespace nlohmann

// #include <nlohmann/detail/macro_scope.hpp>


#include <utility> // pair
// #include <nlohmann/thirdparty/hedley/hedley.hpp>
/* Hedley - https://nemequ.github.io/hedley
 * Created by Evan Nemerson <evan@nemerson.com>
 *
 * To the extent possible under law, the author(s) have dedicated all
 * copyright and related and neighboring rights to this software to
 * the public domain worldwide. This software is distributed without
 * any warranty.
 *
 * For details, see <http://creativecommons.org/publicdomain/zero/1.0/>.
 * SPDX-License-Identifier: CC0-1.0
 */

#if !defined(JSON_HEDLEY_VERSION) || (JSON_HEDLEY_VERSION < 13)
#if defined(JSON_HEDLEY_VERSION)
    #undef JSON_HEDLEY_VERSION
#endif
#define JSON_HEDLEY_VERSION 13

#if defined(JSON_HEDLEY_STRINGIFY_EX)
    #undef JSON_HEDLEY_STRINGIFY_EX
#endif
#define JSON_HEDLEY_STRINGIFY_EX(x) #x

#if defined(JSON_HEDLEY_STRINGIFY)
    #undef JSON_HEDLEY_STRINGIFY
#endif
#define JSON_HEDLEY_STRINGIFY(x) JSON_HEDLEY_STRINGIFY_EX(x)

#if defined(JSON_HEDLEY_CONCAT_EX)
    #undef JSON_HEDLEY_CONCAT_EX
#endif
#define JSON_HEDLEY_CONCAT_EX(a,b) a##b

#if defined(JSON_HEDLEY_CONCAT)
    #undef JSON_HEDLEY_CONCAT
#endif
#define JSON_HEDLEY_CONCAT(a,b) JSON_HEDLEY_CONCAT_EX(a,b)

#if defined(JSON_HEDLEY_CONCAT3_EX)
    #undef JSON_HEDLEY_CONCAT3_EX
#endif
#define JSON_HEDLEY_CONCAT3_EX(a,b,c) a##b##c

#if defined(JSON_HEDLEY_CONCAT3)
    #undef JSON_HEDLEY_CONCAT3
#endif
#define JSON_HEDLEY_CONCAT3(a,b,c) JSON_HEDLEY_CONCAT3_EX(a,b,c)

#if defined(JSON_HEDLEY_VERSION_ENCODE)
    #undef JSON_HEDLEY_VERSION_ENCODE
#endif
#define JSON_HEDLEY_VERSION_ENCODE(major,minor,revision) (((major) * 1000000) + ((minor) * 1000) + (revision))

#if defined(JSON_HEDLEY_VERSION_DECODE_MAJOR)
    #undef JSON_HEDLEY_VERSION_DECODE_MAJOR
#endif
#define JSON_HEDLEY_VERSION_DECODE_MAJOR(version) ((version) / 1000000)

#if defined(JSON_HEDLEY_VERSION_DECODE_MINOR)
    #undef JSON_HEDLEY_VERSION_DECODE_MINOR
#endif
#define JSON_HEDLEY_VERSION_DECODE_MINOR(version) (((version) % 1000000) / 1000)

#if defined(JSON_HEDLEY_VERSION_DECODE_REVISION)
    #undef JSON_HEDLEY_VERSION_DECODE_REVISION
#endif
#define JSON_HEDLEY_VERSION_DECODE_REVISION(version) ((version) % 1000)

#if defined(JSON_HEDLEY_GNUC_VERSION)
    #undef JSON_HEDLEY_GNUC_VERSION
#endif
#if defined(__GNUC__) && defined(__GNUC_PATCHLEVEL__)
    #define JSON_HEDLEY_GNUC_VERSION JSON_HEDLEY_VERSION_ENCODE(__GNUC__, __GNUC_MINOR__, __GNUC_PATCHLEVEL__)
#elif defined(__GNUC__)
    #define JSON_HEDLEY_GNUC_VERSION JSON_HEDLEY_VERSION_ENCODE(__GNUC__, __GNUC_MINOR__, 0)
#endif

#if defined(JSON_HEDLEY_GNUC_VERSION_CHECK)
    #undef JSON_HEDLEY_GNUC_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_GNUC_VERSION)
    #define JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_GNUC_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_MSVC_VERSION)
    #undef JSON_HEDLEY_MSVC_VERSION
#endif
#if defined(_MSC_FULL_VER) && (_MSC_FULL_VER >= 140000000)
    #define JSON_HEDLEY_MSVC_VERSION JSON_HEDLEY_VERSION_ENCODE(_MSC_FULL_VER / 10000000, (_MSC_FULL_VER % 10000000) / 100000, (_MSC_FULL_VER % 100000) / 100)
#elif defined(_MSC_FULL_VER)
    #define JSON_HEDLEY_MSVC_VERSION JSON_HEDLEY_VERSION_ENCODE(_MSC_FULL_VER / 1000000, (_MSC_FULL_VER % 1000000) / 10000, (_MSC_FULL_VER % 10000) / 10)
#elif defined(_MSC_VER)
    #define JSON_HEDLEY_MSVC_VERSION JSON_HEDLEY_VERSION_ENCODE(_MSC_VER / 100, _MSC_VER % 100, 0)
#endif

#if defined(JSON_HEDLEY_MSVC_VERSION_CHECK)
    #undef JSON_HEDLEY_MSVC_VERSION_CHECK
#endif
#if !defined(_MSC_VER)
    #define JSON_HEDLEY_MSVC_VERSION_CHECK(major,minor,patch) (0)
#elif defined(_MSC_VER) && (_MSC_VER >= 1400)
    #define JSON_HEDLEY_MSVC_VERSION_CHECK(major,minor,patch) (_MSC_FULL_VER >= ((major * 10000000) + (minor * 100000) + (patch)))
#elif defined(_MSC_VER) && (_MSC_VER >= 1200)
    #define JSON_HEDLEY_MSVC_VERSION_CHECK(major,minor,patch) (_MSC_FULL_VER >= ((major * 1000000) + (minor * 10000) + (patch)))
#else
    #define JSON_HEDLEY_MSVC_VERSION_CHECK(major,minor,patch) (_MSC_VER >= ((major * 100) + (minor)))
#endif

#if defined(JSON_HEDLEY_INTEL_VERSION)
    #undef JSON_HEDLEY_INTEL_VERSION
#endif
#if defined(__INTEL_COMPILER) && defined(__INTEL_COMPILER_UPDATE)
    #define JSON_HEDLEY_INTEL_VERSION JSON_HEDLEY_VERSION_ENCODE(__INTEL_COMPILER / 100, __INTEL_COMPILER % 100, __INTEL_COMPILER_UPDATE)
#elif defined(__INTEL_COMPILER)
    #define JSON_HEDLEY_INTEL_VERSION JSON_HEDLEY_VERSION_ENCODE(__INTEL_COMPILER / 100, __INTEL_COMPILER % 100, 0)
#endif

#if defined(JSON_HEDLEY_INTEL_VERSION_CHECK)
    #undef JSON_HEDLEY_INTEL_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_INTEL_VERSION)
    #define JSON_HEDLEY_INTEL_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_INTEL_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_INTEL_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_PGI_VERSION)
    #undef JSON_HEDLEY_PGI_VERSION
#endif
#if defined(__PGI) && defined(__PGIC__) && defined(__PGIC_MINOR__) && defined(__PGIC_PATCHLEVEL__)
    #define JSON_HEDLEY_PGI_VERSION JSON_HEDLEY_VERSION_ENCODE(__PGIC__, __PGIC_MINOR__, __PGIC_PATCHLEVEL__)
#endif

#if defined(JSON_HEDLEY_PGI_VERSION_CHECK)
    #undef JSON_HEDLEY_PGI_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_PGI_VERSION)
    #define JSON_HEDLEY_PGI_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_PGI_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_PGI_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_SUNPRO_VERSION)
    #undef JSON_HEDLEY_SUNPRO_VERSION
#endif
#if defined(__SUNPRO_C) && (__SUNPRO_C > 0x1000)
    #define JSON_HEDLEY_SUNPRO_VERSION JSON_HEDLEY_VERSION_ENCODE((((__SUNPRO_C >> 16) & 0xf) * 10) + ((__SUNPRO_C >> 12) & 0xf), (((__SUNPRO_C >> 8) & 0xf) * 10) + ((__SUNPRO_C >> 4) & 0xf), (__SUNPRO_C & 0xf) * 10)
#elif defined(__SUNPRO_C)
    #define JSON_HEDLEY_SUNPRO_VERSION JSON_HEDLEY_VERSION_ENCODE((__SUNPRO_C >> 8) & 0xf, (__SUNPRO_C >> 4) & 0xf, (__SUNPRO_C) & 0xf)
#elif defined(__SUNPRO_CC) && (__SUNPRO_CC > 0x1000)
    #define JSON_HEDLEY_SUNPRO_VERSION JSON_HEDLEY_VERSION_ENCODE((((__SUNPRO_CC >> 16) & 0xf) * 10) + ((__SUNPRO_CC >> 12) & 0xf), (((__SUNPRO_CC >> 8) & 0xf) * 10) + ((__SUNPRO_CC >> 4) & 0xf), (__SUNPRO_CC & 0xf) * 10)
#elif defined(__SUNPRO_CC)
    #define JSON_HEDLEY_SUNPRO_VERSION JSON_HEDLEY_VERSION_ENCODE((__SUNPRO_CC >> 8) & 0xf, (__SUNPRO_CC >> 4) & 0xf, (__SUNPRO_CC) & 0xf)
#endif

#if defined(JSON_HEDLEY_SUNPRO_VERSION_CHECK)
    #undef JSON_HEDLEY_SUNPRO_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_SUNPRO_VERSION)
    #define JSON_HEDLEY_SUNPRO_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_SUNPRO_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_SUNPRO_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_EMSCRIPTEN_VERSION)
    #undef JSON_HEDLEY_EMSCRIPTEN_VERSION
#endif
#if defined(__EMSCRIPTEN__)
    #define JSON_HEDLEY_EMSCRIPTEN_VERSION JSON_HEDLEY_VERSION_ENCODE(__EMSCRIPTEN_major__, __EMSCRIPTEN_minor__, __EMSCRIPTEN_tiny__)
#endif

#if defined(JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK)
    #undef JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_EMSCRIPTEN_VERSION)
    #define JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_EMSCRIPTEN_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_ARM_VERSION)
    #undef JSON_HEDLEY_ARM_VERSION
#endif
#if defined(__CC_ARM) && defined(__ARMCOMPILER_VERSION)
    #define JSON_HEDLEY_ARM_VERSION JSON_HEDLEY_VERSION_ENCODE(__ARMCOMPILER_VERSION / 1000000, (__ARMCOMPILER_VERSION % 1000000) / 10000, (__ARMCOMPILER_VERSION % 10000) / 100)
#elif defined(__CC_ARM) && defined(__ARMCC_VERSION)
    #define JSON_HEDLEY_ARM_VERSION JSON_HEDLEY_VERSION_ENCODE(__ARMCC_VERSION / 1000000, (__ARMCC_VERSION % 1000000) / 10000, (__ARMCC_VERSION % 10000) / 100)
#endif

#if defined(JSON_HEDLEY_ARM_VERSION_CHECK)
    #undef JSON_HEDLEY_ARM_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_ARM_VERSION)
    #define JSON_HEDLEY_ARM_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_ARM_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_ARM_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_IBM_VERSION)
    #undef JSON_HEDLEY_IBM_VERSION
#endif
#if defined(__ibmxl__)
    #define JSON_HEDLEY_IBM_VERSION JSON_HEDLEY_VERSION_ENCODE(__ibmxl_version__, __ibmxl_release__, __ibmxl_modification__)
#elif defined(__xlC__) && defined(__xlC_ver__)
    #define JSON_HEDLEY_IBM_VERSION JSON_HEDLEY_VERSION_ENCODE(__xlC__ >> 8, __xlC__ & 0xff, (__xlC_ver__ >> 8) & 0xff)
#elif defined(__xlC__)
    #define JSON_HEDLEY_IBM_VERSION JSON_HEDLEY_VERSION_ENCODE(__xlC__ >> 8, __xlC__ & 0xff, 0)
#endif

#if defined(JSON_HEDLEY_IBM_VERSION_CHECK)
    #undef JSON_HEDLEY_IBM_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_IBM_VERSION)
    #define JSON_HEDLEY_IBM_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_IBM_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_IBM_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_TI_VERSION)
    #undef JSON_HEDLEY_TI_VERSION
#endif
#if \
    defined(__TI_COMPILER_VERSION__) && \
    ( \
      defined(__TMS470__) || defined(__TI_ARM__) || \
      defined(__MSP430__) || \
      defined(__TMS320C2000__) \
    )
#if (__TI_COMPILER_VERSION__ >= 16000000)
    #define JSON_HEDLEY_TI_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
#endif
#endif

#if defined(JSON_HEDLEY_TI_VERSION_CHECK)
    #undef JSON_HEDLEY_TI_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_TI_VERSION)
    #define JSON_HEDLEY_TI_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_TI_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_TI_CL2000_VERSION)
    #undef JSON_HEDLEY_TI_CL2000_VERSION
#endif
#if defined(__TI_COMPILER_VERSION__) && defined(__TMS320C2000__)
    #define JSON_HEDLEY_TI_CL2000_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
#endif

#if defined(JSON_HEDLEY_TI_CL2000_VERSION_CHECK)
    #undef JSON_HEDLEY_TI_CL2000_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_TI_CL2000_VERSION)
    #define JSON_HEDLEY_TI_CL2000_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CL2000_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_TI_CL2000_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_TI_CL430_VERSION)
    #undef JSON_HEDLEY_TI_CL430_VERSION
#endif
#if defined(__TI_COMPILER_VERSION__) && defined(__MSP430__)
    #define JSON_HEDLEY_TI_CL430_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
#endif

#if defined(JSON_HEDLEY_TI_CL430_VERSION_CHECK)
    #undef JSON_HEDLEY_TI_CL430_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_TI_CL430_VERSION)
    #define JSON_HEDLEY_TI_CL430_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CL430_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_TI_CL430_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_TI_ARMCL_VERSION)
    #undef JSON_HEDLEY_TI_ARMCL_VERSION
#endif
#if defined(__TI_COMPILER_VERSION__) && (defined(__TMS470__) || defined(__TI_ARM__))
    #define JSON_HEDLEY_TI_ARMCL_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
#endif

#if defined(JSON_HEDLEY_TI_ARMCL_VERSION_CHECK)
    #undef JSON_HEDLEY_TI_ARMCL_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_TI_ARMCL_VERSION)
    #define JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_ARMCL_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_TI_CL6X_VERSION)
    #undef JSON_HEDLEY_TI_CL6X_VERSION
#endif
#if defined(__TI_COMPILER_VERSION__) && defined(__TMS320C6X__)
    #define JSON_HEDLEY_TI_CL6X_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
#endif

#if defined(JSON_HEDLEY_TI_CL6X_VERSION_CHECK)
    #undef JSON_HEDLEY_TI_CL6X_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_TI_CL6X_VERSION)
    #define JSON_HEDLEY_TI_CL6X_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CL6X_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_TI_CL6X_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_TI_CL7X_VERSION)
    #undef JSON_HEDLEY_TI_CL7X_VERSION
#endif
#if defined(__TI_COMPILER_VERSION__) && defined(__C7000__)
    #define JSON_HEDLEY_TI_CL7X_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
#endif

#if defined(JSON_HEDLEY_TI_CL7X_VERSION_CHECK)
    #undef JSON_HEDLEY_TI_CL7X_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_TI_CL7X_VERSION)
    #define JSON_HEDLEY_TI_CL7X_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CL7X_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_TI_CL7X_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_TI_CLPRU_VERSION)
    #undef JSON_HEDLEY_TI_CLPRU_VERSION
#endif
#if defined(__TI_COMPILER_VERSION__) && defined(__PRU__)
    #define JSON_HEDLEY_TI_CLPRU_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
#endif

#if defined(JSON_HEDLEY_TI_CLPRU_VERSION_CHECK)
    #undef JSON_HEDLEY_TI_CLPRU_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_TI_CLPRU_VERSION)
    #define JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CLPRU_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_CRAY_VERSION)
    #undef JSON_HEDLEY_CRAY_VERSION
#endif
#if defined(_CRAYC)
    #if defined(_RELEASE_PATCHLEVEL)
        #define JSON_HEDLEY_CRAY_VERSION JSON_HEDLEY_VERSION_ENCODE(_RELEASE_MAJOR, _RELEASE_MINOR, _RELEASE_PATCHLEVEL)
    #else
        #define JSON_HEDLEY_CRAY_VERSION JSON_HEDLEY_VERSION_ENCODE(_RELEASE_MAJOR, _RELEASE_MINOR, 0)
    #endif
#endif

#if defined(JSON_HEDLEY_CRAY_VERSION_CHECK)
    #undef JSON_HEDLEY_CRAY_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_CRAY_VERSION)
    #define JSON_HEDLEY_CRAY_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_CRAY_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_CRAY_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_IAR_VERSION)
    #undef JSON_HEDLEY_IAR_VERSION
#endif
#if defined(__IAR_SYSTEMS_ICC__)
    #if __VER__ > 1000
        #define JSON_HEDLEY_IAR_VERSION JSON_HEDLEY_VERSION_ENCODE((__VER__ / 1000000), ((__VER__ / 1000) % 1000), (__VER__ % 1000))
    #else
        #define JSON_HEDLEY_IAR_VERSION JSON_HEDLEY_VERSION_ENCODE(VER / 100, __VER__ % 100, 0)
    #endif
#endif

#if defined(JSON_HEDLEY_IAR_VERSION_CHECK)
    #undef JSON_HEDLEY_IAR_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_IAR_VERSION)
    #define JSON_HEDLEY_IAR_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_IAR_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_IAR_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_TINYC_VERSION)
    #undef JSON_HEDLEY_TINYC_VERSION
#endif
#if defined(__TINYC__)
    #define JSON_HEDLEY_TINYC_VERSION JSON_HEDLEY_VERSION_ENCODE(__TINYC__ / 1000, (__TINYC__ / 100) % 10, __TINYC__ % 100)
#endif

#if defined(JSON_HEDLEY_TINYC_VERSION_CHECK)
    #undef JSON_HEDLEY_TINYC_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_TINYC_VERSION)
    #define JSON_HEDLEY_TINYC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TINYC_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_TINYC_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_DMC_VERSION)
    #undef JSON_HEDLEY_DMC_VERSION
#endif
#if defined(__DMC__)
    #define JSON_HEDLEY_DMC_VERSION JSON_HEDLEY_VERSION_ENCODE(__DMC__ >> 8, (__DMC__ >> 4) & 0xf, __DMC__ & 0xf)
#endif

#if defined(JSON_HEDLEY_DMC_VERSION_CHECK)
    #undef JSON_HEDLEY_DMC_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_DMC_VERSION)
    #define JSON_HEDLEY_DMC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_DMC_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_DMC_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_COMPCERT_VERSION)
    #undef JSON_HEDLEY_COMPCERT_VERSION
#endif
#if defined(__COMPCERT_VERSION__)
    #define JSON_HEDLEY_COMPCERT_VERSION JSON_HEDLEY_VERSION_ENCODE(__COMPCERT_VERSION__ / 10000, (__COMPCERT_VERSION__ / 100) % 100, __COMPCERT_VERSION__ % 100)
#endif

#if defined(JSON_HEDLEY_COMPCERT_VERSION_CHECK)
    #undef JSON_HEDLEY_COMPCERT_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_COMPCERT_VERSION)
    #define JSON_HEDLEY_COMPCERT_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_COMPCERT_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_COMPCERT_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_PELLES_VERSION)
    #undef JSON_HEDLEY_PELLES_VERSION
#endif
#if defined(__POCC__)
    #define JSON_HEDLEY_PELLES_VERSION JSON_HEDLEY_VERSION_ENCODE(__POCC__ / 100, __POCC__ % 100, 0)
#endif

#if defined(JSON_HEDLEY_PELLES_VERSION_CHECK)
    #undef JSON_HEDLEY_PELLES_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_PELLES_VERSION)
    #define JSON_HEDLEY_PELLES_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_PELLES_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_PELLES_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_GCC_VERSION)
    #undef JSON_HEDLEY_GCC_VERSION
#endif
#if \
    defined(JSON_HEDLEY_GNUC_VERSION) && \
    !defined(__clang__) && \
    !defined(JSON_HEDLEY_INTEL_VERSION) && \
    !defined(JSON_HEDLEY_PGI_VERSION) && \
    !defined(JSON_HEDLEY_ARM_VERSION) && \
    !defined(JSON_HEDLEY_TI_VERSION) && \
    !defined(JSON_HEDLEY_TI_ARMCL_VERSION) && \
    !defined(JSON_HEDLEY_TI_CL430_VERSION) && \
    !defined(JSON_HEDLEY_TI_CL2000_VERSION) && \
    !defined(JSON_HEDLEY_TI_CL6X_VERSION) && \
    !defined(JSON_HEDLEY_TI_CL7X_VERSION) && \
    !defined(JSON_HEDLEY_TI_CLPRU_VERSION) && \
    !defined(__COMPCERT__)
    #define JSON_HEDLEY_GCC_VERSION JSON_HEDLEY_GNUC_VERSION
#endif

#if defined(JSON_HEDLEY_GCC_VERSION_CHECK)
    #undef JSON_HEDLEY_GCC_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_GCC_VERSION)
    #define JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_GCC_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_HAS_ATTRIBUTE)
    #undef JSON_HEDLEY_HAS_ATTRIBUTE
#endif
#if defined(__has_attribute)
    #define JSON_HEDLEY_HAS_ATTRIBUTE(attribute) __has_attribute(attribute)
#else
    #define JSON_HEDLEY_HAS_ATTRIBUTE(attribute) (0)
#endif

#if defined(JSON_HEDLEY_GNUC_HAS_ATTRIBUTE)
    #undef JSON_HEDLEY_GNUC_HAS_ATTRIBUTE
#endif
#if defined(__has_attribute)
    #define JSON_HEDLEY_GNUC_HAS_ATTRIBUTE(attribute,major,minor,patch) __has_attribute(attribute)
#else
    #define JSON_HEDLEY_GNUC_HAS_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_GCC_HAS_ATTRIBUTE)
    #undef JSON_HEDLEY_GCC_HAS_ATTRIBUTE
#endif
#if defined(__has_attribute)
    #define JSON_HEDLEY_GCC_HAS_ATTRIBUTE(attribute,major,minor,patch) __has_attribute(attribute)
#else
    #define JSON_HEDLEY_GCC_HAS_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_HAS_CPP_ATTRIBUTE)
    #undef JSON_HEDLEY_HAS_CPP_ATTRIBUTE
#endif
#if \
    defined(__has_cpp_attribute) && \
    defined(__cplusplus) && \
    (!defined(JSON_HEDLEY_SUNPRO_VERSION) || JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,15,0))
    #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE(attribute) __has_cpp_attribute(attribute)
#else
    #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE(attribute) (0)
#endif

#if defined(JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS)
    #undef JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS
#endif
#if !defined(__cplusplus) || !defined(__has_cpp_attribute)
    #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS(ns,attribute) (0)
#elif \
    !defined(JSON_HEDLEY_PGI_VERSION) && \
    !defined(JSON_HEDLEY_IAR_VERSION) && \
    (!defined(JSON_HEDLEY_SUNPRO_VERSION) || JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,15,0)) && \
    (!defined(JSON_HEDLEY_MSVC_VERSION) || JSON_HEDLEY_MSVC_VERSION_CHECK(19,20,0))
    #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS(ns,attribute) JSON_HEDLEY_HAS_CPP_ATTRIBUTE(ns::attribute)
#else
    #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS(ns,attribute) (0)
#endif

#if defined(JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE)
    #undef JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE
#endif
#if defined(__has_cpp_attribute) && defined(__cplusplus)
    #define JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE(attribute,major,minor,patch) __has_cpp_attribute(attribute)
#else
    #define JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE)
    #undef JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE
#endif
#if defined(__has_cpp_attribute) && defined(__cplusplus)
    #define JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE(attribute,major,minor,patch) __has_cpp_attribute(attribute)
#else
    #define JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_HAS_BUILTIN)
    #undef JSON_HEDLEY_HAS_BUILTIN
#endif
#if defined(__has_builtin)
    #define JSON_HEDLEY_HAS_BUILTIN(builtin) __has_builtin(builtin)
#else
    #define JSON_HEDLEY_HAS_BUILTIN(builtin) (0)
#endif

#if defined(JSON_HEDLEY_GNUC_HAS_BUILTIN)
    #undef JSON_HEDLEY_GNUC_HAS_BUILTIN
#endif
#if defined(__has_builtin)
    #define JSON_HEDLEY_GNUC_HAS_BUILTIN(builtin,major,minor,patch) __has_builtin(builtin)
#else
    #define JSON_HEDLEY_GNUC_HAS_BUILTIN(builtin,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_GCC_HAS_BUILTIN)
    #undef JSON_HEDLEY_GCC_HAS_BUILTIN
#endif
#if defined(__has_builtin)
    #define JSON_HEDLEY_GCC_HAS_BUILTIN(builtin,major,minor,patch) __has_builtin(builtin)
#else
    #define JSON_HEDLEY_GCC_HAS_BUILTIN(builtin,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_HAS_FEATURE)
    #undef JSON_HEDLEY_HAS_FEATURE
#endif
#if defined(__has_feature)
    #define JSON_HEDLEY_HAS_FEATURE(feature) __has_feature(feature)
#else
    #define JSON_HEDLEY_HAS_FEATURE(feature) (0)
#endif

#if defined(JSON_HEDLEY_GNUC_HAS_FEATURE)
    #undef JSON_HEDLEY_GNUC_HAS_FEATURE
#endif
#if defined(__has_feature)
    #define JSON_HEDLEY_GNUC_HAS_FEATURE(feature,major,minor,patch) __has_feature(feature)
#else
    #define JSON_HEDLEY_GNUC_HAS_FEATURE(feature,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_GCC_HAS_FEATURE)
    #undef JSON_HEDLEY_GCC_HAS_FEATURE
#endif
#if defined(__has_feature)
    #define JSON_HEDLEY_GCC_HAS_FEATURE(feature,major,minor,patch) __has_feature(feature)
#else
    #define JSON_HEDLEY_GCC_HAS_FEATURE(feature,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_HAS_EXTENSION)
    #undef JSON_HEDLEY_HAS_EXTENSION
#endif
#if defined(__has_extension)
    #define JSON_HEDLEY_HAS_EXTENSION(extension) __has_extension(extension)
#else
    #define JSON_HEDLEY_HAS_EXTENSION(extension) (0)
#endif

#if defined(JSON_HEDLEY_GNUC_HAS_EXTENSION)
    #undef JSON_HEDLEY_GNUC_HAS_EXTENSION
#endif
#if defined(__has_extension)
    #define JSON_HEDLEY_GNUC_HAS_EXTENSION(extension,major,minor,patch) __has_extension(extension)
#else
    #define JSON_HEDLEY_GNUC_HAS_EXTENSION(extension,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_GCC_HAS_EXTENSION)
    #undef JSON_HEDLEY_GCC_HAS_EXTENSION
#endif
#if defined(__has_extension)
    #define JSON_HEDLEY_GCC_HAS_EXTENSION(extension,major,minor,patch) __has_extension(extension)
#else
    #define JSON_HEDLEY_GCC_HAS_EXTENSION(extension,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE)
    #undef JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE
#endif
#if defined(__has_declspec_attribute)
    #define JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE(attribute) __has_declspec_attribute(attribute)
#else
    #define JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE(attribute) (0)
#endif

#if defined(JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE)
    #undef JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE
#endif
#if defined(__has_declspec_attribute)
    #define JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE(attribute,major,minor,patch) __has_declspec_attribute(attribute)
#else
    #define JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE)
    #undef JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE
#endif
#if defined(__has_declspec_attribute)
    #define JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE(attribute,major,minor,patch) __has_declspec_attribute(attribute)
#else
    #define JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_HAS_WARNING)
    #undef JSON_HEDLEY_HAS_WARNING
#endif
#if defined(__has_warning)
    #define JSON_HEDLEY_HAS_WARNING(warning) __has_warning(warning)
#else
    #define JSON_HEDLEY_HAS_WARNING(warning) (0)
#endif

#if defined(JSON_HEDLEY_GNUC_HAS_WARNING)
    #undef JSON_HEDLEY_GNUC_HAS_WARNING
#endif
#if defined(__has_warning)
    #define JSON_HEDLEY_GNUC_HAS_WARNING(warning,major,minor,patch) __has_warning(warning)
#else
    #define JSON_HEDLEY_GNUC_HAS_WARNING(warning,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_GCC_HAS_WARNING)
    #undef JSON_HEDLEY_GCC_HAS_WARNING
#endif
#if defined(__has_warning)
    #define JSON_HEDLEY_GCC_HAS_WARNING(warning,major,minor,patch) __has_warning(warning)
#else
    #define JSON_HEDLEY_GCC_HAS_WARNING(warning,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
#endif

/* JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_ is for
   HEDLEY INTERNAL USE ONLY.  API subject to change without notice. */
#if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_)
    #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_
#endif
#if defined(__cplusplus)
#  if JSON_HEDLEY_HAS_WARNING("-Wc++98-compat")
#    if JSON_HEDLEY_HAS_WARNING("-Wc++17-extensions")
#      define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(xpr) \
    JSON_HEDLEY_DIAGNOSTIC_PUSH \
    _Pragma("clang diagnostic ignored \"-Wc++98-compat\"") \
    _Pragma("clang diagnostic ignored \"-Wc++17-extensions\"") \
    xpr \
    JSON_HEDLEY_DIAGNOSTIC_POP
#    else
#      define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(xpr) \
    JSON_HEDLEY_DIAGNOSTIC_PUSH \
    _Pragma("clang diagnostic ignored \"-Wc++98-compat\"") \
    xpr \
    JSON_HEDLEY_DIAGNOSTIC_POP
#    endif
#  endif
#endif
#if !defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(x) x
#endif

#if defined(JSON_HEDLEY_CONST_CAST)
    #undef JSON_HEDLEY_CONST_CAST
#endif
#if defined(__cplusplus)
#  define JSON_HEDLEY_CONST_CAST(T, expr) (const_cast<T>(expr))
#elif \
  JSON_HEDLEY_HAS_WARNING("-Wcast-qual") || \
  JSON_HEDLEY_GCC_VERSION_CHECK(4,6,0) || \
  JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
#  define JSON_HEDLEY_CONST_CAST(T, expr) (__extension__ ({ \
        JSON_HEDLEY_DIAGNOSTIC_PUSH \
        JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL \
        ((T) (expr)); \
        JSON_HEDLEY_DIAGNOSTIC_POP \
    }))
#else
#  define JSON_HEDLEY_CONST_CAST(T, expr) ((T) (expr))
#endif

#if defined(JSON_HEDLEY_REINTERPRET_CAST)
    #undef JSON_HEDLEY_REINTERPRET_CAST
#endif
#if defined(__cplusplus)
    #define JSON_HEDLEY_REINTERPRET_CAST(T, expr) (reinterpret_cast<T>(expr))
#else
    #define JSON_HEDLEY_REINTERPRET_CAST(T, expr) ((T) (expr))
#endif

#if defined(JSON_HEDLEY_STATIC_CAST)
    #undef JSON_HEDLEY_STATIC_CAST
#endif
#if defined(__cplusplus)
    #define JSON_HEDLEY_STATIC_CAST(T, expr) (static_cast<T>(expr))
#else
    #define JSON_HEDLEY_STATIC_CAST(T, expr) ((T) (expr))
#endif

#if defined(JSON_HEDLEY_CPP_CAST)
    #undef JSON_HEDLEY_CPP_CAST
#endif
#if defined(__cplusplus)
#  if JSON_HEDLEY_HAS_WARNING("-Wold-style-cast")
#    define JSON_HEDLEY_CPP_CAST(T, expr) \
    JSON_HEDLEY_DIAGNOSTIC_PUSH \
    _Pragma("clang diagnostic ignored \"-Wold-style-cast\"") \
    ((T) (expr)) \
    JSON_HEDLEY_DIAGNOSTIC_POP
#  elif JSON_HEDLEY_IAR_VERSION_CHECK(8,3,0)
#    define JSON_HEDLEY_CPP_CAST(T, expr) \
    JSON_HEDLEY_DIAGNOSTIC_PUSH \
    _Pragma("diag_suppress=Pe137") \
    JSON_HEDLEY_DIAGNOSTIC_POP \
#  else
#    define JSON_HEDLEY_CPP_CAST(T, expr) ((T) (expr))
#  endif
#else
#  define JSON_HEDLEY_CPP_CAST(T, expr) (expr)
#endif

#if \
    (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)) || \
    defined(__clang__) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,0,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0) || \
    JSON_HEDLEY_PGI_VERSION_CHECK(18,4,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,7,0) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(2,0,1) || \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,1,0) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,0,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
    JSON_HEDLEY_CRAY_VERSION_CHECK(5,0,0) || \
    JSON_HEDLEY_TINYC_VERSION_CHECK(0,9,17) || \
    JSON_HEDLEY_SUNPRO_VERSION_CHECK(8,0,0) || \
    (JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) && defined(__C99_PRAGMA_OPERATOR))
    #define JSON_HEDLEY_PRAGMA(value) _Pragma(#value)
#elif JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0)
    #define JSON_HEDLEY_PRAGMA(value) __pragma(value)
#else
    #define JSON_HEDLEY_PRAGMA(value)
#endif

#if defined(JSON_HEDLEY_DIAGNOSTIC_PUSH)
    #undef JSON_HEDLEY_DIAGNOSTIC_PUSH
#endif
#if defined(JSON_HEDLEY_DIAGNOSTIC_POP)
    #undef JSON_HEDLEY_DIAGNOSTIC_POP
#endif
#if defined(__clang__)
    #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("clang diagnostic push")
    #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("clang diagnostic pop")
#elif JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("warning(push)")
    #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("warning(pop)")
#elif JSON_HEDLEY_GCC_VERSION_CHECK(4,6,0)
    #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("GCC diagnostic push")
    #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("GCC diagnostic pop")
#elif JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_PUSH __pragma(warning(push))
    #define JSON_HEDLEY_DIAGNOSTIC_POP __pragma(warning(pop))
#elif JSON_HEDLEY_ARM_VERSION_CHECK(5,6,0)
    #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("push")
    #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("pop")
#elif \
    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,4,0) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,1,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0)
    #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("diag_push")
    #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("diag_pop")
#elif JSON_HEDLEY_PELLES_VERSION_CHECK(2,90,0)
    #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("warning(push)")
    #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("warning(pop)")
#else
    #define JSON_HEDLEY_DIAGNOSTIC_PUSH
    #define JSON_HEDLEY_DIAGNOSTIC_POP
#endif

#if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED)
    #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED
#endif
#if JSON_HEDLEY_HAS_WARNING("-Wdeprecated-declarations")
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("clang diagnostic ignored \"-Wdeprecated-declarations\"")
#elif JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("warning(disable:1478 1786)")
#elif JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("diag_suppress 1215,1444")
#elif JSON_HEDLEY_GCC_VERSION_CHECK(4,3,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("GCC diagnostic ignored \"-Wdeprecated-declarations\"")
#elif JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED __pragma(warning(disable:4996))
#elif \
    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("diag_suppress 1291,1718")
#elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,13,0) && !defined(__cplusplus)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("error_messages(off,E_DEPRECATED_ATT,E_DEPRECATED_ATT_MESS)")
#elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,13,0) && defined(__cplusplus)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("error_messages(off,symdeprecated,symdeprecated2)")
#elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("diag_suppress=Pe1444,Pe1215")
#elif JSON_HEDLEY_PELLES_VERSION_CHECK(2,90,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("warn(disable:2241)")
#else
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED
#endif

#if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS)
    #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS
#endif
#if JSON_HEDLEY_HAS_WARNING("-Wunknown-pragmas")
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("clang diagnostic ignored \"-Wunknown-pragmas\"")
#elif JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("warning(disable:161)")
#elif JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("diag_suppress 1675")
#elif JSON_HEDLEY_GCC_VERSION_CHECK(4,3,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("GCC diagnostic ignored \"-Wunknown-pragmas\"")
#elif JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS __pragma(warning(disable:4068))
#elif \
    JSON_HEDLEY_TI_VERSION_CHECK(16,9,0) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,0,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,3,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("diag_suppress 163")
#elif JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("diag_suppress 163")
#elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("diag_suppress=Pe161")
#else
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS
#endif

#if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES)
    #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES
#endif
#if JSON_HEDLEY_HAS_WARNING("-Wunknown-attributes")
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("clang diagnostic ignored \"-Wunknown-attributes\"")
#elif JSON_HEDLEY_GCC_VERSION_CHECK(4,6,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("GCC diagnostic ignored \"-Wdeprecated-declarations\"")
#elif JSON_HEDLEY_INTEL_VERSION_CHECK(17,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("warning(disable:1292)")
#elif JSON_HEDLEY_MSVC_VERSION_CHECK(19,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES __pragma(warning(disable:5030))
#elif JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("diag_suppress 1097")
#elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,14,0) && defined(__cplusplus)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("error_messages(off,attrskipunsup)")
#elif \
    JSON_HEDLEY_TI_VERSION_CHECK(18,1,0) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,3,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("diag_suppress 1173")
#elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("diag_suppress=Pe1097")
#else
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES
#endif

#if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL)
    #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL
#endif
#if JSON_HEDLEY_HAS_WARNING("-Wcast-qual")
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL _Pragma("clang diagnostic ignored \"-Wcast-qual\"")
#elif JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL _Pragma("warning(disable:2203 2331)")
#elif JSON_HEDLEY_GCC_VERSION_CHECK(3,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL _Pragma("GCC diagnostic ignored \"-Wcast-qual\"")
#else
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL
#endif

#if defined(JSON_HEDLEY_DEPRECATED)
    #undef JSON_HEDLEY_DEPRECATED
#endif
#if defined(JSON_HEDLEY_DEPRECATED_FOR)
    #undef JSON_HEDLEY_DEPRECATED_FOR
#endif
#if JSON_HEDLEY_MSVC_VERSION_CHECK(14,0,0)
    #define JSON_HEDLEY_DEPRECATED(since) __declspec(deprecated("Since " # since))
    #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) __declspec(deprecated("Since " #since "; use " #replacement))
#elif defined(__cplusplus) && (__cplusplus >= 201402L)
    #define JSON_HEDLEY_DEPRECATED(since) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[deprecated("Since " #since)]])
    #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[deprecated("Since " #since "; use " #replacement)]])
#elif \
    JSON_HEDLEY_HAS_EXTENSION(attribute_deprecated_with_message) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(4,5,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(5,6,0) || \
    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,13,0) || \
    JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0) || \
    JSON_HEDLEY_TI_VERSION_CHECK(18,1,0) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(18,1,0) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,3,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,3,0)
    #define JSON_HEDLEY_DEPRECATED(since) __attribute__((__deprecated__("Since " #since)))
    #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) __attribute__((__deprecated__("Since " #since "; use " #replacement)))
#elif \
    JSON_HEDLEY_HAS_ATTRIBUTE(deprecated) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,1,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0)
    #define JSON_HEDLEY_DEPRECATED(since) __attribute__((__deprecated__))
    #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) __attribute__((__deprecated__))
#elif \
    JSON_HEDLEY_MSVC_VERSION_CHECK(13,10,0) || \
    JSON_HEDLEY_PELLES_VERSION_CHECK(6,50,0)
    #define JSON_HEDLEY_DEPRECATED(since) __declspec(deprecated)
    #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) __declspec(deprecated)
#elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
    #define JSON_HEDLEY_DEPRECATED(since) _Pragma("deprecated")
    #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) _Pragma("deprecated")
#else
    #define JSON_HEDLEY_DEPRECATED(since)
    #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement)
#endif

#if defined(JSON_HEDLEY_UNAVAILABLE)
    #undef JSON_HEDLEY_UNAVAILABLE
#endif
#if \
    JSON_HEDLEY_HAS_ATTRIBUTE(warning) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(4,3,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
    #define JSON_HEDLEY_UNAVAILABLE(available_since) __attribute__((__warning__("Not available until " #available_since)))
#else
    #define JSON_HEDLEY_UNAVAILABLE(available_since)
#endif

#if defined(JSON_HEDLEY_WARN_UNUSED_RESULT)
    #undef JSON_HEDLEY_WARN_UNUSED_RESULT
#endif
#if defined(JSON_HEDLEY_WARN_UNUSED_RESULT_MSG)
    #undef JSON_HEDLEY_WARN_UNUSED_RESULT_MSG
#endif
#if (JSON_HEDLEY_HAS_CPP_ATTRIBUTE(nodiscard) >= 201907L)
    #define JSON_HEDLEY_WARN_UNUSED_RESULT JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[nodiscard]])
    #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[nodiscard(msg)]])
#elif JSON_HEDLEY_HAS_CPP_ATTRIBUTE(nodiscard)
    #define JSON_HEDLEY_WARN_UNUSED_RESULT JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[nodiscard]])
    #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[nodiscard]])
#elif \
    JSON_HEDLEY_HAS_ATTRIBUTE(warn_unused_result) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,4,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
    (JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,15,0) && defined(__cplusplus)) || \
    JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0)
    #define JSON_HEDLEY_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))
    #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg) __attribute__((__warn_unused_result__))
#elif defined(_Check_return_) /* SAL */
    #define JSON_HEDLEY_WARN_UNUSED_RESULT _Check_return_
    #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg) _Check_return_
#else
    #define JSON_HEDLEY_WARN_UNUSED_RESULT
    #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg)
#endif

#if defined(JSON_HEDLEY_SENTINEL)
    #undef JSON_HEDLEY_SENTINEL
#endif
#if \
    JSON_HEDLEY_HAS_ATTRIBUTE(sentinel) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(4,0,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(5,4,0)
    #define JSON_HEDLEY_SENTINEL(position) __attribute__((__sentinel__(position)))
#else
    #define JSON_HEDLEY_SENTINEL(position)
#endif

#if defined(JSON_HEDLEY_NO_RETURN)
    #undef JSON_HEDLEY_NO_RETURN
#endif
#if JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
    #define JSON_HEDLEY_NO_RETURN __noreturn
#elif JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
    #define JSON_HEDLEY_NO_RETURN __attribute__((__noreturn__))
#elif defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L
    #define JSON_HEDLEY_NO_RETURN _Noreturn
#elif defined(__cplusplus) && (__cplusplus >= 201103L)
    #define JSON_HEDLEY_NO_RETURN JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[noreturn]])
#elif \
    JSON_HEDLEY_HAS_ATTRIBUTE(noreturn) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,2,0) || \
    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0)
    #define JSON_HEDLEY_NO_RETURN __attribute__((__noreturn__))
#elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0)
    #define JSON_HEDLEY_NO_RETURN _Pragma("does_not_return")
#elif JSON_HEDLEY_MSVC_VERSION_CHECK(13,10,0)
    #define JSON_HEDLEY_NO_RETURN __declspec(noreturn)
#elif JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,0,0) && defined(__cplusplus)
    #define JSON_HEDLEY_NO_RETURN _Pragma("FUNC_NEVER_RETURNS;")
#elif JSON_HEDLEY_COMPCERT_VERSION_CHECK(3,2,0)
    #define JSON_HEDLEY_NO_RETURN __attribute((noreturn))
#elif JSON_HEDLEY_PELLES_VERSION_CHECK(9,0,0)
    #define JSON_HEDLEY_NO_RETURN __declspec(noreturn)
#else
    #define JSON_HEDLEY_NO_RETURN
#endif

#if defined(JSON_HEDLEY_NO_ESCAPE)
    #undef JSON_HEDLEY_NO_ESCAPE
#endif
#if JSON_HEDLEY_HAS_ATTRIBUTE(noescape)
    #define JSON_HEDLEY_NO_ESCAPE __attribute__((__noescape__))
#else
    #define JSON_HEDLEY_NO_ESCAPE
#endif

#if defined(JSON_HEDLEY_UNREACHABLE)
    #undef JSON_HEDLEY_UNREACHABLE
#endif
#if defined(JSON_HEDLEY_UNREACHABLE_RETURN)
    #undef JSON_HEDLEY_UNREACHABLE_RETURN
#endif
#if defined(JSON_HEDLEY_ASSUME)
    #undef JSON_HEDLEY_ASSUME
#endif
#if \
    JSON_HEDLEY_MSVC_VERSION_CHECK(13,10,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
    #define JSON_HEDLEY_ASSUME(expr) __assume(expr)
#elif JSON_HEDLEY_HAS_BUILTIN(__builtin_assume)
    #define JSON_HEDLEY_ASSUME(expr) __builtin_assume(expr)
#elif \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,2,0) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(4,0,0)
    #if defined(__cplusplus)
        #define JSON_HEDLEY_ASSUME(expr) std::_nassert(expr)
    #else
        #define JSON_HEDLEY_ASSUME(expr) _nassert(expr)
    #endif
#endif
#if \
    (JSON_HEDLEY_HAS_BUILTIN(__builtin_unreachable) && (!defined(JSON_HEDLEY_ARM_VERSION))) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(4,5,0) || \
    JSON_HEDLEY_PGI_VERSION_CHECK(18,10,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_IBM_VERSION_CHECK(13,1,5)
    #define JSON_HEDLEY_UNREACHABLE() __builtin_unreachable()
#elif defined(JSON_HEDLEY_ASSUME)
    #define JSON_HEDLEY_UNREACHABLE() JSON_HEDLEY_ASSUME(0)
#endif
#if !defined(JSON_HEDLEY_ASSUME)
    #if defined(JSON_HEDLEY_UNREACHABLE)
        #define JSON_HEDLEY_ASSUME(expr) JSON_HEDLEY_STATIC_CAST(void, ((expr) ? 1 : (JSON_HEDLEY_UNREACHABLE(), 1)))
    #else
        #define JSON_HEDLEY_ASSUME(expr) JSON_HEDLEY_STATIC_CAST(void, expr)
    #endif
#endif
#if defined(JSON_HEDLEY_UNREACHABLE)
    #if  \
        JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,2,0) || \
        JSON_HEDLEY_TI_CL6X_VERSION_CHECK(4,0,0)
        #define JSON_HEDLEY_UNREACHABLE_RETURN(value) return (JSON_HEDLEY_STATIC_CAST(void, JSON_HEDLEY_ASSUME(0)), (value))
    #else
        #define JSON_HEDLEY_UNREACHABLE_RETURN(value) JSON_HEDLEY_UNREACHABLE()
    #endif
#else
    #define JSON_HEDLEY_UNREACHABLE_RETURN(value) return (value)
#endif
#if !defined(JSON_HEDLEY_UNREACHABLE)
    #define JSON_HEDLEY_UNREACHABLE() JSON_HEDLEY_ASSUME(0)
#endif

JSON_HEDLEY_DIAGNOSTIC_PUSH
#if JSON_HEDLEY_HAS_WARNING("-Wpedantic")
    #pragma clang diagnostic ignored "-Wpedantic"
#endif
#if JSON_HEDLEY_HAS_WARNING("-Wc++98-compat-pedantic") && defined(__cplusplus)
    #pragma clang diagnostic ignored "-Wc++98-compat-pedantic"
#endif
#if JSON_HEDLEY_GCC_HAS_WARNING("-Wvariadic-macros",4,0,0)
    #if defined(__clang__)
        #pragma clang diagnostic ignored "-Wvariadic-macros"
    #elif defined(JSON_HEDLEY_GCC_VERSION)
        #pragma GCC diagnostic ignored "-Wvariadic-macros"
    #endif
#endif
#if defined(JSON_HEDLEY_NON_NULL)
    #undef JSON_HEDLEY_NON_NULL
#endif
#if \
    JSON_HEDLEY_HAS_ATTRIBUTE(nonnull) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,3,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0)
    #define JSON_HEDLEY_NON_NULL(...) __attribute__((__nonnull__(__VA_ARGS__)))
#else
    #define JSON_HEDLEY_NON_NULL(...)
#endif
JSON_HEDLEY_DIAGNOSTIC_POP

#if defined(JSON_HEDLEY_PRINTF_FORMAT)
    #undef JSON_HEDLEY_PRINTF_FORMAT
#endif
#if defined(__MINGW32__) && JSON_HEDLEY_GCC_HAS_ATTRIBUTE(format,4,4,0) && !defined(__USE_MINGW_ANSI_STDIO)
    #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check) __attribute__((__format__(ms_printf, string_idx, first_to_check)))
#elif defined(__MINGW32__) && JSON_HEDLEY_GCC_HAS_ATTRIBUTE(format,4,4,0) && defined(__USE_MINGW_ANSI_STDIO)
    #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check) __attribute__((__format__(gnu_printf, string_idx, first_to_check)))
#elif \
    JSON_HEDLEY_HAS_ATTRIBUTE(format) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,1,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(5,6,0) || \
    JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0)
    #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check) __attribute__((__format__(__printf__, string_idx, first_to_check)))
#elif JSON_HEDLEY_PELLES_VERSION_CHECK(6,0,0)
    #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check) __declspec(vaformat(printf,string_idx,first_to_check))
#else
    #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check)
#endif

#if defined(JSON_HEDLEY_CONSTEXPR)
    #undef JSON_HEDLEY_CONSTEXPR
#endif
#if defined(__cplusplus)
    #if __cplusplus >= 201103L
        #define JSON_HEDLEY_CONSTEXPR JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(constexpr)
    #endif
#endif
#if !defined(JSON_HEDLEY_CONSTEXPR)
    #define JSON_HEDLEY_CONSTEXPR
#endif

#if defined(JSON_HEDLEY_PREDICT)
    #undef JSON_HEDLEY_PREDICT
#endif
#if defined(JSON_HEDLEY_LIKELY)
    #undef JSON_HEDLEY_LIKELY
#endif
#if defined(JSON_HEDLEY_UNLIKELY)
    #undef JSON_HEDLEY_UNLIKELY
#endif
#if defined(JSON_HEDLEY_UNPREDICTABLE)
    #undef JSON_HEDLEY_UNPREDICTABLE
#endif
#if JSON_HEDLEY_HAS_BUILTIN(__builtin_unpredictable)
    #define JSON_HEDLEY_UNPREDICTABLE(expr) __builtin_unpredictable((expr))
#endif
#if \
  JSON_HEDLEY_HAS_BUILTIN(__builtin_expect_with_probability) || \
  JSON_HEDLEY_GCC_VERSION_CHECK(9,0,0)
#  define JSON_HEDLEY_PREDICT(expr, value, probability) __builtin_expect_with_probability(  (expr), (value), (probability))
#  define JSON_HEDLEY_PREDICT_TRUE(expr, probability)   __builtin_expect_with_probability(!!(expr),    1   , (probability))
#  define JSON_HEDLEY_PREDICT_FALSE(expr, probability)  __builtin_expect_with_probability(!!(expr),    0   , (probability))
#  define JSON_HEDLEY_LIKELY(expr)                      __builtin_expect                 (!!(expr),    1                  )
#  define JSON_HEDLEY_UNLIKELY(expr)                    __builtin_expect                 (!!(expr),    0                  )
#elif \
  JSON_HEDLEY_HAS_BUILTIN(__builtin_expect) || \
  JSON_HEDLEY_GCC_VERSION_CHECK(3,0,0) || \
  JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
  (JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,15,0) && defined(__cplusplus)) || \
  JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
  JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
  JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
  JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,7,0) || \
  JSON_HEDLEY_TI_CL430_VERSION_CHECK(3,1,0) || \
  JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,1,0) || \
  JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,1,0) || \
  JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
  JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
  JSON_HEDLEY_TINYC_VERSION_CHECK(0,9,27) || \
  JSON_HEDLEY_CRAY_VERSION_CHECK(8,1,0)
#  define JSON_HEDLEY_PREDICT(expr, expected, probability) \
    (((probability) >= 0.9) ? __builtin_expect((expr), (expected)) : (JSON_HEDLEY_STATIC_CAST(void, expected), (expr)))
#  define JSON_HEDLEY_PREDICT_TRUE(expr, probability) \
    (__extension__ ({ \
        double hedley_probability_ = (probability); \
        ((hedley_probability_ >= 0.9) ? __builtin_expect(!!(expr), 1) : ((hedley_probability_ <= 0.1) ? __builtin_expect(!!(expr), 0) : !!(expr))); \
    }))
#  define JSON_HEDLEY_PREDICT_FALSE(expr, probability) \
    (__extension__ ({ \
        double hedley_probability_ = (probability); \
        ((hedley_probability_ >= 0.9) ? __builtin_expect(!!(expr), 0) : ((hedley_probability_ <= 0.1) ? __builtin_expect(!!(expr), 1) : !!(expr))); \
    }))
#  define JSON_HEDLEY_LIKELY(expr)   __builtin_expect(!!(expr), 1)
#  define JSON_HEDLEY_UNLIKELY(expr) __builtin_expect(!!(expr), 0)
#else
#  define JSON_HEDLEY_PREDICT(expr, expected, probability) (JSON_HEDLEY_STATIC_CAST(void, expected), (expr))
#  define JSON_HEDLEY_PREDICT_TRUE(expr, probability) (!!(expr))
#  define JSON_HEDLEY_PREDICT_FALSE(expr, probability) (!!(expr))
#  define JSON_HEDLEY_LIKELY(expr) (!!(expr))
#  define JSON_HEDLEY_UNLIKELY(expr) (!!(expr))
#endif
#if !defined(JSON_HEDLEY_UNPREDICTABLE)
    #define JSON_HEDLEY_UNPREDICTABLE(expr) JSON_HEDLEY_PREDICT(expr, 1, 0.5)
#endif

#if defined(JSON_HEDLEY_MALLOC)
    #undef JSON_HEDLEY_MALLOC
#endif
#if \
    JSON_HEDLEY_HAS_ATTRIBUTE(malloc) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,1,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_IBM_VERSION_CHECK(12,1,0) || \
    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0)
    #define JSON_HEDLEY_MALLOC __attribute__((__malloc__))
#elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0)
    #define JSON_HEDLEY_MALLOC _Pragma("returns_new_memory")
#elif JSON_HEDLEY_MSVC_VERSION_CHECK(14, 0, 0)
    #define JSON_HEDLEY_MALLOC __declspec(restrict)
#else
    #define JSON_HEDLEY_MALLOC
#endif

#if defined(JSON_HEDLEY_PURE)
    #undef JSON_HEDLEY_PURE
#endif
#if \
  JSON_HEDLEY_HAS_ATTRIBUTE(pure) || \
  JSON_HEDLEY_GCC_VERSION_CHECK(2,96,0) || \
  JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
  JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
  JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
  JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
  JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
  (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
  JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
  (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
  JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
  (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
  JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
  (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
  JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
  JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
  JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
  JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0)
#  define JSON_HEDLEY_PURE __attribute__((__pure__))
#elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0)
#  define JSON_HEDLEY_PURE _Pragma("does_not_write_global_data")
#elif defined(__cplusplus) && \
    ( \
      JSON_HEDLEY_TI_CL430_VERSION_CHECK(2,0,1) || \
      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(4,0,0) || \
      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) \
    )
#  define JSON_HEDLEY_PURE _Pragma("FUNC_IS_PURE;")
#else
#  define JSON_HEDLEY_PURE
#endif

#if defined(JSON_HEDLEY_CONST)
    #undef JSON_HEDLEY_CONST
#endif
#if \
    JSON_HEDLEY_HAS_ATTRIBUTE(const) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(2,5,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
    JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0)
    #define JSON_HEDLEY_CONST __attribute__((__const__))
#elif \
    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0)
    #define JSON_HEDLEY_CONST _Pragma("no_side_effect")
#else
    #define JSON_HEDLEY_CONST JSON_HEDLEY_PURE
#endif

#if defined(JSON_HEDLEY_RESTRICT)
    #undef JSON_HEDLEY_RESTRICT
#endif
#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) && !defined(__cplusplus)
    #define JSON_HEDLEY_RESTRICT restrict
#elif \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,1,0) || \
    JSON_HEDLEY_MSVC_VERSION_CHECK(14,0,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
    JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,2,4) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,1,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    (JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,14,0) && defined(__cplusplus)) || \
    JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0) || \
    defined(__clang__)
    #define JSON_HEDLEY_RESTRICT __restrict
#elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,3,0) && !defined(__cplusplus)
    #define JSON_HEDLEY_RESTRICT _Restrict
#else
    #define JSON_HEDLEY_RESTRICT
#endif

#if defined(JSON_HEDLEY_INLINE)
    #undef JSON_HEDLEY_INLINE
#endif
#if \
    (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)) || \
    (defined(__cplusplus) && (__cplusplus >= 199711L))
    #define JSON_HEDLEY_INLINE inline
#elif \
    defined(JSON_HEDLEY_GCC_VERSION) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(6,2,0)
    #define JSON_HEDLEY_INLINE __inline__
#elif \
    JSON_HEDLEY_MSVC_VERSION_CHECK(12,0,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,1,0) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(3,1,0) || \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,2,0) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,0,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0)
    #define JSON_HEDLEY_INLINE __inline
#else
    #define JSON_HEDLEY_INLINE
#endif

#if defined(JSON_HEDLEY_ALWAYS_INLINE)
    #undef JSON_HEDLEY_ALWAYS_INLINE
#endif
#if \
  JSON_HEDLEY_HAS_ATTRIBUTE(always_inline) || \
  JSON_HEDLEY_GCC_VERSION_CHECK(4,0,0) || \
  JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
  JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
  JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
  JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
  JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
  (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
  JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
  (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
  JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
  (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
  JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
  (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
  JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
  JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
  JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0)
#  define JSON_HEDLEY_ALWAYS_INLINE __attribute__((__always_inline__)) JSON_HEDLEY_INLINE
#elif JSON_HEDLEY_MSVC_VERSION_CHECK(12,0,0)
#  define JSON_HEDLEY_ALWAYS_INLINE __forceinline
#elif defined(__cplusplus) && \
    ( \
      JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
      JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
      JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,1,0) || \
      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
      JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) \
    )
#  define JSON_HEDLEY_ALWAYS_INLINE _Pragma("FUNC_ALWAYS_INLINE;")
#elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
#  define JSON_HEDLEY_ALWAYS_INLINE _Pragma("inline=forced")
#else
#  define JSON_HEDLEY_ALWAYS_INLINE JSON_HEDLEY_INLINE
#endif

#if defined(JSON_HEDLEY_NEVER_INLINE)
    #undef JSON_HEDLEY_NEVER_INLINE
#endif
#if \
    JSON_HEDLEY_HAS_ATTRIBUTE(noinline) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(4,0,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0)
    #define JSON_HEDLEY_NEVER_INLINE __attribute__((__noinline__))
#elif JSON_HEDLEY_MSVC_VERSION_CHECK(13,10,0)
    #define JSON_HEDLEY_NEVER_INLINE __declspec(noinline)
#elif JSON_HEDLEY_PGI_VERSION_CHECK(10,2,0)
    #define JSON_HEDLEY_NEVER_INLINE _Pragma("noinline")
#elif JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,0,0) && defined(__cplusplus)
    #define JSON_HEDLEY_NEVER_INLINE _Pragma("FUNC_CANNOT_INLINE;")
#elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
    #define JSON_HEDLEY_NEVER_INLINE _Pragma("inline=never")
#elif JSON_HEDLEY_COMPCERT_VERSION_CHECK(3,2,0)
    #define JSON_HEDLEY_NEVER_INLINE __attribute((noinline))
#elif JSON_HEDLEY_PELLES_VERSION_CHECK(9,0,0)
    #define JSON_HEDLEY_NEVER_INLINE __declspec(noinline)
#else
    #define JSON_HEDLEY_NEVER_INLINE
#endif

#if defined(JSON_HEDLEY_PRIVATE)
    #undef JSON_HEDLEY_PRIVATE
#endif
#if defined(JSON_HEDLEY_PUBLIC)
    #undef JSON_HEDLEY_PUBLIC
#endif
#if defined(JSON_HEDLEY_IMPORT)
    #undef JSON_HEDLEY_IMPORT
#endif
#if defined(_WIN32) || defined(__CYGWIN__)
#  define JSON_HEDLEY_PRIVATE
#  define JSON_HEDLEY_PUBLIC   __declspec(dllexport)
#  define JSON_HEDLEY_IMPORT   __declspec(dllimport)
#else
#  if \
    JSON_HEDLEY_HAS_ATTRIBUTE(visibility) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,3,0) || \
    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_IBM_VERSION_CHECK(13,1,0) || \
    ( \
      defined(__TI_EABI__) && \
      ( \
        (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
        JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) \
      ) \
    )
#    define JSON_HEDLEY_PRIVATE __attribute__((__visibility__("hidden")))
#    define JSON_HEDLEY_PUBLIC  __attribute__((__visibility__("default")))
#  else
#    define JSON_HEDLEY_PRIVATE
#    define JSON_HEDLEY_PUBLIC
#  endif
#  define JSON_HEDLEY_IMPORT    extern
#endif

#if defined(JSON_HEDLEY_NO_THROW)
    #undef JSON_HEDLEY_NO_THROW
#endif
#if \
    JSON_HEDLEY_HAS_ATTRIBUTE(nothrow) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,3,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
    #define JSON_HEDLEY_NO_THROW __attribute__((__nothrow__))
#elif \
    JSON_HEDLEY_MSVC_VERSION_CHECK(13,1,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0)
    #define JSON_HEDLEY_NO_THROW __declspec(nothrow)
#else
    #define JSON_HEDLEY_NO_THROW
#endif

#if defined(JSON_HEDLEY_FALL_THROUGH)
    #undef JSON_HEDLEY_FALL_THROUGH
#endif
#if \
    JSON_HEDLEY_HAS_ATTRIBUTE(fallthrough) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(7,0,0)
    #define JSON_HEDLEY_FALL_THROUGH __attribute__((__fallthrough__))
#elif JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS(clang,fallthrough)
    #define JSON_HEDLEY_FALL_THROUGH JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[clang::fallthrough]])
#elif JSON_HEDLEY_HAS_CPP_ATTRIBUTE(fallthrough)
    #define JSON_HEDLEY_FALL_THROUGH JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[fallthrough]])
#elif defined(__fallthrough) /* SAL */
    #define JSON_HEDLEY_FALL_THROUGH __fallthrough
#else
    #define JSON_HEDLEY_FALL_THROUGH
#endif

#if defined(JSON_HEDLEY_RETURNS_NON_NULL)
    #undef JSON_HEDLEY_RETURNS_NON_NULL
#endif
#if \
    JSON_HEDLEY_HAS_ATTRIBUTE(returns_nonnull) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(4,9,0)
    #define JSON_HEDLEY_RETURNS_NON_NULL __attribute__((__returns_nonnull__))
#elif defined(_Ret_notnull_) /* SAL */
    #define JSON_HEDLEY_RETURNS_NON_NULL _Ret_notnull_
#else
    #define JSON_HEDLEY_RETURNS_NON_NULL
#endif

#if defined(JSON_HEDLEY_ARRAY_PARAM)
    #undef JSON_HEDLEY_ARRAY_PARAM
#endif
#if \
    defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) && \
    !defined(__STDC_NO_VLA__) && \
    !defined(__cplusplus) && \
    !defined(JSON_HEDLEY_PGI_VERSION) && \
    !defined(JSON_HEDLEY_TINYC_VERSION)
    #define JSON_HEDLEY_ARRAY_PARAM(name) (name)
#else
    #define JSON_HEDLEY_ARRAY_PARAM(name)
#endif

#if defined(JSON_HEDLEY_IS_CONSTANT)
    #undef JSON_HEDLEY_IS_CONSTANT
#endif
#if defined(JSON_HEDLEY_REQUIRE_CONSTEXPR)
    #undef JSON_HEDLEY_REQUIRE_CONSTEXPR
#endif
/* JSON_HEDLEY_IS_CONSTEXPR_ is for
   HEDLEY INTERNAL USE ONLY.  API subject to change without notice. */
#if defined(JSON_HEDLEY_IS_CONSTEXPR_)
    #undef JSON_HEDLEY_IS_CONSTEXPR_
#endif
#if \
    JSON_HEDLEY_HAS_BUILTIN(__builtin_constant_p) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,4,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_TINYC_VERSION_CHECK(0,9,19) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_IBM_VERSION_CHECK(13,1,0) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,1,0) || \
    (JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0) && !defined(__cplusplus)) || \
    JSON_HEDLEY_CRAY_VERSION_CHECK(8,1,0)
    #define JSON_HEDLEY_IS_CONSTANT(expr) __builtin_constant_p(expr)
#endif
#if !defined(__cplusplus)
#  if \
       JSON_HEDLEY_HAS_BUILTIN(__builtin_types_compatible_p) || \
       JSON_HEDLEY_GCC_VERSION_CHECK(3,4,0) || \
       JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
       JSON_HEDLEY_IBM_VERSION_CHECK(13,1,0) || \
       JSON_HEDLEY_CRAY_VERSION_CHECK(8,1,0) || \
       JSON_HEDLEY_ARM_VERSION_CHECK(5,4,0) || \
       JSON_HEDLEY_TINYC_VERSION_CHECK(0,9,24)
#if defined(__INTPTR_TYPE__)
    #define JSON_HEDLEY_IS_CONSTEXPR_(expr) __builtin_types_compatible_p(__typeof__((1 ? (void*) ((__INTPTR_TYPE__) ((expr) * 0)) : (int*) 0)), int*)
#else
    #include <stdint.h>
    #define JSON_HEDLEY_IS_CONSTEXPR_(expr) __builtin_types_compatible_p(__typeof__((1 ? (void*) ((intptr_t) ((expr) * 0)) : (int*) 0)), int*)
#endif
#  elif \
       ( \
          defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L) && \
          !defined(JSON_HEDLEY_SUNPRO_VERSION) && \
          !defined(JSON_HEDLEY_PGI_VERSION) && \
          !defined(JSON_HEDLEY_IAR_VERSION)) || \
       JSON_HEDLEY_HAS_EXTENSION(c_generic_selections) || \
       JSON_HEDLEY_GCC_VERSION_CHECK(4,9,0) || \
       JSON_HEDLEY_INTEL_VERSION_CHECK(17,0,0) || \
       JSON_HEDLEY_IBM_VERSION_CHECK(12,1,0) || \
       JSON_HEDLEY_ARM_VERSION_CHECK(5,3,0)
#if defined(__INTPTR_TYPE__)
    #define JSON_HEDLEY_IS_CONSTEXPR_(expr) _Generic((1 ? (void*) ((__INTPTR_TYPE__) ((expr) * 0)) : (int*) 0), int*: 1, void*: 0)
#else
    #include <stdint.h>
    #define JSON_HEDLEY_IS_CONSTEXPR_(expr) _Generic((1 ? (void*) ((intptr_t) * 0) : (int*) 0), int*: 1, void*: 0)
#endif
#  elif \
       defined(JSON_HEDLEY_GCC_VERSION) || \
       defined(JSON_HEDLEY_INTEL_VERSION) || \
       defined(JSON_HEDLEY_TINYC_VERSION) || \
       defined(JSON_HEDLEY_TI_ARMCL_VERSION) || \
       JSON_HEDLEY_TI_CL430_VERSION_CHECK(18,12,0) || \
       defined(JSON_HEDLEY_TI_CL2000_VERSION) || \
       defined(JSON_HEDLEY_TI_CL6X_VERSION) || \
       defined(JSON_HEDLEY_TI_CL7X_VERSION) || \
       defined(JSON_HEDLEY_TI_CLPRU_VERSION) || \
       defined(__clang__)
#    define JSON_HEDLEY_IS_CONSTEXPR_(expr) ( \
        sizeof(void) != \
        sizeof(*( \
                  1 ? \
                  ((void*) ((expr) * 0L) ) : \
((struct { char v[sizeof(void) * 2]; } *) 1) \
                ) \
              ) \
                                            )
#  endif
#endif
#if defined(JSON_HEDLEY_IS_CONSTEXPR_)
    #if !defined(JSON_HEDLEY_IS_CONSTANT)
        #define JSON_HEDLEY_IS_CONSTANT(expr) JSON_HEDLEY_IS_CONSTEXPR_(expr)
    #endif
    #define JSON_HEDLEY_REQUIRE_CONSTEXPR(expr) (JSON_HEDLEY_IS_CONSTEXPR_(expr) ? (expr) : (-1))
#else
    #if !defined(JSON_HEDLEY_IS_CONSTANT)
        #define JSON_HEDLEY_IS_CONSTANT(expr) (0)
    #endif
    #define JSON_HEDLEY_REQUIRE_CONSTEXPR(expr) (expr)
#endif

#if defined(JSON_HEDLEY_BEGIN_C_DECLS)
    #undef JSON_HEDLEY_BEGIN_C_DECLS
#endif
#if defined(JSON_HEDLEY_END_C_DECLS)
    #undef JSON_HEDLEY_END_C_DECLS
#endif
#if defined(JSON_HEDLEY_C_DECL)
    #undef JSON_HEDLEY_C_DECL
#endif
#if defined(__cplusplus)
    #define JSON_HEDLEY_BEGIN_C_DECLS extern "C" {
    #define JSON_HEDLEY_END_C_DECLS }
    #define JSON_HEDLEY_C_DECL extern "C"
#else
    #define JSON_HEDLEY_BEGIN_C_DECLS
    #define JSON_HEDLEY_END_C_DECLS
    #define JSON_HEDLEY_C_DECL
#endif

#if defined(JSON_HEDLEY_STATIC_ASSERT)
    #undef JSON_HEDLEY_STATIC_ASSERT
#endif
#if \
  !defined(__cplusplus) && ( \
      (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L)) || \
      JSON_HEDLEY_HAS_FEATURE(c_static_assert) || \
      JSON_HEDLEY_GCC_VERSION_CHECK(6,0,0) || \
      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
      defined(_Static_assert) \
    )
#  define JSON_HEDLEY_STATIC_ASSERT(expr, message) _Static_assert(expr, message)
#elif \
  (defined(__cplusplus) && (__cplusplus >= 201103L)) || \
  JSON_HEDLEY_MSVC_VERSION_CHECK(16,0,0)
#  define JSON_HEDLEY_STATIC_ASSERT(expr, message) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(static_assert(expr, message))
#else
#  define JSON_HEDLEY_STATIC_ASSERT(expr, message)
#endif

#if defined(JSON_HEDLEY_NULL)
    #undef JSON_HEDLEY_NULL
#endif
#if defined(__cplusplus)
    #if __cplusplus >= 201103L
        #define JSON_HEDLEY_NULL JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(nullptr)
    #elif defined(NULL)
        #define JSON_HEDLEY_NULL NULL
    #else
        #define JSON_HEDLEY_NULL JSON_HEDLEY_STATIC_CAST(void*, 0)
    #endif
#elif defined(NULL)
    #define JSON_HEDLEY_NULL NULL
#else
    #define JSON_HEDLEY_NULL ((void*) 0)
#endif

#if defined(JSON_HEDLEY_MESSAGE)
    #undef JSON_HEDLEY_MESSAGE
#endif
#if JSON_HEDLEY_HAS_WARNING("-Wunknown-pragmas")
#  define JSON_HEDLEY_MESSAGE(msg) \
    JSON_HEDLEY_DIAGNOSTIC_PUSH \
    JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS \
    JSON_HEDLEY_PRAGMA(message msg) \
    JSON_HEDLEY_DIAGNOSTIC_POP
#elif \
  JSON_HEDLEY_GCC_VERSION_CHECK(4,4,0) || \
  JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
#  define JSON_HEDLEY_MESSAGE(msg) JSON_HEDLEY_PRAGMA(message msg)
#elif JSON_HEDLEY_CRAY_VERSION_CHECK(5,0,0)
#  define JSON_HEDLEY_MESSAGE(msg) JSON_HEDLEY_PRAGMA(_CRI message msg)
#elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
#  define JSON_HEDLEY_MESSAGE(msg) JSON_HEDLEY_PRAGMA(message(msg))
#elif JSON_HEDLEY_PELLES_VERSION_CHECK(2,0,0)
#  define JSON_HEDLEY_MESSAGE(msg) JSON_HEDLEY_PRAGMA(message(msg))
#else
#  define JSON_HEDLEY_MESSAGE(msg)
#endif

#if defined(JSON_HEDLEY_WARNING)
    #undef JSON_HEDLEY_WARNING
#endif
#if JSON_HEDLEY_HAS_WARNING("-Wunknown-pragmas")
#  define JSON_HEDLEY_WARNING(msg) \
    JSON_HEDLEY_DIAGNOSTIC_PUSH \
    JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS \
    JSON_HEDLEY_PRAGMA(clang warning msg) \
    JSON_HEDLEY_DIAGNOSTIC_POP
#elif \
  JSON_HEDLEY_GCC_VERSION_CHECK(4,8,0) || \
  JSON_HEDLEY_PGI_VERSION_CHECK(18,4,0) || \
  JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
#  define JSON_HEDLEY_WARNING(msg) JSON_HEDLEY_PRAGMA(GCC warning msg)
#elif JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0)
#  define JSON_HEDLEY_WARNING(msg) JSON_HEDLEY_PRAGMA(message(msg))
#else
#  define JSON_HEDLEY_WARNING(msg) JSON_HEDLEY_MESSAGE(msg)
#endif

#if defined(JSON_HEDLEY_REQUIRE)
    #undef JSON_HEDLEY_REQUIRE
#endif
#if defined(JSON_HEDLEY_REQUIRE_MSG)
    #undef JSON_HEDLEY_REQUIRE_MSG
#endif
#if JSON_HEDLEY_HAS_ATTRIBUTE(diagnose_if)
#  if JSON_HEDLEY_HAS_WARNING("-Wgcc-compat")
#    define JSON_HEDLEY_REQUIRE(expr) \
    JSON_HEDLEY_DIAGNOSTIC_PUSH \
    _Pragma("clang diagnostic ignored \"-Wgcc-compat\"") \
    __attribute__((diagnose_if(!(expr), #expr, "error"))) \
    JSON_HEDLEY_DIAGNOSTIC_POP
#    define JSON_HEDLEY_REQUIRE_MSG(expr,msg) \
    JSON_HEDLEY_DIAGNOSTIC_PUSH \
    _Pragma("clang diagnostic ignored \"-Wgcc-compat\"") \
    __attribute__((diagnose_if(!(expr), msg, "error"))) \
    JSON_HEDLEY_DIAGNOSTIC_POP
#  else
#    define JSON_HEDLEY_REQUIRE(expr) __attribute__((diagnose_if(!(expr), #expr, "error")))
#    define JSON_HEDLEY_REQUIRE_MSG(expr,msg) __attribute__((diagnose_if(!(expr), msg, "error")))
#  endif
#else
#  define JSON_HEDLEY_REQUIRE(expr)
#  define JSON_HEDLEY_REQUIRE_MSG(expr,msg)
#endif

#if defined(JSON_HEDLEY_FLAGS)
    #undef JSON_HEDLEY_FLAGS
#endif
#if JSON_HEDLEY_HAS_ATTRIBUTE(flag_enum)
    #define JSON_HEDLEY_FLAGS __attribute__((__flag_enum__))
#endif

#if defined(JSON_HEDLEY_FLAGS_CAST)
    #undef JSON_HEDLEY_FLAGS_CAST
#endif
#if JSON_HEDLEY_INTEL_VERSION_CHECK(19,0,0)
#  define JSON_HEDLEY_FLAGS_CAST(T, expr) (__extension__ ({ \
        JSON_HEDLEY_DIAGNOSTIC_PUSH \
        _Pragma("warning(disable:188)") \
        ((T) (expr)); \
        JSON_HEDLEY_DIAGNOSTIC_POP \
    }))
#else
#  define JSON_HEDLEY_FLAGS_CAST(T, expr) JSON_HEDLEY_STATIC_CAST(T, expr)
#endif

#if defined(JSON_HEDLEY_EMPTY_BASES)
    #undef JSON_HEDLEY_EMPTY_BASES
#endif
#if JSON_HEDLEY_MSVC_VERSION_CHECK(19,0,23918) && !JSON_HEDLEY_MSVC_VERSION_CHECK(20,0,0)
    #define JSON_HEDLEY_EMPTY_BASES __declspec(empty_bases)
#else
    #define JSON_HEDLEY_EMPTY_BASES
#endif

/* Remaining macros are deprecated. */

#if defined(JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK)
    #undef JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK
#endif
#if defined(__clang__)
    #define JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK(major,minor,patch) (0)
#else
    #define JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK(major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_CLANG_HAS_ATTRIBUTE)
    #undef JSON_HEDLEY_CLANG_HAS_ATTRIBUTE
#endif
#define JSON_HEDLEY_CLANG_HAS_ATTRIBUTE(attribute) JSON_HEDLEY_HAS_ATTRIBUTE(attribute)

#if defined(JSON_HEDLEY_CLANG_HAS_CPP_ATTRIBUTE)
    #undef JSON_HEDLEY_CLANG_HAS_CPP_ATTRIBUTE
#endif
#define JSON_HEDLEY_CLANG_HAS_CPP_ATTRIBUTE(attribute) JSON_HEDLEY_HAS_CPP_ATTRIBUTE(attribute)

#if defined(JSON_HEDLEY_CLANG_HAS_BUILTIN)
    #undef JSON_HEDLEY_CLANG_HAS_BUILTIN
#endif
#define JSON_HEDLEY_CLANG_HAS_BUILTIN(builtin) JSON_HEDLEY_HAS_BUILTIN(builtin)

#if defined(JSON_HEDLEY_CLANG_HAS_FEATURE)
    #undef JSON_HEDLEY_CLANG_HAS_FEATURE
#endif
#define JSON_HEDLEY_CLANG_HAS_FEATURE(feature) JSON_HEDLEY_HAS_FEATURE(feature)

#if defined(JSON_HEDLEY_CLANG_HAS_EXTENSION)
    #undef JSON_HEDLEY_CLANG_HAS_EXTENSION
#endif
#define JSON_HEDLEY_CLANG_HAS_EXTENSION(extension) JSON_HEDLEY_HAS_EXTENSION(extension)

#if defined(JSON_HEDLEY_CLANG_HAS_DECLSPEC_DECLSPEC_ATTRIBUTE)
    #undef JSON_HEDLEY_CLANG_HAS_DECLSPEC_DECLSPEC_ATTRIBUTE
#endif
#define JSON_HEDLEY_CLANG_HAS_DECLSPEC_ATTRIBUTE(attribute) JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE(attribute)

#if defined(JSON_HEDLEY_CLANG_HAS_WARNING)
    #undef JSON_HEDLEY_CLANG_HAS_WARNING
#endif
#define JSON_HEDLEY_CLANG_HAS_WARNING(warning) JSON_HEDLEY_HAS_WARNING(warning)

#endif /* !defined(JSON_HEDLEY_VERSION) || (JSON_HEDLEY_VERSION < X) */


// This file contains all internal macro definitions
// You MUST include macro_unscope.hpp at the end of json.hpp to undef all of them

// exclude unsupported compilers
#if !defined(JSON_SKIP_UNSUPPORTED_COMPILER_CHECK)
    #if defined(__clang__)
        #if (__clang_major__ * 10000 + __clang_minor__ * 100 + __clang_patchlevel__) < 30400
            #error "unsupported Clang version - see https://github.com/nlohmann/json#supported-compilers"
        #endif
    #elif defined(__GNUC__) && !(defined(__ICC) || defined(__INTEL_COMPILER))
        #if (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__) < 40800
            #error "unsupported GCC version - see https://github.com/nlohmann/json#supported-compilers"
        #endif
    #endif
#endif

// C++ language standard detection
#if (defined(__cplusplus) && __cplusplus >= 202002L) || (defined(_MSVC_LANG) && _MSVC_LANG >= 202002L)
    #define JSON_HAS_CPP_20
    #define JSON_HAS_CPP_17
    #define JSON_HAS_CPP_14
#elif (defined(__cplusplus) && __cplusplus >= 201703L) || (defined(_HAS_CXX17) && _HAS_CXX17 == 1) // fix for issue #464
    #define JSON_HAS_CPP_17
    #define JSON_HAS_CPP_14
#elif (defined(__cplusplus) && __cplusplus >= 201402L) || (defined(_HAS_CXX14) && _HAS_CXX14 == 1)
    #define JSON_HAS_CPP_14
#endif

// disable float-equal warnings on GCC/clang
#if defined(__clang__) || defined(__GNUC__) || defined(__GNUG__)
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wfloat-equal"
#endif

// disable documentation warnings on clang
#if defined(__clang__)
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wdocumentation"
#endif

// allow to disable exceptions
#if (defined(__cpp_exceptions) || defined(__EXCEPTIONS) || defined(_CPPUNWIND)) && !defined(JSON_NOEXCEPTION)
    #define JSON_THROW(exception) throw exception
    #define JSON_TRY try
    #define JSON_CATCH(exception) catch(exception)
    #define JSON_INTERNAL_CATCH(exception) catch(exception)
#else
    #include <cstdlib>
    #define JSON_THROW(exception) std::abort()
    #define JSON_TRY if(true)
    #define JSON_CATCH(exception) if(false)
    #define JSON_INTERNAL_CATCH(exception) if(false)
#endif

// override exception macros
#if defined(JSON_THROW_USER)
    #undef JSON_THROW
    #define JSON_THROW JSON_THROW_USER
#endif
#if defined(JSON_TRY_USER)
    #undef JSON_TRY
    #define JSON_TRY JSON_TRY_USER
#endif
#if defined(JSON_CATCH_USER)
    #undef JSON_CATCH
    #define JSON_CATCH JSON_CATCH_USER
    #undef JSON_INTERNAL_CATCH
    #define JSON_INTERNAL_CATCH JSON_CATCH_USER
#endif
#if defined(JSON_INTERNAL_CATCH_USER)
    #undef JSON_INTERNAL_CATCH
    #define JSON_INTERNAL_CATCH JSON_INTERNAL_CATCH_USER
#endif

// allow to override assert
#if !defined(JSON_ASSERT)
    #include <cassert> // assert
    #define JSON_ASSERT(x) assert(x)
#endif

/*!
@brief macro to briefly define a mapping between an enum and JSON
@def NLOHMANN_JSON_SERIALIZE_ENUM
@since version 3.4.0
*/
#define NLOHMANN_JSON_SERIALIZE_ENUM(ENUM_TYPE, ...)                                            \
    template<typename BasicJsonType>                                                            \
    inline void to_json(BasicJsonType& j, const ENUM_TYPE& e)                                   \
    {                                                                                           \
        static_assert(std::is_enum<ENUM_TYPE>::value, #ENUM_TYPE " must be an enum!");          \
        static const std::pair<ENUM_TYPE, BasicJsonType> m[] = __VA_ARGS__;                     \
        auto it = std::find_if(std::begin(m), std::end(m),                                      \
                               [e](const std::pair<ENUM_TYPE, BasicJsonType>& ej_pair) -> bool  \
        {                                                                                       \
            return ej_pair.first == e;                                                          \
        });                                                                                     \
        j = ((it != std::end(m)) ? it : std::begin(m))->second;                                 \
    }                                                                                           \
    template<typename BasicJsonType>                                                            \
    inline void from_json(const BasicJsonType& j, ENUM_TYPE& e)                                 \
    {                                                                                           \
        static_assert(std::is_enum<ENUM_TYPE>::value, #ENUM_TYPE " must be an enum!");          \
        static const std::pair<ENUM_TYPE, BasicJsonType> m[] = __VA_ARGS__;                     \
        auto it = std::find_if(std::begin(m), std::end(m),                                      \
                               [&j](const std::pair<ENUM_TYPE, BasicJsonType>& ej_pair) -> bool \
        {                                                                                       \
            return ej_pair.second == j;                                                         \
        });                                                                                     \
        e = ((it != std::end(m)) ? it : std::begin(m))->first;                                  \
    }

// Ugly macros to avoid uglier copy-paste when specializing basic_json. They
// may be removed in the future once the class is split.

#define NLOHMANN_BASIC_JSON_TPL_DECLARATION                                \
    template<template<typename, typename, typename...> class ObjectType,   \
             template<typename, typename...> class ArrayType,              \
             class StringType, class BooleanType, class NumberIntegerType, \
             class NumberUnsignedType, class NumberFloatType,              \
             template<typename> class AllocatorType,                       \
             template<typename, typename = void> class JSONSerializer,     \
             class BinaryType>

#define NLOHMANN_BASIC_JSON_TPL                                            \
    basic_json<ObjectType, ArrayType, StringType, BooleanType,             \
    NumberIntegerType, NumberUnsignedType, NumberFloatType,                \
    AllocatorType, JSONSerializer, BinaryType>

// Macros to simplify conversion from/to types

#define NLOHMANN_JSON_EXPAND( x ) x
#define NLOHMANN_JSON_GET_MACRO(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, NAME,...) NAME
#define NLOHMANN_JSON_PASTE(...) NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_GET_MACRO(__VA_ARGS__, \
        NLOHMANN_JSON_PASTE64, \
        NLOHMANN_JSON_PASTE63, \
        NLOHMANN_JSON_PASTE62, \
        NLOHMANN_JSON_PASTE61, \
        NLOHMANN_JSON_PASTE60, \
        NLOHMANN_JSON_PASTE59, \
        NLOHMANN_JSON_PASTE58, \
        NLOHMANN_JSON_PASTE57, \
        NLOHMANN_JSON_PASTE56, \
        NLOHMANN_JSON_PASTE55, \
        NLOHMANN_JSON_PASTE54, \
        NLOHMANN_JSON_PASTE53, \
        NLOHMANN_JSON_PASTE52, \
        NLOHMANN_JSON_PASTE51, \
        NLOHMANN_JSON_PASTE50, \
        NLOHMANN_JSON_PASTE49, \
        NLOHMANN_JSON_PASTE48, \
        NLOHMANN_JSON_PASTE47, \
        NLOHMANN_JSON_PASTE46, \
        NLOHMANN_JSON_PASTE45, \
        NLOHMANN_JSON_PASTE44, \
        NLOHMANN_JSON_PASTE43, \
        NLOHMANN_JSON_PASTE42, \
        NLOHMANN_JSON_PASTE41, \
        NLOHMANN_JSON_PASTE40, \
        NLOHMANN_JSON_PASTE39, \
        NLOHMANN_JSON_PASTE38, \
        NLOHMANN_JSON_PASTE37, \
        NLOHMANN_JSON_PASTE36, \
        NLOHMANN_JSON_PASTE35, \
        NLOHMANN_JSON_PASTE34, \
        NLOHMANN_JSON_PASTE33, \
        NLOHMANN_JSON_PASTE32, \
        NLOHMANN_JSON_PASTE31, \
        NLOHMANN_JSON_PASTE30, \
        NLOHMANN_JSON_PASTE29, \
        NLOHMANN_JSON_PASTE28, \
        NLOHMANN_JSON_PASTE27, \
        NLOHMANN_JSON_PASTE26, \
        NLOHMANN_JSON_PASTE25, \
        NLOHMANN_JSON_PASTE24, \
        NLOHMANN_JSON_PASTE23, \
        NLOHMANN_JSON_PASTE22, \
        NLOHMANN_JSON_PASTE21, \
        NLOHMANN_JSON_PASTE20, \
        NLOHMANN_JSON_PASTE19, \
        NLOHMANN_JSON_PASTE18, \
        NLOHMANN_JSON_PASTE17, \
        NLOHMANN_JSON_PASTE16, \
        NLOHMANN_JSON_PASTE15, \
        NLOHMANN_JSON_PASTE14, \
        NLOHMANN_JSON_PASTE13, \
        NLOHMANN_JSON_PASTE12, \
        NLOHMANN_JSON_PASTE11, \
        NLOHMANN_JSON_PASTE10, \
        NLOHMANN_JSON_PASTE9, \
        NLOHMANN_JSON_PASTE8, \
        NLOHMANN_JSON_PASTE7, \
        NLOHMANN_JSON_PASTE6, \
        NLOHMANN_JSON_PASTE5, \
        NLOHMANN_JSON_PASTE4, \
        NLOHMANN_JSON_PASTE3, \
        NLOHMANN_JSON_PASTE2, \
        NLOHMANN_JSON_PASTE1)(__VA_ARGS__))
#define NLOHMANN_JSON_PASTE2(func, v1) func(v1)
#define NLOHMANN_JSON_PASTE3(func, v1, v2) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE2(func, v2)
#define NLOHMANN_JSON_PASTE4(func, v1, v2, v3) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE3(func, v2, v3)
#define NLOHMANN_JSON_PASTE5(func, v1, v2, v3, v4) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE4(func, v2, v3, v4)
#define NLOHMANN_JSON_PASTE6(func, v1, v2, v3, v4, v5) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE5(func, v2, v3, v4, v5)
#define NLOHMANN_JSON_PASTE7(func, v1, v2, v3, v4, v5, v6) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE6(func, v2, v3, v4, v5, v6)
#define NLOHMANN_JSON_PASTE8(func, v1, v2, v3, v4, v5, v6, v7) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE7(func, v2, v3, v4, v5, v6, v7)
#define NLOHMANN_JSON_PASTE9(func, v1, v2, v3, v4, v5, v6, v7, v8) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE8(func, v2, v3, v4, v5, v6, v7, v8)
#define NLOHMANN_JSON_PASTE10(func, v1, v2, v3, v4, v5, v6, v7, v8, v9) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE9(func, v2, v3, v4, v5, v6, v7, v8, v9)
#define NLOHMANN_JSON_PASTE11(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE10(func, v2, v3, v4, v5, v6, v7, v8, v9, v10)
#define NLOHMANN_JSON_PASTE12(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE11(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11)
#define NLOHMANN_JSON_PASTE13(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE12(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12)
#define NLOHMANN_JSON_PASTE14(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE13(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13)
#define NLOHMANN_JSON_PASTE15(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE14(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14)
#define NLOHMANN_JSON_PASTE16(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE15(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15)
#define NLOHMANN_JSON_PASTE17(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE16(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16)
#define NLOHMANN_JSON_PASTE18(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE17(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17)
#define NLOHMANN_JSON_PASTE19(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE18(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18)
#define NLOHMANN_JSON_PASTE20(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE19(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19)
#define NLOHMANN_JSON_PASTE21(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE20(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20)
#define NLOHMANN_JSON_PASTE22(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE21(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21)
#define NLOHMANN_JSON_PASTE23(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE22(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22)
#define NLOHMANN_JSON_PASTE24(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE23(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23)
#define NLOHMANN_JSON_PASTE25(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE24(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24)
#define NLOHMANN_JSON_PASTE26(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE25(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25)
#define NLOHMANN_JSON_PASTE27(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE26(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26)
#define NLOHMANN_JSON_PASTE28(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE27(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27)
#define NLOHMANN_JSON_PASTE29(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE28(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28)
#define NLOHMANN_JSON_PASTE30(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE29(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29)
#define NLOHMANN_JSON_PASTE31(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE30(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30)
#define NLOHMANN_JSON_PASTE32(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE31(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31)
#define NLOHMANN_JSON_PASTE33(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE32(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32)
#define NLOHMANN_JSON_PASTE34(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE33(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33)
#define NLOHMANN_JSON_PASTE35(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE34(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34)
#define NLOHMANN_JSON_PASTE36(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE35(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35)
#define NLOHMANN_JSON_PASTE37(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE36(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36)
#define NLOHMANN_JSON_PASTE38(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE37(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37)
#define NLOHMANN_JSON_PASTE39(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE38(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38)
#define NLOHMANN_JSON_PASTE40(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE39(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39)
#define NLOHMANN_JSON_PASTE41(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE40(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40)
#define NLOHMANN_JSON_PASTE42(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE41(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41)
#define NLOHMANN_JSON_PASTE43(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE42(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42)
#define NLOHMANN_JSON_PASTE44(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE43(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43)
#define NLOHMANN_JSON_PASTE45(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE44(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44)
#define NLOHMANN_JSON_PASTE46(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE45(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45)
#define NLOHMANN_JSON_PASTE47(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE46(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46)
#define NLOHMANN_JSON_PASTE48(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE47(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47)
#define NLOHMANN_JSON_PASTE49(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE48(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48)
#define NLOHMANN_JSON_PASTE50(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE49(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49)
#define NLOHMANN_JSON_PASTE51(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE50(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50)
#define NLOHMANN_JSON_PASTE52(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE51(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51)
#define NLOHMANN_JSON_PASTE53(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE52(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52)
#define NLOHMANN_JSON_PASTE54(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE53(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53)
#define NLOHMANN_JSON_PASTE55(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE54(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54)
#define NLOHMANN_JSON_PASTE56(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE55(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55)
#define NLOHMANN_JSON_PASTE57(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE56(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56)
#define NLOHMANN_JSON_PASTE58(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE57(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57)
#define NLOHMANN_JSON_PASTE59(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE58(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58)
#define NLOHMANN_JSON_PASTE60(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE59(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59)
#define NLOHMANN_JSON_PASTE61(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE60(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60)
#define NLOHMANN_JSON_PASTE62(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE61(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61)
#define NLOHMANN_JSON_PASTE63(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE62(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62)
#define NLOHMANN_JSON_PASTE64(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62, v63) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE63(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62, v63)

#define NLOHMANN_JSON_TO(v1) nlohmann_json_j[#v1] = nlohmann_json_t.v1;
#define NLOHMANN_JSON_FROM(v1) nlohmann_json_j.at(#v1).get_to(nlohmann_json_t.v1);

/*!
@brief macro
@def NLOHMANN_DEFINE_TYPE_INTRUSIVE
@since version 3.9.0
*/
#define NLOHMANN_DEFINE_TYPE_INTRUSIVE(Type, ...)  \
    friend void to_json(nlohmann::json& nlohmann_json_j, const Type& nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_TO, __VA_ARGS__)) } \
    friend void from_json(const nlohmann::json& nlohmann_json_j, Type& nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_FROM, __VA_ARGS__)) }

/*!
@brief macro
@def NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE
@since version 3.9.0
*/
#define NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE(Type, ...)  \
    inline void to_json(nlohmann::json& nlohmann_json_j, const Type& nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_TO, __VA_ARGS__)) } \
    inline void from_json(const nlohmann::json& nlohmann_json_j, Type& nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_FROM, __VA_ARGS__)) }

#ifndef JSON_USE_IMPLICIT_CONVERSIONS
    #define JSON_USE_IMPLICIT_CONVERSIONS 1
#endif

#if JSON_USE_IMPLICIT_CONVERSIONS
    #define JSON_EXPLICIT
#else
    #define JSON_EXPLICIT explicit
#endif


namespace nlohmann
{
namespace detail
{
////////////////
// exceptions //
////////////////

/*!
@brief general exception of the @ref basic_json class

This class is an extension of `std::exception` objects with a member @a id for
exception ids. It is used as the base class for all exceptions thrown by the
@ref basic_json class. This class can hence be used as "wildcard" to catch
exceptions.

Subclasses:
- @ref parse_error for exceptions indicating a parse error
- @ref invalid_iterator for exceptions indicating errors with iterators
- @ref type_error for exceptions indicating executing a member function with
                  a wrong type
- @ref out_of_range for exceptions indicating access out of the defined range
- @ref other_error for exceptions indicating other library errors

@internal
@note To have nothrow-copy-constructible exceptions, we internally use
      `std::runtime_error` which can cope with arbitrary-length error messages.
      Intermediate strings are built with static functions and then passed to
      the actual constructor.
@endinternal

@liveexample{The following code shows how arbitrary library exceptions can be
caught.,exception}

@since version 3.0.0
*/
class exception : public std::exception
{
  public:
    /// returns the explanatory string
    JSON_HEDLEY_RETURNS_NON_NULL
    const char* what() const noexcept override
    {
        return m.what();
    }

    /// the id of the exception
    const int id;

  protected:
    JSON_HEDLEY_NON_NULL(3)
    exception(int id_, const char* what_arg) : id(id_), m(what_arg) {}

    static std::string name(const std::string& ename, int id_)
    {
        return "[json.exception." + ename + "." + std::to_string(id_) + "] ";
    }

  private:
    /// an exception object as storage for error messages
    std::runtime_error m;
};

/*!
@brief exception indicating a parse error

This exception is thrown by the library when a parse error occurs. Parse errors
can occur during the deserialization of JSON text, CBOR, MessagePack, as well
as when using JSON Patch.

Member @a byte holds the byte index of the last read character in the input
file.

Exceptions have ids 1xx.

name / id                      | example message | description
------------------------------ | --------------- | -------------------------
json.exception.parse_error.101 | parse error at 2: unexpected end of input; expected string literal | This error indicates a syntax error while deserializing a JSON text. The error message describes that an unexpected token (character) was encountered, and the member @a byte indicates the error position.
json.exception.parse_error.102 | parse error at 14: missing or wrong low surrogate | JSON uses the `\uxxxx` format to describe Unicode characters. Code points above above 0xFFFF are split into two `\uxxxx` entries ("surrogate pairs"). This error indicates that the surrogate pair is incomplete or contains an invalid code point.
json.exception.parse_error.103 | parse error: code points above 0x10FFFF are invalid | Unicode supports code points up to 0x10FFFF. Code points above 0x10FFFF are invalid.
json.exception.parse_error.104 | parse error: JSON patch must be an array of objects | [RFC 6902](https://tools.ietf.org/html/rfc6902) requires a JSON Patch document to be a JSON document that represents an array of objects.
json.exception.parse_error.105 | parse error: operation must have string member 'op' | An operation of a JSON Patch document must contain exactly one "op" member, whose value indicates the operation to perform. Its value must be one of "add", "remove", "replace", "move", "copy", or "test"; other values are errors.
json.exception.parse_error.106 | parse error: array index '01' must not begin with '0' | An array index in a JSON Pointer ([RFC 6901](https://tools.ietf.org/html/rfc6901)) may be `0` or any number without a leading `0`.
json.exception.parse_error.107 | parse error: JSON pointer must be empty or begin with '/' - was: 'foo' | A JSON Pointer must be a Unicode string containing a sequence of zero or more reference tokens, each prefixed by a `/` character.
json.exception.parse_error.108 | parse error: escape character '~' must be followed with '0' or '1' | In a JSON Pointer, only `~0` and `~1` are valid escape sequences.
json.exception.parse_error.109 | parse error: array index 'one' is not a number | A JSON Pointer array index must be a number.
json.exception.parse_error.110 | parse error at 1: cannot read 2 bytes from vector | When parsing CBOR or MessagePack, the byte vector ends before the complete value has been read.
json.exception.parse_error.112 | parse error at 1: error reading CBOR; last byte: 0xF8 | Not all types of CBOR or MessagePack are supported. This exception occurs if an unsupported byte was read.
json.exception.parse_error.113 | parse error at 2: expected a CBOR string; last byte: 0x98 | While parsing a map key, a value that is not a string has been read.
json.exception.parse_error.114 | parse error: Unsupported BSON record type 0x0F | The parsing of the corresponding BSON record type is not implemented (yet).
json.exception.parse_error.115 | parse error at byte 5: syntax error while parsing UBJSON high-precision number: invalid number text: 1A | A UBJSON high-precision number could not be parsed.

@note For an input with n bytes, 1 is the index of the first character and n+1
      is the index of the terminating null byte or the end of file. This also
      holds true when reading a byte vector (CBOR or MessagePack).

@liveexample{The following code shows how a `parse_error` exception can be
caught.,parse_error}

@sa - @ref exception for the base class of the library exceptions
@sa - @ref invalid_iterator for exceptions indicating errors with iterators
@sa - @ref type_error for exceptions indicating executing a member function with
                    a wrong type
@sa - @ref out_of_range for exceptions indicating access out of the defined range
@sa - @ref other_error for exceptions indicating other library errors

@since version 3.0.0
*/
class parse_error : public exception
{
  public:
    /*!
    @brief create a parse error exception
    @param[in] id_       the id of the exception
    @param[in] pos       the position where the error occurred (or with
                         chars_read_total=0 if the position cannot be
                         determined)
    @param[in] what_arg  the explanatory string
    @return parse_error object
    */
    static parse_error create(int id_, const position_t& pos, const std::string& what_arg)
    {
        std::string w = exception::name("parse_error", id_) + "parse error" +
                        position_string(pos) + ": " + what_arg;
        return parse_error(id_, pos.chars_read_total, w.c_str());
    }

    static parse_error create(int id_, std::size_t byte_, const std::string& what_arg)
    {
        std::string w = exception::name("parse_error", id_) + "parse error" +
                        (byte_ != 0 ? (" at byte " + std::to_string(byte_)) : "") +
                        ": " + what_arg;
        return parse_error(id_, byte_, w.c_str());
    }

    /*!
    @brief byte index of the parse error

    The byte index of the last read character in the input file.

    @note For an input with n bytes, 1 is the index of the first character and
          n+1 is the index of the terminating null byte or the end of file.
          This also holds true when reading a byte vector (CBOR or MessagePack).
    */
    const std::size_t byte;

  private:
    parse_error(int id_, std::size_t byte_, const char* what_arg)
        : exception(id_, what_arg), byte(byte_) {}

    static std::string position_string(const position_t& pos)
    {
        return " at line " + std::to_string(pos.lines_read + 1) +
               ", column " + std::to_string(pos.chars_read_current_line);
    }
};

/*!
@brief exception indicating errors with iterators

This exception is thrown if iterators passed to a library function do not match
the expected semantics.

Exceptions have ids 2xx.

name / id                           | example message | description
----------------------------------- | --------------- | -------------------------
json.exception.invalid_iterator.201 | iterators are not compatible | The iterators passed to constructor @ref basic_json(InputIT first, InputIT last) are not compatible, meaning they do not belong to the same container. Therefore, the range (@a first, @a last) is invalid.
json.exception.invalid_iterator.202 | iterator does not fit current value | In an erase or insert function, the passed iterator @a pos does not belong to the JSON value for which the function was called. It hence does not define a valid position for the deletion/insertion.
json.exception.invalid_iterator.203 | iterators do not fit current value | Either iterator passed to function @ref erase(IteratorType first, IteratorType last) does not belong to the JSON value from which values shall be erased. It hence does not define a valid range to delete values from.
json.exception.invalid_iterator.204 | iterators out of range | When an iterator range for a primitive type (number, boolean, or string) is passed to a constructor or an erase function, this range has to be exactly (@ref begin(), @ref end()), because this is the only way the single stored value is expressed. All other ranges are invalid.
json.exception.invalid_iterator.205 | iterator out of range | When an iterator for a primitive type (number, boolean, or string) is passed to an erase function, the iterator has to be the @ref begin() iterator, because it is the only way to address the stored value. All other iterators are invalid.
json.exception.invalid_iterator.206 | cannot construct with iterators from null | The iterators passed to constructor @ref basic_json(InputIT first, InputIT last) belong to a JSON null value and hence to not define a valid range.
json.exception.invalid_iterator.207 | cannot use key() for non-object iterators | The key() member function can only be used on iterators belonging to a JSON object, because other types do not have a concept of a key.
json.exception.invalid_iterator.208 | cannot use operator[] for object iterators | The operator[] to specify a concrete offset cannot be used on iterators belonging to a JSON object, because JSON objects are unordered.
json.exception.invalid_iterator.209 | cannot use offsets with object iterators | The offset operators (+, -, +=, -=) cannot be used on iterators belonging to a JSON object, because JSON objects are unordered.
json.exception.invalid_iterator.210 | iterators do not fit | The iterator range passed to the insert function are not compatible, meaning they do not belong to the same container. Therefore, the range (@a first, @a last) is invalid.
json.exception.invalid_iterator.211 | passed iterators may not belong to container | The iterator range passed to the insert function must not be a subrange of the container to insert to.
json.exception.invalid_iterator.212 | cannot compare iterators of different containers | When two iterators are compared, they must belong to the same container.
json.exception.invalid_iterator.213 | cannot compare order of object iterators | The order of object iterators cannot be compared, because JSON objects are unordered.
json.exception.invalid_iterator.214 | cannot get value | Cannot get value for iterator: Either the iterator belongs to a null value or it is an iterator to a primitive type (number, boolean, or string), but the iterator is different to @ref begin().

@liveexample{The following code shows how an `invalid_iterator` exception can be
caught.,invalid_iterator}

@sa - @ref exception for the base class of the library exceptions
@sa - @ref parse_error for exceptions indicating a parse error
@sa - @ref type_error for exceptions indicating executing a member function with
                    a wrong type
@sa - @ref out_of_range for exceptions indicating access out of the defined range
@sa - @ref other_error for exceptions indicating other library errors

@since version 3.0.0
*/
class invalid_iterator : public exception
{
  public:
    static invalid_iterator create(int id_, const std::string& what_arg)
    {
        std::string w = exception::name("invalid_iterator", id_) + what_arg;
        return invalid_iterator(id_, w.c_str());
    }

  private:
    JSON_HEDLEY_NON_NULL(3)
    invalid_iterator(int id_, const char* what_arg)
        : exception(id_, what_arg) {}
};

/*!
@brief exception indicating executing a member function with a wrong type

This exception is thrown in case of a type error; that is, a library function is
executed on a JSON value whose type does not match the expected semantics.

Exceptions have ids 3xx.

name / id                     | example message | description
----------------------------- | --------------- | -------------------------
json.exception.type_error.301 | cannot create object from initializer list | To create an object from an initializer list, the initializer list must consist only of a list of pairs whose first element is a string. When this constraint is violated, an array is created instead.
json.exception.type_error.302 | type must be object, but is array | During implicit or explicit value conversion, the JSON type must be compatible to the target type. For instance, a JSON string can only be converted into string types, but not into numbers or boolean types.
json.exception.type_error.303 | incompatible ReferenceType for get_ref, actual type is object | To retrieve a reference to a value stored in a @ref basic_json object with @ref get_ref, the type of the reference must match the value type. For instance, for a JSON array, the @a ReferenceType must be @ref array_t &.
json.exception.type_error.304 | cannot use at() with string | The @ref at() member functions can only be executed for certain JSON types.
json.exception.type_error.305 | cannot use operator[] with string | The @ref operator[] member functions can only be executed for certain JSON types.
json.exception.type_error.306 | cannot use value() with string | The @ref value() member functions can only be executed for certain JSON types.
json.exception.type_error.307 | cannot use erase() with string | The @ref erase() member functions can only be executed for certain JSON types.
json.exception.type_error.308 | cannot use push_back() with string | The @ref push_back() and @ref operator+= member functions can only be executed for certain JSON types.
json.exception.type_error.309 | cannot use insert() with | The @ref insert() member functions can only be executed for certain JSON types.
json.exception.type_error.310 | cannot use swap() with number | The @ref swap() member functions can only be executed for certain JSON types.
json.exception.type_error.311 | cannot use emplace_back() with string | The @ref emplace_back() member function can only be executed for certain JSON types.
json.exception.type_error.312 | cannot use update() with string | The @ref update() member functions can only be executed for certain JSON types.
json.exception.type_error.313 | invalid value to unflatten | The @ref unflatten function converts an object whose keys are JSON Pointers back into an arbitrary nested JSON value. The JSON Pointers must not overlap, because then the resulting value would not be well defined.
json.exception.type_error.314 | only objects can be unflattened | The @ref unflatten function only works for an object whose keys are JSON Pointers.
json.exception.type_error.315 | values in object must be primitive | The @ref unflatten function only works for an object whose keys are JSON Pointers and whose values are primitive.
json.exception.type_error.316 | invalid UTF-8 byte at index 10: 0x7E | The @ref dump function only works with UTF-8 encoded strings; that is, if you assign a `std::string` to a JSON value, make sure it is UTF-8 encoded. |
json.exception.type_error.317 | JSON value cannot be serialized to requested format | The dynamic type of the object cannot be represented in the requested serialization format (e.g. a raw `true` or `null` JSON object cannot be serialized to BSON) |

@liveexample{The following code shows how a `type_error` exception can be
caught.,type_error}

@sa - @ref exception for the base class of the library exceptions
@sa - @ref parse_error for exceptions indicating a parse error
@sa - @ref invalid_iterator for exceptions indicating errors with iterators
@sa - @ref out_of_range for exceptions indicating access out of the defined range
@sa - @ref other_error for exceptions indicating other library errors

@since version 3.0.0
*/
class type_error : public exception
{
  public:
    static type_error create(int id_, const std::string& what_arg)
    {
        std::string w = exception::name("type_error", id_) + what_arg;
        return type_error(id_, w.c_str());
    }

  private:
    JSON_HEDLEY_NON_NULL(3)
    type_error(int id_, const char* what_arg) : exception(id_, what_arg) {}
};

/*!
@brief exception indicating access out of the defined range

This exception is thrown in case a library function is called on an input
parameter that exceeds the expected range, for instance in case of array
indices or nonexisting object keys.

Exceptions have ids 4xx.

name / id                       | example message | description
------------------------------- | --------------- | -------------------------
json.exception.out_of_range.401 | array index 3 is out of range | The provided array index @a i is larger than @a size-1.
json.exception.out_of_range.402 | array index '-' (3) is out of range | The special array index `-` in a JSON Pointer never describes a valid element of the array, but the index past the end. That is, it can only be used to add elements at this position, but not to read it.
json.exception.out_of_range.403 | key 'foo' not found | The provided key was not found in the JSON object.
json.exception.out_of_range.404 | unresolved reference token 'foo' | A reference token in a JSON Pointer could not be resolved.
json.exception.out_of_range.405 | JSON pointer has no parent | The JSON Patch operations 'remove' and 'add' can not be applied to the root element of the JSON value.
json.exception.out_of_range.406 | number overflow parsing '10E1000' | A parsed number could not be stored as without changing it to NaN or INF.
json.exception.out_of_range.407 | number overflow serializing '9223372036854775808' | UBJSON and BSON only support integer numbers up to 9223372036854775807. (until version 3.8.0) |
json.exception.out_of_range.408 | excessive array size: 8658170730974374167 | The size (following `#`) of an UBJSON array or object exceeds the maximal capacity. |
json.exception.out_of_range.409 | BSON key cannot contain code point U+0000 (at byte 2) | Key identifiers to be serialized to BSON cannot contain code point U+0000, since the key is stored as zero-terminated c-string |

@liveexample{The following code shows how an `out_of_range` exception can be
caught.,out_of_range}

@sa - @ref exception for the base class of the library exceptions
@sa - @ref parse_error for exceptions indicating a parse error
@sa - @ref invalid_iterator for exceptions indicating errors with iterators
@sa - @ref type_error for exceptions indicating executing a member function with
                    a wrong type
@sa - @ref other_error for exceptions indicating other library errors

@since version 3.0.0
*/
class out_of_range : public exception
{
  public:
    static out_of_range create(int id_, const std::string& what_arg)
    {
        std::string w = exception::name("out_of_range", id_) + what_arg;
        return out_of_range(id_, w.c_str());
    }

  private:
    JSON_HEDLEY_NON_NULL(3)
    out_of_range(int id_, const char* what_arg) : exception(id_, what_arg) {}
};

/*!
@brief exception indicating other library errors

This exception is thrown in case of errors that cannot be classified with the
other exception types.

Exceptions have ids 5xx.

name / id                      | example message | description
------------------------------ | --------------- | -------------------------
json.exception.other_error.501 | unsuccessful: {"op":"test","path":"/baz", "value":"bar"} | A JSON Patch operation 'test' failed. The unsuccessful operation is also printed.

@sa - @ref exception for the base class of the library exceptions
@sa - @ref parse_error for exceptions indicating a parse error
@sa - @ref invalid_iterator for exceptions indicating errors with iterators
@sa - @ref type_error for exceptions indicating executing a member function with
                    a wrong type
@sa - @ref out_of_range for exceptions indicating access out of the defined range

@liveexample{The following code shows how an `other_error` exception can be
caught.,other_error}

@since version 3.0.0
*/
class other_error : public exception
{
  public:
    static other_error create(int id_, const std::string& what_arg)
    {
        std::string w = exception::name("other_error", id_) + what_arg;
        return other_error(id_, w.c_str());
    }

  private:
    JSON_HEDLEY_NON_NULL(3)
    other_error(int id_, const char* what_arg) : exception(id_, what_arg) {}
};
}  // namespace detail
}  // namespace nlohmann

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/meta/cpp_future.hpp>


#include <cstddef> // size_t
#include <type_traits> // conditional, enable_if, false_type, integral_constant, is_constructible, is_integral, is_same, remove_cv, remove_reference, true_type

namespace nlohmann
{
namespace detail
{
// alias templates to reduce boilerplate
template<bool B, typename T = void>
using enable_if_t = typename std::enable_if<B, T>::type;

template<typename T>
using uncvref_t = typename std::remove_cv<typename std::remove_reference<T>::type>::type;

// implementation of C++14 index_sequence and affiliates
// source: https://stackoverflow.com/a/32223343
template<std::size_t... Ints>
struct index_sequence
{
    using type = index_sequence;
    using value_type = std::size_t;
    static constexpr std::size_t size() noexcept
    {
        return sizeof...(Ints);
    }
};

template<class Sequence1, class Sequence2>
struct merge_and_renumber;

template<std::size_t... I1, std::size_t... I2>
struct merge_and_renumber<index_sequence<I1...>, index_sequence<I2...>>
        : index_sequence < I1..., (sizeof...(I1) + I2)... > {};

template<std::size_t N>
struct make_index_sequence
    : merge_and_renumber < typename make_index_sequence < N / 2 >::type,
      typename make_index_sequence < N - N / 2 >::type > {};

template<> struct make_index_sequence<0> : index_sequence<> {};
template<> struct make_index_sequence<1> : index_sequence<0> {};

template<typename... Ts>
using index_sequence_for = make_index_sequence<sizeof...(Ts)>;

// dispatch utility (taken from ranges-v3)
template<unsigned N> struct priority_tag : priority_tag < N - 1 > {};
template<> struct priority_tag<0> {};

// taken from ranges-v3
template<typename T>
struct static_const
{
    static constexpr T value{};
};

template<typename T>
constexpr T static_const<T>::value;
}  // namespace detail
}  // namespace nlohmann

// #include <nlohmann/detail/meta/type_traits.hpp>


#include <limits> // numeric_limits
#include <type_traits> // false_type, is_constructible, is_integral, is_same, true_type
#include <utility> // declval

// #include <nlohmann/detail/iterators/iterator_traits.hpp>


#include <iterator> // random_access_iterator_tag

// #include <nlohmann/detail/meta/void_t.hpp>


namespace nlohmann
{
namespace detail
{
template<typename ...Ts> struct make_void
{
    using type = void;
};
template<typename ...Ts> using void_t = typename make_void<Ts...>::type;
} // namespace detail
}  // namespace nlohmann

// #include <nlohmann/detail/meta/cpp_future.hpp>


namespace nlohmann
{
namespace detail
{
template<typename It, typename = void>
struct iterator_types {};

template<typename It>
struct iterator_types <
    It,
    void_t<typename It::difference_type, typename It::value_type, typename It::pointer,
    typename It::reference, typename It::iterator_category >>
{
    using difference_type = typename It::difference_type;
    using value_type = typename It::value_type;
    using pointer = typename It::pointer;
    using reference = typename It::reference;
    using iterator_category = typename It::iterator_category;
};

// This is required as some compilers implement std::iterator_traits in a way that
// doesn't work with SFINAE. See https://github.com/nlohmann/json/issues/1341.
template<typename T, typename = void>
struct iterator_traits
{
};

template<typename T>
struct iterator_traits < T, enable_if_t < !std::is_pointer<T>::value >>
            : iterator_types<T>
{
};

template<typename T>
struct iterator_traits<T*, enable_if_t<std::is_object<T>::value>>
{
    using iterator_category = std::random_access_iterator_tag;
    using value_type = T;
    using difference_type = ptrdiff_t;
    using pointer = T*;
    using reference = T&;
};
} // namespace detail
} // namespace nlohmann

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/meta/cpp_future.hpp>

// #include <nlohmann/detail/meta/detected.hpp>


#include <type_traits>

// #include <nlohmann/detail/meta/void_t.hpp>


// https://en.cppreference.com/w/cpp/experimental/is_detected
namespace nlohmann
{
namespace detail
{
struct nonesuch
{
    nonesuch() = delete;
    ~nonesuch() = delete;
    nonesuch(nonesuch const&) = delete;
    nonesuch(nonesuch const&&) = delete;
    void operator=(nonesuch const&) = delete;
    void operator=(nonesuch&&) = delete;
};

template<class Default,
         class AlwaysVoid,
         template<class...> class Op,
         class... Args>
struct detector
{
    using value_t = std::false_type;
    using type = Default;
};

template<class Default, template<class...> class Op, class... Args>
struct detector<Default, void_t<Op<Args...>>, Op, Args...>
{
    using value_t = std::true_type;
    using type = Op<Args...>;
};

template<template<class...> class Op, class... Args>
using is_detected = typename detector<nonesuch, void, Op, Args...>::value_t;

template<template<class...> class Op, class... Args>
using detected_t = typename detector<nonesuch, void, Op, Args...>::type;

template<class Default, template<class...> class Op, class... Args>
using detected_or = detector<Default, void, Op, Args...>;

template<class Default, template<class...> class Op, class... Args>
using detected_or_t = typename detected_or<Default, Op, Args...>::type;

template<class Expected, template<class...> class Op, class... Args>
using is_detected_exact = std::is_same<Expected, detected_t<Op, Args...>>;

template<class To, template<class...> class Op, class... Args>
using is_detected_convertible =
    std::is_convertible<detected_t<Op, Args...>, To>;
}  // namespace detail
}  // namespace nlohmann

// #include <nlohmann/json_fwd.hpp>
#ifndef INCLUDE_NLOHMANN_JSON_FWD_HPP_
#define INCLUDE_NLOHMANN_JSON_FWD_HPP_

#include <cstdint> // int64_t, uint64_t
#include <map> // map
#include <memory> // allocator
#include <string> // string
#include <vector> // vector

/*!
@brief namespace for Niels Lohmann
@see https://github.com/nlohmann
@since version 1.0.0
*/
namespace nlohmann
{
/*!
@brief default JSONSerializer template argument

This serializer ignores the template arguments and uses ADL
([argument-dependent lookup](https://en.cppreference.com/w/cpp/language/adl))
for serialization.
*/
template<typename T = void, typename SFINAE = void>
struct adl_serializer;

template<template<typename U, typename V, typename... Args> class ObjectType =
         std::map,
         template<typename U, typename... Args> class ArrayType = std::vector,
         class StringType = std::string, class BooleanType = bool,
         class NumberIntegerType = std::int64_t,
         class NumberUnsignedType = std::uint64_t,
         class NumberFloatType = double,
         template<typename U> class AllocatorType = std::allocator,
         template<typename T, typename SFINAE = void> class JSONSerializer =
         adl_serializer,
         class BinaryType = std::vector<std::uint8_t>>
class basic_json;

/*!
@brief JSON Pointer

A JSON pointer defines a string syntax for identifying a specific value
within a JSON document. It can be used with functions `at` and
`operator[]`. Furthermore, JSON pointers are the base for JSON patches.

@sa [RFC 6901](https://tools.ietf.org/html/rfc6901)

@since version 2.0.0
*/
template<typename BasicJsonType>
class json_pointer;

/*!
@brief default JSON class

This type is the default specialization of the @ref basic_json class which
uses the standard template types.

@since version 1.0.0
*/
using json = basic_json<>;

template<class Key, class T, class IgnoredLess, class Allocator>
struct ordered_map;

/*!
@brief ordered JSON class

This type preserves the insertion order of object keys.

@since version 3.9.0
*/
using ordered_json = basic_json<nlohmann::ordered_map>;

}  // namespace nlohmann

#endif  // INCLUDE_NLOHMANN_JSON_FWD_HPP_


namespace nlohmann
{
/*!
@brief detail namespace with internal helper functions

This namespace collects functions that should not be exposed,
implementations of some @ref basic_json methods, and meta-programming helpers.

@since version 2.1.0
*/
namespace detail
{
/////////////
// helpers //
/////////////

// Note to maintainers:
//
// Every trait in this file expects a non CV-qualified type.
// The only exceptions are in the 'aliases for detected' section
// (i.e. those of the form: decltype(T::member_function(std::declval<T>())))
//
// In this case, T has to be properly CV-qualified to constraint the function arguments
// (e.g. to_json(BasicJsonType&, const T&))

template<typename> struct is_basic_json : std::false_type {};

NLOHMANN_BASIC_JSON_TPL_DECLARATION
struct is_basic_json<NLOHMANN_BASIC_JSON_TPL> : std::true_type {};

//////////////////////
// json_ref helpers //
//////////////////////

template<typename>
class json_ref;

template<typename>
struct is_json_ref : std::false_type {};

template<typename T>
struct is_json_ref<json_ref<T>> : std::true_type {};

//////////////////////////
// aliases for detected //
//////////////////////////

template<typename T>
using mapped_type_t = typename T::mapped_type;

template<typename T>
using key_type_t = typename T::key_type;

template<typename T>
using value_type_t = typename T::value_type;

template<typename T>
using difference_type_t = typename T::difference_type;

template<typename T>
using pointer_t = typename T::pointer;

template<typename T>
using reference_t = typename T::reference;

template<typename T>
using iterator_category_t = typename T::iterator_category;

template<typename T>
using iterator_t = typename T::iterator;

template<typename T, typename... Args>
using to_json_function = decltype(T::to_json(std::declval<Args>()...));

template<typename T, typename... Args>
using from_json_function = decltype(T::from_json(std::declval<Args>()...));

template<typename T, typename U>
using get_template_function = decltype(std::declval<T>().template get<U>());

// trait checking if JSONSerializer<T>::from_json(json const&, udt&) exists
template<typename BasicJsonType, typename T, typename = void>
struct has_from_json : std::false_type {};

// trait checking if j.get<T> is valid
// use this trait instead of std::is_constructible or std::is_convertible,
// both rely on, or make use of implicit conversions, and thus fail when T
// has several constructors/operator= (see https://github.com/nlohmann/json/issues/958)
template <typename BasicJsonType, typename T>
struct is_getable
{
    static constexpr bool value = is_detected<get_template_function, const BasicJsonType&, T>::value;
};

template<typename BasicJsonType, typename T>
struct has_from_json < BasicJsonType, T,
           enable_if_t < !is_basic_json<T>::value >>
{
    using serializer = typename BasicJsonType::template json_serializer<T, void>;

    static constexpr bool value =
        is_detected_exact<void, from_json_function, serializer,
        const BasicJsonType&, T&>::value;
};

// This trait checks if JSONSerializer<T>::from_json(json const&) exists
// this overload is used for non-default-constructible user-defined-types
template<typename BasicJsonType, typename T, typename = void>
struct has_non_default_from_json : std::false_type {};

template<typename BasicJsonType, typename T>
struct has_non_default_from_json < BasicJsonType, T, enable_if_t < !is_basic_json<T>::value >>
{
    using serializer = typename BasicJsonType::template json_serializer<T, void>;

    static constexpr bool value =
        is_detected_exact<T, from_json_function, serializer,
        const BasicJsonType&>::value;
};

// This trait checks if BasicJsonType::json_serializer<T>::to_json exists
// Do not evaluate the trait when T is a basic_json type, to avoid template instantiation infinite recursion.
template<typename BasicJsonType, typename T, typename = void>
struct has_to_json : std::false_type {};

template<typename BasicJsonType, typename T>
struct has_to_json < BasicJsonType, T, enable_if_t < !is_basic_json<T>::value >>
{
    using serializer = typename BasicJsonType::template json_serializer<T, void>;

    static constexpr bool value =
        is_detected_exact<void, to_json_function, serializer, BasicJsonType&,
        T>::value;
};


///////////////////
// is_ functions //
///////////////////

template<typename T, typename = void>
struct is_iterator_traits : std::false_type {};

template<typename T>
struct is_iterator_traits<iterator_traits<T>>
{
  private:
    using traits = iterator_traits<T>;

  public:
    static constexpr auto value =
        is_detected<value_type_t, traits>::value &&
        is_detected<difference_type_t, traits>::value &&
        is_detected<pointer_t, traits>::value &&
        is_detected<iterator_category_t, traits>::value &&
        is_detected<reference_t, traits>::value;
};

// source: https://stackoverflow.com/a/37193089/4116453

template<typename T, typename = void>
struct is_complete_type : std::false_type {};

template<typename T>
struct is_complete_type<T, decltype(void(sizeof(T)))> : std::true_type {};

template<typename BasicJsonType, typename CompatibleObjectType,
         typename = void>
struct is_compatible_object_type_impl : std::false_type {};

template<typename BasicJsonType, typename CompatibleObjectType>
struct is_compatible_object_type_impl <
    BasicJsonType, CompatibleObjectType,
    enable_if_t < is_detected<mapped_type_t, CompatibleObjectType>::value&&
    is_detected<key_type_t, CompatibleObjectType>::value >>
{

    using object_t = typename BasicJsonType::object_t;

    // macOS's is_constructible does not play well with nonesuch...
    static constexpr bool value =
        std::is_constructible<typename object_t::key_type,
        typename CompatibleObjectType::key_type>::value &&
        std::is_constructible<typename object_t::mapped_type,
        typename CompatibleObjectType::mapped_type>::value;
};

template<typename BasicJsonType, typename CompatibleObjectType>
struct is_compatible_object_type
    : is_compatible_object_type_impl<BasicJsonType, CompatibleObjectType> {};

template<typename BasicJsonType, typename ConstructibleObjectType,
         typename = void>
struct is_constructible_object_type_impl : std::false_type {};

template<typename BasicJsonType, typename ConstructibleObjectType>
struct is_constructible_object_type_impl <
    BasicJsonType, ConstructibleObjectType,
    enable_if_t < is_detected<mapped_type_t, ConstructibleObjectType>::value&&
    is_detected<key_type_t, ConstructibleObjectType>::value >>
{
    using object_t = typename BasicJsonType::object_t;

    static constexpr bool value =
        (std::is_default_constructible<ConstructibleObjectType>::value &&
         (std::is_move_assignable<ConstructibleObjectType>::value ||
          std::is_copy_assignable<ConstructibleObjectType>::value) &&
         (std::is_constructible<typename ConstructibleObjectType::key_type,
          typename object_t::key_type>::value &&
          std::is_same <
          typename object_t::mapped_type,
          typename ConstructibleObjectType::mapped_type >::value)) ||
        (has_from_json<BasicJsonType,
         typename ConstructibleObjectType::mapped_type>::value ||
         has_non_default_from_json <
         BasicJsonType,
         typename ConstructibleObjectType::mapped_type >::value);
};

template<typename BasicJsonType, typename ConstructibleObjectType>
struct is_constructible_object_type
    : is_constructible_object_type_impl<BasicJsonType,
      ConstructibleObjectType> {};

template<typename BasicJsonType, typename CompatibleStringType,
         typename = void>
struct is_compatible_string_type_impl : std::false_type {};

template<typename BasicJsonType, typename CompatibleStringType>
struct is_compatible_string_type_impl <
    BasicJsonType, CompatibleStringType,
    enable_if_t<is_detected_exact<typename BasicJsonType::string_t::value_type,
    value_type_t, CompatibleStringType>::value >>
{
    static constexpr auto value =
        std::is_constructible<typename BasicJsonType::string_t, CompatibleStringType>::value;
};

template<typename BasicJsonType, typename ConstructibleStringType>
struct is_compatible_string_type
    : is_compatible_string_type_impl<BasicJsonType, ConstructibleStringType> {};

template<typename BasicJsonType, typename ConstructibleStringType,
         typename = void>
struct is_constructible_string_type_impl : std::false_type {};

template<typename BasicJsonType, typename ConstructibleStringType>
struct is_constructible_string_type_impl <
    BasicJsonType, ConstructibleStringType,
    enable_if_t<is_detected_exact<typename BasicJsonType::string_t::value_type,
    value_type_t, ConstructibleStringType>::value >>
{
    static constexpr auto value =
        std::is_constructible<ConstructibleStringType,
        typename BasicJsonType::string_t>::value;
};

template<typename BasicJsonType, typename ConstructibleStringType>
struct is_constructible_string_type
    : is_constructible_string_type_impl<BasicJsonType, ConstructibleStringType> {};

template<typename BasicJsonType, typename CompatibleArrayType, typename = void>
struct is_compatible_array_type_impl : std::false_type {};

template<typename BasicJsonType, typename CompatibleArrayType>
struct is_compatible_array_type_impl <
    BasicJsonType, CompatibleArrayType,
    enable_if_t < is_detected<value_type_t, CompatibleArrayType>::value&&
    is_detected<iterator_t, CompatibleArrayType>::value&&
// This is needed because json_reverse_iterator has a ::iterator type...
// Therefore it is detected as a CompatibleArrayType.
// The real fix would be to have an Iterable concept.
    !is_iterator_traits <
    iterator_traits<CompatibleArrayType >>::value >>
{
    static constexpr bool value =
        std::is_constructible<BasicJsonType,
        typename CompatibleArrayType::value_type>::value;
};

template<typename BasicJsonType, typename CompatibleArrayType>
struct is_compatible_array_type
    : is_compatible_array_type_impl<BasicJsonType, CompatibleArrayType> {};

template<typename BasicJsonType, typename ConstructibleArrayType, typename = void>
struct is_constructible_array_type_impl : std::false_type {};

template<typename BasicJsonType, typename ConstructibleArrayType>
struct is_constructible_array_type_impl <
    BasicJsonType, ConstructibleArrayType,
    enable_if_t<std::is_same<ConstructibleArrayType,
    typename BasicJsonType::value_type>::value >>
            : std::true_type {};

template<typename BasicJsonType, typename ConstructibleArrayType>
struct is_constructible_array_type_impl <
    BasicJsonType, ConstructibleArrayType,
    enable_if_t < !std::is_same<ConstructibleArrayType,
    typename BasicJsonType::value_type>::value&&
    std::is_default_constructible<ConstructibleArrayType>::value&&
(std::is_move_assignable<ConstructibleArrayType>::value ||
 std::is_copy_assignable<ConstructibleArrayType>::value)&&
is_detected<value_type_t, ConstructibleArrayType>::value&&
is_detected<iterator_t, ConstructibleArrayType>::value&&
is_complete_type <
detected_t<value_type_t, ConstructibleArrayType >>::value >>
{
    static constexpr bool value =
        // This is needed because json_reverse_iterator has a ::iterator type,
        // furthermore, std::back_insert_iterator (and other iterators) have a
        // base class `iterator`... Therefore it is detected as a
        // ConstructibleArrayType. The real fix would be to have an Iterable
        // concept.
        !is_iterator_traits<iterator_traits<ConstructibleArrayType>>::value &&

        (std::is_same<typename ConstructibleArrayType::value_type,
         typename BasicJsonType::array_t::value_type>::value ||
         has_from_json<BasicJsonType,
         typename ConstructibleArrayType::value_type>::value ||
         has_non_default_from_json <
         BasicJsonType, typename ConstructibleArrayType::value_type >::value);
};

template<typename BasicJsonType, typename ConstructibleArrayType>
struct is_constructible_array_type
    : is_constructible_array_type_impl<BasicJsonType, ConstructibleArrayType> {};

template<typename RealIntegerType, typename CompatibleNumberIntegerType,
         typename = void>
struct is_compatible_integer_type_impl : std::false_type {};

template<typename RealIntegerType, typename CompatibleNumberIntegerType>
struct is_compatible_integer_type_impl <
    RealIntegerType, CompatibleNumberIntegerType,
    enable_if_t < std::is_integral<RealIntegerType>::value&&
    std::is_integral<CompatibleNumberIntegerType>::value&&
    !std::is_same<bool, CompatibleNumberIntegerType>::value >>
{
    // is there an assert somewhere on overflows?
    using RealLimits = std::numeric_limits<RealIntegerType>;
    using CompatibleLimits = std::numeric_limits<CompatibleNumberIntegerType>;

    static constexpr auto value =
        std::is_constructible<RealIntegerType,
        CompatibleNumberIntegerType>::value &&
        CompatibleLimits::is_integer &&
        RealLimits::is_signed == CompatibleLimits::is_signed;
};

template<typename RealIntegerType, typename CompatibleNumberIntegerType>
struct is_compatible_integer_type
    : is_compatible_integer_type_impl<RealIntegerType,
      CompatibleNumberIntegerType> {};

template<typename BasicJsonType, typename CompatibleType, typename = void>
struct is_compatible_type_impl: std::false_type {};

template<typename BasicJsonType, typename CompatibleType>
struct is_compatible_type_impl <
    BasicJsonType, CompatibleType,
    enable_if_t<is_complete_type<CompatibleType>::value >>
{
    static constexpr bool value =
        has_to_json<BasicJsonType, CompatibleType>::value;
};

template<typename BasicJsonType, typename CompatibleType>
struct is_compatible_type
    : is_compatible_type_impl<BasicJsonType, CompatibleType> {};

// https://en.cppreference.com/w/cpp/types/conjunction
template<class...> struct conjunction : std::true_type { };
template<class B1> struct conjunction<B1> : B1 { };
template<class B1, class... Bn>
struct conjunction<B1, Bn...>
: std::conditional<bool(B1::value), conjunction<Bn...>, B1>::type {};

template<typename T1, typename T2>
struct is_constructible_tuple : std::false_type {};

template<typename T1, typename... Args>
struct is_constructible_tuple<T1, std::tuple<Args...>> : conjunction<std::is_constructible<T1, Args>...> {};
}  // namespace detail
}  // namespace nlohmann

// #include <nlohmann/detail/value_t.hpp>


#include <array> // array
#include <cstddef> // size_t
#include <cstdint> // uint8_t
#include <string> // string

namespace nlohmann
{
namespace detail
{
///////////////////////////
// JSON type enumeration //
///////////////////////////

/*!
@brief the JSON type enumeration

This enumeration collects the different JSON types. It is internally used to
distinguish the stored values, and the functions @ref basic_json::is_null(),
@ref basic_json::is_object(), @ref basic_json::is_array(),
@ref basic_json::is_string(), @ref basic_json::is_boolean(),
@ref basic_json::is_number() (with @ref basic_json::is_number_integer(),
@ref basic_json::is_number_unsigned(), and @ref basic_json::is_number_float()),
@ref basic_json::is_discarded(), @ref basic_json::is_primitive(), and
@ref basic_json::is_structured() rely on it.

@note There are three enumeration entries (number_integer, number_unsigned, and
number_float), because the library distinguishes these three types for numbers:
@ref basic_json::number_unsigned_t is used for unsigned integers,
@ref basic_json::number_integer_t is used for signed integers, and
@ref basic_json::number_float_t is used for floating-point numbers or to
approximate integers which do not fit in the limits of their respective type.

@sa @ref basic_json::basic_json(const value_t value_type) -- create a JSON
value with the default value for a given type

@since version 1.0.0
*/
enum class value_t : std::uint8_t
{
    null,             ///< null value
    object,           ///< object (unordered set of name/value pairs)
    array,            ///< array (ordered collection of values)
    string,           ///< string value
    boolean,          ///< boolean value
    number_integer,   ///< number value (signed integer)
    number_unsigned,  ///< number value (unsigned integer)
    number_float,     ///< number value (floating-point)
    binary,           ///< binary array (ordered collection of bytes)
    discarded         ///< discarded by the parser callback function
};

/*!
@brief comparison operator for JSON types

Returns an ordering that is similar to Python:
- order: null < boolean < number < object < array < string < binary
- furthermore, each type is not smaller than itself
- discarded values are not comparable
- binary is represented as a b"" string in python and directly comparable to a
  string; however, making a binary array directly comparable with a string would
  be surprising behavior in a JSON file.

@since version 1.0.0
*/
inline bool operator<(const value_t lhs, const value_t rhs) noexcept
{
    static constexpr std::array<std::uint8_t, 9> order = {{
            0 /* null */, 3 /* object */, 4 /* array */, 5 /* string */,
            1 /* boolean */, 2 /* integer */, 2 /* unsigned */, 2 /* float */,
            6 /* binary */
        }
    };

    const auto l_index = static_cast<std::size_t>(lhs);
    const auto r_index = static_cast<std::size_t>(rhs);
    return l_index < order.size() && r_index < order.size() && order[l_index] < order[r_index];
}
}  // namespace detail
}  // namespace nlohmann


namespace nlohmann
{
namespace detail
{
template<typename BasicJsonType>
void from_json(const BasicJsonType& j, typename std::nullptr_t& n)
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_null()))
    {
        JSON_THROW(type_error::create(302, "type must be null, but is " + std::string(j.type_name())));
    }
    n = nullptr;
}

// overloads for basic_json template parameters
template < typename BasicJsonType, typename ArithmeticType,
           enable_if_t < std::is_arithmetic<ArithmeticType>::value&&
                         !std::is_same<ArithmeticType, typename BasicJsonType::boolean_t>::value,
                         int > = 0 >
void get_arithmetic_value(const BasicJsonType& j, ArithmeticType& val)
{
    switch (static_cast<value_t>(j))
    {
        case value_t::number_unsigned:
        {
            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_unsigned_t*>());
            break;
        }
        case value_t::number_integer:
        {
            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_integer_t*>());
            break;
        }
        case value_t::number_float:
        {
            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_float_t*>());
            break;
        }

        default:
            JSON_THROW(type_error::create(302, "type must be number, but is " + std::string(j.type_name())));
    }
}

template<typename BasicJsonType>
void from_json(const BasicJsonType& j, typename BasicJsonType::boolean_t& b)
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_boolean()))
    {
        JSON_THROW(type_error::create(302, "type must be boolean, but is " + std::string(j.type_name())));
    }
    b = *j.template get_ptr<const typename BasicJsonType::boolean_t*>();
}

template<typename BasicJsonType>
void from_json(const BasicJsonType& j, typename BasicJsonType::string_t& s)
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_string()))
    {
        JSON_THROW(type_error::create(302, "type must be string, but is " + std::string(j.type_name())));
    }
    s = *j.template get_ptr<const typename BasicJsonType::string_t*>();
}

template <
    typename BasicJsonType, typename ConstructibleStringType,
    enable_if_t <
        is_constructible_string_type<BasicJsonType, ConstructibleStringType>::value&&
        !std::is_same<typename BasicJsonType::string_t,
                      ConstructibleStringType>::value,
        int > = 0 >
void from_json(const BasicJsonType& j, ConstructibleStringType& s)
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_string()))
    {
        JSON_THROW(type_error::create(302, "type must be string, but is " + std::string(j.type_name())));
    }

    s = *j.template get_ptr<const typename BasicJsonType::string_t*>();
}

template<typename BasicJsonType>
void from_json(const BasicJsonType& j, typename BasicJsonType::number_float_t& val)
{
    get_arithmetic_value(j, val);
}

template<typename BasicJsonType>
void from_json(const BasicJsonType& j, typename BasicJsonType::number_unsigned_t& val)
{
    get_arithmetic_value(j, val);
}

template<typename BasicJsonType>
void from_json(const BasicJsonType& j, typename BasicJsonType::number_integer_t& val)
{
    get_arithmetic_value(j, val);
}

template<typename BasicJsonType, typename EnumType,
         enable_if_t<std::is_enum<EnumType>::value, int> = 0>
void from_json(const BasicJsonType& j, EnumType& e)
{
    typename std::underlying_type<EnumType>::type val;
    get_arithmetic_value(j, val);
    e = static_cast<EnumType>(val);
}

// forward_list doesn't have an insert method
template<typename BasicJsonType, typename T, typename Allocator,
         enable_if_t<is_getable<BasicJsonType, T>::value, int> = 0>
void from_json(const BasicJsonType& j, std::forward_list<T, Allocator>& l)
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
    {
        JSON_THROW(type_error::create(302, "type must be array, but is " + std::string(j.type_name())));
    }
    l.clear();
    std::transform(j.rbegin(), j.rend(),
                   std::front_inserter(l), [](const BasicJsonType & i)
    {
        return i.template get<T>();
    });
}

// valarray doesn't have an insert method
template<typename BasicJsonType, typename T,
         enable_if_t<is_getable<BasicJsonType, T>::value, int> = 0>
void from_json(const BasicJsonType& j, std::valarray<T>& l)
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
    {
        JSON_THROW(type_error::create(302, "type must be array, but is " + std::string(j.type_name())));
    }
    l.resize(j.size());
    std::transform(j.begin(), j.end(), std::begin(l),
                   [](const BasicJsonType & elem)
    {
        return elem.template get<T>();
    });
}

template<typename BasicJsonType, typename T, std::size_t N>
auto from_json(const BasicJsonType& j, T (&arr)[N])
-> decltype(j.template get<T>(), void())
{
    for (std::size_t i = 0; i < N; ++i)
    {
        arr[i] = j.at(i).template get<T>();
    }
}

template<typename BasicJsonType>
void from_json_array_impl(const BasicJsonType& j, typename BasicJsonType::array_t& arr, priority_tag<3> /*unused*/)
{
    arr = *j.template get_ptr<const typename BasicJsonType::array_t*>();
}

template<typename BasicJsonType, typename T, std::size_t N>
auto from_json_array_impl(const BasicJsonType& j, std::array<T, N>& arr,
                          priority_tag<2> /*unused*/)
-> decltype(j.template get<T>(), void())
{
    for (std::size_t i = 0; i < N; ++i)
    {
        arr[i] = j.at(i).template get<T>();
    }
}

template<typename BasicJsonType, typename ConstructibleArrayType>
auto from_json_array_impl(const BasicJsonType& j, ConstructibleArrayType& arr, priority_tag<1> /*unused*/)
-> decltype(
    arr.reserve(std::declval<typename ConstructibleArrayType::size_type>()),
    j.template get<typename ConstructibleArrayType::value_type>(),
    void())
{
    using std::end;

    ConstructibleArrayType ret;
    ret.reserve(j.size());
    std::transform(j.begin(), j.end(),
                   std::inserter(ret, end(ret)), [](const BasicJsonType & i)
    {
        // get<BasicJsonType>() returns *this, this won't call a from_json
        // method when value_type is BasicJsonType
        return i.template get<typename ConstructibleArrayType::value_type>();
    });
    arr = std::move(ret);
}

template<typename BasicJsonType, typename ConstructibleArrayType>
void from_json_array_impl(const BasicJsonType& j, ConstructibleArrayType& arr,
                          priority_tag<0> /*unused*/)
{
    using std::end;

    ConstructibleArrayType ret;
    std::transform(
        j.begin(), j.end(), std::inserter(ret, end(ret)),
        [](const BasicJsonType & i)
    {
        // get<BasicJsonType>() returns *this, this won't call a from_json
        // method when value_type is BasicJsonType
        return i.template get<typename ConstructibleArrayType::value_type>();
    });
    arr = std::move(ret);
}

template < typename BasicJsonType, typename ConstructibleArrayType,
           enable_if_t <
               is_constructible_array_type<BasicJsonType, ConstructibleArrayType>::value&&
               !is_constructible_object_type<BasicJsonType, ConstructibleArrayType>::value&&
               !is_constructible_string_type<BasicJsonType, ConstructibleArrayType>::value&&
               !std::is_same<ConstructibleArrayType, typename BasicJsonType::binary_t>::value&&
               !is_basic_json<ConstructibleArrayType>::value,
               int > = 0 >
auto from_json(const BasicJsonType& j, ConstructibleArrayType& arr)
-> decltype(from_json_array_impl(j, arr, priority_tag<3> {}),
j.template get<typename ConstructibleArrayType::value_type>(),
void())
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
    {
        JSON_THROW(type_error::create(302, "type must be array, but is " +
                                      std::string(j.type_name())));
    }

    from_json_array_impl(j, arr, priority_tag<3> {});
}

template<typename BasicJsonType>
void from_json(const BasicJsonType& j, typename BasicJsonType::binary_t& bin)
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_binary()))
    {
        JSON_THROW(type_error::create(302, "type must be binary, but is " + std::string(j.type_name())));
    }

    bin = *j.template get_ptr<const typename BasicJsonType::binary_t*>();
}

template<typename BasicJsonType, typename ConstructibleObjectType,
         enable_if_t<is_constructible_object_type<BasicJsonType, ConstructibleObjectType>::value, int> = 0>
void from_json(const BasicJsonType& j, ConstructibleObjectType& obj)
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_object()))
    {
        JSON_THROW(type_error::create(302, "type must be object, but is " + std::string(j.type_name())));
    }

    ConstructibleObjectType ret;
    auto inner_object = j.template get_ptr<const typename BasicJsonType::object_t*>();
    using value_type = typename ConstructibleObjectType::value_type;
    std::transform(
        inner_object->begin(), inner_object->end(),
        std::inserter(ret, ret.begin()),
        [](typename BasicJsonType::object_t::value_type const & p)
    {
        return value_type(p.first, p.second.template get<typename ConstructibleObjectType::mapped_type>());
    });
    obj = std::move(ret);
}

// overload for arithmetic types, not chosen for basic_json template arguments
// (BooleanType, etc..); note: Is it really necessary to provide explicit
// overloads for boolean_t etc. in case of a custom BooleanType which is not
// an arithmetic type?
template < typename BasicJsonType, typename ArithmeticType,
           enable_if_t <
               std::is_arithmetic<ArithmeticType>::value&&
               !std::is_same<ArithmeticType, typename BasicJsonType::number_unsigned_t>::value&&
               !std::is_same<ArithmeticType, typename BasicJsonType::number_integer_t>::value&&
               !std::is_same<ArithmeticType, typename BasicJsonType::number_float_t>::value&&
               !std::is_same<ArithmeticType, typename BasicJsonType::boolean_t>::value,
               int > = 0 >
void from_json(const BasicJsonType& j, ArithmeticType& val)
{
    switch (static_cast<value_t>(j))
    {
        case value_t::number_unsigned:
        {
            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_unsigned_t*>());
            break;
        }
        case value_t::number_integer:
        {
            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_integer_t*>());
            break;
        }
        case value_t::number_float:
        {
            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_float_t*>());
            break;
        }
        case value_t::boolean:
        {
            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::boolean_t*>());
            break;
        }

        default:
            JSON_THROW(type_error::create(302, "type must be number, but is " + std::string(j.type_name())));
    }
}

template<typename BasicJsonType, typename A1, typename A2>
void from_json(const BasicJsonType& j, std::pair<A1, A2>& p)
{
    p = {j.at(0).template get<A1>(), j.at(1).template get<A2>()};
}

template<typename BasicJsonType, typename Tuple, std::size_t... Idx>
void from_json_tuple_impl(const BasicJsonType& j, Tuple& t, index_sequence<Idx...> /*unused*/)
{
    t = std::make_tuple(j.at(Idx).template get<typename std::tuple_element<Idx, Tuple>::type>()...);
}

template<typename BasicJsonType, typename... Args>
void from_json(const BasicJsonType& j, std::tuple<Args...>& t)
{
    from_json_tuple_impl(j, t, index_sequence_for<Args...> {});
}

template < typename BasicJsonType, typename Key, typename Value, typename Compare, typename Allocator,
           typename = enable_if_t < !std::is_constructible <
                                        typename BasicJsonType::string_t, Key >::value >>
void from_json(const BasicJsonType& j, std::map<Key, Value, Compare, Allocator>& m)
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
    {
        JSON_THROW(type_error::create(302, "type must be array, but is " + std::string(j.type_name())));
    }
    m.clear();
    for (const auto& p : j)
    {
        if (JSON_HEDLEY_UNLIKELY(!p.is_array()))
        {
            JSON_THROW(type_error::create(302, "type must be array, but is " + std::string(p.type_name())));
        }
        m.emplace(p.at(0).template get<Key>(), p.at(1).template get<Value>());
    }
}

template < typename BasicJsonType, typename Key, typename Value, typename Hash, typename KeyEqual, typename Allocator,
           typename = enable_if_t < !std::is_constructible <
                                        typename BasicJsonType::string_t, Key >::value >>
void from_json(const BasicJsonType& j, std::unordered_map<Key, Value, Hash, KeyEqual, Allocator>& m)
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
    {
        JSON_THROW(type_error::create(302, "type must be array, but is " + std::string(j.type_name())));
    }
    m.clear();
    for (const auto& p : j)
    {
        if (JSON_HEDLEY_UNLIKELY(!p.is_array()))
        {
            JSON_THROW(type_error::create(302, "type must be array, but is " + std::string(p.type_name())));
        }
        m.emplace(p.at(0).template get<Key>(), p.at(1).template get<Value>());
    }
}

struct from_json_fn
{
    template<typename BasicJsonType, typename T>
    auto operator()(const BasicJsonType& j, T& val) const
    noexcept(noexcept(from_json(j, val)))
    -> decltype(from_json(j, val), void())
    {
        return from_json(j, val);
    }
};
}  // namespace detail

/// namespace to hold default `from_json` function
/// to see why this is required:
/// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4381.html
namespace
{
constexpr const auto& from_json = detail::static_const<detail::from_json_fn>::value;
} // namespace
} // namespace nlohmann

// #include <nlohmann/detail/conversions/to_json.hpp>


#include <algorithm> // copy
#include <iterator> // begin, end
#include <string> // string
#include <tuple> // tuple, get
#include <type_traits> // is_same, is_constructible, is_floating_point, is_enum, underlying_type
#include <utility> // move, forward, declval, pair
#include <valarray> // valarray
#include <vector> // vector

// #include <nlohmann/detail/iterators/iteration_proxy.hpp>


#include <cstddef> // size_t
#include <iterator> // input_iterator_tag
#include <string> // string, to_string
#include <tuple> // tuple_size, get, tuple_element

// #include <nlohmann/detail/meta/type_traits.hpp>

// #include <nlohmann/detail/value_t.hpp>


namespace nlohmann
{
namespace detail
{
template<typename string_type>
void int_to_string( string_type& target, std::size_t value )
{
    // For ADL
    using std::to_string;
    target = to_string(value);
}
template<typename IteratorType> class iteration_proxy_value
{
  public:
    using difference_type = std::ptrdiff_t;
    using value_type = iteration_proxy_value;
    using pointer = value_type * ;
    using reference = value_type & ;
    using iterator_category = std::input_iterator_tag;
    using string_type = typename std::remove_cv< typename std::remove_reference<decltype( std::declval<IteratorType>().key() ) >::type >::type;

  private:
    /// the iterator
    IteratorType anchor;
    /// an index for arrays (used to create key names)
    std::size_t array_index = 0;
    /// last stringified array index
    mutable std::size_t array_index_last = 0;
    /// a string representation of the array index
    mutable string_type array_index_str = "0";
    /// an empty string (to return a reference for primitive values)
    const string_type empty_str = "";

  public:
    explicit iteration_proxy_value(IteratorType it) noexcept : anchor(it) {}

    /// dereference operator (needed for range-based for)
    iteration_proxy_value& operator*()
    {
        return *this;
    }

    /// increment operator (needed for range-based for)
    iteration_proxy_value& operator++()
    {
        ++anchor;
        ++array_index;

        return *this;
    }

    /// equality operator (needed for InputIterator)
    bool operator==(const iteration_proxy_value& o) const
    {
        return anchor == o.anchor;
    }

    /// inequality operator (needed for range-based for)
    bool operator!=(const iteration_proxy_value& o) const
    {
        return anchor != o.anchor;
    }

    /// return key of the iterator
    const string_type& key() const
    {
        JSON_ASSERT(anchor.m_object != nullptr);

        switch (anchor.m_object->type())
        {
            // use integer array index as key
            case value_t::array:
            {
                if (array_index != array_index_last)
                {
                    int_to_string( array_index_str, array_index );
                    array_index_last = array_index;
                }
                return array_index_str;
            }

            // use key from the object
            case value_t::object:
                return anchor.key();

            // use an empty key for all primitive types
            default:
                return empty_str;
        }
    }

    /// return value of the iterator
    typename IteratorType::reference value() const
    {
        return anchor.value();
    }
};

/// proxy class for the items() function
template<typename IteratorType> class iteration_proxy
{
  private:
    /// the container to iterate
    typename IteratorType::reference container;

  public:
    /// construct iteration proxy from a container
    explicit iteration_proxy(typename IteratorType::reference cont) noexcept
        : container(cont) {}

    /// return iterator begin (needed for range-based for)
    iteration_proxy_value<IteratorType> begin() noexcept
    {
        return iteration_proxy_value<IteratorType>(container.begin());
    }

    /// return iterator end (needed for range-based for)
    iteration_proxy_value<IteratorType> end() noexcept
    {
        return iteration_proxy_value<IteratorType>(container.end());
    }
};
// Structured Bindings Support
// For further reference see https://blog.tartanllama.xyz/structured-bindings/
// And see https://github.com/nlohmann/json/pull/1391
template<std::size_t N, typename IteratorType, enable_if_t<N == 0, int> = 0>
auto get(const nlohmann::detail::iteration_proxy_value<IteratorType>& i) -> decltype(i.key())
{
    return i.key();
}
// Structured Bindings Support
// For further reference see https://blog.tartanllama.xyz/structured-bindings/
// And see https://github.com/nlohmann/json/pull/1391
template<std::size_t N, typename IteratorType, enable_if_t<N == 1, int> = 0>
auto get(const nlohmann::detail::iteration_proxy_value<IteratorType>& i) -> decltype(i.value())
{
    return i.value();
}
}  // namespace detail
}  // namespace nlohmann

// The Addition to the STD Namespace is required to add
// Structured Bindings Support to the iteration_proxy_value class
// For further reference see https://blog.tartanllama.xyz/structured-bindings/
// And see https://github.com/nlohmann/json/pull/1391
namespace std
{
#if defined(__clang__)
    // Fix: https://github.com/nlohmann/json/issues/1401
    #pragma clang diagnostic push
    #pragma clang diagnostic ignored "-Wmismatched-tags"
#endif
template<typename IteratorType>
class tuple_size<::nlohmann::detail::iteration_proxy_value<IteratorType>>
            : public std::integral_constant<std::size_t, 2> {};

template<std::size_t N, typename IteratorType>
class tuple_element<N, ::nlohmann::detail::iteration_proxy_value<IteratorType >>
{
  public:
    using type = decltype(
                     get<N>(std::declval <
                            ::nlohmann::detail::iteration_proxy_value<IteratorType >> ()));
};
#if defined(__clang__)
    #pragma clang diagnostic pop
#endif
} // namespace std

// #include <nlohmann/detail/meta/cpp_future.hpp>

// #include <nlohmann/detail/meta/type_traits.hpp>

// #include <nlohmann/detail/value_t.hpp>


namespace nlohmann
{
namespace detail
{
//////////////////
// constructors //
//////////////////

template<value_t> struct external_constructor;

template<>
struct external_constructor<value_t::boolean>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::boolean_t b) noexcept
    {
        j.m_type = value_t::boolean;
        j.m_value = b;
        j.assert_invariant();
    }
};

template<>
struct external_constructor<value_t::string>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, const typename BasicJsonType::string_t& s)
    {
        j.m_type = value_t::string;
        j.m_value = s;
        j.assert_invariant();
    }

    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::string_t&& s)
    {
        j.m_type = value_t::string;
        j.m_value = std::move(s);
        j.assert_invariant();
    }

    template < typename BasicJsonType, typename CompatibleStringType,
               enable_if_t < !std::is_same<CompatibleStringType, typename BasicJsonType::string_t>::value,
                             int > = 0 >
    static void construct(BasicJsonType& j, const CompatibleStringType& str)
    {
        j.m_type = value_t::string;
        j.m_value.string = j.template create<typename BasicJsonType::string_t>(str);
        j.assert_invariant();
    }
};

template<>
struct external_constructor<value_t::binary>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, const typename BasicJsonType::binary_t& b)
    {
        j.m_type = value_t::binary;
        typename BasicJsonType::binary_t value{b};
        j.m_value = value;
        j.assert_invariant();
    }

    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::binary_t&& b)
    {
        j.m_type = value_t::binary;
        typename BasicJsonType::binary_t value{std::move(b)};
        j.m_value = value;
        j.assert_invariant();
    }
};

template<>
struct external_constructor<value_t::number_float>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::number_float_t val) noexcept
    {
        j.m_type = value_t::number_float;
        j.m_value = val;
        j.assert_invariant();
    }
};

template<>
struct external_constructor<value_t::number_unsigned>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::number_unsigned_t val) noexcept
    {
        j.m_type = value_t::number_unsigned;
        j.m_value = val;
        j.assert_invariant();
    }
};

template<>
struct external_constructor<value_t::number_integer>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::number_integer_t val) noexcept
    {
        j.m_type = value_t::number_integer;
        j.m_value = val;
        j.assert_invariant();
    }
};

template<>
struct external_constructor<value_t::array>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, const typename BasicJsonType::array_t& arr)
    {
        j.m_type = value_t::array;
        j.m_value = arr;
        j.assert_invariant();
    }

    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::array_t&& arr)
    {
        j.m_type = value_t::array;
        j.m_value = std::move(arr);
        j.assert_invariant();
    }

    template < typename BasicJsonType, typename CompatibleArrayType,
               enable_if_t < !std::is_same<CompatibleArrayType, typename BasicJsonType::array_t>::value,
                             int > = 0 >
    static void construct(BasicJsonType& j, const CompatibleArrayType& arr)
    {
        using std::begin;
        using std::end;
        j.m_type = value_t::array;
        j.m_value.array = j.template create<typename BasicJsonType::array_t>(begin(arr), end(arr));
        j.assert_invariant();
    }

    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, const std::vector<bool>& arr)
    {
        j.m_type = value_t::array;
        j.m_value = value_t::array;
        j.m_value.array->reserve(arr.size());
        for (const bool x : arr)
        {
            j.m_value.array->push_back(x);
        }
        j.assert_invariant();
    }

    template<typename BasicJsonType, typename T,
             enable_if_t<std::is_convertible<T, BasicJsonType>::value, int> = 0>
    static void construct(BasicJsonType& j, const std::valarray<T>& arr)
    {
        j.m_type = value_t::array;
        j.m_value = value_t::array;
        j.m_value.array->resize(arr.size());
        if (arr.size() > 0)
        {
            std::copy(std::begin(arr), std::end(arr), j.m_value.array->begin());
        }
        j.assert_invariant();
    }
};

template<>
struct external_constructor<value_t::object>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, const typename BasicJsonType::object_t& obj)
    {
        j.m_type = value_t::object;
        j.m_value = obj;
        j.assert_invariant();
    }

    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::object_t&& obj)
    {
        j.m_type = value_t::object;
        j.m_value = std::move(obj);
        j.assert_invariant();
    }

    template < typename BasicJsonType, typename CompatibleObjectType,
               enable_if_t < !std::is_same<CompatibleObjectType, typename BasicJsonType::object_t>::value, int > = 0 >
    static void construct(BasicJsonType& j, const CompatibleObjectType& obj)
    {
        using std::begin;
        using std::end;

        j.m_type = value_t::object;
        j.m_value.object = j.template create<typename BasicJsonType::object_t>(begin(obj), end(obj));
        j.assert_invariant();
    }
};

/////////////
// to_json //
/////////////

template<typename BasicJsonType, typename T,
         enable_if_t<std::is_same<T, typename BasicJsonType::boolean_t>::value, int> = 0>
void to_json(BasicJsonType& j, T b) noexcept
{
    external_constructor<value_t::boolean>::construct(j, b);
}

template<typename BasicJsonType, typename CompatibleString,
         enable_if_t<std::is_constructible<typename BasicJsonType::string_t, CompatibleString>::value, int> = 0>
void to_json(BasicJsonType& j, const CompatibleString& s)
{
    external_constructor<value_t::string>::construct(j, s);
}

template<typename BasicJsonType>
void to_json(BasicJsonType& j, typename BasicJsonType::string_t&& s)
{
    external_constructor<value_t::string>::construct(j, std::move(s));
}

template<typename BasicJsonType, typename FloatType,
         enable_if_t<std::is_floating_point<FloatType>::value, int> = 0>
void to_json(BasicJsonType& j, FloatType val) noexcept
{
    external_constructor<value_t::number_float>::construct(j, static_cast<typename BasicJsonType::number_float_t>(val));
}

template<typename BasicJsonType, typename CompatibleNumberUnsignedType,
         enable_if_t<is_compatible_integer_type<typename BasicJsonType::number_unsigned_t, CompatibleNumberUnsignedType>::value, int> = 0>
void to_json(BasicJsonType& j, CompatibleNumberUnsignedType val) noexcept
{
    external_constructor<value_t::number_unsigned>::construct(j, static_cast<typename BasicJsonType::number_unsigned_t>(val));
}

template<typename BasicJsonType, typename CompatibleNumberIntegerType,
         enable_if_t<is_compatible_integer_type<typename BasicJsonType::number_integer_t, CompatibleNumberIntegerType>::value, int> = 0>
void to_json(BasicJsonType& j, CompatibleNumberIntegerType val) noexcept
{
    external_constructor<value_t::number_integer>::construct(j, static_cast<typename BasicJsonType::number_integer_t>(val));
}

template<typename BasicJsonType, typename EnumType,
         enable_if_t<std::is_enum<EnumType>::value, int> = 0>
void to_json(BasicJsonType& j, EnumType e) noexcept
{
    using underlying_type = typename std::underlying_type<EnumType>::type;
    external_constructor<value_t::number_integer>::construct(j, static_cast<underlying_type>(e));
}

template<typename BasicJsonType>
void to_json(BasicJsonType& j, const std::vector<bool>& e)
{
    external_constructor<value_t::array>::construct(j, e);
}

template < typename BasicJsonType, typename CompatibleArrayType,
           enable_if_t < is_compatible_array_type<BasicJsonType,
                         CompatibleArrayType>::value&&
                         !is_compatible_object_type<BasicJsonType, CompatibleArrayType>::value&&
                         !is_compatible_string_type<BasicJsonType, CompatibleArrayType>::value&&
                         !std::is_same<typename BasicJsonType::binary_t, CompatibleArrayType>::value&&
                         !is_basic_json<CompatibleArrayType>::value,
                         int > = 0 >
void to_json(BasicJsonType& j, const CompatibleArrayType& arr)
{
    external_constructor<value_t::array>::construct(j, arr);
}

template<typename BasicJsonType>
void to_json(BasicJsonType& j, const typename BasicJsonType::binary_t& bin)
{
    external_constructor<value_t::binary>::construct(j, bin);
}

template<typename BasicJsonType, typename T,
         enable_if_t<std::is_convertible<T, BasicJsonType>::value, int> = 0>
void to_json(BasicJsonType& j, const std::valarray<T>& arr)
{
    external_constructor<value_t::array>::construct(j, std::move(arr));
}

template<typename BasicJsonType>
void to_json(BasicJsonType& j, typename BasicJsonType::array_t&& arr)
{
    external_constructor<value_t::array>::construct(j, std::move(arr));
}

template < typename BasicJsonType, typename CompatibleObjectType,
           enable_if_t < is_compatible_object_type<BasicJsonType, CompatibleObjectType>::value&& !is_basic_json<CompatibleObjectType>::value, int > = 0 >
void to_json(BasicJsonType& j, const CompatibleObjectType& obj)
{
    external_constructor<value_t::object>::construct(j, obj);
}

template<typename BasicJsonType>
void to_json(BasicJsonType& j, typename BasicJsonType::object_t&& obj)
{
    external_constructor<value_t::object>::construct(j, std::move(obj));
}

template <
    typename BasicJsonType, typename T, std::size_t N,
    enable_if_t < !std::is_constructible<typename BasicJsonType::string_t,
                  const T(&)[N]>::value,
                  int > = 0 >
void to_json(BasicJsonType& j, const T(&arr)[N])
{
    external_constructor<value_t::array>::construct(j, arr);
}

template < typename BasicJsonType, typename T1, typename T2, enable_if_t < std::is_constructible<BasicJsonType, T1>::value&& std::is_constructible<BasicJsonType, T2>::value, int > = 0 >
void to_json(BasicJsonType& j, const std::pair<T1, T2>& p)
{
    j = { p.first, p.second };
}

// for https://github.com/nlohmann/json/pull/1134
template<typename BasicJsonType, typename T,
         enable_if_t<std::is_same<T, iteration_proxy_value<typename BasicJsonType::iterator>>::value, int> = 0>
void to_json(BasicJsonType& j, const T& b)
{
    j = { {b.key(), b.value()} };
}

template<typename BasicJsonType, typename Tuple, std::size_t... Idx>
void to_json_tuple_impl(BasicJsonType& j, const Tuple& t, index_sequence<Idx...> /*unused*/)
{
    j = { std::get<Idx>(t)... };
}

template<typename BasicJsonType, typename T, enable_if_t<is_constructible_tuple<BasicJsonType, T>::value, int > = 0>
void to_json(BasicJsonType& j, const T& t)
{
    to_json_tuple_impl(j, t, make_index_sequence<std::tuple_size<T>::value> {});
}

struct to_json_fn
{
    template<typename BasicJsonType, typename T>
    auto operator()(BasicJsonType& j, T&& val) const noexcept(noexcept(to_json(j, std::forward<T>(val))))
    -> decltype(to_json(j, std::forward<T>(val)), void())
    {
        return to_json(j, std::forward<T>(val));
    }
};
}  // namespace detail

/// namespace to hold default `to_json` function
namespace
{
constexpr const auto& to_json = detail::static_const<detail::to_json_fn>::value;
} // namespace
} // namespace nlohmann


namespace nlohmann
{

template<typename, typename>
struct adl_serializer
{
    /*!
    @brief convert a JSON value to any value type

    This function is usually called by the `get()` function of the
    @ref basic_json class (either explicit or via conversion operators).

    @param[in] j        JSON value to read from
    @param[in,out] val  value to write to
    */
    template<typename BasicJsonType, typename ValueType>
    static auto from_json(BasicJsonType&& j, ValueType& val) noexcept(
        noexcept(::nlohmann::from_json(std::forward<BasicJsonType>(j), val)))
    -> decltype(::nlohmann::from_json(std::forward<BasicJsonType>(j), val), void())
    {
        ::nlohmann::from_json(std::forward<BasicJsonType>(j), val);
    }

    /*!
    @brief convert any value type to a JSON value

    This function is usually called by the constructors of the @ref basic_json
    class.

    @param[in,out] j  JSON value to write to
    @param[in] val    value to read from
    */
    template<typename BasicJsonType, typename ValueType>
    static auto to_json(BasicJsonType& j, ValueType&& val) noexcept(
        noexcept(::nlohmann::to_json(j, std::forward<ValueType>(val))))
    -> decltype(::nlohmann::to_json(j, std::forward<ValueType>(val)), void())
    {
        ::nlohmann::to_json(j, std::forward<ValueType>(val));
    }
};

}  // namespace nlohmann

// #include <nlohmann/byte_container_with_subtype.hpp>


#include <cstdint> // uint8_t
#include <tuple> // tie
#include <utility> // move

namespace nlohmann
{

/*!
@brief an internal type for a backed binary type

This type extends the template parameter @a BinaryType provided to `basic_json`
with a subtype used by BSON and MessagePack. This type exists so that the user
does not have to specify a type themselves with a specific naming scheme in
order to override the binary type.

@tparam BinaryType container to store bytes (`std::vector<std::uint8_t>` by
                   default)

@since version 3.8.0
*/
template<typename BinaryType>
class byte_container_with_subtype : public BinaryType
{
  public:
    /// the type of the underlying container
    using container_type = BinaryType;

    byte_container_with_subtype() noexcept(noexcept(container_type()))
        : container_type()
    {}

    byte_container_with_subtype(const container_type& b) noexcept(noexcept(container_type(b)))
        : container_type(b)
    {}

    byte_container_with_subtype(container_type&& b) noexcept(noexcept(container_type(std::move(b))))
        : container_type(std::move(b))
    {}

    byte_container_with_subtype(const container_type& b, std::uint8_t subtype) noexcept(noexcept(container_type(b)))
        : container_type(b)
        , m_subtype(subtype)
        , m_has_subtype(true)
    {}

    byte_container_with_subtype(container_type&& b, std::uint8_t subtype) noexcept(noexcept(container_type(std::move(b))))
        : container_type(std::move(b))
        , m_subtype(subtype)
        , m_has_subtype(true)
    {}

    bool operator==(const byte_container_with_subtype& rhs) const
    {
        return std::tie(static_cast<const BinaryType&>(*this), m_subtype, m_has_subtype) ==
               std::tie(static_cast<const BinaryType&>(rhs), rhs.m_subtype, rhs.m_has_subtype);
    }

    bool operator!=(const byte_container_with_subtype& rhs) const
    {
        return !(rhs == *this);
    }

    /*!
    @brief sets the binary subtype

    Sets the binary subtype of the value, also flags a binary JSON value as
    having a subtype, which has implications for serialization.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @sa @ref subtype() -- return the binary subtype
    @sa @ref clear_subtype() -- clears the binary subtype
    @sa @ref has_subtype() -- returns whether or not the binary value has a
    subtype

    @since version 3.8.0
    */
    void set_subtype(std::uint8_t subtype) noexcept
    {
        m_subtype = subtype;
        m_has_subtype = true;
    }

    /*!
    @brief return the binary subtype

    Returns the numerical subtype of the value if it has a subtype. If it does
    not have a subtype, this function will return size_t(-1) as a sentinel
    value.

    @return the numerical subtype of the binary value

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @sa @ref set_subtype() -- sets the binary subtype
    @sa @ref clear_subtype() -- clears the binary subtype
    @sa @ref has_subtype() -- returns whether or not the binary value has a
    subtype

    @since version 3.8.0
    */
    constexpr std::uint8_t subtype() const noexcept
    {
        return m_subtype;
    }

    /*!
    @brief return whether the value has a subtype

    @return whether the value has a subtype

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @sa @ref subtype() -- return the binary subtype
    @sa @ref set_subtype() -- sets the binary subtype
    @sa @ref clear_subtype() -- clears the binary subtype

    @since version 3.8.0
    */
    constexpr bool has_subtype() const noexcept
    {
        return m_has_subtype;
    }

    /*!
    @brief clears the binary subtype

    Clears the binary subtype and flags the value as not having a subtype, which
    has implications for serialization; for instance MessagePack will prefer the
    bin family over the ext family.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @sa @ref subtype() -- return the binary subtype
    @sa @ref set_subtype() -- sets the binary subtype
    @sa @ref has_subtype() -- returns whether or not the binary value has a
    subtype

    @since version 3.8.0
    */
    void clear_subtype() noexcept
    {
        m_subtype = 0;
        m_has_subtype = false;
    }

  private:
    std::uint8_t m_subtype = 0;
    bool m_has_subtype = false;
};

}  // namespace nlohmann

// #include <nlohmann/detail/conversions/from_json.hpp>

// #include <nlohmann/detail/conversions/to_json.hpp>

// #include <nlohmann/detail/exceptions.hpp>

// #include <nlohmann/detail/hash.hpp>


#include <cstddef> // size_t, uint8_t
#include <functional> // hash

namespace nlohmann
{
namespace detail
{

// boost::hash_combine
inline std::size_t combine(std::size_t seed, std::size_t h) noexcept
{
    seed ^= h + 0x9e3779b9 + (seed << 6U) + (seed >> 2U);
    return seed;
}

/*!
@brief hash a JSON value

The hash function tries to rely on std::hash where possible. Furthermore, the
type of the JSON value is taken into account to have different hash values for
null, 0, 0U, and false, etc.

@tparam BasicJsonType basic_json specialization
@param j JSON value to hash
@return hash value of j
*/
template<typename BasicJsonType>
std::size_t hash(const BasicJsonType& j)
{
    using string_t = typename BasicJsonType::string_t;
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;

    const auto type = static_cast<std::size_t>(j.type());
    switch (j.type())
    {
        case BasicJsonType::value_t::null:
        case BasicJsonType::value_t::discarded:
        {
            return combine(type, 0);
        }

        case BasicJsonType::value_t::object:
        {
            auto seed = combine(type, j.size());
            for (const auto& element : j.items())
            {
                const auto h = std::hash<string_t> {}(element.key());
                seed = combine(seed, h);
                seed = combine(seed, hash(element.value()));
            }
            return seed;
        }

        case BasicJsonType::value_t::array:
        {
            auto seed = combine(type, j.size());
            for (const auto& element : j)
            {
                seed = combine(seed, hash(element));
            }
            return seed;
        }

        case BasicJsonType::value_t::string:
        {
            const auto h = std::hash<string_t> {}(j.template get_ref<const string_t&>());
            return combine(type, h);
        }

        case BasicJsonType::value_t::boolean:
        {
            const auto h = std::hash<bool> {}(j.template get<bool>());
            return combine(type, h);
        }

        case BasicJsonType::value_t::number_integer:
        {
            const auto h = std::hash<number_integer_t> {}(j.template get<number_integer_t>());
            return combine(type, h);
        }

        case nlohmann::detail::value_t::number_unsigned:
        {
            const auto h = std::hash<number_unsigned_t> {}(j.template get<number_unsigned_t>());
            return combine(type, h);
        }

        case nlohmann::detail::value_t::number_float:
        {
            const auto h = std::hash<number_float_t> {}(j.template get<number_float_t>());
            return combine(type, h);
        }

        case nlohmann::detail::value_t::binary:
        {
            auto seed = combine(type, j.get_binary().size());
            const auto h = std::hash<bool> {}(j.get_binary().has_subtype());
            seed = combine(seed, h);
            seed = combine(seed, j.get_binary().subtype());
            for (const auto byte : j.get_binary())
            {
                seed = combine(seed, std::hash<std::uint8_t> {}(byte));
            }
            return seed;
        }

        default: // LCOV_EXCL_LINE
            JSON_ASSERT(false); // LCOV_EXCL_LINE
    }
}

}  // namespace detail
}  // namespace nlohmann

// #include <nlohmann/detail/input/binary_reader.hpp>


#include <algorithm> // generate_n
#include <array> // array
#include <cmath> // ldexp
#include <cstddef> // size_t
#include <cstdint> // uint8_t, uint16_t, uint32_t, uint64_t
#include <cstdio> // snprintf
#include <cstring> // memcpy
#include <iterator> // back_inserter
#include <limits> // numeric_limits
#include <string> // char_traits, string
#include <utility> // make_pair, move

// #include <nlohmann/detail/exceptions.hpp>

// #include <nlohmann/detail/input/input_adapters.hpp>


#include <array> // array
#include <cstddef> // size_t
#include <cstdio> //FILE *
#include <cstring> // strlen
#include <istream> // istream
#include <iterator> // begin, end, iterator_traits, random_access_iterator_tag, distance, next
#include <memory> // shared_ptr, make_shared, addressof
#include <numeric> // accumulate
#include <string> // string, char_traits
#include <type_traits> // enable_if, is_base_of, is_pointer, is_integral, remove_pointer
#include <utility> // pair, declval

// #include <nlohmann/detail/iterators/iterator_traits.hpp>

// #include <nlohmann/detail/macro_scope.hpp>


namespace nlohmann
{
namespace detail
{
/// the supported input formats
enum class input_format_t { json, cbor, msgpack, ubjson, bson };

////////////////////
// input adapters //
////////////////////

/*!
Input adapter for stdio file access. This adapter read only 1 byte and do not use any
 buffer. This adapter is a very low level adapter.
*/
class file_input_adapter
{
  public:
    using char_type = char;

    JSON_HEDLEY_NON_NULL(2)
    explicit file_input_adapter(std::FILE* f) noexcept
        : m_file(f)
    {}

    // make class move-only
    file_input_adapter(const file_input_adapter&) = delete;
    file_input_adapter(file_input_adapter&&) = default;
    file_input_adapter& operator=(const file_input_adapter&) = delete;
    file_input_adapter& operator=(file_input_adapter&&) = delete;

    std::char_traits<char>::int_type get_character() noexcept
    {
        return std::fgetc(m_file);
    }

  private:
    /// the file pointer to read from
    std::FILE* m_file;
};


/*!
Input adapter for a (caching) istream. Ignores a UFT Byte Order Mark at
beginning of input. Does not support changing the underlying std::streambuf
in mid-input. Maintains underlying std::istream and std::streambuf to support
subsequent use of standard std::istream operations to process any input
characters following those used in parsing the JSON input.  Clears the
std::istream flags; any input errors (e.g., EOF) will be detected by the first
subsequent call for input from the std::istream.
*/
class input_stream_adapter
{
  public:
    using char_type = char;

    ~input_stream_adapter()
    {
        // clear stream flags; we use underlying streambuf I/O, do not
        // maintain ifstream flags, except eof
        if (is != nullptr)
        {
            is->clear(is->rdstate() & std::ios::eofbit);
        }
    }

    explicit input_stream_adapter(std::istream& i)
        : is(&i), sb(i.rdbuf())
    {}

    // delete because of pointer members
    input_stream_adapter(const input_stream_adapter&) = delete;
    input_stream_adapter& operator=(input_stream_adapter&) = delete;
    input_stream_adapter& operator=(input_stream_adapter&& rhs) = delete;

    input_stream_adapter(input_stream_adapter&& rhs) noexcept : is(rhs.is), sb(rhs.sb)
    {
        rhs.is = nullptr;
        rhs.sb = nullptr;
    }

    // std::istream/std::streambuf use std::char_traits<char>::to_int_type, to
    // ensure that std::char_traits<char>::eof() and the character 0xFF do not
    // end up as the same value, eg. 0xFFFFFFFF.
    std::char_traits<char>::int_type get_character()
    {
        auto res = sb->sbumpc();
        // set eof manually, as we don't use the istream interface.
        if (JSON_HEDLEY_UNLIKELY(res == EOF))
        {
            is->clear(is->rdstate() | std::ios::eofbit);
        }
        return res;
    }

  private:
    /// the associated input stream
    std::istream* is = nullptr;
    std::streambuf* sb = nullptr;
};

// General-purpose iterator-based adapter. It might not be as fast as
// theoretically possible for some containers, but it is extremely versatile.
template<typename IteratorType>
class iterator_input_adapter
{
  public:
    using char_type = typename std::iterator_traits<IteratorType>::value_type;

    iterator_input_adapter(IteratorType first, IteratorType last)
        : current(std::move(first)), end(std::move(last)) {}

    typename std::char_traits<char_type>::int_type get_character()
    {
        if (JSON_HEDLEY_LIKELY(current != end))
        {
            auto result = std::char_traits<char_type>::to_int_type(*current);
            std::advance(current, 1);
            return result;
        }
        else
        {
            return std::char_traits<char_type>::eof();
        }
    }

  private:
    IteratorType current;
    IteratorType end;

    template<typename BaseInputAdapter, size_t T>
    friend struct wide_string_input_helper;

    bool empty() const
    {
        return current == end;
    }

};


template<typename BaseInputAdapter, size_t T>
struct wide_string_input_helper;

template<typename BaseInputAdapter>
struct wide_string_input_helper<BaseInputAdapter, 4>
{
    // UTF-32
    static void fill_buffer(BaseInputAdapter& input,
                            std::array<std::char_traits<char>::int_type, 4>& utf8_bytes,
                            size_t& utf8_bytes_index,
                            size_t& utf8_bytes_filled)
    {
        utf8_bytes_index = 0;

        if (JSON_HEDLEY_UNLIKELY(input.empty()))
        {
            utf8_bytes[0] = std::char_traits<char>::eof();
            utf8_bytes_filled = 1;
        }
        else
        {
            // get the current character
            const auto wc = input.get_character();

            // UTF-32 to UTF-8 encoding
            if (wc < 0x80)
            {
                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(wc);
                utf8_bytes_filled = 1;
            }
            else if (wc <= 0x7FF)
            {
                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xC0u | ((static_cast<unsigned int>(wc) >> 6u) & 0x1Fu));
                utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | (static_cast<unsigned int>(wc) & 0x3Fu));
                utf8_bytes_filled = 2;
            }
            else if (wc <= 0xFFFF)
            {
                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xE0u | ((static_cast<unsigned int>(wc) >> 12u) & 0x0Fu));
                utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | ((static_cast<unsigned int>(wc) >> 6u) & 0x3Fu));
                utf8_bytes[2] = static_cast<std::char_traits<char>::int_type>(0x80u | (static_cast<unsigned int>(wc) & 0x3Fu));
                utf8_bytes_filled = 3;
            }
            else if (wc <= 0x10FFFF)
            {
                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xF0u | ((static_cast<unsigned int>(wc) >> 18u) & 0x07u));
                utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | ((static_cast<unsigned int>(wc) >> 12u) & 0x3Fu));
                utf8_bytes[2] = static_cast<std::char_traits<char>::int_type>(0x80u | ((static_cast<unsigned int>(wc) >> 6u) & 0x3Fu));
                utf8_bytes[3] = static_cast<std::char_traits<char>::int_type>(0x80u | (static_cast<unsigned int>(wc) & 0x3Fu));
                utf8_bytes_filled = 4;
            }
            else
            {
                // unknown character
                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(wc);
                utf8_bytes_filled = 1;
            }
        }
    }
};

template<typename BaseInputAdapter>
struct wide_string_input_helper<BaseInputAdapter, 2>
{
    // UTF-16
    static void fill_buffer(BaseInputAdapter& input,
                            std::array<std::char_traits<char>::int_type, 4>& utf8_bytes,
                            size_t& utf8_bytes_index,
                            size_t& utf8_bytes_filled)
    {
        utf8_bytes_index = 0;

        if (JSON_HEDLEY_UNLIKELY(input.empty()))
        {
            utf8_bytes[0] = std::char_traits<char>::eof();
            utf8_bytes_filled = 1;
        }
        else
        {
            // get the current character
            const auto wc = input.get_character();

            // UTF-16 to UTF-8 encoding
            if (wc < 0x80)
            {
                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(wc);
                utf8_bytes_filled = 1;
            }
            else if (wc <= 0x7FF)
            {
                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xC0u | ((static_cast<unsigned int>(wc) >> 6u)));
                utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | (static_cast<unsigned int>(wc) & 0x3Fu));
                utf8_bytes_filled = 2;
            }
            else if (0xD800 > wc || wc >= 0xE000)
            {
                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xE0u | ((static_cast<unsigned int>(wc) >> 12u)));
                utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | ((static_cast<unsigned int>(wc) >> 6u) & 0x3Fu));
                utf8_bytes[2] = static_cast<std::char_traits<char>::int_type>(0x80u | (static_cast<unsigned int>(wc) & 0x3Fu));
                utf8_bytes_filled = 3;
            }
            else
            {
                if (JSON_HEDLEY_UNLIKELY(!input.empty()))
                {
                    const auto wc2 = static_cast<unsigned int>(input.get_character());
                    const auto charcode = 0x10000u + (((static_cast<unsigned int>(wc) & 0x3FFu) << 10u) | (wc2 & 0x3FFu));
                    utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xF0u | (charcode >> 18u));
                    utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | ((charcode >> 12u) & 0x3Fu));
                    utf8_bytes[2] = static_cast<std::char_traits<char>::int_type>(0x80u | ((charcode >> 6u) & 0x3Fu));
                    utf8_bytes[3] = static_cast<std::char_traits<char>::int_type>(0x80u | (charcode & 0x3Fu));
                    utf8_bytes_filled = 4;
                }
                else
                {
                    utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(wc);
                    utf8_bytes_filled = 1;
                }
            }
        }
    }
};

// Wraps another input apdater to convert wide character types into individual bytes.
template<typename BaseInputAdapter, typename WideCharType>
class wide_string_input_adapter
{
  public:
    using char_type = char;

    wide_string_input_adapter(BaseInputAdapter base)
        : base_adapter(base) {}

    typename std::char_traits<char>::int_type get_character() noexcept
    {
        // check if buffer needs to be filled
        if (utf8_bytes_index == utf8_bytes_filled)
        {
            fill_buffer<sizeof(WideCharType)>();

            JSON_ASSERT(utf8_bytes_filled > 0);
            JSON_ASSERT(utf8_bytes_index == 0);
        }

        // use buffer
        JSON_ASSERT(utf8_bytes_filled > 0);
        JSON_ASSERT(utf8_bytes_index < utf8_bytes_filled);
        return utf8_bytes[utf8_bytes_index++];
    }

  private:
    BaseInputAdapter base_adapter;

    template<size_t T>
    void fill_buffer()
    {
        wide_string_input_helper<BaseInputAdapter, T>::fill_buffer(base_adapter, utf8_bytes, utf8_bytes_index, utf8_bytes_filled);
    }

    /// a buffer for UTF-8 bytes
    std::array<std::char_traits<char>::int_type, 4> utf8_bytes = {{0, 0, 0, 0}};

    /// index to the utf8_codes array for the next valid byte
    std::size_t utf8_bytes_index = 0;
    /// number of valid bytes in the utf8_codes array
    std::size_t utf8_bytes_filled = 0;
};


template<typename IteratorType, typename Enable = void>
struct iterator_input_adapter_factory
{
    using iterator_type = IteratorType;
    using char_type = typename std::iterator_traits<iterator_type>::value_type;
    using adapter_type = iterator_input_adapter<iterator_type>;

    static adapter_type create(IteratorType first, IteratorType last)
    {
        return adapter_type(std::move(first), std::move(last));
    }
};

template<typename T>
struct is_iterator_of_multibyte
{
    using value_type = typename std::iterator_traits<T>::value_type;
    enum
    {
        value = sizeof(value_type) > 1
    };
};

template<typename IteratorType>
struct iterator_input_adapter_factory<IteratorType, enable_if_t<is_iterator_of_multibyte<IteratorType>::value>>
{
    using iterator_type = IteratorType;
    using char_type = typename std::iterator_traits<iterator_type>::value_type;
    using base_adapter_type = iterator_input_adapter<iterator_type>;
    using adapter_type = wide_string_input_adapter<base_adapter_type, char_type>;

    static adapter_type create(IteratorType first, IteratorType last)
    {
        return adapter_type(base_adapter_type(std::move(first), std::move(last)));
    }
};

// General purpose iterator-based input
template<typename IteratorType>
typename iterator_input_adapter_factory<IteratorType>::adapter_type input_adapter(IteratorType first, IteratorType last)
{
    using factory_type = iterator_input_adapter_factory<IteratorType>;
    return factory_type::create(first, last);
}

// Convenience shorthand from container to iterator
template<typename ContainerType>
auto input_adapter(const ContainerType& container) -> decltype(input_adapter(begin(container), end(container)))
{
    // Enable ADL
    using std::begin;
    using std::end;

    return input_adapter(begin(container), end(container));
}

// Special cases with fast paths
inline file_input_adapter input_adapter(std::FILE* file)
{
    return file_input_adapter(file);
}

inline input_stream_adapter input_adapter(std::istream& stream)
{
    return input_stream_adapter(stream);
}

inline input_stream_adapter input_adapter(std::istream&& stream)
{
    return input_stream_adapter(stream);
}

using contiguous_bytes_input_adapter = decltype(input_adapter(std::declval<const char*>(), std::declval<const char*>()));

// Null-delimited strings, and the like.
template < typename CharT,
           typename std::enable_if <
               std::is_pointer<CharT>::value&&
               !std::is_array<CharT>::value&&
               std::is_integral<typename std::remove_pointer<CharT>::type>::value&&
               sizeof(typename std::remove_pointer<CharT>::type) == 1,
               int >::type = 0 >
contiguous_bytes_input_adapter input_adapter(CharT b)
{
    auto length = std::strlen(reinterpret_cast<const char*>(b));
    const auto* ptr = reinterpret_cast<const char*>(b);
    return input_adapter(ptr, ptr + length);
}

template<typename T, std::size_t N>
auto input_adapter(T (&array)[N]) -> decltype(input_adapter(array, array + N))
{
    return input_adapter(array, array + N);
}

// This class only handles inputs of input_buffer_adapter type.
// It's required so that expressions like {ptr, len} can be implicitely casted
// to the correct adapter.
class span_input_adapter
{
  public:
    template < typename CharT,
               typename std::enable_if <
                   std::is_pointer<CharT>::value&&
                   std::is_integral<typename std::remove_pointer<CharT>::type>::value&&
                   sizeof(typename std::remove_pointer<CharT>::type) == 1,
                   int >::type = 0 >
    span_input_adapter(CharT b, std::size_t l)
        : ia(reinterpret_cast<const char*>(b), reinterpret_cast<const char*>(b) + l) {}

    template<class IteratorType,
             typename std::enable_if<
                 std::is_same<typename iterator_traits<IteratorType>::iterator_category, std::random_access_iterator_tag>::value,
                 int>::type = 0>
    span_input_adapter(IteratorType first, IteratorType last)
        : ia(input_adapter(first, last)) {}

    contiguous_bytes_input_adapter&& get()
    {
        return std::move(ia);
    }

  private:
    contiguous_bytes_input_adapter ia;
};
}  // namespace detail
}  // namespace nlohmann

// #include <nlohmann/detail/input/json_sax.hpp>


#include <cstddef>
#include <string> // string
#include <utility> // move
#include <vector> // vector

// #include <nlohmann/detail/exceptions.hpp>

// #include <nlohmann/detail/macro_scope.hpp>


namespace nlohmann
{

/*!
@brief SAX interface

This class describes the SAX interface used by @ref nlohmann::json::sax_parse.
Each function is called in different situations while the input is parsed. The
boolean return value informs the parser whether to continue processing the
input.
*/
template<typename BasicJsonType>
struct json_sax
{
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;
    using binary_t = typename BasicJsonType::binary_t;

    /*!
    @brief a null value was read
    @return whether parsing should proceed
    */
    virtual bool null() = 0;

    /*!
    @brief a boolean value was read
    @param[in] val  boolean value
    @return whether parsing should proceed
    */
    virtual bool boolean(bool val) = 0;

    /*!
    @brief an integer number was read
    @param[in] val  integer value
    @return whether parsing should proceed
    */
    virtual bool number_integer(number_integer_t val) = 0;

    /*!
    @brief an unsigned integer number was read
    @param[in] val  unsigned integer value
    @return whether parsing should proceed
    */
    virtual bool number_unsigned(number_unsigned_t val) = 0;

    /*!
    @brief an floating-point number was read
    @param[in] val  floating-point value
    @param[in] s    raw token value
    @return whether parsing should proceed
    */
    virtual bool number_float(number_float_t val, const string_t& s) = 0;

    /*!
    @brief a string was read
    @param[in] val  string value
    @return whether parsing should proceed
    @note It is safe to move the passed string.
    */
    virtual bool string(string_t& val) = 0;

    /*!
    @brief a binary string was read
    @param[in] val  binary value
    @return whether parsing should proceed
    @note It is safe to move the passed binary.
    */
    virtual bool binary(binary_t& val) = 0;

    /*!
    @brief the beginning of an object was read
    @param[in] elements  number of object elements or -1 if unknown
    @return whether parsing should proceed
    @note binary formats may report the number of elements
    */
    virtual bool start_object(std::size_t elements) = 0;

    /*!
    @brief an object key was read
    @param[in] val  object key
    @return whether parsing should proceed
    @note It is safe to move the passed string.
    */
    virtual bool key(string_t& val) = 0;

    /*!
    @brief the end of an object was read
    @return whether parsing should proceed
    */
    virtual bool end_object() = 0;

    /*!
    @brief the beginning of an array was read
    @param[in] elements  number of array elements or -1 if unknown
    @return whether parsing should proceed
    @note binary formats may report the number of elements
    */
    virtual bool start_array(std::size_t elements) = 0;

    /*!
    @brief the end of an array was read
    @return whether parsing should proceed
    */
    virtual bool end_array() = 0;

    /*!
    @brief a parse error occurred
    @param[in] position    the position in the input where the error occurs
    @param[in] last_token  the last read token
    @param[in] ex          an exception object describing the error
    @return whether parsing should proceed (must return false)
    */
    virtual bool parse_error(std::size_t position,
                             const std::string& last_token,
                             const detail::exception& ex) = 0;

    virtual ~json_sax() = default;
};


namespace detail
{
/*!
@brief SAX implementation to create a JSON value from SAX events

This class implements the @ref json_sax interface and processes the SAX events
to create a JSON value which makes it basically a DOM parser. The structure or
hierarchy of the JSON value is managed by the stack `ref_stack` which contains
a pointer to the respective array or object for each recursion depth.

After successful parsing, the value that is passed by reference to the
constructor contains the parsed value.

@tparam BasicJsonType  the JSON type
*/
template<typename BasicJsonType>
class json_sax_dom_parser
{
  public:
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;
    using binary_t = typename BasicJsonType::binary_t;

    /*!
    @param[in, out] r  reference to a JSON value that is manipulated while
                       parsing
    @param[in] allow_exceptions_  whether parse errors yield exceptions
    */
    explicit json_sax_dom_parser(BasicJsonType& r, const bool allow_exceptions_ = true)
        : root(r), allow_exceptions(allow_exceptions_)
    {}

    // make class move-only
    json_sax_dom_parser(const json_sax_dom_parser&) = delete;
    json_sax_dom_parser(json_sax_dom_parser&&) = default;
    json_sax_dom_parser& operator=(const json_sax_dom_parser&) = delete;
    json_sax_dom_parser& operator=(json_sax_dom_parser&&) = default;
    ~json_sax_dom_parser() = default;

    bool null()
    {
        handle_value(nullptr);
        return true;
    }

    bool boolean(bool val)
    {
        handle_value(val);
        return true;
    }

    bool number_integer(number_integer_t val)
    {
        handle_value(val);
        return true;
    }

    bool number_unsigned(number_unsigned_t val)
    {
        handle_value(val);
        return true;
    }

    bool number_float(number_float_t val, const string_t& /*unused*/)
    {
        handle_value(val);
        return true;
    }

    bool string(string_t& val)
    {
        handle_value(val);
        return true;
    }

    bool binary(binary_t& val)
    {
        handle_value(std::move(val));
        return true;
    }

    bool start_object(std::size_t len)
    {
        ref_stack.push_back(handle_value(BasicJsonType::value_t::object));

        if (JSON_HEDLEY_UNLIKELY(len != std::size_t(-1) && len > ref_stack.back()->max_size()))
        {
            JSON_THROW(out_of_range::create(408,
                                            "excessive object size: " + std::to_string(len)));
        }

        return true;
    }

    bool key(string_t& val)
    {
        // add null at given key and store the reference for later
        object_element = &(ref_stack.back()->m_value.object->operator[](val));
        return true;
    }

    bool end_object()
    {
        ref_stack.pop_back();
        return true;
    }

    bool start_array(std::size_t len)
    {
        ref_stack.push_back(handle_value(BasicJsonType::value_t::array));

        if (JSON_HEDLEY_UNLIKELY(len != std::size_t(-1) && len > ref_stack.back()->max_size()))
        {
            JSON_THROW(out_of_range::create(408,
                                            "excessive array size: " + std::to_string(len)));
        }

        return true;
    }

    bool end_array()
    {
        ref_stack.pop_back();
        return true;
    }

    template<class Exception>
    bool parse_error(std::size_t /*unused*/, const std::string& /*unused*/,
                     const Exception& ex)
    {
        errored = true;
        static_cast<void>(ex);
        if (allow_exceptions)
        {
            JSON_THROW(ex);
        }
        return false;
    }

    constexpr bool is_errored() const
    {
        return errored;
    }

  private:
    /*!
    @invariant If the ref stack is empty, then the passed value will be the new
               root.
    @invariant If the ref stack contains a value, then it is an array or an
               object to which we can add elements
    */
    template<typename Value>
    JSON_HEDLEY_RETURNS_NON_NULL
    BasicJsonType* handle_value(Value&& v)
    {
        if (ref_stack.empty())
        {
            root = BasicJsonType(std::forward<Value>(v));
            return &root;
        }

        JSON_ASSERT(ref_stack.back()->is_array() || ref_stack.back()->is_object());

        if (ref_stack.back()->is_array())
        {
            ref_stack.back()->m_value.array->emplace_back(std::forward<Value>(v));
            return &(ref_stack.back()->m_value.array->back());
        }

        JSON_ASSERT(ref_stack.back()->is_object());
        JSON_ASSERT(object_element);
        *object_element = BasicJsonType(std::forward<Value>(v));
        return object_element;
    }

    /// the parsed JSON value
    BasicJsonType& root;
    /// stack to model hierarchy of values
    std::vector<BasicJsonType*> ref_stack {};
    /// helper to hold the reference for the next object element
    BasicJsonType* object_element = nullptr;
    /// whether a syntax error occurred
    bool errored = false;
    /// whether to throw exceptions in case of errors
    const bool allow_exceptions = true;
};

template<typename BasicJsonType>
class json_sax_dom_callback_parser
{
  public:
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;
    using binary_t = typename BasicJsonType::binary_t;
    using parser_callback_t = typename BasicJsonType::parser_callback_t;
    using parse_event_t = typename BasicJsonType::parse_event_t;

    json_sax_dom_callback_parser(BasicJsonType& r,
                                 const parser_callback_t cb,
                                 const bool allow_exceptions_ = true)
        : root(r), callback(cb), allow_exceptions(allow_exceptions_)
    {
        keep_stack.push_back(true);
    }

    // make class move-only
    json_sax_dom_callback_parser(const json_sax_dom_callback_parser&) = delete;
    json_sax_dom_callback_parser(json_sax_dom_callback_parser&&) = default;
    json_sax_dom_callback_parser& operator=(const json_sax_dom_callback_parser&) = delete;
    json_sax_dom_callback_parser& operator=(json_sax_dom_callback_parser&&) = default;
    ~json_sax_dom_callback_parser() = default;

    bool null()
    {
        handle_value(nullptr);
        return true;
    }

    bool boolean(bool val)
    {
        handle_value(val);
        return true;
    }

    bool number_integer(number_integer_t val)
    {
        handle_value(val);
        return true;
    }

    bool number_unsigned(number_unsigned_t val)
    {
        handle_value(val);
        return true;
    }

    bool number_float(number_float_t val, const string_t& /*unused*/)
    {
        handle_value(val);
        return true;
    }

    bool string(string_t& val)
    {
        handle_value(val);
        return true;
    }

    bool binary(binary_t& val)
    {
        handle_value(std::move(val));
        return true;
    }

    bool start_object(std::size_t len)
    {
        // check callback for object start
        const bool keep = callback(static_cast<int>(ref_stack.size()), parse_event_t::object_start, discarded);
        keep_stack.push_back(keep);

        auto val = handle_value(BasicJsonType::value_t::object, true);
        ref_stack.push_back(val.second);

        // check object limit
        if (ref_stack.back() && JSON_HEDLEY_UNLIKELY(len != std::size_t(-1) && len > ref_stack.back()->max_size()))
        {
            JSON_THROW(out_of_range::create(408, "excessive object size: " + std::to_string(len)));
        }

        return true;
    }

    bool key(string_t& val)
    {
        BasicJsonType k = BasicJsonType(val);

        // check callback for key
        const bool keep = callback(static_cast<int>(ref_stack.size()), parse_event_t::key, k);
        key_keep_stack.push_back(keep);

        // add discarded value at given key and store the reference for later
        if (keep && ref_stack.back())
        {
            object_element = &(ref_stack.back()->m_value.object->operator[](val) = discarded);
        }

        return true;
    }

    bool end_object()
    {
        if (ref_stack.back() && !callback(static_cast<int>(ref_stack.size()) - 1, parse_event_t::object_end, *ref_stack.back()))
        {
            // discard object
            *ref_stack.back() = discarded;
        }

        JSON_ASSERT(!ref_stack.empty());
        JSON_ASSERT(!keep_stack.empty());
        ref_stack.pop_back();
        keep_stack.pop_back();

        if (!ref_stack.empty() && ref_stack.back() && ref_stack.back()->is_structured())
        {
            // remove discarded value
            for (auto it = ref_stack.back()->begin(); it != ref_stack.back()->end(); ++it)
            {
                if (it->is_discarded())
                {
                    ref_stack.back()->erase(it);
                    break;
                }
            }
        }

        return true;
    }

    bool start_array(std::size_t len)
    {
        const bool keep = callback(static_cast<int>(ref_stack.size()), parse_event_t::array_start, discarded);
        keep_stack.push_back(keep);

        auto val = handle_value(BasicJsonType::value_t::array, true);
        ref_stack.push_back(val.second);

        // check array limit
        if (ref_stack.back() && JSON_HEDLEY_UNLIKELY(len != std::size_t(-1) && len > ref_stack.back()->max_size()))
        {
            JSON_THROW(out_of_range::create(408, "excessive array size: " + std::to_string(len)));
        }

        return true;
    }

    bool end_array()
    {
        bool keep = true;

        if (ref_stack.back())
        {
            keep = callback(static_cast<int>(ref_stack.size()) - 1, parse_event_t::array_end, *ref_stack.back());
            if (!keep)
            {
                // discard array
                *ref_stack.back() = discarded;
            }
        }

        JSON_ASSERT(!ref_stack.empty());
        JSON_ASSERT(!keep_stack.empty());
        ref_stack.pop_back();
        keep_stack.pop_back();

        // remove discarded value
        if (!keep && !ref_stack.empty() && ref_stack.back()->is_array())
        {
            ref_stack.back()->m_value.array->pop_back();
        }

        return true;
    }

    template<class Exception>
    bool parse_error(std::size_t /*unused*/, const std::string& /*unused*/,
                     const Exception& ex)
    {
        errored = true;
        static_cast<void>(ex);
        if (allow_exceptions)
        {
            JSON_THROW(ex);
        }
        return false;
    }

    constexpr bool is_errored() const
    {
        return errored;
    }

  private:
    /*!
    @param[in] v  value to add to the JSON value we build during parsing
    @param[in] skip_callback  whether we should skip calling the callback
               function; this is required after start_array() and
               start_object() SAX events, because otherwise we would call the
               callback function with an empty array or object, respectively.

    @invariant If the ref stack is empty, then the passed value will be the new
               root.
    @invariant If the ref stack contains a value, then it is an array or an
               object to which we can add elements

    @return pair of boolean (whether value should be kept) and pointer (to the
            passed value in the ref_stack hierarchy; nullptr if not kept)
    */
    template<typename Value>
    std::pair<bool, BasicJsonType*> handle_value(Value&& v, const bool skip_callback = false)
    {
        JSON_ASSERT(!keep_stack.empty());

        // do not handle this value if we know it would be added to a discarded
        // container
        if (!keep_stack.back())
        {
            return {false, nullptr};
        }

        // create value
        auto value = BasicJsonType(std::forward<Value>(v));

        // check callback
        const bool keep = skip_callback || callback(static_cast<int>(ref_stack.size()), parse_event_t::value, value);

        // do not handle this value if we just learnt it shall be discarded
        if (!keep)
        {
            return {false, nullptr};
        }

        if (ref_stack.empty())
        {
            root = std::move(value);
            return {true, &root};
        }

        // skip this value if we already decided to skip the parent
        // (https://github.com/nlohmann/json/issues/971#issuecomment-413678360)
        if (!ref_stack.back())
        {
            return {false, nullptr};
        }

        // we now only expect arrays and objects
        JSON_ASSERT(ref_stack.back()->is_array() || ref_stack.back()->is_object());

        // array
        if (ref_stack.back()->is_array())
        {
            ref_stack.back()->m_value.array->push_back(std::move(value));
            return {true, &(ref_stack.back()->m_value.array->back())};
        }

        // object
        JSON_ASSERT(ref_stack.back()->is_object());
        // check if we should store an element for the current key
        JSON_ASSERT(!key_keep_stack.empty());
        const bool store_element = key_keep_stack.back();
        key_keep_stack.pop_back();

        if (!store_element)
        {
            return {false, nullptr};
        }

        JSON_ASSERT(object_element);
        *object_element = std::move(value);
        return {true, object_element};
    }

    /// the parsed JSON value
    BasicJsonType& root;
    /// stack to model hierarchy of values
    std::vector<BasicJsonType*> ref_stack {};
    /// stack to manage which values to keep
    std::vector<bool> keep_stack {};
    /// stack to manage which object keys to keep
    std::vector<bool> key_keep_stack {};
    /// helper to hold the reference for the next object element
    BasicJsonType* object_element = nullptr;
    /// whether a syntax error occurred
    bool errored = false;
    /// callback function
    const parser_callback_t callback = nullptr;
    /// whether to throw exceptions in case of errors
    const bool allow_exceptions = true;
    /// a discarded value for the callback
    BasicJsonType discarded = BasicJsonType::value_t::discarded;
};

template<typename BasicJsonType>
class json_sax_acceptor
{
  public:
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;
    using binary_t = typename BasicJsonType::binary_t;

    bool null()
    {
        return true;
    }

    bool boolean(bool /*unused*/)
    {
        return true;
    }

    bool number_integer(number_integer_t /*unused*/)
    {
        return true;
    }

    bool number_unsigned(number_unsigned_t /*unused*/)
    {
        return true;
    }

    bool number_float(number_float_t /*unused*/, const string_t& /*unused*/)
    {
        return true;
    }

    bool string(string_t& /*unused*/)
    {
        return true;
    }

    bool binary(binary_t& /*unused*/)
    {
        return true;
    }

    bool start_object(std::size_t /*unused*/ = std::size_t(-1))
    {
        return true;
    }

    bool key(string_t& /*unused*/)
    {
        return true;
    }

    bool end_object()
    {
        return true;
    }

    bool start_array(std::size_t /*unused*/ = std::size_t(-1))
    {
        return true;
    }

    bool end_array()
    {
        return true;
    }

    bool parse_error(std::size_t /*unused*/, const std::string& /*unused*/, const detail::exception& /*unused*/)
    {
        return false;
    }
};
}  // namespace detail

}  // namespace nlohmann

// #include <nlohmann/detail/input/lexer.hpp>


#include <array> // array
#include <clocale> // localeconv
#include <cstddef> // size_t
#include <cstdio> // snprintf
#include <cstdlib> // strtof, strtod, strtold, strtoll, strtoull
#include <initializer_list> // initializer_list
#include <string> // char_traits, string
#include <utility> // move
#include <vector> // vector

// #include <nlohmann/detail/input/input_adapters.hpp>

// #include <nlohmann/detail/input/position_t.hpp>

// #include <nlohmann/detail/macro_scope.hpp>


namespace nlohmann
{
namespace detail
{
///////////
// lexer //
///////////

template<typename BasicJsonType>
class lexer_base
{
  public:
    /// token types for the parser
    enum class token_type
    {
        uninitialized,    ///< indicating the scanner is uninitialized
        literal_true,     ///< the `true` literal
        literal_false,    ///< the `false` literal
        literal_null,     ///< the `null` literal
        value_string,     ///< a string -- use get_string() for actual value
        value_unsigned,   ///< an unsigned integer -- use get_number_unsigned() for actual value
        value_integer,    ///< a signed integer -- use get_number_integer() for actual value
        value_float,      ///< an floating point number -- use get_number_float() for actual value
        begin_array,      ///< the character for array begin `[`
        begin_object,     ///< the character for object begin `{`
        end_array,        ///< the character for array end `]`
        end_object,       ///< the character for object end `}`
        name_separator,   ///< the name separator `:`
        value_separator,  ///< the value separator `,`
        parse_error,      ///< indicating a parse error
        end_of_input,     ///< indicating the end of the input buffer
        literal_or_value  ///< a literal or the begin of a value (only for diagnostics)
    };

    /// return name of values of type token_type (only used for errors)
    JSON_HEDLEY_RETURNS_NON_NULL
    JSON_HEDLEY_CONST
    static const char* token_type_name(const token_type t) noexcept
    {
        switch (t)
        {
            case token_type::uninitialized:
                return "<uninitialized>";
            case token_type::literal_true:
                return "true literal";
            case token_type::literal_false:
                return "false literal";
            case token_type::literal_null:
                return "null literal";
            case token_type::value_string:
                return "string literal";
            case token_type::value_unsigned:
            case token_type::value_integer:
            case token_type::value_float:
                return "number literal";
            case token_type::begin_array:
                return "'['";
            case token_type::begin_object:
                return "'{'";
            case token_type::end_array:
                return "']'";
            case token_type::end_object:
                return "'}'";
            case token_type::name_separator:
                return "':'";
            case token_type::value_separator:
                return "','";
            case token_type::parse_error:
                return "<parse error>";
            case token_type::end_of_input:
                return "end of input";
            case token_type::literal_or_value:
                return "'[', '{', or a literal";
            // LCOV_EXCL_START
            default: // catch non-enum values
                return "unknown token";
                // LCOV_EXCL_STOP
        }
    }
};
/*!
@brief lexical analysis

This class organizes the lexical analysis during JSON deserialization.
*/
template<typename BasicJsonType, typename InputAdapterType>
class lexer : public lexer_base<BasicJsonType>
{
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;
    using char_type = typename InputAdapterType::char_type;
    using char_int_type = typename std::char_traits<char_type>::int_type;

  public:
    using token_type = typename lexer_base<BasicJsonType>::token_type;

    explicit lexer(InputAdapterType&& adapter, bool ignore_comments_ = false)
        : ia(std::move(adapter))
        , ignore_comments(ignore_comments_)
        , decimal_point_char(static_cast<char_int_type>(get_decimal_point()))
    {}

    // delete because of pointer members
    lexer(const lexer&) = delete;
    lexer(lexer&&) = default;
    lexer& operator=(lexer&) = delete;
    lexer& operator=(lexer&&) = default;
    ~lexer() = default;

  private:
    /////////////////////
    // locales
    /////////////////////

    /// return the locale-dependent decimal point
    JSON_HEDLEY_PURE
    static char get_decimal_point() noexcept
    {
        const auto* loc = localeconv();
        JSON_ASSERT(loc != nullptr);
        return (loc->decimal_point == nullptr) ? '.' : *(loc->decimal_point);
    }

    /////////////////////
    // scan functions
    /////////////////////

    /*!
    @brief get codepoint from 4 hex characters following `\u`

    For input "\u c1 c2 c3 c4" the codepoint is:
      (c1 * 0x1000) + (c2 * 0x0100) + (c3 * 0x0010) + c4
    = (c1 << 12) + (c2 << 8) + (c3 << 4) + (c4 << 0)

    Furthermore, the possible characters '0'..'9', 'A'..'F', and 'a'..'f'
    must be converted to the integers 0x0..0x9, 0xA..0xF, 0xA..0xF, resp. The
    conversion is done by subtracting the offset (0x30, 0x37, and 0x57)
    between the ASCII value of the character and the desired integer value.

    @return codepoint (0x0000..0xFFFF) or -1 in case of an error (e.g. EOF or
            non-hex character)
    */
    int get_codepoint()
    {
        // this function only makes sense after reading `\u`
        JSON_ASSERT(current == 'u');
        int codepoint = 0;

        const auto factors = { 12u, 8u, 4u, 0u };
        for (const auto factor : factors)
        {
            get();

            if (current >= '0' && current <= '9')
            {
                codepoint += static_cast<int>((static_cast<unsigned int>(current) - 0x30u) << factor);
            }
            else if (current >= 'A' && current <= 'F')
            {
                codepoint += static_cast<int>((static_cast<unsigned int>(current) - 0x37u) << factor);
            }
            else if (current >= 'a' && current <= 'f')
            {
                codepoint += static_cast<int>((static_cast<unsigned int>(current) - 0x57u) << factor);
            }
            else
            {
                return -1;
            }
        }

        JSON_ASSERT(0x0000 <= codepoint && codepoint <= 0xFFFF);
        return codepoint;
    }

    /*!
    @brief check if the next byte(s) are inside a given range

    Adds the current byte and, for each passed range, reads a new byte and
    checks if it is inside the range. If a violation was detected, set up an
    error message and return false. Otherwise, return true.

    @param[in] ranges  list of integers; interpreted as list of pairs of
                       inclusive lower and upper bound, respectively

    @pre The passed list @a ranges must have 2, 4, or 6 elements; that is,
         1, 2, or 3 pairs. This precondition is enforced by an assertion.

    @return true if and only if no range violation was detected
    */
    bool next_byte_in_range(std::initializer_list<char_int_type> ranges)
    {
        JSON_ASSERT(ranges.size() == 2 || ranges.size() == 4 || ranges.size() == 6);
        add(current);

        for (auto range = ranges.begin(); range != ranges.end(); ++range)
        {
            get();
            if (JSON_HEDLEY_LIKELY(*range <= current && current <= *(++range)))
            {
                add(current);
            }
            else
            {
                error_message = "invalid string: ill-formed UTF-8 byte";
                return false;
            }
        }

        return true;
    }

    /*!
    @brief scan a string literal

    This function scans a string according to Sect. 7 of RFC 7159. While
    scanning, bytes are escaped and copied into buffer token_buffer. Then the
    function returns successfully, token_buffer is *not* null-terminated (as it
    may contain \0 bytes), and token_buffer.size() is the number of bytes in the
    string.

    @return token_type::value_string if string could be successfully scanned,
            token_type::parse_error otherwise

    @note In case of errors, variable error_message contains a textual
          description.
    */
    token_type scan_string()
    {
        // reset token_buffer (ignore opening quote)
        reset();

        // we entered the function by reading an open quote
        JSON_ASSERT(current == '\"');

        while (true)
        {
            // get next character
            switch (get())
            {
                // end of file while parsing string
                case std::char_traits<char_type>::eof():
                {
                    error_message = "invalid string: missing closing quote";
                    return token_type::parse_error;
                }

                // closing quote
                case '\"':
                {
                    return token_type::value_string;
                }

                // escapes
                case '\\':
                {
                    switch (get())
                    {
                        // quotation mark
                        case '\"':
                            add('\"');
                            break;
                        // reverse solidus
                        case '\\':
                            add('\\');
                            break;
                        // solidus
                        case '/':
                            add('/');
                            break;
                        // backspace
                        case 'b':
                            add('\b');
                            break;
                        // form feed
                        case 'f':
                            add('\f');
                            break;
                        // line feed
                        case 'n':
                            add('\n');
                            break;
                        // carriage return
                        case 'r':
                            add('\r');
                            break;
                        // tab
                        case 't':
                            add('\t');
                            break;

                        // unicode escapes
                        case 'u':
                        {
                            const int codepoint1 = get_codepoint();
                            int codepoint = codepoint1; // start with codepoint1

                            if (JSON_HEDLEY_UNLIKELY(codepoint1 == -1))
                            {
                                error_message = "invalid string: '\\u' must be followed by 4 hex digits";
                                return token_type::parse_error;
                            }

                            // check if code point is a high surrogate
                            if (0xD800 <= codepoint1 && codepoint1 <= 0xDBFF)
                            {
                                // expect next \uxxxx entry
                                if (JSON_HEDLEY_LIKELY(get() == '\\' && get() == 'u'))
                                {
                                    const int codepoint2 = get_codepoint();

                                    if (JSON_HEDLEY_UNLIKELY(codepoint2 == -1))
                                    {
                                        error_message = "invalid string: '\\u' must be followed by 4 hex digits";
                                        return token_type::parse_error;
                                    }

                                    // check if codepoint2 is a low surrogate
                                    if (JSON_HEDLEY_LIKELY(0xDC00 <= codepoint2 && codepoint2 <= 0xDFFF))
                                    {
                                        // overwrite codepoint
                                        codepoint = static_cast<int>(
                                                        // high surrogate occupies the most significant 22 bits
                                                        (static_cast<unsigned int>(codepoint1) << 10u)
                                                        // low surrogate occupies the least significant 15 bits
                                                        + static_cast<unsigned int>(codepoint2)
                                                        // there is still the 0xD800, 0xDC00 and 0x10000 noise
                                                        // in the result so we have to subtract with:
                                                        // (0xD800 << 10) + DC00 - 0x10000 = 0x35FDC00
                                                        - 0x35FDC00u);
                                    }
                                    else
                                    {
                                        error_message = "invalid string: surrogate U+D800..U+DBFF must be followed by U+DC00..U+DFFF";
                                        return token_type::parse_error;
                                    }
                                }
                                else
                                {
                                    error_message = "invalid string: surrogate U+D800..U+DBFF must be followed by U+DC00..U+DFFF";
                                    return token_type::parse_error;
                                }
                            }
                            else
                            {
                                if (JSON_HEDLEY_UNLIKELY(0xDC00 <= codepoint1 && codepoint1 <= 0xDFFF))
                                {
                                    error_message = "invalid string: surrogate U+DC00..U+DFFF must follow U+D800..U+DBFF";
                                    return token_type::parse_error;
                                }
                            }

                            // result of the above calculation yields a proper codepoint
                            JSON_ASSERT(0x00 <= codepoint && codepoint <= 0x10FFFF);

                            // translate codepoint into bytes
                            if (codepoint < 0x80)
                            {
                                // 1-byte characters: 0xxxxxxx (ASCII)
                                add(static_cast<char_int_type>(codepoint));
                            }
                            else if (codepoint <= 0x7FF)
                            {
                                // 2-byte characters: 110xxxxx 10xxxxxx
                                add(static_cast<char_int_type>(0xC0u | (static_cast<unsigned int>(codepoint) >> 6u)));
                                add(static_cast<char_int_type>(0x80u | (static_cast<unsigned int>(codepoint) & 0x3Fu)));
                            }
                            else if (codepoint <= 0xFFFF)
                            {
                                // 3-byte characters: 1110xxxx 10xxxxxx 10xxxxxx
                                add(static_cast<char_int_type>(0xE0u | (static_cast<unsigned int>(codepoint) >> 12u)));
                                add(static_cast<char_int_type>(0x80u | ((static_cast<unsigned int>(codepoint) >> 6u) & 0x3Fu)));
                                add(static_cast<char_int_type>(0x80u | (static_cast<unsigned int>(codepoint) & 0x3Fu)));
                            }
                            else
                            {
                                // 4-byte characters: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
                                add(static_cast<char_int_type>(0xF0u | (static_cast<unsigned int>(codepoint) >> 18u)));
                                add(static_cast<char_int_type>(0x80u | ((static_cast<unsigned int>(codepoint) >> 12u) & 0x3Fu)));
                                add(static_cast<char_int_type>(0x80u | ((static_cast<unsigned int>(codepoint) >> 6u) & 0x3Fu)));
                                add(static_cast<char_int_type>(0x80u | (static_cast<unsigned int>(codepoint) & 0x3Fu)));
                            }

                            break;
                        }

                        // other characters after escape
                        default:
                            error_message = "invalid string: forbidden character after backslash";
                            return token_type::parse_error;
                    }

                    break;
                }

                // invalid control characters
                case 0x00:
                {
                    error_message = "invalid string: control character U+0000 (NUL) must be escaped to \\u0000";
                    return token_type::parse_error;
                }

                case 0x01:
                {
                    error_message = "invalid string: control character U+0001 (SOH) must be escaped to \\u0001";
                    return token_type::parse_error;
                }

                case 0x02:
                {
                    error_message = "invalid string: control character U+0002 (STX) must be escaped to \\u0002";
                    return token_type::parse_error;
                }

                case 0x03:
                {
                    error_message = "invalid string: control character U+0003 (ETX) must be escaped to \\u0003";
                    return token_type::parse_error;
                }

                case 0x04:
                {
                    error_message = "invalid string: control character U+0004 (EOT) must be escaped to \\u0004";
                    return token_type::parse_error;
                }

                case 0x05:
                {
                    error_message = "invalid string: control character U+0005 (ENQ) must be escaped to \\u0005";
                    return token_type::parse_error;
                }

                case 0x06:
                {
                    error_message = "invalid string: control character U+0006 (ACK) must be escaped to \\u0006";
                    return token_type::parse_error;
                }

                case 0x07:
                {
                    error_message = "invalid string: control character U+0007 (BEL) must be escaped to \\u0007";
                    return token_type::parse_error;
                }

                case 0x08:
                {
                    error_message = "invalid string: control character U+0008 (BS) must be escaped to \\u0008 or \\b";
                    return token_type::parse_error;
                }

                case 0x09:
                {
                    error_message = "invalid string: control character U+0009 (HT) must be escaped to \\u0009 or \\t";
                    return token_type::parse_error;
                }

                case 0x0A:
                {
                    error_message = "invalid string: control character U+000A (LF) must be escaped to \\u000A or \\n";
                    return token_type::parse_error;
                }

                case 0x0B:
                {
                    error_message = "invalid string: control character U+000B (VT) must be escaped to \\u000B";
                    return token_type::parse_error;
                }

                case 0x0C:
                {
                    error_message = "invalid string: control character U+000C (FF) must be escaped to \\u000C or \\f";
                    return token_type::parse_error;
                }

                case 0x0D:
                {
                    error_message = "invalid string: control character U+000D (CR) must be escaped to \\u000D or \\r";
                    return token_type::parse_error;
                }

                case 0x0E:
                {
                    error_message = "invalid string: control character U+000E (SO) must be escaped to \\u000E";
                    return token_type::parse_error;
                }

                case 0x0F:
                {
                    error_message = "invalid string: control character U+000F (SI) must be escaped to \\u000F";
                    return token_type::parse_error;
                }

                case 0x10:
                {
                    error_message = "invalid string: control character U+0010 (DLE) must be escaped to \\u0010";
                    return token_type::parse_error;
                }

                case 0x11:
                {
                    error_message = "invalid string: control character U+0011 (DC1) must be escaped to \\u0011";
                    return token_type::parse_error;
                }

                case 0x12:
                {
                    error_message = "invalid string: control character U+0012 (DC2) must be escaped to \\u0012";
                    return token_type::parse_error;
                }

                case 0x13:
                {
                    error_message = "invalid string: control character U+0013 (DC3) must be escaped to \\u0013";
                    return token_type::parse_error;
                }

                case 0x14:
                {
                    error_message = "invalid string: control character U+0014 (DC4) must be escaped to \\u0014";
                    return token_type::parse_error;
                }

                case 0x15:
                {
                    error_message = "invalid string: control character U+0015 (NAK) must be escaped to \\u0015";
                    return token_type::parse_error;
                }

                case 0x16:
                {
                    error_message = "invalid string: control character U+0016 (SYN) must be escaped to \\u0016";
                    return token_type::parse_error;
                }

                case 0x17:
                {
                    error_message = "invalid string: control character U+0017 (ETB) must be escaped to \\u0017";
                    return token_type::parse_error;
                }

                case 0x18:
                {
                    error_message = "invalid string: control character U+0018 (CAN) must be escaped to \\u0018";
                    return token_type::parse_error;
                }

                case 0x19:
                {
                    error_message = "invalid string: control character U+0019 (EM) must be escaped to \\u0019";
                    return token_type::parse_error;
                }

                case 0x1A:
                {
                    error_message = "invalid string: control character U+001A (SUB) must be escaped to \\u001A";
                    return token_type::parse_error;
                }

                case 0x1B:
                {
                    error_message = "invalid string: control character U+001B (ESC) must be escaped to \\u001B";
                    return token_type::parse_error;
                }

                case 0x1C:
                {
                    error_message = "invalid string: control character U+001C (FS) must be escaped to \\u001C";
                    return token_type::parse_error;
                }

                case 0x1D:
                {
                    error_message = "invalid string: control character U+001D (GS) must be escaped to \\u001D";
                    return token_type::parse_error;
                }

                case 0x1E:
                {
                    error_message = "invalid string: control character U+001E (RS) must be escaped to \\u001E";
                    return token_type::parse_error;
                }

                case 0x1F:
                {
                    error_message = "invalid string: control character U+001F (US) must be escaped to \\u001F";
                    return token_type::parse_error;
                }

                // U+0020..U+007F (except U+0022 (quote) and U+005C (backspace))
                case 0x20:
                case 0x21:
                case 0x23:
                case 0x24:
                case 0x25:
                case 0x26:
                case 0x27:
                case 0x28:
                case 0x29:
                case 0x2A:
                case 0x2B:
                case 0x2C:
                case 0x2D:
                case 0x2E:
                case 0x2F:
                case 0x30:
                case 0x31:
                case 0x32:
                case 0x33:
                case 0x34:
                case 0x35:
                case 0x36:
                case 0x37:
                case 0x38:
                case 0x39:
                case 0x3A:
                case 0x3B:
                case 0x3C:
                case 0x3D:
                case 0x3E:
                case 0x3F:
                case 0x40:
                case 0x41:
                case 0x42:
                case 0x43:
                case 0x44:
                case 0x45:
                case 0x46:
                case 0x47:
                case 0x48:
                case 0x49:
                case 0x4A:
                case 0x4B:
                case 0x4C:
                case 0x4D:
                case 0x4E:
                case 0x4F:
                case 0x50:
                case 0x51:
                case 0x52:
                case 0x53:
                case 0x54:
                case 0x55:
                case 0x56:
                case 0x57:
                case 0x58:
                case 0x59:
                case 0x5A:
                case 0x5B:
                case 0x5D:
                case 0x5E:
                case 0x5F:
                case 0x60:
                case 0x61:
                case 0x62:
                case 0x63:
                case 0x64:
                case 0x65:
                case 0x66:
                case 0x67:
                case 0x68:
                case 0x69:
                case 0x6A:
                case 0x6B:
                case 0x6C:
                case 0x6D:
                case 0x6E:
                case 0x6F:
                case 0x70:
                case 0x71:
                case 0x72:
                case 0x73:
                case 0x74:
                case 0x75:
                case 0x76:
                case 0x77:
                case 0x78:
                case 0x79:
                case 0x7A:
                case 0x7B:
                case 0x7C:
                case 0x7D:
                case 0x7E:
                case 0x7F:
                {
                    add(current);
                    break;
                }

                // U+0080..U+07FF: bytes C2..DF 80..BF
                case 0xC2:
                case 0xC3:
                case 0xC4:
                case 0xC5:
                case 0xC6:
                case 0xC7:
                case 0xC8:
                case 0xC9:
                case 0xCA:
                case 0xCB:
                case 0xCC:
                case 0xCD:
                case 0xCE:
                case 0xCF:
                case 0xD0:
                case 0xD1:
                case 0xD2:
                case 0xD3:
                case 0xD4:
                case 0xD5:
                case 0xD6:
                case 0xD7:
                case 0xD8:
                case 0xD9:
                case 0xDA:
                case 0xDB:
                case 0xDC:
                case 0xDD:
                case 0xDE:
                case 0xDF:
                {
                    if (JSON_HEDLEY_UNLIKELY(!next_byte_in_range({0x80, 0xBF})))
                    {
                        return token_type::parse_error;
                    }
                    break;
                }

                // U+0800..U+0FFF: bytes E0 A0..BF 80..BF
                case 0xE0:
                {
                    if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0xA0, 0xBF, 0x80, 0xBF}))))
                    {
                        return token_type::parse_error;
                    }
                    break;
                }

                // U+1000..U+CFFF: bytes E1..EC 80..BF 80..BF
                // U+E000..U+FFFF: bytes EE..EF 80..BF 80..BF
                case 0xE1:
                case 0xE2:
                case 0xE3:
                case 0xE4:
                case 0xE5:
                case 0xE6:
                case 0xE7:
                case 0xE8:
                case 0xE9:
                case 0xEA:
                case 0xEB:
                case 0xEC:
                case 0xEE:
                case 0xEF:
                {
                    if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0x80, 0xBF, 0x80, 0xBF}))))
                    {
                        return token_type::parse_error;
                    }
                    break;
                }

                // U+D000..U+D7FF: bytes ED 80..9F 80..BF
                case 0xED:
                {
                    if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0x80, 0x9F, 0x80, 0xBF}))))
                    {
                        return token_type::parse_error;
                    }
                    break;
                }

                // U+10000..U+3FFFF F0 90..BF 80..BF 80..BF
                case 0xF0:
                {
                    if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0x90, 0xBF, 0x80, 0xBF, 0x80, 0xBF}))))
                    {
                        return token_type::parse_error;
                    }
                    break;
                }

                // U+40000..U+FFFFF F1..F3 80..BF 80..BF 80..BF
                case 0xF1:
                case 0xF2:
                case 0xF3:
                {
                    if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0x80, 0xBF, 0x80, 0xBF, 0x80, 0xBF}))))
                    {
                        return token_type::parse_error;
                    }
                    break;
                }

                // U+100000..U+10FFFF F4 80..8F 80..BF 80..BF
                case 0xF4:
                {
                    if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0x80, 0x8F, 0x80, 0xBF, 0x80, 0xBF}))))
                    {
                        return token_type::parse_error;
                    }
                    break;
                }

                // remaining bytes (80..C1 and F5..FF) are ill-formed
                default:
                {
                    error_message = "invalid string: ill-formed UTF-8 byte";
                    return token_type::parse_error;
                }
            }
        }
    }

    /*!
     * @brief scan a comment
     * @return whether comment could be scanned successfully
     */
    bool scan_comment()
    {
        switch (get())
        {
            // single-line comments skip input until a newline or EOF is read
            case '/':
            {
                while (true)
                {
                    switch (get())
                    {
                        case '\n':
                        case '\r':
                        case std::char_traits<char_type>::eof():
                        case '\0':
                            return true;

                        default:
                            break;
                    }
                }
            }

            // multi-line comments skip input until */ is read
            case '*':
            {
                while (true)
                {
                    switch (get())
                    {
                        case std::char_traits<char_type>::eof():
                        case '\0':
                        {
                            error_message = "invalid comment; missing closing '*/'";
                            return false;
                        }

                        case '*':
                        {
                            switch (get())
                            {
                                case '/':
                                    return true;

                                default:
                                {
                                    unget();
                                    continue;
                                }
                            }
                        }

                        default:
                            continue;
                    }
                }
            }

            // unexpected character after reading '/'
            default:
            {
                error_message = "invalid comment; expecting '/' or '*' after '/'";
                return false;
            }
        }
    }

    JSON_HEDLEY_NON_NULL(2)
    static void strtof(float& f, const char* str, char** endptr) noexcept
    {
        f = std::strtof(str, endptr);
    }

    JSON_HEDLEY_NON_NULL(2)
    static void strtof(double& f, const char* str, char** endptr) noexcept
    {
        f = std::strtod(str, endptr);
    }

    JSON_HEDLEY_NON_NULL(2)
    static void strtof(long double& f, const char* str, char** endptr) noexcept
    {
        f = std::strtold(str, endptr);
    }

    /*!
    @brief scan a number literal

    This function scans a string according to Sect. 6 of RFC 7159.

    The function is realized with a deterministic finite state machine derived
    from the grammar described in RFC 7159. Starting in state "init", the
    input is read and used to determined the next state. Only state "done"
    accepts the number. State "error" is a trap state to model errors. In the
    table below, "anything" means any character but the ones listed before.

    state    | 0        | 1-9      | e E      | +       | -       | .        | anything
    ---------|----------|----------|----------|---------|---------|----------|-----------
    init     | zero     | any1     | [error]  | [error] | minus   | [error]  | [error]
    minus    | zero     | any1     | [error]  | [error] | [error] | [error]  | [error]
    zero     | done     | done     | exponent | done    | done    | decimal1 | done
    any1     | any1     | any1     | exponent | done    | done    | decimal1 | done
    decimal1 | decimal2 | decimal2 | [error]  | [error] | [error] | [error]  | [error]
    decimal2 | decimal2 | decimal2 | exponent | done    | done    | done     | done
    exponent | any2     | any2     | [error]  | sign    | sign    | [error]  | [error]
    sign     | any2     | any2     | [error]  | [error] | [error] | [error]  | [error]
    any2     | any2     | any2     | done     | done    | done    | done     | done

    The state machine is realized with one label per state (prefixed with
    "scan_number_") and `goto` statements between them. The state machine
    contains cycles, but any cycle can be left when EOF is read. Therefore,
    the function is guaranteed to terminate.

    During scanning, the read bytes are stored in token_buffer. This string is
    then converted to a signed integer, an unsigned integer, or a
    floating-point number.

    @return token_type::value_unsigned, token_type::value_integer, or
            token_type::value_float if number could be successfully scanned,
            token_type::parse_error otherwise

    @note The scanner is independent of the current locale. Internally, the
          locale's decimal point is used instead of `.` to work with the
          locale-dependent converters.
    */
    token_type scan_number()  // lgtm [cpp/use-of-goto]
    {
        // reset token_buffer to store the number's bytes
        reset();

        // the type of the parsed number; initially set to unsigned; will be
        // changed if minus sign, decimal point or exponent is read
        token_type number_type = token_type::value_unsigned;

        // state (init): we just found out we need to scan a number
        switch (current)
        {
            case '-':
            {
                add(current);
                goto scan_number_minus;
            }

            case '0':
            {
                add(current);
                goto scan_number_zero;
            }

            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_any1;
            }

            // all other characters are rejected outside scan_number()
            default:            // LCOV_EXCL_LINE
                JSON_ASSERT(false);  // LCOV_EXCL_LINE
        }

scan_number_minus:
        // state: we just parsed a leading minus sign
        number_type = token_type::value_integer;
        switch (get())
        {
            case '0':
            {
                add(current);
                goto scan_number_zero;
            }

            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_any1;
            }

            default:
            {
                error_message = "invalid number; expected digit after '-'";
                return token_type::parse_error;
            }
        }

scan_number_zero:
        // state: we just parse a zero (maybe with a leading minus sign)
        switch (get())
        {
            case '.':
            {
                add(decimal_point_char);
                goto scan_number_decimal1;
            }

            case 'e':
            case 'E':
            {
                add(current);
                goto scan_number_exponent;
            }

            default:
                goto scan_number_done;
        }

scan_number_any1:
        // state: we just parsed a number 0-9 (maybe with a leading minus sign)
        switch (get())
        {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_any1;
            }

            case '.':
            {
                add(decimal_point_char);
                goto scan_number_decimal1;
            }

            case 'e':
            case 'E':
            {
                add(current);
                goto scan_number_exponent;
            }

            default:
                goto scan_number_done;
        }

scan_number_decimal1:
        // state: we just parsed a decimal point
        number_type = token_type::value_float;
        switch (get())
        {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_decimal2;
            }

            default:
            {
                error_message = "invalid number; expected digit after '.'";
                return token_type::parse_error;
            }
        }

scan_number_decimal2:
        // we just parsed at least one number after a decimal point
        switch (get())
        {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_decimal2;
            }

            case 'e':
            case 'E':
            {
                add(current);
                goto scan_number_exponent;
            }

            default:
                goto scan_number_done;
        }

scan_number_exponent:
        // we just parsed an exponent
        number_type = token_type::value_float;
        switch (get())
        {
            case '+':
            case '-':
            {
                add(current);
                goto scan_number_sign;
            }

            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_any2;
            }

            default:
            {
                error_message =
                    "invalid number; expected '+', '-', or digit after exponent";
                return token_type::parse_error;
            }
        }

scan_number_sign:
        // we just parsed an exponent sign
        switch (get())
        {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_any2;
            }

            default:
            {
                error_message = "invalid number; expected digit after exponent sign";
                return token_type::parse_error;
            }
        }

scan_number_any2:
        // we just parsed a number after the exponent or exponent sign
        switch (get())
        {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_any2;
            }

            default:
                goto scan_number_done;
        }

scan_number_done:
        // unget the character after the number (we only read it to know that
        // we are done scanning a number)
        unget();

        char* endptr = nullptr;
        errno = 0;

        // try to parse integers first and fall back to floats
        if (number_type == token_type::value_unsigned)
        {
#if defined(_MSC_VER)
            const auto x = strtoull(token_buffer.data(), &endptr, 10);
#else
            const auto x = std::strtoull(token_buffer.data(), &endptr, 10);
#endif
            // we checked the number format before
            JSON_ASSERT(endptr == token_buffer.data() + token_buffer.size());

            if (errno == 0)
            {
                value_unsigned = static_cast<number_unsigned_t>(x);
                if (value_unsigned == x)
                {
                    return token_type::value_unsigned;
                }
            }
        }
        else if (number_type == token_type::value_integer)
        {
#if defined(_MSC_VER)
            const auto x = strtoll(token_buffer.data(), &endptr, 10);
#else
            const auto x = std::strtoll(token_buffer.data(), &endptr, 10);
#endif
            // we checked the number format before
            JSON_ASSERT(endptr == token_buffer.data() + token_buffer.size());

            if (errno == 0)
            {
                value_integer = static_cast<number_integer_t>(x);
                if (value_integer == x)
                {
                    return token_type::value_integer;
                }
            }
        }

        // this code is reached if we parse a floating-point number or if an
        // integer conversion above failed
        strtof(value_float, token_buffer.data(), &endptr);

        // we checked the number format before
        JSON_ASSERT(endptr == token_buffer.data() + token_buffer.size());

        return token_type::value_float;
    }

    /*!
    @param[in] literal_text  the literal text to expect
    @param[in] length        the length of the passed literal text
    @param[in] return_type   the token type to return on success
    */
    JSON_HEDLEY_NON_NULL(2)
    token_type scan_literal(const char_type* literal_text, const std::size_t length,
                            token_type return_type)
    {
        JSON_ASSERT(std::char_traits<char_type>::to_char_type(current) == literal_text[0]);
        for (std::size_t i = 1; i < length; ++i)
        {
            if (JSON_HEDLEY_UNLIKELY(std::char_traits<char_type>::to_char_type(get()) != literal_text[i]))
            {
                error_message = "invalid literal";
                return token_type::parse_error;
            }
        }
        return return_type;
    }

    /////////////////////
    // input management
    /////////////////////

    /// reset token_buffer; current character is beginning of token
    void reset() noexcept
    {
        token_buffer.clear();
        token_string.clear();
        token_string.push_back(std::char_traits<char_type>::to_char_type(current));
    }

    /*
    @brief get next character from the input

    This function provides the interface to the used input adapter. It does
    not throw in case the input reached EOF, but returns a
    `std::char_traits<char>::eof()` in that case.  Stores the scanned characters
    for use in error messages.

    @return character read from the input
    */
    char_int_type get()
    {
        ++position.chars_read_total;
        ++position.chars_read_current_line;

        if (next_unget)
        {
            // just reset the next_unget variable and work with current
            next_unget = false;
        }
        else
        {
            current = ia.get_character();
        }

        if (JSON_HEDLEY_LIKELY(current != std::char_traits<char_type>::eof()))
        {
            token_string.push_back(std::char_traits<char_type>::to_char_type(current));
        }

        if (current == '\n')
        {
            ++position.lines_read;
            position.chars_read_current_line = 0;
        }

        return current;
    }

    /*!
    @brief unget current character (read it again on next get)

    We implement unget by setting variable next_unget to true. The input is not
    changed - we just simulate ungetting by modifying chars_read_total,
    chars_read_current_line, and token_string. The next call to get() will
    behave as if the unget character is read again.
    */
    void unget()
    {
        next_unget = true;

        --position.chars_read_total;

        // in case we "unget" a newline, we have to also decrement the lines_read
        if (position.chars_read_current_line == 0)
        {
            if (position.lines_read > 0)
            {
                --position.lines_read;
            }
        }
        else
        {
            --position.chars_read_current_line;
        }

        if (JSON_HEDLEY_LIKELY(current != std::char_traits<char_type>::eof()))
        {
            JSON_ASSERT(!token_string.empty());
            token_string.pop_back();
        }
    }

    /// add a character to token_buffer
    void add(char_int_type c)
    {
        token_buffer.push_back(static_cast<typename string_t::value_type>(c));
    }

  public:
    /////////////////////
    // value getters
    /////////////////////

    /// return integer value
    constexpr number_integer_t get_number_integer() const noexcept
    {
        return value_integer;
    }

    /// return unsigned integer value
    constexpr number_unsigned_t get_number_unsigned() const noexcept
    {
        return value_unsigned;
    }

    /// return floating-point value
    constexpr number_float_t get_number_float() const noexcept
    {
        return value_float;
    }

    /// return current string value (implicitly resets the token; useful only once)
    string_t& get_string()
    {
        return token_buffer;
    }

    /////////////////////
    // diagnostics
    /////////////////////

    /// return position of last read token
    constexpr position_t get_position() const noexcept
    {
        return position;
    }

    /// return the last read token (for errors only).  Will never contain EOF
    /// (an arbitrary value that is not a valid char value, often -1), because
    /// 255 may legitimately occur.  May contain NUL, which should be escaped.
    std::string get_token_string() const
    {
        // escape control characters
        std::string result;
        for (const auto c : token_string)
        {
            if (static_cast<unsigned char>(c) <= '\x1F')
            {
                // escape control characters
                std::array<char, 9> cs{{}};
                (std::snprintf)(cs.data(), cs.size(), "<U+%.4X>", static_cast<unsigned char>(c));
                result += cs.data();
            }
            else
            {
                // add character as is
                result.push_back(static_cast<std::string::value_type>(c));
            }
        }

        return result;
    }

    /// return syntax error message
    JSON_HEDLEY_RETURNS_NON_NULL
    constexpr const char* get_error_message() const noexcept
    {
        return error_message;
    }

    /////////////////////
    // actual scanner
    /////////////////////

    /*!
    @brief skip the UTF-8 byte order mark
    @return true iff there is no BOM or the correct BOM has been skipped
    */
    bool skip_bom()
    {
        if (get() == 0xEF)
        {
            // check if we completely parse the BOM
            return get() == 0xBB && get() == 0xBF;
        }

        // the first character is not the beginning of the BOM; unget it to
        // process is later
        unget();
        return true;
    }

    void skip_whitespace()
    {
        do
        {
            get();
        }
        while (current == ' ' || current == '\t' || current == '\n' || current == '\r');
    }

    token_type scan()
    {
        // initially, skip the BOM
        if (position.chars_read_total == 0 && !skip_bom())
        {
            error_message = "invalid BOM; must be 0xEF 0xBB 0xBF if given";
            return token_type::parse_error;
        }

        // read next character and ignore whitespace
        skip_whitespace();

        // ignore comments
        while (ignore_comments && current == '/')
        {
            if (!scan_comment())
            {
                return token_type::parse_error;
            }

            // skip following whitespace
            skip_whitespace();
        }

        switch (current)
        {
            // structural characters
            case '[':
                return token_type::begin_array;
            case ']':
                return token_type::end_array;
            case '{':
                return token_type::begin_object;
            case '}':
                return token_type::end_object;
            case ':':
                return token_type::name_separator;
            case ',':
                return token_type::value_separator;

            // literals
            case 't':
            {
                std::array<char_type, 4> true_literal = {{'t', 'r', 'u', 'e'}};
                return scan_literal(true_literal.data(), true_literal.size(), token_type::literal_true);
            }
            case 'f':
            {
                std::array<char_type, 5> false_literal = {{'f', 'a', 'l', 's', 'e'}};
                return scan_literal(false_literal.data(), false_literal.size(), token_type::literal_false);
            }
            case 'n':
            {
                std::array<char_type, 4> null_literal = {{'n', 'u', 'l', 'l'}};
                return scan_literal(null_literal.data(), null_literal.size(), token_type::literal_null);
            }

            // string
            case '\"':
                return scan_string();

            // number
            case '-':
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
                return scan_number();

            // end of input (the null byte is needed when parsing from
            // string literals)
            case '\0':
            case std::char_traits<char_type>::eof():
                return token_type::end_of_input;

            // error
            default:
                error_message = "invalid literal";
                return token_type::parse_error;
        }
    }

  private:
    /// input adapter
    InputAdapterType ia;

    /// whether comments should be ignored (true) or signaled as errors (false)
    const bool ignore_comments = false;

    /// the current character
    char_int_type current = std::char_traits<char_type>::eof();

    /// whether the next get() call should just return current
    bool next_unget = false;

    /// the start position of the current token
    position_t position {};

    /// raw input token string (for error messages)
    std::vector<char_type> token_string {};

    /// buffer for variable-length tokens (numbers, strings)
    string_t token_buffer {};

    /// a description of occurred lexer errors
    const char* error_message = "";

    // number values
    number_integer_t value_integer = 0;
    number_unsigned_t value_unsigned = 0;
    number_float_t value_float = 0;

    /// the decimal point
    const char_int_type decimal_point_char = '.';
};
}  // namespace detail
}  // namespace nlohmann

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/meta/is_sax.hpp>


#include <cstdint> // size_t
#include <utility> // declval
#include <string> // string

// #include <nlohmann/detail/meta/detected.hpp>

// #include <nlohmann/detail/meta/type_traits.hpp>


namespace nlohmann
{
namespace detail
{
template<typename T>
using null_function_t = decltype(std::declval<T&>().null());

template<typename T>
using boolean_function_t =
    decltype(std::declval<T&>().boolean(std::declval<bool>()));

template<typename T, typename Integer>
using number_integer_function_t =
    decltype(std::declval<T&>().number_integer(std::declval<Integer>()));

template<typename T, typename Unsigned>
using number_unsigned_function_t =
    decltype(std::declval<T&>().number_unsigned(std::declval<Unsigned>()));

template<typename T, typename Float, typename String>
using number_float_function_t = decltype(std::declval<T&>().number_float(
                                    std::declval<Float>(), std::declval<const String&>()));

template<typename T, typename String>
using string_function_t =
    decltype(std::declval<T&>().string(std::declval<String&>()));

template<typename T, typename Binary>
using binary_function_t =
    decltype(std::declval<T&>().binary(std::declval<Binary&>()));

template<typename T>
using start_object_function_t =
    decltype(std::declval<T&>().start_object(std::declval<std::size_t>()));

template<typename T, typename String>
using key_function_t =
    decltype(std::declval<T&>().key(std::declval<String&>()));

template<typename T>
using end_object_function_t = decltype(std::declval<T&>().end_object());

template<typename T>
using start_array_function_t =
    decltype(std::declval<T&>().start_array(std::declval<std::size_t>()));

template<typename T>
using end_array_function_t = decltype(std::declval<T&>().end_array());

template<typename T, typename Exception>
using parse_error_function_t = decltype(std::declval<T&>().parse_error(
        std::declval<std::size_t>(), std::declval<const std::string&>(),
        std::declval<const Exception&>()));

template<typename SAX, typename BasicJsonType>
struct is_sax
{
  private:
    static_assert(is_basic_json<BasicJsonType>::value,
                  "BasicJsonType must be of type basic_json<...>");

    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;
    using binary_t = typename BasicJsonType::binary_t;
    using exception_t = typename BasicJsonType::exception;

  public:
    static constexpr bool value =
        is_detected_exact<bool, null_function_t, SAX>::value &&
        is_detected_exact<bool, boolean_function_t, SAX>::value &&
        is_detected_exact<bool, number_integer_function_t, SAX, number_integer_t>::value &&
        is_detected_exact<bool, number_unsigned_function_t, SAX, number_unsigned_t>::value &&
        is_detected_exact<bool, number_float_function_t, SAX, number_float_t, string_t>::value &&
        is_detected_exact<bool, string_function_t, SAX, string_t>::value &&
        is_detected_exact<bool, binary_function_t, SAX, binary_t>::value &&
        is_detected_exact<bool, start_object_function_t, SAX>::value &&
        is_detected_exact<bool, key_function_t, SAX, string_t>::value &&
        is_detected_exact<bool, end_object_function_t, SAX>::value &&
        is_detected_exact<bool, start_array_function_t, SAX>::value &&
        is_detected_exact<bool, end_array_function_t, SAX>::value &&
        is_detected_exact<bool, parse_error_function_t, SAX, exception_t>::value;
};

template<typename SAX, typename BasicJsonType>
struct is_sax_static_asserts
{
  private:
    static_assert(is_basic_json<BasicJsonType>::value,
                  "BasicJsonType must be of type basic_json<...>");

    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;
    using binary_t = typename BasicJsonType::binary_t;
    using exception_t = typename BasicJsonType::exception;

  public:
    static_assert(is_detected_exact<bool, null_function_t, SAX>::value,
                  "Missing/invalid function: bool null()");
    static_assert(is_detected_exact<bool, boolean_function_t, SAX>::value,
                  "Missing/invalid function: bool boolean(bool)");
    static_assert(is_detected_exact<bool, boolean_function_t, SAX>::value,
                  "Missing/invalid function: bool boolean(bool)");
    static_assert(
        is_detected_exact<bool, number_integer_function_t, SAX,
        number_integer_t>::value,
        "Missing/invalid function: bool number_integer(number_integer_t)");
    static_assert(
        is_detected_exact<bool, number_unsigned_function_t, SAX,
        number_unsigned_t>::value,
        "Missing/invalid function: bool number_unsigned(number_unsigned_t)");
    static_assert(is_detected_exact<bool, number_float_function_t, SAX,
                  number_float_t, string_t>::value,
                  "Missing/invalid function: bool number_float(number_float_t, const string_t&)");
    static_assert(
        is_detected_exact<bool, string_function_t, SAX, string_t>::value,
        "Missing/invalid function: bool string(string_t&)");
    static_assert(
        is_detected_exact<bool, binary_function_t, SAX, binary_t>::value,
        "Missing/invalid function: bool binary(binary_t&)");
    static_assert(is_detected_exact<bool, start_object_function_t, SAX>::value,
                  "Missing/invalid function: bool start_object(std::size_t)");
    static_assert(is_detected_exact<bool, key_function_t, SAX, string_t>::value,
                  "Missing/invalid function: bool key(string_t&)");
    static_assert(is_detected_exact<bool, end_object_function_t, SAX>::value,
                  "Missing/invalid function: bool end_object()");
    static_assert(is_detected_exact<bool, start_array_function_t, SAX>::value,
                  "Missing/invalid function: bool start_array(std::size_t)");
    static_assert(is_detected_exact<bool, end_array_function_t, SAX>::value,
                  "Missing/invalid function: bool end_array()");
    static_assert(
        is_detected_exact<bool, parse_error_function_t, SAX, exception_t>::value,
        "Missing/invalid function: bool parse_error(std::size_t, const "
        "std::string&, const exception&)");
};
}  // namespace detail
}  // namespace nlohmann

// #include <nlohmann/detail/value_t.hpp>


namespace nlohmann
{
namespace detail
{

/// how to treat CBOR tags
enum class cbor_tag_handler_t
{
    error,  ///< throw a parse_error exception in case of a tag
    ignore   ///< ignore tags
};

/*!
@brief determine system byte order

@return true if and only if system's byte order is little endian

@note from https://stackoverflow.com/a/1001328/266378
*/
static inline bool little_endianess(int num = 1) noexcept
{
    return *reinterpret_cast<char*>(&num) == 1;
}


///////////////////
// binary reader //
///////////////////

/*!
@brief deserialization of CBOR, MessagePack, and UBJSON values
*/
template<typename BasicJsonType, typename InputAdapterType, typename SAX = json_sax_dom_parser<BasicJsonType>>
class binary_reader
{
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;
    using binary_t = typename BasicJsonType::binary_t;
    using json_sax_t = SAX;
    using char_type = typename InputAdapterType::char_type;
    using char_int_type = typename std::char_traits<char_type>::int_type;

  public:
    /*!
    @brief create a binary reader

    @param[in] adapter  input adapter to read from
    */
    explicit binary_reader(InputAdapterType&& adapter) : ia(std::move(adapter))
    {
        (void)detail::is_sax_static_asserts<SAX, BasicJsonType> {};
    }

    // make class move-only
    binary_reader(const binary_reader&) = delete;
    binary_reader(binary_reader&&) = default;
    binary_reader& operator=(const binary_reader&) = delete;
    binary_reader& operator=(binary_reader&&) = default;
    ~binary_reader() = default;

    /*!
    @param[in] format  the binary format to parse
    @param[in] sax_    a SAX event processor
    @param[in] strict  whether to expect the input to be consumed completed
    @param[in] tag_handler  how to treat CBOR tags

    @return
    */
    JSON_HEDLEY_NON_NULL(3)
    bool sax_parse(const input_format_t format,
                   json_sax_t* sax_,
                   const bool strict = true,
                   const cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error)
    {
        sax = sax_;
        bool result = false;

        switch (format)
        {
            case input_format_t::bson:
                result = parse_bson_internal();
                break;

            case input_format_t::cbor:
                result = parse_cbor_internal(true, tag_handler);
                break;

            case input_format_t::msgpack:
                result = parse_msgpack_internal();
                break;

            case input_format_t::ubjson:
                result = parse_ubjson_internal();
                break;

            default:            // LCOV_EXCL_LINE
                JSON_ASSERT(false);  // LCOV_EXCL_LINE
        }

        // strict mode: next byte must be EOF
        if (result && strict)
        {
            if (format == input_format_t::ubjson)
            {
                get_ignore_noop();
            }
            else
            {
                get();
            }

            if (JSON_HEDLEY_UNLIKELY(current != std::char_traits<char_type>::eof()))
            {
                return sax->parse_error(chars_read, get_token_string(),
                                        parse_error::create(110, chars_read, exception_message(format, "expected end of input; last byte: 0x" + get_token_string(), "value")));
            }
        }

        return result;
    }

  private:
    //////////
    // BSON //
    //////////

    /*!
    @brief Reads in a BSON-object and passes it to the SAX-parser.
    @return whether a valid BSON-value was passed to the SAX parser
    */
    bool parse_bson_internal()
    {
        std::int32_t document_size{};
        get_number<std::int32_t, true>(input_format_t::bson, document_size);

        if (JSON_HEDLEY_UNLIKELY(!sax->start_object(std::size_t(-1))))
        {
            return false;
        }

        if (JSON_HEDLEY_UNLIKELY(!parse_bson_element_list(/*is_array*/false)))
        {
            return false;
        }

        return sax->end_object();
    }

    /*!
    @brief Parses a C-style string from the BSON input.
    @param[in, out] result  A reference to the string variable where the read
                            string is to be stored.
    @return `true` if the \x00-byte indicating the end of the string was
             encountered before the EOF; false` indicates an unexpected EOF.
    */
    bool get_bson_cstr(string_t& result)
    {
        auto out = std::back_inserter(result);
        while (true)
        {
            get();
            if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::bson, "cstring")))
            {
                return false;
            }
            if (current == 0x00)
            {
                return true;
            }
            *out++ = static_cast<typename string_t::value_type>(current);
        }
    }

    /*!
    @brief Parses a zero-terminated string of length @a len from the BSON
           input.
    @param[in] len  The length (including the zero-byte at the end) of the
                    string to be read.
    @param[in, out] result  A reference to the string variable where the read
                            string is to be stored.
    @tparam NumberType The type of the length @a len
    @pre len >= 1
    @return `true` if the string was successfully parsed
    */
    template<typename NumberType>
    bool get_bson_string(const NumberType len, string_t& result)
    {
        if (JSON_HEDLEY_UNLIKELY(len < 1))
        {
            auto last_token = get_token_string();
            return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read, exception_message(input_format_t::bson, "string length must be at least 1, is " + std::to_string(len), "string")));
        }

        return get_string(input_format_t::bson, len - static_cast<NumberType>(1), result) && get() != std::char_traits<char_type>::eof();
    }

    /*!
    @brief Parses a byte array input of length @a len from the BSON input.
    @param[in] len  The length of the byte array to be read.
    @param[in, out] result  A reference to the binary variable where the read
                            array is to be stored.
    @tparam NumberType The type of the length @a len
    @pre len >= 0
    @return `true` if the byte array was successfully parsed
    */
    template<typename NumberType>
    bool get_bson_binary(const NumberType len, binary_t& result)
    {
        if (JSON_HEDLEY_UNLIKELY(len < 0))
        {
            auto last_token = get_token_string();
            return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read, exception_message(input_format_t::bson, "byte array length cannot be negative, is " + std::to_string(len), "binary")));
        }

        // All BSON binary values have a subtype
        std::uint8_t subtype{};
        get_number<std::uint8_t>(input_format_t::bson, subtype);
        result.set_subtype(subtype);

        return get_binary(input_format_t::bson, len, result);
    }

    /*!
    @brief Read a BSON document element of the given @a element_type.
    @param[in] element_type The BSON element type, c.f. http://bsonspec.org/spec.html
    @param[in] element_type_parse_position The position in the input stream,
               where the `element_type` was read.
    @warning Not all BSON element types are supported yet. An unsupported
             @a element_type will give rise to a parse_error.114:
             Unsupported BSON record type 0x...
    @return whether a valid BSON-object/array was passed to the SAX parser
    */
    bool parse_bson_element_internal(const char_int_type element_type,
                                     const std::size_t element_type_parse_position)
    {
        switch (element_type)
        {
            case 0x01: // double
            {
                double number{};
                return get_number<double, true>(input_format_t::bson, number) && sax->number_float(static_cast<number_float_t>(number), "");
            }

            case 0x02: // string
            {
                std::int32_t len{};
                string_t value;
                return get_number<std::int32_t, true>(input_format_t::bson, len) && get_bson_string(len, value) && sax->string(value);
            }

            case 0x03: // object
            {
                return parse_bson_internal();
            }

            case 0x04: // array
            {
                return parse_bson_array();
            }

            case 0x05: // binary
            {
                std::int32_t len{};
                binary_t value;
                return get_number<std::int32_t, true>(input_format_t::bson, len) && get_bson_binary(len, value) && sax->binary(value);
            }

            case 0x08: // boolean
            {
                return sax->boolean(get() != 0);
            }

            case 0x0A: // null
            {
                return sax->null();
            }

            case 0x10: // int32
            {
                std::int32_t value{};
                return get_number<std::int32_t, true>(input_format_t::bson, value) && sax->number_integer(value);
            }

            case 0x12: // int64
            {
                std::int64_t value{};
                return get_number<std::int64_t, true>(input_format_t::bson, value) && sax->number_integer(value);
            }

            default: // anything else not supported (yet)
            {
                std::array<char, 3> cr{{}};
                (std::snprintf)(cr.data(), cr.size(), "%.2hhX", static_cast<unsigned char>(element_type));
                return sax->parse_error(element_type_parse_position, std::string(cr.data()), parse_error::create(114, element_type_parse_position, "Unsupported BSON record type 0x" + std::string(cr.data())));
            }
        }
    }

    /*!
    @brief Read a BSON element list (as specified in the BSON-spec)

    The same binary layout is used for objects and arrays, hence it must be
    indicated with the argument @a is_array which one is expected
    (true --> array, false --> object).

    @param[in] is_array Determines if the element list being read is to be
                        treated as an object (@a is_array == false), or as an
                        array (@a is_array == true).
    @return whether a valid BSON-object/array was passed to the SAX parser
    */
    bool parse_bson_element_list(const bool is_array)
    {
        string_t key;

        while (auto element_type = get())
        {
            if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::bson, "element list")))
            {
                return false;
            }

            const std::size_t element_type_parse_position = chars_read;
            if (JSON_HEDLEY_UNLIKELY(!get_bson_cstr(key)))
            {
                return false;
            }

            if (!is_array && !sax->key(key))
            {
                return false;
            }

            if (JSON_HEDLEY_UNLIKELY(!parse_bson_element_internal(element_type, element_type_parse_position)))
            {
                return false;
            }

            // get_bson_cstr only appends
            key.clear();
        }

        return true;
    }

    /*!
    @brief Reads an array from the BSON input and passes it to the SAX-parser.
    @return whether a valid BSON-array was passed to the SAX parser
    */
    bool parse_bson_array()
    {
        std::int32_t document_size{};
        get_number<std::int32_t, true>(input_format_t::bson, document_size);

        if (JSON_HEDLEY_UNLIKELY(!sax->start_array(std::size_t(-1))))
        {
            return false;
        }

        if (JSON_HEDLEY_UNLIKELY(!parse_bson_element_list(/*is_array*/true)))
        {
            return false;
        }

        return sax->end_array();
    }

    //////////
    // CBOR //
    //////////

    /*!
    @param[in] get_char  whether a new character should be retrieved from the
                         input (true) or whether the last read character should
                         be considered instead (false)
    @param[in] tag_handler how CBOR tags should be treated

    @return whether a valid CBOR value was passed to the SAX parser
    */
    bool parse_cbor_internal(const bool get_char,
                             const cbor_tag_handler_t tag_handler)
    {
        switch (get_char ? get() : current)
        {
            // EOF
            case std::char_traits<char_type>::eof():
                return unexpect_eof(input_format_t::cbor, "value");

            // Integer 0x00..0x17 (0..23)
            case 0x00:
            case 0x01:
            case 0x02:
            case 0x03:
            case 0x04:
            case 0x05:
            case 0x06:
            case 0x07:
            case 0x08:
            case 0x09:
            case 0x0A:
            case 0x0B:
            case 0x0C:
            case 0x0D:
            case 0x0E:
            case 0x0F:
            case 0x10:
            case 0x11:
            case 0x12:
            case 0x13:
            case 0x14:
            case 0x15:
            case 0x16:
            case 0x17:
                return sax->number_unsigned(static_cast<number_unsigned_t>(current));

            case 0x18: // Unsigned integer (one-byte uint8_t follows)
            {
                std::uint8_t number{};
                return get_number(input_format_t::cbor, number) && sax->number_unsigned(number);
            }

            case 0x19: // Unsigned integer (two-byte uint16_t follows)
            {
                std::uint16_t number{};
                return get_number(input_format_t::cbor, number) && sax->number_unsigned(number);
            }

            case 0x1A: // Unsigned integer (four-byte uint32_t follows)
            {
                std::uint32_t number{};
                return get_number(input_format_t::cbor, number) && sax->number_unsigned(number);
            }

            case 0x1B: // Unsigned integer (eight-byte uint64_t follows)
            {
                std::uint64_t number{};
                return get_number(input_format_t::cbor, number) && sax->number_unsigned(number);
            }

            // Negative integer -1-0x00..-1-0x17 (-1..-24)
            case 0x20:
            case 0x21:
            case 0x22:
            case 0x23:
            case 0x24:
            case 0x25:
            case 0x26:
            case 0x27:
            case 0x28:
            case 0x29:
            case 0x2A:
            case 0x2B:
            case 0x2C:
            case 0x2D:
            case 0x2E:
            case 0x2F:
            case 0x30:
            case 0x31:
            case 0x32:
            case 0x33:
            case 0x34:
            case 0x35:
            case 0x36:
            case 0x37:
                return sax->number_integer(static_cast<std::int8_t>(0x20 - 1 - current));

            case 0x38: // Negative integer (one-byte uint8_t follows)
            {
                std::uint8_t number{};
                return get_number(input_format_t::cbor, number) && sax->number_integer(static_cast<number_integer_t>(-1) - number);
            }

            case 0x39: // Negative integer -1-n (two-byte uint16_t follows)
            {
                std::uint16_t number{};
                return get_number(input_format_t::cbor, number) && sax->number_integer(static_cast<number_integer_t>(-1) - number);
            }

            case 0x3A: // Negative integer -1-n (four-byte uint32_t follows)
            {
                std::uint32_t number{};
                return get_number(input_format_t::cbor, number) && sax->number_integer(static_cast<number_integer_t>(-1) - number);
            }

            case 0x3B: // Negative integer -1-n (eight-byte uint64_t follows)
            {
                std::uint64_t number{};
                return get_number(input_format_t::cbor, number) && sax->number_integer(static_cast<number_integer_t>(-1)
                        - static_cast<number_integer_t>(number));
            }

            // Binary data (0x00..0x17 bytes follow)
            case 0x40:
            case 0x41:
            case 0x42:
            case 0x43:
            case 0x44:
            case 0x45:
            case 0x46:
            case 0x47:
            case 0x48:
            case 0x49:
            case 0x4A:
            case 0x4B:
            case 0x4C:
            case 0x4D:
            case 0x4E:
            case 0x4F:
            case 0x50:
            case 0x51:
            case 0x52:
            case 0x53:
            case 0x54:
            case 0x55:
            case 0x56:
            case 0x57:
            case 0x58: // Binary data (one-byte uint8_t for n follows)
            case 0x59: // Binary data (two-byte uint16_t for n follow)
            case 0x5A: // Binary data (four-byte uint32_t for n follow)
            case 0x5B: // Binary data (eight-byte uint64_t for n follow)
            case 0x5F: // Binary data (indefinite length)
            {
                binary_t b;
                return get_cbor_binary(b) && sax->binary(b);
            }

            // UTF-8 string (0x00..0x17 bytes follow)
            case 0x60:
            case 0x61:
            case 0x62:
            case 0x63:
            case 0x64:
            case 0x65:
            case 0x66:
            case 0x67:
            case 0x68:
            case 0x69:
            case 0x6A:
            case 0x6B:
            case 0x6C:
            case 0x6D:
            case 0x6E:
            case 0x6F:
            case 0x70:
            case 0x71:
            case 0x72:
            case 0x73:
            case 0x74:
            case 0x75:
            case 0x76:
            case 0x77:
            case 0x78: // UTF-8 string (one-byte uint8_t for n follows)
            case 0x79: // UTF-8 string (two-byte uint16_t for n follow)
            case 0x7A: // UTF-8 string (four-byte uint32_t for n follow)
            case 0x7B: // UTF-8 string (eight-byte uint64_t for n follow)
            case 0x7F: // UTF-8 string (indefinite length)
            {
                string_t s;
                return get_cbor_string(s) && sax->string(s);
            }

            // array (0x00..0x17 data items follow)
            case 0x80:
            case 0x81:
            case 0x82:
            case 0x83:
            case 0x84:
            case 0x85:
            case 0x86:
            case 0x87:
            case 0x88:
            case 0x89:
            case 0x8A:
            case 0x8B:
            case 0x8C:
            case 0x8D:
            case 0x8E:
            case 0x8F:
            case 0x90:
            case 0x91:
            case 0x92:
            case 0x93:
            case 0x94:
            case 0x95:
            case 0x96:
            case 0x97:
                return get_cbor_array(static_cast<std::size_t>(static_cast<unsigned int>(current) & 0x1Fu), tag_handler);

            case 0x98: // array (one-byte uint8_t for n follows)
            {
                std::uint8_t len{};
                return get_number(input_format_t::cbor, len) && get_cbor_array(static_cast<std::size_t>(len), tag_handler);
            }

            case 0x99: // array (two-byte uint16_t for n follow)
            {
                std::uint16_t len{};
                return get_number(input_format_t::cbor, len) && get_cbor_array(static_cast<std::size_t>(len), tag_handler);
            }

            case 0x9A: // array (four-byte uint32_t for n follow)
            {
                std::uint32_t len{};
                return get_number(input_format_t::cbor, len) && get_cbor_array(static_cast<std::size_t>(len), tag_handler);
            }

            case 0x9B: // array (eight-byte uint64_t for n follow)
            {
                std::uint64_t len{};
                return get_number(input_format_t::cbor, len) && get_cbor_array(static_cast<std::size_t>(len), tag_handler);
            }

            case 0x9F: // array (indefinite length)
                return get_cbor_array(std::size_t(-1), tag_handler);

            // map (0x00..0x17 pairs of data items follow)
            case 0xA0:
            case 0xA1:
            case 0xA2:
            case 0xA3:
            case 0xA4:
            case 0xA5:
            case 0xA6:
            case 0xA7:
            case 0xA8:
            case 0xA9:
            case 0xAA:
            case 0xAB:
            case 0xAC:
            case 0xAD:
            case 0xAE:
            case 0xAF:
            case 0xB0:
            case 0xB1:
            case 0xB2:
            case 0xB3:
            case 0xB4:
            case 0xB5:
            case 0xB6:
            case 0xB7:
                return get_cbor_object(static_cast<std::size_t>(static_cast<unsigned int>(current) & 0x1Fu), tag_handler);

            case 0xB8: // map (one-byte uint8_t for n follows)
            {
                std::uint8_t len{};
                return get_number(input_format_t::cbor, len) && get_cbor_object(static_cast<std::size_t>(len), tag_handler);
            }

            case 0xB9: // map (two-byte uint16_t for n follow)
            {
                std::uint16_t len{};
                return get_number(input_format_t::cbor, len) && get_cbor_object(static_cast<std::size_t>(len), tag_handler);
            }

            case 0xBA: // map (four-byte uint32_t for n follow)
            {
                std::uint32_t len{};
                return get_number(input_format_t::cbor, len) && get_cbor_object(static_cast<std::size_t>(len), tag_handler);
            }

            case 0xBB: // map (eight-byte uint64_t for n follow)
            {
                std::uint64_t len{};
                return get_number(input_format_t::cbor, len) && get_cbor_object(static_cast<std::size_t>(len), tag_handler);
            }

            case 0xBF: // map (indefinite length)
                return get_cbor_object(std::size_t(-1), tag_handler);

            case 0xC6: // tagged item
            case 0xC7:
            case 0xC8:
            case 0xC9:
            case 0xCA:
            case 0xCB:
            case 0xCC:
            case 0xCD:
            case 0xCE:
            case 0xCF:
            case 0xD0:
            case 0xD1:
            case 0xD2:
            case 0xD3:
            case 0xD4:
            case 0xD8: // tagged item (1 bytes follow)
            case 0xD9: // tagged item (2 bytes follow)
            case 0xDA: // tagged item (4 bytes follow)
            case 0xDB: // tagged item (8 bytes follow)
            {
                switch (tag_handler)
                {
                    case cbor_tag_handler_t::error:
                    {
                        auto last_token = get_token_string();
                        return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read, exception_message(input_format_t::cbor, "invalid byte: 0x" + last_token, "value")));
                    }

                    case cbor_tag_handler_t::ignore:
                    {
                        switch (current)
                        {
                            case 0xD8:
                            {
                                std::uint8_t len{};
                                get_number(input_format_t::cbor, len);
                                break;
                            }
                            case 0xD9:
                            {
                                std::uint16_t len{};
                                get_number(input_format_t::cbor, len);
                                break;
                            }
                            case 0xDA:
                            {
                                std::uint32_t len{};
                                get_number(input_format_t::cbor, len);
                                break;
                            }
                            case 0xDB:
                            {
                                std::uint64_t len{};
                                get_number(input_format_t::cbor, len);
                                break;
                            }
                            default:
                                break;
                        }
                        return parse_cbor_internal(true, tag_handler);
                    }

                    default:            // LCOV_EXCL_LINE
                        JSON_ASSERT(false);  // LCOV_EXCL_LINE
                }
            }

            case 0xF4: // false
                return sax->boolean(false);

            case 0xF5: // true
                return sax->boolean(true);

            case 0xF6: // null
                return sax->null();

            case 0xF9: // Half-Precision Float (two-byte IEEE 754)
            {
                const auto byte1_raw = get();
                if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::cbor, "number")))
                {
                    return false;
                }
                const auto byte2_raw = get();
                if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::cbor, "number")))
                {
                    return false;
                }

                const auto byte1 = static_cast<unsigned char>(byte1_raw);
                const auto byte2 = static_cast<unsigned char>(byte2_raw);

                // code from RFC 7049, Appendix D, Figure 3:
                // As half-precision floating-point numbers were only added
                // to IEEE 754 in 2008, today's programming platforms often
                // still only have limited support for them. It is very
                // easy to include at least decoding support for them even
                // without such support. An example of a small decoder for
                // half-precision floating-point numbers in the C language
                // is shown in Fig. 3.
                const auto half = static_cast<unsigned int>((byte1 << 8u) + byte2);
                const double val = [&half]
                {
                    const int exp = (half >> 10u) & 0x1Fu;
                    const unsigned int mant = half & 0x3FFu;
                    JSON_ASSERT(0 <= exp&& exp <= 32);
                    JSON_ASSERT(mant <= 1024);
                    switch (exp)
                    {
                        case 0:
                            return std::ldexp(mant, -24);
                        case 31:
                            return (mant == 0)
                            ? std::numeric_limits<double>::infinity()
                            : std::numeric_limits<double>::quiet_NaN();
                        default:
                            return std::ldexp(mant + 1024, exp - 25);
                    }
                }();
                return sax->number_float((half & 0x8000u) != 0
                                         ? static_cast<number_float_t>(-val)
                                         : static_cast<number_float_t>(val), "");
            }

            case 0xFA: // Single-Precision Float (four-byte IEEE 754)
            {
                float number{};
                return get_number(input_format_t::cbor, number) && sax->number_float(static_cast<number_float_t>(number), "");
            }

            case 0xFB: // Double-Precision Float (eight-byte IEEE 754)
            {
                double number{};
                return get_number(input_format_t::cbor, number) && sax->number_float(static_cast<number_float_t>(number), "");
            }

            default: // anything else (0xFF is handled inside the other types)
            {
                auto last_token = get_token_string();
                return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read, exception_message(input_format_t::cbor, "invalid byte: 0x" + last_token, "value")));
            }
        }
    }

    /*!
    @brief reads a CBOR string

    This function first reads starting bytes to determine the expected
    string length and then copies this number of bytes into a string.
    Additionally, CBOR's strings with indefinite lengths are supported.

    @param[out] result  created string

    @return whether string creation completed
    */
    bool get_cbor_string(string_t& result)
    {
        if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::cbor, "string")))
        {
            return false;
        }

        switch (current)
        {
            // UTF-8 string (0x00..0x17 bytes follow)
            case 0x60:
            case 0x61:
            case 0x62:
            case 0x63:
            case 0x64:
            case 0x65:
            case 0x66:
            case 0x67:
            case 0x68:
            case 0x69:
            case 0x6A:
            case 0x6B:
            case 0x6C:
            case 0x6D:
            case 0x6E:
            case 0x6F:
            case 0x70:
            case 0x71:
            case 0x72:
            case 0x73:
            case 0x74:
            case 0x75:
            case 0x76:
            case 0x77:
            {
                return get_string(input_format_t::cbor, static_cast<unsigned int>(current) & 0x1Fu, result);
            }

            case 0x78: // UTF-8 string (one-byte uint8_t for n follows)
            {
                std::uint8_t len{};
                return get_number(input_format_t::cbor, len) && get_string(input_format_t::cbor, len, result);
            }

            case 0x79: // UTF-8 string (two-byte uint16_t for n follow)
            {
                std::uint16_t len{};
                return get_number(input_format_t::cbor, len) && get_string(input_format_t::cbor, len, result);
            }

            case 0x7A: // UTF-8 string (four-byte uint32_t for n follow)
            {
                std::uint32_t len{};
                return get_number(input_format_t::cbor, len) && get_string(input_format_t::cbor, len, result);
            }

            case 0x7B: // UTF-8 string (eight-byte uint64_t for n follow)
            {
                std::uint64_t len{};
                return get_number(input_format_t::cbor, len) && get_string(input_format_t::cbor, len, result);
            }

            case 0x7F: // UTF-8 string (indefinite length)
            {
                while (get() != 0xFF)
                {
                    string_t chunk;
                    if (!get_cbor_string(chunk))
                    {
                        return false;
                    }
                    result.append(chunk);
                }
                return true;
            }

            default:
            {
                auto last_token = get_token_string();
                return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, exception_message(input_format_t::cbor, "expected length specification (0x60-0x7B) or indefinite string type (0x7F); last byte: 0x" + last_token, "string")));
            }
        }
    }

    /*!
    @brief reads a CBOR byte array

    This function first reads starting bytes to determine the expected
    byte array length and then copies this number of bytes into the byte array.
    Additionally, CBOR's byte arrays with indefinite lengths are supported.

    @param[out] result  created byte array

    @return whether byte array creation completed
    */
    bool get_cbor_binary(binary_t& result)
    {
        if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::cbor, "binary")))
        {
            return false;
        }

        switch (current)
        {
            // Binary data (0x00..0x17 bytes follow)
            case 0x40:
            case 0x41:
            case 0x42:
            case 0x43:
            case 0x44:
            case 0x45:
            case 0x46:
            case 0x47:
            case 0x48:
            case 0x49:
            case 0x4A:
            case 0x4B:
            case 0x4C:
            case 0x4D:
            case 0x4E:
            case 0x4F:
            case 0x50:
            case 0x51:
            case 0x52:
            case 0x53:
            case 0x54:
            case 0x55:
            case 0x56:
            case 0x57:
            {
                return get_binary(input_format_t::cbor, static_cast<unsigned int>(current) & 0x1Fu, result);
            }

            case 0x58: // Binary data (one-byte uint8_t for n follows)
            {
                std::uint8_t len{};
                return get_number(input_format_t::cbor, len) &&
                       get_binary(input_format_t::cbor, len, result);
            }

            case 0x59: // Binary data (two-byte uint16_t for n follow)
            {
                std::uint16_t len{};
                return get_number(input_format_t::cbor, len) &&
                       get_binary(input_format_t::cbor, len, result);
            }

            case 0x5A: // Binary data (four-byte uint32_t for n follow)
            {
                std::uint32_t len{};
                return get_number(input_format_t::cbor, len) &&
                       get_binary(input_format_t::cbor, len, result);
            }

            case 0x5B: // Binary data (eight-byte uint64_t for n follow)
            {
                std::uint64_t len{};
                return get_number(input_format_t::cbor, len) &&
                       get_binary(input_format_t::cbor, len, result);
            }

            case 0x5F: // Binary data (indefinite length)
            {
                while (get() != 0xFF)
                {
                    binary_t chunk;
                    if (!get_cbor_binary(chunk))
                    {
                        return false;
                    }
                    result.insert(result.end(), chunk.begin(), chunk.end());
                }
                return true;
            }

            default:
            {
                auto last_token = get_token_string();
                return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, exception_message(input_format_t::cbor, "expected length specification (0x40-0x5B) or indefinite binary array type (0x5F); last byte: 0x" + last_token, "binary")));
            }
        }
    }

    /*!
    @param[in] len  the length of the array or std::size_t(-1) for an
                    array of indefinite size
    @param[in] tag_handler how CBOR tags should be treated
    @return whether array creation completed
    */
    bool get_cbor_array(const std::size_t len,
                        const cbor_tag_handler_t tag_handler)
    {
        if (JSON_HEDLEY_UNLIKELY(!sax->start_array(len)))
        {
            return false;
        }

        if (len != std::size_t(-1))
        {
            for (std::size_t i = 0; i < len; ++i)
            {
                if (JSON_HEDLEY_UNLIKELY(!parse_cbor_internal(true, tag_handler)))
                {
                    return false;
                }
            }
        }
        else
        {
            while (get() != 0xFF)
            {
                if (JSON_HEDLEY_UNLIKELY(!parse_cbor_internal(false, tag_handler)))
                {
                    return false;
                }
            }
        }

        return sax->end_array();
    }

    /*!
    @param[in] len  the length of the object or std::size_t(-1) for an
                    object of indefinite size
    @param[in] tag_handler how CBOR tags should be treated
    @return whether object creation completed
    */
    bool get_cbor_object(const std::size_t len,
                         const cbor_tag_handler_t tag_handler)
    {
        if (JSON_HEDLEY_UNLIKELY(!sax->start_object(len)))
        {
            return false;
        }

        string_t key;
        if (len != std::size_t(-1))
        {
            for (std::size_t i = 0; i < len; ++i)
            {
                get();
                if (JSON_HEDLEY_UNLIKELY(!get_cbor_string(key) || !sax->key(key)))
                {
                    return false;
                }

                if (JSON_HEDLEY_UNLIKELY(!parse_cbor_internal(true, tag_handler)))
                {
                    return false;
                }
                key.clear();
            }
        }
        else
        {
            while (get() != 0xFF)
            {
                if (JSON_HEDLEY_UNLIKELY(!get_cbor_string(key) || !sax->key(key)))
                {
                    return false;
                }

                if (JSON_HEDLEY_UNLIKELY(!parse_cbor_internal(true, tag_handler)))
                {
                    return false;
                }
                key.clear();
            }
        }

        return sax->end_object();
    }

    /////////////
    // MsgPack //
    /////////////

    /*!
    @return whether a valid MessagePack value was passed to the SAX parser
    */
    bool parse_msgpack_internal()
    {
        switch (get())
        {
            // EOF
            case std::char_traits<char_type>::eof():
                return unexpect_eof(input_format_t::msgpack, "value");

            // positive fixint
            case 0x00:
            case 0x01:
            case 0x02:
            case 0x03:
            case 0x04:
            case 0x05:
            case 0x06:
            case 0x07:
            case 0x08:
            case 0x09:
            case 0x0A:
            case 0x0B:
            case 0x0C:
            case 0x0D:
            case 0x0E:
            case 0x0F:
            case 0x10:
            case 0x11:
            case 0x12:
            case 0x13:
            case 0x14:
            case 0x15:
            case 0x16:
            case 0x17:
            case 0x18:
            case 0x19:
            case 0x1A:
            case 0x1B:
            case 0x1C:
            case 0x1D:
            case 0x1E:
            case 0x1F:
            case 0x20:
            case 0x21:
            case 0x22:
            case 0x23:
            case 0x24:
            case 0x25:
            case 0x26:
            case 0x27:
            case 0x28:
            case 0x29:
            case 0x2A:
            case 0x2B:
            case 0x2C:
            case 0x2D:
            case 0x2E:
            case 0x2F:
            case 0x30:
            case 0x31:
            case 0x32:
            case 0x33:
            case 0x34:
            case 0x35:
            case 0x36:
            case 0x37:
            case 0x38:
            case 0x39:
            case 0x3A:
            case 0x3B:
            case 0x3C:
            case 0x3D:
            case 0x3E:
            case 0x3F:
            case 0x40:
            case 0x41:
            case 0x42:
            case 0x43:
            case 0x44:
            case 0x45:
            case 0x46:
            case 0x47:
            case 0x48:
            case 0x49:
            case 0x4A:
            case 0x4B:
            case 0x4C:
            case 0x4D:
            case 0x4E:
            case 0x4F:
            case 0x50:
            case 0x51:
            case 0x52:
            case 0x53:
            case 0x54:
            case 0x55:
            case 0x56:
            case 0x57:
            case 0x58:
            case 0x59:
            case 0x5A:
            case 0x5B:
            case 0x5C:
            case 0x5D:
            case 0x5E:
            case 0x5F:
            case 0x60:
            case 0x61:
            case 0x62:
            case 0x63:
            case 0x64:
            case 0x65:
            case 0x66:
            case 0x67:
            case 0x68:
            case 0x69:
            case 0x6A:
            case 0x6B:
            case 0x6C:
            case 0x6D:
            case 0x6E:
            case 0x6F:
            case 0x70:
            case 0x71:
            case 0x72:
            case 0x73:
            case 0x74:
            case 0x75:
            case 0x76:
            case 0x77:
            case 0x78:
            case 0x79:
            case 0x7A:
            case 0x7B:
            case 0x7C:
            case 0x7D:
            case 0x7E:
            case 0x7F:
                return sax->number_unsigned(static_cast<number_unsigned_t>(current));

            // fixmap
            case 0x80:
            case 0x81:
            case 0x82:
            case 0x83:
            case 0x84:
            case 0x85:
            case 0x86:
            case 0x87:
            case 0x88:
            case 0x89:
            case 0x8A:
            case 0x8B:
            case 0x8C:
            case 0x8D:
            case 0x8E:
            case 0x8F:
                return get_msgpack_object(static_cast<std::size_t>(static_cast<unsigned int>(current) & 0x0Fu));

            // fixarray
            case 0x90:
            case 0x91:
            case 0x92:
            case 0x93:
            case 0x94:
            case 0x95:
            case 0x96:
            case 0x97:
            case 0x98:
            case 0x99:
            case 0x9A:
            case 0x9B:
            case 0x9C:
            case 0x9D:
            case 0x9E:
            case 0x9F:
                return get_msgpack_array(static_cast<std::size_t>(static_cast<unsigned int>(current) & 0x0Fu));

            // fixstr
            case 0xA0:
            case 0xA1:
            case 0xA2:
            case 0xA3:
            case 0xA4:
            case 0xA5:
            case 0xA6:
            case 0xA7:
            case 0xA8:
            case 0xA9:
            case 0xAA:
            case 0xAB:
            case 0xAC:
            case 0xAD:
            case 0xAE:
            case 0xAF:
            case 0xB0:
            case 0xB1:
            case 0xB2:
            case 0xB3:
            case 0xB4:
            case 0xB5:
            case 0xB6:
            case 0xB7:
            case 0xB8:
            case 0xB9:
            case 0xBA:
            case 0xBB:
            case 0xBC:
            case 0xBD:
            case 0xBE:
            case 0xBF:
            case 0xD9: // str 8
            case 0xDA: // str 16
            case 0xDB: // str 32
            {
                string_t s;
                return get_msgpack_string(s) && sax->string(s);
            }

            case 0xC0: // nil
                return sax->null();

            case 0xC2: // false
                return sax->boolean(false);

            case 0xC3: // true
                return sax->boolean(true);

            case 0xC4: // bin 8
            case 0xC5: // bin 16
            case 0xC6: // bin 32
            case 0xC7: // ext 8
            case 0xC8: // ext 16
            case 0xC9: // ext 32
            case 0xD4: // fixext 1
            case 0xD5: // fixext 2
            case 0xD6: // fixext 4
            case 0xD7: // fixext 8
            case 0xD8: // fixext 16
            {
                binary_t b;
                return get_msgpack_binary(b) && sax->binary(b);
            }

            case 0xCA: // float 32
            {
                float number{};
                return get_number(input_format_t::msgpack, number) && sax->number_float(static_cast<number_float_t>(number), "");
            }

            case 0xCB: // float 64
            {
                double number{};
                return get_number(input_format_t::msgpack, number) && sax->number_float(static_cast<number_float_t>(number), "");
            }

            case 0xCC: // uint 8
            {
                std::uint8_t number{};
                return get_number(input_format_t::msgpack, number) && sax->number_unsigned(number);
            }

            case 0xCD: // uint 16
            {
                std::uint16_t number{};
                return get_number(input_format_t::msgpack, number) && sax->number_unsigned(number);
            }

            case 0xCE: // uint 32
            {
                std::uint32_t number{};
                return get_number(input_format_t::msgpack, number) && sax->number_unsigned(number);
            }

            case 0xCF: // uint 64
            {
                std::uint64_t number{};
                return get_number(input_format_t::msgpack, number) && sax->number_unsigned(number);
            }

            case 0xD0: // int 8
            {
                std::int8_t number{};
                return get_number(input_format_t::msgpack, number) && sax->number_integer(number);
            }

            case 0xD1: // int 16
            {
                std::int16_t number{};
                return get_number(input_format_t::msgpack, number) && sax->number_integer(number);
            }

            case 0xD2: // int 32
            {
                std::int32_t number{};
                return get_number(input_format_t::msgpack, number) && sax->number_integer(number);
            }

            case 0xD3: // int 64
            {
                std::int64_t number{};
                return get_number(input_format_t::msgpack, number) && sax->number_integer(number);
            }

            case 0xDC: // array 16
            {
                std::uint16_t len{};
                return get_number(input_format_t::msgpack, len) && get_msgpack_array(static_cast<std::size_t>(len));
            }

            case 0xDD: // array 32
            {
                std::uint32_t len{};
                return get_number(input_format_t::msgpack, len) && get_msgpack_array(static_cast<std::size_t>(len));
            }

            case 0xDE: // map 16
            {
                std::uint16_t len{};
                return get_number(input_format_t::msgpack, len) && get_msgpack_object(static_cast<std::size_t>(len));
            }

            case 0xDF: // map 32
            {
                std::uint32_t len{};
                return get_number(input_format_t::msgpack, len) && get_msgpack_object(static_cast<std::size_t>(len));
            }

            // negative fixint
            case 0xE0:
            case 0xE1:
            case 0xE2:
            case 0xE3:
            case 0xE4:
            case 0xE5:
            case 0xE6:
            case 0xE7:
            case 0xE8:
            case 0xE9:
            case 0xEA:
            case 0xEB:
            case 0xEC:
            case 0xED:
            case 0xEE:
            case 0xEF:
            case 0xF0:
            case 0xF1:
            case 0xF2:
            case 0xF3:
            case 0xF4:
            case 0xF5:
            case 0xF6:
            case 0xF7:
            case 0xF8:
            case 0xF9:
            case 0xFA:
            case 0xFB:
            case 0xFC:
            case 0xFD:
            case 0xFE:
            case 0xFF:
                return sax->number_integer(static_cast<std::int8_t>(current));

            default: // anything else
            {
                auto last_token = get_token_string();
                return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read, exception_message(input_format_t::msgpack, "invalid byte: 0x" + last_token, "value")));
            }
        }
    }

    /*!
    @brief reads a MessagePack string

    This function first reads starting bytes to determine the expected
    string length and then copies this number of bytes into a string.

    @param[out] result  created string

    @return whether string creation completed
    */
    bool get_msgpack_string(string_t& result)
    {
        if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::msgpack, "string")))
        {
            return false;
        }

        switch (current)
        {
            // fixstr
            case 0xA0:
            case 0xA1:
            case 0xA2:
            case 0xA3:
            case 0xA4:
            case 0xA5:
            case 0xA6:
            case 0xA7:
            case 0xA8:
            case 0xA9:
            case 0xAA:
            case 0xAB:
            case 0xAC:
            case 0xAD:
            case 0xAE:
            case 0xAF:
            case 0xB0:
            case 0xB1:
            case 0xB2:
            case 0xB3:
            case 0xB4:
            case 0xB5:
            case 0xB6:
            case 0xB7:
            case 0xB8:
            case 0xB9:
            case 0xBA:
            case 0xBB:
            case 0xBC:
            case 0xBD:
            case 0xBE:
            case 0xBF:
            {
                return get_string(input_format_t::msgpack, static_cast<unsigned int>(current) & 0x1Fu, result);
            }

            case 0xD9: // str 8
            {
                std::uint8_t len{};
                return get_number(input_format_t::msgpack, len) && get_string(input_format_t::msgpack, len, result);
            }

            case 0xDA: // str 16
            {
                std::uint16_t len{};
                return get_number(input_format_t::msgpack, len) && get_string(input_format_t::msgpack, len, result);
            }

            case 0xDB: // str 32
            {
                std::uint32_t len{};
                return get_number(input_format_t::msgpack, len) && get_string(input_format_t::msgpack, len, result);
            }

            default:
            {
                auto last_token = get_token_string();
                return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, exception_message(input_format_t::msgpack, "expected length specification (0xA0-0xBF, 0xD9-0xDB); last byte: 0x" + last_token, "string")));
            }
        }
    }

    /*!
    @brief reads a MessagePack byte array

    This function first reads starting bytes to determine the expected
    byte array length and then copies this number of bytes into a byte array.

    @param[out] result  created byte array

    @return whether byte array creation completed
    */
    bool get_msgpack_binary(binary_t& result)
    {
        // helper function to set the subtype
        auto assign_and_return_true = [&result](std::int8_t subtype)
        {
            result.set_subtype(static_cast<std::uint8_t>(subtype));
            return true;
        };

        switch (current)
        {
            case 0xC4: // bin 8
            {
                std::uint8_t len{};
                return get_number(input_format_t::msgpack, len) &&
                       get_binary(input_format_t::msgpack, len, result);
            }

            case 0xC5: // bin 16
            {
                std::uint16_t len{};
                return get_number(input_format_t::msgpack, len) &&
                       get_binary(input_format_t::msgpack, len, result);
            }

            case 0xC6: // bin 32
            {
                std::uint32_t len{};
                return get_number(input_format_t::msgpack, len) &&
                       get_binary(input_format_t::msgpack, len, result);
            }

            case 0xC7: // ext 8
            {
                std::uint8_t len{};
                std::int8_t subtype{};
                return get_number(input_format_t::msgpack, len) &&
                       get_number(input_format_t::msgpack, subtype) &&
                       get_binary(input_format_t::msgpack, len, result) &&
                       assign_and_return_true(subtype);
            }

            case 0xC8: // ext 16
            {
                std::uint16_t len{};
                std::int8_t subtype{};
                return get_number(input_format_t::msgpack, len) &&
                       get_number(input_format_t::msgpack, subtype) &&
                       get_binary(input_format_t::msgpack, len, result) &&
                       assign_and_return_true(subtype);
            }

            case 0xC9: // ext 32
            {
                std::uint32_t len{};
                std::int8_t subtype{};
                return get_number(input_format_t::msgpack, len) &&
                       get_number(input_format_t::msgpack, subtype) &&
                       get_binary(input_format_t::msgpack, len, result) &&
                       assign_and_return_true(subtype);
            }

            case 0xD4: // fixext 1
            {
                std::int8_t subtype{};
                return get_number(input_format_t::msgpack, subtype) &&
                       get_binary(input_format_t::msgpack, 1, result) &&
                       assign_and_return_true(subtype);
            }

            case 0xD5: // fixext 2
            {
                std::int8_t subtype{};
                return get_number(input_format_t::msgpack, subtype) &&
                       get_binary(input_format_t::msgpack, 2, result) &&
                       assign_and_return_true(subtype);
            }

            case 0xD6: // fixext 4
            {
                std::int8_t subtype{};
                return get_number(input_format_t::msgpack, subtype) &&
                       get_binary(input_format_t::msgpack, 4, result) &&
                       assign_and_return_true(subtype);
            }

            case 0xD7: // fixext 8
            {
                std::int8_t subtype{};
                return get_number(input_format_t::msgpack, subtype) &&
                       get_binary(input_format_t::msgpack, 8, result) &&
                       assign_and_return_true(subtype);
            }

            case 0xD8: // fixext 16
            {
                std::int8_t subtype{};
                return get_number(input_format_t::msgpack, subtype) &&
                       get_binary(input_format_t::msgpack, 16, result) &&
                       assign_and_return_true(subtype);
            }

            default:           // LCOV_EXCL_LINE
                return false;  // LCOV_EXCL_LINE
        }
    }

    /*!
    @param[in] len  the length of the array
    @return whether array creation completed
    */
    bool get_msgpack_array(const std::size_t len)
    {
        if (JSON_HEDLEY_UNLIKELY(!sax->start_array(len)))
        {
            return false;
        }

        for (std::size_t i = 0; i < len; ++i)
        {
            if (JSON_HEDLEY_UNLIKELY(!parse_msgpack_internal()))
            {
                return false;
            }
        }

        return sax->end_array();
    }

    /*!
    @param[in] len  the length of the object
    @return whether object creation completed
    */
    bool get_msgpack_object(const std::size_t len)
    {
        if (JSON_HEDLEY_UNLIKELY(!sax->start_object(len)))
        {
            return false;
        }

        string_t key;
        for (std::size_t i = 0; i < len; ++i)
        {
            get();
            if (JSON_HEDLEY_UNLIKELY(!get_msgpack_string(key) || !sax->key(key)))
            {
                return false;
            }

            if (JSON_HEDLEY_UNLIKELY(!parse_msgpack_internal()))
            {
                return false;
            }
            key.clear();
        }

        return sax->end_object();
    }

    ////////////
    // UBJSON //
    ////////////

    /*!
    @param[in] get_char  whether a new character should be retrieved from the
                         input (true, default) or whether the last read
                         character should be considered instead

    @return whether a valid UBJSON value was passed to the SAX parser
    */
    bool parse_ubjson_internal(const bool get_char = true)
    {
        return get_ubjson_value(get_char ? get_ignore_noop() : current);
    }

    /*!
    @brief reads a UBJSON string

    This function is either called after reading the 'S' byte explicitly
    indicating a string, or in case of an object key where the 'S' byte can be
    left out.

    @param[out] result   created string
    @param[in] get_char  whether a new character should be retrieved from the
                         input (true, default) or whether the last read
                         character should be considered instead

    @return whether string creation completed
    */
    bool get_ubjson_string(string_t& result, const bool get_char = true)
    {
        if (get_char)
        {
            get();  // TODO(niels): may we ignore N here?
        }

        if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::ubjson, "value")))
        {
            return false;
        }

        switch (current)
        {
            case 'U':
            {
                std::uint8_t len{};
                return get_number(input_format_t::ubjson, len) && get_string(input_format_t::ubjson, len, result);
            }

            case 'i':
            {
                std::int8_t len{};
                return get_number(input_format_t::ubjson, len) && get_string(input_format_t::ubjson, len, result);
            }

            case 'I':
            {
                std::int16_t len{};
                return get_number(input_format_t::ubjson, len) && get_string(input_format_t::ubjson, len, result);
            }

            case 'l':
            {
                std::int32_t len{};
                return get_number(input_format_t::ubjson, len) && get_string(input_format_t::ubjson, len, result);
            }

            case 'L':
            {
                std::int64_t len{};
                return get_number(input_format_t::ubjson, len) && get_string(input_format_t::ubjson, len, result);
            }

            default:
                auto last_token = get_token_string();
                return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, exception_message(input_format_t::ubjson, "expected length type specification (U, i, I, l, L); last byte: 0x" + last_token, "string")));
        }
    }

    /*!
    @param[out] result  determined size
    @return whether size determination completed
    */
    bool get_ubjson_size_value(std::size_t& result)
    {
        switch (get_ignore_noop())
        {
            case 'U':
            {
                std::uint8_t number{};
                if (JSON_HEDLEY_UNLIKELY(!get_number(input_format_t::ubjson, number)))
                {
                    return false;
                }
                result = static_cast<std::size_t>(number);
                return true;
            }

            case 'i':
            {
                std::int8_t number{};
                if (JSON_HEDLEY_UNLIKELY(!get_number(input_format_t::ubjson, number)))
                {
                    return false;
                }
                result = static_cast<std::size_t>(number);
                return true;
            }

            case 'I':
            {
                std::int16_t number{};
                if (JSON_HEDLEY_UNLIKELY(!get_number(input_format_t::ubjson, number)))
                {
                    return false;
                }
                result = static_cast<std::size_t>(number);
                return true;
            }

            case 'l':
            {
                std::int32_t number{};
                if (JSON_HEDLEY_UNLIKELY(!get_number(input_format_t::ubjson, number)))
                {
                    return false;
                }
                result = static_cast<std::size_t>(number);
                return true;
            }

            case 'L':
            {
                std::int64_t number{};
                if (JSON_HEDLEY_UNLIKELY(!get_number(input_format_t::ubjson, number)))
                {
                    return false;
                }
                result = static_cast<std::size_t>(number);
                return true;
            }

            default:
            {
                auto last_token = get_token_string();
                return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, exception_message(input_format_t::ubjson, "expected length type specification (U, i, I, l, L) after '#'; last byte: 0x" + last_token, "size")));
            }
        }
    }

    /*!
    @brief determine the type and size for a container

    In the optimized UBJSON format, a type and a size can be provided to allow
    for a more compact representation.

    @param[out] result  pair of the size and the type

    @return whether pair creation completed
    */
    bool get_ubjson_size_type(std::pair<std::size_t, char_int_type>& result)
    {
        result.first = string_t::npos; // size
        result.second = 0; // type

        get_ignore_noop();

        if (current == '$')
        {
            result.second = get();  // must not ignore 'N', because 'N' maybe the type
            if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::ubjson, "type")))
            {
                return false;
            }

            get_ignore_noop();
            if (JSON_HEDLEY_UNLIKELY(current != '#'))
            {
                if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::ubjson, "value")))
                {
                    return false;
                }
                auto last_token = get_token_string();
                return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read, exception_message(input_format_t::ubjson, "expected '#' after type information; last byte: 0x" + last_token, "size")));
            }

            return get_ubjson_size_value(result.first);
        }

        if (current == '#')
        {
            return get_ubjson_size_value(result.first);
        }

        return true;
    }

    /*!
    @param prefix  the previously read or set type prefix
    @return whether value creation completed
    */
    bool get_ubjson_value(const char_int_type prefix)
    {
        switch (prefix)
        {
            case std::char_traits<char_type>::eof():  // EOF
                return unexpect_eof(input_format_t::ubjson, "value");

            case 'T':  // true
                return sax->boolean(true);
            case 'F':  // false
                return sax->boolean(false);

            case 'Z':  // null
                return sax->null();

            case 'U':
            {
                std::uint8_t number{};
                return get_number(input_format_t::ubjson, number) && sax->number_unsigned(number);
            }

            case 'i':
            {
                std::int8_t number{};
                return get_number(input_format_t::ubjson, number) && sax->number_integer(number);
            }

            case 'I':
            {
                std::int16_t number{};
                return get_number(input_format_t::ubjson, number) && sax->number_integer(number);
            }

            case 'l':
            {
                std::int32_t number{};
                return get_number(input_format_t::ubjson, number) && sax->number_integer(number);
            }

            case 'L':
            {
                std::int64_t number{};
                return get_number(input_format_t::ubjson, number) && sax->number_integer(number);
            }

            case 'd':
            {
                float number{};
                return get_number(input_format_t::ubjson, number) && sax->number_float(static_cast<number_float_t>(number), "");
            }

            case 'D':
            {
                double number{};
                return get_number(input_format_t::ubjson, number) && sax->number_float(static_cast<number_float_t>(number), "");
            }

            case 'H':
            {
                return get_ubjson_high_precision_number();
            }

            case 'C':  // char
            {
                get();
                if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::ubjson, "char")))
                {
                    return false;
                }
                if (JSON_HEDLEY_UNLIKELY(current > 127))
                {
                    auto last_token = get_token_string();
                    return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, exception_message(input_format_t::ubjson, "byte after 'C' must be in range 0x00..0x7F; last byte: 0x" + last_token, "char")));
                }
                string_t s(1, static_cast<typename string_t::value_type>(current));
                return sax->string(s);
            }

            case 'S':  // string
            {
                string_t s;
                return get_ubjson_string(s) && sax->string(s);
            }

            case '[':  // array
                return get_ubjson_array();

            case '{':  // object
                return get_ubjson_object();

            default: // anything else
            {
                auto last_token = get_token_string();
                return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read, exception_message(input_format_t::ubjson, "invalid byte: 0x" + last_token, "value")));
            }
        }
    }

    /*!
    @return whether array creation completed
    */
    bool get_ubjson_array()
    {
        std::pair<std::size_t, char_int_type> size_and_type;
        if (JSON_HEDLEY_UNLIKELY(!get_ubjson_size_type(size_and_type)))
        {
            return false;
        }

        if (size_and_type.first != string_t::npos)
        {
            if (JSON_HEDLEY_UNLIKELY(!sax->start_array(size_and_type.first)))
            {
                return false;
            }

            if (size_and_type.second != 0)
            {
                if (size_and_type.second != 'N')
                {
                    for (std::size_t i = 0; i < size_and_type.first; ++i)
                    {
                        if (JSON_HEDLEY_UNLIKELY(!get_ubjson_value(size_and_type.second)))
                        {
                            return false;
                        }
                    }
                }
            }
            else
            {
                for (std::size_t i = 0; i < size_and_type.first; ++i)
                {
                    if (JSON_HEDLEY_UNLIKELY(!parse_ubjson_internal()))
                    {
                        return false;
                    }
                }
            }
        }
        else
        {
            if (JSON_HEDLEY_UNLIKELY(!sax->start_array(std::size_t(-1))))
            {
                return false;
            }

            while (current != ']')
            {
                if (JSON_HEDLEY_UNLIKELY(!parse_ubjson_internal(false)))
                {
                    return false;
                }
                get_ignore_noop();
            }
        }

        return sax->end_array();
    }

    /*!
    @return whether object creation completed
    */
    bool get_ubjson_object()
    {
        std::pair<std::size_t, char_int_type> size_and_type;
        if (JSON_HEDLEY_UNLIKELY(!get_ubjson_size_type(size_and_type)))
        {
            return false;
        }

        string_t key;
        if (size_and_type.first != string_t::npos)
        {
            if (JSON_HEDLEY_UNLIKELY(!sax->start_object(size_and_type.first)))
            {
                return false;
            }

            if (size_and_type.second != 0)
            {
                for (std::size_t i = 0; i < size_and_type.first; ++i)
                {
                    if (JSON_HEDLEY_UNLIKELY(!get_ubjson_string(key) || !sax->key(key)))
                    {
                        return false;
                    }
                    if (JSON_HEDLEY_UNLIKELY(!get_ubjson_value(size_and_type.second)))
                    {
                        return false;
                    }
                    key.clear();
                }
            }
            else
            {
                for (std::size_t i = 0; i < size_and_type.first; ++i)
                {
                    if (JSON_HEDLEY_UNLIKELY(!get_ubjson_string(key) || !sax->key(key)))
                    {
                        return false;
                    }
                    if (JSON_HEDLEY_UNLIKELY(!parse_ubjson_internal()))
                    {
                        return false;
                    }
                    key.clear();
                }
            }
        }
        else
        {
            if (JSON_HEDLEY_UNLIKELY(!sax->start_object(std::size_t(-1))))
            {
                return false;
            }

            while (current != '}')
            {
                if (JSON_HEDLEY_UNLIKELY(!get_ubjson_string(key, false) || !sax->key(key)))
                {
                    return false;
                }
                if (JSON_HEDLEY_UNLIKELY(!parse_ubjson_internal()))
                {
                    return false;
                }
                get_ignore_noop();
                key.clear();
            }
        }

        return sax->end_object();
    }

    // Note, no reader for UBJSON binary types is implemented because they do
    // not exist

    bool get_ubjson_high_precision_number()
    {
        // get size of following number string
        std::size_t size{};
        auto res = get_ubjson_size_value(size);
        if (JSON_HEDLEY_UNLIKELY(!res))
        {
            return res;
        }

        // get number string
        std::vector<char> number_vector;
        for (std::size_t i = 0; i < size; ++i)
        {
            get();
            if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::ubjson, "number")))
            {
                return false;
            }
            number_vector.push_back(static_cast<char>(current));
        }

        // parse number string
        auto number_ia = detail::input_adapter(std::forward<decltype(number_vector)>(number_vector));
        auto number_lexer = detail::lexer<BasicJsonType, decltype(number_ia)>(std::move(number_ia), false);
        const auto result_number = number_lexer.scan();
        const auto number_string = number_lexer.get_token_string();
        const auto result_remainder = number_lexer.scan();

        using token_type = typename detail::lexer_base<BasicJsonType>::token_type;

        if (JSON_HEDLEY_UNLIKELY(result_remainder != token_type::end_of_input))
        {
            return sax->parse_error(chars_read, number_string, parse_error::create(115, chars_read, exception_message(input_format_t::ubjson, "invalid number text: " + number_lexer.get_token_string(), "high-precision number")));
        }

        switch (result_number)
        {
            case token_type::value_integer:
                return sax->number_integer(number_lexer.get_number_integer());
            case token_type::value_unsigned:
                return sax->number_unsigned(number_lexer.get_number_unsigned());
            case token_type::value_float:
                return sax->number_float(number_lexer.get_number_float(), std::move(number_string));
            default:
                return sax->parse_error(chars_read, number_string, parse_error::create(115, chars_read, exception_message(input_format_t::ubjson, "invalid number text: " + number_lexer.get_token_string(), "high-precision number")));
        }
    }

    ///////////////////////
    // Utility functions //
    ///////////////////////

    /*!
    @brief get next character from the input

    This function provides the interface to the used input adapter. It does
    not throw in case the input reached EOF, but returns a -'ve valued
    `std::char_traits<char_type>::eof()` in that case.

    @return character read from the input
    */
    char_int_type get()
    {
        ++chars_read;
        return current = ia.get_character();
    }

    /*!
    @return character read from the input after ignoring all 'N' entries
    */
    char_int_type get_ignore_noop()
    {
        do
        {
            get();
        }
        while (current == 'N');

        return current;
    }

    /*
    @brief read a number from the input

    @tparam NumberType the type of the number
    @param[in] format   the current format (for diagnostics)
    @param[out] result  number of type @a NumberType

    @return whether conversion completed

    @note This function needs to respect the system's endianess, because
          bytes in CBOR, MessagePack, and UBJSON are stored in network order
          (big endian) and therefore need reordering on little endian systems.
    */
    template<typename NumberType, bool InputIsLittleEndian = false>
    bool get_number(const input_format_t format, NumberType& result)
    {
        // step 1: read input into array with system's byte order
        std::array<std::uint8_t, sizeof(NumberType)> vec;
        for (std::size_t i = 0; i < sizeof(NumberType); ++i)
        {
            get();
            if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(format, "number")))
            {
                return false;
            }

            // reverse byte order prior to conversion if necessary
            if (is_little_endian != InputIsLittleEndian)
            {
                vec[sizeof(NumberType) - i - 1] = static_cast<std::uint8_t>(current);
            }
            else
            {
                vec[i] = static_cast<std::uint8_t>(current); // LCOV_EXCL_LINE
            }
        }

        // step 2: convert array into number of type T and return
        std::memcpy(&result, vec.data(), sizeof(NumberType));
        return true;
    }

    /*!
    @brief create a string by reading characters from the input

    @tparam NumberType the type of the number
    @param[in] format the current format (for diagnostics)
    @param[in] len number of characters to read
    @param[out] result string created by reading @a len bytes

    @return whether string creation completed

    @note We can not reserve @a len bytes for the result, because @a len
          may be too large. Usually, @ref unexpect_eof() detects the end of
          the input before we run out of string memory.
    */
    template<typename NumberType>
    bool get_string(const input_format_t format,
                    const NumberType len,
                    string_t& result)
    {
        bool success = true;
        for (NumberType i = 0; i < len; i++)
        {
            get();
            if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(format, "string")))
            {
                success = false;
                break;
            }
            result.push_back(static_cast<typename string_t::value_type>(current));
        };
        return success;
    }

    /*!
    @brief create a byte array by reading bytes from the input

    @tparam NumberType the type of the number
    @param[in] format the current format (for diagnostics)
    @param[in] len number of bytes to read
    @param[out] result byte array created by reading @a len bytes

    @return whether byte array creation completed

    @note We can not reserve @a len bytes for the result, because @a len
          may be too large. Usually, @ref unexpect_eof() detects the end of
          the input before we run out of memory.
    */
    template<typename NumberType>
    bool get_binary(const input_format_t format,
                    const NumberType len,
                    binary_t& result)
    {
        bool success = true;
        for (NumberType i = 0; i < len; i++)
        {
            get();
            if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(format, "binary")))
            {
                success = false;
                break;
            }
            result.push_back(static_cast<std::uint8_t>(current));
        }
        return success;
    }

    /*!
    @param[in] format   the current format (for diagnostics)
    @param[in] context  further context information (for diagnostics)
    @return whether the last read character is not EOF
    */
    JSON_HEDLEY_NON_NULL(3)
    bool unexpect_eof(const input_format_t format, const char* context) const
    {
        if (JSON_HEDLEY_UNLIKELY(current == std::char_traits<char_type>::eof()))
        {
            return sax->parse_error(chars_read, "<end of file>",
                                    parse_error::create(110, chars_read, exception_message(format, "unexpected end of input", context)));
        }
        return true;
    }

    /*!
    @return a string representation of the last read byte
    */
    std::string get_token_string() const
    {
        std::array<char, 3> cr{{}};
        (std::snprintf)(cr.data(), cr.size(), "%.2hhX", static_cast<unsigned char>(current));
        return std::string{cr.data()};
    }

    /*!
    @param[in] format   the current format
    @param[in] detail   a detailed error message
    @param[in] context  further context information
    @return a message string to use in the parse_error exceptions
    */
    std::string exception_message(const input_format_t format,
                                  const std::string& detail,
                                  const std::string& context) const
    {
        std::string error_msg = "syntax error while parsing ";

        switch (format)
        {
            case input_format_t::cbor:
                error_msg += "CBOR";
                break;

            case input_format_t::msgpack:
                error_msg += "MessagePack";
                break;

            case input_format_t::ubjson:
                error_msg += "UBJSON";
                break;

            case input_format_t::bson:
                error_msg += "BSON";
                break;

            default:            // LCOV_EXCL_LINE
                JSON_ASSERT(false);  // LCOV_EXCL_LINE
        }

        return error_msg + " " + context + ": " + detail;
    }

  private:
    /// input adapter
    InputAdapterType ia;

    /// the current character
    char_int_type current = std::char_traits<char_type>::eof();

    /// the number of characters read
    std::size_t chars_read = 0;

    /// whether we can assume little endianess
    const bool is_little_endian = little_endianess();

    /// the SAX parser
    json_sax_t* sax = nullptr;
};
}  // namespace detail
}  // namespace nlohmann

// #include <nlohmann/detail/input/input_adapters.hpp>

// #include <nlohmann/detail/input/lexer.hpp>

// #include <nlohmann/detail/input/parser.hpp>


#include <cmath> // isfinite
#include <cstdint> // uint8_t
#include <functional> // function
#include <string> // string
#include <utility> // move
#include <vector> // vector

// #include <nlohmann/detail/exceptions.hpp>

// #include <nlohmann/detail/input/input_adapters.hpp>

// #include <nlohmann/detail/input/json_sax.hpp>

// #include <nlohmann/detail/input/lexer.hpp>

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/meta/is_sax.hpp>

// #include <nlohmann/detail/value_t.hpp>


namespace nlohmann
{
namespace detail
{
////////////
// parser //
////////////

enum class parse_event_t : uint8_t
{
    /// the parser read `{` and started to process a JSON object
    object_start,
    /// the parser read `}` and finished processing a JSON object
    object_end,
    /// the parser read `[` and started to process a JSON array
    array_start,
    /// the parser read `]` and finished processing a JSON array
    array_end,
    /// the parser read a key of a value in an object
    key,
    /// the parser finished reading a JSON value
    value
};

template<typename BasicJsonType>
using parser_callback_t =
    std::function<bool(int depth, parse_event_t event, BasicJsonType& parsed)>;

/*!
@brief syntax analysis

This class implements a recursive descent parser.
*/
template<typename BasicJsonType, typename InputAdapterType>
class parser
{
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;
    using lexer_t = lexer<BasicJsonType, InputAdapterType>;
    using token_type = typename lexer_t::token_type;

  public:
    /// a parser reading from an input adapter
    explicit parser(InputAdapterType&& adapter,
                    const parser_callback_t<BasicJsonType> cb = nullptr,
                    const bool allow_exceptions_ = true,
                    const bool skip_comments = false)
        : callback(cb)
        , m_lexer(std::move(adapter), skip_comments)
        , allow_exceptions(allow_exceptions_)
    {
        // read first token
        get_token();
    }

    /*!
    @brief public parser interface

    @param[in] strict      whether to expect the last token to be EOF
    @param[in,out] result  parsed JSON value

    @throw parse_error.101 in case of an unexpected token
    @throw parse_error.102 if to_unicode fails or surrogate error
    @throw parse_error.103 if to_unicode fails
    */
    void parse(const bool strict, BasicJsonType& result)
    {
        if (callback)
        {
            json_sax_dom_callback_parser<BasicJsonType> sdp(result, callback, allow_exceptions);
            sax_parse_internal(&sdp);
            result.assert_invariant();

            // in strict mode, input must be completely read
            if (strict && (get_token() != token_type::end_of_input))
            {
                sdp.parse_error(m_lexer.get_position(),
                                m_lexer.get_token_string(),
                                parse_error::create(101, m_lexer.get_position(),
                                                    exception_message(token_type::end_of_input, "value")));
            }

            // in case of an error, return discarded value
            if (sdp.is_errored())
            {
                result = value_t::discarded;
                return;
            }

            // set top-level value to null if it was discarded by the callback
            // function
            if (result.is_discarded())
            {
                result = nullptr;
            }
        }
        else
        {
            json_sax_dom_parser<BasicJsonType> sdp(result, allow_exceptions);
            sax_parse_internal(&sdp);
            result.assert_invariant();

            // in strict mode, input must be completely read
            if (strict && (get_token() != token_type::end_of_input))
            {
                sdp.parse_error(m_lexer.get_position(),
                                m_lexer.get_token_string(),
                                parse_error::create(101, m_lexer.get_position(),
                                                    exception_message(token_type::end_of_input, "value")));
            }

            // in case of an error, return discarded value
            if (sdp.is_errored())
            {
                result = value_t::discarded;
                return;
            }
        }
    }

    /*!
    @brief public accept interface

    @param[in] strict  whether to expect the last token to be EOF
    @return whether the input is a proper JSON text
    */
    bool accept(const bool strict = true)
    {
        json_sax_acceptor<BasicJsonType> sax_acceptor;
        return sax_parse(&sax_acceptor, strict);
    }

    template<typename SAX>
    JSON_HEDLEY_NON_NULL(2)
    bool sax_parse(SAX* sax, const bool strict = true)
    {
        (void)detail::is_sax_static_asserts<SAX, BasicJsonType> {};
        const bool result = sax_parse_internal(sax);

        // strict mode: next byte must be EOF
        if (result && strict && (get_token() != token_type::end_of_input))
        {
            return sax->parse_error(m_lexer.get_position(),
                                    m_lexer.get_token_string(),
                                    parse_error::create(101, m_lexer.get_position(),
                                            exception_message(token_type::end_of_input, "value")));
        }

        return result;
    }

  private:
    template<typename SAX>
    JSON_HEDLEY_NON_NULL(2)
    bool sax_parse_internal(SAX* sax)
    {
        // stack to remember the hierarchy of structured values we are parsing
        // true = array; false = object
        std::vector<bool> states;
        // value to avoid a goto (see comment where set to true)
        bool skip_to_state_evaluation = false;

        while (true)
        {
            if (!skip_to_state_evaluation)
            {
                // invariant: get_token() was called before each iteration
                switch (last_token)
                {
                    case token_type::begin_object:
                    {
                        if (JSON_HEDLEY_UNLIKELY(!sax->start_object(std::size_t(-1))))
                        {
                            return false;
                        }

                        // closing } -> we are done
                        if (get_token() == token_type::end_object)
                        {
                            if (JSON_HEDLEY_UNLIKELY(!sax->end_object()))
                            {
                                return false;
                            }
                            break;
                        }

                        // parse key
                        if (JSON_HEDLEY_UNLIKELY(last_token != token_type::value_string))
                        {
                            return sax->parse_error(m_lexer.get_position(),
                                                    m_lexer.get_token_string(),
                                                    parse_error::create(101, m_lexer.get_position(),
                                                            exception_message(token_type::value_string, "object key")));
                        }
                        if (JSON_HEDLEY_UNLIKELY(!sax->key(m_lexer.get_string())))
                        {
                            return false;
                        }

                        // parse separator (:)
                        if (JSON_HEDLEY_UNLIKELY(get_token() != token_type::name_separator))
                        {
                            return sax->parse_error(m_lexer.get_position(),
                                                    m_lexer.get_token_string(),
                                                    parse_error::create(101, m_lexer.get_position(),
                                                            exception_message(token_type::name_separator, "object separator")));
                        }

                        // remember we are now inside an object
                        states.push_back(false);

                        // parse values
                        get_token();
                        continue;
                    }

                    case token_type::begin_array:
                    {
                        if (JSON_HEDLEY_UNLIKELY(!sax->start_array(std::size_t(-1))))
                        {
                            return false;
                        }

                        // closing ] -> we are done
                        if (get_token() == token_type::end_array)
                        {
                            if (JSON_HEDLEY_UNLIKELY(!sax->end_array()))
                            {
                                return false;
                            }
                            break;
                        }

                        // remember we are now inside an array
                        states.push_back(true);

                        // parse values (no need to call get_token)
                        continue;
                    }

                    case token_type::value_float:
                    {
                        const auto res = m_lexer.get_number_float();

                        if (JSON_HEDLEY_UNLIKELY(!std::isfinite(res)))
                        {
                            return sax->parse_error(m_lexer.get_position(),
                                                    m_lexer.get_token_string(),
                                                    out_of_range::create(406, "number overflow parsing '" + m_lexer.get_token_string() + "'"));
                        }

                        if (JSON_HEDLEY_UNLIKELY(!sax->number_float(res, m_lexer.get_string())))
                        {
                            return false;
                        }

                        break;
                    }

                    case token_type::literal_false:
                    {
                        if (JSON_HEDLEY_UNLIKELY(!sax->boolean(false)))
                        {
                            return false;
                        }
                        break;
                    }

                    case token_type::literal_null:
                    {
                        if (JSON_HEDLEY_UNLIKELY(!sax->null()))
                        {
                            return false;
                        }
                        break;
                    }

                    case token_type::literal_true:
                    {
                        if (JSON_HEDLEY_UNLIKELY(!sax->boolean(true)))
                        {
                            return false;
                        }
                        break;
                    }

                    case token_type::value_integer:
                    {
                        if (JSON_HEDLEY_UNLIKELY(!sax->number_integer(m_lexer.get_number_integer())))
                        {
                            return false;
                        }
                        break;
                    }

                    case token_type::value_string:
                    {
                        if (JSON_HEDLEY_UNLIKELY(!sax->string(m_lexer.get_string())))
                        {
                            return false;
                        }
                        break;
                    }

                    case token_type::value_unsigned:
                    {
                        if (JSON_HEDLEY_UNLIKELY(!sax->number_unsigned(m_lexer.get_number_unsigned())))
                        {
                            return false;
                        }
                        break;
                    }

                    case token_type::parse_error:
                    {
                        // using "uninitialized" to avoid "expected" message
                        return sax->parse_error(m_lexer.get_position(),
                                                m_lexer.get_token_string(),
                                                parse_error::create(101, m_lexer.get_position(),
                                                        exception_message(token_type::uninitialized, "value")));
                    }

                    default: // the last token was unexpected
                    {
                        return sax->parse_error(m_lexer.get_position(),
                                                m_lexer.get_token_string(),
                                                parse_error::create(101, m_lexer.get_position(),
                                                        exception_message(token_type::literal_or_value, "value")));
                    }
                }
            }
            else
            {
                skip_to_state_evaluation = false;
            }

            // we reached this line after we successfully parsed a value
            if (states.empty())
            {
                // empty stack: we reached the end of the hierarchy: done
                return true;
            }

            if (states.back())  // array
            {
                // comma -> next value
                if (get_token() == token_type::value_separator)
                {
                    // parse a new value
                    get_token();
                    continue;
                }

                // closing ]
                if (JSON_HEDLEY_LIKELY(last_token == token_type::end_array))
                {
                    if (JSON_HEDLEY_UNLIKELY(!sax->end_array()))
                    {
                        return false;
                    }

                    // We are done with this array. Before we can parse a
                    // new value, we need to evaluate the new state first.
                    // By setting skip_to_state_evaluation to false, we
                    // are effectively jumping to the beginning of this if.
                    JSON_ASSERT(!states.empty());
                    states.pop_back();
                    skip_to_state_evaluation = true;
                    continue;
                }

                return sax->parse_error(m_lexer.get_position(),
                                        m_lexer.get_token_string(),
                                        parse_error::create(101, m_lexer.get_position(),
                                                exception_message(token_type::end_array, "array")));
            }
            else  // object
            {
                // comma -> next value
                if (get_token() == token_type::value_separator)
                {
                    // parse key
                    if (JSON_HEDLEY_UNLIKELY(get_token() != token_type::value_string))
                    {
                        return sax->parse_error(m_lexer.get_position(),
                                                m_lexer.get_token_string(),
                                                parse_error::create(101, m_lexer.get_position(),
                                                        exception_message(token_type::value_string, "object key")));
                    }

                    if (JSON_HEDLEY_UNLIKELY(!sax->key(m_lexer.get_string())))
                    {
                        return false;
                    }

                    // parse separator (:)
                    if (JSON_HEDLEY_UNLIKELY(get_token() != token_type::name_separator))
                    {
                        return sax->parse_error(m_lexer.get_position(),
                                                m_lexer.get_token_string(),
                                                parse_error::create(101, m_lexer.get_position(),
                                                        exception_message(token_type::name_separator, "object separator")));
                    }

                    // parse values
                    get_token();
                    continue;
                }

                // closing }
                if (JSON_HEDLEY_LIKELY(last_token == token_type::end_object))
                {
                    if (JSON_HEDLEY_UNLIKELY(!sax->end_object()))
                    {
                        return false;
                    }

                    // We are done with this object. Before we can parse a
                    // new value, we need to evaluate the new state first.
                    // By setting skip_to_state_evaluation to false, we
                    // are effectively jumping to the beginning of this if.
                    JSON_ASSERT(!states.empty());
                    states.pop_back();
                    skip_to_state_evaluation = true;
                    continue;
                }

                return sax->parse_error(m_lexer.get_position(),
                                        m_lexer.get_token_string(),
                                        parse_error::create(101, m_lexer.get_position(),
                                                exception_message(token_type::end_object, "object")));
            }
        }
    }

    /// get next token from lexer
    token_type get_token()
    {
        return last_token = m_lexer.scan();
    }

    std::string exception_message(const token_type expected, const std::string& context)
    {
        std::string error_msg = "syntax error ";

        if (!context.empty())
        {
            error_msg += "while parsing " + context + " ";
        }

        error_msg += "- ";

        if (last_token == token_type::parse_error)
        {
            error_msg += std::string(m_lexer.get_error_message()) + "; last read: '" +
                         m_lexer.get_token_string() + "'";
        }
        else
        {
            error_msg += "unexpected " + std::string(lexer_t::token_type_name(last_token));
        }

        if (expected != token_type::uninitialized)
        {
            error_msg += "; expected " + std::string(lexer_t::token_type_name(expected));
        }

        return error_msg;
    }

  private:
    /// callback function
    const parser_callback_t<BasicJsonType> callback = nullptr;
    /// the type of the last read token
    token_type last_token = token_type::uninitialized;
    /// the lexer
    lexer_t m_lexer;
    /// whether to throw exceptions in case of errors
    const bool allow_exceptions = true;
};
}  // namespace detail
}  // namespace nlohmann

// #include <nlohmann/detail/iterators/internal_iterator.hpp>


// #include <nlohmann/detail/iterators/primitive_iterator.hpp>


#include <cstddef> // ptrdiff_t
#include <limits>  // numeric_limits

namespace nlohmann
{
namespace detail
{
/*
@brief an iterator for primitive JSON types

This class models an iterator for primitive JSON types (boolean, number,
string). It's only purpose is to allow the iterator/const_iterator classes
to "iterate" over primitive values. Internally, the iterator is modeled by
a `difference_type` variable. Value begin_value (`0`) models the begin,
end_value (`1`) models past the end.
*/
class primitive_iterator_t
{
  private:
    using difference_type = std::ptrdiff_t;
    static constexpr difference_type begin_value = 0;
    static constexpr difference_type end_value = begin_value + 1;

    /// iterator as signed integer type
    difference_type m_it = (std::numeric_limits<std::ptrdiff_t>::min)();

  public:
    constexpr difference_type get_value() const noexcept
    {
        return m_it;
    }

    /// set iterator to a defined beginning
    void set_begin() noexcept
    {
        m_it = begin_value;
    }

    /// set iterator to a defined past the end
    void set_end() noexcept
    {
        m_it = end_value;
    }

    /// return whether the iterator can be dereferenced
    constexpr bool is_begin() const noexcept
    {
        return m_it == begin_value;
    }

    /// return whether the iterator is at end
    constexpr bool is_end() const noexcept
    {
        return m_it == end_value;
    }

    friend constexpr bool operator==(primitive_iterator_t lhs, primitive_iterator_t rhs) noexcept
    {
        return lhs.m_it == rhs.m_it;
    }

    friend constexpr bool operator<(primitive_iterator_t lhs, primitive_iterator_t rhs) noexcept
    {
        return lhs.m_it < rhs.m_it;
    }

    primitive_iterator_t operator+(difference_type n) noexcept
    {
        auto result = *this;
        result += n;
        return result;
    }

    friend constexpr difference_type operator-(primitive_iterator_t lhs, primitive_iterator_t rhs) noexcept
    {
        return lhs.m_it - rhs.m_it;
    }

    primitive_iterator_t& operator++() noexcept
    {
        ++m_it;
        return *this;
    }

    primitive_iterator_t const operator++(int) noexcept
    {
        auto result = *this;
        ++m_it;
        return result;
    }

    primitive_iterator_t& operator--() noexcept
    {
        --m_it;
        return *this;
    }

    primitive_iterator_t const operator--(int) noexcept
    {
        auto result = *this;
        --m_it;
        return result;
    }

    primitive_iterator_t& operator+=(difference_type n) noexcept
    {
        m_it += n;
        return *this;
    }

    primitive_iterator_t& operator-=(difference_type n) noexcept
    {
        m_it -= n;
        return *this;
    }
};
}  // namespace detail
}  // namespace nlohmann


namespace nlohmann
{
namespace detail
{
/*!
@brief an iterator value

@note This structure could easily be a union, but MSVC currently does not allow
unions members with complex constructors, see https://github.com/nlohmann/json/pull/105.
*/
template<typename BasicJsonType> struct internal_iterator
{
    /// iterator for JSON objects
    typename BasicJsonType::object_t::iterator object_iterator {};
    /// iterator for JSON arrays
    typename BasicJsonType::array_t::iterator array_iterator {};
    /// generic iterator for all other types
    primitive_iterator_t primitive_iterator {};
};
}  // namespace detail
}  // namespace nlohmann

// #include <nlohmann/detail/iterators/iter_impl.hpp>


#include <iterator> // iterator, random_access_iterator_tag, bidirectional_iterator_tag, advance, next
#include <type_traits> // conditional, is_const, remove_const

// #include <nlohmann/detail/exceptions.hpp>

// #include <nlohmann/detail/iterators/internal_iterator.hpp>

// #include <nlohmann/detail/iterators/primitive_iterator.hpp>

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/meta/cpp_future.hpp>

// #include <nlohmann/detail/meta/type_traits.hpp>

// #include <nlohmann/detail/value_t.hpp>


namespace nlohmann
{
namespace detail
{
// forward declare, to be able to friend it later on
template<typename IteratorType> class iteration_proxy;
template<typename IteratorType> class iteration_proxy_value;

/*!
@brief a template for a bidirectional iterator for the @ref basic_json class
This class implements a both iterators (iterator and const_iterator) for the
@ref basic_json class.
@note An iterator is called *initialized* when a pointer to a JSON value has
      been set (e.g., by a constructor or a copy assignment). If the iterator is
      default-constructed, it is *uninitialized* and most methods are undefined.
      **The library uses assertions to detect calls on uninitialized iterators.**
@requirement The class satisfies the following concept requirements:
-
[BidirectionalIterator](https://en.cppreference.com/w/cpp/named_req/BidirectionalIterator):
  The iterator that can be moved can be moved in both directions (i.e.
  incremented and decremented).
@since version 1.0.0, simplified in version 2.0.9, change to bidirectional
       iterators in version 3.0.0 (see https://github.com/nlohmann/json/issues/593)
*/
template<typename BasicJsonType>
class iter_impl
{
    /// allow basic_json to access private members
    friend iter_impl<typename std::conditional<std::is_const<BasicJsonType>::value, typename std::remove_const<BasicJsonType>::type, const BasicJsonType>::type>;
    friend BasicJsonType;
    friend iteration_proxy<iter_impl>;
    friend iteration_proxy_value<iter_impl>;

    using object_t = typename BasicJsonType::object_t;
    using array_t = typename BasicJsonType::array_t;
    // make sure BasicJsonType is basic_json or const basic_json
    static_assert(is_basic_json<typename std::remove_const<BasicJsonType>::type>::value,
                  "iter_impl only accepts (const) basic_json");

  public:

    /// The std::iterator class template (used as a base class to provide typedefs) is deprecated in C++17.
    /// The C++ Standard has never required user-defined iterators to derive from std::iterator.
    /// A user-defined iterator should provide publicly accessible typedefs named
    /// iterator_category, value_type, difference_type, pointer, and reference.
    /// Note that value_type is required to be non-const, even for constant iterators.
    using iterator_category = std::bidirectional_iterator_tag;

    /// the type of the values when the iterator is dereferenced
    using value_type = typename BasicJsonType::value_type;
    /// a type to represent differences between iterators
    using difference_type = typename BasicJsonType::difference_type;
    /// defines a pointer to the type iterated over (value_type)
    using pointer = typename std::conditional<std::is_const<BasicJsonType>::value,
          typename BasicJsonType::const_pointer,
          typename BasicJsonType::pointer>::type;
    /// defines a reference to the type iterated over (value_type)
    using reference =
        typename std::conditional<std::is_const<BasicJsonType>::value,
        typename BasicJsonType::const_reference,
        typename BasicJsonType::reference>::type;

    /// default constructor
    iter_impl() = default;

    /*!
    @brief constructor for a given JSON instance
    @param[in] object  pointer to a JSON object for this iterator
    @pre object != nullptr
    @post The iterator is initialized; i.e. `m_object != nullptr`.
    */
    explicit iter_impl(pointer object) noexcept : m_object(object)
    {
        JSON_ASSERT(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
            {
                m_it.object_iterator = typename object_t::iterator();
                break;
            }

            case value_t::array:
            {
                m_it.array_iterator = typename array_t::iterator();
                break;
            }

            default:
            {
                m_it.primitive_iterator = primitive_iterator_t();
                break;
            }
        }
    }

    /*!
    @note The conventional copy constructor and copy assignment are implicitly
          defined. Combined with the following converting constructor and
          assignment, they support: (1) copy from iterator to iterator, (2)
          copy from const iterator to const iterator, and (3) conversion from
          iterator to const iterator. However conversion from const iterator
          to iterator is not defined.
    */

    /*!
    @brief const copy constructor
    @param[in] other const iterator to copy from
    @note This copy constructor had to be defined explicitly to circumvent a bug
          occurring on msvc v19.0 compiler (VS 2015) debug build. For more
          information refer to: https://github.com/nlohmann/json/issues/1608
    */
    iter_impl(const iter_impl<const BasicJsonType>& other) noexcept
        : m_object(other.m_object), m_it(other.m_it)
    {}

    /*!
    @brief converting assignment
    @param[in] other const iterator to copy from
    @return const/non-const iterator
    @note It is not checked whether @a other is initialized.
    */
    iter_impl& operator=(const iter_impl<const BasicJsonType>& other) noexcept
    {
        m_object = other.m_object;
        m_it = other.m_it;
        return *this;
    }

    /*!
    @brief converting constructor
    @param[in] other  non-const iterator to copy from
    @note It is not checked whether @a other is initialized.
    */
    iter_impl(const iter_impl<typename std::remove_const<BasicJsonType>::type>& other) noexcept
        : m_object(other.m_object), m_it(other.m_it)
    {}

    /*!
    @brief converting assignment
    @param[in] other  non-const iterator to copy from
    @return const/non-const iterator
    @note It is not checked whether @a other is initialized.
    */
    iter_impl& operator=(const iter_impl<typename std::remove_const<BasicJsonType>::type>& other) noexcept
    {
        m_object = other.m_object;
        m_it = other.m_it;
        return *this;
    }

  private:
    /*!
    @brief set the iterator to the first value
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    void set_begin() noexcept
    {
        JSON_ASSERT(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
            {
                m_it.object_iterator = m_object->m_value.object->begin();
                break;
            }

            case value_t::array:
            {
                m_it.array_iterator = m_object->m_value.array->begin();
                break;
            }

            case value_t::null:
            {
                // set to end so begin()==end() is true: null is empty
                m_it.primitive_iterator.set_end();
                break;
            }

            default:
            {
                m_it.primitive_iterator.set_begin();
                break;
            }
        }
    }

    /*!
    @brief set the iterator past the last value
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    void set_end() noexcept
    {
        JSON_ASSERT(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
            {
                m_it.object_iterator = m_object->m_value.object->end();
                break;
            }

            case value_t::array:
            {
                m_it.array_iterator = m_object->m_value.array->end();
                break;
            }

            default:
            {
                m_it.primitive_iterator.set_end();
                break;
            }
        }
    }

  public:
    /*!
    @brief return a reference to the value pointed to by the iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    reference operator*() const
    {
        JSON_ASSERT(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
            {
                JSON_ASSERT(m_it.object_iterator != m_object->m_value.object->end());
                return m_it.object_iterator->second;
            }

            case value_t::array:
            {
                JSON_ASSERT(m_it.array_iterator != m_object->m_value.array->end());
                return *m_it.array_iterator;
            }

            case value_t::null:
                JSON_THROW(invalid_iterator::create(214, "cannot get value"));

            default:
            {
                if (JSON_HEDLEY_LIKELY(m_it.primitive_iterator.is_begin()))
                {
                    return *m_object;
                }

                JSON_THROW(invalid_iterator::create(214, "cannot get value"));
            }
        }
    }

    /*!
    @brief dereference the iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    pointer operator->() const
    {
        JSON_ASSERT(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
            {
                JSON_ASSERT(m_it.object_iterator != m_object->m_value.object->end());
                return &(m_it.object_iterator->second);
            }

            case value_t::array:
            {
                JSON_ASSERT(m_it.array_iterator != m_object->m_value.array->end());
                return &*m_it.array_iterator;
            }

            default:
            {
                if (JSON_HEDLEY_LIKELY(m_it.primitive_iterator.is_begin()))
                {
                    return m_object;
                }

                JSON_THROW(invalid_iterator::create(214, "cannot get value"));
            }
        }
    }

    /*!
    @brief post-increment (it++)
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl const operator++(int)
    {
        auto result = *this;
        ++(*this);
        return result;
    }

    /*!
    @brief pre-increment (++it)
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl& operator++()
    {
        JSON_ASSERT(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
            {
                std::advance(m_it.object_iterator, 1);
                break;
            }

            case value_t::array:
            {
                std::advance(m_it.array_iterator, 1);
                break;
            }

            default:
            {
                ++m_it.primitive_iterator;
                break;
            }
        }

        return *this;
    }

    /*!
    @brief post-decrement (it--)
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl const operator--(int)
    {
        auto result = *this;
        --(*this);
        return result;
    }

    /*!
    @brief pre-decrement (--it)
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl& operator--()
    {
        JSON_ASSERT(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
            {
                std::advance(m_it.object_iterator, -1);
                break;
            }

            case value_t::array:
            {
                std::advance(m_it.array_iterator, -1);
                break;
            }

            default:
            {
                --m_it.primitive_iterator;
                break;
            }
        }

        return *this;
    }

    /*!
    @brief  comparison: equal
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    bool operator==(const iter_impl& other) const
    {
        // if objects are not the same, the comparison is undefined
        if (JSON_HEDLEY_UNLIKELY(m_object != other.m_object))
        {
            JSON_THROW(invalid_iterator::create(212, "cannot compare iterators of different containers"));
        }

        JSON_ASSERT(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
                return (m_it.object_iterator == other.m_it.object_iterator);

            case value_t::array:
                return (m_it.array_iterator == other.m_it.array_iterator);

            default:
                return (m_it.primitive_iterator == other.m_it.primitive_iterator);
        }
    }

    /*!
    @brief  comparison: not equal
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    bool operator!=(const iter_impl& other) const
    {
        return !operator==(other);
    }

    /*!
    @brief  comparison: smaller
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    bool operator<(const iter_impl& other) const
    {
        // if objects are not the same, the comparison is undefined
        if (JSON_HEDLEY_UNLIKELY(m_object != other.m_object))
        {
            JSON_THROW(invalid_iterator::create(212, "cannot compare iterators of different containers"));
        }

        JSON_ASSERT(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
                JSON_THROW(invalid_iterator::create(213, "cannot compare order of object iterators"));

            case value_t::array:
                return (m_it.array_iterator < other.m_it.array_iterator);

            default:
                return (m_it.primitive_iterator < other.m_it.primitive_iterator);
        }
    }

    /*!
    @brief  comparison: less than or equal
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    bool operator<=(const iter_impl& other) const
    {
        return !other.operator < (*this);
    }

    /*!
    @brief  comparison: greater than
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    bool operator>(const iter_impl& other) const
    {
        return !operator<=(other);
    }

    /*!
    @brief  comparison: greater than or equal
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    bool operator>=(const iter_impl& other) const
    {
        return !operator<(other);
    }

    /*!
    @brief  add to iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl& operator+=(difference_type i)
    {
        JSON_ASSERT(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
                JSON_THROW(invalid_iterator::create(209, "cannot use offsets with object iterators"));

            case value_t::array:
            {
                std::advance(m_it.array_iterator, i);
                break;
            }

            default:
            {
                m_it.primitive_iterator += i;
                break;
            }
        }

        return *this;
    }

    /*!
    @brief  subtract from iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl& operator-=(difference_type i)
    {
        return operator+=(-i);
    }

    /*!
    @brief  add to iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl operator+(difference_type i) const
    {
        auto result = *this;
        result += i;
        return result;
    }

    /*!
    @brief  addition of distance and iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    friend iter_impl operator+(difference_type i, const iter_impl& it)
    {
        auto result = it;
        result += i;
        return result;
    }

    /*!
    @brief  subtract from iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl operator-(difference_type i) const
    {
        auto result = *this;
        result -= i;
        return result;
    }

    /*!
    @brief  return difference
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    difference_type operator-(const iter_impl& other) const
    {
        JSON_ASSERT(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
                JSON_THROW(invalid_iterator::create(209, "cannot use offsets with object iterators"));

            case value_t::array:
                return m_it.array_iterator - other.m_it.array_iterator;

            default:
                return m_it.primitive_iterator - other.m_it.primitive_iterator;
        }
    }

    /*!
    @brief  access to successor
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    reference operator[](difference_type n) const
    {
        JSON_ASSERT(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
                JSON_THROW(invalid_iterator::create(208, "cannot use operator[] for object iterators"));

            case value_t::array:
                return *std::next(m_it.array_iterator, n);

            case value_t::null:
                JSON_THROW(invalid_iterator::create(214, "cannot get value"));

            default:
            {
                if (JSON_HEDLEY_LIKELY(m_it.primitive_iterator.get_value() == -n))
                {
                    return *m_object;
                }

                JSON_THROW(invalid_iterator::create(214, "cannot get value"));
            }
        }
    }

    /*!
    @brief  return the key of an object iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    const typename object_t::key_type& key() const
    {
        JSON_ASSERT(m_object != nullptr);

        if (JSON_HEDLEY_LIKELY(m_object->is_object()))
        {
            return m_it.object_iterator->first;
        }

        JSON_THROW(invalid_iterator::create(207, "cannot use key() for non-object iterators"));
    }

    /*!
    @brief  return the value of an iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    reference value() const
    {
        return operator*();
    }

  private:
    /// associated JSON instance
    pointer m_object = nullptr;
    /// the actual iterator of the associated instance
    internal_iterator<typename std::remove_const<BasicJsonType>::type> m_it {};
};
} // namespace detail
} // namespace nlohmann

// #include <nlohmann/detail/iterators/iteration_proxy.hpp>

// #include <nlohmann/detail/iterators/json_reverse_iterator.hpp>


#include <cstddef> // ptrdiff_t
#include <iterator> // reverse_iterator
#include <utility> // declval

namespace nlohmann
{
namespace detail
{
//////////////////////
// reverse_iterator //
//////////////////////

/*!
@brief a template for a reverse iterator class

@tparam Base the base iterator type to reverse. Valid types are @ref
iterator (to create @ref reverse_iterator) and @ref const_iterator (to
create @ref const_reverse_iterator).

@requirement The class satisfies the following concept requirements:
-
[BidirectionalIterator](https://en.cppreference.com/w/cpp/named_req/BidirectionalIterator):
  The iterator that can be moved can be moved in both directions (i.e.
  incremented and decremented).
- [OutputIterator](https://en.cppreference.com/w/cpp/named_req/OutputIterator):
  It is possible to write to the pointed-to element (only if @a Base is
  @ref iterator).

@since version 1.0.0
*/
template<typename Base>
class json_reverse_iterator : public std::reverse_iterator<Base>
{
  public:
    using difference_type = std::ptrdiff_t;
    /// shortcut to the reverse iterator adapter
    using base_iterator = std::reverse_iterator<Base>;
    /// the reference type for the pointed-to element
    using reference = typename Base::reference;

    /// create reverse iterator from iterator
    explicit json_reverse_iterator(const typename base_iterator::iterator_type& it) noexcept
        : base_iterator(it) {}

    /// create reverse iterator from base class
    explicit json_reverse_iterator(const base_iterator& it) noexcept : base_iterator(it) {}

    /// post-increment (it++)
    json_reverse_iterator const operator++(int)
    {
        return static_cast<json_reverse_iterator>(base_iterator::operator++(1));
    }

    /// pre-increment (++it)
    json_reverse_iterator& operator++()
    {
        return static_cast<json_reverse_iterator&>(base_iterator::operator++());
    }

    /// post-decrement (it--)
    json_reverse_iterator const operator--(int)
    {
        return static_cast<json_reverse_iterator>(base_iterator::operator--(1));
    }

    /// pre-decrement (--it)
    json_reverse_iterator& operator--()
    {
        return static_cast<json_reverse_iterator&>(base_iterator::operator--());
    }

    /// add to iterator
    json_reverse_iterator& operator+=(difference_type i)
    {
        return static_cast<json_reverse_iterator&>(base_iterator::operator+=(i));
    }

    /// add to iterator
    json_reverse_iterator operator+(difference_type i) const
    {
        return static_cast<json_reverse_iterator>(base_iterator::operator+(i));
    }

    /// subtract from iterator
    json_reverse_iterator operator-(difference_type i) const
    {
        return static_cast<json_reverse_iterator>(base_iterator::operator-(i));
    }

    /// return difference
    difference_type operator-(const json_reverse_iterator& other) const
    {
        return base_iterator(*this) - base_iterator(other);
    }

    /// access to successor
    reference operator[](difference_type n) const
    {
        return *(this->operator+(n));
    }

    /// return the key of an object iterator
    auto key() const -> decltype(std::declval<Base>().key())
    {
        auto it = --this->base();
        return it.key();
    }

    /// return the value of an iterator
    reference value() const
    {
        auto it = --this->base();
        return it.operator * ();
    }
};
}  // namespace detail
}  // namespace nlohmann

// #include <nlohmann/detail/iterators/primitive_iterator.hpp>

// #include <nlohmann/detail/json_pointer.hpp>


#include <algorithm> // all_of
#include <cctype> // isdigit
#include <limits> // max
#include <numeric> // accumulate
#include <string> // string
#include <utility> // move
#include <vector> // vector

// #include <nlohmann/detail/exceptions.hpp>

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/value_t.hpp>


namespace nlohmann
{
template<typename BasicJsonType>
class json_pointer
{
    // allow basic_json to access private members
    NLOHMANN_BASIC_JSON_TPL_DECLARATION
    friend class basic_json;

  public:
    /*!
    @brief create JSON pointer

    Create a JSON pointer according to the syntax described in
    [Section 3 of RFC6901](https://tools.ietf.org/html/rfc6901#section-3).

    @param[in] s  string representing the JSON pointer; if omitted, the empty
                  string is assumed which references the whole JSON value

    @throw parse_error.107 if the given JSON pointer @a s is nonempty and does
                           not begin with a slash (`/`); see example below

    @throw parse_error.108 if a tilde (`~`) in the given JSON pointer @a s is
    not followed by `0` (representing `~`) or `1` (representing `/`); see
    example below

    @liveexample{The example shows the construction several valid JSON pointers
    as well as the exceptional behavior.,json_pointer}

    @since version 2.0.0
    */
    explicit json_pointer(const std::string& s = "")
        : reference_tokens(split(s))
    {}

    /*!
    @brief return a string representation of the JSON pointer

    @invariant For each JSON pointer `ptr`, it holds:
    @code {.cpp}
    ptr == json_pointer(ptr.to_string());
    @endcode

    @return a string representation of the JSON pointer

    @liveexample{The example shows the result of `to_string`.,json_pointer__to_string}

    @since version 2.0.0
    */
    std::string to_string() const
    {
        return std::accumulate(reference_tokens.begin(), reference_tokens.end(),
                               std::string{},
                               [](const std::string & a, const std::string & b)
        {
            return a + "/" + escape(b);
        });
    }

    /// @copydoc to_string()
    operator std::string() const
    {
        return to_string();
    }

    /*!
    @brief append another JSON pointer at the end of this JSON pointer

    @param[in] ptr  JSON pointer to append
    @return JSON pointer with @a ptr appended

    @liveexample{The example shows the usage of `operator/=`.,json_pointer__operator_add}

    @complexity Linear in the length of @a ptr.

    @sa @ref operator/=(std::string) to append a reference token
    @sa @ref operator/=(std::size_t) to append an array index
    @sa @ref operator/(const json_pointer&, const json_pointer&) for a binary operator

    @since version 3.6.0
    */
    json_pointer& operator/=(const json_pointer& ptr)
    {
        reference_tokens.insert(reference_tokens.end(),
                                ptr.reference_tokens.begin(),
                                ptr.reference_tokens.end());
        return *this;
    }

    /*!
    @brief append an unescaped reference token at the end of this JSON pointer

    @param[in] token  reference token to append
    @return JSON pointer with @a token appended without escaping @a token

    @liveexample{The example shows the usage of `operator/=`.,json_pointer__operator_add}

    @complexity Amortized constant.

    @sa @ref operator/=(const json_pointer&) to append a JSON pointer
    @sa @ref operator/=(std::size_t) to append an array index
    @sa @ref operator/(const json_pointer&, std::size_t) for a binary operator

    @since version 3.6.0
    */
    json_pointer& operator/=(std::string token)
    {
        push_back(std::move(token));
        return *this;
    }

    /*!
    @brief append an array index at the end of this JSON pointer

    @param[in] array_idx  array index to append
    @return JSON pointer with @a array_idx appended

    @liveexample{The example shows the usage of `operator/=`.,json_pointer__operator_add}

    @complexity Amortized constant.

    @sa @ref operator/=(const json_pointer&) to append a JSON pointer
    @sa @ref operator/=(std::string) to append a reference token
    @sa @ref operator/(const json_pointer&, std::string) for a binary operator

    @since version 3.6.0
    */
    json_pointer& operator/=(std::size_t array_idx)
    {
        return *this /= std::to_string(array_idx);
    }

    /*!
    @brief create a new JSON pointer by appending the right JSON pointer at the end of the left JSON pointer

    @param[in] lhs  JSON pointer
    @param[in] rhs  JSON pointer
    @return a new JSON pointer with @a rhs appended to @a lhs

    @liveexample{The example shows the usage of `operator/`.,json_pointer__operator_add_binary}

    @complexity Linear in the length of @a lhs and @a rhs.

    @sa @ref operator/=(const json_pointer&) to append a JSON pointer

    @since version 3.6.0
    */
    friend json_pointer operator/(const json_pointer& lhs,
                                  const json_pointer& rhs)
    {
        return json_pointer(lhs) /= rhs;
    }

    /*!
    @brief create a new JSON pointer by appending the unescaped token at the end of the JSON pointer

    @param[in] ptr  JSON pointer
    @param[in] token  reference token
    @return a new JSON pointer with unescaped @a token appended to @a ptr

    @liveexample{The example shows the usage of `operator/`.,json_pointer__operator_add_binary}

    @complexity Linear in the length of @a ptr.

    @sa @ref operator/=(std::string) to append a reference token

    @since version 3.6.0
    */
    friend json_pointer operator/(const json_pointer& ptr, std::string token)
    {
        return json_pointer(ptr) /= std::move(token);
    }

    /*!
    @brief create a new JSON pointer by appending the array-index-token at the end of the JSON pointer

    @param[in] ptr  JSON pointer
    @param[in] array_idx  array index
    @return a new JSON pointer with @a array_idx appended to @a ptr

    @liveexample{The example shows the usage of `operator/`.,json_pointer__operator_add_binary}

    @complexity Linear in the length of @a ptr.

    @sa @ref operator/=(std::size_t) to append an array index

    @since version 3.6.0
    */
    friend json_pointer operator/(const json_pointer& ptr, std::size_t array_idx)
    {
        return json_pointer(ptr) /= array_idx;
    }

    /*!
    @brief returns the parent of this JSON pointer

    @return parent of this JSON pointer; in case this JSON pointer is the root,
            the root itself is returned

    @complexity Linear in the length of the JSON pointer.

    @liveexample{The example shows the result of `parent_pointer` for different
    JSON Pointers.,json_pointer__parent_pointer}

    @since version 3.6.0
    */
    json_pointer parent_pointer() const
    {
        if (empty())
        {
            return *this;
        }

        json_pointer res = *this;
        res.pop_back();
        return res;
    }

    /*!
    @brief remove last reference token

    @pre not `empty()`

    @liveexample{The example shows the usage of `pop_back`.,json_pointer__pop_back}

    @complexity Constant.

    @throw out_of_range.405 if JSON pointer has no parent

    @since version 3.6.0
    */
    void pop_back()
    {
        if (JSON_HEDLEY_UNLIKELY(empty()))
        {
            JSON_THROW(detail::out_of_range::create(405, "JSON pointer has no parent"));
        }

        reference_tokens.pop_back();
    }

    /*!
    @brief return last reference token

    @pre not `empty()`
    @return last reference token

    @liveexample{The example shows the usage of `back`.,json_pointer__back}

    @complexity Constant.

    @throw out_of_range.405 if JSON pointer has no parent

    @since version 3.6.0
    */
    const std::string& back() const
    {
        if (JSON_HEDLEY_UNLIKELY(empty()))
        {
            JSON_THROW(detail::out_of_range::create(405, "JSON pointer has no parent"));
        }

        return reference_tokens.back();
    }

    /*!
    @brief append an unescaped token at the end of the reference pointer

    @param[in] token  token to add

    @complexity Amortized constant.

    @liveexample{The example shows the result of `push_back` for different
    JSON Pointers.,json_pointer__push_back}

    @since version 3.6.0
    */
    void push_back(const std::string& token)
    {
        reference_tokens.push_back(token);
    }

    /// @copydoc push_back(const std::string&)
    void push_back(std::string&& token)
    {
        reference_tokens.push_back(std::move(token));
    }

    /*!
    @brief return whether pointer points to the root document

    @return true iff the JSON pointer points to the root document

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this function never throws exceptions.

    @liveexample{The example shows the result of `empty` for different JSON
    Pointers.,json_pointer__empty}

    @since version 3.6.0
    */
    bool empty() const noexcept
    {
        return reference_tokens.empty();
    }

  private:
    /*!
    @param[in] s  reference token to be converted into an array index

    @return integer representation of @a s

    @throw parse_error.106  if an array index begins with '0'
    @throw parse_error.109  if an array index begins not with a digit
    @throw out_of_range.404 if string @a s could not be converted to an integer
    @throw out_of_range.410 if an array index exceeds size_type
    */
    static typename BasicJsonType::size_type array_index(const std::string& s)
    {
        using size_type = typename BasicJsonType::size_type;

        // error condition (cf. RFC 6901, Sect. 4)
        if (JSON_HEDLEY_UNLIKELY(s.size() > 1 && s[0] == '0'))
        {
            JSON_THROW(detail::parse_error::create(106, 0,
                                                   "array index '" + s +
                                                   "' must not begin with '0'"));
        }

        // error condition (cf. RFC 6901, Sect. 4)
        if (JSON_HEDLEY_UNLIKELY(s.size() > 1 && !(s[0] >= '1' && s[0] <= '9')))
        {
            JSON_THROW(detail::parse_error::create(109, 0, "array index '" + s + "' is not a number"));
        }

        std::size_t processed_chars = 0;
        unsigned long long res = 0;
        JSON_TRY
        {
            res = std::stoull(s, &processed_chars);
        }
        JSON_CATCH(std::out_of_range&)
        {
            JSON_THROW(detail::out_of_range::create(404, "unresolved reference token '" + s + "'"));
        }

        // check if the string was completely read
        if (JSON_HEDLEY_UNLIKELY(processed_chars != s.size()))
        {
            JSON_THROW(detail::out_of_range::create(404, "unresolved reference token '" + s + "'"));
        }

        // only triggered on special platforms (like 32bit), see also
        // https://github.com/nlohmann/json/pull/2203
        if (res >= static_cast<unsigned long long>((std::numeric_limits<size_type>::max)()))
        {
            JSON_THROW(detail::out_of_range::create(410, "array index " + s + " exceeds size_type")); // LCOV_EXCL_LINE
        }

        return static_cast<size_type>(res);
    }

    json_pointer top() const
    {
        if (JSON_HEDLEY_UNLIKELY(empty()))
        {
            JSON_THROW(detail::out_of_range::create(405, "JSON pointer has no parent"));
        }

        json_pointer result = *this;
        result.reference_tokens = {reference_tokens[0]};
        return result;
    }

    /*!
    @brief create and return a reference to the pointed to value

    @complexity Linear in the number of reference tokens.

    @throw parse_error.109 if array index is not a number
    @throw type_error.313 if value cannot be unflattened
    */
    BasicJsonType& get_and_create(BasicJsonType& j) const
    {
        auto result = &j;

        // in case no reference tokens exist, return a reference to the JSON value
        // j which will be overwritten by a primitive value
        for (const auto& reference_token : reference_tokens)
        {
            switch (result->type())
            {
                case detail::value_t::null:
                {
                    if (reference_token == "0")
                    {
                        // start a new array if reference token is 0
                        result = &result->operator[](0);
                    }
                    else
                    {
                        // start a new object otherwise
                        result = &result->operator[](reference_token);
                    }
                    break;
                }

                case detail::value_t::object:
                {
                    // create an entry in the object
                    result = &result->operator[](reference_token);
                    break;
                }

                case detail::value_t::array:
                {
                    // create an entry in the array
                    result = &result->operator[](array_index(reference_token));
                    break;
                }

                /*
                The following code is only reached if there exists a reference
                token _and_ the current value is primitive. In this case, we have
                an error situation, because primitive values may only occur as
                single value; that is, with an empty list of reference tokens.
                */
                default:
                    JSON_THROW(detail::type_error::create(313, "invalid value to unflatten"));
            }
        }

        return *result;
    }

    /*!
    @brief return a reference to the pointed to value

    @note This version does not throw if a value is not present, but tries to
          create nested values instead. For instance, calling this function
          with pointer `"/this/that"` on a null value is equivalent to calling
          `operator[]("this").operator[]("that")` on that value, effectively
          changing the null value to an object.

    @param[in] ptr  a JSON value

    @return reference to the JSON value pointed to by the JSON pointer

    @complexity Linear in the length of the JSON pointer.

    @throw parse_error.106   if an array index begins with '0'
    @throw parse_error.109   if an array index was not a number
    @throw out_of_range.404  if the JSON pointer can not be resolved
    */
    BasicJsonType& get_unchecked(BasicJsonType* ptr) const
    {
        for (const auto& reference_token : reference_tokens)
        {
            // convert null values to arrays or objects before continuing
            if (ptr->is_null())
            {
                // check if reference token is a number
                const bool nums =
                    std::all_of(reference_token.begin(), reference_token.end(),
                                [](const unsigned char x)
                {
                    return std::isdigit(x);
                });

                // change value to array for numbers or "-" or to object otherwise
                *ptr = (nums || reference_token == "-")
                       ? detail::value_t::array
                       : detail::value_t::object;
            }

            switch (ptr->type())
            {
                case detail::value_t::object:
                {
                    // use unchecked object access
                    ptr = &ptr->operator[](reference_token);
                    break;
                }

                case detail::value_t::array:
                {
                    if (reference_token == "-")
                    {
                        // explicitly treat "-" as index beyond the end
                        ptr = &ptr->operator[](ptr->m_value.array->size());
                    }
                    else
                    {
                        // convert array index to number; unchecked access
                        ptr = &ptr->operator[](array_index(reference_token));
                    }
                    break;
                }

                default:
                    JSON_THROW(detail::out_of_range::create(404, "unresolved reference token '" + reference_token + "'"));
            }
        }

        return *ptr;
    }

    /*!
    @throw parse_error.106   if an array index begins with '0'
    @throw parse_error.109   if an array index was not a number
    @throw out_of_range.402  if the array index '-' is used
    @throw out_of_range.404  if the JSON pointer can not be resolved
    */
    BasicJsonType& get_checked(BasicJsonType* ptr) const
    {
        for (const auto& reference_token : reference_tokens)
        {
            switch (ptr->type())
            {
                case detail::value_t::object:
                {
                    // note: at performs range check
                    ptr = &ptr->at(reference_token);
                    break;
                }

                case detail::value_t::array:
                {
                    if (JSON_HEDLEY_UNLIKELY(reference_token == "-"))
                    {
                        // "-" always fails the range check
                        JSON_THROW(detail::out_of_range::create(402,
                                                                "array index '-' (" + std::to_string(ptr->m_value.array->size()) +
                                                                ") is out of range"));
                    }

                    // note: at performs range check
                    ptr = &ptr->at(array_index(reference_token));
                    break;
                }

                default:
                    JSON_THROW(detail::out_of_range::create(404, "unresolved reference token '" + reference_token + "'"));
            }
        }

        return *ptr;
    }

    /*!
    @brief return a const reference to the pointed to value

    @param[in] ptr  a JSON value

    @return const reference to the JSON value pointed to by the JSON
    pointer

    @throw parse_error.106   if an array index begins with '0'
    @throw parse_error.109   if an array index was not a number
    @throw out_of_range.402  if the array index '-' is used
    @throw out_of_range.404  if the JSON pointer can not be resolved
    */
    const BasicJsonType& get_unchecked(const BasicJsonType* ptr) const
    {
        for (const auto& reference_token : reference_tokens)
        {
            switch (ptr->type())
            {
                case detail::value_t::object:
                {
                    // use unchecked object access
                    ptr = &ptr->operator[](reference_token);
                    break;
                }

                case detail::value_t::array:
                {
                    if (JSON_HEDLEY_UNLIKELY(reference_token == "-"))
                    {
                        // "-" cannot be used for const access
                        JSON_THROW(detail::out_of_range::create(402,
                                                                "array index '-' (" + std::to_string(ptr->m_value.array->size()) +
                                                                ") is out of range"));
                    }

                    // use unchecked array access
                    ptr = &ptr->operator[](array_index(reference_token));
                    break;
                }

                default:
                    JSON_THROW(detail::out_of_range::create(404, "unresolved reference token '" + reference_token + "'"));
            }
        }

        return *ptr;
    }

    /*!
    @throw parse_error.106   if an array index begins with '0'
    @throw parse_error.109   if an array index was not a number
    @throw out_of_range.402  if the array index '-' is used
    @throw out_of_range.404  if the JSON pointer can not be resolved
    */
    const BasicJsonType& get_checked(const BasicJsonType* ptr) const
    {
        for (const auto& reference_token : reference_tokens)
        {
            switch (ptr->type())
            {
                case detail::value_t::object:
                {
                    // note: at performs range check
                    ptr = &ptr->at(reference_token);
                    break;
                }

                case detail::value_t::array:
                {
                    if (JSON_HEDLEY_UNLIKELY(reference_token == "-"))
                    {
                        // "-" always fails the range check
                        JSON_THROW(detail::out_of_range::create(402,
                                                                "array index '-' (" + std::to_string(ptr->m_value.array->size()) +
                                                                ") is out of range"));
                    }

                    // note: at performs range check
                    ptr = &ptr->at(array_index(reference_token));
                    break;
                }

                default:
                    JSON_THROW(detail::out_of_range::create(404, "unresolved reference token '" + reference_token + "'"));
            }
        }

        return *ptr;
    }

    /*!
    @throw parse_error.106   if an array index begins with '0'
    @throw parse_error.109   if an array index was not a number
    */
    bool contains(const BasicJsonType* ptr) const
    {
        for (const auto& reference_token : reference_tokens)
        {
            switch (ptr->type())
            {
                case detail::value_t::object:
                {
                    if (!ptr->contains(reference_token))
                    {
                        // we did not find the key in the object
                        return false;
                    }

                    ptr = &ptr->operator[](reference_token);
                    break;
                }

                case detail::value_t::array:
                {
                    if (JSON_HEDLEY_UNLIKELY(reference_token == "-"))
                    {
                        // "-" always fails the range check
                        return false;
                    }
                    if (JSON_HEDLEY_UNLIKELY(reference_token.size() == 1 && !("0" <= reference_token && reference_token <= "9")))
                    {
                        // invalid char
                        return false;
                    }
                    if (JSON_HEDLEY_UNLIKELY(reference_token.size() > 1))
                    {
                        if (JSON_HEDLEY_UNLIKELY(!('1' <= reference_token[0] && reference_token[0] <= '9')))
                        {
                            // first char should be between '1' and '9'
                            return false;
                        }
                        for (std::size_t i = 1; i < reference_token.size(); i++)
                        {
                            if (JSON_HEDLEY_UNLIKELY(!('0' <= reference_token[i] && reference_token[i] <= '9')))
                            {
                                // other char should be between '0' and '9'
                                return false;
                            }
                        }
                    }

                    const auto idx = array_index(reference_token);
                    if (idx >= ptr->size())
                    {
                        // index out of range
                        return false;
                    }

                    ptr = &ptr->operator[](idx);
                    break;
                }

                default:
                {
                    // we do not expect primitive values if there is still a
                    // reference token to process
                    return false;
                }
            }
        }

        // no reference token left means we found a primitive value
        return true;
    }

    /*!
    @brief split the string input to reference tokens

    @note This function is only called by the json_pointer constructor.
          All exceptions below are documented there.

    @throw parse_error.107  if the pointer is not empty or begins with '/'
    @throw parse_error.108  if character '~' is not followed by '0' or '1'
    */
    static std::vector<std::string> split(const std::string& reference_string)
    {
        std::vector<std::string> result;

        // special case: empty reference string -> no reference tokens
        if (reference_string.empty())
        {
            return result;
        }

        // check if nonempty reference string begins with slash
        if (JSON_HEDLEY_UNLIKELY(reference_string[0] != '/'))
        {
            JSON_THROW(detail::parse_error::create(107, 1,
                                                   "JSON pointer must be empty or begin with '/' - was: '" +
                                                   reference_string + "'"));
        }

        // extract the reference tokens:
        // - slash: position of the last read slash (or end of string)
        // - start: position after the previous slash
        for (
            // search for the first slash after the first character
            std::size_t slash = reference_string.find_first_of('/', 1),
            // set the beginning of the first reference token
            start = 1;
            // we can stop if start == 0 (if slash == std::string::npos)
            start != 0;
            // set the beginning of the next reference token
            // (will eventually be 0 if slash == std::string::npos)
            start = (slash == std::string::npos) ? 0 : slash + 1,
            // find next slash
            slash = reference_string.find_first_of('/', start))
        {
            // use the text between the beginning of the reference token
            // (start) and the last slash (slash).
            auto reference_token = reference_string.substr(start, slash - start);

            // check reference tokens are properly escaped
            for (std::size_t pos = reference_token.find_first_of('~');
                    pos != std::string::npos;
                    pos = reference_token.find_first_of('~', pos + 1))
            {
                JSON_ASSERT(reference_token[pos] == '~');

                // ~ must be followed by 0 or 1
                if (JSON_HEDLEY_UNLIKELY(pos == reference_token.size() - 1 ||
                                         (reference_token[pos + 1] != '0' &&
                                          reference_token[pos + 1] != '1')))
                {
                    JSON_THROW(detail::parse_error::create(108, 0, "escape character '~' must be followed with '0' or '1'"));
                }
            }

            // finally, store the reference token
            unescape(reference_token);
            result.push_back(reference_token);
        }

        return result;
    }

    /*!
    @brief replace all occurrences of a substring by another string

    @param[in,out] s  the string to manipulate; changed so that all
                   occurrences of @a f are replaced with @a t
    @param[in]     f  the substring to replace with @a t
    @param[in]     t  the string to replace @a f

    @pre The search string @a f must not be empty. **This precondition is
    enforced with an assertion.**

    @since version 2.0.0
    */
    static void replace_substring(std::string& s, const std::string& f,
                                  const std::string& t)
    {
        JSON_ASSERT(!f.empty());
        for (auto pos = s.find(f);                // find first occurrence of f
                pos != std::string::npos;         // make sure f was found
                s.replace(pos, f.size(), t),      // replace with t, and
                pos = s.find(f, pos + t.size()))  // find next occurrence of f
        {}
    }

    /// escape "~" to "~0" and "/" to "~1"
    static std::string escape(std::string s)
    {
        replace_substring(s, "~", "~0");
        replace_substring(s, "/", "~1");
        return s;
    }

    /// unescape "~1" to tilde and "~0" to slash (order is important!)
    static void unescape(std::string& s)
    {
        replace_substring(s, "~1", "/");
        replace_substring(s, "~0", "~");
    }

    /*!
    @param[in] reference_string  the reference string to the current value
    @param[in] value             the value to consider
    @param[in,out] result        the result object to insert values to

    @note Empty objects or arrays are flattened to `null`.
    */
    static void flatten(const std::string& reference_string,
                        const BasicJsonType& value,
                        BasicJsonType& result)
    {
        switch (value.type())
        {
            case detail::value_t::array:
            {
                if (value.m_value.array->empty())
                {
                    // flatten empty array as null
                    result[reference_string] = nullptr;
                }
                else
                {
                    // iterate array and use index as reference string
                    for (std::size_t i = 0; i < value.m_value.array->size(); ++i)
                    {
                        flatten(reference_string + "/" + std::to_string(i),
                                value.m_value.array->operator[](i), result);
                    }
                }
                break;
            }

            case detail::value_t::object:
            {
                if (value.m_value.object->empty())
                {
                    // flatten empty object as null
                    result[reference_string] = nullptr;
                }
                else
                {
                    // iterate object and use keys as reference string
                    for (const auto& element : *value.m_value.object)
                    {
                        flatten(reference_string + "/" + escape(element.first), element.second, result);
                    }
                }
                break;
            }

            default:
            {
                // add primitive value with its reference string
                result[reference_string] = value;
                break;
            }
        }
    }

    /*!
    @param[in] value  flattened JSON

    @return unflattened JSON

    @throw parse_error.109 if array index is not a number
    @throw type_error.314  if value is not an object
    @throw type_error.315  if object values are not primitive
    @throw type_error.313  if value cannot be unflattened
    */
    static BasicJsonType
    unflatten(const BasicJsonType& value)
    {
        if (JSON_HEDLEY_UNLIKELY(!value.is_object()))
        {
            JSON_THROW(detail::type_error::create(314, "only objects can be unflattened"));
        }

        BasicJsonType result;

        // iterate the JSON object values
        for (const auto& element : *value.m_value.object)
        {
            if (JSON_HEDLEY_UNLIKELY(!element.second.is_primitive()))
            {
                JSON_THROW(detail::type_error::create(315, "values in object must be primitive"));
            }

            // assign value to reference pointed to by JSON pointer; Note that if
            // the JSON pointer is "" (i.e., points to the whole value), function
            // get_and_create returns a reference to result itself. An assignment
            // will then create a primitive value.
            json_pointer(element.first).get_and_create(result) = element.second;
        }

        return result;
    }

    /*!
    @brief compares two JSON pointers for equality

    @param[in] lhs  JSON pointer to compare
    @param[in] rhs  JSON pointer to compare
    @return whether @a lhs is equal to @a rhs

    @complexity Linear in the length of the JSON pointer

    @exceptionsafety No-throw guarantee: this function never throws exceptions.
    */
    friend bool operator==(json_pointer const& lhs,
                           json_pointer const& rhs) noexcept
    {
        return lhs.reference_tokens == rhs.reference_tokens;
    }

    /*!
    @brief compares two JSON pointers for inequality

    @param[in] lhs  JSON pointer to compare
    @param[in] rhs  JSON pointer to compare
    @return whether @a lhs is not equal @a rhs

    @complexity Linear in the length of the JSON pointer

    @exceptionsafety No-throw guarantee: this function never throws exceptions.
    */
    friend bool operator!=(json_pointer const& lhs,
                           json_pointer const& rhs) noexcept
    {
        return !(lhs == rhs);
    }

    /// the reference tokens
    std::vector<std::string> reference_tokens;
};
}  // namespace nlohmann

// #include <nlohmann/detail/json_ref.hpp>


#include <initializer_list>
#include <utility>

// #include <nlohmann/detail/meta/type_traits.hpp>


namespace nlohmann
{
namespace detail
{
template<typename BasicJsonType>
class json_ref
{
  public:
    using value_type = BasicJsonType;

    json_ref(value_type&& value)
        : owned_value(std::move(value))
        , value_ref(&owned_value)
        , is_rvalue(true)
    {}

    json_ref(const value_type& value)
        : value_ref(const_cast<value_type*>(&value))
        , is_rvalue(false)
    {}

    json_ref(std::initializer_list<json_ref> init)
        : owned_value(init)
        , value_ref(&owned_value)
        , is_rvalue(true)
    {}

    template <
        class... Args,
        enable_if_t<std::is_constructible<value_type, Args...>::value, int> = 0 >
    json_ref(Args && ... args)
        : owned_value(std::forward<Args>(args)...)
        , value_ref(&owned_value)
        , is_rvalue(true)
    {}

    // class should be movable only
    json_ref(json_ref&&) = default;
    json_ref(const json_ref&) = delete;
    json_ref& operator=(const json_ref&) = delete;
    json_ref& operator=(json_ref&&) = delete;
    ~json_ref() = default;

    value_type moved_or_copied() const
    {
        if (is_rvalue)
        {
            return std::move(*value_ref);
        }
        return *value_ref;
    }

    value_type const& operator*() const
    {
        return *static_cast<value_type const*>(value_ref);
    }

    value_type const* operator->() const
    {
        return static_cast<value_type const*>(value_ref);
    }

  private:
    mutable value_type owned_value = nullptr;
    value_type* value_ref = nullptr;
    const bool is_rvalue = true;
};
}  // namespace detail
}  // namespace nlohmann

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/meta/cpp_future.hpp>

// #include <nlohmann/detail/meta/type_traits.hpp>

// #include <nlohmann/detail/output/binary_writer.hpp>


#include <algorithm> // reverse
#include <array> // array
#include <cstdint> // uint8_t, uint16_t, uint32_t, uint64_t
#include <cstring> // memcpy
#include <limits> // numeric_limits
#include <string> // string
#include <cmath> // isnan, isinf

// #include <nlohmann/detail/input/binary_reader.hpp>

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/output/output_adapters.hpp>


#include <algorithm> // copy
#include <cstddef> // size_t
#include <ios> // streamsize
#include <iterator> // back_inserter
#include <memory> // shared_ptr, make_shared
#include <ostream> // basic_ostream
#include <string> // basic_string
#include <vector> // vector
// #include <nlohmann/detail/macro_scope.hpp>


namespace nlohmann
{
namespace detail
{
/// abstract output adapter interface
template<typename CharType> struct output_adapter_protocol
{
    virtual void write_character(CharType c) = 0;
    virtual void write_characters(const CharType* s, std::size_t length) = 0;
    virtual ~output_adapter_protocol() = default;
};

/// a type to simplify interfaces
template<typename CharType>
using output_adapter_t = std::shared_ptr<output_adapter_protocol<CharType>>;

/// output adapter for byte vectors
template<typename CharType>
class output_vector_adapter : public output_adapter_protocol<CharType>
{
  public:
    explicit output_vector_adapter(std::vector<CharType>& vec) noexcept
        : v(vec)
    {}

    void write_character(CharType c) override
    {
        v.push_back(c);
    }

    JSON_HEDLEY_NON_NULL(2)
    void write_characters(const CharType* s, std::size_t length) override
    {
        std::copy(s, s + length, std::back_inserter(v));
    }

  private:
    std::vector<CharType>& v;
};

/// output adapter for output streams
template<typename CharType>
class output_stream_adapter : public output_adapter_protocol<CharType>
{
  public:
    explicit output_stream_adapter(std::basic_ostream<CharType>& s) noexcept
        : stream(s)
    {}

    void write_character(CharType c) override
    {
        stream.put(c);
    }

    JSON_HEDLEY_NON_NULL(2)
    void write_characters(const CharType* s, std::size_t length) override
    {
        stream.write(s, static_cast<std::streamsize>(length));
    }

  private:
    std::basic_ostream<CharType>& stream;
};

/// output adapter for basic_string
template<typename CharType, typename StringType = std::basic_string<CharType>>
class output_string_adapter : public output_adapter_protocol<CharType>
{
  public:
    explicit output_string_adapter(StringType& s) noexcept
        : str(s)
    {}

    void write_character(CharType c) override
    {
        str.push_back(c);
    }

    JSON_HEDLEY_NON_NULL(2)
    void write_characters(const CharType* s, std::size_t length) override
    {
        str.append(s, length);
    }

  private:
    StringType& str;
};

template<typename CharType, typename StringType = std::basic_string<CharType>>
class output_adapter
{
  public:
    output_adapter(std::vector<CharType>& vec)
        : oa(std::make_shared<output_vector_adapter<CharType>>(vec)) {}

    output_adapter(std::basic_ostream<CharType>& s)
        : oa(std::make_shared<output_stream_adapter<CharType>>(s)) {}

    output_adapter(StringType& s)
        : oa(std::make_shared<output_string_adapter<CharType, StringType>>(s)) {}

    operator output_adapter_t<CharType>()
    {
        return oa;
    }

  private:
    output_adapter_t<CharType> oa = nullptr;
};
}  // namespace detail
}  // namespace nlohmann


namespace nlohmann
{
namespace detail
{
///////////////////
// binary writer //
///////////////////

/*!
@brief serialization to CBOR and MessagePack values
*/
template<typename BasicJsonType, typename CharType>
class binary_writer
{
    using string_t = typename BasicJsonType::string_t;
    using binary_t = typename BasicJsonType::binary_t;
    using number_float_t = typename BasicJsonType::number_float_t;

  public:
    /*!
    @brief create a binary writer

    @param[in] adapter  output adapter to write to
    */
    explicit binary_writer(output_adapter_t<CharType> adapter) : oa(adapter)
    {
        JSON_ASSERT(oa);
    }

    /*!
    @param[in] j  JSON value to serialize
    @pre       j.type() == value_t::object
    */
    void write_bson(const BasicJsonType& j)
    {
        switch (j.type())
        {
            case value_t::object:
            {
                write_bson_object(*j.m_value.object);
                break;
            }

            default:
            {
                JSON_THROW(type_error::create(317, "to serialize to BSON, top-level type must be object, but is " + std::string(j.type_name())));
            }
        }
    }

    /*!
    @param[in] j  JSON value to serialize
    */
    void write_cbor(const BasicJsonType& j)
    {
        switch (j.type())
        {
            case value_t::null:
            {
                oa->write_character(to_char_type(0xF6));
                break;
            }

            case value_t::boolean:
            {
                oa->write_character(j.m_value.boolean
                                    ? to_char_type(0xF5)
                                    : to_char_type(0xF4));
                break;
            }

            case value_t::number_integer:
            {
                if (j.m_value.number_integer >= 0)
                {
                    // CBOR does not differentiate between positive signed
                    // integers and unsigned integers. Therefore, we used the
                    // code from the value_t::number_unsigned case here.
                    if (j.m_value.number_integer <= 0x17)
                    {
                        write_number(static_cast<std::uint8_t>(j.m_value.number_integer));
                    }
                    else if (j.m_value.number_integer <= (std::numeric_limits<std::uint8_t>::max)())
                    {
                        oa->write_character(to_char_type(0x18));
                        write_number(static_cast<std::uint8_t>(j.m_value.number_integer));
                    }
                    else if (j.m_value.number_integer <= (std::numeric_limits<std::uint16_t>::max)())
                    {
                        oa->write_character(to_char_type(0x19));
                        write_number(static_cast<std::uint16_t>(j.m_value.number_integer));
                    }
                    else if (j.m_value.number_integer <= (std::numeric_limits<std::uint32_t>::max)())
                    {
                        oa->write_character(to_char_type(0x1A));
                        write_number(static_cast<std::uint32_t>(j.m_value.number_integer));
                    }
                    else
                    {
                        oa->write_character(to_char_type(0x1B));
                        write_number(static_cast<std::uint64_t>(j.m_value.number_integer));
                    }
                }
                else
                {
                    // The conversions below encode the sign in the first
                    // byte, and the value is converted to a positive number.
                    const auto positive_number = -1 - j.m_value.number_integer;
                    if (j.m_value.number_integer >= -24)
                    {
                        write_number(static_cast<std::uint8_t>(0x20 + positive_number));
                    }
                    else if (positive_number <= (std::numeric_limits<std::uint8_t>::max)())
                    {
                        oa->write_character(to_char_type(0x38));
                        write_number(static_cast<std::uint8_t>(positive_number));
                    }
                    else if (positive_number <= (std::numeric_limits<std::uint16_t>::max)())
                    {
                        oa->write_character(to_char_type(0x39));
                        write_number(static_cast<std::uint16_t>(positive_number));
                    }
                    else if (positive_number <= (std::numeric_limits<std::uint32_t>::max)())
                    {
                        oa->write_character(to_char_type(0x3A));
                        write_number(static_cast<std::uint32_t>(positive_number));
                    }
                    else
                    {
                        oa->write_character(to_char_type(0x3B));
                        write_number(static_cast<std::uint64_t>(positive_number));
                    }
                }
                break;
            }

            case value_t::number_unsigned:
            {
                if (j.m_value.number_unsigned <= 0x17)
                {
                    write_number(static_cast<std::uint8_t>(j.m_value.number_unsigned));
                }
                else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    oa->write_character(to_char_type(0x18));
                    write_number(static_cast<std::uint8_t>(j.m_value.number_unsigned));
                }
                else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    oa->write_character(to_char_type(0x19));
                    write_number(static_cast<std::uint16_t>(j.m_value.number_unsigned));
                }
                else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    oa->write_character(to_char_type(0x1A));
                    write_number(static_cast<std::uint32_t>(j.m_value.number_unsigned));
                }
                else
                {
                    oa->write_character(to_char_type(0x1B));
                    write_number(static_cast<std::uint64_t>(j.m_value.number_unsigned));
                }
                break;
            }

            case value_t::number_float:
            {
                if (std::isnan(j.m_value.number_float))
                {
                    // NaN is 0xf97e00 in CBOR
                    oa->write_character(to_char_type(0xF9));
                    oa->write_character(to_char_type(0x7E));
                    oa->write_character(to_char_type(0x00));
                }
                else if (std::isinf(j.m_value.number_float))
                {
                    // Infinity is 0xf97c00, -Infinity is 0xf9fc00
                    oa->write_character(to_char_type(0xf9));
                    oa->write_character(j.m_value.number_float > 0 ? to_char_type(0x7C) : to_char_type(0xFC));
                    oa->write_character(to_char_type(0x00));
                }
                else
                {
                    write_compact_float(j.m_value.number_float, detail::input_format_t::cbor);
                }
                break;
            }

            case value_t::string:
            {
                // step 1: write control byte and the string length
                const auto N = j.m_value.string->size();
                if (N <= 0x17)
                {
                    write_number(static_cast<std::uint8_t>(0x60 + N));
                }
                else if (N <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    oa->write_character(to_char_type(0x78));
                    write_number(static_cast<std::uint8_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    oa->write_character(to_char_type(0x79));
                    write_number(static_cast<std::uint16_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    oa->write_character(to_char_type(0x7A));
                    write_number(static_cast<std::uint32_t>(N));
                }
                // LCOV_EXCL_START
                else if (N <= (std::numeric_limits<std::uint64_t>::max)())
                {
                    oa->write_character(to_char_type(0x7B));
                    write_number(static_cast<std::uint64_t>(N));
                }
                // LCOV_EXCL_STOP

                // step 2: write the string
                oa->write_characters(
                    reinterpret_cast<const CharType*>(j.m_value.string->c_str()),
                    j.m_value.string->size());
                break;
            }

            case value_t::array:
            {
                // step 1: write control byte and the array size
                const auto N = j.m_value.array->size();
                if (N <= 0x17)
                {
                    write_number(static_cast<std::uint8_t>(0x80 + N));
                }
                else if (N <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    oa->write_character(to_char_type(0x98));
                    write_number(static_cast<std::uint8_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    oa->write_character(to_char_type(0x99));
                    write_number(static_cast<std::uint16_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    oa->write_character(to_char_type(0x9A));
                    write_number(static_cast<std::uint32_t>(N));
                }
                // LCOV_EXCL_START
                else if (N <= (std::numeric_limits<std::uint64_t>::max)())
                {
                    oa->write_character(to_char_type(0x9B));
                    write_number(static_cast<std::uint64_t>(N));
                }
                // LCOV_EXCL_STOP

                // step 2: write each element
                for (const auto& el : *j.m_value.array)
                {
                    write_cbor(el);
                }
                break;
            }

            case value_t::binary:
            {
                if (j.m_value.binary->has_subtype())
                {
                    write_number(static_cast<std::uint8_t>(0xd8));
                    write_number(j.m_value.binary->subtype());
                }

                // step 1: write control byte and the binary array size
                const auto N = j.m_value.binary->size();
                if (N <= 0x17)
                {
                    write_number(static_cast<std::uint8_t>(0x40 + N));
                }
                else if (N <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    oa->write_character(to_char_type(0x58));
                    write_number(static_cast<std::uint8_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    oa->write_character(to_char_type(0x59));
                    write_number(static_cast<std::uint16_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    oa->write_character(to_char_type(0x5A));
                    write_number(static_cast<std::uint32_t>(N));
                }
                // LCOV_EXCL_START
                else if (N <= (std::numeric_limits<std::uint64_t>::max)())
                {
                    oa->write_character(to_char_type(0x5B));
                    write_number(static_cast<std::uint64_t>(N));
                }
                // LCOV_EXCL_STOP

                // step 2: write each element
                oa->write_characters(
                    reinterpret_cast<const CharType*>(j.m_value.binary->data()),
                    N);

                break;
            }

            case value_t::object:
            {
                // step 1: write control byte and the object size
                const auto N = j.m_value.object->size();
                if (N <= 0x17)
                {
                    write_number(static_cast<std::uint8_t>(0xA0 + N));
                }
                else if (N <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    oa->write_character(to_char_type(0xB8));
                    write_number(static_cast<std::uint8_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    oa->write_character(to_char_type(0xB9));
                    write_number(static_cast<std::uint16_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    oa->write_character(to_char_type(0xBA));
                    write_number(static_cast<std::uint32_t>(N));
                }
                // LCOV_EXCL_START
                else if (N <= (std::numeric_limits<std::uint64_t>::max)())
                {
                    oa->write_character(to_char_type(0xBB));
                    write_number(static_cast<std::uint64_t>(N));
                }
                // LCOV_EXCL_STOP

                // step 2: write each element
                for (const auto& el : *j.m_value.object)
                {
                    write_cbor(el.first);
                    write_cbor(el.second);
                }
                break;
            }

            default:
                break;
        }
    }

    /*!
    @param[in] j  JSON value to serialize
    */
    void write_msgpack(const BasicJsonType& j)
    {
        switch (j.type())
        {
            case value_t::null: // nil
            {
                oa->write_character(to_char_type(0xC0));
                break;
            }

            case value_t::boolean: // true and false
            {
                oa->write_character(j.m_value.boolean
                                    ? to_char_type(0xC3)
                                    : to_char_type(0xC2));
                break;
            }

            case value_t::number_integer:
            {
                if (j.m_value.number_integer >= 0)
                {
                    // MessagePack does not differentiate between positive
                    // signed integers and unsigned integers. Therefore, we used
                    // the code from the value_t::number_unsigned case here.
                    if (j.m_value.number_unsigned < 128)
                    {
                        // positive fixnum
                        write_number(static_cast<std::uint8_t>(j.m_value.number_integer));
                    }
                    else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint8_t>::max)())
                    {
                        // uint 8
                        oa->write_character(to_char_type(0xCC));
                        write_number(static_cast<std::uint8_t>(j.m_value.number_integer));
                    }
                    else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint16_t>::max)())
                    {
                        // uint 16
                        oa->write_character(to_char_type(0xCD));
                        write_number(static_cast<std::uint16_t>(j.m_value.number_integer));
                    }
                    else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint32_t>::max)())
                    {
                        // uint 32
                        oa->write_character(to_char_type(0xCE));
                        write_number(static_cast<std::uint32_t>(j.m_value.number_integer));
                    }
                    else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint64_t>::max)())
                    {
                        // uint 64
                        oa->write_character(to_char_type(0xCF));
                        write_number(static_cast<std::uint64_t>(j.m_value.number_integer));
                    }
                }
                else
                {
                    if (j.m_value.number_integer >= -32)
                    {
                        // negative fixnum
                        write_number(static_cast<std::int8_t>(j.m_value.number_integer));
                    }
                    else if (j.m_value.number_integer >= (std::numeric_limits<std::int8_t>::min)() &&
                             j.m_value.number_integer <= (std::numeric_limits<std::int8_t>::max)())
                    {
                        // int 8
                        oa->write_character(to_char_type(0xD0));
                        write_number(static_cast<std::int8_t>(j.m_value.number_integer));
                    }
                    else if (j.m_value.number_integer >= (std::numeric_limits<std::int16_t>::min)() &&
                             j.m_value.number_integer <= (std::numeric_limits<std::int16_t>::max)())
                    {
                        // int 16
                        oa->write_character(to_char_type(0xD1));
                        write_number(static_cast<std::int16_t>(j.m_value.number_integer));
                    }
                    else if (j.m_value.number_integer >= (std::numeric_limits<std::int32_t>::min)() &&
                             j.m_value.number_integer <= (std::numeric_limits<std::int32_t>::max)())
                    {
                        // int 32
                        oa->write_character(to_char_type(0xD2));
                        write_number(static_cast<std::int32_t>(j.m_value.number_integer));
                    }
                    else if (j.m_value.number_integer >= (std::numeric_limits<std::int64_t>::min)() &&
                             j.m_value.number_integer <= (std::numeric_limits<std::int64_t>::max)())
                    {
                        // int 64
                        oa->write_character(to_char_type(0xD3));
                        write_number(static_cast<std::int64_t>(j.m_value.number_integer));
                    }
                }
                break;
            }

            case value_t::number_unsigned:
            {
                if (j.m_value.number_unsigned < 128)
                {
                    // positive fixnum
                    write_number(static_cast<std::uint8_t>(j.m_value.number_integer));
                }
                else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    // uint 8
                    oa->write_character(to_char_type(0xCC));
                    write_number(static_cast<std::uint8_t>(j.m_value.number_integer));
                }
                else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    // uint 16
                    oa->write_character(to_char_type(0xCD));
                    write_number(static_cast<std::uint16_t>(j.m_value.number_integer));
                }
                else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    // uint 32
                    oa->write_character(to_char_type(0xCE));
                    write_number(static_cast<std::uint32_t>(j.m_value.number_integer));
                }
                else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint64_t>::max)())
                {
                    // uint 64
                    oa->write_character(to_char_type(0xCF));
                    write_number(static_cast<std::uint64_t>(j.m_value.number_integer));
                }
                break;
            }

            case value_t::number_float:
            {
                write_compact_float(j.m_value.number_float, detail::input_format_t::msgpack);
                break;
            }

            case value_t::string:
            {
                // step 1: write control byte and the string length
                const auto N = j.m_value.string->size();
                if (N <= 31)
                {
                    // fixstr
                    write_number(static_cast<std::uint8_t>(0xA0 | N));
                }
                else if (N <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    // str 8
                    oa->write_character(to_char_type(0xD9));
                    write_number(static_cast<std::uint8_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    // str 16
                    oa->write_character(to_char_type(0xDA));
                    write_number(static_cast<std::uint16_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    // str 32
                    oa->write_character(to_char_type(0xDB));
                    write_number(static_cast<std::uint32_t>(N));
                }

                // step 2: write the string
                oa->write_characters(
                    reinterpret_cast<const CharType*>(j.m_value.string->c_str()),
                    j.m_value.string->size());
                break;
            }

            case value_t::array:
            {
                // step 1: write control byte and the array size
                const auto N = j.m_value.array->size();
                if (N <= 15)
                {
                    // fixarray
                    write_number(static_cast<std::uint8_t>(0x90 | N));
                }
                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    // array 16
                    oa->write_character(to_char_type(0xDC));
                    write_number(static_cast<std::uint16_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    // array 32
                    oa->write_character(to_char_type(0xDD));
                    write_number(static_cast<std::uint32_t>(N));
                }

                // step 2: write each element
                for (const auto& el : *j.m_value.array)
                {
                    write_msgpack(el);
                }
                break;
            }

            case value_t::binary:
            {
                // step 0: determine if the binary type has a set subtype to
                // determine whether or not to use the ext or fixext types
                const bool use_ext = j.m_value.binary->has_subtype();

                // step 1: write control byte and the byte string length
                const auto N = j.m_value.binary->size();
                if (N <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    std::uint8_t output_type{};
                    bool fixed = true;
                    if (use_ext)
                    {
                        switch (N)
                        {
                            case 1:
                                output_type = 0xD4; // fixext 1
                                break;
                            case 2:
                                output_type = 0xD5; // fixext 2
                                break;
                            case 4:
                                output_type = 0xD6; // fixext 4
                                break;
                            case 8:
                                output_type = 0xD7; // fixext 8
                                break;
                            case 16:
                                output_type = 0xD8; // fixext 16
                                break;
                            default:
                                output_type = 0xC7; // ext 8
                                fixed = false;
                                break;
                        }

                    }
                    else
                    {
                        output_type = 0xC4; // bin 8
                        fixed = false;
                    }

                    oa->write_character(to_char_type(output_type));
                    if (!fixed)
                    {
                        write_number(static_cast<std::uint8_t>(N));
                    }
                }
                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    std::uint8_t output_type = use_ext
                                               ? 0xC8 // ext 16
                                               : 0xC5; // bin 16

                    oa->write_character(to_char_type(output_type));
                    write_number(static_cast<std::uint16_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    std::uint8_t output_type = use_ext
                                               ? 0xC9 // ext 32
                                               : 0xC6; // bin 32

                    oa->write_character(to_char_type(output_type));
                    write_number(static_cast<std::uint32_t>(N));
                }

                // step 1.5: if this is an ext type, write the subtype
                if (use_ext)
                {
                    write_number(static_cast<std::int8_t>(j.m_value.binary->subtype()));
                }

                // step 2: write the byte string
                oa->write_characters(
                    reinterpret_cast<const CharType*>(j.m_value.binary->data()),
                    N);

                break;
            }

            case value_t::object:
            {
                // step 1: write control byte and the object size
                const auto N = j.m_value.object->size();
                if (N <= 15)
                {
                    // fixmap
                    write_number(static_cast<std::uint8_t>(0x80 | (N & 0xF)));
                }
                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    // map 16
                    oa->write_character(to_char_type(0xDE));
                    write_number(static_cast<std::uint16_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    // map 32
                    oa->write_character(to_char_type(0xDF));
                    write_number(static_cast<std::uint32_t>(N));
                }

                // step 2: write each element
                for (const auto& el : *j.m_value.object)
                {
                    write_msgpack(el.first);
                    write_msgpack(el.second);
                }
                break;
            }

            default:
                break;
        }
    }

    /*!
    @param[in] j  JSON value to serialize
    @param[in] use_count   whether to use '#' prefixes (optimized format)
    @param[in] use_type    whether to use '$' prefixes (optimized format)
    @param[in] add_prefix  whether prefixes need to be used for this value
    */
    void write_ubjson(const BasicJsonType& j, const bool use_count,
                      const bool use_type, const bool add_prefix = true)
    {
        switch (j.type())
        {
            case value_t::null:
            {
                if (add_prefix)
                {
                    oa->write_character(to_char_type('Z'));
                }
                break;
            }

            case value_t::boolean:
            {
                if (add_prefix)
                {
                    oa->write_character(j.m_value.boolean
                                        ? to_char_type('T')
                                        : to_char_type('F'));
                }
                break;
            }

            case value_t::number_integer:
            {
                write_number_with_ubjson_prefix(j.m_value.number_integer, add_prefix);
                break;
            }

            case value_t::number_unsigned:
            {
                write_number_with_ubjson_prefix(j.m_value.number_unsigned, add_prefix);
                break;
            }

            case value_t::number_float:
            {
                write_number_with_ubjson_prefix(j.m_value.number_float, add_prefix);
                break;
            }

            case value_t::string:
            {
                if (add_prefix)
                {
                    oa->write_character(to_char_type('S'));
                }
                write_number_with_ubjson_prefix(j.m_value.string->size(), true);
                oa->write_characters(
                    reinterpret_cast<const CharType*>(j.m_value.string->c_str()),
                    j.m_value.string->size());
                break;
            }

            case value_t::array:
            {
                if (add_prefix)
                {
                    oa->write_character(to_char_type('['));
                }

                bool prefix_required = true;
                if (use_type && !j.m_value.array->empty())
                {
                    JSON_ASSERT(use_count);
                    const CharType first_prefix = ubjson_prefix(j.front());
                    const bool same_prefix = std::all_of(j.begin() + 1, j.end(),
                                                         [this, first_prefix](const BasicJsonType & v)
                    {
                        return ubjson_prefix(v) == first_prefix;
                    });

                    if (same_prefix)
                    {
                        prefix_required = false;
                        oa->write_character(to_char_type('$'));
                        oa->write_character(first_prefix);
                    }
                }

                if (use_count)
                {
                    oa->write_character(to_char_type('#'));
                    write_number_with_ubjson_prefix(j.m_value.array->size(), true);
                }

                for (const auto& el : *j.m_value.array)
                {
                    write_ubjson(el, use_count, use_type, prefix_required);
                }

                if (!use_count)
                {
                    oa->write_character(to_char_type(']'));
                }

                break;
            }

            case value_t::binary:
            {
                if (add_prefix)
                {
                    oa->write_character(to_char_type('['));
                }

                if (use_type && !j.m_value.binary->empty())
                {
                    JSON_ASSERT(use_count);
                    oa->write_character(to_char_type('$'));
                    oa->write_character('U');
                }

                if (use_count)
                {
                    oa->write_character(to_char_type('#'));
                    write_number_with_ubjson_prefix(j.m_value.binary->size(), true);
                }

                if (use_type)
                {
                    oa->write_characters(
                        reinterpret_cast<const CharType*>(j.m_value.binary->data()),
                        j.m_value.binary->size());
                }
                else
                {
                    for (size_t i = 0; i < j.m_value.binary->size(); ++i)
                    {
                        oa->write_character(to_char_type('U'));
                        oa->write_character(j.m_value.binary->data()[i]);
                    }
                }

                if (!use_count)
                {
                    oa->write_character(to_char_type(']'));
                }

                break;
            }

            case value_t::object:
            {
                if (add_prefix)
                {
                    oa->write_character(to_char_type('{'));
                }

                bool prefix_required = true;
                if (use_type && !j.m_value.object->empty())
                {
                    JSON_ASSERT(use_count);
                    const CharType first_prefix = ubjson_prefix(j.front());
                    const bool same_prefix = std::all_of(j.begin(), j.end(),
                                                         [this, first_prefix](const BasicJsonType & v)
                    {
                        return ubjson_prefix(v) == first_prefix;
                    });

                    if (same_prefix)
                    {
                        prefix_required = false;
                        oa->write_character(to_char_type('$'));
                        oa->write_character(first_prefix);
                    }
                }

                if (use_count)
                {
                    oa->write_character(to_char_type('#'));
                    write_number_with_ubjson_prefix(j.m_value.object->size(), true);
                }

                for (const auto& el : *j.m_value.object)
                {
                    write_number_with_ubjson_prefix(el.first.size(), true);
                    oa->write_characters(
                        reinterpret_cast<const CharType*>(el.first.c_str()),
                        el.first.size());
                    write_ubjson(el.second, use_count, use_type, prefix_required);
                }

                if (!use_count)
                {
                    oa->write_character(to_char_type('}'));
                }

                break;
            }

            default:
                break;
        }
    }

  private:
    //////////
    // BSON //
    //////////

    /*!
    @return The size of a BSON document entry header, including the id marker
            and the entry name size (and its null-terminator).
    */
    static std::size_t calc_bson_entry_header_size(const string_t& name)
    {
        const auto it = name.find(static_cast<typename string_t::value_type>(0));
        if (JSON_HEDLEY_UNLIKELY(it != BasicJsonType::string_t::npos))
        {
            JSON_THROW(out_of_range::create(409,
                                            "BSON key cannot contain code point U+0000 (at byte " + std::to_string(it) + ")"));
        }

        return /*id*/ 1ul + name.size() + /*zero-terminator*/1u;
    }

    /*!
    @brief Writes the given @a element_type and @a name to the output adapter
    */
    void write_bson_entry_header(const string_t& name,
                                 const std::uint8_t element_type)
    {
        oa->write_character(to_char_type(element_type)); // boolean
        oa->write_characters(
            reinterpret_cast<const CharType*>(name.c_str()),
            name.size() + 1u);
    }

    /*!
    @brief Writes a BSON element with key @a name and boolean value @a value
    */
    void write_bson_boolean(const string_t& name,
                            const bool value)
    {
        write_bson_entry_header(name, 0x08);
        oa->write_character(value ? to_char_type(0x01) : to_char_type(0x00));
    }

    /*!
    @brief Writes a BSON element with key @a name and double value @a value
    */
    void write_bson_double(const string_t& name,
                           const double value)
    {
        write_bson_entry_header(name, 0x01);
        write_number<double, true>(value);
    }

    /*!
    @return The size of the BSON-encoded string in @a value
    */
    static std::size_t calc_bson_string_size(const string_t& value)
    {
        return sizeof(std::int32_t) + value.size() + 1ul;
    }

    /*!
    @brief Writes a BSON element with key @a name and string value @a value
    */
    void write_bson_string(const string_t& name,
                           const string_t& value)
    {
        write_bson_entry_header(name, 0x02);

        write_number<std::int32_t, true>(static_cast<std::int32_t>(value.size() + 1ul));
        oa->write_characters(
            reinterpret_cast<const CharType*>(value.c_str()),
            value.size() + 1);
    }

    /*!
    @brief Writes a BSON element with key @a name and null value
    */
    void write_bson_null(const string_t& name)
    {
        write_bson_entry_header(name, 0x0A);
    }

    /*!
    @return The size of the BSON-encoded integer @a value
    */
    static std::size_t calc_bson_integer_size(const std::int64_t value)
    {
        return (std::numeric_limits<std::int32_t>::min)() <= value && value <= (std::numeric_limits<std::int32_t>::max)()
               ? sizeof(std::int32_t)
               : sizeof(std::int64_t);
    }

    /*!
    @brief Writes a BSON element with key @a name and integer @a value
    */
    void write_bson_integer(const string_t& name,
                            const std::int64_t value)
    {
        if ((std::numeric_limits<std::int32_t>::min)() <= value && value <= (std::numeric_limits<std::int32_t>::max)())
        {
            write_bson_entry_header(name, 0x10); // int32
            write_number<std::int32_t, true>(static_cast<std::int32_t>(value));
        }
        else
        {
            write_bson_entry_header(name, 0x12); // int64
            write_number<std::int64_t, true>(static_cast<std::int64_t>(value));
        }
    }

    /*!
    @return The size of the BSON-encoded unsigned integer in @a j
    */
    static constexpr std::size_t calc_bson_unsigned_size(const std::uint64_t value) noexcept
    {
        return (value <= static_cast<std::uint64_t>((std::numeric_limits<std::int32_t>::max)()))
               ? sizeof(std::int32_t)
               : sizeof(std::int64_t);
    }

    /*!
    @brief Writes a BSON element with key @a name and unsigned @a value
    */
    void write_bson_unsigned(const string_t& name,
                             const std::uint64_t value)
    {
        if (value <= static_cast<std::uint64_t>((std::numeric_limits<std::int32_t>::max)()))
        {
            write_bson_entry_header(name, 0x10 /* int32 */);
            write_number<std::int32_t, true>(static_cast<std::int32_t>(value));
        }
        else if (value <= static_cast<std::uint64_t>((std::numeric_limits<std::int64_t>::max)()))
        {
            write_bson_entry_header(name, 0x12 /* int64 */);
            write_number<std::int64_t, true>(static_cast<std::int64_t>(value));
        }
        else
        {
            JSON_THROW(out_of_range::create(407, "integer number " + std::to_string(value) + " cannot be represented by BSON as it does not fit int64"));
        }
    }

    /*!
    @brief Writes a BSON element with key @a name and object @a value
    */
    void write_bson_object_entry(const string_t& name,
                                 const typename BasicJsonType::object_t& value)
    {
        write_bson_entry_header(name, 0x03); // object
        write_bson_object(value);
    }

    /*!
    @return The size of the BSON-encoded array @a value
    */
    static std::size_t calc_bson_array_size(const typename BasicJsonType::array_t& value)
    {
        std::size_t array_index = 0ul;

        const std::size_t embedded_document_size = std::accumulate(std::begin(value), std::end(value), std::size_t(0), [&array_index](std::size_t result, const typename BasicJsonType::array_t::value_type & el)
        {
            return result + calc_bson_element_size(std::to_string(array_index++), el);
        });

        return sizeof(std::int32_t) + embedded_document_size + 1ul;
    }

    /*!
    @return The size of the BSON-encoded binary array @a value
    */
    static std::size_t calc_bson_binary_size(const typename BasicJsonType::binary_t& value)
    {
        return sizeof(std::int32_t) + value.size() + 1ul;
    }

    /*!
    @brief Writes a BSON element with key @a name and array @a value
    */
    void write_bson_array(const string_t& name,
                          const typename BasicJsonType::array_t& value)
    {
        write_bson_entry_header(name, 0x04); // array
        write_number<std::int32_t, true>(static_cast<std::int32_t>(calc_bson_array_size(value)));

        std::size_t array_index = 0ul;

        for (const auto& el : value)
        {
            write_bson_element(std::to_string(array_index++), el);
        }

        oa->write_character(to_char_type(0x00));
    }

    /*!
    @brief Writes a BSON element with key @a name and binary value @a value
    */
    void write_bson_binary(const string_t& name,
                           const binary_t& value)
    {
        write_bson_entry_header(name, 0x05);

        write_number<std::int32_t, true>(static_cast<std::int32_t>(value.size()));
        write_number(value.has_subtype() ? value.subtype() : std::uint8_t(0x00));

        oa->write_characters(reinterpret_cast<const CharType*>(value.data()), value.size());
    }

    /*!
    @brief Calculates the size necessary to serialize the JSON value @a j with its @a name
    @return The calculated size for the BSON document entry for @a j with the given @a name.
    */
    static std::size_t calc_bson_element_size(const string_t& name,
            const BasicJsonType& j)
    {
        const auto header_size = calc_bson_entry_header_size(name);
        switch (j.type())
        {
            case value_t::object:
                return header_size + calc_bson_object_size(*j.m_value.object);

            case value_t::array:
                return header_size + calc_bson_array_size(*j.m_value.array);

            case value_t::binary:
                return header_size + calc_bson_binary_size(*j.m_value.binary);

            case value_t::boolean:
                return header_size + 1ul;

            case value_t::number_float:
                return header_size + 8ul;

            case value_t::number_integer:
                return header_size + calc_bson_integer_size(j.m_value.number_integer);

            case value_t::number_unsigned:
                return header_size + calc_bson_unsigned_size(j.m_value.number_unsigned);

            case value_t::string:
                return header_size + calc_bson_string_size(*j.m_value.string);

            case value_t::null:
                return header_size + 0ul;

            // LCOV_EXCL_START
            default:
                JSON_ASSERT(false);
                return 0ul;
                // LCOV_EXCL_STOP
        }
    }

    /*!
    @brief Serializes the JSON value @a j to BSON and associates it with the
           key @a name.
    @param name The name to associate with the JSON entity @a j within the
                current BSON document
    @return The size of the BSON entry
    */
    void write_bson_element(const string_t& name,
                            const BasicJsonType& j)
    {
        switch (j.type())
        {
            case value_t::object:
                return write_bson_object_entry(name, *j.m_value.object);

            case value_t::array:
                return write_bson_array(name, *j.m_value.array);

            case value_t::binary:
                return write_bson_binary(name, *j.m_value.binary);

            case value_t::boolean:
                return write_bson_boolean(name, j.m_value.boolean);

            case value_t::number_float:
                return write_bson_double(name, j.m_value.number_float);

            case value_t::number_integer:
                return write_bson_integer(name, j.m_value.number_integer);

            case value_t::number_unsigned:
                return write_bson_unsigned(name, j.m_value.number_unsigned);

            case value_t::string:
                return write_bson_string(name, *j.m_value.string);

            case value_t::null:
                return write_bson_null(name);

            // LCOV_EXCL_START
            default:
                JSON_ASSERT(false);
                return;
                // LCOV_EXCL_STOP
        }
    }

    /*!
    @brief Calculates the size of the BSON serialization of the given
           JSON-object @a j.
    @param[in] j  JSON value to serialize
    @pre       j.type() == value_t::object
    */
    static std::size_t calc_bson_object_size(const typename BasicJsonType::object_t& value)
    {
        std::size_t document_size = std::accumulate(value.begin(), value.end(), std::size_t(0),
                                    [](size_t result, const typename BasicJsonType::object_t::value_type & el)
        {
            return result += calc_bson_element_size(el.first, el.second);
        });

        return sizeof(std::int32_t) + document_size + 1ul;
    }

    /*!
    @param[in] j  JSON value to serialize
    @pre       j.type() == value_t::object
    */
    void write_bson_object(const typename BasicJsonType::object_t& value)
    {
        write_number<std::int32_t, true>(static_cast<std::int32_t>(calc_bson_object_size(value)));

        for (const auto& el : value)
        {
            write_bson_element(el.first, el.second);
        }

        oa->write_character(to_char_type(0x00));
    }

    //////////
    // CBOR //
    //////////

    static constexpr CharType get_cbor_float_prefix(float /*unused*/)
    {
        return to_char_type(0xFA);  // Single-Precision Float
    }

    static constexpr CharType get_cbor_float_prefix(double /*unused*/)
    {
        return to_char_type(0xFB);  // Double-Precision Float
    }

    /////////////
    // MsgPack //
    /////////////

    static constexpr CharType get_msgpack_float_prefix(float /*unused*/)
    {
        return to_char_type(0xCA);  // float 32
    }

    static constexpr CharType get_msgpack_float_prefix(double /*unused*/)
    {
        return to_char_type(0xCB);  // float 64
    }

    ////////////
    // UBJSON //
    ////////////

    // UBJSON: write number (floating point)
    template<typename NumberType, typename std::enable_if<
                 std::is_floating_point<NumberType>::value, int>::type = 0>
    void write_number_with_ubjson_prefix(const NumberType n,
                                         const bool add_prefix)
    {
        if (add_prefix)
        {
            oa->write_character(get_ubjson_float_prefix(n));
        }
        write_number(n);
    }

    // UBJSON: write number (unsigned integer)
    template<typename NumberType, typename std::enable_if<
                 std::is_unsigned<NumberType>::value, int>::type = 0>
    void write_number_with_ubjson_prefix(const NumberType n,
                                         const bool add_prefix)
    {
        if (n <= static_cast<std::uint64_t>((std::numeric_limits<std::int8_t>::max)()))
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('i'));  // int8
            }
            write_number(static_cast<std::uint8_t>(n));
        }
        else if (n <= (std::numeric_limits<std::uint8_t>::max)())
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('U'));  // uint8
            }
            write_number(static_cast<std::uint8_t>(n));
        }
        else if (n <= static_cast<std::uint64_t>((std::numeric_limits<std::int16_t>::max)()))
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('I'));  // int16
            }
            write_number(static_cast<std::int16_t>(n));
        }
        else if (n <= static_cast<std::uint64_t>((std::numeric_limits<std::int32_t>::max)()))
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('l'));  // int32
            }
            write_number(static_cast<std::int32_t>(n));
        }
        else if (n <= static_cast<std::uint64_t>((std::numeric_limits<std::int64_t>::max)()))
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('L'));  // int64
            }
            write_number(static_cast<std::int64_t>(n));
        }
        else
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('H'));  // high-precision number
            }

            const auto number = BasicJsonType(n).dump();
            write_number_with_ubjson_prefix(number.size(), true);
            for (std::size_t i = 0; i < number.size(); ++i)
            {
                oa->write_character(to_char_type(static_cast<std::uint8_t>(number[i])));
            }
        }
    }

    // UBJSON: write number (signed integer)
    template < typename NumberType, typename std::enable_if <
                   std::is_signed<NumberType>::value&&
                   !std::is_floating_point<NumberType>::value, int >::type = 0 >
    void write_number_with_ubjson_prefix(const NumberType n,
                                         const bool add_prefix)
    {
        if ((std::numeric_limits<std::int8_t>::min)() <= n && n <= (std::numeric_limits<std::int8_t>::max)())
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('i'));  // int8
            }
            write_number(static_cast<std::int8_t>(n));
        }
        else if (static_cast<std::int64_t>((std::numeric_limits<std::uint8_t>::min)()) <= n && n <= static_cast<std::int64_t>((std::numeric_limits<std::uint8_t>::max)()))
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('U'));  // uint8
            }
            write_number(static_cast<std::uint8_t>(n));
        }
        else if ((std::numeric_limits<std::int16_t>::min)() <= n && n <= (std::numeric_limits<std::int16_t>::max)())
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('I'));  // int16
            }
            write_number(static_cast<std::int16_t>(n));
        }
        else if ((std::numeric_limits<std::int32_t>::min)() <= n && n <= (std::numeric_limits<std::int32_t>::max)())
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('l'));  // int32
            }
            write_number(static_cast<std::int32_t>(n));
        }
        else if ((std::numeric_limits<std::int64_t>::min)() <= n && n <= (std::numeric_limits<std::int64_t>::max)())
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('L'));  // int64
            }
            write_number(static_cast<std::int64_t>(n));
        }
        // LCOV_EXCL_START
        else
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('H'));  // high-precision number
            }

            const auto number = BasicJsonType(n).dump();
            write_number_with_ubjson_prefix(number.size(), true);
            for (std::size_t i = 0; i < number.size(); ++i)
            {
                oa->write_character(to_char_type(static_cast<std::uint8_t>(number[i])));
            }
        }
        // LCOV_EXCL_STOP
    }

    /*!
    @brief determine the type prefix of container values
    */
    CharType ubjson_prefix(const BasicJsonType& j) const noexcept
    {
        switch (j.type())
        {
            case value_t::null:
                return 'Z';

            case value_t::boolean:
                return j.m_value.boolean ? 'T' : 'F';

            case value_t::number_integer:
            {
                if ((std::numeric_limits<std::int8_t>::min)() <= j.m_value.number_integer && j.m_value.number_integer <= (std::numeric_limits<std::int8_t>::max)())
                {
                    return 'i';
                }
                if ((std::numeric_limits<std::uint8_t>::min)() <= j.m_value.number_integer && j.m_value.number_integer <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    return 'U';
                }
                if ((std::numeric_limits<std::int16_t>::min)() <= j.m_value.number_integer && j.m_value.number_integer <= (std::numeric_limits<std::int16_t>::max)())
                {
                    return 'I';
                }
                if ((std::numeric_limits<std::int32_t>::min)() <= j.m_value.number_integer && j.m_value.number_integer <= (std::numeric_limits<std::int32_t>::max)())
                {
                    return 'l';
                }
                if ((std::numeric_limits<std::int64_t>::min)() <= j.m_value.number_integer && j.m_value.number_integer <= (std::numeric_limits<std::int64_t>::max)())
                {
                    return 'L';
                }
                // anything else is treated as high-precision number
                return 'H'; // LCOV_EXCL_LINE
            }

            case value_t::number_unsigned:
            {
                if (j.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::int8_t>::max)()))
                {
                    return 'i';
                }
                if (j.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::uint8_t>::max)()))
                {
                    return 'U';
                }
                if (j.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::int16_t>::max)()))
                {
                    return 'I';
                }
                if (j.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::int32_t>::max)()))
                {
                    return 'l';
                }
                if (j.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::int64_t>::max)()))
                {
                    return 'L';
                }
                // anything else is treated as high-precision number
                return 'H'; // LCOV_EXCL_LINE
            }

            case value_t::number_float:
                return get_ubjson_float_prefix(j.m_value.number_float);

            case value_t::string:
                return 'S';

            case value_t::array: // fallthrough
            case value_t::binary:
                return '[';

            case value_t::object:
                return '{';

            default:  // discarded values
                return 'N';
        }
    }

    static constexpr CharType get_ubjson_float_prefix(float /*unused*/)
    {
        return 'd';  // float 32
    }

    static constexpr CharType get_ubjson_float_prefix(double /*unused*/)
    {
        return 'D';  // float 64
    }

    ///////////////////////
    // Utility functions //
    ///////////////////////

    /*
    @brief write a number to output input
    @param[in] n number of type @a NumberType
    @tparam NumberType the type of the number
    @tparam OutputIsLittleEndian Set to true if output data is
                                 required to be little endian

    @note This function needs to respect the system's endianess, because bytes
          in CBOR, MessagePack, and UBJSON are stored in network order (big
          endian) and therefore need reordering on little endian systems.
    */
    template<typename NumberType, bool OutputIsLittleEndian = false>
    void write_number(const NumberType n)
    {
        // step 1: write number to array of length NumberType
        std::array<CharType, sizeof(NumberType)> vec;
        std::memcpy(vec.data(), &n, sizeof(NumberType));

        // step 2: write array to output (with possible reordering)
        if (is_little_endian != OutputIsLittleEndian)
        {
            // reverse byte order prior to conversion if necessary
            std::reverse(vec.begin(), vec.end());
        }

        oa->write_characters(vec.data(), sizeof(NumberType));
    }

    void write_compact_float(const number_float_t n, detail::input_format_t format)
    {
        if (static_cast<double>(n) >= static_cast<double>(std::numeric_limits<float>::lowest()) &&
                static_cast<double>(n) <= static_cast<double>((std::numeric_limits<float>::max)()) &&
                static_cast<double>(static_cast<float>(n)) == static_cast<double>(n))
        {
            oa->write_character(format == detail::input_format_t::cbor
                                ? get_cbor_float_prefix(static_cast<float>(n))
                                : get_msgpack_float_prefix(static_cast<float>(n)));
            write_number(static_cast<float>(n));
        }
        else
        {
            oa->write_character(format == detail::input_format_t::cbor
                                ? get_cbor_float_prefix(n)
                                : get_msgpack_float_prefix(n));
            write_number(n);
        }
    }

  public:
    // The following to_char_type functions are implement the conversion
    // between uint8_t and CharType. In case CharType is not unsigned,
    // such a conversion is required to allow values greater than 128.
    // See <https://github.com/nlohmann/json/issues/1286> for a discussion.
    template < typename C = CharType,
               enable_if_t < std::is_signed<C>::value && std::is_signed<char>::value > * = nullptr >
    static constexpr CharType to_char_type(std::uint8_t x) noexcept
    {
        return *reinterpret_cast<char*>(&x);
    }

    template < typename C = CharType,
               enable_if_t < std::is_signed<C>::value && std::is_unsigned<char>::value > * = nullptr >
    static CharType to_char_type(std::uint8_t x) noexcept
    {
        static_assert(sizeof(std::uint8_t) == sizeof(CharType), "size of CharType must be equal to std::uint8_t");
        static_assert(std::is_trivial<CharType>::value, "CharType must be trivial");
        CharType result;
        std::memcpy(&result, &x, sizeof(x));
        return result;
    }

    template<typename C = CharType,
             enable_if_t<std::is_unsigned<C>::value>* = nullptr>
    static constexpr CharType to_char_type(std::uint8_t x) noexcept
    {
        return x;
    }

    template < typename InputCharType, typename C = CharType,
               enable_if_t <
                   std::is_signed<C>::value &&
                   std::is_signed<char>::value &&
                   std::is_same<char, typename std::remove_cv<InputCharType>::type>::value
                   > * = nullptr >
    static constexpr CharType to_char_type(InputCharType x) noexcept
    {
        return x;
    }

  private:
    /// whether we can assume little endianess
    const bool is_little_endian = little_endianess();

    /// the output
    output_adapter_t<CharType> oa = nullptr;
};
}  // namespace detail
}  // namespace nlohmann

// #include <nlohmann/detail/output/output_adapters.hpp>

// #include <nlohmann/detail/output/serializer.hpp>


#include <algorithm> // reverse, remove, fill, find, none_of
#include <array> // array
#include <clocale> // localeconv, lconv
#include <cmath> // labs, isfinite, isnan, signbit
#include <cstddef> // size_t, ptrdiff_t
#include <cstdint> // uint8_t
#include <cstdio> // snprintf
#include <limits> // numeric_limits
#include <string> // string, char_traits
#include <type_traits> // is_same
#include <utility> // move

// #include <nlohmann/detail/conversions/to_chars.hpp>


#include <array> // array
#include <cmath>   // signbit, isfinite
#include <cstdint> // intN_t, uintN_t
#include <cstring> // memcpy, memmove
#include <limits> // numeric_limits
#include <type_traits> // conditional

// #include <nlohmann/detail/macro_scope.hpp>


namespace nlohmann
{
namespace detail
{

/*!
@brief implements the Grisu2 algorithm for binary to decimal floating-point
conversion.

This implementation is a slightly modified version of the reference
implementation which may be obtained from
http://florian.loitsch.com/publications (bench.tar.gz).

The code is distributed under the MIT license, Copyright (c) 2009 Florian Loitsch.

For a detailed description of the algorithm see:

[1] Loitsch, "Printing Floating-Point Numbers Quickly and Accurately with
    Integers", Proceedings of the ACM SIGPLAN 2010 Conference on Programming
    Language Design and Implementation, PLDI 2010
[2] Burger, Dybvig, "Printing Floating-Point Numbers Quickly and Accurately",
    Proceedings of the ACM SIGPLAN 1996 Conference on Programming Language
    Design and Implementation, PLDI 1996
*/
namespace dtoa_impl
{

template<typename Target, typename Source>
Target reinterpret_bits(const Source source)
{
    static_assert(sizeof(Target) == sizeof(Source), "size mismatch");

    Target target;
    std::memcpy(&target, &source, sizeof(Source));
    return target;
}

struct diyfp // f * 2^e
{
    static constexpr int kPrecision = 64; // = q

    std::uint64_t f = 0;
    int e = 0;

    constexpr diyfp(std::uint64_t f_, int e_) noexcept : f(f_), e(e_) {}

    /*!
    @brief returns x - y
    @pre x.e == y.e and x.f >= y.f
    */
    static diyfp sub(const diyfp& x, const diyfp& y) noexcept
    {
        JSON_ASSERT(x.e == y.e);
        JSON_ASSERT(x.f >= y.f);

        return {x.f - y.f, x.e};
    }

    /*!
    @brief returns x * y
    @note The result is rounded. (Only the upper q bits are returned.)
    */
    static diyfp mul(const diyfp& x, const diyfp& y) noexcept
    {
        static_assert(kPrecision == 64, "internal error");

        // Computes:
        //  f = round((x.f * y.f) / 2^q)
        //  e = x.e + y.e + q

        // Emulate the 64-bit * 64-bit multiplication:
        //
        // p = u * v
        //   = (u_lo + 2^32 u_hi) (v_lo + 2^32 v_hi)
        //   = (u_lo v_lo         ) + 2^32 ((u_lo v_hi         ) + (u_hi v_lo         )) + 2^64 (u_hi v_hi         )
        //   = (p0                ) + 2^32 ((p1                ) + (p2                )) + 2^64 (p3                )
        //   = (p0_lo + 2^32 p0_hi) + 2^32 ((p1_lo + 2^32 p1_hi) + (p2_lo + 2^32 p2_hi)) + 2^64 (p3                )
        //   = (p0_lo             ) + 2^32 (p0_hi + p1_lo + p2_lo                      ) + 2^64 (p1_hi + p2_hi + p3)
        //   = (p0_lo             ) + 2^32 (Q                                          ) + 2^64 (H                 )
        //   = (p0_lo             ) + 2^32 (Q_lo + 2^32 Q_hi                           ) + 2^64 (H                 )
        //
        // (Since Q might be larger than 2^32 - 1)
        //
        //   = (p0_lo + 2^32 Q_lo) + 2^64 (Q_hi + H)
        //
        // (Q_hi + H does not overflow a 64-bit int)
        //
        //   = p_lo + 2^64 p_hi

        const std::uint64_t u_lo = x.f & 0xFFFFFFFFu;
        const std::uint64_t u_hi = x.f >> 32u;
        const std::uint64_t v_lo = y.f & 0xFFFFFFFFu;
        const std::uint64_t v_hi = y.f >> 32u;

        const std::uint64_t p0 = u_lo * v_lo;
        const std::uint64_t p1 = u_lo * v_hi;
        const std::uint64_t p2 = u_hi * v_lo;
        const std::uint64_t p3 = u_hi * v_hi;

        const std::uint64_t p0_hi = p0 >> 32u;
        const std::uint64_t p1_lo = p1 & 0xFFFFFFFFu;
        const std::uint64_t p1_hi = p1 >> 32u;
        const std::uint64_t p2_lo = p2 & 0xFFFFFFFFu;
        const std::uint64_t p2_hi = p2 >> 32u;

        std::uint64_t Q = p0_hi + p1_lo + p2_lo;

        // The full product might now be computed as
        //
        // p_hi = p3 + p2_hi + p1_hi + (Q >> 32)
        // p_lo = p0_lo + (Q << 32)
        //
        // But in this particular case here, the full p_lo is not required.
        // Effectively we only need to add the highest bit in p_lo to p_hi (and
        // Q_hi + 1 does not overflow).

        Q += std::uint64_t{1} << (64u - 32u - 1u); // round, ties up

        const std::uint64_t h = p3 + p2_hi + p1_hi + (Q >> 32u);

        return {h, x.e + y.e + 64};
    }

    /*!
    @brief normalize x such that the significand is >= 2^(q-1)
    @pre x.f != 0
    */
    static diyfp normalize(diyfp x) noexcept
    {
        JSON_ASSERT(x.f != 0);

        while ((x.f >> 63u) == 0)
        {
            x.f <<= 1u;
            x.e--;
        }

        return x;
    }

    /*!
    @brief normalize x such that the result has the exponent E
    @pre e >= x.e and the upper e - x.e bits of x.f must be zero.
    */
    static diyfp normalize_to(const diyfp& x, const int target_exponent) noexcept
    {
        const int delta = x.e - target_exponent;

        JSON_ASSERT(delta >= 0);
        JSON_ASSERT(((x.f << delta) >> delta) == x.f);

        return {x.f << delta, target_exponent};
    }
};

struct boundaries
{
    diyfp w;
    diyfp minus;
    diyfp plus;
};

/*!
Compute the (normalized) diyfp representing the input number 'value' and its
boundaries.

@pre value must be finite and positive
*/
template<typename FloatType>
boundaries compute_boundaries(FloatType value)
{
    JSON_ASSERT(std::isfinite(value));
    JSON_ASSERT(value > 0);

    // Convert the IEEE representation into a diyfp.
    //
    // If v is denormal:
    //      value = 0.F * 2^(1 - bias) = (          F) * 2^(1 - bias - (p-1))
    // If v is normalized:
    //      value = 1.F * 2^(E - bias) = (2^(p-1) + F) * 2^(E - bias - (p-1))

    static_assert(std::numeric_limits<FloatType>::is_iec559,
                  "internal error: dtoa_short requires an IEEE-754 floating-point implementation");

    constexpr int      kPrecision = std::numeric_limits<FloatType>::digits; // = p (includes the hidden bit)
    constexpr int      kBias      = std::numeric_limits<FloatType>::max_exponent - 1 + (kPrecision - 1);
    constexpr int      kMinExp    = 1 - kBias;
    constexpr std::uint64_t kHiddenBit = std::uint64_t{1} << (kPrecision - 1); // = 2^(p-1)

    using bits_type = typename std::conditional<kPrecision == 24, std::uint32_t, std::uint64_t >::type;

    const std::uint64_t bits = reinterpret_bits<bits_type>(value);
    const std::uint64_t E = bits >> (kPrecision - 1);
    const std::uint64_t F = bits & (kHiddenBit - 1);

    const bool is_denormal = E == 0;
    const diyfp v = is_denormal
                    ? diyfp(F, kMinExp)
                    : diyfp(F + kHiddenBit, static_cast<int>(E) - kBias);

    // Compute the boundaries m- and m+ of the floating-point value
    // v = f * 2^e.
    //
    // Determine v- and v+, the floating-point predecessor and successor if v,
    // respectively.
    //
    //      v- = v - 2^e        if f != 2^(p-1) or e == e_min                (A)
    //         = v - 2^(e-1)    if f == 2^(p-1) and e > e_min                (B)
    //
    //      v+ = v + 2^e
    //
    // Let m- = (v- + v) / 2 and m+ = (v + v+) / 2. All real numbers _strictly_
    // between m- and m+ round to v, regardless of how the input rounding
    // algorithm breaks ties.
    //
    //      ---+-------------+-------------+-------------+-------------+---  (A)
    //         v-            m-            v             m+            v+
    //
    //      -----------------+------+------+-------------+-------------+---  (B)
    //                       v-     m-     v             m+            v+

    const bool lower_boundary_is_closer = F == 0 && E > 1;
    const diyfp m_plus = diyfp(2 * v.f + 1, v.e - 1);
    const diyfp m_minus = lower_boundary_is_closer
                          ? diyfp(4 * v.f - 1, v.e - 2)  // (B)
                          : diyfp(2 * v.f - 1, v.e - 1); // (A)

    // Determine the normalized w+ = m+.
    const diyfp w_plus = diyfp::normalize(m_plus);

    // Determine w- = m- such that e_(w-) = e_(w+).
    const diyfp w_minus = diyfp::normalize_to(m_minus, w_plus.e);

    return {diyfp::normalize(v), w_minus, w_plus};
}

// Given normalized diyfp w, Grisu needs to find a (normalized) cached
// power-of-ten c, such that the exponent of the product c * w = f * 2^e lies
// within a certain range [alpha, gamma] (Definition 3.2 from [1])
//
//      alpha <= e = e_c + e_w + q <= gamma
//
// or
//
//      f_c * f_w * 2^alpha <= f_c 2^(e_c) * f_w 2^(e_w) * 2^q
//                          <= f_c * f_w * 2^gamma
//
// Since c and w are normalized, i.e. 2^(q-1) <= f < 2^q, this implies
//
//      2^(q-1) * 2^(q-1) * 2^alpha <= c * w * 2^q < 2^q * 2^q * 2^gamma
//
// or
//
//      2^(q - 2 + alpha) <= c * w < 2^(q + gamma)
//
// The choice of (alpha,gamma) determines the size of the table and the form of
// the digit generation procedure. Using (alpha,gamma)=(-60,-32) works out well
// in practice:
//
// The idea is to cut the number c * w = f * 2^e into two parts, which can be
// processed independently: An integral part p1, and a fractional part p2:
//
//      f * 2^e = ( (f div 2^-e) * 2^-e + (f mod 2^-e) ) * 2^e
//              = (f div 2^-e) + (f mod 2^-e) * 2^e
//              = p1 + p2 * 2^e
//
// The conversion of p1 into decimal form requires a series of divisions and
// modulos by (a power of) 10. These operations are faster for 32-bit than for
// 64-bit integers, so p1 should ideally fit into a 32-bit integer. This can be
// achieved by choosing
//
//      -e >= 32   or   e <= -32 := gamma
//
// In order to convert the fractional part
//
//      p2 * 2^e = p2 / 2^-e = d[-1] / 10^1 + d[-2] / 10^2 + ...
//
// into decimal form, the fraction is repeatedly multiplied by 10 and the digits
// d[-i] are extracted in order:
//
//      (10 * p2) div 2^-e = d[-1]
//      (10 * p2) mod 2^-e = d[-2] / 10^1 + ...
//
// The multiplication by 10 must not overflow. It is sufficient to choose
//
//      10 * p2 < 16 * p2 = 2^4 * p2 <= 2^64.
//
// Since p2 = f mod 2^-e < 2^-e,
//
//      -e <= 60   or   e >= -60 := alpha

constexpr int kAlpha = -60;
constexpr int kGamma = -32;

struct cached_power // c = f * 2^e ~= 10^k
{
    std::uint64_t f;
    int e;
    int k;
};

/*!
For a normalized diyfp w = f * 2^e, this function returns a (normalized) cached
power-of-ten c = f_c * 2^e_c, such that the exponent of the product w * c
satisfies (Definition 3.2 from [1])

     alpha <= e_c + e + q <= gamma.
*/
inline cached_power get_cached_power_for_binary_exponent(int e)
{
    // Now
    //
    //      alpha <= e_c + e + q <= gamma                                    (1)
    //      ==> f_c * 2^alpha <= c * 2^e * 2^q
    //
    // and since the c's are normalized, 2^(q-1) <= f_c,
    //
    //      ==> 2^(q - 1 + alpha) <= c * 2^(e + q)
    //      ==> 2^(alpha - e - 1) <= c
    //
    // If c were an exact power of ten, i.e. c = 10^k, one may determine k as
    //
    //      k = ceil( log_10( 2^(alpha - e - 1) ) )
    //        = ceil( (alpha - e - 1) * log_10(2) )
    //
    // From the paper:
    // "In theory the result of the procedure could be wrong since c is rounded,
    //  and the computation itself is approximated [...]. In practice, however,
    //  this simple function is sufficient."
    //
    // For IEEE double precision floating-point numbers converted into
    // normalized diyfp's w = f * 2^e, with q = 64,
    //
    //      e >= -1022      (min IEEE exponent)
    //           -52        (p - 1)
    //           -52        (p - 1, possibly normalize denormal IEEE numbers)
    //           -11        (normalize the diyfp)
    //         = -1137
    //
    // and
    //
    //      e <= +1023      (max IEEE exponent)
    //           -52        (p - 1)
    //           -11        (normalize the diyfp)
    //         = 960
    //
    // This binary exponent range [-1137,960] results in a decimal exponent
    // range [-307,324]. One does not need to store a cached power for each
    // k in this range. For each such k it suffices to find a cached power
    // such that the exponent of the product lies in [alpha,gamma].
    // This implies that the difference of the decimal exponents of adjacent
    // table entries must be less than or equal to
    //
    //      floor( (gamma - alpha) * log_10(2) ) = 8.
    //
    // (A smaller distance gamma-alpha would require a larger table.)

    // NB:
    // Actually this function returns c, such that -60 <= e_c + e + 64 <= -34.

    constexpr int kCachedPowersMinDecExp = -300;
    constexpr int kCachedPowersDecStep = 8;

    static constexpr std::array<cached_power, 79> kCachedPowers =
    {
        {
            { 0xAB70FE17C79AC6CA, -1060, -300 },
            { 0xFF77B1FCBEBCDC4F, -1034, -292 },
            { 0xBE5691EF416BD60C, -1007, -284 },
            { 0x8DD01FAD907FFC3C,  -980, -276 },
            { 0xD3515C2831559A83,  -954, -268 },
            { 0x9D71AC8FADA6C9B5,  -927, -260 },
            { 0xEA9C227723EE8BCB,  -901, -252 },
            { 0xAECC49914078536D,  -874, -244 },
            { 0x823C12795DB6CE57,  -847, -236 },
            { 0xC21094364DFB5637,  -821, -228 },
            { 0x9096EA6F3848984F,  -794, -220 },
            { 0xD77485CB25823AC7,  -768, -212 },
            { 0xA086CFCD97BF97F4,  -741, -204 },
            { 0xEF340A98172AACE5,  -715, -196 },
            { 0xB23867FB2A35B28E,  -688, -188 },
            { 0x84C8D4DFD2C63F3B,  -661, -180 },
            { 0xC5DD44271AD3CDBA,  -635, -172 },
            { 0x936B9FCEBB25C996,  -608, -164 },
            { 0xDBAC6C247D62A584,  -582, -156 },
            { 0xA3AB66580D5FDAF6,  -555, -148 },
            { 0xF3E2F893DEC3F126,  -529, -140 },
            { 0xB5B5ADA8AAFF80B8,  -502, -132 },
            { 0x87625F056C7C4A8B,  -475, -124 },
            { 0xC9BCFF6034C13053,  -449, -116 },
            { 0x964E858C91BA2655,  -422, -108 },
            { 0xDFF9772470297EBD,  -396, -100 },
            { 0xA6DFBD9FB8E5B88F,  -369,  -92 },
            { 0xF8A95FCF88747D94,  -343,  -84 },
            { 0xB94470938FA89BCF,  -316,  -76 },
            { 0x8A08F0F8BF0F156B,  -289,  -68 },
            { 0xCDB02555653131B6,  -263,  -60 },
            { 0x993FE2C6D07B7FAC,  -236,  -52 },
            { 0xE45C10C42A2B3B06,  -210,  -44 },
            { 0xAA242499697392D3,  -183,  -36 },
            { 0xFD87B5F28300CA0E,  -157,  -28 },
            { 0xBCE5086492111AEB,  -130,  -20 },
            { 0x8CBCCC096F5088CC,  -103,  -12 },
            { 0xD1B71758E219652C,   -77,   -4 },
            { 0x9C40000000000000,   -50,    4 },
            { 0xE8D4A51000000000,   -24,   12 },
            { 0xAD78EBC5AC620000,     3,   20 },
            { 0x813F3978F8940984,    30,   28 },
            { 0xC097CE7BC90715B3,    56,   36 },
            { 0x8F7E32CE7BEA5C70,    83,   44 },
            { 0xD5D238A4ABE98068,   109,   52 },
            { 0x9F4F2726179A2245,   136,   60 },
            { 0xED63A231D4C4FB27,   162,   68 },
            { 0xB0DE65388CC8ADA8,   189,   76 },
            { 0x83C7088E1AAB65DB,   216,   84 },
            { 0xC45D1DF942711D9A,   242,   92 },
            { 0x924D692CA61BE758,   269,  100 },
            { 0xDA01EE641A708DEA,   295,  108 },
            { 0xA26DA3999AEF774A,   322,  116 },
            { 0xF209787BB47D6B85,   348,  124 },
            { 0xB454E4A179DD1877,   375,  132 },
            { 0x865B86925B9BC5C2,   402,  140 },
            { 0xC83553C5C8965D3D,   428,  148 },
            { 0x952AB45CFA97A0B3,   455,  156 },
            { 0xDE469FBD99A05FE3,   481,  164 },
            { 0xA59BC234DB398C25,   508,  172 },
            { 0xF6C69A72A3989F5C,   534,  180 },
            { 0xB7DCBF5354E9BECE,   561,  188 },
            { 0x88FCF317F22241E2,   588,  196 },
            { 0xCC20CE9BD35C78A5,   614,  204 },
            { 0x98165AF37B2153DF,   641,  212 },
            { 0xE2A0B5DC971F303A,   667,  220 },
            { 0xA8D9D1535CE3B396,   694,  228 },
            { 0xFB9B7CD9A4A7443C,   720,  236 },
            { 0xBB764C4CA7A44410,   747,  244 },
            { 0x8BAB8EEFB6409C1A,   774,  252 },
            { 0xD01FEF10A657842C,   800,  260 },
            { 0x9B10A4E5E9913129,   827,  268 },
            { 0xE7109BFBA19C0C9D,   853,  276 },
            { 0xAC2820D9623BF429,   880,  284 },
            { 0x80444B5E7AA7CF85,   907,  292 },
            { 0xBF21E44003ACDD2D,   933,  300 },
            { 0x8E679C2F5E44FF8F,   960,  308 },
            { 0xD433179D9C8CB841,   986,  316 },
            { 0x9E19DB92B4E31BA9,  1013,  324 },
        }
    };

    // This computation gives exactly the same results for k as
    //      k = ceil((kAlpha - e - 1) * 0.30102999566398114)
    // for |e| <= 1500, but doesn't require floating-point operations.
    // NB: log_10(2) ~= 78913 / 2^18
    JSON_ASSERT(e >= -1500);
    JSON_ASSERT(e <=  1500);
    const int f = kAlpha - e - 1;
    const int k = (f * 78913) / (1 << 18) + static_cast<int>(f > 0);

    const int index = (-kCachedPowersMinDecExp + k + (kCachedPowersDecStep - 1)) / kCachedPowersDecStep;
    JSON_ASSERT(index >= 0);
    JSON_ASSERT(static_cast<std::size_t>(index) < kCachedPowers.size());

    const cached_power cached = kCachedPowers[static_cast<std::size_t>(index)];
    JSON_ASSERT(kAlpha <= cached.e + e + 64);
    JSON_ASSERT(kGamma >= cached.e + e + 64);

    return cached;
}

/*!
For n != 0, returns k, such that pow10 := 10^(k-1) <= n < 10^k.
For n == 0, returns 1 and sets pow10 := 1.
*/
inline int find_largest_pow10(const std::uint32_t n, std::uint32_t& pow10)
{
    // LCOV_EXCL_START
    if (n >= 1000000000)
    {
        pow10 = 1000000000;
        return 10;
    }
    // LCOV_EXCL_STOP
    else if (n >= 100000000)
    {
        pow10 = 100000000;
        return  9;
    }
    else if (n >= 10000000)
    {
        pow10 = 10000000;
        return  8;
    }
    else if (n >= 1000000)
    {
        pow10 = 1000000;
        return  7;
    }
    else if (n >= 100000)
    {
        pow10 = 100000;
        return  6;
    }
    else if (n >= 10000)
    {
        pow10 = 10000;
        return  5;
    }
    else if (n >= 1000)
    {
        pow10 = 1000;
        return  4;
    }
    else if (n >= 100)
    {
        pow10 = 100;
        return  3;
    }
    else if (n >= 10)
    {
        pow10 = 10;
        return  2;
    }
    else
    {
        pow10 = 1;
        return 1;
    }
}

inline void grisu2_round(char* buf, int len, std::uint64_t dist, std::uint64_t delta,
                         std::uint64_t rest, std::uint64_t ten_k)
{
    JSON_ASSERT(len >= 1);
    JSON_ASSERT(dist <= delta);
    JSON_ASSERT(rest <= delta);
    JSON_ASSERT(ten_k > 0);

    //               <--------------------------- delta ---->
    //                                  <---- dist --------->
    // --------------[------------------+-------------------]--------------
    //               M-                 w                   M+
    //
    //                                  ten_k
    //                                <------>
    //                                       <---- rest ---->
    // --------------[------------------+----+--------------]--------------
    //                                  w    V
    //                                       = buf * 10^k
    //
    // ten_k represents a unit-in-the-last-place in the decimal representation
    // stored in buf.
    // Decrement buf by ten_k while this takes buf closer to w.

    // The tests are written in this order to avoid overflow in unsigned
    // integer arithmetic.

    while (rest < dist
            && delta - rest >= ten_k
            && (rest + ten_k < dist || dist - rest > rest + ten_k - dist))
    {
        JSON_ASSERT(buf[len - 1] != '0');
        buf[len - 1]--;
        rest += ten_k;
    }
}

/*!
Generates V = buffer * 10^decimal_exponent, such that M- <= V <= M+.
M- and M+ must be normalized and share the same exponent -60 <= e <= -32.
*/
inline void grisu2_digit_gen(char* buffer, int& length, int& decimal_exponent,
                             diyfp M_minus, diyfp w, diyfp M_plus)
{
    static_assert(kAlpha >= -60, "internal error");
    static_assert(kGamma <= -32, "internal error");

    // Generates the digits (and the exponent) of a decimal floating-point
    // number V = buffer * 10^decimal_exponent in the range [M-, M+]. The diyfp's
    // w, M- and M+ share the same exponent e, which satisfies alpha <= e <= gamma.
    //
    //               <--------------------------- delta ---->
    //                                  <---- dist --------->
    // --------------[------------------+-------------------]--------------
    //               M-                 w                   M+
    //
    // Grisu2 generates the digits of M+ from left to right and stops as soon as
    // V is in [M-,M+].

    JSON_ASSERT(M_plus.e >= kAlpha);
    JSON_ASSERT(M_plus.e <= kGamma);

    std::uint64_t delta = diyfp::sub(M_plus, M_minus).f; // (significand of (M+ - M-), implicit exponent is e)
    std::uint64_t dist  = diyfp::sub(M_plus, w      ).f; // (significand of (M+ - w ), implicit exponent is e)

    // Split M+ = f * 2^e into two parts p1 and p2 (note: e < 0):
    //
    //      M+ = f * 2^e
    //         = ((f div 2^-e) * 2^-e + (f mod 2^-e)) * 2^e
    //         = ((p1        ) * 2^-e + (p2        )) * 2^e
    //         = p1 + p2 * 2^e

    const diyfp one(std::uint64_t{1} << -M_plus.e, M_plus.e);

    auto p1 = static_cast<std::uint32_t>(M_plus.f >> -one.e); // p1 = f div 2^-e (Since -e >= 32, p1 fits into a 32-bit int.)
    std::uint64_t p2 = M_plus.f & (one.f - 1);                    // p2 = f mod 2^-e

    // 1)
    //
    // Generate the digits of the integral part p1 = d[n-1]...d[1]d[0]

    JSON_ASSERT(p1 > 0);

    std::uint32_t pow10;
    const int k = find_largest_pow10(p1, pow10);

    //      10^(k-1) <= p1 < 10^k, pow10 = 10^(k-1)
    //
    //      p1 = (p1 div 10^(k-1)) * 10^(k-1) + (p1 mod 10^(k-1))
    //         = (d[k-1]         ) * 10^(k-1) + (p1 mod 10^(k-1))
    //
    //      M+ = p1                                             + p2 * 2^e
    //         = d[k-1] * 10^(k-1) + (p1 mod 10^(k-1))          + p2 * 2^e
    //         = d[k-1] * 10^(k-1) + ((p1 mod 10^(k-1)) * 2^-e + p2) * 2^e
    //         = d[k-1] * 10^(k-1) + (                         rest) * 2^e
    //
    // Now generate the digits d[n] of p1 from left to right (n = k-1,...,0)
    //
    //      p1 = d[k-1]...d[n] * 10^n + d[n-1]...d[0]
    //
    // but stop as soon as
    //
    //      rest * 2^e = (d[n-1]...d[0] * 2^-e + p2) * 2^e <= delta * 2^e

    int n = k;
    while (n > 0)
    {
        // Invariants:
        //      M+ = buffer * 10^n + (p1 + p2 * 2^e)    (buffer = 0 for n = k)
        //      pow10 = 10^(n-1) <= p1 < 10^n
        //
        const std::uint32_t d = p1 / pow10;  // d = p1 div 10^(n-1)
        const std::uint32_t r = p1 % pow10;  // r = p1 mod 10^(n-1)
        //
        //      M+ = buffer * 10^n + (d * 10^(n-1) + r) + p2 * 2^e
        //         = (buffer * 10 + d) * 10^(n-1) + (r + p2 * 2^e)
        //
        JSON_ASSERT(d <= 9);
        buffer[length++] = static_cast<char>('0' + d); // buffer := buffer * 10 + d
        //
        //      M+ = buffer * 10^(n-1) + (r + p2 * 2^e)
        //
        p1 = r;
        n--;
        //
        //      M+ = buffer * 10^n + (p1 + p2 * 2^e)
        //      pow10 = 10^n
        //

        // Now check if enough digits have been generated.
        // Compute
        //
        //      p1 + p2 * 2^e = (p1 * 2^-e + p2) * 2^e = rest * 2^e
        //
        // Note:
        // Since rest and delta share the same exponent e, it suffices to
        // compare the significands.
        const std::uint64_t rest = (std::uint64_t{p1} << -one.e) + p2;
        if (rest <= delta)
        {
            // V = buffer * 10^n, with M- <= V <= M+.

            decimal_exponent += n;

            // We may now just stop. But instead look if the buffer could be
            // decremented to bring V closer to w.
            //
            // pow10 = 10^n is now 1 ulp in the decimal representation V.
            // The rounding procedure works with diyfp's with an implicit
            // exponent of e.
            //
            //      10^n = (10^n * 2^-e) * 2^e = ulp * 2^e
            //
            const std::uint64_t ten_n = std::uint64_t{pow10} << -one.e;
            grisu2_round(buffer, length, dist, delta, rest, ten_n);

            return;
        }

        pow10 /= 10;
        //
        //      pow10 = 10^(n-1) <= p1 < 10^n
        // Invariants restored.
    }

    // 2)
    //
    // The digits of the integral part have been generated:
    //
    //      M+ = d[k-1]...d[1]d[0] + p2 * 2^e
    //         = buffer            + p2 * 2^e
    //
    // Now generate the digits of the fractional part p2 * 2^e.
    //
    // Note:
    // No decimal point is generated: the exponent is adjusted instead.
    //
    // p2 actually represents the fraction
    //
    //      p2 * 2^e
    //          = p2 / 2^-e
    //          = d[-1] / 10^1 + d[-2] / 10^2 + ...
    //
    // Now generate the digits d[-m] of p1 from left to right (m = 1,2,...)
    //
    //      p2 * 2^e = d[-1]d[-2]...d[-m] * 10^-m
    //                      + 10^-m * (d[-m-1] / 10^1 + d[-m-2] / 10^2 + ...)
    //
    // using
    //
    //      10^m * p2 = ((10^m * p2) div 2^-e) * 2^-e + ((10^m * p2) mod 2^-e)
    //                = (                   d) * 2^-e + (                   r)
    //
    // or
    //      10^m * p2 * 2^e = d + r * 2^e
    //
    // i.e.
    //
    //      M+ = buffer + p2 * 2^e
    //         = buffer + 10^-m * (d + r * 2^e)
    //         = (buffer * 10^m + d) * 10^-m + 10^-m * r * 2^e
    //
    // and stop as soon as 10^-m * r * 2^e <= delta * 2^e

    JSON_ASSERT(p2 > delta);

    int m = 0;
    for (;;)
    {
        // Invariant:
        //      M+ = buffer * 10^-m + 10^-m * (d[-m-1] / 10 + d[-m-2] / 10^2 + ...) * 2^e
        //         = buffer * 10^-m + 10^-m * (p2                                 ) * 2^e
        //         = buffer * 10^-m + 10^-m * (1/10 * (10 * p2)                   ) * 2^e
        //         = buffer * 10^-m + 10^-m * (1/10 * ((10*p2 div 2^-e) * 2^-e + (10*p2 mod 2^-e)) * 2^e
        //
        JSON_ASSERT(p2 <= (std::numeric_limits<std::uint64_t>::max)() / 10);
        p2 *= 10;
        const std::uint64_t d = p2 >> -one.e;     // d = (10 * p2) div 2^-e
        const std::uint64_t r = p2 & (one.f - 1); // r = (10 * p2) mod 2^-e
        //
        //      M+ = buffer * 10^-m + 10^-m * (1/10 * (d * 2^-e + r) * 2^e
        //         = buffer * 10^-m + 10^-m * (1/10 * (d + r * 2^e))
        //         = (buffer * 10 + d) * 10^(-m-1) + 10^(-m-1) * r * 2^e
        //
        JSON_ASSERT(d <= 9);
        buffer[length++] = static_cast<char>('0' + d); // buffer := buffer * 10 + d
        //
        //      M+ = buffer * 10^(-m-1) + 10^(-m-1) * r * 2^e
        //
        p2 = r;
        m++;
        //
        //      M+ = buffer * 10^-m + 10^-m * p2 * 2^e
        // Invariant restored.

        // Check if enough digits have been generated.
        //
        //      10^-m * p2 * 2^e <= delta * 2^e
        //              p2 * 2^e <= 10^m * delta * 2^e
        //                    p2 <= 10^m * delta
        delta *= 10;
        dist  *= 10;
        if (p2 <= delta)
        {
            break;
        }
    }

    // V = buffer * 10^-m, with M- <= V <= M+.

    decimal_exponent -= m;

    // 1 ulp in the decimal representation is now 10^-m.
    // Since delta and dist are now scaled by 10^m, we need to do the
    // same with ulp in order to keep the units in sync.
    //
    //      10^m * 10^-m = 1 = 2^-e * 2^e = ten_m * 2^e
    //
    const std::uint64_t ten_m = one.f;
    grisu2_round(buffer, length, dist, delta, p2, ten_m);

    // By construction this algorithm generates the shortest possible decimal
    // number (Loitsch, Theorem 6.2) which rounds back to w.
    // For an input number of precision p, at least
    //
    //      N = 1 + ceil(p * log_10(2))
    //
    // decimal digits are sufficient to identify all binary floating-point
    // numbers (Matula, "In-and-Out conversions").
    // This implies that the algorithm does not produce more than N decimal
    // digits.
    //
    //      N = 17 for p = 53 (IEEE double precision)
    //      N = 9  for p = 24 (IEEE single precision)
}

/*!
v = buf * 10^decimal_exponent
len is the length of the buffer (number of decimal digits)
The buffer must be large enough, i.e. >= max_digits10.
*/
JSON_HEDLEY_NON_NULL(1)
inline void grisu2(char* buf, int& len, int& decimal_exponent,
                   diyfp m_minus, diyfp v, diyfp m_plus)
{
    JSON_ASSERT(m_plus.e == m_minus.e);
    JSON_ASSERT(m_plus.e == v.e);

    //  --------(-----------------------+-----------------------)--------    (A)
    //          m-                      v                       m+
    //
    //  --------------------(-----------+-----------------------)--------    (B)
    //                      m-          v                       m+
    //
    // First scale v (and m- and m+) such that the exponent is in the range
    // [alpha, gamma].

    const cached_power cached = get_cached_power_for_binary_exponent(m_plus.e);

    const diyfp c_minus_k(cached.f, cached.e); // = c ~= 10^-k

    // The exponent of the products is = v.e + c_minus_k.e + q and is in the range [alpha,gamma]
    const diyfp w       = diyfp::mul(v,       c_minus_k);
    const diyfp w_minus = diyfp::mul(m_minus, c_minus_k);
    const diyfp w_plus  = diyfp::mul(m_plus,  c_minus_k);

    //  ----(---+---)---------------(---+---)---------------(---+---)----
    //          w-                      w                       w+
    //          = c*m-                  = c*v                   = c*m+
    //
    // diyfp::mul rounds its result and c_minus_k is approximated too. w, w- and
    // w+ are now off by a small amount.
    // In fact:
    //
    //      w - v * 10^k < 1 ulp
    //
    // To account for this inaccuracy, add resp. subtract 1 ulp.
    //
    //  --------+---[---------------(---+---)---------------]---+--------
    //          w-  M-                  w                   M+  w+
    //
    // Now any number in [M-, M+] (bounds included) will round to w when input,
    // regardless of how the input rounding algorithm breaks ties.
    //
    // And digit_gen generates the shortest possible such number in [M-, M+].
    // Note that this does not mean that Grisu2 always generates the shortest
    // possible number in the interval (m-, m+).
    const diyfp M_minus(w_minus.f + 1, w_minus.e);
    const diyfp M_plus (w_plus.f  - 1, w_plus.e );

    decimal_exponent = -cached.k; // = -(-k) = k

    grisu2_digit_gen(buf, len, decimal_exponent, M_minus, w, M_plus);
}

/*!
v = buf * 10^decimal_exponent
len is the length of the buffer (number of decimal digits)
The buffer must be large enough, i.e. >= max_digits10.
*/
template<typename FloatType>
JSON_HEDLEY_NON_NULL(1)
void grisu2(char* buf, int& len, int& decimal_exponent, FloatType value)
{
    static_assert(diyfp::kPrecision >= std::numeric_limits<FloatType>::digits + 3,
                  "internal error: not enough precision");

    JSON_ASSERT(std::isfinite(value));
    JSON_ASSERT(value > 0);

    // If the neighbors (and boundaries) of 'value' are always computed for double-precision
    // numbers, all float's can be recovered using strtod (and strtof). However, the resulting
    // decimal representations are not exactly "short".
    //
    // The documentation for 'std::to_chars' (https://en.cppreference.com/w/cpp/utility/to_chars)
    // says "value is converted to a string as if by std::sprintf in the default ("C") locale"
    // and since sprintf promotes float's to double's, I think this is exactly what 'std::to_chars'
    // does.
    // On the other hand, the documentation for 'std::to_chars' requires that "parsing the
    // representation using the corresponding std::from_chars function recovers value exactly". That
    // indicates that single precision floating-point numbers should be recovered using
    // 'std::strtof'.
    //
    // NB: If the neighbors are computed for single-precision numbers, there is a single float
    //     (7.0385307e-26f) which can't be recovered using strtod. The resulting double precision
    //     value is off by 1 ulp.
#if 0
    const boundaries w = compute_boundaries(static_cast<double>(value));
#else
    const boundaries w = compute_boundaries(value);
#endif

    grisu2(buf, len, decimal_exponent, w.minus, w.w, w.plus);
}

/*!
@brief appends a decimal representation of e to buf
@return a pointer to the element following the exponent.
@pre -1000 < e < 1000
*/
JSON_HEDLEY_NON_NULL(1)
JSON_HEDLEY_RETURNS_NON_NULL
inline char* append_exponent(char* buf, int e)
{
    JSON_ASSERT(e > -1000);
    JSON_ASSERT(e <  1000);

    if (e < 0)
    {
        e = -e;
        *buf++ = '-';
    }
    else
    {
        *buf++ = '+';
    }

    auto k = static_cast<std::uint32_t>(e);
    if (k < 10)
    {
        // Always print at least two digits in the exponent.
        // This is for compatibility with printf("%g").
        *buf++ = '0';
        *buf++ = static_cast<char>('0' + k);
    }
    else if (k < 100)
    {
        *buf++ = static_cast<char>('0' + k / 10);
        k %= 10;
        *buf++ = static_cast<char>('0' + k);
    }
    else
    {
        *buf++ = static_cast<char>('0' + k / 100);
        k %= 100;
        *buf++ = static_cast<char>('0' + k / 10);
        k %= 10;
        *buf++ = static_cast<char>('0' + k);
    }

    return buf;
}

/*!
@brief prettify v = buf * 10^decimal_exponent

If v is in the range [10^min_exp, 10^max_exp) it will be printed in fixed-point
notation. Otherwise it will be printed in exponential notation.

@pre min_exp < 0
@pre max_exp > 0
*/
JSON_HEDLEY_NON_NULL(1)
JSON_HEDLEY_RETURNS_NON_NULL
inline char* format_buffer(char* buf, int len, int decimal_exponent,
                           int min_exp, int max_exp)
{
    JSON_ASSERT(min_exp < 0);
    JSON_ASSERT(max_exp > 0);

    const int k = len;
    const int n = len + decimal_exponent;

    // v = buf * 10^(n-k)
    // k is the length of the buffer (number of decimal digits)
    // n is the position of the decimal point relative to the start of the buffer.

    if (k <= n && n <= max_exp)
    {
        // digits[000]
        // len <= max_exp + 2

        std::memset(buf + k, '0', static_cast<size_t>(n) - static_cast<size_t>(k));
        // Make it look like a floating-point number (#362, #378)
        buf[n + 0] = '.';
        buf[n + 1] = '0';
        return buf + (static_cast<size_t>(n) + 2);
    }

    if (0 < n && n <= max_exp)
    {
        // dig.its
        // len <= max_digits10 + 1

        JSON_ASSERT(k > n);

        std::memmove(buf + (static_cast<size_t>(n) + 1), buf + n, static_cast<size_t>(k) - static_cast<size_t>(n));
        buf[n] = '.';
        return buf + (static_cast<size_t>(k) + 1U);
    }

    if (min_exp < n && n <= 0)
    {
        // 0.[000]digits
        // len <= 2 + (-min_exp - 1) + max_digits10

        std::memmove(buf + (2 + static_cast<size_t>(-n)), buf, static_cast<size_t>(k));
        buf[0] = '0';
        buf[1] = '.';
        std::memset(buf + 2, '0', static_cast<size_t>(-n));
        return buf + (2U + static_cast<size_t>(-n) + static_cast<size_t>(k));
    }

    if (k == 1)
    {
        // dE+123
        // len <= 1 + 5

        buf += 1;
    }
    else
    {
        // d.igitsE+123
        // len <= max_digits10 + 1 + 5

        std::memmove(buf + 2, buf + 1, static_cast<size_t>(k) - 1);
        buf[1] = '.';
        buf += 1 + static_cast<size_t>(k);
    }

    *buf++ = 'e';
    return append_exponent(buf, n - 1);
}

} // namespace dtoa_impl

/*!
@brief generates a decimal representation of the floating-point number value in [first, last).

The format of the resulting decimal representation is similar to printf's %g
format. Returns an iterator pointing past-the-end of the decimal representation.

@note The input number must be finite, i.e. NaN's and Inf's are not supported.
@note The buffer must be large enough.
@note The result is NOT null-terminated.
*/
template<typename FloatType>
JSON_HEDLEY_NON_NULL(1, 2)
JSON_HEDLEY_RETURNS_NON_NULL
char* to_chars(char* first, const char* last, FloatType value)
{
    static_cast<void>(last); // maybe unused - fix warning
    JSON_ASSERT(std::isfinite(value));

    // Use signbit(value) instead of (value < 0) since signbit works for -0.
    if (std::signbit(value))
    {
        value = -value;
        *first++ = '-';
    }

    if (value == 0) // +-0
    {
        *first++ = '0';
        // Make it look like a floating-point number (#362, #378)
        *first++ = '.';
        *first++ = '0';
        return first;
    }

    JSON_ASSERT(last - first >= std::numeric_limits<FloatType>::max_digits10);

    // Compute v = buffer * 10^decimal_exponent.
    // The decimal digits are stored in the buffer, which needs to be interpreted
    // as an unsigned decimal integer.
    // len is the length of the buffer, i.e. the number of decimal digits.
    int len = 0;
    int decimal_exponent = 0;
    dtoa_impl::grisu2(first, len, decimal_exponent, value);

    JSON_ASSERT(len <= std::numeric_limits<FloatType>::max_digits10);

    // Format the buffer like printf("%.*g", prec, value)
    constexpr int kMinExp = -4;
    // Use digits10 here to increase compatibility with version 2.
    constexpr int kMaxExp = std::numeric_limits<FloatType>::digits10;

    JSON_ASSERT(last - first >= kMaxExp + 2);
    JSON_ASSERT(last - first >= 2 + (-kMinExp - 1) + std::numeric_limits<FloatType>::max_digits10);
    JSON_ASSERT(last - first >= std::numeric_limits<FloatType>::max_digits10 + 6);

    return dtoa_impl::format_buffer(first, len, decimal_exponent, kMinExp, kMaxExp);
}

} // namespace detail
} // namespace nlohmann

// #include <nlohmann/detail/exceptions.hpp>

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/meta/cpp_future.hpp>

// #include <nlohmann/detail/output/binary_writer.hpp>

// #include <nlohmann/detail/output/output_adapters.hpp>

// #include <nlohmann/detail/value_t.hpp>


namespace nlohmann
{
namespace detail
{
///////////////////
// serialization //
///////////////////

/// how to treat decoding errors
enum class error_handler_t
{
    strict,  ///< throw a type_error exception in case of invalid UTF-8
    replace, ///< replace invalid UTF-8 sequences with U+FFFD
    ignore   ///< ignore invalid UTF-8 sequences
};

template<typename BasicJsonType>
class serializer
{
    using string_t = typename BasicJsonType::string_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using binary_char_t = typename BasicJsonType::binary_t::value_type;
    static constexpr std::uint8_t UTF8_ACCEPT = 0;
    static constexpr std::uint8_t UTF8_REJECT = 1;

  public:
    /*!
    @param[in] s  output stream to serialize to
    @param[in] ichar  indentation character to use
    @param[in] error_handler_  how to react on decoding errors
    */
    serializer(output_adapter_t<char> s, const char ichar,
               error_handler_t error_handler_ = error_handler_t::strict)
        : o(std::move(s))
        , loc(std::localeconv())
        , thousands_sep(loc->thousands_sep == nullptr ? '\0' : std::char_traits<char>::to_char_type(* (loc->thousands_sep)))
        , decimal_point(loc->decimal_point == nullptr ? '\0' : std::char_traits<char>::to_char_type(* (loc->decimal_point)))
        , indent_char(ichar)
        , indent_string(512, indent_char)
        , error_handler(error_handler_)
    {}

    // delete because of pointer members
    serializer(const serializer&) = delete;
    serializer& operator=(const serializer&) = delete;
    serializer(serializer&&) = delete;
    serializer& operator=(serializer&&) = delete;
    ~serializer() = default;

    /*!
    @brief internal implementation of the serialization function

    This function is called by the public member function dump and organizes
    the serialization internally. The indentation level is propagated as
    additional parameter. In case of arrays and objects, the function is
    called recursively.

    - strings and object keys are escaped using `escape_string()`
    - integer numbers are converted implicitly via `operator<<`
    - floating-point numbers are converted to a string using `"%g"` format
    - binary values are serialized as objects containing the subtype and the
      byte array

    @param[in] val               value to serialize
    @param[in] pretty_print      whether the output shall be pretty-printed
    @param[in] ensure_ascii If @a ensure_ascii is true, all non-ASCII characters
    in the output are escaped with `\uXXXX` sequences, and the result consists
    of ASCII characters only.
    @param[in] indent_step       the indent level
    @param[in] current_indent    the current indent level (only used internally)
    */
    void dump(const BasicJsonType& val,
              const bool pretty_print,
              const bool ensure_ascii,
              const unsigned int indent_step,
              const unsigned int current_indent = 0)
    {
        switch (val.m_type)
        {
            case value_t::object:
            {
                if (val.m_value.object->empty())
                {
                    o->write_characters("{}", 2);
                    return;
                }

                if (pretty_print)
                {
                    o->write_characters("{\n", 2);

                    // variable to hold indentation for recursive calls
                    const auto new_indent = current_indent + indent_step;
                    if (JSON_HEDLEY_UNLIKELY(indent_string.size() < new_indent))
                    {
                        indent_string.resize(indent_string.size() * 2, ' ');
                    }

                    // first n-1 elements
                    auto i = val.m_value.object->cbegin();
                    for (std::size_t cnt = 0; cnt < val.m_value.object->size() - 1; ++cnt, ++i)
                    {
                        o->write_characters(indent_string.c_str(), new_indent);
                        o->write_character('\"');
                        dump_escaped(i->first, ensure_ascii);
                        o->write_characters("\": ", 3);
                        dump(i->second, true, ensure_ascii, indent_step, new_indent);
                        o->write_characters(",\n", 2);
                    }

                    // last element
                    JSON_ASSERT(i != val.m_value.object->cend());
                    JSON_ASSERT(std::next(i) == val.m_value.object->cend());
                    o->write_characters(indent_string.c_str(), new_indent);
                    o->write_character('\"');
                    dump_escaped(i->first, ensure_ascii);
                    o->write_characters("\": ", 3);
                    dump(i->second, true, ensure_ascii, indent_step, new_indent);

                    o->write_character('\n');
                    o->write_characters(indent_string.c_str(), current_indent);
                    o->write_character('}');
                }
                else
                {
                    o->write_character('{');

                    // first n-1 elements
                    auto i = val.m_value.object->cbegin();
                    for (std::size_t cnt = 0; cnt < val.m_value.object->size() - 1; ++cnt, ++i)
                    {
                        o->write_character('\"');
                        dump_escaped(i->first, ensure_ascii);
                        o->write_characters("\":", 2);
                        dump(i->second, false, ensure_ascii, indent_step, current_indent);
                        o->write_character(',');
                    }

                    // last element
                    JSON_ASSERT(i != val.m_value.object->cend());
                    JSON_ASSERT(std::next(i) == val.m_value.object->cend());
                    o->write_character('\"');
                    dump_escaped(i->first, ensure_ascii);
                    o->write_characters("\":", 2);
                    dump(i->second, false, ensure_ascii, indent_step, current_indent);

                    o->write_character('}');
                }

                return;
            }

            case value_t::array:
            {
                if (val.m_value.array->empty())
                {
                    o->write_characters("[]", 2);
                    return;
                }

                if (pretty_print)
                {
                    o->write_characters("[\n", 2);

                    // variable to hold indentation for recursive calls
                    const auto new_indent = current_indent + indent_step;
                    if (JSON_HEDLEY_UNLIKELY(indent_string.size() < new_indent))
                    {
                        indent_string.resize(indent_string.size() * 2, ' ');
                    }

                    // first n-1 elements
                    for (auto i = val.m_value.array->cbegin();
                            i != val.m_value.array->cend() - 1; ++i)
                    {
                        o->write_characters(indent_string.c_str(), new_indent);
                        dump(*i, true, ensure_ascii, indent_step, new_indent);
                        o->write_characters(",\n", 2);
                    }

                    // last element
                    JSON_ASSERT(!val.m_value.array->empty());
                    o->write_characters(indent_string.c_str(), new_indent);
                    dump(val.m_value.array->back(), true, ensure_ascii, indent_step, new_indent);

                    o->write_character('\n');
                    o->write_characters(indent_string.c_str(), current_indent);
                    o->write_character(']');
                }
                else
                {
                    o->write_character('[');

                    // first n-1 elements
                    for (auto i = val.m_value.array->cbegin();
                            i != val.m_value.array->cend() - 1; ++i)
                    {
                        dump(*i, false, ensure_ascii, indent_step, current_indent);
                        o->write_character(',');
                    }

                    // last element
                    JSON_ASSERT(!val.m_value.array->empty());
                    dump(val.m_value.array->back(), false, ensure_ascii, indent_step, current_indent);

                    o->write_character(']');
                }

                return;
            }

            case value_t::string:
            {
                o->write_character('\"');
                dump_escaped(*val.m_value.string, ensure_ascii);
                o->write_character('\"');
                return;
            }

            case value_t::binary:
            {
                if (pretty_print)
                {
                    o->write_characters("{\n", 2);

                    // variable to hold indentation for recursive calls
                    const auto new_indent = current_indent + indent_step;
                    if (JSON_HEDLEY_UNLIKELY(indent_string.size() < new_indent))
                    {
                        indent_string.resize(indent_string.size() * 2, ' ');
                    }

                    o->write_characters(indent_string.c_str(), new_indent);

                    o->write_characters("\"bytes\": [", 10);

                    if (!val.m_value.binary->empty())
                    {
                        for (auto i = val.m_value.binary->cbegin();
                                i != val.m_value.binary->cend() - 1; ++i)
                        {
                            dump_integer(*i);
                            o->write_characters(", ", 2);
                        }
                        dump_integer(val.m_value.binary->back());
                    }

                    o->write_characters("],\n", 3);
                    o->write_characters(indent_string.c_str(), new_indent);

                    o->write_characters("\"subtype\": ", 11);
                    if (val.m_value.binary->has_subtype())
                    {
                        dump_integer(val.m_value.binary->subtype());
                    }
                    else
                    {
                        o->write_characters("null", 4);
                    }
                    o->write_character('\n');
                    o->write_characters(indent_string.c_str(), current_indent);
                    o->write_character('}');
                }
                else
                {
                    o->write_characters("{\"bytes\":[", 10);

                    if (!val.m_value.binary->empty())
                    {
                        for (auto i = val.m_value.binary->cbegin();
                                i != val.m_value.binary->cend() - 1; ++i)
                        {
                            dump_integer(*i);
                            o->write_character(',');
                        }
                        dump_integer(val.m_value.binary->back());
                    }

                    o->write_characters("],\"subtype\":", 12);
                    if (val.m_value.binary->has_subtype())
                    {
                        dump_integer(val.m_value.binary->subtype());
                        o->write_character('}');
                    }
                    else
                    {
                        o->write_characters("null}", 5);
                    }
                }
                return;
            }

            case value_t::boolean:
            {
                if (val.m_value.boolean)
                {
                    o->write_characters("true", 4);
                }
                else
                {
                    o->write_characters("false", 5);
                }
                return;
            }

            case value_t::number_integer:
            {
                dump_integer(val.m_value.number_integer);
                return;
            }

            case value_t::number_unsigned:
            {
                dump_integer(val.m_value.number_unsigned);
                return;
            }

            case value_t::number_float:
            {
                dump_float(val.m_value.number_float);
                return;
            }

            case value_t::discarded:
            {
                o->write_characters("<discarded>", 11);
                return;
            }

            case value_t::null:
            {
                o->write_characters("null", 4);
                return;
            }

            default:            // LCOV_EXCL_LINE
                JSON_ASSERT(false);  // LCOV_EXCL_LINE
        }
    }

  private:
    /*!
    @brief dump escaped string

    Escape a string by replacing certain special characters by a sequence of an
    escape character (backslash) and another character and other control
    characters by a sequence of "\u" followed by a four-digit hex
    representation. The escaped string is written to output stream @a o.

    @param[in] s  the string to escape
    @param[in] ensure_ascii  whether to escape non-ASCII characters with
                             \uXXXX sequences

    @complexity Linear in the length of string @a s.
    */
    void dump_escaped(const string_t& s, const bool ensure_ascii)
    {
        std::uint32_t codepoint;
        std::uint8_t state = UTF8_ACCEPT;
        std::size_t bytes = 0;  // number of bytes written to string_buffer

        // number of bytes written at the point of the last valid byte
        std::size_t bytes_after_last_accept = 0;
        std::size_t undumped_chars = 0;

        for (std::size_t i = 0; i < s.size(); ++i)
        {
            const auto byte = static_cast<uint8_t>(s[i]);

            switch (decode(state, codepoint, byte))
            {
                case UTF8_ACCEPT:  // decode found a new code point
                {
                    switch (codepoint)
                    {
                        case 0x08: // backspace
                        {
                            string_buffer[bytes++] = '\\';
                            string_buffer[bytes++] = 'b';
                            break;
                        }

                        case 0x09: // horizontal tab
                        {
                            string_buffer[bytes++] = '\\';
                            string_buffer[bytes++] = 't';
                            break;
                        }

                        case 0x0A: // newline
                        {
                            string_buffer[bytes++] = '\\';
                            string_buffer[bytes++] = 'n';
                            break;
                        }

                        case 0x0C: // formfeed
                        {
                            string_buffer[bytes++] = '\\';
                            string_buffer[bytes++] = 'f';
                            break;
                        }

                        case 0x0D: // carriage return
                        {
                            string_buffer[bytes++] = '\\';
                            string_buffer[bytes++] = 'r';
                            break;
                        }

                        case 0x22: // quotation mark
                        {
                            string_buffer[bytes++] = '\\';
                            string_buffer[bytes++] = '\"';
                            break;
                        }

                        case 0x5C: // reverse solidus
                        {
                            string_buffer[bytes++] = '\\';
                            string_buffer[bytes++] = '\\';
                            break;
                        }

                        default:
                        {
                            // escape control characters (0x00..0x1F) or, if
                            // ensure_ascii parameter is used, non-ASCII characters
                            if ((codepoint <= 0x1F) || (ensure_ascii && (codepoint >= 0x7F)))
                            {
                                if (codepoint <= 0xFFFF)
                                {
                                    (std::snprintf)(string_buffer.data() + bytes, 7, "\\u%04x",
                                                    static_cast<std::uint16_t>(codepoint));
                                    bytes += 6;
                                }
                                else
                                {
                                    (std::snprintf)(string_buffer.data() + bytes, 13, "\\u%04x\\u%04x",
                                                    static_cast<std::uint16_t>(0xD7C0u + (codepoint >> 10u)),
                                                    static_cast<std::uint16_t>(0xDC00u + (codepoint & 0x3FFu)));
                                    bytes += 12;
                                }
                            }
                            else
                            {
                                // copy byte to buffer (all previous bytes
                                // been copied have in default case above)
                                string_buffer[bytes++] = s[i];
                            }
                            break;
                        }
                    }

                    // write buffer and reset index; there must be 13 bytes
                    // left, as this is the maximal number of bytes to be
                    // written ("\uxxxx\uxxxx\0") for one code point
                    if (string_buffer.size() - bytes < 13)
                    {
                        o->write_characters(string_buffer.data(), bytes);
                        bytes = 0;
                    }

                    // remember the byte position of this accept
                    bytes_after_last_accept = bytes;
                    undumped_chars = 0;
                    break;
                }

                case UTF8_REJECT:  // decode found invalid UTF-8 byte
                {
                    switch (error_handler)
                    {
                        case error_handler_t::strict:
                        {
                            std::string sn(3, '\0');
                            (std::snprintf)(&sn[0], sn.size(), "%.2X", byte);
                            JSON_THROW(type_error::create(316, "invalid UTF-8 byte at index " + std::to_string(i) + ": 0x" + sn));
                        }

                        case error_handler_t::ignore:
                        case error_handler_t::replace:
                        {
                            // in case we saw this character the first time, we
                            // would like to read it again, because the byte
                            // may be OK for itself, but just not OK for the
                            // previous sequence
                            if (undumped_chars > 0)
                            {
                                --i;
                            }

                            // reset length buffer to the last accepted index;
                            // thus removing/ignoring the invalid characters
                            bytes = bytes_after_last_accept;

                            if (error_handler == error_handler_t::replace)
                            {
                                // add a replacement character
                                if (ensure_ascii)
                                {
                                    string_buffer[bytes++] = '\\';
                                    string_buffer[bytes++] = 'u';
                                    string_buffer[bytes++] = 'f';
                                    string_buffer[bytes++] = 'f';
                                    string_buffer[bytes++] = 'f';
                                    string_buffer[bytes++] = 'd';
                                }
                                else
                                {
                                    string_buffer[bytes++] = detail::binary_writer<BasicJsonType, char>::to_char_type('\xEF');
                                    string_buffer[bytes++] = detail::binary_writer<BasicJsonType, char>::to_char_type('\xBF');
                                    string_buffer[bytes++] = detail::binary_writer<BasicJsonType, char>::to_char_type('\xBD');
                                }

                                // write buffer and reset index; there must be 13 bytes
                                // left, as this is the maximal number of bytes to be
                                // written ("\uxxxx\uxxxx\0") for one code point
                                if (string_buffer.size() - bytes < 13)
                                {
                                    o->write_characters(string_buffer.data(), bytes);
                                    bytes = 0;
                                }

                                bytes_after_last_accept = bytes;
                            }

                            undumped_chars = 0;

                            // continue processing the string
                            state = UTF8_ACCEPT;
                            break;
                        }

                        default:            // LCOV_EXCL_LINE
                            JSON_ASSERT(false);  // LCOV_EXCL_LINE
                    }
                    break;
                }

                default:  // decode found yet incomplete multi-byte code point
                {
                    if (!ensure_ascii)
                    {
                        // code point will not be escaped - copy byte to buffer
                        string_buffer[bytes++] = s[i];
                    }
                    ++undumped_chars;
                    break;
                }
            }
        }

        // we finished processing the string
        if (JSON_HEDLEY_LIKELY(state == UTF8_ACCEPT))
        {
            // write buffer
            if (bytes > 0)
            {
                o->write_characters(string_buffer.data(), bytes);
            }
        }
        else
        {
            // we finish reading, but do not accept: string was incomplete
            switch (error_handler)
            {
                case error_handler_t::strict:
                {
                    std::string sn(3, '\0');
                    (std::snprintf)(&sn[0], sn.size(), "%.2X", static_cast<std::uint8_t>(s.back()));
                    JSON_THROW(type_error::create(316, "incomplete UTF-8 string; last byte: 0x" + sn));
                }

                case error_handler_t::ignore:
                {
                    // write all accepted bytes
                    o->write_characters(string_buffer.data(), bytes_after_last_accept);
                    break;
                }

                case error_handler_t::replace:
                {
                    // write all accepted bytes
                    o->write_characters(string_buffer.data(), bytes_after_last_accept);
                    // add a replacement character
                    if (ensure_ascii)
                    {
                        o->write_characters("\\ufffd", 6);
                    }
                    else
                    {
                        o->write_characters("\xEF\xBF\xBD", 3);
                    }
                    break;
                }

                default:            // LCOV_EXCL_LINE
                    JSON_ASSERT(false);  // LCOV_EXCL_LINE
            }
        }
    }

    /*!
    @brief count digits

    Count the number of decimal (base 10) digits for an input unsigned integer.

    @param[in] x  unsigned integer number to count its digits
    @return    number of decimal digits
    */
    inline unsigned int count_digits(number_unsigned_t x) noexcept
    {
        unsigned int n_digits = 1;
        for (;;)
        {
            if (x < 10)
            {
                return n_digits;
            }
            if (x < 100)
            {
                return n_digits + 1;
            }
            if (x < 1000)
            {
                return n_digits + 2;
            }
            if (x < 10000)
            {
                return n_digits + 3;
            }
            x = x / 10000u;
            n_digits += 4;
        }
    }

    /*!
    @brief dump an integer

    Dump a given integer to output stream @a o. Works internally with
    @a number_buffer.

    @param[in] x  integer number (signed or unsigned) to dump
    @tparam NumberType either @a number_integer_t or @a number_unsigned_t
    */
    template < typename NumberType, detail::enable_if_t <
                   std::is_same<NumberType, number_unsigned_t>::value ||
                   std::is_same<NumberType, number_integer_t>::value ||
                   std::is_same<NumberType, binary_char_t>::value,
                   int > = 0 >
    void dump_integer(NumberType x)
    {
        static constexpr std::array<std::array<char, 2>, 100> digits_to_99
        {
            {
                {{'0', '0'}}, {{'0', '1'}}, {{'0', '2'}}, {{'0', '3'}}, {{'0', '4'}}, {{'0', '5'}}, {{'0', '6'}}, {{'0', '7'}}, {{'0', '8'}}, {{'0', '9'}},
                {{'1', '0'}}, {{'1', '1'}}, {{'1', '2'}}, {{'1', '3'}}, {{'1', '4'}}, {{'1', '5'}}, {{'1', '6'}}, {{'1', '7'}}, {{'1', '8'}}, {{'1', '9'}},
                {{'2', '0'}}, {{'2', '1'}}, {{'2', '2'}}, {{'2', '3'}}, {{'2', '4'}}, {{'2', '5'}}, {{'2', '6'}}, {{'2', '7'}}, {{'2', '8'}}, {{'2', '9'}},
                {{'3', '0'}}, {{'3', '1'}}, {{'3', '2'}}, {{'3', '3'}}, {{'3', '4'}}, {{'3', '5'}}, {{'3', '6'}}, {{'3', '7'}}, {{'3', '8'}}, {{'3', '9'}},
                {{'4', '0'}}, {{'4', '1'}}, {{'4', '2'}}, {{'4', '3'}}, {{'4', '4'}}, {{'4', '5'}}, {{'4', '6'}}, {{'4', '7'}}, {{'4', '8'}}, {{'4', '9'}},
                {{'5', '0'}}, {{'5', '1'}}, {{'5', '2'}}, {{'5', '3'}}, {{'5', '4'}}, {{'5', '5'}}, {{'5', '6'}}, {{'5', '7'}}, {{'5', '8'}}, {{'5', '9'}},
                {{'6', '0'}}, {{'6', '1'}}, {{'6', '2'}}, {{'6', '3'}}, {{'6', '4'}}, {{'6', '5'}}, {{'6', '6'}}, {{'6', '7'}}, {{'6', '8'}}, {{'6', '9'}},
                {{'7', '0'}}, {{'7', '1'}}, {{'7', '2'}}, {{'7', '3'}}, {{'7', '4'}}, {{'7', '5'}}, {{'7', '6'}}, {{'7', '7'}}, {{'7', '8'}}, {{'7', '9'}},
                {{'8', '0'}}, {{'8', '1'}}, {{'8', '2'}}, {{'8', '3'}}, {{'8', '4'}}, {{'8', '5'}}, {{'8', '6'}}, {{'8', '7'}}, {{'8', '8'}}, {{'8', '9'}},
                {{'9', '0'}}, {{'9', '1'}}, {{'9', '2'}}, {{'9', '3'}}, {{'9', '4'}}, {{'9', '5'}}, {{'9', '6'}}, {{'9', '7'}}, {{'9', '8'}}, {{'9', '9'}},
            }
        };

        // special case for "0"
        if (x == 0)
        {
            o->write_character('0');
            return;
        }

        // use a pointer to fill the buffer
        auto buffer_ptr = number_buffer.begin();

        const bool is_negative = std::is_same<NumberType, number_integer_t>::value && !(x >= 0); // see issue #755
        number_unsigned_t abs_value;

        unsigned int n_chars;

        if (is_negative)
        {
            *buffer_ptr = '-';
            abs_value = remove_sign(static_cast<number_integer_t>(x));

            // account one more byte for the minus sign
            n_chars = 1 + count_digits(abs_value);
        }
        else
        {
            abs_value = static_cast<number_unsigned_t>(x);
            n_chars = count_digits(abs_value);
        }

        // spare 1 byte for '\0'
        JSON_ASSERT(n_chars < number_buffer.size() - 1);

        // jump to the end to generate the string from backward
        // so we later avoid reversing the result
        buffer_ptr += n_chars;

        // Fast int2ascii implementation inspired by "Fastware" talk by Andrei Alexandrescu
        // See: https://www.youtube.com/watch?v=o4-CwDo2zpg
        while (abs_value >= 100)
        {
            const auto digits_index = static_cast<unsigned>((abs_value % 100));
            abs_value /= 100;
            *(--buffer_ptr) = digits_to_99[digits_index][1];
            *(--buffer_ptr) = digits_to_99[digits_index][0];
        }

        if (abs_value >= 10)
        {
            const auto digits_index = static_cast<unsigned>(abs_value);
            *(--buffer_ptr) = digits_to_99[digits_index][1];
            *(--buffer_ptr) = digits_to_99[digits_index][0];
        }
        else
        {
            *(--buffer_ptr) = static_cast<char>('0' + abs_value);
        }

        o->write_characters(number_buffer.data(), n_chars);
    }

    /*!
    @brief dump a floating-point number

    Dump a given floating-point number to output stream @a o. Works internally
    with @a number_buffer.

    @param[in] x  floating-point number to dump
    */
    void dump_float(number_float_t x)
    {
        // NaN / inf
        if (!std::isfinite(x))
        {
            o->write_characters("null", 4);
            return;
        }

        // If number_float_t is an IEEE-754 single or double precision number,
        // use the Grisu2 algorithm to produce short numbers which are
        // guaranteed to round-trip, using strtof and strtod, resp.
        //
        // NB: The test below works if <long double> == <double>.
        static constexpr bool is_ieee_single_or_double
            = (std::numeric_limits<number_float_t>::is_iec559 && std::numeric_limits<number_float_t>::digits == 24 && std::numeric_limits<number_float_t>::max_exponent == 128) ||
              (std::numeric_limits<number_float_t>::is_iec559 && std::numeric_limits<number_float_t>::digits == 53 && std::numeric_limits<number_float_t>::max_exponent == 1024);

        dump_float(x, std::integral_constant<bool, is_ieee_single_or_double>());
    }

    void dump_float(number_float_t x, std::true_type /*is_ieee_single_or_double*/)
    {
        char* begin = number_buffer.data();
        char* end = ::nlohmann::detail::to_chars(begin, begin + number_buffer.size(), x);

        o->write_characters(begin, static_cast<size_t>(end - begin));
    }

    void dump_float(number_float_t x, std::false_type /*is_ieee_single_or_double*/)
    {
        // get number of digits for a float -> text -> float round-trip
        static constexpr auto d = std::numeric_limits<number_float_t>::max_digits10;

        // the actual conversion
        std::ptrdiff_t len = (std::snprintf)(number_buffer.data(), number_buffer.size(), "%.*g", d, x);

        // negative value indicates an error
        JSON_ASSERT(len > 0);
        // check if buffer was large enough
        JSON_ASSERT(static_cast<std::size_t>(len) < number_buffer.size());

        // erase thousands separator
        if (thousands_sep != '\0')
        {
            const auto end = std::remove(number_buffer.begin(),
                                         number_buffer.begin() + len, thousands_sep);
            std::fill(end, number_buffer.end(), '\0');
            JSON_ASSERT((end - number_buffer.begin()) <= len);
            len = (end - number_buffer.begin());
        }

        // convert decimal point to '.'
        if (decimal_point != '\0' && decimal_point != '.')
        {
            const auto dec_pos = std::find(number_buffer.begin(), number_buffer.end(), decimal_point);
            if (dec_pos != number_buffer.end())
            {
                *dec_pos = '.';
            }
        }

        o->write_characters(number_buffer.data(), static_cast<std::size_t>(len));

        // determine if need to append ".0"
        const bool value_is_int_like =
            std::none_of(number_buffer.begin(), number_buffer.begin() + len + 1,
                         [](char c)
        {
            return c == '.' || c == 'e';
        });

        if (value_is_int_like)
        {
            o->write_characters(".0", 2);
        }
    }

    /*!
    @brief check whether a string is UTF-8 encoded

    The function checks each byte of a string whether it is UTF-8 encoded. The
    result of the check is stored in the @a state parameter. The function must
    be called initially with state 0 (accept). State 1 means the string must
    be rejected, because the current byte is not allowed. If the string is
    completely processed, but the state is non-zero, the string ended
    prematurely; that is, the last byte indicated more bytes should have
    followed.

    @param[in,out] state  the state of the decoding
    @param[in,out] codep  codepoint (valid only if resulting state is UTF8_ACCEPT)
    @param[in] byte       next byte to decode
    @return               new state

    @note The function has been edited: a std::array is used.

    @copyright Copyright (c) 2008-2009 Bjoern Hoehrmann <bjoern@hoehrmann.de>
    @sa http://bjoern.hoehrmann.de/utf-8/decoder/dfa/
    */
    static std::uint8_t decode(std::uint8_t& state, std::uint32_t& codep, const std::uint8_t byte) noexcept
    {
        static const std::array<std::uint8_t, 400> utf8d =
        {
            {
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 00..1F
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 20..3F
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 40..5F
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 60..7F
                1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, // 80..9F
                7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, // A0..BF
                8, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, // C0..DF
                0xA, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x4, 0x3, 0x3, // E0..EF
                0xB, 0x6, 0x6, 0x6, 0x5, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, // F0..FF
                0x0, 0x1, 0x2, 0x3, 0x5, 0x8, 0x7, 0x1, 0x1, 0x1, 0x4, 0x6, 0x1, 0x1, 0x1, 0x1, // s0..s0
                1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, // s1..s2
                1, 2, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, // s3..s4
                1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, // s5..s6
                1, 3, 1, 1, 1, 1, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 // s7..s8
            }
        };

        const std::uint8_t type = utf8d[byte];

        codep = (state != UTF8_ACCEPT)
                ? (byte & 0x3fu) | (codep << 6u)
                : (0xFFu >> type) & (byte);

        std::size_t index = 256u + static_cast<size_t>(state) * 16u + static_cast<size_t>(type);
        JSON_ASSERT(index < 400);
        state = utf8d[index];
        return state;
    }

    /*
     * Overload to make the compiler happy while it is instantiating
     * dump_integer for number_unsigned_t.
     * Must never be called.
     */
    number_unsigned_t remove_sign(number_unsigned_t x)
    {
        JSON_ASSERT(false); // LCOV_EXCL_LINE
        return x; // LCOV_EXCL_LINE
    }

    /*
     * Helper function for dump_integer
     *
     * This function takes a negative signed integer and returns its absolute
     * value as unsigned integer. The plus/minus shuffling is necessary as we can
     * not directly remove the sign of an arbitrary signed integer as the
     * absolute values of INT_MIN and INT_MAX are usually not the same. See
     * #1708 for details.
     */
    inline number_unsigned_t remove_sign(number_integer_t x) noexcept
    {
        JSON_ASSERT(x < 0 && x < (std::numeric_limits<number_integer_t>::max)());
        return static_cast<number_unsigned_t>(-(x + 1)) + 1;
    }

  private:
    /// the output of the serializer
    output_adapter_t<char> o = nullptr;

    /// a (hopefully) large enough character buffer
    std::array<char, 64> number_buffer{{}};

    /// the locale
    const std::lconv* loc = nullptr;
    /// the locale's thousand separator character
    const char thousands_sep = '\0';
    /// the locale's decimal point character
    const char decimal_point = '\0';

    /// string buffer
    std::array<char, 512> string_buffer{{}};

    /// the indentation character
    const char indent_char;
    /// the indentation string
    string_t indent_string;

    /// error_handler how to react on decoding errors
    const error_handler_t error_handler;
};
}  // namespace detail
}  // namespace nlohmann

// #include <nlohmann/detail/value_t.hpp>

// #include <nlohmann/json_fwd.hpp>

// #include <nlohmann/ordered_map.hpp>


#include <functional> // less
#include <memory> // allocator
#include <utility> // pair
#include <vector> // vector

namespace nlohmann
{

/// ordered_map: a minimal map-like container that preserves insertion order
/// for use within nlohmann::basic_json<ordered_map>
template <class Key, class T, class IgnoredLess = std::less<Key>,
          class Allocator = std::allocator<std::pair<const Key, T>>>
                  struct ordered_map : std::vector<std::pair<const Key, T>, Allocator>
{
    using key_type = Key;
    using mapped_type = T;
    using Container = std::vector<std::pair<const Key, T>, Allocator>;
    using typename Container::iterator;
    using typename Container::const_iterator;
    using typename Container::size_type;
    using typename Container::value_type;

    // Explicit constructors instead of `using Container::Container`
    // otherwise older compilers choke on it (GCC <= 5.5, xcode <= 9.4)
    ordered_map(const Allocator& alloc = Allocator()) : Container{alloc} {}
    template <class It>
    ordered_map(It first, It last, const Allocator& alloc = Allocator())
        : Container{first, last, alloc} {}
    ordered_map(std::initializer_list<T> init, const Allocator& alloc = Allocator() )
        : Container{init, alloc} {}

    std::pair<iterator, bool> emplace(const key_type& key, T&& t)
    {
        for (auto it = this->begin(); it != this->end(); ++it)
        {
            if (it->first == key)
            {
                return {it, false};
            }
        }
        Container::emplace_back(key, t);
        return {--this->end(), true};
    }

    T& operator[](const Key& key)
    {
        return emplace(key, T{}).first->second;
    }

    const T& operator[](const Key& key) const
    {
        return at(key);
    }

    T& at(const Key& key)
    {
        for (auto it = this->begin(); it != this->end(); ++it)
        {
            if (it->first == key)
            {
                return it->second;
            }
        }

        throw std::out_of_range("key not found");
    }

    const T& at(const Key& key) const
    {
        for (auto it = this->begin(); it != this->end(); ++it)
        {
            if (it->first == key)
            {
                return it->second;
            }
        }

        throw std::out_of_range("key not found");
    }

    size_type erase(const Key& key)
    {
        for (auto it = this->begin(); it != this->end(); ++it)
        {
            if (it->first == key)
            {
                // Since we cannot move const Keys, re-construct them in place
                for (auto next = it; ++next != this->end(); ++it)
                {
                    it->~value_type(); // Destroy but keep allocation
                    new (&*it) value_type{std::move(*next)};
                }
                Container::pop_back();
                return 1;
            }
        }
        return 0;
    }

    iterator erase(iterator pos)
    {
        auto it = pos;

        // Since we cannot move const Keys, re-construct them in place
        for (auto next = it; ++next != this->end(); ++it)
        {
            it->~value_type(); // Destroy but keep allocation
            new (&*it) value_type{std::move(*next)};
        }
        Container::pop_back();
        return pos;
    }

    size_type count(const Key& key) const
    {
        for (auto it = this->begin(); it != this->end(); ++it)
        {
            if (it->first == key)
            {
                return 1;
            }
        }
        return 0;
    }

    iterator find(const Key& key)
    {
        for (auto it = this->begin(); it != this->end(); ++it)
        {
            if (it->first == key)
            {
                return it;
            }
        }
        return Container::end();
    }

    const_iterator find(const Key& key) const
    {
        for (auto it = this->begin(); it != this->end(); ++it)
        {
            if (it->first == key)
            {
                return it;
            }
        }
        return Container::end();
    }

    std::pair<iterator, bool> insert( value_type&& value )
    {
        return emplace(value.first, std::move(value.second));
    }

    std::pair<iterator, bool> insert( const value_type& value )
    {
        for (auto it = this->begin(); it != this->end(); ++it)
        {
            if (it->first == value.first)
            {
                return {it, false};
            }
        }
        Container::push_back(value);
        return {--this->end(), true};
    }
};

}  // namespace nlohmann


/*!
@brief namespace for Niels Lohmann
@see https://github.com/nlohmann
@since version 1.0.0
*/
namespace nlohmann
{

/*!
@brief a class to store JSON values

@tparam ObjectType type for JSON objects (`std::map` by default; will be used
in @ref object_t)
@tparam ArrayType type for JSON arrays (`std::vector` by default; will be used
in @ref array_t)
@tparam StringType type for JSON strings and object keys (`std::string` by
default; will be used in @ref string_t)
@tparam BooleanType type for JSON booleans (`bool` by default; will be used
in @ref boolean_t)
@tparam NumberIntegerType type for JSON integer numbers (`int64_t` by
default; will be used in @ref number_integer_t)
@tparam NumberUnsignedType type for JSON unsigned integer numbers (@c
`uint64_t` by default; will be used in @ref number_unsigned_t)
@tparam NumberFloatType type for JSON floating-point numbers (`double` by
default; will be used in @ref number_float_t)
@tparam BinaryType type for packed binary data for compatibility with binary
serialization formats (`std::vector<std::uint8_t>` by default; will be used in
@ref binary_t)
@tparam AllocatorType type of the allocator to use (`std::allocator` by
default)
@tparam JSONSerializer the serializer to resolve internal calls to `to_json()`
and `from_json()` (@ref adl_serializer by default)

@requirement The class satisfies the following concept requirements:
- Basic
 - [DefaultConstructible](https://en.cppreference.com/w/cpp/named_req/DefaultConstructible):
   JSON values can be default constructed. The result will be a JSON null
   value.
 - [MoveConstructible](https://en.cppreference.com/w/cpp/named_req/MoveConstructible):
   A JSON value can be constructed from an rvalue argument.
 - [CopyConstructible](https://en.cppreference.com/w/cpp/named_req/CopyConstructible):
   A JSON value can be copy-constructed from an lvalue expression.
 - [MoveAssignable](https://en.cppreference.com/w/cpp/named_req/MoveAssignable):
   A JSON value van be assigned from an rvalue argument.
 - [CopyAssignable](https://en.cppreference.com/w/cpp/named_req/CopyAssignable):
   A JSON value can be copy-assigned from an lvalue expression.
 - [Destructible](https://en.cppreference.com/w/cpp/named_req/Destructible):
   JSON values can be destructed.
- Layout
 - [StandardLayoutType](https://en.cppreference.com/w/cpp/named_req/StandardLayoutType):
   JSON values have
   [standard layout](https://en.cppreference.com/w/cpp/language/data_members#Standard_layout):
   All non-static data members are private and standard layout types, the
   class has no virtual functions or (virtual) base classes.
- Library-wide
 - [EqualityComparable](https://en.cppreference.com/w/cpp/named_req/EqualityComparable):
   JSON values can be compared with `==`, see @ref
   operator==(const_reference,const_reference).
 - [LessThanComparable](https://en.cppreference.com/w/cpp/named_req/LessThanComparable):
   JSON values can be compared with `<`, see @ref
   operator<(const_reference,const_reference).
 - [Swappable](https://en.cppreference.com/w/cpp/named_req/Swappable):
   Any JSON lvalue or rvalue of can be swapped with any lvalue or rvalue of
   other compatible types, using unqualified function call @ref swap().
 - [NullablePointer](https://en.cppreference.com/w/cpp/named_req/NullablePointer):
   JSON values can be compared against `std::nullptr_t` objects which are used
   to model the `null` value.
- Container
 - [Container](https://en.cppreference.com/w/cpp/named_req/Container):
   JSON values can be used like STL containers and provide iterator access.
 - [ReversibleContainer](https://en.cppreference.com/w/cpp/named_req/ReversibleContainer);
   JSON values can be used like STL containers and provide reverse iterator
   access.

@invariant The member variables @a m_value and @a m_type have the following
relationship:
- If `m_type == value_t::object`, then `m_value.object != nullptr`.
- If `m_type == value_t::array`, then `m_value.array != nullptr`.
- If `m_type == value_t::string`, then `m_value.string != nullptr`.
The invariants are checked by member function assert_invariant().

@internal
@note ObjectType trick from https://stackoverflow.com/a/9860911
@endinternal

@see [RFC 7159: The JavaScript Object Notation (JSON) Data Interchange
Format](http://rfc7159.net/rfc7159)

@since version 1.0.0

@nosubgrouping
*/
NLOHMANN_BASIC_JSON_TPL_DECLARATION
class basic_json
{
  private:
    template<detail::value_t> friend struct detail::external_constructor;
    friend ::nlohmann::json_pointer<basic_json>;

    template<typename BasicJsonType, typename InputType>
    friend class ::nlohmann::detail::parser;
    friend ::nlohmann::detail::serializer<basic_json>;
    template<typename BasicJsonType>
    friend class ::nlohmann::detail::iter_impl;
    template<typename BasicJsonType, typename CharType>
    friend class ::nlohmann::detail::binary_writer;
    template<typename BasicJsonType, typename InputType, typename SAX>
    friend class ::nlohmann::detail::binary_reader;
    template<typename BasicJsonType>
    friend class ::nlohmann::detail::json_sax_dom_parser;
    template<typename BasicJsonType>
    friend class ::nlohmann::detail::json_sax_dom_callback_parser;

    /// workaround type for MSVC
    using basic_json_t = NLOHMANN_BASIC_JSON_TPL;

    // convenience aliases for types residing in namespace detail;
    using lexer = ::nlohmann::detail::lexer_base<basic_json>;

    template<typename InputAdapterType>
    static ::nlohmann::detail::parser<basic_json, InputAdapterType> parser(
        InputAdapterType adapter,
        detail::parser_callback_t<basic_json>cb = nullptr,
        const bool allow_exceptions = true,
        const bool ignore_comments = false
                                 )
    {
        return ::nlohmann::detail::parser<basic_json, InputAdapterType>(std::move(adapter),
                std::move(cb), allow_exceptions, ignore_comments);
    }

    using primitive_iterator_t = ::nlohmann::detail::primitive_iterator_t;
    template<typename BasicJsonType>
    using internal_iterator = ::nlohmann::detail::internal_iterator<BasicJsonType>;
    template<typename BasicJsonType>
    using iter_impl = ::nlohmann::detail::iter_impl<BasicJsonType>;
    template<typename Iterator>
    using iteration_proxy = ::nlohmann::detail::iteration_proxy<Iterator>;
    template<typename Base> using json_reverse_iterator = ::nlohmann::detail::json_reverse_iterator<Base>;

    template<typename CharType>
    using output_adapter_t = ::nlohmann::detail::output_adapter_t<CharType>;

    template<typename InputType>
    using binary_reader = ::nlohmann::detail::binary_reader<basic_json, InputType>;
    template<typename CharType> using binary_writer = ::nlohmann::detail::binary_writer<basic_json, CharType>;

    using serializer = ::nlohmann::detail::serializer<basic_json>;

  public:
    using value_t = detail::value_t;
    /// JSON Pointer, see @ref nlohmann::json_pointer
    using json_pointer = ::nlohmann::json_pointer<basic_json>;
    template<typename T, typename SFINAE>
    using json_serializer = JSONSerializer<T, SFINAE>;
    /// how to treat decoding errors
    using error_handler_t = detail::error_handler_t;
    /// how to treat CBOR tags
    using cbor_tag_handler_t = detail::cbor_tag_handler_t;
    /// helper type for initializer lists of basic_json values
    using initializer_list_t = std::initializer_list<detail::json_ref<basic_json>>;

    using input_format_t = detail::input_format_t;
    /// SAX interface type, see @ref nlohmann::json_sax
    using json_sax_t = json_sax<basic_json>;

    ////////////////
    // exceptions //
    ////////////////

    /// @name exceptions
    /// Classes to implement user-defined exceptions.
    /// @{

    /// @copydoc detail::exception
    using exception = detail::exception;
    /// @copydoc detail::parse_error
    using parse_error = detail::parse_error;
    /// @copydoc detail::invalid_iterator
    using invalid_iterator = detail::invalid_iterator;
    /// @copydoc detail::type_error
    using type_error = detail::type_error;
    /// @copydoc detail::out_of_range
    using out_of_range = detail::out_of_range;
    /// @copydoc detail::other_error
    using other_error = detail::other_error;

    /// @}


    /////////////////////
    // container types //
    /////////////////////

    /// @name container types
    /// The canonic container types to use @ref basic_json like any other STL
    /// container.
    /// @{

    /// the type of elements in a basic_json container
    using value_type = basic_json;

    /// the type of an element reference
    using reference = value_type&;
    /// the type of an element const reference
    using const_reference = const value_type&;

    /// a type to represent differences between iterators
    using difference_type = std::ptrdiff_t;
    /// a type to represent container sizes
    using size_type = std::size_t;

    /// the allocator type
    using allocator_type = AllocatorType<basic_json>;

    /// the type of an element pointer
    using pointer = typename std::allocator_traits<allocator_type>::pointer;
    /// the type of an element const pointer
    using const_pointer = typename std::allocator_traits<allocator_type>::const_pointer;

    /// an iterator for a basic_json container
    using iterator = iter_impl<basic_json>;
    /// a const iterator for a basic_json container
    using const_iterator = iter_impl<const basic_json>;
    /// a reverse iterator for a basic_json container
    using reverse_iterator = json_reverse_iterator<typename basic_json::iterator>;
    /// a const reverse iterator for a basic_json container
    using const_reverse_iterator = json_reverse_iterator<typename basic_json::const_iterator>;

    /// @}


    /*!
    @brief returns the allocator associated with the container
    */
    static allocator_type get_allocator()
    {
        return allocator_type();
    }

    /*!
    @brief returns version information on the library

    This function returns a JSON object with information about the library,
    including the version number and information on the platform and compiler.

    @return JSON object holding version information
    key         | description
    ----------- | ---------------
    `compiler`  | Information on the used compiler. It is an object with the following keys: `c++` (the used C++ standard), `family` (the compiler family; possible values are `clang`, `icc`, `gcc`, `ilecpp`, `msvc`, `pgcpp`, `sunpro`, and `unknown`), and `version` (the compiler version).
    `copyright` | The copyright line for the library as string.
    `name`      | The name of the library as string.
    `platform`  | The used platform as string. Possible values are `win32`, `linux`, `apple`, `unix`, and `unknown`.
    `url`       | The URL of the project as string.
    `version`   | The version of the library. It is an object with the following keys: `major`, `minor`, and `patch` as defined by [Semantic Versioning](http://semver.org), and `string` (the version string).

    @liveexample{The following code shows an example output of the `meta()`
    function.,meta}

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes to any JSON value.

    @complexity Constant.

    @since 2.1.0
    */
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json meta()
    {
        basic_json result;

        result["copyright"] = "(C) 2013-2020 Niels Lohmann";
        result["name"] = "JSON for Modern C++";
        result["url"] = "https://github.com/nlohmann/json";
        result["version"]["string"] =
            std::to_string(NLOHMANN_JSON_VERSION_MAJOR) + "." +
            std::to_string(NLOHMANN_JSON_VERSION_MINOR) + "." +
            std::to_string(NLOHMANN_JSON_VERSION_PATCH);
        result["version"]["major"] = NLOHMANN_JSON_VERSION_MAJOR;
        result["version"]["minor"] = NLOHMANN_JSON_VERSION_MINOR;
        result["version"]["patch"] = NLOHMANN_JSON_VERSION_PATCH;

#ifdef _WIN32
        result["platform"] = "win32";
#elif defined __linux__
        result["platform"] = "linux";
#elif defined __APPLE__
        result["platform"] = "apple";
#elif defined __unix__
        result["platform"] = "unix";
#else
        result["platform"] = "unknown";
#endif

#if defined(__ICC) || defined(__INTEL_COMPILER)
        result["compiler"] = {{"family", "icc"}, {"version", __INTEL_COMPILER}};
#elif defined(__clang__)
        result["compiler"] = {{"family", "clang"}, {"version", __clang_version__}};
#elif defined(__GNUC__) || defined(__GNUG__)
        result["compiler"] = {{"family", "gcc"}, {"version", std::to_string(__GNUC__) + "." + std::to_string(__GNUC_MINOR__) + "." + std::to_string(__GNUC_PATCHLEVEL__)}};
#elif defined(__HP_cc) || defined(__HP_aCC)
        result["compiler"] = "hp"
#elif defined(__IBMCPP__)
        result["compiler"] = {{"family", "ilecpp"}, {"version", __IBMCPP__}};
#elif defined(_MSC_VER)
        result["compiler"] = {{"family", "msvc"}, {"version", _MSC_VER}};
#elif defined(__PGI)
        result["compiler"] = {{"family", "pgcpp"}, {"version", __PGI}};
#elif defined(__SUNPRO_CC)
        result["compiler"] = {{"family", "sunpro"}, {"version", __SUNPRO_CC}};
#else
        result["compiler"] = {{"family", "unknown"}, {"version", "unknown"}};
#endif

#ifdef __cplusplus
        result["compiler"]["c++"] = std::to_string(__cplusplus);
#else
        result["compiler"]["c++"] = "unknown";
#endif
        return result;
    }


    ///////////////////////////
    // JSON value data types //
    ///////////////////////////

    /// @name JSON value data types
    /// The data types to store a JSON value. These types are derived from
    /// the template arguments passed to class @ref basic_json.
    /// @{

#if defined(JSON_HAS_CPP_14)
    // Use transparent comparator if possible, combined with perfect forwarding
    // on find() and count() calls prevents unnecessary string construction.
    using object_comparator_t = std::less<>;
#else
    using object_comparator_t = std::less<StringType>;
#endif

    /*!
    @brief a type for an object

    [RFC 7159](http://rfc7159.net/rfc7159) describes JSON objects as follows:
    > An object is an unordered collection of zero or more name/value pairs,
    > where a name is a string and a value is a string, number, boolean, null,
    > object, or array.

    To store objects in C++, a type is defined by the template parameters
    described below.

    @tparam ObjectType  the container to store objects (e.g., `std::map` or
    `std::unordered_map`)
    @tparam StringType the type of the keys or names (e.g., `std::string`).
    The comparison function `std::less<StringType>` is used to order elements
    inside the container.
    @tparam AllocatorType the allocator to use for objects (e.g.,
    `std::allocator`)

    #### Default type

    With the default values for @a ObjectType (`std::map`), @a StringType
    (`std::string`), and @a AllocatorType (`std::allocator`), the default
    value for @a object_t is:

    @code {.cpp}
    std::map<
      std::string, // key_type
      basic_json, // value_type
      std::less<std::string>, // key_compare
      std::allocator<std::pair<const std::string, basic_json>> // allocator_type
    >
    @endcode

    #### Behavior

    The choice of @a object_t influences the behavior of the JSON class. With
    the default type, objects have the following behavior:

    - When all names are unique, objects will be interoperable in the sense
      that all software implementations receiving that object will agree on
      the name-value mappings.
    - When the names within an object are not unique, it is unspecified which
      one of the values for a given key will be chosen. For instance,
      `{"key": 2, "key": 1}` could be equal to either `{"key": 1}` or
      `{"key": 2}`.
    - Internally, name/value pairs are stored in lexicographical order of the
      names. Objects will also be serialized (see @ref dump) in this order.
      For instance, `{"b": 1, "a": 2}` and `{"a": 2, "b": 1}` will be stored
      and serialized as `{"a": 2, "b": 1}`.
    - When comparing objects, the order of the name/value pairs is irrelevant.
      This makes objects interoperable in the sense that they will not be
      affected by these differences. For instance, `{"b": 1, "a": 2}` and
      `{"a": 2, "b": 1}` will be treated as equal.

    #### Limits

    [RFC 7159](http://rfc7159.net/rfc7159) specifies:
    > An implementation may set limits on the maximum depth of nesting.

    In this class, the object's limit of nesting is not explicitly constrained.
    However, a maximum depth of nesting may be introduced by the compiler or
    runtime environment. A theoretical limit can be queried by calling the
    @ref max_size function of a JSON object.

    #### Storage

    Objects are stored as pointers in a @ref basic_json type. That is, for any
    access to object values, a pointer of type `object_t*` must be
    dereferenced.

    @sa @ref array_t -- type for an array value

    @since version 1.0.0

    @note The order name/value pairs are added to the object is *not*
    preserved by the library. Therefore, iterating an object may return
    name/value pairs in a different order than they were originally stored. In
    fact, keys will be traversed in alphabetical order as `std::map` with
    `std::less` is used by default. Please note this behavior conforms to [RFC
    7159](http://rfc7159.net/rfc7159), because any order implements the
    specified "unordered" nature of JSON objects.
    */
    using object_t = ObjectType<StringType,
          basic_json,
          object_comparator_t,
          AllocatorType<std::pair<const StringType,
          basic_json>>>;

    /*!
    @brief a type for an array

    [RFC 7159](http://rfc7159.net/rfc7159) describes JSON arrays as follows:
    > An array is an ordered sequence of zero or more values.

    To store objects in C++, a type is defined by the template parameters
    explained below.

    @tparam ArrayType  container type to store arrays (e.g., `std::vector` or
    `std::list`)
    @tparam AllocatorType allocator to use for arrays (e.g., `std::allocator`)

    #### Default type

    With the default values for @a ArrayType (`std::vector`) and @a
    AllocatorType (`std::allocator`), the default value for @a array_t is:

    @code {.cpp}
    std::vector<
      basic_json, // value_type
      std::allocator<basic_json> // allocator_type
    >
    @endcode

    #### Limits

    [RFC 7159](http://rfc7159.net/rfc7159) specifies:
    > An implementation may set limits on the maximum depth of nesting.

    In this class, the array's limit of nesting is not explicitly constrained.
    However, a maximum depth of nesting may be introduced by the compiler or
    runtime environment. A theoretical limit can be queried by calling the
    @ref max_size function of a JSON array.

    #### Storage

    Arrays are stored as pointers in a @ref basic_json type. That is, for any
    access to array values, a pointer of type `array_t*` must be dereferenced.

    @sa @ref object_t -- type for an object value

    @since version 1.0.0
    */
    using array_t = ArrayType<basic_json, AllocatorType<basic_json>>;

    /*!
    @brief a type for a string

    [RFC 7159](http://rfc7159.net/rfc7159) describes JSON strings as follows:
    > A string is a sequence of zero or more Unicode characters.

    To store objects in C++, a type is defined by the template parameter
    described below. Unicode values are split by the JSON class into
    byte-sized characters during deserialization.

    @tparam StringType  the container to store strings (e.g., `std::string`).
    Note this container is used for keys/names in objects, see @ref object_t.

    #### Default type

    With the default values for @a StringType (`std::string`), the default
    value for @a string_t is:

    @code {.cpp}
    std::string
    @endcode

    #### Encoding

    Strings are stored in UTF-8 encoding. Therefore, functions like
    `std::string::size()` or `std::string::length()` return the number of
    bytes in the string rather than the number of characters or glyphs.

    #### String comparison

    [RFC 7159](http://rfc7159.net/rfc7159) states:
    > Software implementations are typically required to test names of object
    > members for equality. Implementations that transform the textual
    > representation into sequences of Unicode code units and then perform the
    > comparison numerically, code unit by code unit, are interoperable in the
    > sense that implementations will agree in all cases on equality or
    > inequality of two strings. For example, implementations that compare
    > strings with escaped characters unconverted may incorrectly find that
    > `"a\\b"` and `"a\u005Cb"` are not equal.

    This implementation is interoperable as it does compare strings code unit
    by code unit.

    #### Storage

    String values are stored as pointers in a @ref basic_json type. That is,
    for any access to string values, a pointer of type `string_t*` must be
    dereferenced.

    @since version 1.0.0
    */
    using string_t = StringType;

    /*!
    @brief a type for a boolean

    [RFC 7159](http://rfc7159.net/rfc7159) implicitly describes a boolean as a
    type which differentiates the two literals `true` and `false`.

    To store objects in C++, a type is defined by the template parameter @a
    BooleanType which chooses the type to use.

    #### Default type

    With the default values for @a BooleanType (`bool`), the default value for
    @a boolean_t is:

    @code {.cpp}
    bool
    @endcode

    #### Storage

    Boolean values are stored directly inside a @ref basic_json type.

    @since version 1.0.0
    */
    using boolean_t = BooleanType;

    /*!
    @brief a type for a number (integer)

    [RFC 7159](http://rfc7159.net/rfc7159) describes numbers as follows:
    > The representation of numbers is similar to that used in most
    > programming languages. A number is represented in base 10 using decimal
    > digits. It contains an integer component that may be prefixed with an
    > optional minus sign, which may be followed by a fraction part and/or an
    > exponent part. Leading zeros are not allowed. (...) Numeric values that
    > cannot be represented in the grammar below (such as Infinity and NaN)
    > are not permitted.

    This description includes both integer and floating-point numbers.
    However, C++ allows more precise storage if it is known whether the number
    is a signed integer, an unsigned integer or a floating-point number.
    Therefore, three different types, @ref number_integer_t, @ref
    number_unsigned_t and @ref number_float_t are used.

    To store integer numbers in C++, a type is defined by the template
    parameter @a NumberIntegerType which chooses the type to use.

    #### Default type

    With the default values for @a NumberIntegerType (`int64_t`), the default
    value for @a number_integer_t is:

    @code {.cpp}
    int64_t
    @endcode

    #### Default behavior

    - The restrictions about leading zeros is not enforced in C++. Instead,
      leading zeros in integer literals lead to an interpretation as octal
      number. Internally, the value will be stored as decimal number. For
      instance, the C++ integer literal `010` will be serialized to `8`.
      During deserialization, leading zeros yield an error.
    - Not-a-number (NaN) values will be serialized to `null`.

    #### Limits

    [RFC 7159](http://rfc7159.net/rfc7159) specifies:
    > An implementation may set limits on the range and precision of numbers.

    When the default type is used, the maximal integer number that can be
    stored is `9223372036854775807` (INT64_MAX) and the minimal integer number
    that can be stored is `-9223372036854775808` (INT64_MIN). Integer numbers
    that are out of range will yield over/underflow when used in a
    constructor. During deserialization, too large or small integer numbers
    will be automatically be stored as @ref number_unsigned_t or @ref
    number_float_t.

    [RFC 7159](http://rfc7159.net/rfc7159) further states:
    > Note that when such software is used, numbers that are integers and are
    > in the range \f$[-2^{53}+1, 2^{53}-1]\f$ are interoperable in the sense
    > that implementations will agree exactly on their numeric values.

    As this range is a subrange of the exactly supported range [INT64_MIN,
    INT64_MAX], this class's integer type is interoperable.

    #### Storage

    Integer number values are stored directly inside a @ref basic_json type.

    @sa @ref number_float_t -- type for number values (floating-point)

    @sa @ref number_unsigned_t -- type for number values (unsigned integer)

    @since version 1.0.0
    */
    using number_integer_t = NumberIntegerType;

    /*!
    @brief a type for a number (unsigned)

    [RFC 7159](http://rfc7159.net/rfc7159) describes numbers as follows:
    > The representation of numbers is similar to that used in most
    > programming languages. A number is represented in base 10 using decimal
    > digits. It contains an integer component that may be prefixed with an
    > optional minus sign, which may be followed by a fraction part and/or an
    > exponent part. Leading zeros are not allowed. (...) Numeric values that
    > cannot be represented in the grammar below (such as Infinity and NaN)
    > are not permitted.

    This description includes both integer and floating-point numbers.
    However, C++ allows more precise storage if it is known whether the number
    is a signed integer, an unsigned integer or a floating-point number.
    Therefore, three different types, @ref number_integer_t, @ref
    number_unsigned_t and @ref number_float_t are used.

    To store unsigned integer numbers in C++, a type is defined by the
    template parameter @a NumberUnsignedType which chooses the type to use.

    #### Default type

    With the default values for @a NumberUnsignedType (`uint64_t`), the
    default value for @a number_unsigned_t is:

    @code {.cpp}
    uint64_t
    @endcode

    #### Default behavior

    - The restrictions about leading zeros is not enforced in C++. Instead,
      leading zeros in integer literals lead to an interpretation as octal
      number. Internally, the value will be stored as decimal number. For
      instance, the C++ integer literal `010` will be serialized to `8`.
      During deserialization, leading zeros yield an error.
    - Not-a-number (NaN) values will be serialized to `null`.

    #### Limits

    [RFC 7159](http://rfc7159.net/rfc7159) specifies:
    > An implementation may set limits on the range and precision of numbers.

    When the default type is used, the maximal integer number that can be
    stored is `18446744073709551615` (UINT64_MAX) and the minimal integer
    number that can be stored is `0`. Integer numbers that are out of range
    will yield over/underflow when used in a constructor. During
    deserialization, too large or small integer numbers will be automatically
    be stored as @ref number_integer_t or @ref number_float_t.

    [RFC 7159](http://rfc7159.net/rfc7159) further states:
    > Note that when such software is used, numbers that are integers and are
    > in the range \f$[-2^{53}+1, 2^{53}-1]\f$ are interoperable in the sense
    > that implementations will agree exactly on their numeric values.

    As this range is a subrange (when considered in conjunction with the
    number_integer_t type) of the exactly supported range [0, UINT64_MAX],
    this class's integer type is interoperable.

    #### Storage

    Integer number values are stored directly inside a @ref basic_json type.

    @sa @ref number_float_t -- type for number values (floating-point)
    @sa @ref number_integer_t -- type for number values (integer)

    @since version 2.0.0
    */
    using number_unsigned_t = NumberUnsignedType;

    /*!
    @brief a type for a number (floating-point)

    [RFC 7159](http://rfc7159.net/rfc7159) describes numbers as follows:
    > The representation of numbers is similar to that used in most
    > programming languages. A number is represented in base 10 using decimal
    > digits. It contains an integer component that may be prefixed with an
    > optional minus sign, which may be followed by a fraction part and/or an
    > exponent part. Leading zeros are not allowed. (...) Numeric values that
    > cannot be represented in the grammar below (such as Infinity and NaN)
    > are not permitted.

    This description includes both integer and floating-point numbers.
    However, C++ allows more precise storage if it is known whether the number
    is a signed integer, an unsigned integer or a floating-point number.
    Therefore, three different types, @ref number_integer_t, @ref
    number_unsigned_t and @ref number_float_t are used.

    To store floating-point numbers in C++, a type is defined by the template
    parameter @a NumberFloatType which chooses the type to use.

    #### Default type

    With the default values for @a NumberFloatType (`double`), the default
    value for @a number_float_t is:

    @code {.cpp}
    double
    @endcode

    #### Default behavior

    - The restrictions about leading zeros is not enforced in C++. Instead,
      leading zeros in floating-point literals will be ignored. Internally,
      the value will be stored as decimal number. For instance, the C++
      floating-point literal `01.2` will be serialized to `1.2`. During
      deserialization, leading zeros yield an error.
    - Not-a-number (NaN) values will be serialized to `null`.

    #### Limits

    [RFC 7159](http://rfc7159.net/rfc7159) states:
    > This specification allows implementations to set limits on the range and
    > precision of numbers accepted. Since software that implements IEEE
    > 754-2008 binary64 (double precision) numbers is generally available and
    > widely used, good interoperability can be achieved by implementations
    > that expect no more precision or range than these provide, in the sense
    > that implementations will approximate JSON numbers within the expected
    > precision.

    This implementation does exactly follow this approach, as it uses double
    precision floating-point numbers. Note values smaller than
    `-1.79769313486232e+308` and values greater than `1.79769313486232e+308`
    will be stored as NaN internally and be serialized to `null`.

    #### Storage

    Floating-point number values are stored directly inside a @ref basic_json
    type.

    @sa @ref number_integer_t -- type for number values (integer)

    @sa @ref number_unsigned_t -- type for number values (unsigned integer)

    @since version 1.0.0
    */
    using number_float_t = NumberFloatType;

    /*!
    @brief a type for a packed binary type

    This type is a type designed to carry binary data that appears in various
    serialized formats, such as CBOR's Major Type 2, MessagePack's bin, and
    BSON's generic binary subtype. This type is NOT a part of standard JSON and
    exists solely for compatibility with these binary types. As such, it is
    simply defined as an ordered sequence of zero or more byte values.

    Additionally, as an implementation detail, the subtype of the binary data is
    carried around as a `std::uint8_t`, which is compatible with both of the
    binary data formats that use binary subtyping, (though the specific
    numbering is incompatible with each other, and it is up to the user to
    translate between them).

    [CBOR's RFC 7049](https://tools.ietf.org/html/rfc7049) describes this type
    as:
    > Major type 2: a byte string. The string's length in bytes is represented
    > following the rules for positive integers (major type 0).

    [MessagePack's documentation on the bin type
    family](https://github.com/msgpack/msgpack/blob/master/spec.md#bin-format-family)
    describes this type as:
    > Bin format family stores an byte array in 2, 3, or 5 bytes of extra bytes
    > in addition to the size of the byte array.

    [BSON's specifications](http://bsonspec.org/spec.html) describe several
    binary types; however, this type is intended to represent the generic binary
    type which has the description:
    > Generic binary subtype - This is the most commonly used binary subtype and
    > should be the 'default' for drivers and tools.

    None of these impose any limitations on the internal representation other
    than the basic unit of storage be some type of array whose parts are
    decomposable into bytes.

    The default representation of this binary format is a
    `std::vector<std::uint8_t>`, which is a very common way to represent a byte
    array in modern C++.

    #### Default type

    The default values for @a BinaryType is `std::vector<std::uint8_t>`

    #### Storage

    Binary Arrays are stored as pointers in a @ref basic_json type. That is,
    for any access to array values, a pointer of the type `binary_t*` must be
    dereferenced.

    #### Notes on subtypes

    - CBOR
       - Binary values are represented as byte strings. No subtypes are
         supported and will be ignored when CBOR is written.
    - MessagePack
       - If a subtype is given and the binary array contains exactly 1, 2, 4, 8,
         or 16 elements, the fixext family (fixext1, fixext2, fixext4, fixext8)
         is used. For other sizes, the ext family (ext8, ext16, ext32) is used.
         The subtype is then added as singed 8-bit integer.
       - If no subtype is given, the bin family (bin8, bin16, bin32) is used.
    - BSON
       - If a subtype is given, it is used and added as unsigned 8-bit integer.
       - If no subtype is given, the generic binary subtype 0x00 is used.

    @sa @ref binary -- create a binary array

    @since version 3.8.0
    */
    using binary_t = nlohmann::byte_container_with_subtype<BinaryType>;
    /// @}

  private:

    /// helper for exception-safe object creation
    template<typename T, typename... Args>
    JSON_HEDLEY_RETURNS_NON_NULL
    static T* create(Args&& ... args)
    {
        AllocatorType<T> alloc;
        using AllocatorTraits = std::allocator_traits<AllocatorType<T>>;

        auto deleter = [&](T * object)
        {
            AllocatorTraits::deallocate(alloc, object, 1);
        };
        std::unique_ptr<T, decltype(deleter)> object(AllocatorTraits::allocate(alloc, 1), deleter);
        AllocatorTraits::construct(alloc, object.get(), std::forward<Args>(args)...);
        JSON_ASSERT(object != nullptr);
        return object.release();
    }

    ////////////////////////
    // JSON value storage //
    ////////////////////////

    /*!
    @brief a JSON value

    The actual storage for a JSON value of the @ref basic_json class. This
    union combines the different storage types for the JSON value types
    defined in @ref value_t.

    JSON type | value_t type    | used type
    --------- | --------------- | ------------------------
    object    | object          | pointer to @ref object_t
    array     | array           | pointer to @ref array_t
    string    | string          | pointer to @ref string_t
    boolean   | boolean         | @ref boolean_t
    number    | number_integer  | @ref number_integer_t
    number    | number_unsigned | @ref number_unsigned_t
    number    | number_float    | @ref number_float_t
    binary    | binary          | pointer to @ref binary_t
    null      | null            | *no value is stored*

    @note Variable-length types (objects, arrays, and strings) are stored as
    pointers. The size of the union should not exceed 64 bits if the default
    value types are used.

    @since version 1.0.0
    */
    union json_value
    {
        /// object (stored with pointer to save storage)
        object_t* object;
        /// array (stored with pointer to save storage)
        array_t* array;
        /// string (stored with pointer to save storage)
        string_t* string;
        /// binary (stored with pointer to save storage)
        binary_t* binary;
        /// boolean
        boolean_t boolean;
        /// number (integer)
        number_integer_t number_integer;
        /// number (unsigned integer)
        number_unsigned_t number_unsigned;
        /// number (floating-point)
        number_float_t number_float;

        /// default constructor (for null values)
        json_value() = default;
        /// constructor for booleans
        json_value(boolean_t v) noexcept : boolean(v) {}
        /// constructor for numbers (integer)
        json_value(number_integer_t v) noexcept : number_integer(v) {}
        /// constructor for numbers (unsigned)
        json_value(number_unsigned_t v) noexcept : number_unsigned(v) {}
        /// constructor for numbers (floating-point)
        json_value(number_float_t v) noexcept : number_float(v) {}
        /// constructor for empty values of a given type
        json_value(value_t t)
        {
            switch (t)
            {
                case value_t::object:
                {
                    object = create<object_t>();
                    break;
                }

                case value_t::array:
                {
                    array = create<array_t>();
                    break;
                }

                case value_t::string:
                {
                    string = create<string_t>("");
                    break;
                }

                case value_t::binary:
                {
                    binary = create<binary_t>();
                    break;
                }

                case value_t::boolean:
                {
                    boolean = boolean_t(false);
                    break;
                }

                case value_t::number_integer:
                {
                    number_integer = number_integer_t(0);
                    break;
                }

                case value_t::number_unsigned:
                {
                    number_unsigned = number_unsigned_t(0);
                    break;
                }

                case value_t::number_float:
                {
                    number_float = number_float_t(0.0);
                    break;
                }

                case value_t::null:
                {
                    object = nullptr;  // silence warning, see #821
                    break;
                }

                default:
                {
                    object = nullptr;  // silence warning, see #821
                    if (JSON_HEDLEY_UNLIKELY(t == value_t::null))
                    {
                        JSON_THROW(other_error::create(500, "961c151d2e87f2686a955a9be24d316f1362bf21 3.9.1")); // LCOV_EXCL_LINE
                    }
                    break;
                }
            }
        }

        /// constructor for strings
        json_value(const string_t& value)
        {
            string = create<string_t>(value);
        }

        /// constructor for rvalue strings
        json_value(string_t&& value)
        {
            string = create<string_t>(std::move(value));
        }

        /// constructor for objects
        json_value(const object_t& value)
        {
            object = create<object_t>(value);
        }

        /// constructor for rvalue objects
        json_value(object_t&& value)
        {
            object = create<object_t>(std::move(value));
        }

        /// constructor for arrays
        json_value(const array_t& value)
        {
            array = create<array_t>(value);
        }

        /// constructor for rvalue arrays
        json_value(array_t&& value)
        {
            array = create<array_t>(std::move(value));
        }

        /// constructor for binary arrays
        json_value(const typename binary_t::container_type& value)
        {
            binary = create<binary_t>(value);
        }

        /// constructor for rvalue binary arrays
        json_value(typename binary_t::container_type&& value)
        {
            binary = create<binary_t>(std::move(value));
        }

        /// constructor for binary arrays (internal type)
        json_value(const binary_t& value)
        {
            binary = create<binary_t>(value);
        }

        /// constructor for rvalue binary arrays (internal type)
        json_value(binary_t&& value)
        {
            binary = create<binary_t>(std::move(value));
        }

        void destroy(value_t t) noexcept
        {
            // flatten the current json_value to a heap-allocated stack
            std::vector<basic_json> stack;

            // move the top-level items to stack
            if (t == value_t::array)
            {
                stack.reserve(array->size());
                std::move(array->begin(), array->end(), std::back_inserter(stack));
            }
            else if (t == value_t::object)
            {
                stack.reserve(object->size());
                for (auto&& it : *object)
                {
                    stack.push_back(std::move(it.second));
                }
            }

            while (!stack.empty())
            {
                // move the last item to local variable to be processed
                basic_json current_item(std::move(stack.back()));
                stack.pop_back();

                // if current_item is array/object, move
                // its children to the stack to be processed later
                if (current_item.is_array())
                {
                    std::move(current_item.m_value.array->begin(), current_item.m_value.array->end(),
                              std::back_inserter(stack));

                    current_item.m_value.array->clear();
                }
                else if (current_item.is_object())
                {
                    for (auto&& it : *current_item.m_value.object)
                    {
                        stack.push_back(std::move(it.second));
                    }

                    current_item.m_value.object->clear();
                }

                // it's now safe that current_item get destructed
                // since it doesn't have any children
            }

            switch (t)
            {
                case value_t::object:
                {
                    AllocatorType<object_t> alloc;
                    std::allocator_traits<decltype(alloc)>::destroy(alloc, object);
                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, object, 1);
                    break;
                }

                case value_t::array:
                {
                    AllocatorType<array_t> alloc;
                    std::allocator_traits<decltype(alloc)>::destroy(alloc, array);
                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, array, 1);
                    break;
                }

                case value_t::string:
                {
                    AllocatorType<string_t> alloc;
                    std::allocator_traits<decltype(alloc)>::destroy(alloc, string);
                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, string, 1);
                    break;
                }

                case value_t::binary:
                {
                    AllocatorType<binary_t> alloc;
                    std::allocator_traits<decltype(alloc)>::destroy(alloc, binary);
                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, binary, 1);
                    break;
                }

                default:
                {
                    break;
                }
            }
        }
    };

    /*!
    @brief checks the class invariants

    This function asserts the class invariants. It needs to be called at the
    end of every constructor to make sure that created objects respect the
    invariant. Furthermore, it has to be called each time the type of a JSON
    value is changed, because the invariant expresses a relationship between
    @a m_type and @a m_value.
    */
    void assert_invariant() const noexcept
    {
        JSON_ASSERT(m_type != value_t::object || m_value.object != nullptr);
        JSON_ASSERT(m_type != value_t::array || m_value.array != nullptr);
        JSON_ASSERT(m_type != value_t::string || m_value.string != nullptr);
        JSON_ASSERT(m_type != value_t::binary || m_value.binary != nullptr);
    }

  public:
    //////////////////////////
    // JSON parser callback //
    //////////////////////////

    /*!
    @brief parser event types

    The parser callback distinguishes the following events:
    - `object_start`: the parser read `{` and started to process a JSON object
    - `key`: the parser read a key of a value in an object
    - `object_end`: the parser read `}` and finished processing a JSON object
    - `array_start`: the parser read `[` and started to process a JSON array
    - `array_end`: the parser read `]` and finished processing a JSON array
    - `value`: the parser finished reading a JSON value

    @image html callback_events.png "Example when certain parse events are triggered"

    @sa @ref parser_callback_t for more information and examples
    */
    using parse_event_t = detail::parse_event_t;

    /*!
    @brief per-element parser callback type

    With a parser callback function, the result of parsing a JSON text can be
    influenced. When passed to @ref parse, it is called on certain events
    (passed as @ref parse_event_t via parameter @a event) with a set recursion
    depth @a depth and context JSON value @a parsed. The return value of the
    callback function is a boolean indicating whether the element that emitted
    the callback shall be kept or not.

    We distinguish six scenarios (determined by the event type) in which the
    callback function can be called. The following table describes the values
    of the parameters @a depth, @a event, and @a parsed.

    parameter @a event | description | parameter @a depth | parameter @a parsed
    ------------------ | ----------- | ------------------ | -------------------
    parse_event_t::object_start | the parser read `{` and started to process a JSON object | depth of the parent of the JSON object | a JSON value with type discarded
    parse_event_t::key | the parser read a key of a value in an object | depth of the currently parsed JSON object | a JSON string containing the key
    parse_event_t::object_end | the parser read `}` and finished processing a JSON object | depth of the parent of the JSON object | the parsed JSON object
    parse_event_t::array_start | the parser read `[` and started to process a JSON array | depth of the parent of the JSON array | a JSON value with type discarded
    parse_event_t::array_end | the parser read `]` and finished processing a JSON array | depth of the parent of the JSON array | the parsed JSON array
    parse_event_t::value | the parser finished reading a JSON value | depth of the value | the parsed JSON value

    @image html callback_events.png "Example when certain parse events are triggered"

    Discarding a value (i.e., returning `false`) has different effects
    depending on the context in which function was called:

    - Discarded values in structured types are skipped. That is, the parser
      will behave as if the discarded value was never read.
    - In case a value outside a structured type is skipped, it is replaced
      with `null`. This case happens if the top-level element is skipped.

    @param[in] depth  the depth of the recursion during parsing

    @param[in] event  an event of type parse_event_t indicating the context in
    the callback function has been called

    @param[in,out] parsed  the current intermediate parse result; note that
    writing to this value has no effect for parse_event_t::key events

    @return Whether the JSON value which called the function during parsing
    should be kept (`true`) or not (`false`). In the latter case, it is either
    skipped completely or replaced by an empty discarded object.

    @sa @ref parse for examples

    @since version 1.0.0
    */
    using parser_callback_t = detail::parser_callback_t<basic_json>;

    //////////////////
    // constructors //
    //////////////////

    /// @name constructors and destructors
    /// Constructors of class @ref basic_json, copy/move constructor, copy
    /// assignment, static functions creating objects, and the destructor.
    /// @{

    /*!
    @brief create an empty value with a given type

    Create an empty JSON value with a given type. The value will be default
    initialized with an empty value which depends on the type:

    Value type  | initial value
    ----------- | -------------
    null        | `null`
    boolean     | `false`
    string      | `""`
    number      | `0`
    object      | `{}`
    array       | `[]`
    binary      | empty array

    @param[in] v  the type of the value to create

    @complexity Constant.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes to any JSON value.

    @liveexample{The following code shows the constructor for different @ref
    value_t values,basic_json__value_t}

    @sa @ref clear() -- restores the postcondition of this constructor

    @since version 1.0.0
    */
    basic_json(const value_t v)
        : m_type(v), m_value(v)
    {
        assert_invariant();
    }

    /*!
    @brief create a null object

    Create a `null` JSON value. It either takes a null pointer as parameter
    (explicitly creating `null`) or no parameter (implicitly creating `null`).
    The passed null pointer itself is not read -- it is only used to choose
    the right constructor.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this constructor never throws
    exceptions.

    @liveexample{The following code shows the constructor with and without a
    null pointer parameter.,basic_json__nullptr_t}

    @since version 1.0.0
    */
    basic_json(std::nullptr_t = nullptr) noexcept
        : basic_json(value_t::null)
    {
        assert_invariant();
    }

    /*!
    @brief create a JSON value

    This is a "catch all" constructor for all compatible JSON types; that is,
    types for which a `to_json()` method exists. The constructor forwards the
    parameter @a val to that method (to `json_serializer<U>::to_json` method
    with `U = uncvref_t<CompatibleType>`, to be exact).

    Template type @a CompatibleType includes, but is not limited to, the
    following types:
    - **arrays**: @ref array_t and all kinds of compatible containers such as
      `std::vector`, `std::deque`, `std::list`, `std::forward_list`,
      `std::array`, `std::valarray`, `std::set`, `std::unordered_set`,
      `std::multiset`, and `std::unordered_multiset` with a `value_type` from
      which a @ref basic_json value can be constructed.
    - **objects**: @ref object_t and all kinds of compatible associative
      containers such as `std::map`, `std::unordered_map`, `std::multimap`,
      and `std::unordered_multimap` with a `key_type` compatible to
      @ref string_t and a `value_type` from which a @ref basic_json value can
      be constructed.
    - **strings**: @ref string_t, string literals, and all compatible string
      containers can be used.
    - **numbers**: @ref number_integer_t, @ref number_unsigned_t,
      @ref number_float_t, and all convertible number types such as `int`,
      `size_t`, `int64_t`, `float` or `double` can be used.
    - **boolean**: @ref boolean_t / `bool` can be used.
    - **binary**: @ref binary_t / `std::vector<uint8_t>` may be used,
      unfortunately because string literals cannot be distinguished from binary
      character arrays by the C++ type system, all types compatible with `const
      char*` will be directed to the string constructor instead.  This is both
      for backwards compatibility, and due to the fact that a binary type is not
      a standard JSON type.

    See the examples below.

    @tparam CompatibleType a type such that:
    - @a CompatibleType is not derived from `std::istream`,
    - @a CompatibleType is not @ref basic_json (to avoid hijacking copy/move
         constructors),
    - @a CompatibleType is not a different @ref basic_json type (i.e. with different template arguments)
    - @a CompatibleType is not a @ref basic_json nested type (e.g.,
         @ref json_pointer, @ref iterator, etc ...)
    - @ref @ref json_serializer<U> has a
         `to_json(basic_json_t&, CompatibleType&&)` method

    @tparam U = `uncvref_t<CompatibleType>`

    @param[in] val the value to be forwarded to the respective constructor

    @complexity Usually linear in the size of the passed @a val, also
                depending on the implementation of the called `to_json()`
                method.

    @exceptionsafety Depends on the called constructor. For types directly
    supported by the library (i.e., all types for which no `to_json()` function
    was provided), strong guarantee holds: if an exception is thrown, there are
    no changes to any JSON value.

    @liveexample{The following code shows the constructor with several
    compatible types.,basic_json__CompatibleType}

    @since version 2.1.0
    */
    template < typename CompatibleType,
               typename U = detail::uncvref_t<CompatibleType>,
               detail::enable_if_t <
                   !detail::is_basic_json<U>::value && detail::is_compatible_type<basic_json_t, U>::value, int > = 0 >
    basic_json(CompatibleType && val) noexcept(noexcept(
                JSONSerializer<U>::to_json(std::declval<basic_json_t&>(),
                                           std::forward<CompatibleType>(val))))
    {
        JSONSerializer<U>::to_json(*this, std::forward<CompatibleType>(val));
        assert_invariant();
    }

    /*!
    @brief create a JSON value from an existing one

    This is a constructor for existing @ref basic_json types.
    It does not hijack copy/move constructors, since the parameter has different
    template arguments than the current ones.

    The constructor tries to convert the internal @ref m_value of the parameter.

    @tparam BasicJsonType a type such that:
    - @a BasicJsonType is a @ref basic_json type.
    - @a BasicJsonType has different template arguments than @ref basic_json_t.

    @param[in] val the @ref basic_json value to be converted.

    @complexity Usually linear in the size of the passed @a val, also
                depending on the implementation of the called `to_json()`
                method.

    @exceptionsafety Depends on the called constructor. For types directly
    supported by the library (i.e., all types for which no `to_json()` function
    was provided), strong guarantee holds: if an exception is thrown, there are
    no changes to any JSON value.

    @since version 3.2.0
    */
    template < typename BasicJsonType,
               detail::enable_if_t <
                   detail::is_basic_json<BasicJsonType>::value&& !std::is_same<basic_json, BasicJsonType>::value, int > = 0 >
    basic_json(const BasicJsonType& val)
    {
        using other_boolean_t = typename BasicJsonType::boolean_t;
        using other_number_float_t = typename BasicJsonType::number_float_t;
        using other_number_integer_t = typename BasicJsonType::number_integer_t;
        using other_number_unsigned_t = typename BasicJsonType::number_unsigned_t;
        using other_string_t = typename BasicJsonType::string_t;
        using other_object_t = typename BasicJsonType::object_t;
        using other_array_t = typename BasicJsonType::array_t;
        using other_binary_t = typename BasicJsonType::binary_t;

        switch (val.type())
        {
            case value_t::boolean:
                JSONSerializer<other_boolean_t>::to_json(*this, val.template get<other_boolean_t>());
                break;
            case value_t::number_float:
                JSONSerializer<other_number_float_t>::to_json(*this, val.template get<other_number_float_t>());
                break;
            case value_t::number_integer:
                JSONSerializer<other_number_integer_t>::to_json(*this, val.template get<other_number_integer_t>());
                break;
            case value_t::number_unsigned:
                JSONSerializer<other_number_unsigned_t>::to_json(*this, val.template get<other_number_unsigned_t>());
                break;
            case value_t::string:
                JSONSerializer<other_string_t>::to_json(*this, val.template get_ref<const other_string_t&>());
                break;
            case value_t::object:
                JSONSerializer<other_object_t>::to_json(*this, val.template get_ref<const other_object_t&>());
                break;
            case value_t::array:
                JSONSerializer<other_array_t>::to_json(*this, val.template get_ref<const other_array_t&>());
                break;
            case value_t::binary:
                JSONSerializer<other_binary_t>::to_json(*this, val.template get_ref<const other_binary_t&>());
                break;
            case value_t::null:
                *this = nullptr;
                break;
            case value_t::discarded:
                m_type = value_t::discarded;
                break;
            default:            // LCOV_EXCL_LINE
                JSON_ASSERT(false);  // LCOV_EXCL_LINE
        }
        assert_invariant();
    }

    /*!
    @brief create a container (array or object) from an initializer list

    Creates a JSON value of type array or object from the passed initializer
    list @a init. In case @a type_deduction is `true` (default), the type of
    the JSON value to be created is deducted from the initializer list @a init
    according to the following rules:

    1. If the list is empty, an empty JSON object value `{}` is created.
    2. If the list consists of pairs whose first element is a string, a JSON
       object value is created where the first elements of the pairs are
       treated as keys and the second elements are as values.
    3. In all other cases, an array is created.

    The rules aim to create the best fit between a C++ initializer list and
    JSON values. The rationale is as follows:

    1. The empty initializer list is written as `{}` which is exactly an empty
       JSON object.
    2. C++ has no way of describing mapped types other than to list a list of
       pairs. As JSON requires that keys must be of type string, rule 2 is the
       weakest constraint one can pose on initializer lists to interpret them
       as an object.
    3. In all other cases, the initializer list could not be interpreted as
       JSON object type, so interpreting it as JSON array type is safe.

    With the rules described above, the following JSON values cannot be
    expressed by an initializer list:

    - the empty array (`[]`): use @ref array(initializer_list_t)
      with an empty initializer list in this case
    - arrays whose elements satisfy rule 2: use @ref
      array(initializer_list_t) with the same initializer list
      in this case

    @note When used without parentheses around an empty initializer list, @ref
    basic_json() is called instead of this function, yielding the JSON null
    value.

    @param[in] init  initializer list with JSON values

    @param[in] type_deduction internal parameter; when set to `true`, the type
    of the JSON value is deducted from the initializer list @a init; when set
    to `false`, the type provided via @a manual_type is forced. This mode is
    used by the functions @ref array(initializer_list_t) and
    @ref object(initializer_list_t).

    @param[in] manual_type internal parameter; when @a type_deduction is set
    to `false`, the created JSON value will use the provided type (only @ref
    value_t::array and @ref value_t::object are valid); when @a type_deduction
    is set to `true`, this parameter has no effect

    @throw type_error.301 if @a type_deduction is `false`, @a manual_type is
    `value_t::object`, but @a init contains an element which is not a pair
    whose first element is a string. In this case, the constructor could not
    create an object. If @a type_deduction would have be `true`, an array
    would have been created. See @ref object(initializer_list_t)
    for an example.

    @complexity Linear in the size of the initializer list @a init.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes to any JSON value.

    @liveexample{The example below shows how JSON values are created from
    initializer lists.,basic_json__list_init_t}

    @sa @ref array(initializer_list_t) -- create a JSON array
    value from an initializer list
    @sa @ref object(initializer_list_t) -- create a JSON object
    value from an initializer list

    @since version 1.0.0
    */
    basic_json(initializer_list_t init,
               bool type_deduction = true,
               value_t manual_type = value_t::array)
    {
        // check if each element is an array with two elements whose first
        // element is a string
        bool is_an_object = std::all_of(init.begin(), init.end(),
                                        [](const detail::json_ref<basic_json>& element_ref)
        {
            return element_ref->is_array() && element_ref->size() == 2 && (*element_ref)[0].is_string();
        });

        // adjust type if type deduction is not wanted
        if (!type_deduction)
        {
            // if array is wanted, do not create an object though possible
            if (manual_type == value_t::array)
            {
                is_an_object = false;
            }

            // if object is wanted but impossible, throw an exception
            if (JSON_HEDLEY_UNLIKELY(manual_type == value_t::object && !is_an_object))
            {
                JSON_THROW(type_error::create(301, "cannot create object from initializer list"));
            }
        }

        if (is_an_object)
        {
            // the initializer list is a list of pairs -> create object
            m_type = value_t::object;
            m_value = value_t::object;

            std::for_each(init.begin(), init.end(), [this](const detail::json_ref<basic_json>& element_ref)
            {
                auto element = element_ref.moved_or_copied();
                m_value.object->emplace(
                    std::move(*((*element.m_value.array)[0].m_value.string)),
                    std::move((*element.m_value.array)[1]));
            });
        }
        else
        {
            // the initializer list describes an array -> create array
            m_type = value_t::array;
            m_value.array = create<array_t>(init.begin(), init.end());
        }

        assert_invariant();
    }

    /*!
    @brief explicitly create a binary array (without subtype)

    Creates a JSON binary array value from a given binary container. Binary
    values are part of various binary formats, such as CBOR, MessagePack, and
    BSON. This constructor is used to create a value for serialization to those
    formats.

    @note Note, this function exists because of the difficulty in correctly
    specifying the correct template overload in the standard value ctor, as both
    JSON arrays and JSON binary arrays are backed with some form of a
    `std::vector`. Because JSON binary arrays are a non-standard extension it
    was decided that it would be best to prevent automatic initialization of a
    binary array type, for backwards compatibility and so it does not happen on
    accident.

    @param[in] init container containing bytes to use as binary type

    @return JSON binary array value

    @complexity Linear in the size of @a init.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes to any JSON value.

    @since version 3.8.0
    */
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json binary(const typename binary_t::container_type& init)
    {
        auto res = basic_json();
        res.m_type = value_t::binary;
        res.m_value = init;
        return res;
    }

    /*!
    @brief explicitly create a binary array (with subtype)

    Creates a JSON binary array value from a given binary container. Binary
    values are part of various binary formats, such as CBOR, MessagePack, and
    BSON. This constructor is used to create a value for serialization to those
    formats.

    @note Note, this function exists because of the difficulty in correctly
    specifying the correct template overload in the standard value ctor, as both
    JSON arrays and JSON binary arrays are backed with some form of a
    `std::vector`. Because JSON binary arrays are a non-standard extension it
    was decided that it would be best to prevent automatic initialization of a
    binary array type, for backwards compatibility and so it does not happen on
    accident.

    @param[in] init container containing bytes to use as binary type
    @param[in] subtype subtype to use in MessagePack and BSON

    @return JSON binary array value

    @complexity Linear in the size of @a init.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes to any JSON value.

    @since version 3.8.0
    */
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json binary(const typename binary_t::container_type& init, std::uint8_t subtype)
    {
        auto res = basic_json();
        res.m_type = value_t::binary;
        res.m_value = binary_t(init, subtype);
        return res;
    }

    /// @copydoc binary(const typename binary_t::container_type&)
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json binary(typename binary_t::container_type&& init)
    {
        auto res = basic_json();
        res.m_type = value_t::binary;
        res.m_value = std::move(init);
        return res;
    }

    /// @copydoc binary(const typename binary_t::container_type&, std::uint8_t)
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json binary(typename binary_t::container_type&& init, std::uint8_t subtype)
    {
        auto res = basic_json();
        res.m_type = value_t::binary;
        res.m_value = binary_t(std::move(init), subtype);
        return res;
    }

    /*!
    @brief explicitly create an array from an initializer list

    Creates a JSON array value from a given initializer list. That is, given a
    list of values `a, b, c`, creates the JSON value `[a, b, c]`. If the
    initializer list is empty, the empty array `[]` is created.

    @note This function is only needed to express two edge cases that cannot
    be realized with the initializer list constructor (@ref
    basic_json(initializer_list_t, bool, value_t)). These cases
    are:
    1. creating an array whose elements are all pairs whose first element is a
    string -- in this case, the initializer list constructor would create an
    object, taking the first elements as keys
    2. creating an empty array -- passing the empty initializer list to the
    initializer list constructor yields an empty object

    @param[in] init  initializer list with JSON values to create an array from
    (optional)

    @return JSON array value

    @complexity Linear in the size of @a init.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes to any JSON value.

    @liveexample{The following code shows an example for the `array`
    function.,array}

    @sa @ref basic_json(initializer_list_t, bool, value_t) --
    create a JSON value from an initializer list
    @sa @ref object(initializer_list_t) -- create a JSON object
    value from an initializer list

    @since version 1.0.0
    */
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json array(initializer_list_t init = {})
    {
        return basic_json(init, false, value_t::array);
    }

    /*!
    @brief explicitly create an object from an initializer list

    Creates a JSON object value from a given initializer list. The initializer
    lists elements must be pairs, and their first elements must be strings. If
    the initializer list is empty, the empty object `{}` is created.

    @note This function is only added for symmetry reasons. In contrast to the
    related function @ref array(initializer_list_t), there are
    no cases which can only be expressed by this function. That is, any
    initializer list @a init can also be passed to the initializer list
    constructor @ref basic_json(initializer_list_t, bool, value_t).

    @param[in] init  initializer list to create an object from (optional)

    @return JSON object value

    @throw type_error.301 if @a init is not a list of pairs whose first
    elements are strings. In this case, no object can be created. When such a
    value is passed to @ref basic_json(initializer_list_t, bool, value_t),
    an array would have been created from the passed initializer list @a init.
    See example below.

    @complexity Linear in the size of @a init.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes to any JSON value.

    @liveexample{The following code shows an example for the `object`
    function.,object}

    @sa @ref basic_json(initializer_list_t, bool, value_t) --
    create a JSON value from an initializer list
    @sa @ref array(initializer_list_t) -- create a JSON array
    value from an initializer list

    @since version 1.0.0
    */
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json object(initializer_list_t init = {})
    {
        return basic_json(init, false, value_t::object);
    }

    /*!
    @brief construct an array with count copies of given value

    Constructs a JSON array value by creating @a cnt copies of a passed value.
    In case @a cnt is `0`, an empty array is created.

    @param[in] cnt  the number of JSON copies of @a val to create
    @param[in] val  the JSON value to copy

    @post `std::distance(begin(),end()) == cnt` holds.

    @complexity Linear in @a cnt.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes to any JSON value.

    @liveexample{The following code shows examples for the @ref
    basic_json(size_type\, const basic_json&)
    constructor.,basic_json__size_type_basic_json}

    @since version 1.0.0
    */
    basic_json(size_type cnt, const basic_json& val)
        : m_type(value_t::array)
    {
        m_value.array = create<array_t>(cnt, val);
        assert_invariant();
    }

    /*!
    @brief construct a JSON container given an iterator range

    Constructs the JSON value with the contents of the range `[first, last)`.
    The semantics depends on the different types a JSON value can have:
    - In case of a null type, invalid_iterator.206 is thrown.
    - In case of other primitive types (number, boolean, or string), @a first
      must be `begin()` and @a last must be `end()`. In this case, the value is
      copied. Otherwise, invalid_iterator.204 is thrown.
    - In case of structured types (array, object), the constructor behaves as
      similar versions for `std::vector` or `std::map`; that is, a JSON array
      or object is constructed from the values in the range.

    @tparam InputIT an input iterator type (@ref iterator or @ref
    const_iterator)

    @param[in] first begin of the range to copy from (included)
    @param[in] last end of the range to copy from (excluded)

    @pre Iterators @a first and @a last must be initialized. **This
         precondition is enforced with an assertion (see warning).** If
         assertions are switched off, a violation of this precondition yields
         undefined behavior.

    @pre Range `[first, last)` is valid. Usually, this precondition cannot be
         checked efficiently. Only certain edge cases are detected; see the
         description of the exceptions below. A violation of this precondition
         yields undefined behavior.

    @warning A precondition is enforced with a runtime assertion that will
             result in calling `std::abort` if this precondition is not met.
             Assertions can be disabled by defining `NDEBUG` at compile time.
             See https://en.cppreference.com/w/cpp/error/assert for more
             information.

    @throw invalid_iterator.201 if iterators @a first and @a last are not
    compatible (i.e., do not belong to the same JSON value). In this case,
    the range `[first, last)` is undefined.
    @throw invalid_iterator.204 if iterators @a first and @a last belong to a
    primitive type (number, boolean, or string), but @a first does not point
    to the first element any more. In this case, the range `[first, last)` is
    undefined. See example code below.
    @throw invalid_iterator.206 if iterators @a first and @a last belong to a
    null value. In this case, the range `[first, last)` is undefined.

    @complexity Linear in distance between @a first and @a last.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes to any JSON value.

    @liveexample{The example below shows several ways to create JSON values by
    specifying a subrange with iterators.,basic_json__InputIt_InputIt}

    @since version 1.0.0
    */
    template < class InputIT, typename std::enable_if <
                   std::is_same<InputIT, typename basic_json_t::iterator>::value ||
                   std::is_same<InputIT, typename basic_json_t::const_iterator>::value, int >::type = 0 >
    basic_json(InputIT first, InputIT last)
    {
        JSON_ASSERT(first.m_object != nullptr);
        JSON_ASSERT(last.m_object != nullptr);

        // make sure iterator fits the current value
        if (JSON_HEDLEY_UNLIKELY(first.m_object != last.m_object))
        {
            JSON_THROW(invalid_iterator::create(201, "iterators are not compatible"));
        }

        // copy type from first iterator
        m_type = first.m_object->m_type;

        // check if iterator range is complete for primitive values
        switch (m_type)
        {
            case value_t::boolean:
            case value_t::number_float:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::string:
            {
                if (JSON_HEDLEY_UNLIKELY(!first.m_it.primitive_iterator.is_begin()
                                         || !last.m_it.primitive_iterator.is_end()))
                {
                    JSON_THROW(invalid_iterator::create(204, "iterators out of range"));
                }
                break;
            }

            default:
                break;
        }

        switch (m_type)
        {
            case value_t::number_integer:
            {
                m_value.number_integer = first.m_object->m_value.number_integer;
                break;
            }

            case value_t::number_unsigned:
            {
                m_value.number_unsigned = first.m_object->m_value.number_unsigned;
                break;
            }

            case value_t::number_float:
            {
                m_value.number_float = first.m_object->m_value.number_float;
                break;
            }

            case value_t::boolean:
            {
                m_value.boolean = first.m_object->m_value.boolean;
                break;
            }

            case value_t::string:
            {
                m_value = *first.m_object->m_value.string;
                break;
            }

            case value_t::object:
            {
                m_value.object = create<object_t>(first.m_it.object_iterator,
                                                  last.m_it.object_iterator);
                break;
            }

            case value_t::array:
            {
                m_value.array = create<array_t>(first.m_it.array_iterator,
                                                last.m_it.array_iterator);
                break;
            }

            case value_t::binary:
            {
                m_value = *first.m_object->m_value.binary;
                break;
            }

            default:
                JSON_THROW(invalid_iterator::create(206, "cannot construct with iterators from " +
                                                    std::string(first.m_object->type_name())));
        }

        assert_invariant();
    }


    ///////////////////////////////////////
    // other constructors and destructor //
    ///////////////////////////////////////

    template<typename JsonRef,
             detail::enable_if_t<detail::conjunction<detail::is_json_ref<JsonRef>,
                                 std::is_same<typename JsonRef::value_type, basic_json>>::value, int> = 0 >
    basic_json(const JsonRef& ref) : basic_json(ref.moved_or_copied()) {}

    /*!
    @brief copy constructor

    Creates a copy of a given JSON value.

    @param[in] other  the JSON value to copy

    @post `*this == other`

    @complexity Linear in the size of @a other.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes to any JSON value.

    @requirement This function helps `basic_json` satisfying the
    [Container](https://en.cppreference.com/w/cpp/named_req/Container)
    requirements:
    - The complexity is linear.
    - As postcondition, it holds: `other == basic_json(other)`.

    @liveexample{The following code shows an example for the copy
    constructor.,basic_json__basic_json}

    @since version 1.0.0
    */
    basic_json(const basic_json& other)
        : m_type(other.m_type)
    {
        // check of passed value is valid
        other.assert_invariant();

        switch (m_type)
        {
            case value_t::object:
            {
                m_value = *other.m_value.object;
                break;
            }

            case value_t::array:
            {
                m_value = *other.m_value.array;
                break;
            }

            case value_t::string:
            {
                m_value = *other.m_value.string;
                break;
            }

            case value_t::boolean:
            {
                m_value = other.m_value.boolean;
                break;
            }

            case value_t::number_integer:
            {
                m_value = other.m_value.number_integer;
                break;
            }

            case value_t::number_unsigned:
            {
                m_value = other.m_value.number_unsigned;
                break;
            }

            case value_t::number_float:
            {
                m_value = other.m_value.number_float;
                break;
            }

            case value_t::binary:
            {
                m_value = *other.m_value.binary;
                break;
            }

            default:
                break;
        }

        assert_invariant();
    }

    /*!
    @brief move constructor

    Move constructor. Constructs a JSON value with the contents of the given
    value @a other using move semantics. It "steals" the resources from @a
    other and leaves it as JSON null value.

    @param[in,out] other  value to move to this object

    @post `*this` has the same value as @a other before the call.
    @post @a other is a JSON null value.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this constructor never throws
    exceptions.

    @requirement This function helps `basic_json` satisfying the
    [MoveConstructible](https://en.cppreference.com/w/cpp/named_req/MoveConstructible)
    requirements.

    @liveexample{The code below shows the move constructor explicitly called
    via std::move.,basic_json__moveconstructor}

    @since version 1.0.0
    */
    basic_json(basic_json&& other) noexcept
        : m_type(std::move(other.m_type)),
          m_value(std::move(other.m_value))
    {
        // check that passed value is valid
        other.assert_invariant();

        // invalidate payload
        other.m_type = value_t::null;
        other.m_value = {};

        assert_invariant();
    }

    /*!
    @brief copy assignment

    Copy assignment operator. Copies a JSON value via the "copy and swap"
    strategy: It is expressed in terms of the copy constructor, destructor,
    and the `swap()` member function.

    @param[in] other  value to copy from

    @complexity Linear.

    @requirement This function helps `basic_json` satisfying the
    [Container](https://en.cppreference.com/w/cpp/named_req/Container)
    requirements:
    - The complexity is linear.

    @liveexample{The code below shows and example for the copy assignment. It
    creates a copy of value `a` which is then swapped with `b`. Finally\, the
    copy of `a` (which is the null value after the swap) is
    destroyed.,basic_json__copyassignment}

    @since version 1.0.0
    */
    basic_json& operator=(basic_json other) noexcept (
        std::is_nothrow_move_constructible<value_t>::value&&
        std::is_nothrow_move_assignable<value_t>::value&&
        std::is_nothrow_move_constructible<json_value>::value&&
        std::is_nothrow_move_assignable<json_value>::value
    )
    {
        // check that passed value is valid
        other.assert_invariant();

        using std::swap;
        swap(m_type, other.m_type);
        swap(m_value, other.m_value);

        assert_invariant();
        return *this;
    }

    /*!
    @brief destructor

    Destroys the JSON value and frees all allocated memory.

    @complexity Linear.

    @requirement This function helps `basic_json` satisfying the
    [Container](https://en.cppreference.com/w/cpp/named_req/Container)
    requirements:
    - The complexity is linear.
    - All stored elements are destroyed and all memory is freed.

    @since version 1.0.0
    */
    ~basic_json() noexcept
    {
        assert_invariant();
        m_value.destroy(m_type);
    }

    /// @}

  public:
    ///////////////////////
    // object inspection //
    ///////////////////////

    /// @name object inspection
    /// Functions to inspect the type of a JSON value.
    /// @{

    /*!
    @brief serialization

    Serialization function for JSON values. The function tries to mimic
    Python's `json.dumps()` function, and currently supports its @a indent
    and @a ensure_ascii parameters.

    @param[in] indent If indent is nonnegative, then array elements and object
    members will be pretty-printed with that indent level. An indent level of
    `0` will only insert newlines. `-1` (the default) selects the most compact
    representation.
    @param[in] indent_char The character to use for indentation if @a indent is
    greater than `0`. The default is ` ` (space).
    @param[in] ensure_ascii If @a ensure_ascii is true, all non-ASCII characters
    in the output are escaped with `\uXXXX` sequences, and the result consists
    of ASCII characters only.
    @param[in] error_handler  how to react on decoding errors; there are three
    possible values: `strict` (throws and exception in case a decoding error
    occurs; default), `replace` (replace invalid UTF-8 sequences with U+FFFD),
    and `ignore` (ignore invalid UTF-8 sequences during serialization; all
    bytes are copied to the output unchanged).

    @return string containing the serialization of the JSON value

    @throw type_error.316 if a string stored inside the JSON value is not
                          UTF-8 encoded and @a error_handler is set to strict

    @note Binary values are serialized as object containing two keys:
      - "bytes": an array of bytes as integers
      - "subtype": the subtype as integer or "null" if the binary has no subtype

    @complexity Linear.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes in the JSON value.

    @liveexample{The following example shows the effect of different @a indent\,
    @a indent_char\, and @a ensure_ascii parameters to the result of the
    serialization.,dump}

    @see https://docs.python.org/2/library/json.html#json.dump

    @since version 1.0.0; indentation character @a indent_char, option
           @a ensure_ascii and exceptions added in version 3.0.0; error
           handlers added in version 3.4.0; serialization of binary values added
           in version 3.8.0.
    */
    string_t dump(const int indent = -1,
                  const char indent_char = ' ',
                  const bool ensure_ascii = false,
                  const error_handler_t error_handler = error_handler_t::strict) const
    {
        string_t result;
        serializer s(detail::output_adapter<char, string_t>(result), indent_char, error_handler);

        if (indent >= 0)
        {
            s.dump(*this, true, ensure_ascii, static_cast<unsigned int>(indent));
        }
        else
        {
            s.dump(*this, false, ensure_ascii, 0);
        }

        return result;
    }

    /*!
    @brief return the type of the JSON value (explicit)

    Return the type of the JSON value as a value from the @ref value_t
    enumeration.

    @return the type of the JSON value
            Value type                | return value
            ------------------------- | -------------------------
            null                      | value_t::null
            boolean                   | value_t::boolean
            string                    | value_t::string
            number (integer)          | value_t::number_integer
            number (unsigned integer) | value_t::number_unsigned
            number (floating-point)   | value_t::number_float
            object                    | value_t::object
            array                     | value_t::array
            binary                    | value_t::binary
            discarded                 | value_t::discarded

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `type()` for all JSON
    types.,type}

    @sa @ref operator value_t() -- return the type of the JSON value (implicit)
    @sa @ref type_name() -- return the type as string

    @since version 1.0.0
    */
    constexpr value_t type() const noexcept
    {
        return m_type;
    }

    /*!
    @brief return whether type is primitive

    This function returns true if and only if the JSON type is primitive
    (string, number, boolean, or null).

    @return `true` if type is primitive (string, number, boolean, or null),
    `false` otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_primitive()` for all JSON
    types.,is_primitive}

    @sa @ref is_structured() -- returns whether JSON value is structured
    @sa @ref is_null() -- returns whether JSON value is `null`
    @sa @ref is_string() -- returns whether JSON value is a string
    @sa @ref is_boolean() -- returns whether JSON value is a boolean
    @sa @ref is_number() -- returns whether JSON value is a number
    @sa @ref is_binary() -- returns whether JSON value is a binary array

    @since version 1.0.0
    */
    constexpr bool is_primitive() const noexcept
    {
        return is_null() || is_string() || is_boolean() || is_number() || is_binary();
    }

    /*!
    @brief return whether type is structured

    This function returns true if and only if the JSON type is structured
    (array or object).

    @return `true` if type is structured (array or object), `false` otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_structured()` for all JSON
    types.,is_structured}

    @sa @ref is_primitive() -- returns whether value is primitive
    @sa @ref is_array() -- returns whether value is an array
    @sa @ref is_object() -- returns whether value is an object

    @since version 1.0.0
    */
    constexpr bool is_structured() const noexcept
    {
        return is_array() || is_object();
    }

    /*!
    @brief return whether value is null

    This function returns true if and only if the JSON value is null.

    @return `true` if type is null, `false` otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_null()` for all JSON
    types.,is_null}

    @since version 1.0.0
    */
    constexpr bool is_null() const noexcept
    {
        return m_type == value_t::null;
    }

    /*!
    @brief return whether value is a boolean

    This function returns true if and only if the JSON value is a boolean.

    @return `true` if type is boolean, `false` otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_boolean()` for all JSON
    types.,is_boolean}

    @since version 1.0.0
    */
    constexpr bool is_boolean() const noexcept
    {
        return m_type == value_t::boolean;
    }

    /*!
    @brief return whether value is a number

    This function returns true if and only if the JSON value is a number. This
    includes both integer (signed and unsigned) and floating-point values.

    @return `true` if type is number (regardless whether integer, unsigned
    integer or floating-type), `false` otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_number()` for all JSON
    types.,is_number}

    @sa @ref is_number_integer() -- check if value is an integer or unsigned
    integer number
    @sa @ref is_number_unsigned() -- check if value is an unsigned integer
    number
    @sa @ref is_number_float() -- check if value is a floating-point number

    @since version 1.0.0
    */
    constexpr bool is_number() const noexcept
    {
        return is_number_integer() || is_number_float();
    }

    /*!
    @brief return whether value is an integer number

    This function returns true if and only if the JSON value is a signed or
    unsigned integer number. This excludes floating-point values.

    @return `true` if type is an integer or unsigned integer number, `false`
    otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_number_integer()` for all
    JSON types.,is_number_integer}

    @sa @ref is_number() -- check if value is a number
    @sa @ref is_number_unsigned() -- check if value is an unsigned integer
    number
    @sa @ref is_number_float() -- check if value is a floating-point number

    @since version 1.0.0
    */
    constexpr bool is_number_integer() const noexcept
    {
        return m_type == value_t::number_integer || m_type == value_t::number_unsigned;
    }

    /*!
    @brief return whether value is an unsigned integer number

    This function returns true if and only if the JSON value is an unsigned
    integer number. This excludes floating-point and signed integer values.

    @return `true` if type is an unsigned integer number, `false` otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_number_unsigned()` for all
    JSON types.,is_number_unsigned}

    @sa @ref is_number() -- check if value is a number
    @sa @ref is_number_integer() -- check if value is an integer or unsigned
    integer number
    @sa @ref is_number_float() -- check if value is a floating-point number

    @since version 2.0.0
    */
    constexpr bool is_number_unsigned() const noexcept
    {
        return m_type == value_t::number_unsigned;
    }

    /*!
    @brief return whether value is a floating-point number

    This function returns true if and only if the JSON value is a
    floating-point number. This excludes signed and unsigned integer values.

    @return `true` if type is a floating-point number, `false` otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_number_float()` for all
    JSON types.,is_number_float}

    @sa @ref is_number() -- check if value is number
    @sa @ref is_number_integer() -- check if value is an integer number
    @sa @ref is_number_unsigned() -- check if value is an unsigned integer
    number

    @since version 1.0.0
    */
    constexpr bool is_number_float() const noexcept
    {
        return m_type == value_t::number_float;
    }

    /*!
    @brief return whether value is an object

    This function returns true if and only if the JSON value is an object.

    @return `true` if type is object, `false` otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_object()` for all JSON
    types.,is_object}

    @since version 1.0.0
    */
    constexpr bool is_object() const noexcept
    {
        return m_type == value_t::object;
    }

    /*!
    @brief return whether value is an array

    This function returns true if and only if the JSON value is an array.

    @return `true` if type is array, `false` otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_array()` for all JSON
    types.,is_array}

    @since version 1.0.0
    */
    constexpr bool is_array() const noexcept
    {
        return m_type == value_t::array;
    }

    /*!
    @brief return whether value is a string

    This function returns true if and only if the JSON value is a string.

    @return `true` if type is string, `false` otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_string()` for all JSON
    types.,is_string}

    @since version 1.0.0
    */
    constexpr bool is_string() const noexcept
    {
        return m_type == value_t::string;
    }

    /*!
    @brief return whether value is a binary array

    This function returns true if and only if the JSON value is a binary array.

    @return `true` if type is binary array, `false` otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_binary()` for all JSON
    types.,is_binary}

    @since version 3.8.0
    */
    constexpr bool is_binary() const noexcept
    {
        return m_type == value_t::binary;
    }

    /*!
    @brief return whether value is discarded

    This function returns true if and only if the JSON value was discarded
    during parsing with a callback function (see @ref parser_callback_t).

    @note This function will always be `false` for JSON values after parsing.
    That is, discarded values can only occur during parsing, but will be
    removed when inside a structured value or replaced by null in other cases.

    @return `true` if type is discarded, `false` otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_discarded()` for all JSON
    types.,is_discarded}

    @since version 1.0.0
    */
    constexpr bool is_discarded() const noexcept
    {
        return m_type == value_t::discarded;
    }

    /*!
    @brief return the type of the JSON value (implicit)

    Implicitly return the type of the JSON value as a value from the @ref
    value_t enumeration.

    @return the type of the JSON value

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies the @ref value_t operator for
    all JSON types.,operator__value_t}

    @sa @ref type() -- return the type of the JSON value (explicit)
    @sa @ref type_name() -- return the type as string

    @since version 1.0.0
    */
    constexpr operator value_t() const noexcept
    {
        return m_type;
    }

    /// @}

  private:
    //////////////////
    // value access //
    //////////////////

    /// get a boolean (explicit)
    boolean_t get_impl(boolean_t* /*unused*/) const
    {
        if (JSON_HEDLEY_LIKELY(is_boolean()))
        {
            return m_value.boolean;
        }

        JSON_THROW(type_error::create(302, "type must be boolean, but is " + std::string(type_name())));
    }

    /// get a pointer to the value (object)
    object_t* get_impl_ptr(object_t* /*unused*/) noexcept
    {
        return is_object() ? m_value.object : nullptr;
    }

    /// get a pointer to the value (object)
    constexpr const object_t* get_impl_ptr(const object_t* /*unused*/) const noexcept
    {
        return is_object() ? m_value.object : nullptr;
    }

    /// get a pointer to the value (array)
    array_t* get_impl_ptr(array_t* /*unused*/) noexcept
    {
        return is_array() ? m_value.array : nullptr;
    }

    /// get a pointer to the value (array)
    constexpr const array_t* get_impl_ptr(const array_t* /*unused*/) const noexcept
    {
        return is_array() ? m_value.array : nullptr;
    }

    /// get a pointer to the value (string)
    string_t* get_impl_ptr(string_t* /*unused*/) noexcept
    {
        return is_string() ? m_value.string : nullptr;
    }

    /// get a pointer to the value (string)
    constexpr const string_t* get_impl_ptr(const string_t* /*unused*/) const noexcept
    {
        return is_string() ? m_value.string : nullptr;
    }

    /// get a pointer to the value (boolean)
    boolean_t* get_impl_ptr(boolean_t* /*unused*/) noexcept
    {
        return is_boolean() ? &m_value.boolean : nullptr;
    }

    /// get a pointer to the value (boolean)
    constexpr const boolean_t* get_impl_ptr(const boolean_t* /*unused*/) const noexcept
    {
        return is_boolean() ? &m_value.boolean : nullptr;
    }

    /// get a pointer to the value (integer number)
    number_integer_t* get_impl_ptr(number_integer_t* /*unused*/) noexcept
    {
        return is_number_integer() ? &m_value.number_integer : nullptr;
    }

    /// get a pointer to the value (integer number)
    constexpr const number_integer_t* get_impl_ptr(const number_integer_t* /*unused*/) const noexcept
    {
        return is_number_integer() ? &m_value.number_integer : nullptr;
    }

    /// get a pointer to the value (unsigned number)
    number_unsigned_t* get_impl_ptr(number_unsigned_t* /*unused*/) noexcept
    {
        return is_number_unsigned() ? &m_value.number_unsigned : nullptr;
    }

    /// get a pointer to the value (unsigned number)
    constexpr const number_unsigned_t* get_impl_ptr(const number_unsigned_t* /*unused*/) const noexcept
    {
        return is_number_unsigned() ? &m_value.number_unsigned : nullptr;
    }

    /// get a pointer to the value (floating-point number)
    number_float_t* get_impl_ptr(number_float_t* /*unused*/) noexcept
    {
        return is_number_float() ? &m_value.number_float : nullptr;
    }

    /// get a pointer to the value (floating-point number)
    constexpr const number_float_t* get_impl_ptr(const number_float_t* /*unused*/) const noexcept
    {
        return is_number_float() ? &m_value.number_float : nullptr;
    }

    /// get a pointer to the value (binary)
    binary_t* get_impl_ptr(binary_t* /*unused*/) noexcept
    {
        return is_binary() ? m_value.binary : nullptr;
    }

    /// get a pointer to the value (binary)
    constexpr const binary_t* get_impl_ptr(const binary_t* /*unused*/) const noexcept
    {
        return is_binary() ? m_value.binary : nullptr;
    }

    /*!
    @brief helper function to implement get_ref()

    This function helps to implement get_ref() without code duplication for
    const and non-const overloads

    @tparam ThisType will be deduced as `basic_json` or `const basic_json`

    @throw type_error.303 if ReferenceType does not match underlying value
    type of the current JSON
    */
    template<typename ReferenceType, typename ThisType>
    static ReferenceType get_ref_impl(ThisType& obj)
    {
        // delegate the call to get_ptr<>()
        auto ptr = obj.template get_ptr<typename std::add_pointer<ReferenceType>::type>();

        if (JSON_HEDLEY_LIKELY(ptr != nullptr))
        {
            return *ptr;
        }

        JSON_THROW(type_error::create(303, "incompatible ReferenceType for get_ref, actual type is " + std::string(obj.type_name())));
    }

  public:
    /// @name value access
    /// Direct access to the stored value of a JSON value.
    /// @{

    /*!
    @brief get special-case overload

    This overloads avoids a lot of template boilerplate, it can be seen as the
    identity method

    @tparam BasicJsonType == @ref basic_json

    @return a copy of *this

    @complexity Constant.

    @since version 2.1.0
    */
    template<typename BasicJsonType, detail::enable_if_t<
                 std::is_same<typename std::remove_const<BasicJsonType>::type, basic_json_t>::value,
                 int> = 0>
    basic_json get() const
    {
        return *this;
    }

    /*!
    @brief get special-case overload

    This overloads converts the current @ref basic_json in a different
    @ref basic_json type

    @tparam BasicJsonType == @ref basic_json

    @return a copy of *this, converted into @tparam BasicJsonType

    @complexity Depending on the implementation of the called `from_json()`
                method.

    @since version 3.2.0
    */
    template < typename BasicJsonType, detail::enable_if_t <
                   !std::is_same<BasicJsonType, basic_json>::value&&
                   detail::is_basic_json<BasicJsonType>::value, int > = 0 >
    BasicJsonType get() const
    {
        return *this;
    }

    /*!
    @brief get a value (explicit)

    Explicit type conversion between the JSON value and a compatible value
    which is [CopyConstructible](https://en.cppreference.com/w/cpp/named_req/CopyConstructible)
    and [DefaultConstructible](https://en.cppreference.com/w/cpp/named_req/DefaultConstructible).
    The value is converted by calling the @ref json_serializer<ValueType>
    `from_json()` method.

    The function is equivalent to executing
    @code {.cpp}
    ValueType ret;
    JSONSerializer<ValueType>::from_json(*this, ret);
    return ret;
    @endcode

    This overloads is chosen if:
    - @a ValueType is not @ref basic_json,
    - @ref json_serializer<ValueType> has a `from_json()` method of the form
      `void from_json(const basic_json&, ValueType&)`, and
    - @ref json_serializer<ValueType> does not have a `from_json()` method of
      the form `ValueType from_json(const basic_json&)`

    @tparam ValueTypeCV the provided value type
    @tparam ValueType the returned value type

    @return copy of the JSON value, converted to @a ValueType

    @throw what @ref json_serializer<ValueType> `from_json()` method throws

    @liveexample{The example below shows several conversions from JSON values
    to other types. There a few things to note: (1) Floating-point numbers can
    be converted to integers\, (2) A JSON array can be converted to a standard
    `std::vector<short>`\, (3) A JSON object can be converted to C++
    associative containers such as `std::unordered_map<std::string\,
    json>`.,get__ValueType_const}

    @since version 2.1.0
    */
    template < typename ValueTypeCV, typename ValueType = detail::uncvref_t<ValueTypeCV>,
               detail::enable_if_t <
                   !detail::is_basic_json<ValueType>::value &&
                   detail::has_from_json<basic_json_t, ValueType>::value &&
                   !detail::has_non_default_from_json<basic_json_t, ValueType>::value,
                   int > = 0 >
    ValueType get() const noexcept(noexcept(
                                       JSONSerializer<ValueType>::from_json(std::declval<const basic_json_t&>(), std::declval<ValueType&>())))
    {
        // we cannot static_assert on ValueTypeCV being non-const, because
        // there is support for get<const basic_json_t>(), which is why we
        // still need the uncvref
        static_assert(!std::is_reference<ValueTypeCV>::value,
                      "get() cannot be used with reference types, you might want to use get_ref()");
        static_assert(std::is_default_constructible<ValueType>::value,
                      "types must be DefaultConstructible when used with get()");

        ValueType ret;
        JSONSerializer<ValueType>::from_json(*this, ret);
        return ret;
    }

    /*!
    @brief get a value (explicit); special case

    Explicit type conversion between the JSON value and a compatible value
    which is **not** [CopyConstructible](https://en.cppreference.com/w/cpp/named_req/CopyConstructible)
    and **not** [DefaultConstructible](https://en.cppreference.com/w/cpp/named_req/DefaultConstructible).
    The value is converted by calling the @ref json_serializer<ValueType>
    `from_json()` method.

    The function is equivalent to executing
    @code {.cpp}
    return JSONSerializer<ValueTypeCV>::from_json(*this);
    @endcode

    This overloads is chosen if:
    - @a ValueType is not @ref basic_json and
    - @ref json_serializer<ValueType> has a `from_json()` method of the form
      `ValueType from_json(const basic_json&)`

    @note If @ref json_serializer<ValueType> has both overloads of
    `from_json()`, this one is chosen.

    @tparam ValueTypeCV the provided value type
    @tparam ValueType the returned value type

    @return copy of the JSON value, converted to @a ValueType

    @throw what @ref json_serializer<ValueType> `from_json()` method throws

    @since version 2.1.0
    */
    template < typename ValueTypeCV, typename ValueType = detail::uncvref_t<ValueTypeCV>,
               detail::enable_if_t < !std::is_same<basic_json_t, ValueType>::value &&
                                     detail::has_non_default_from_json<basic_json_t, ValueType>::value,
                                     int > = 0 >
    ValueType get() const noexcept(noexcept(
                                       JSONSerializer<ValueType>::from_json(std::declval<const basic_json_t&>())))
    {
        static_assert(!std::is_reference<ValueTypeCV>::value,
                      "get() cannot be used with reference types, you might want to use get_ref()");
        return JSONSerializer<ValueType>::from_json(*this);
    }

    /*!
    @brief get a value (explicit)

    Explicit type conversion between the JSON value and a compatible value.
    The value is filled into the input parameter by calling the @ref json_serializer<ValueType>
    `from_json()` method.

    The function is equivalent to executing
    @code {.cpp}
    ValueType v;
    JSONSerializer<ValueType>::from_json(*this, v);
    @endcode

    This overloads is chosen if:
    - @a ValueType is not @ref basic_json,
    - @ref json_serializer<ValueType> has a `from_json()` method of the form
      `void from_json(const basic_json&, ValueType&)`, and

    @tparam ValueType the input parameter type.

    @return the input parameter, allowing chaining calls.

    @throw what @ref json_serializer<ValueType> `from_json()` method throws

    @liveexample{The example below shows several conversions from JSON values
    to other types. There a few things to note: (1) Floating-point numbers can
    be converted to integers\, (2) A JSON array can be converted to a standard
    `std::vector<short>`\, (3) A JSON object can be converted to C++
    associative containers such as `std::unordered_map<std::string\,
    json>`.,get_to}

    @since version 3.3.0
    */
    template < typename ValueType,
               detail::enable_if_t <
                   !detail::is_basic_json<ValueType>::value&&
                   detail::has_from_json<basic_json_t, ValueType>::value,
                   int > = 0 >
    ValueType & get_to(ValueType& v) const noexcept(noexcept(
                JSONSerializer<ValueType>::from_json(std::declval<const basic_json_t&>(), v)))
    {
        JSONSerializer<ValueType>::from_json(*this, v);
        return v;
    }

    // specialization to allow to call get_to with a basic_json value
    // see https://github.com/nlohmann/json/issues/2175
    template<typename ValueType,
             detail::enable_if_t <
                 detail::is_basic_json<ValueType>::value,
                 int> = 0>
    ValueType & get_to(ValueType& v) const
    {
        v = *this;
        return v;
    }

    template <
        typename T, std::size_t N,
        typename Array = T (&)[N],
        detail::enable_if_t <
            detail::has_from_json<basic_json_t, Array>::value, int > = 0 >
    Array get_to(T (&v)[N]) const
    noexcept(noexcept(JSONSerializer<Array>::from_json(
                          std::declval<const basic_json_t&>(), v)))
    {
        JSONSerializer<Array>::from_json(*this, v);
        return v;
    }


    /*!
    @brief get a pointer value (implicit)

    Implicit pointer access to the internally stored JSON value. No copies are
    made.

    @warning Writing data to the pointee of the result yields an undefined
    state.

    @tparam PointerType pointer type; must be a pointer to @ref array_t, @ref
    object_t, @ref string_t, @ref boolean_t, @ref number_integer_t,
    @ref number_unsigned_t, or @ref number_float_t. Enforced by a static
    assertion.

    @return pointer to the internally stored JSON value if the requested
    pointer type @a PointerType fits to the JSON value; `nullptr` otherwise

    @complexity Constant.

    @liveexample{The example below shows how pointers to internal values of a
    JSON value can be requested. Note that no type conversions are made and a
    `nullptr` is returned if the value and the requested pointer type does not
    match.,get_ptr}

    @since version 1.0.0
    */
    template<typename PointerType, typename std::enable_if<
                 std::is_pointer<PointerType>::value, int>::type = 0>
    auto get_ptr() noexcept -> decltype(std::declval<basic_json_t&>().get_impl_ptr(std::declval<PointerType>()))
    {
        // delegate the call to get_impl_ptr<>()
        return get_impl_ptr(static_cast<PointerType>(nullptr));
    }

    /*!
    @brief get a pointer value (implicit)
    @copydoc get_ptr()
    */
    template < typename PointerType, typename std::enable_if <
                   std::is_pointer<PointerType>::value&&
                   std::is_const<typename std::remove_pointer<PointerType>::type>::value, int >::type = 0 >
    constexpr auto get_ptr() const noexcept -> decltype(std::declval<const basic_json_t&>().get_impl_ptr(std::declval<PointerType>()))
    {
        // delegate the call to get_impl_ptr<>() const
        return get_impl_ptr(static_cast<PointerType>(nullptr));
    }

    /*!
    @brief get a pointer value (explicit)

    Explicit pointer access to the internally stored JSON value. No copies are
    made.

    @warning The pointer becomes invalid if the underlying JSON object
    changes.

    @tparam PointerType pointer type; must be a pointer to @ref array_t, @ref
    object_t, @ref string_t, @ref boolean_t, @ref number_integer_t,
    @ref number_unsigned_t, or @ref number_float_t.

    @return pointer to the internally stored JSON value if the requested
    pointer type @a PointerType fits to the JSON value; `nullptr` otherwise

    @complexity Constant.

    @liveexample{The example below shows how pointers to internal values of a
    JSON value can be requested. Note that no type conversions are made and a
    `nullptr` is returned if the value and the requested pointer type does not
    match.,get__PointerType}

    @sa @ref get_ptr() for explicit pointer-member access

    @since version 1.0.0
    */
    template<typename PointerType, typename std::enable_if<
                 std::is_pointer<PointerType>::value, int>::type = 0>
    auto get() noexcept -> decltype(std::declval<basic_json_t&>().template get_ptr<PointerType>())
    {
        // delegate the call to get_ptr
        return get_ptr<PointerType>();
    }

    /*!
    @brief get a pointer value (explicit)
    @copydoc get()
    */
    template<typename PointerType, typename std::enable_if<
                 std::is_pointer<PointerType>::value, int>::type = 0>
    constexpr auto get() const noexcept -> decltype(std::declval<const basic_json_t&>().template get_ptr<PointerType>())
    {
        // delegate the call to get_ptr
        return get_ptr<PointerType>();
    }

    /*!
    @brief get a reference value (implicit)

    Implicit reference access to the internally stored JSON value. No copies
    are made.

    @warning Writing data to the referee of the result yields an undefined
    state.

    @tparam ReferenceType reference type; must be a reference to @ref array_t,
    @ref object_t, @ref string_t, @ref boolean_t, @ref number_integer_t, or
    @ref number_float_t. Enforced by static assertion.

    @return reference to the internally stored JSON value if the requested
    reference type @a ReferenceType fits to the JSON value; throws
    type_error.303 otherwise

    @throw type_error.303 in case passed type @a ReferenceType is incompatible
    with the stored JSON value; see example below

    @complexity Constant.

    @liveexample{The example shows several calls to `get_ref()`.,get_ref}

    @since version 1.1.0
    */
    template<typename ReferenceType, typename std::enable_if<
                 std::is_reference<ReferenceType>::value, int>::type = 0>
    ReferenceType get_ref()
    {
        // delegate call to get_ref_impl
        return get_ref_impl<ReferenceType>(*this);
    }

    /*!
    @brief get a reference value (implicit)
    @copydoc get_ref()
    */
    template < typename ReferenceType, typename std::enable_if <
                   std::is_reference<ReferenceType>::value&&
                   std::is_const<typename std::remove_reference<ReferenceType>::type>::value, int >::type = 0 >
    ReferenceType get_ref() const
    {
        // delegate call to get_ref_impl
        return get_ref_impl<ReferenceType>(*this);
    }

    /*!
    @brief get a value (implicit)

    Implicit type conversion between the JSON value and a compatible value.
    The call is realized by calling @ref get() const.

    @tparam ValueType non-pointer type compatible to the JSON value, for
    instance `int` for JSON integer numbers, `bool` for JSON booleans, or
    `std::vector` types for JSON arrays. The character type of @ref string_t
    as well as an initializer list of this type is excluded to avoid
    ambiguities as these types implicitly convert to `std::string`.

    @return copy of the JSON value, converted to type @a ValueType

    @throw type_error.302 in case passed type @a ValueType is incompatible
    to the JSON value type (e.g., the JSON value is of type boolean, but a
    string is requested); see example below

    @complexity Linear in the size of the JSON value.

    @liveexample{The example below shows several conversions from JSON values
    to other types. There a few things to note: (1) Floating-point numbers can
    be converted to integers\, (2) A JSON array can be converted to a standard
    `std::vector<short>`\, (3) A JSON object can be converted to C++
    associative containers such as `std::unordered_map<std::string\,
    json>`.,operator__ValueType}

    @since version 1.0.0
    */
    template < typename ValueType, typename std::enable_if <
                   !std::is_pointer<ValueType>::value&&
                   !std::is_same<ValueType, detail::json_ref<basic_json>>::value&&
                   !std::is_same<ValueType, typename string_t::value_type>::value&&
                   !detail::is_basic_json<ValueType>::value
                   && !std::is_same<ValueType, std::initializer_list<typename string_t::value_type>>::value
#if defined(JSON_HAS_CPP_17) && (defined(__GNUC__) || (defined(_MSC_VER) && _MSC_VER >= 1910 && _MSC_VER <= 1914))
                   && !std::is_same<ValueType, typename std::string_view>::value
#endif
                   && detail::is_detected<detail::get_template_function, const basic_json_t&, ValueType>::value
                   , int >::type = 0 >
    JSON_EXPLICIT operator ValueType() const
    {
        // delegate the call to get<>() const
        return get<ValueType>();
    }

    /*!
    @return reference to the binary value

    @throw type_error.302 if the value is not binary

    @sa @ref is_binary() to check if the value is binary

    @since version 3.8.0
    */
    binary_t& get_binary()
    {
        if (!is_binary())
        {
            JSON_THROW(type_error::create(302, "type must be binary, but is " + std::string(type_name())));
        }

        return *get_ptr<binary_t*>();
    }

    /// @copydoc get_binary()
    const binary_t& get_binary() const
    {
        if (!is_binary())
        {
            JSON_THROW(type_error::create(302, "type must be binary, but is " + std::string(type_name())));
        }

        return *get_ptr<const binary_t*>();
    }

    /// @}


    ////////////////////
    // element access //
    ////////////////////

    /// @name element access
    /// Access to the JSON value.
    /// @{

    /*!
    @brief access specified array element with bounds checking

    Returns a reference to the element at specified location @a idx, with
    bounds checking.

    @param[in] idx  index of the element to access

    @return reference to the element at index @a idx

    @throw type_error.304 if the JSON value is not an array; in this case,
    calling `at` with an index makes no sense. See example below.
    @throw out_of_range.401 if the index @a idx is out of range of the array;
    that is, `idx >= size()`. See example below.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes in the JSON value.

    @complexity Constant.

    @since version 1.0.0

    @liveexample{The example below shows how array elements can be read and
    written using `at()`. It also demonstrates the different exceptions that
    can be thrown.,at__size_type}
    */
    reference at(size_type idx)
    {
        // at only works for arrays
        if (JSON_HEDLEY_LIKELY(is_array()))
        {
            JSON_TRY
            {
                return m_value.array->at(idx);
            }
            JSON_CATCH (std::out_of_range&)
            {
                // create better exception explanation
                JSON_THROW(out_of_range::create(401, "array index " + std::to_string(idx) + " is out of range"));
            }
        }
        else
        {
            JSON_THROW(type_error::create(304, "cannot use at() with " + std::string(type_name())));
        }
    }

    /*!
    @brief access specified array element with bounds checking

    Returns a const reference to the element at specified location @a idx,
    with bounds checking.

    @param[in] idx  index of the element to access

    @return const reference to the element at index @a idx

    @throw type_error.304 if the JSON value is not an array; in this case,
    calling `at` with an index makes no sense. See example below.
    @throw out_of_range.401 if the index @a idx is out of range of the array;
    that is, `idx >= size()`. See example below.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes in the JSON value.

    @complexity Constant.

    @since version 1.0.0

    @liveexample{The example below shows how array elements can be read using
    `at()`. It also demonstrates the different exceptions that can be thrown.,
    at__size_type_const}
    */
    const_reference at(size_type idx) const
    {
        // at only works for arrays
        if (JSON_HEDLEY_LIKELY(is_array()))
        {
            JSON_TRY
            {
                return m_value.array->at(idx);
            }
            JSON_CATCH (std::out_of_range&)
            {
                // create better exception explanation
                JSON_THROW(out_of_range::create(401, "array index " + std::to_string(idx) + " is out of range"));
            }
        }
        else
        {
            JSON_THROW(type_error::create(304, "cannot use at() with " + std::string(type_name())));
        }
    }

    /*!
    @brief access specified object element with bounds checking

    Returns a reference to the element at with specified key @a key, with
    bounds checking.

    @param[in] key  key of the element to access

    @return reference to the element at key @a key

    @throw type_error.304 if the JSON value is not an object; in this case,
    calling `at` with a key makes no sense. See example below.
    @throw out_of_range.403 if the key @a key is is not stored in the object;
    that is, `find(key) == end()`. See example below.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes in the JSON value.

    @complexity Logarithmic in the size of the container.

    @sa @ref operator[](const typename object_t::key_type&) for unchecked
    access by reference
    @sa @ref value() for access by value with a default value

    @since version 1.0.0

    @liveexample{The example below shows how object elements can be read and
    written using `at()`. It also demonstrates the different exceptions that
    can be thrown.,at__object_t_key_type}
    */
    reference at(const typename object_t::key_type& key)
    {
        // at only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            JSON_TRY
            {
                return m_value.object->at(key);
            }
            JSON_CATCH (std::out_of_range&)
            {
                // create better exception explanation
                JSON_THROW(out_of_range::create(403, "key '" + key + "' not found"));
            }
        }
        else
        {
            JSON_THROW(type_error::create(304, "cannot use at() with " + std::string(type_name())));
        }
    }

    /*!
    @brief access specified object element with bounds checking

    Returns a const reference to the element at with specified key @a key,
    with bounds checking.

    @param[in] key  key of the element to access

    @return const reference to the element at key @a key

    @throw type_error.304 if the JSON value is not an object; in this case,
    calling `at` with a key makes no sense. See example below.
    @throw out_of_range.403 if the key @a key is is not stored in the object;
    that is, `find(key) == end()`. See example below.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes in the JSON value.

    @complexity Logarithmic in the size of the container.

    @sa @ref operator[](const typename object_t::key_type&) for unchecked
    access by reference
    @sa @ref value() for access by value with a default value

    @since version 1.0.0

    @liveexample{The example below shows how object elements can be read using
    `at()`. It also demonstrates the different exceptions that can be thrown.,
    at__object_t_key_type_const}
    */
    const_reference at(const typename object_t::key_type& key) const
    {
        // at only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            JSON_TRY
            {
                return m_value.object->at(key);
            }
            JSON_CATCH (std::out_of_range&)
            {
                // create better exception explanation
                JSON_THROW(out_of_range::create(403, "key '" + key + "' not found"));
            }
        }
        else
        {
            JSON_THROW(type_error::create(304, "cannot use at() with " + std::string(type_name())));
        }
    }

    /*!
    @brief access specified array element

    Returns a reference to the element at specified location @a idx.

    @note If @a idx is beyond the range of the array (i.e., `idx >= size()`),
    then the array is silently filled up with `null` values to make `idx` a
    valid reference to the last stored element.

    @param[in] idx  index of the element to access

    @return reference to the element at index @a idx

    @throw type_error.305 if the JSON value is not an array or null; in that
    cases, using the [] operator with an index makes no sense.

    @complexity Constant if @a idx is in the range of the array. Otherwise
    linear in `idx - size()`.

    @liveexample{The example below shows how array elements can be read and
    written using `[]` operator. Note the addition of `null`
    values.,operatorarray__size_type}

    @since version 1.0.0
    */
    reference operator[](size_type idx)
    {
        // implicitly convert null value to an empty array
        if (is_null())
        {
            m_type = value_t::array;
            m_value.array = create<array_t>();
            assert_invariant();
        }

        // operator[] only works for arrays
        if (JSON_HEDLEY_LIKELY(is_array()))
        {
            // fill up array with null values if given idx is outside range
            if (idx >= m_value.array->size())
            {
                m_value.array->insert(m_value.array->end(),
                                      idx - m_value.array->size() + 1,
                                      basic_json());
            }

            return m_value.array->operator[](idx);
        }

        JSON_THROW(type_error::create(305, "cannot use operator[] with a numeric argument with " + std::string(type_name())));
    }

    /*!
    @brief access specified array element

    Returns a const reference to the element at specified location @a idx.

    @param[in] idx  index of the element to access

    @return const reference to the element at index @a idx

    @throw type_error.305 if the JSON value is not an array; in that case,
    using the [] operator with an index makes no sense.

    @complexity Constant.

    @liveexample{The example below shows how array elements can be read using
    the `[]` operator.,operatorarray__size_type_const}

    @since version 1.0.0
    */
    const_reference operator[](size_type idx) const
    {
        // const operator[] only works for arrays
        if (JSON_HEDLEY_LIKELY(is_array()))
        {
            return m_value.array->operator[](idx);
        }

        JSON_THROW(type_error::create(305, "cannot use operator[] with a numeric argument with " + std::string(type_name())));
    }

    /*!
    @brief access specified object element

    Returns a reference to the element at with specified key @a key.

    @note If @a key is not found in the object, then it is silently added to
    the object and filled with a `null` value to make `key` a valid reference.
    In case the value was `null` before, it is converted to an object.

    @param[in] key  key of the element to access

    @return reference to the element at key @a key

    @throw type_error.305 if the JSON value is not an object or null; in that
    cases, using the [] operator with a key makes no sense.

    @complexity Logarithmic in the size of the container.

    @liveexample{The example below shows how object elements can be read and
    written using the `[]` operator.,operatorarray__key_type}

    @sa @ref at(const typename object_t::key_type&) for access by reference
    with range checking
    @sa @ref value() for access by value with a default value

    @since version 1.0.0
    */
    reference operator[](const typename object_t::key_type& key)
    {
        // implicitly convert null value to an empty object
        if (is_null())
        {
            m_type = value_t::object;
            m_value.object = create<object_t>();
            assert_invariant();
        }

        // operator[] only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            return m_value.object->operator[](key);
        }

        JSON_THROW(type_error::create(305, "cannot use operator[] with a string argument with " + std::string(type_name())));
    }

    /*!
    @brief read-only access specified object element

    Returns a const reference to the element at with specified key @a key. No
    bounds checking is performed.

    @warning If the element with key @a key does not exist, the behavior is
    undefined.

    @param[in] key  key of the element to access

    @return const reference to the element at key @a key

    @pre The element with key @a key must exist. **This precondition is
         enforced with an assertion.**

    @throw type_error.305 if the JSON value is not an object; in that case,
    using the [] operator with a key makes no sense.

    @complexity Logarithmic in the size of the container.

    @liveexample{The example below shows how object elements can be read using
    the `[]` operator.,operatorarray__key_type_const}

    @sa @ref at(const typename object_t::key_type&) for access by reference
    with range checking
    @sa @ref value() for access by value with a default value

    @since version 1.0.0
    */
    const_reference operator[](const typename object_t::key_type& key) const
    {
        // const operator[] only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            JSON_ASSERT(m_value.object->find(key) != m_value.object->end());
            return m_value.object->find(key)->second;
        }

        JSON_THROW(type_error::create(305, "cannot use operator[] with a string argument with " + std::string(type_name())));
    }

    /*!
    @brief access specified object element

    Returns a reference to the element at with specified key @a key.

    @note If @a key is not found in the object, then it is silently added to
    the object and filled with a `null` value to make `key` a valid reference.
    In case the value was `null` before, it is converted to an object.

    @param[in] key  key of the element to access

    @return reference to the element at key @a key

    @throw type_error.305 if the JSON value is not an object or null; in that
    cases, using the [] operator with a key makes no sense.

    @complexity Logarithmic in the size of the container.

    @liveexample{The example below shows how object elements can be read and
    written using the `[]` operator.,operatorarray__key_type}

    @sa @ref at(const typename object_t::key_type&) for access by reference
    with range checking
    @sa @ref value() for access by value with a default value

    @since version 1.1.0
    */
    template<typename T>
    JSON_HEDLEY_NON_NULL(2)
    reference operator[](T* key)
    {
        // implicitly convert null to object
        if (is_null())
        {
            m_type = value_t::object;
            m_value = value_t::object;
            assert_invariant();
        }

        // at only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            return m_value.object->operator[](key);
        }

        JSON_THROW(type_error::create(305, "cannot use operator[] with a string argument with " + std::string(type_name())));
    }

    /*!
    @brief read-only access specified object element

    Returns a const reference to the element at with specified key @a key. No
    bounds checking is performed.

    @warning If the element with key @a key does not exist, the behavior is
    undefined.

    @param[in] key  key of the element to access

    @return const reference to the element at key @a key

    @pre The element with key @a key must exist. **This precondition is
         enforced with an assertion.**

    @throw type_error.305 if the JSON value is not an object; in that case,
    using the [] operator with a key makes no sense.

    @complexity Logarithmic in the size of the container.

    @liveexample{The example below shows how object elements can be read using
    the `[]` operator.,operatorarray__key_type_const}

    @sa @ref at(const typename object_t::key_type&) for access by reference
    with range checking
    @sa @ref value() for access by value with a default value

    @since version 1.1.0
    */
    template<typename T>
    JSON_HEDLEY_NON_NULL(2)
    const_reference operator[](T* key) const
    {
        // at only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            JSON_ASSERT(m_value.object->find(key) != m_value.object->end());
            return m_value.object->find(key)->second;
        }

        JSON_THROW(type_error::create(305, "cannot use operator[] with a string argument with " + std::string(type_name())));
    }

    /*!
    @brief access specified object element with default value

    Returns either a copy of an object's element at the specified key @a key
    or a given default value if no element with key @a key exists.

    The function is basically equivalent to executing
    @code {.cpp}
    try {
        return at(key);
    } catch(out_of_range) {
        return default_value;
    }
    @endcode

    @note Unlike @ref at(const typename object_t::key_type&), this function
    does not throw if the given key @a key was not found.

    @note Unlike @ref operator[](const typename object_t::key_type& key), this
    function does not implicitly add an element to the position defined by @a
    key. This function is furthermore also applicable to const objects.

    @param[in] key  key of the element to access
    @param[in] default_value  the value to return if @a key is not found

    @tparam ValueType type compatible to JSON values, for instance `int` for
    JSON integer numbers, `bool` for JSON booleans, or `std::vector` types for
    JSON arrays. Note the type of the expected value at @a key and the default
    value @a default_value must be compatible.

    @return copy of the element at key @a key or @a default_value if @a key
    is not found

    @throw type_error.302 if @a default_value does not match the type of the
    value at @a key
    @throw type_error.306 if the JSON value is not an object; in that case,
    using `value()` with a key makes no sense.

    @complexity Logarithmic in the size of the container.

    @liveexample{The example below shows how object elements can be queried
    with a default value.,basic_json__value}

    @sa @ref at(const typename object_t::key_type&) for access by reference
    with range checking
    @sa @ref operator[](const typename object_t::key_type&) for unchecked
    access by reference

    @since version 1.0.0
    */
    // using std::is_convertible in a std::enable_if will fail when using explicit conversions
    template < class ValueType, typename std::enable_if <
                   detail::is_getable<basic_json_t, ValueType>::value
                   && !std::is_same<value_t, ValueType>::value, int >::type = 0 >
    ValueType value(const typename object_t::key_type& key, const ValueType& default_value) const
    {
        // at only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            // if key is found, return value and given default value otherwise
            const auto it = find(key);
            if (it != end())
            {
                return it->template get<ValueType>();
            }

            return default_value;
        }

        JSON_THROW(type_error::create(306, "cannot use value() with " + std::string(type_name())));
    }

    /*!
    @brief overload for a default value of type const char*
    @copydoc basic_json::value(const typename object_t::key_type&, const ValueType&) const
    */
    string_t value(const typename object_t::key_type& key, const char* default_value) const
    {
        return value(key, string_t(default_value));
    }

    /*!
    @brief access specified object element via JSON Pointer with default value

    Returns either a copy of an object's element at the specified key @a key
    or a given default value if no element with key @a key exists.

    The function is basically equivalent to executing
    @code {.cpp}
    try {
        return at(ptr);
    } catch(out_of_range) {
        return default_value;
    }
    @endcode

    @note Unlike @ref at(const json_pointer&), this function does not throw
    if the given key @a key was not found.

    @param[in] ptr  a JSON pointer to the element to access
    @param[in] default_value  the value to return if @a ptr found no value

    @tparam ValueType type compatible to JSON values, for instance `int` for
    JSON integer numbers, `bool` for JSON booleans, or `std::vector` types for
    JSON arrays. Note the type of the expected value at @a key and the default
    value @a default_value must be compatible.

    @return copy of the element at key @a key or @a default_value if @a key
    is not found

    @throw type_error.302 if @a default_value does not match the type of the
    value at @a ptr
    @throw type_error.306 if the JSON value is not an object; in that case,
    using `value()` with a key makes no sense.

    @complexity Logarithmic in the size of the container.

    @liveexample{The example below shows how object elements can be queried
    with a default value.,basic_json__value_ptr}

    @sa @ref operator[](const json_pointer&) for unchecked access by reference

    @since version 2.0.2
    */
    template<class ValueType, typename std::enable_if<
                 detail::is_getable<basic_json_t, ValueType>::value, int>::type = 0>
    ValueType value(const json_pointer& ptr, const ValueType& default_value) const
    {
        // at only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            // if pointer resolves a value, return it or use default value
            JSON_TRY
            {
                return ptr.get_checked(this).template get<ValueType>();
            }
            JSON_INTERNAL_CATCH (out_of_range&)
            {
                return default_value;
            }
        }

        JSON_THROW(type_error::create(306, "cannot use value() with " + std::string(type_name())));
    }

    /*!
    @brief overload for a default value of type const char*
    @copydoc basic_json::value(const json_pointer&, ValueType) const
    */
    JSON_HEDLEY_NON_NULL(3)
    string_t value(const json_pointer& ptr, const char* default_value) const
    {
        return value(ptr, string_t(default_value));
    }

    /*!
    @brief access the first element

    Returns a reference to the first element in the container. For a JSON
    container `c`, the expression `c.front()` is equivalent to `*c.begin()`.

    @return In case of a structured type (array or object), a reference to the
    first element is returned. In case of number, string, boolean, or binary
    values, a reference to the value is returned.

    @complexity Constant.

    @pre The JSON value must not be `null` (would throw `std::out_of_range`)
    or an empty array or object (undefined behavior, **guarded by
    assertions**).
    @post The JSON value remains unchanged.

    @throw invalid_iterator.214 when called on `null` value

    @liveexample{The following code shows an example for `front()`.,front}

    @sa @ref back() -- access the last element

    @since version 1.0.0
    */
    reference front()
    {
        return *begin();
    }

    /*!
    @copydoc basic_json::front()
    */
    const_reference front() const
    {
        return *cbegin();
    }

    /*!
    @brief access the last element

    Returns a reference to the last element in the container. For a JSON
    container `c`, the expression `c.back()` is equivalent to
    @code {.cpp}
    auto tmp = c.end();
    --tmp;
    return *tmp;
    @endcode

    @return In case of a structured type (array or object), a reference to the
    last element is returned. In case of number, string, boolean, or binary
    values, a reference to the value is returned.

    @complexity Constant.

    @pre The JSON value must not be `null` (would throw `std::out_of_range`)
    or an empty array or object (undefined behavior, **guarded by
    assertions**).
    @post The JSON value remains unchanged.

    @throw invalid_iterator.214 when called on a `null` value. See example
    below.

    @liveexample{The following code shows an example for `back()`.,back}

    @sa @ref front() -- access the first element

    @since version 1.0.0
    */
    reference back()
    {
        auto tmp = end();
        --tmp;
        return *tmp;
    }

    /*!
    @copydoc basic_json::back()
    */
    const_reference back() const
    {
        auto tmp = cend();
        --tmp;
        return *tmp;
    }

    /*!
    @brief remove element given an iterator

    Removes the element specified by iterator @a pos. The iterator @a pos must
    be valid and dereferenceable. Thus the `end()` iterator (which is valid,
    but is not dereferenceable) cannot be used as a value for @a pos.

    If called on a primitive type other than `null`, the resulting JSON value
    will be `null`.

    @param[in] pos iterator to the element to remove
    @return Iterator following the last removed element. If the iterator @a
    pos refers to the last element, the `end()` iterator is returned.

    @tparam IteratorType an @ref iterator or @ref const_iterator

    @post Invalidates iterators and references at or after the point of the
    erase, including the `end()` iterator.

    @throw type_error.307 if called on a `null` value; example: `"cannot use
    erase() with null"`
    @throw invalid_iterator.202 if called on an iterator which does not belong
    to the current JSON value; example: `"iterator does not fit current
    value"`
    @throw invalid_iterator.205 if called on a primitive type with invalid
    iterator (i.e., any iterator which is not `begin()`); example: `"iterator
    out of range"`

    @complexity The complexity depends on the type:
    - objects: amortized constant
    - arrays: linear in distance between @a pos and the end of the container
    - strings and binary: linear in the length of the member
    - other types: constant

    @liveexample{The example shows the result of `erase()` for different JSON
    types.,erase__IteratorType}

    @sa @ref erase(IteratorType, IteratorType) -- removes the elements in
    the given range
    @sa @ref erase(const typename object_t::key_type&) -- removes the element
    from an object at the given key
    @sa @ref erase(const size_type) -- removes the element from an array at
    the given index

    @since version 1.0.0
    */
    template < class IteratorType, typename std::enable_if <
                   std::is_same<IteratorType, typename basic_json_t::iterator>::value ||
                   std::is_same<IteratorType, typename basic_json_t::const_iterator>::value, int >::type
               = 0 >
    IteratorType erase(IteratorType pos)
    {
        // make sure iterator fits the current value
        if (JSON_HEDLEY_UNLIKELY(this != pos.m_object))
        {
            JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value"));
        }

        IteratorType result = end();

        switch (m_type)
        {
            case value_t::boolean:
            case value_t::number_float:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::string:
            case value_t::binary:
            {
                if (JSON_HEDLEY_UNLIKELY(!pos.m_it.primitive_iterator.is_begin()))
                {
                    JSON_THROW(invalid_iterator::create(205, "iterator out of range"));
                }

                if (is_string())
                {
                    AllocatorType<string_t> alloc;
                    std::allocator_traits<decltype(alloc)>::destroy(alloc, m_value.string);
                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, m_value.string, 1);
                    m_value.string = nullptr;
                }
                else if (is_binary())
                {
                    AllocatorType<binary_t> alloc;
                    std::allocator_traits<decltype(alloc)>::destroy(alloc, m_value.binary);
                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, m_value.binary, 1);
                    m_value.binary = nullptr;
                }

                m_type = value_t::null;
                assert_invariant();
                break;
            }

            case value_t::object:
            {
                result.m_it.object_iterator = m_value.object->erase(pos.m_it.object_iterator);
                break;
            }

            case value_t::array:
            {
                result.m_it.array_iterator = m_value.array->erase(pos.m_it.array_iterator);
                break;
            }

            default:
                JSON_THROW(type_error::create(307, "cannot use erase() with " + std::string(type_name())));
        }

        return result;
    }

    /*!
    @brief remove elements given an iterator range

    Removes the element specified by the range `[first; last)`. The iterator
    @a first does not need to be dereferenceable if `first == last`: erasing
    an empty range is a no-op.

    If called on a primitive type other than `null`, the resulting JSON value
    will be `null`.

    @param[in] first iterator to the beginning of the range to remove
    @param[in] last iterator past the end of the range to remove
    @return Iterator following the last removed element. If the iterator @a
    second refers to the last element, the `end()` iterator is returned.

    @tparam IteratorType an @ref iterator or @ref const_iterator

    @post Invalidates iterators and references at or after the point of the
    erase, including the `end()` iterator.

    @throw type_error.307 if called on a `null` value; example: `"cannot use
    erase() with null"`
    @throw invalid_iterator.203 if called on iterators which does not belong
    to the current JSON value; example: `"iterators do not fit current value"`
    @throw invalid_iterator.204 if called on a primitive type with invalid
    iterators (i.e., if `first != begin()` and `last != end()`); example:
    `"iterators out of range"`

    @complexity The complexity depends on the type:
    - objects: `log(size()) + std::distance(first, last)`
    - arrays: linear in the distance between @a first and @a last, plus linear
      in the distance between @a last and end of the container
    - strings and binary: linear in the length of the member
    - other types: constant

    @liveexample{The example shows the result of `erase()` for different JSON
    types.,erase__IteratorType_IteratorType}

    @sa @ref erase(IteratorType) -- removes the element at a given position
    @sa @ref erase(const typename object_t::key_type&) -- removes the element
    from an object at the given key
    @sa @ref erase(const size_type) -- removes the element from an array at
    the given index

    @since version 1.0.0
    */
    template < class IteratorType, typename std::enable_if <
                   std::is_same<IteratorType, typename basic_json_t::iterator>::value ||
                   std::is_same<IteratorType, typename basic_json_t::const_iterator>::value, int >::type
               = 0 >
    IteratorType erase(IteratorType first, IteratorType last)
    {
        // make sure iterator fits the current value
        if (JSON_HEDLEY_UNLIKELY(this != first.m_object || this != last.m_object))
        {
            JSON_THROW(invalid_iterator::create(203, "iterators do not fit current value"));
        }

        IteratorType result = end();

        switch (m_type)
        {
            case value_t::boolean:
            case value_t::number_float:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::string:
            case value_t::binary:
            {
                if (JSON_HEDLEY_LIKELY(!first.m_it.primitive_iterator.is_begin()
                                       || !last.m_it.primitive_iterator.is_end()))
                {
                    JSON_THROW(invalid_iterator::create(204, "iterators out of range"));
                }

                if (is_string())
                {
                    AllocatorType<string_t> alloc;
                    std::allocator_traits<decltype(alloc)>::destroy(alloc, m_value.string);
                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, m_value.string, 1);
                    m_value.string = nullptr;
                }
                else if (is_binary())
                {
                    AllocatorType<binary_t> alloc;
                    std::allocator_traits<decltype(alloc)>::destroy(alloc, m_value.binary);
                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, m_value.binary, 1);
                    m_value.binary = nullptr;
                }

                m_type = value_t::null;
                assert_invariant();
                break;
            }

            case value_t::object:
            {
                result.m_it.object_iterator = m_value.object->erase(first.m_it.object_iterator,
                                              last.m_it.object_iterator);
                break;
            }

            case value_t::array:
            {
                result.m_it.array_iterator = m_value.array->erase(first.m_it.array_iterator,
                                             last.m_it.array_iterator);
                break;
            }

            default:
                JSON_THROW(type_error::create(307, "cannot use erase() with " + std::string(type_name())));
        }

        return result;
    }

    /*!
    @brief remove element from a JSON object given a key

    Removes elements from a JSON object with the key value @a key.

    @param[in] key value of the elements to remove

    @return Number of elements removed. If @a ObjectType is the default
    `std::map` type, the return value will always be `0` (@a key was not
    found) or `1` (@a key was found).

    @post References and iterators to the erased elements are invalidated.
    Other references and iterators are not affected.

    @throw type_error.307 when called on a type other than JSON object;
    example: `"cannot use erase() with null"`

    @complexity `log(size()) + count(key)`

    @liveexample{The example shows the effect of `erase()`.,erase__key_type}

    @sa @ref erase(IteratorType) -- removes the element at a given position
    @sa @ref erase(IteratorType, IteratorType) -- removes the elements in
    the given range
    @sa @ref erase(const size_type) -- removes the element from an array at
    the given index

    @since version 1.0.0
    */
    size_type erase(const typename object_t::key_type& key)
    {
        // this erase only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            return m_value.object->erase(key);
        }

        JSON_THROW(type_error::create(307, "cannot use erase() with " + std::string(type_name())));
    }

    /*!
    @brief remove element from a JSON array given an index

    Removes element from a JSON array at the index @a idx.

    @param[in] idx index of the element to remove

    @throw type_error.307 when called on a type other than JSON object;
    example: `"cannot use erase() with null"`
    @throw out_of_range.401 when `idx >= size()`; example: `"array index 17
    is out of range"`

    @complexity Linear in distance between @a idx and the end of the container.

    @liveexample{The example shows the effect of `erase()`.,erase__size_type}

    @sa @ref erase(IteratorType) -- removes the element at a given position
    @sa @ref erase(IteratorType, IteratorType) -- removes the elements in
    the given range
    @sa @ref erase(const typename object_t::key_type&) -- removes the element
    from an object at the given key

    @since version 1.0.0
    */
    void erase(const size_type idx)
    {
        // this erase only works for arrays
        if (JSON_HEDLEY_LIKELY(is_array()))
        {
            if (JSON_HEDLEY_UNLIKELY(idx >= size()))
            {
                JSON_THROW(out_of_range::create(401, "array index " + std::to_string(idx) + " is out of range"));
            }

            m_value.array->erase(m_value.array->begin() + static_cast<difference_type>(idx));
        }
        else
        {
            JSON_THROW(type_error::create(307, "cannot use erase() with " + std::string(type_name())));
        }
    }

    /// @}


    ////////////
    // lookup //
    ////////////

    /// @name lookup
    /// @{

    /*!
    @brief find an element in a JSON object

    Finds an element in a JSON object with key equivalent to @a key. If the
    element is not found or the JSON value is not an object, end() is
    returned.

    @note This method always returns @ref end() when executed on a JSON type
          that is not an object.

    @param[in] key key value of the element to search for.

    @return Iterator to an element with key equivalent to @a key. If no such
    element is found or the JSON value is not an object, past-the-end (see
    @ref end()) iterator is returned.

    @complexity Logarithmic in the size of the JSON object.

    @liveexample{The example shows how `find()` is used.,find__key_type}

    @sa @ref contains(KeyT&&) const -- checks whether a key exists

    @since version 1.0.0
    */
    template<typename KeyT>
    iterator find(KeyT&& key)
    {
        auto result = end();

        if (is_object())
        {
            result.m_it.object_iterator = m_value.object->find(std::forward<KeyT>(key));
        }

        return result;
    }

    /*!
    @brief find an element in a JSON object
    @copydoc find(KeyT&&)
    */
    template<typename KeyT>
    const_iterator find(KeyT&& key) const
    {
        auto result = cend();

        if (is_object())
        {
            result.m_it.object_iterator = m_value.object->find(std::forward<KeyT>(key));
        }

        return result;
    }

    /*!
    @brief returns the number of occurrences of a key in a JSON object

    Returns the number of elements with key @a key. If ObjectType is the
    default `std::map` type, the return value will always be `0` (@a key was
    not found) or `1` (@a key was found).

    @note This method always returns `0` when executed on a JSON type that is
          not an object.

    @param[in] key key value of the element to count

    @return Number of elements with key @a key. If the JSON value is not an
    object, the return value will be `0`.

    @complexity Logarithmic in the size of the JSON object.

    @liveexample{The example shows how `count()` is used.,count}

    @since version 1.0.0
    */
    template<typename KeyT>
    size_type count(KeyT&& key) const
    {
        // return 0 for all nonobject types
        return is_object() ? m_value.object->count(std::forward<KeyT>(key)) : 0;
    }

    /*!
    @brief check the existence of an element in a JSON object

    Check whether an element exists in a JSON object with key equivalent to
    @a key. If the element is not found or the JSON value is not an object,
    false is returned.

    @note This method always returns false when executed on a JSON type
          that is not an object.

    @param[in] key key value to check its existence.

    @return true if an element with specified @a key exists. If no such
    element with such key is found or the JSON value is not an object,
    false is returned.

    @complexity Logarithmic in the size of the JSON object.

    @liveexample{The following code shows an example for `contains()`.,contains}

    @sa @ref find(KeyT&&) -- returns an iterator to an object element
    @sa @ref contains(const json_pointer&) const -- checks the existence for a JSON pointer

    @since version 3.6.0
    */
    template < typename KeyT, typename std::enable_if <
                   !std::is_same<typename std::decay<KeyT>::type, json_pointer>::value, int >::type = 0 >
    bool contains(KeyT && key) const
    {
        return is_object() && m_value.object->find(std::forward<KeyT>(key)) != m_value.object->end();
    }

    /*!
    @brief check the existence of an element in a JSON object given a JSON pointer

    Check whether the given JSON pointer @a ptr can be resolved in the current
    JSON value.

    @note This method can be executed on any JSON value type.

    @param[in] ptr JSON pointer to check its existence.

    @return true if the JSON pointer can be resolved to a stored value, false
    otherwise.

    @post If `j.contains(ptr)` returns true, it is safe to call `j[ptr]`.

    @throw parse_error.106   if an array index begins with '0'
    @throw parse_error.109   if an array index was not a number

    @complexity Logarithmic in the size of the JSON object.

    @liveexample{The following code shows an example for `contains()`.,contains_json_pointer}

    @sa @ref contains(KeyT &&) const -- checks the existence of a key

    @since version 3.7.0
    */
    bool contains(const json_pointer& ptr) const
    {
        return ptr.contains(this);
    }

    /// @}


    ///////////////
    // iterators //
    ///////////////

    /// @name iterators
    /// @{

    /*!
    @brief returns an iterator to the first element

    Returns an iterator to the first element.

    @image html range-begin-end.svg "Illustration from cppreference.com"

    @return iterator to the first element

    @complexity Constant.

    @requirement This function helps `basic_json` satisfying the
    [Container](https://en.cppreference.com/w/cpp/named_req/Container)
    requirements:
    - The complexity is constant.

    @liveexample{The following code shows an example for `begin()`.,begin}

    @sa @ref cbegin() -- returns a const iterator to the beginning
    @sa @ref end() -- returns an iterator to the end
    @sa @ref cend() -- returns a const iterator to the end

    @since version 1.0.0
    */
    iterator begin() noexcept
    {
        iterator result(this);
        result.set_begin();
        return result;
    }

    /*!
    @copydoc basic_json::cbegin()
    */
    const_iterator begin() const noexcept
    {
        return cbegin();
    }

    /*!
    @brief returns a const iterator to the first element

    Returns a const iterator to the first element.

    @image html range-begin-end.svg "Illustration from cppreference.com"

    @return const iterator to the first element

    @complexity Constant.

    @requirement This function helps `basic_json` satisfying the
    [Container](https://en.cppreference.com/w/cpp/named_req/Container)
    requirements:
    - The complexity is constant.
    - Has the semantics of `const_cast<const basic_json&>(*this).begin()`.

    @liveexample{The following code shows an example for `cbegin()`.,cbegin}

    @sa @ref begin() -- returns an iterator to the beginning
    @sa @ref end() -- returns an iterator to the end
    @sa @ref cend() -- returns a const iterator to the end

    @since version 1.0.0
    */
    const_iterator cbegin() const noexcept
    {
        const_iterator result(this);
        result.set_begin();
        return result;
    }

    /*!
    @brief returns an iterator to one past the last element

    Returns an iterator to one past the last element.

    @image html range-begin-end.svg "Illustration from cppreference.com"

    @return iterator one past the last element

    @complexity Constant.

    @requirement This function helps `basic_json` satisfying the
    [Container](https://en.cppreference.com/w/cpp/named_req/Container)
    requirements:
    - The complexity is constant.

    @liveexample{The following code shows an example for `end()`.,end}

    @sa @ref cend() -- returns a const iterator to the end
    @sa @ref begin() -- returns an iterator to the beginning
    @sa @ref cbegin() -- returns a const iterator to the beginning

    @since version 1.0.0
    */
    iterator end() noexcept
    {
        iterator result(this);
        result.set_end();
        return result;
    }

    /*!
    @copydoc basic_json::cend()
    */
    const_iterator end() const noexcept
    {
        return cend();
    }

    /*!
    @brief returns a const iterator to one past the last element

    Returns a const iterator to one past the last element.

    @image html range-begin-end.svg "Illustration from cppreference.com"

    @return const iterator one past the last element

    @complexity Constant.

    @requirement This function helps `basic_json` satisfying the
    [Container](https://en.cppreference.com/w/cpp/named_req/Container)
    requirements:
    - The complexity is constant.
    - Has the semantics of `const_cast<const basic_json&>(*this).end()`.

    @liveexample{The following code shows an example for `cend()`.,cend}

    @sa @ref end() -- returns an iterator to the end
    @sa @ref begin() -- returns an iterator to the beginning
    @sa @ref cbegin() -- returns a const iterator to the beginning

    @since version 1.0.0
    */
    const_iterator cend() const noexcept
    {
        const_iterator result(this);
        result.set_end();
        return result;
    }

    /*!
    @brief returns an iterator to the reverse-beginning

    Returns an iterator to the reverse-beginning; that is, the last element.

    @image html range-rbegin-rend.svg "Illustration from cppreference.com"

    @complexity Constant.

    @requirement This function helps `basic_json` satisfying the
    [ReversibleContainer](https://en.cppreference.com/w/cpp/named_req/ReversibleContainer)
    requirements:
    - The complexity is constant.
    - Has the semantics of `reverse_iterator(end())`.

    @liveexample{The following code shows an example for `rbegin()`.,rbegin}

    @sa @ref crbegin() -- returns a const reverse iterator to the beginning
    @sa @ref rend() -- returns a reverse iterator to the end
    @sa @ref crend() -- returns a const reverse iterator to the end

    @since version 1.0.0
    */
    reverse_iterator rbegin() noexcept
    {
        return reverse_iterator(end());
    }

    /*!
    @copydoc basic_json::crbegin()
    */
    const_reverse_iterator rbegin() const noexcept
    {
        return crbegin();
    }

    /*!
    @brief returns an iterator to the reverse-end

    Returns an iterator to the reverse-end; that is, one before the first
    element.

    @image html range-rbegin-rend.svg "Illustration from cppreference.com"

    @complexity Constant.

    @requirement This function helps `basic_json` satisfying the
    [ReversibleContainer](https://en.cppreference.com/w/cpp/named_req/ReversibleContainer)
    requirements:
    - The complexity is constant.
    - Has the semantics of `reverse_iterator(begin())`.

    @liveexample{The following code shows an example for `rend()`.,rend}

    @sa @ref crend() -- returns a const reverse iterator to the end
    @sa @ref rbegin() -- returns a reverse iterator to the beginning
    @sa @ref crbegin() -- returns a const reverse iterator to the beginning

    @since version 1.0.0
    */
    reverse_iterator rend() noexcept
    {
        return reverse_iterator(begin());
    }

    /*!
    @copydoc basic_json::crend()
    */
    const_reverse_iterator rend() const noexcept
    {
        return crend();
    }

    /*!
    @brief returns a const reverse iterator to the last element

    Returns a const iterator to the reverse-beginning; that is, the last
    element.

    @image html range-rbegin-rend.svg "Illustration from cppreference.com"

    @complexity Constant.

    @requirement This function helps `basic_json` satisfying the
    [ReversibleContainer](https://en.cppreference.com/w/cpp/named_req/ReversibleContainer)
    requirements:
    - The complexity is constant.
    - Has the semantics of `const_cast<const basic_json&>(*this).rbegin()`.

    @liveexample{The following code shows an example for `crbegin()`.,crbegin}

    @sa @ref rbegin() -- returns a reverse iterator to the beginning
    @sa @ref rend() -- returns a reverse iterator to the end
    @sa @ref crend() -- returns a const reverse iterator to the end

    @since version 1.0.0
    */
    const_reverse_iterator crbegin() const noexcept
    {
        return const_reverse_iterator(cend());
    }

    /*!
    @brief returns a const reverse iterator to one before the first

    Returns a const reverse iterator to the reverse-end; that is, one before
    the first element.

    @image html range-rbegin-rend.svg "Illustration from cppreference.com"

    @complexity Constant.

    @requirement This function helps `basic_json` satisfying the
    [ReversibleContainer](https://en.cppreference.com/w/cpp/named_req/ReversibleContainer)
    requirements:
    - The complexity is constant.
    - Has the semantics of `const_cast<const basic_json&>(*this).rend()`.

    @liveexample{The following code shows an example for `crend()`.,crend}

    @sa @ref rend() -- returns a reverse iterator to the end
    @sa @ref rbegin() -- returns a reverse iterator to the beginning
    @sa @ref crbegin() -- returns a const reverse iterator to the beginning

    @since version 1.0.0
    */
    const_reverse_iterator crend() const noexcept
    {
        return const_reverse_iterator(cbegin());
    }

  public:
    /*!
    @brief wrapper to access iterator member functions in range-based for

    This function allows to access @ref iterator::key() and @ref
    iterator::value() during range-based for loops. In these loops, a
    reference to the JSON values is returned, so there is no access to the
    underlying iterator.

    For loop without iterator_wrapper:

    @code{cpp}
    for (auto it = j_object.begin(); it != j_object.end(); ++it)
    {
        std::cout << "key: " << it.key() << ", value:" << it.value() << '\n';
    }
    @endcode

    Range-based for loop without iterator proxy:

    @code{cpp}
    for (auto it : j_object)
    {
        // "it" is of type json::reference and has no key() member
        std::cout << "value: " << it << '\n';
    }
    @endcode

    Range-based for loop with iterator proxy:

    @code{cpp}
    for (auto it : json::iterator_wrapper(j_object))
    {
        std::cout << "key: " << it.key() << ", value:" << it.value() << '\n';
    }
    @endcode

    @note When iterating over an array, `key()` will return the index of the
          element as string (see example).

    @param[in] ref  reference to a JSON value
    @return iteration proxy object wrapping @a ref with an interface to use in
            range-based for loops

    @liveexample{The following code shows how the wrapper is used,iterator_wrapper}

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes in the JSON value.

    @complexity Constant.

    @note The name of this function is not yet final and may change in the
    future.

    @deprecated This stream operator is deprecated and will be removed in
                future 4.0.0 of the library. Please use @ref items() instead;
                that is, replace `json::iterator_wrapper(j)` with `j.items()`.
    */
    JSON_HEDLEY_DEPRECATED_FOR(3.1.0, items())
    static iteration_proxy<iterator> iterator_wrapper(reference ref) noexcept
    {
        return ref.items();
    }

    /*!
    @copydoc iterator_wrapper(reference)
    */
    JSON_HEDLEY_DEPRECATED_FOR(3.1.0, items())
    static iteration_proxy<const_iterator> iterator_wrapper(const_reference ref) noexcept
    {
        return ref.items();
    }

    /*!
    @brief helper to access iterator member functions in range-based for

    This function allows to access @ref iterator::key() and @ref
    iterator::value() during range-based for loops. In these loops, a
    reference to the JSON values is returned, so there is no access to the
    underlying iterator.

    For loop without `items()` function:

    @code{cpp}
    for (auto it = j_object.begin(); it != j_object.end(); ++it)
    {
        std::cout << "key: " << it.key() << ", value:" << it.value() << '\n';
    }
    @endcode

    Range-based for loop without `items()` function:

    @code{cpp}
    for (auto it : j_object)
    {
        // "it" is of type json::reference and has no key() member
        std::cout << "value: " << it << '\n';
    }
    @endcode

    Range-based for loop with `items()` function:

    @code{cpp}
    for (auto& el : j_object.items())
    {
        std::cout << "key: " << el.key() << ", value:" << el.value() << '\n';
    }
    @endcode

    The `items()` function also allows to use
    [structured bindings](https://en.cppreference.com/w/cpp/language/structured_binding)
    (C++17):

    @code{cpp}
    for (auto& [key, val] : j_object.items())
    {
        std::cout << "key: " << key << ", value:" << val << '\n';
    }
    @endcode

    @note When iterating over an array, `key()` will return the index of the
          element as string (see example). For primitive types (e.g., numbers),
          `key()` returns an empty string.

    @warning Using `items()` on temporary objects is dangerous. Make sure the
             object's lifetime exeeds the iteration. See
             <https://github.com/nlohmann/json/issues/2040> for more
             information.

    @return iteration proxy object wrapping @a ref with an interface to use in
            range-based for loops

    @liveexample{The following code shows how the function is used.,items}

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes in the JSON value.

    @complexity Constant.

    @since version 3.1.0, structured bindings support since 3.5.0.
    */
    iteration_proxy<iterator> items() noexcept
    {
        return iteration_proxy<iterator>(*this);
    }

    /*!
    @copydoc items()
    */
    iteration_proxy<const_iterator> items() const noexcept
    {
        return iteration_proxy<const_iterator>(*this);
    }

    /// @}


    //////////////
    // capacity //
    //////////////

    /// @name capacity
    /// @{

    /*!
    @brief checks whether the container is empty.

    Checks if a JSON value has no elements (i.e. whether its @ref size is `0`).

    @return The return value depends on the different types and is
            defined as follows:
            Value type  | return value
            ----------- | -------------
            null        | `true`
            boolean     | `false`
            string      | `false`
            number      | `false`
            binary      | `false`
            object      | result of function `object_t::empty()`
            array       | result of function `array_t::empty()`

    @liveexample{The following code uses `empty()` to check if a JSON
    object contains any elements.,empty}

    @complexity Constant, as long as @ref array_t and @ref object_t satisfy
    the Container concept; that is, their `empty()` functions have constant
    complexity.

    @iterators No changes.

    @exceptionsafety No-throw guarantee: this function never throws exceptions.

    @note This function does not return whether a string stored as JSON value
    is empty - it returns whether the JSON container itself is empty which is
    false in the case of a string.

    @requirement This function helps `basic_json` satisfying the
    [Container](https://en.cppreference.com/w/cpp/named_req/Container)
    requirements:
    - The complexity is constant.
    - Has the semantics of `begin() == end()`.

    @sa @ref size() -- returns the number of elements

    @since version 1.0.0
    */
    bool empty() const noexcept
    {
        switch (m_type)
        {
            case value_t::null:
            {
                // null values are empty
                return true;
            }

            case value_t::array:
            {
                // delegate call to array_t::empty()
                return m_value.array->empty();
            }

            case value_t::object:
            {
                // delegate call to object_t::empty()
                return m_value.object->empty();
            }

            default:
            {
                // all other types are nonempty
                return false;
            }
        }
    }

    /*!
    @brief returns the number of elements

    Returns the number of elements in a JSON value.

    @return The return value depends on the different types and is
            defined as follows:
            Value type  | return value
            ----------- | -------------
            null        | `0`
            boolean     | `1`
            string      | `1`
            number      | `1`
            binary      | `1`
            object      | result of function object_t::size()
            array       | result of function array_t::size()

    @liveexample{The following code calls `size()` on the different value
    types.,size}

    @complexity Constant, as long as @ref array_t and @ref object_t satisfy
    the Container concept; that is, their size() functions have constant
    complexity.

    @iterators No changes.

    @exceptionsafety No-throw guarantee: this function never throws exceptions.

    @note This function does not return the length of a string stored as JSON
    value - it returns the number of elements in the JSON value which is 1 in
    the case of a string.

    @requirement This function helps `basic_json` satisfying the
    [Container](https://en.cppreference.com/w/cpp/named_req/Container)
    requirements:
    - The complexity is constant.
    - Has the semantics of `std::distance(begin(), end())`.

    @sa @ref empty() -- checks whether the container is empty
    @sa @ref max_size() -- returns the maximal number of elements

    @since version 1.0.0
    */
    size_type size() const noexcept
    {
        switch (m_type)
        {
            case value_t::null:
            {
                // null values are empty
                return 0;
            }

            case value_t::array:
            {
                // delegate call to array_t::size()
                return m_value.array->size();
            }

            case value_t::object:
            {
                // delegate call to object_t::size()
                return m_value.object->size();
            }

            default:
            {
                // all other types have size 1
                return 1;
            }
        }
    }

    /*!
    @brief returns the maximum possible number of elements

    Returns the maximum number of elements a JSON value is able to hold due to
    system or library implementation limitations, i.e. `std::distance(begin(),
    end())` for the JSON value.

    @return The return value depends on the different types and is
            defined as follows:
            Value type  | return value
            ----------- | -------------
            null        | `0` (same as `size()`)
            boolean     | `1` (same as `size()`)
            string      | `1` (same as `size()`)
            number      | `1` (same as `size()`)
            binary      | `1` (same as `size()`)
            object      | result of function `object_t::max_size()`
            array       | result of function `array_t::max_size()`

    @liveexample{The following code calls `max_size()` on the different value
    types. Note the output is implementation specific.,max_size}

    @complexity Constant, as long as @ref array_t and @ref object_t satisfy
    the Container concept; that is, their `max_size()` functions have constant
    complexity.

    @iterators No changes.

    @exceptionsafety No-throw guarantee: this function never throws exceptions.

    @requirement This function helps `basic_json` satisfying the
    [Container](https://en.cppreference.com/w/cpp/named_req/Container)
    requirements:
    - The complexity is constant.
    - Has the semantics of returning `b.size()` where `b` is the largest
      possible JSON value.

    @sa @ref size() -- returns the number of elements

    @since version 1.0.0
    */
    size_type max_size() const noexcept
    {
        switch (m_type)
        {
            case value_t::array:
            {
                // delegate call to array_t::max_size()
                return m_value.array->max_size();
            }

            case value_t::object:
            {
                // delegate call to object_t::max_size()
                return m_value.object->max_size();
            }

            default:
            {
                // all other types have max_size() == size()
                return size();
            }
        }
    }

    /// @}


    ///////////////
    // modifiers //
    ///////////////

    /// @name modifiers
    /// @{

    /*!
    @brief clears the contents

    Clears the content of a JSON value and resets it to the default value as
    if @ref basic_json(value_t) would have been called with the current value
    type from @ref type():

    Value type  | initial value
    ----------- | -------------
    null        | `null`
    boolean     | `false`
    string      | `""`
    number      | `0`
    binary      | An empty byte vector
    object      | `{}`
    array       | `[]`

    @post Has the same effect as calling
    @code {.cpp}
    *this = basic_json(type());
    @endcode

    @liveexample{The example below shows the effect of `clear()` to different
    JSON types.,clear}

    @complexity Linear in the size of the JSON value.

    @iterators All iterators, pointers and references related to this container
               are invalidated.

    @exceptionsafety No-throw guarantee: this function never throws exceptions.

    @sa @ref basic_json(value_t) -- constructor that creates an object with the
        same value than calling `clear()`

    @since version 1.0.0
    */
    void clear() noexcept
    {
        switch (m_type)
        {
            case value_t::number_integer:
            {
                m_value.number_integer = 0;
                break;
            }

            case value_t::number_unsigned:
            {
                m_value.number_unsigned = 0;
                break;
            }

            case value_t::number_float:
            {
                m_value.number_float = 0.0;
                break;
            }

            case value_t::boolean:
            {
                m_value.boolean = false;
                break;
            }

            case value_t::string:
            {
                m_value.string->clear();
                break;
            }

            case value_t::binary:
            {
                m_value.binary->clear();
                break;
            }

            case value_t::array:
            {
                m_value.array->clear();
                break;
            }

            case value_t::object:
            {
                m_value.object->clear();
                break;
            }

            default:
                break;
        }
    }

    /*!
    @brief add an object to an array

    Appends the given element @a val to the end of the JSON value. If the
    function is called on a JSON null value, an empty array is created before
    appending @a val.

    @param[in] val the value to add to the JSON array

    @throw type_error.308 when called on a type other than JSON array or
    null; example: `"cannot use push_back() with number"`

    @complexity Amortized constant.

    @liveexample{The example shows how `push_back()` and `+=` can be used to
    add elements to a JSON array. Note how the `null` value was silently
    converted to a JSON array.,push_back}

    @since version 1.0.0
    */
    void push_back(basic_json&& val)
    {
        // push_back only works for null objects or arrays
        if (JSON_HEDLEY_UNLIKELY(!(is_null() || is_array())))
        {
            JSON_THROW(type_error::create(308, "cannot use push_back() with " + std::string(type_name())));
        }

        // transform null object into an array
        if (is_null())
        {
            m_type = value_t::array;
            m_value = value_t::array;
            assert_invariant();
        }

        // add element to array (move semantics)
        m_value.array->push_back(std::move(val));
        // if val is moved from, basic_json move constructor marks it null so we do not call the destructor
    }

    /*!
    @brief add an object to an array
    @copydoc push_back(basic_json&&)
    */
    reference operator+=(basic_json&& val)
    {
        push_back(std::move(val));
        return *this;
    }

    /*!
    @brief add an object to an array
    @copydoc push_back(basic_json&&)
    */
    void push_back(const basic_json& val)
    {
        // push_back only works for null objects or arrays
        if (JSON_HEDLEY_UNLIKELY(!(is_null() || is_array())))
        {
            JSON_THROW(type_error::create(308, "cannot use push_back() with " + std::string(type_name())));
        }

        // transform null object into an array
        if (is_null())
        {
            m_type = value_t::array;
            m_value = value_t::array;
            assert_invariant();
        }

        // add element to array
        m_value.array->push_back(val);
    }

    /*!
    @brief add an object to an array
    @copydoc push_back(basic_json&&)
    */
    reference operator+=(const basic_json& val)
    {
        push_back(val);
        return *this;
    }

    /*!
    @brief add an object to an object

    Inserts the given element @a val to the JSON object. If the function is
    called on a JSON null value, an empty object is created before inserting
    @a val.

    @param[in] val the value to add to the JSON object

    @throw type_error.308 when called on a type other than JSON object or
    null; example: `"cannot use push_back() with number"`

    @complexity Logarithmic in the size of the container, O(log(`size()`)).

    @liveexample{The example shows how `push_back()` and `+=` can be used to
    add elements to a JSON object. Note how the `null` value was silently
    converted to a JSON object.,push_back__object_t__value}

    @since version 1.0.0
    */
    void push_back(const typename object_t::value_type& val)
    {
        // push_back only works for null objects or objects
        if (JSON_HEDLEY_UNLIKELY(!(is_null() || is_object())))
        {
            JSON_THROW(type_error::create(308, "cannot use push_back() with " + std::string(type_name())));
        }

        // transform null object into an object
        if (is_null())
        {
            m_type = value_t::object;
            m_value = value_t::object;
            assert_invariant();
        }

        // add element to array
        m_value.object->insert(val);
    }

    /*!
    @brief add an object to an object
    @copydoc push_back(const typename object_t::value_type&)
    */
    reference operator+=(const typename object_t::value_type& val)
    {
        push_back(val);
        return *this;
    }

    /*!
    @brief add an object to an object

    This function allows to use `push_back` with an initializer list. In case

    1. the current value is an object,
    2. the initializer list @a init contains only two elements, and
    3. the first element of @a init is a string,

    @a init is converted into an object element and added using
    @ref push_back(const typename object_t::value_type&). Otherwise, @a init
    is converted to a JSON value and added using @ref push_back(basic_json&&).

    @param[in] init  an initializer list

    @complexity Linear in the size of the initializer list @a init.

    @note This function is required to resolve an ambiguous overload error,
          because pairs like `{"key", "value"}` can be both interpreted as
          `object_t::value_type` or `std::initializer_list<basic_json>`, see
          https://github.com/nlohmann/json/issues/235 for more information.

    @liveexample{The example shows how initializer lists are treated as
    objects when possible.,push_back__initializer_list}
    */
    void push_back(initializer_list_t init)
    {
        if (is_object() && init.size() == 2 && (*init.begin())->is_string())
        {
            basic_json&& key = init.begin()->moved_or_copied();
            push_back(typename object_t::value_type(
                          std::move(key.get_ref<string_t&>()), (init.begin() + 1)->moved_or_copied()));
        }
        else
        {
            push_back(basic_json(init));
        }
    }

    /*!
    @brief add an object to an object
    @copydoc push_back(initializer_list_t)
    */
    reference operator+=(initializer_list_t init)
    {
        push_back(init);
        return *this;
    }

    /*!
    @brief add an object to an array

    Creates a JSON value from the passed parameters @a args to the end of the
    JSON value. If the function is called on a JSON null value, an empty array
    is created before appending the value created from @a args.

    @param[in] args arguments to forward to a constructor of @ref basic_json
    @tparam Args compatible types to create a @ref basic_json object

    @return reference to the inserted element

    @throw type_error.311 when called on a type other than JSON array or
    null; example: `"cannot use emplace_back() with number"`

    @complexity Amortized constant.

    @liveexample{The example shows how `push_back()` can be used to add
    elements to a JSON array. Note how the `null` value was silently converted
    to a JSON array.,emplace_back}

    @since version 2.0.8, returns reference since 3.7.0
    */
    template<class... Args>
    reference emplace_back(Args&& ... args)
    {
        // emplace_back only works for null objects or arrays
        if (JSON_HEDLEY_UNLIKELY(!(is_null() || is_array())))
        {
            JSON_THROW(type_error::create(311, "cannot use emplace_back() with " + std::string(type_name())));
        }

        // transform null object into an array
        if (is_null())
        {
            m_type = value_t::array;
            m_value = value_t::array;
            assert_invariant();
        }

        // add element to array (perfect forwarding)
#ifdef JSON_HAS_CPP_17
        return m_value.array->emplace_back(std::forward<Args>(args)...);
#else
        m_value.array->emplace_back(std::forward<Args>(args)...);
        return m_value.array->back();
#endif
    }

    /*!
    @brief add an object to an object if key does not exist

    Inserts a new element into a JSON object constructed in-place with the
    given @a args if there is no element with the key in the container. If the
    function is called on a JSON null value, an empty object is created before
    appending the value created from @a args.

    @param[in] args arguments to forward to a constructor of @ref basic_json
    @tparam Args compatible types to create a @ref basic_json object

    @return a pair consisting of an iterator to the inserted element, or the
            already-existing element if no insertion happened, and a bool
            denoting whether the insertion took place.

    @throw type_error.311 when called on a type other than JSON object or
    null; example: `"cannot use emplace() with number"`

    @complexity Logarithmic in the size of the container, O(log(`size()`)).

    @liveexample{The example shows how `emplace()` can be used to add elements
    to a JSON object. Note how the `null` value was silently converted to a
    JSON object. Further note how no value is added if there was already one
    value stored with the same key.,emplace}

    @since version 2.0.8
    */
    template<class... Args>
    std::pair<iterator, bool> emplace(Args&& ... args)
    {
        // emplace only works for null objects or arrays
        if (JSON_HEDLEY_UNLIKELY(!(is_null() || is_object())))
        {
            JSON_THROW(type_error::create(311, "cannot use emplace() with " + std::string(type_name())));
        }

        // transform null object into an object
        if (is_null())
        {
            m_type = value_t::object;
            m_value = value_t::object;
            assert_invariant();
        }

        // add element to array (perfect forwarding)
        auto res = m_value.object->emplace(std::forward<Args>(args)...);
        // create result iterator and set iterator to the result of emplace
        auto it = begin();
        it.m_it.object_iterator = res.first;

        // return pair of iterator and boolean
        return {it, res.second};
    }

    /// Helper for insertion of an iterator
    /// @note: This uses std::distance to support GCC 4.8,
    ///        see https://github.com/nlohmann/json/pull/1257
    template<typename... Args>
    iterator insert_iterator(const_iterator pos, Args&& ... args)
    {
        iterator result(this);
        JSON_ASSERT(m_value.array != nullptr);

        auto insert_pos = std::distance(m_value.array->begin(), pos.m_it.array_iterator);
        m_value.array->insert(pos.m_it.array_iterator, std::forward<Args>(args)...);
        result.m_it.array_iterator = m_value.array->begin() + insert_pos;

        // This could have been written as:
        // result.m_it.array_iterator = m_value.array->insert(pos.m_it.array_iterator, cnt, val);
        // but the return value of insert is missing in GCC 4.8, so it is written this way instead.

        return result;
    }

    /*!
    @brief inserts element

    Inserts element @a val before iterator @a pos.

    @param[in] pos iterator before which the content will be inserted; may be
    the end() iterator
    @param[in] val element to insert
    @return iterator pointing to the inserted @a val.

    @throw type_error.309 if called on JSON values other than arrays;
    example: `"cannot use insert() with string"`
    @throw invalid_iterator.202 if @a pos is not an iterator of *this;
    example: `"iterator does not fit current value"`

    @complexity Constant plus linear in the distance between @a pos and end of
    the container.

    @liveexample{The example shows how `insert()` is used.,insert}

    @since version 1.0.0
    */
    iterator insert(const_iterator pos, const basic_json& val)
    {
        // insert only works for arrays
        if (JSON_HEDLEY_LIKELY(is_array()))
        {
            // check if iterator pos fits to this JSON value
            if (JSON_HEDLEY_UNLIKELY(pos.m_object != this))
            {
                JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value"));
            }

            // insert to array and return iterator
            return insert_iterator(pos, val);
        }

        JSON_THROW(type_error::create(309, "cannot use insert() with " + std::string(type_name())));
    }

    /*!
    @brief inserts element
    @copydoc insert(const_iterator, const basic_json&)
    */
    iterator insert(const_iterator pos, basic_json&& val)
    {
        return insert(pos, val);
    }

    /*!
    @brief inserts elements

    Inserts @a cnt copies of @a val before iterator @a pos.

    @param[in] pos iterator before which the content will be inserted; may be
    the end() iterator
    @param[in] cnt number of copies of @a val to insert
    @param[in] val element to insert
    @return iterator pointing to the first element inserted, or @a pos if
    `cnt==0`

    @throw type_error.309 if called on JSON values other than arrays; example:
    `"cannot use insert() with string"`
    @throw invalid_iterator.202 if @a pos is not an iterator of *this;
    example: `"iterator does not fit current value"`

    @complexity Linear in @a cnt plus linear in the distance between @a pos
    and end of the container.

    @liveexample{The example shows how `insert()` is used.,insert__count}

    @since version 1.0.0
    */
    iterator insert(const_iterator pos, size_type cnt, const basic_json& val)
    {
        // insert only works for arrays
        if (JSON_HEDLEY_LIKELY(is_array()))
        {
            // check if iterator pos fits to this JSON value
            if (JSON_HEDLEY_UNLIKELY(pos.m_object != this))
            {
                JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value"));
            }

            // insert to array and return iterator
            return insert_iterator(pos, cnt, val);
        }

        JSON_THROW(type_error::create(309, "cannot use insert() with " + std::string(type_name())));
    }

    /*!
    @brief inserts elements

    Inserts elements from range `[first, last)` before iterator @a pos.

    @param[in] pos iterator before which the content will be inserted; may be
    the end() iterator
    @param[in] first begin of the range of elements to insert
    @param[in] last end of the range of elements to insert

    @throw type_error.309 if called on JSON values other than arrays; example:
    `"cannot use insert() with string"`
    @throw invalid_iterator.202 if @a pos is not an iterator of *this;
    example: `"iterator does not fit current value"`
    @throw invalid_iterator.210 if @a first and @a last do not belong to the
    same JSON value; example: `"iterators do not fit"`
    @throw invalid_iterator.211 if @a first or @a last are iterators into
    container for which insert is called; example: `"passed iterators may not
    belong to container"`

    @return iterator pointing to the first element inserted, or @a pos if
    `first==last`

    @complexity Linear in `std::distance(first, last)` plus linear in the
    distance between @a pos and end of the container.

    @liveexample{The example shows how `insert()` is used.,insert__range}

    @since version 1.0.0
    */
    iterator insert(const_iterator pos, const_iterator first, const_iterator last)
    {
        // insert only works for arrays
        if (JSON_HEDLEY_UNLIKELY(!is_array()))
        {
            JSON_THROW(type_error::create(309, "cannot use insert() with " + std::string(type_name())));
        }

        // check if iterator pos fits to this JSON value
        if (JSON_HEDLEY_UNLIKELY(pos.m_object != this))
        {
            JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value"));
        }

        // check if range iterators belong to the same JSON object
        if (JSON_HEDLEY_UNLIKELY(first.m_object != last.m_object))
        {
            JSON_THROW(invalid_iterator::create(210, "iterators do not fit"));
        }

        if (JSON_HEDLEY_UNLIKELY(first.m_object == this))
        {
            JSON_THROW(invalid_iterator::create(211, "passed iterators may not belong to container"));
        }

        // insert to array and return iterator
        return insert_iterator(pos, first.m_it.array_iterator, last.m_it.array_iterator);
    }

    /*!
    @brief inserts elements

    Inserts elements from initializer list @a ilist before iterator @a pos.

    @param[in] pos iterator before which the content will be inserted; may be
    the end() iterator
    @param[in] ilist initializer list to insert the values from

    @throw type_error.309 if called on JSON values other than arrays; example:
    `"cannot use insert() with string"`
    @throw invalid_iterator.202 if @a pos is not an iterator of *this;
    example: `"iterator does not fit current value"`

    @return iterator pointing to the first element inserted, or @a pos if
    `ilist` is empty

    @complexity Linear in `ilist.size()` plus linear in the distance between
    @a pos and end of the container.

    @liveexample{The example shows how `insert()` is used.,insert__ilist}

    @since version 1.0.0
    */
    iterator insert(const_iterator pos, initializer_list_t ilist)
    {
        // insert only works for arrays
        if (JSON_HEDLEY_UNLIKELY(!is_array()))
        {
            JSON_THROW(type_error::create(309, "cannot use insert() with " + std::string(type_name())));
        }

        // check if iterator pos fits to this JSON value
        if (JSON_HEDLEY_UNLIKELY(pos.m_object != this))
        {
            JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value"));
        }

        // insert to array and return iterator
        return insert_iterator(pos, ilist.begin(), ilist.end());
    }

    /*!
    @brief inserts elements

    Inserts elements from range `[first, last)`.

    @param[in] first begin of the range of elements to insert
    @param[in] last end of the range of elements to insert

    @throw type_error.309 if called on JSON values other than objects; example:
    `"cannot use insert() with string"`
    @throw invalid_iterator.202 if iterator @a first or @a last does does not
    point to an object; example: `"iterators first and last must point to
    objects"`
    @throw invalid_iterator.210 if @a first and @a last do not belong to the
    same JSON value; example: `"iterators do not fit"`

    @complexity Logarithmic: `O(N*log(size() + N))`, where `N` is the number
    of elements to insert.

    @liveexample{The example shows how `insert()` is used.,insert__range_object}

    @since version 3.0.0
    */
    void insert(const_iterator first, const_iterator last)
    {
        // insert only works for objects
        if (JSON_HEDLEY_UNLIKELY(!is_object()))
        {
            JSON_THROW(type_error::create(309, "cannot use insert() with " + std::string(type_name())));
        }

        // check if range iterators belong to the same JSON object
        if (JSON_HEDLEY_UNLIKELY(first.m_object != last.m_object))
        {
            JSON_THROW(invalid_iterator::create(210, "iterators do not fit"));
        }

        // passed iterators must belong to objects
        if (JSON_HEDLEY_UNLIKELY(!first.m_object->is_object()))
        {
            JSON_THROW(invalid_iterator::create(202, "iterators first and last must point to objects"));
        }

        m_value.object->insert(first.m_it.object_iterator, last.m_it.object_iterator);
    }

    /*!
    @brief updates a JSON object from another object, overwriting existing keys

    Inserts all values from JSON object @a j and overwrites existing keys.

    @param[in] j  JSON object to read values from

    @throw type_error.312 if called on JSON values other than objects; example:
    `"cannot use update() with string"`

    @complexity O(N*log(size() + N)), where N is the number of elements to
                insert.

    @liveexample{The example shows how `update()` is used.,update}

    @sa https://docs.python.org/3.6/library/stdtypes.html#dict.update

    @since version 3.0.0
    */
    void update(const_reference j)
    {
        // implicitly convert null value to an empty object
        if (is_null())
        {
            m_type = value_t::object;
            m_value.object = create<object_t>();
            assert_invariant();
        }

        if (JSON_HEDLEY_UNLIKELY(!is_object()))
        {
            JSON_THROW(type_error::create(312, "cannot use update() with " + std::string(type_name())));
        }
        if (JSON_HEDLEY_UNLIKELY(!j.is_object()))
        {
            JSON_THROW(type_error::create(312, "cannot use update() with " + std::string(j.type_name())));
        }

        for (auto it = j.cbegin(); it != j.cend(); ++it)
        {
            m_value.object->operator[](it.key()) = it.value();
        }
    }

    /*!
    @brief updates a JSON object from another object, overwriting existing keys

    Inserts all values from from range `[first, last)` and overwrites existing
    keys.

    @param[in] first begin of the range of elements to insert
    @param[in] last end of the range of elements to insert

    @throw type_error.312 if called on JSON values other than objects; example:
    `"cannot use update() with string"`
    @throw invalid_iterator.202 if iterator @a first or @a last does does not
    point to an object; example: `"iterators first and last must point to
    objects"`
    @throw invalid_iterator.210 if @a first and @a last do not belong to the
    same JSON value; example: `"iterators do not fit"`

    @complexity O(N*log(size() + N)), where N is the number of elements to
                insert.

    @liveexample{The example shows how `update()` is used__range.,update}

    @sa https://docs.python.org/3.6/library/stdtypes.html#dict.update

    @since version 3.0.0
    */
    void update(const_iterator first, const_iterator last)
    {
        // implicitly convert null value to an empty object
        if (is_null())
        {
            m_type = value_t::object;
            m_value.object = create<object_t>();
            assert_invariant();
        }

        if (JSON_HEDLEY_UNLIKELY(!is_object()))
        {
            JSON_THROW(type_error::create(312, "cannot use update() with " + std::string(type_name())));
        }

        // check if range iterators belong to the same JSON object
        if (JSON_HEDLEY_UNLIKELY(first.m_object != last.m_object))
        {
            JSON_THROW(invalid_iterator::create(210, "iterators do not fit"));
        }

        // passed iterators must belong to objects
        if (JSON_HEDLEY_UNLIKELY(!first.m_object->is_object()
                                 || !last.m_object->is_object()))
        {
            JSON_THROW(invalid_iterator::create(202, "iterators first and last must point to objects"));
        }

        for (auto it = first; it != last; ++it)
        {
            m_value.object->operator[](it.key()) = it.value();
        }
    }

    /*!
    @brief exchanges the values

    Exchanges the contents of the JSON value with those of @a other. Does not
    invoke any move, copy, or swap operations on individual elements. All
    iterators and references remain valid. The past-the-end iterator is
    invalidated.

    @param[in,out] other JSON value to exchange the contents with

    @complexity Constant.

    @liveexample{The example below shows how JSON values can be swapped with
    `swap()`.,swap__reference}

    @since version 1.0.0
    */
    void swap(reference other) noexcept (
        std::is_nothrow_move_constructible<value_t>::value&&
        std::is_nothrow_move_assignable<value_t>::value&&
        std::is_nothrow_move_constructible<json_value>::value&&
        std::is_nothrow_move_assignable<json_value>::value
    )
    {
        std::swap(m_type, other.m_type);
        std::swap(m_value, other.m_value);
        assert_invariant();
    }

    /*!
    @brief exchanges the values

    Exchanges the contents of the JSON value from @a left with those of @a right. Does not
    invoke any move, copy, or swap operations on individual elements. All
    iterators and references remain valid. The past-the-end iterator is
    invalidated. implemented as a friend function callable via ADL.

    @param[in,out] left JSON value to exchange the contents with
    @param[in,out] right JSON value to exchange the contents with

    @complexity Constant.

    @liveexample{The example below shows how JSON values can be swapped with
    `swap()`.,swap__reference}

    @since version 1.0.0
    */
    friend void swap(reference left, reference right) noexcept (
        std::is_nothrow_move_constructible<value_t>::value&&
        std::is_nothrow_move_assignable<value_t>::value&&
        std::is_nothrow_move_constructible<json_value>::value&&
        std::is_nothrow_move_assignable<json_value>::value
    )
    {
        left.swap(right);
    }

    /*!
    @brief exchanges the values

    Exchanges the contents of a JSON array with those of @a other. Does not
    invoke any move, copy, or swap operations on individual elements. All
    iterators and references remain valid. The past-the-end iterator is
    invalidated.

    @param[in,out] other array to exchange the contents with

    @throw type_error.310 when JSON value is not an array; example: `"cannot
    use swap() with string"`

    @complexity Constant.

    @liveexample{The example below shows how arrays can be swapped with
    `swap()`.,swap__array_t}

    @since version 1.0.0
    */
    void swap(array_t& other)
    {
        // swap only works for arrays
        if (JSON_HEDLEY_LIKELY(is_array()))
        {
            std::swap(*(m_value.array), other);
        }
        else
        {
            JSON_THROW(type_error::create(310, "cannot use swap() with " + std::string(type_name())));
        }
    }

    /*!
    @brief exchanges the values

    Exchanges the contents of a JSON object with those of @a other. Does not
    invoke any move, copy, or swap operations on individual elements. All
    iterators and references remain valid. The past-the-end iterator is
    invalidated.

    @param[in,out] other object to exchange the contents with

    @throw type_error.310 when JSON value is not an object; example:
    `"cannot use swap() with string"`

    @complexity Constant.

    @liveexample{The example below shows how objects can be swapped with
    `swap()`.,swap__object_t}

    @since version 1.0.0
    */
    void swap(object_t& other)
    {
        // swap only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            std::swap(*(m_value.object), other);
        }
        else
        {
            JSON_THROW(type_error::create(310, "cannot use swap() with " + std::string(type_name())));
        }
    }

    /*!
    @brief exchanges the values

    Exchanges the contents of a JSON string with those of @a other. Does not
    invoke any move, copy, or swap operations on individual elements. All
    iterators and references remain valid. The past-the-end iterator is
    invalidated.

    @param[in,out] other string to exchange the contents with

    @throw type_error.310 when JSON value is not a string; example: `"cannot
    use swap() with boolean"`

    @complexity Constant.

    @liveexample{The example below shows how strings can be swapped with
    `swap()`.,swap__string_t}

    @since version 1.0.0
    */
    void swap(string_t& other)
    {
        // swap only works for strings
        if (JSON_HEDLEY_LIKELY(is_string()))
        {
            std::swap(*(m_value.string), other);
        }
        else
        {
            JSON_THROW(type_error::create(310, "cannot use swap() with " + std::string(type_name())));
        }
    }

    /*!
    @brief exchanges the values

    Exchanges the contents of a JSON string with those of @a other. Does not
    invoke any move, copy, or swap operations on individual elements. All
    iterators and references remain valid. The past-the-end iterator is
    invalidated.

    @param[in,out] other binary to exchange the contents with

    @throw type_error.310 when JSON value is not a string; example: `"cannot
    use swap() with boolean"`

    @complexity Constant.

    @liveexample{The example below shows how strings can be swapped with
    `swap()`.,swap__binary_t}

    @since version 3.8.0
    */
    void swap(binary_t& other)
    {
        // swap only works for strings
        if (JSON_HEDLEY_LIKELY(is_binary()))
        {
            std::swap(*(m_value.binary), other);
        }
        else
        {
            JSON_THROW(type_error::create(310, "cannot use swap() with " + std::string(type_name())));
        }
    }

    /// @copydoc swap(binary_t)
    void swap(typename binary_t::container_type& other)
    {
        // swap only works for strings
        if (JSON_HEDLEY_LIKELY(is_binary()))
        {
            std::swap(*(m_value.binary), other);
        }
        else
        {
            JSON_THROW(type_error::create(310, "cannot use swap() with " + std::string(type_name())));
        }
    }

    /// @}

  public:
    //////////////////////////////////////////
    // lexicographical comparison operators //
    //////////////////////////////////////////

    /// @name lexicographical comparison operators
    /// @{

    /*!
    @brief comparison: equal

    Compares two JSON values for equality according to the following rules:
    - Two JSON values are equal if (1) they are from the same type and (2)
      their stored values are the same according to their respective
      `operator==`.
    - Integer and floating-point numbers are automatically converted before
      comparison. Note that two NaN values are always treated as unequal.
    - Two JSON null values are equal.

    @note Floating-point inside JSON values numbers are compared with
    `json::number_float_t::operator==` which is `double::operator==` by
    default. To compare floating-point while respecting an epsilon, an alternative
    [comparison function](https://github.com/mariokonrad/marnav/blob/master/include/marnav/math/floatingpoint.hpp#L34-#L39)
    could be used, for instance
    @code {.cpp}
    template<typename T, typename = typename std::enable_if<std::is_floating_point<T>::value, T>::type>
    inline bool is_same(T a, T b, T epsilon = std::numeric_limits<T>::epsilon()) noexcept
    {
        return std::abs(a - b) <= epsilon;
    }
    @endcode
    Or you can self-defined operator equal function like this:
    @code {.cpp}
    bool my_equal(const_reference lhs, const_reference rhs) {
    const auto lhs_type lhs.type();
    const auto rhs_type rhs.type();
    if (lhs_type == rhs_type) {
        switch(lhs_type)
            // self_defined case
            case value_t::number_float:
                return std::abs(lhs - rhs) <= std::numeric_limits<float>::epsilon();
            // other cases remain the same with the original
            ...
    }
    ...
    }
    @endcode

    @note NaN values never compare equal to themselves or to other NaN values.

    @param[in] lhs  first JSON value to consider
    @param[in] rhs  second JSON value to consider
    @return whether the values @a lhs and @a rhs are equal

    @exceptionsafety No-throw guarantee: this function never throws exceptions.

    @complexity Linear.

    @liveexample{The example demonstrates comparing several JSON
    types.,operator__equal}

    @since version 1.0.0
    */
    friend bool operator==(const_reference lhs, const_reference rhs) noexcept
    {
        const auto lhs_type = lhs.type();
        const auto rhs_type = rhs.type();

        if (lhs_type == rhs_type)
        {
            switch (lhs_type)
            {
                case value_t::array:
                    return *lhs.m_value.array == *rhs.m_value.array;

                case value_t::object:
                    return *lhs.m_value.object == *rhs.m_value.object;

                case value_t::null:
                    return true;

                case value_t::string:
                    return *lhs.m_value.string == *rhs.m_value.string;

                case value_t::boolean:
                    return lhs.m_value.boolean == rhs.m_value.boolean;

                case value_t::number_integer:
                    return lhs.m_value.number_integer == rhs.m_value.number_integer;

                case value_t::number_unsigned:
                    return lhs.m_value.number_unsigned == rhs.m_value.number_unsigned;

                case value_t::number_float:
                    return lhs.m_value.number_float == rhs.m_value.number_float;

                case value_t::binary:
                    return *lhs.m_value.binary == *rhs.m_value.binary;

                default:
                    return false;
            }
        }
        else if (lhs_type == value_t::number_integer && rhs_type == value_t::number_float)
        {
            return static_cast<number_float_t>(lhs.m_value.number_integer) == rhs.m_value.number_float;
        }
        else if (lhs_type == value_t::number_float && rhs_type == value_t::number_integer)
        {
            return lhs.m_value.number_float == static_cast<number_float_t>(rhs.m_value.number_integer);
        }
        else if (lhs_type == value_t::number_unsigned && rhs_type == value_t::number_float)
        {
            return static_cast<number_float_t>(lhs.m_value.number_unsigned) == rhs.m_value.number_float;
        }
        else if (lhs_type == value_t::number_float && rhs_type == value_t::number_unsigned)
        {
            return lhs.m_value.number_float == static_cast<number_float_t>(rhs.m_value.number_unsigned);
        }
        else if (lhs_type == value_t::number_unsigned && rhs_type == value_t::number_integer)
        {
            return static_cast<number_integer_t>(lhs.m_value.number_unsigned) == rhs.m_value.number_integer;
        }
        else if (lhs_type == value_t::number_integer && rhs_type == value_t::number_unsigned)
        {
            return lhs.m_value.number_integer == static_cast<number_integer_t>(rhs.m_value.number_unsigned);
        }

        return false;
    }

    /*!
    @brief comparison: equal
    @copydoc operator==(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator==(const_reference lhs, const ScalarType rhs) noexcept
    {
        return lhs == basic_json(rhs);
    }

    /*!
    @brief comparison: equal
    @copydoc operator==(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator==(const ScalarType lhs, const_reference rhs) noexcept
    {
        return basic_json(lhs) == rhs;
    }

    /*!
    @brief comparison: not equal

    Compares two JSON values for inequality by calculating `not (lhs == rhs)`.

    @param[in] lhs  first JSON value to consider
    @param[in] rhs  second JSON value to consider
    @return whether the values @a lhs and @a rhs are not equal

    @complexity Linear.

    @exceptionsafety No-throw guarantee: this function never throws exceptions.

    @liveexample{The example demonstrates comparing several JSON
    types.,operator__notequal}

    @since version 1.0.0
    */
    friend bool operator!=(const_reference lhs, const_reference rhs) noexcept
    {
        return !(lhs == rhs);
    }

    /*!
    @brief comparison: not equal
    @copydoc operator!=(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator!=(const_reference lhs, const ScalarType rhs) noexcept
    {
        return lhs != basic_json(rhs);
    }

    /*!
    @brief comparison: not equal
    @copydoc operator!=(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator!=(const ScalarType lhs, const_reference rhs) noexcept
    {
        return basic_json(lhs) != rhs;
    }

    /*!
    @brief comparison: less than

    Compares whether one JSON value @a lhs is less than another JSON value @a
    rhs according to the following rules:
    - If @a lhs and @a rhs have the same type, the values are compared using
      the default `<` operator.
    - Integer and floating-point numbers are automatically converted before
      comparison
    - In case @a lhs and @a rhs have different types, the values are ignored
      and the order of the types is considered, see
      @ref operator<(const value_t, const value_t).

    @param[in] lhs  first JSON value to consider
    @param[in] rhs  second JSON value to consider
    @return whether @a lhs is less than @a rhs

    @complexity Linear.

    @exceptionsafety No-throw guarantee: this function never throws exceptions.

    @liveexample{The example demonstrates comparing several JSON
    types.,operator__less}

    @since version 1.0.0
    */
    friend bool operator<(const_reference lhs, const_reference rhs) noexcept
    {
        const auto lhs_type = lhs.type();
        const auto rhs_type = rhs.type();

        if (lhs_type == rhs_type)
        {
            switch (lhs_type)
            {
                case value_t::array:
                    // note parentheses are necessary, see
                    // https://github.com/nlohmann/json/issues/1530
                    return (*lhs.m_value.array) < (*rhs.m_value.array);

                case value_t::object:
                    return (*lhs.m_value.object) < (*rhs.m_value.object);

                case value_t::null:
                    return false;

                case value_t::string:
                    return (*lhs.m_value.string) < (*rhs.m_value.string);

                case value_t::boolean:
                    return (lhs.m_value.boolean) < (rhs.m_value.boolean);

                case value_t::number_integer:
                    return (lhs.m_value.number_integer) < (rhs.m_value.number_integer);

                case value_t::number_unsigned:
                    return (lhs.m_value.number_unsigned) < (rhs.m_value.number_unsigned);

                case value_t::number_float:
                    return (lhs.m_value.number_float) < (rhs.m_value.number_float);

                case value_t::binary:
                    return (*lhs.m_value.binary) < (*rhs.m_value.binary);

                default:
                    return false;
            }
        }
        else if (lhs_type == value_t::number_integer && rhs_type == value_t::number_float)
        {
            return static_cast<number_float_t>(lhs.m_value.number_integer) < rhs.m_value.number_float;
        }
        else if (lhs_type == value_t::number_float && rhs_type == value_t::number_integer)
        {
            return lhs.m_value.number_float < static_cast<number_float_t>(rhs.m_value.number_integer);
        }
        else if (lhs_type == value_t::number_unsigned && rhs_type == value_t::number_float)
        {
            return static_cast<number_float_t>(lhs.m_value.number_unsigned) < rhs.m_value.number_float;
        }
        else if (lhs_type == value_t::number_float && rhs_type == value_t::number_unsigned)
        {
            return lhs.m_value.number_float < static_cast<number_float_t>(rhs.m_value.number_unsigned);
        }
        else if (lhs_type == value_t::number_integer && rhs_type == value_t::number_unsigned)
        {
            return lhs.m_value.number_integer < static_cast<number_integer_t>(rhs.m_value.number_unsigned);
        }
        else if (lhs_type == value_t::number_unsigned && rhs_type == value_t::number_integer)
        {
            return static_cast<number_integer_t>(lhs.m_value.number_unsigned) < rhs.m_value.number_integer;
        }

        // We only reach this line if we cannot compare values. In that case,
        // we compare types. Note we have to call the operator explicitly,
        // because MSVC has problems otherwise.
        return operator<(lhs_type, rhs_type);
    }

    /*!
    @brief comparison: less than
    @copydoc operator<(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator<(const_reference lhs, const ScalarType rhs) noexcept
    {
        return lhs < basic_json(rhs);
    }

    /*!
    @brief comparison: less than
    @copydoc operator<(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator<(const ScalarType lhs, const_reference rhs) noexcept
    {
        return basic_json(lhs) < rhs;
    }

    /*!
    @brief comparison: less than or equal

    Compares whether one JSON value @a lhs is less than or equal to another
    JSON value by calculating `not (rhs < lhs)`.

    @param[in] lhs  first JSON value to consider
    @param[in] rhs  second JSON value to consider
    @return whether @a lhs is less than or equal to @a rhs

    @complexity Linear.

    @exceptionsafety No-throw guarantee: this function never throws exceptions.

    @liveexample{The example demonstrates comparing several JSON
    types.,operator__greater}

    @since version 1.0.0
    */
    friend bool operator<=(const_reference lhs, const_reference rhs) noexcept
    {
        return !(rhs < lhs);
    }

    /*!
    @brief comparison: less than or equal
    @copydoc operator<=(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator<=(const_reference lhs, const ScalarType rhs) noexcept
    {
        return lhs <= basic_json(rhs);
    }

    /*!
    @brief comparison: less than or equal
    @copydoc operator<=(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator<=(const ScalarType lhs, const_reference rhs) noexcept
    {
        return basic_json(lhs) <= rhs;
    }

    /*!
    @brief comparison: greater than

    Compares whether one JSON value @a lhs is greater than another
    JSON value by calculating `not (lhs <= rhs)`.

    @param[in] lhs  first JSON value to consider
    @param[in] rhs  second JSON value to consider
    @return whether @a lhs is greater than to @a rhs

    @complexity Linear.

    @exceptionsafety No-throw guarantee: this function never throws exceptions.

    @liveexample{The example demonstrates comparing several JSON
    types.,operator__lessequal}

    @since version 1.0.0
    */
    friend bool operator>(const_reference lhs, const_reference rhs) noexcept
    {
        return !(lhs <= rhs);
    }

    /*!
    @brief comparison: greater than
    @copydoc operator>(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator>(const_reference lhs, const ScalarType rhs) noexcept
    {
        return lhs > basic_json(rhs);
    }

    /*!
    @brief comparison: greater than
    @copydoc operator>(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator>(const ScalarType lhs, const_reference rhs) noexcept
    {
        return basic_json(lhs) > rhs;
    }

    /*!
    @brief comparison: greater than or equal

    Compares whether one JSON value @a lhs is greater than or equal to another
    JSON value by calculating `not (lhs < rhs)`.

    @param[in] lhs  first JSON value to consider
    @param[in] rhs  second JSON value to consider
    @return whether @a lhs is greater than or equal to @a rhs

    @complexity Linear.

    @exceptionsafety No-throw guarantee: this function never throws exceptions.

    @liveexample{The example demonstrates comparing several JSON
    types.,operator__greaterequal}

    @since version 1.0.0
    */
    friend bool operator>=(const_reference lhs, const_reference rhs) noexcept
    {
        return !(lhs < rhs);
    }

    /*!
    @brief comparison: greater than or equal
    @copydoc operator>=(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator>=(const_reference lhs, const ScalarType rhs) noexcept
    {
        return lhs >= basic_json(rhs);
    }

    /*!
    @brief comparison: greater than or equal
    @copydoc operator>=(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator>=(const ScalarType lhs, const_reference rhs) noexcept
    {
        return basic_json(lhs) >= rhs;
    }

    /// @}

    ///////////////////
    // serialization //
    ///////////////////

    /// @name serialization
    /// @{

    /*!
    @brief serialize to stream

    Serialize the given JSON value @a j to the output stream @a o. The JSON
    value will be serialized using the @ref dump member function.

    - The indentation of the output can be controlled with the member variable
      `width` of the output stream @a o. For instance, using the manipulator
      `std::setw(4)` on @a o sets the indentation level to `4` and the
      serialization result is the same as calling `dump(4)`.

    - The indentation character can be controlled with the member variable
      `fill` of the output stream @a o. For instance, the manipulator
      `std::setfill('\\t')` sets indentation to use a tab character rather than
      the default space character.

    @param[in,out] o  stream to serialize to
    @param[in] j  JSON value to serialize

    @return the stream @a o

    @throw type_error.316 if a string stored inside the JSON value is not
                          UTF-8 encoded

    @complexity Linear.

    @liveexample{The example below shows the serialization with different
    parameters to `width` to adjust the indentation level.,operator_serialize}

    @since version 1.0.0; indentation character added in version 3.0.0
    */
    friend std::ostream& operator<<(std::ostream& o, const basic_json& j)
    {
        // read width member and use it as indentation parameter if nonzero
        const bool pretty_print = o.width() > 0;
        const auto indentation = pretty_print ? o.width() : 0;

        // reset width to 0 for subsequent calls to this stream
        o.width(0);

        // do the actual serialization
        serializer s(detail::output_adapter<char>(o), o.fill());
        s.dump(j, pretty_print, false, static_cast<unsigned int>(indentation));
        return o;
    }

    /*!
    @brief serialize to stream
    @deprecated This stream operator is deprecated and will be removed in
                future 4.0.0 of the library. Please use
                @ref operator<<(std::ostream&, const basic_json&)
                instead; that is, replace calls like `j >> o;` with `o << j;`.
    @since version 1.0.0; deprecated since version 3.0.0
    */
    JSON_HEDLEY_DEPRECATED_FOR(3.0.0, operator<<(std::ostream&, const basic_json&))
    friend std::ostream& operator>>(const basic_json& j, std::ostream& o)
    {
        return o << j;
    }

    /// @}


    /////////////////////
    // deserialization //
    /////////////////////

    /// @name deserialization
    /// @{

    /*!
    @brief deserialize from a compatible input

    @tparam InputType A compatible input, for instance
    - an std::istream object
    - a FILE pointer
    - a C-style array of characters
    - a pointer to a null-terminated string of single byte characters
    - an object obj for which begin(obj) and end(obj) produces a valid pair of
      iterators.

    @param[in] i  input to read from
    @param[in] cb  a parser callback function of type @ref parser_callback_t
    which is used to control the deserialization by filtering unwanted values
    (optional)
    @param[in] allow_exceptions  whether to throw exceptions in case of a
    parse error (optional, true by default)
    @param[in] ignore_comments  whether comments should be ignored and treated
    like whitespace (true) or yield a parse error (true); (optional, false by
    default)

    @return deserialized JSON value; in case of a parse error and
            @a allow_exceptions set to `false`, the return value will be
            value_t::discarded.

    @throw parse_error.101 if a parse error occurs; example: `""unexpected end
    of input; expected string literal""`
    @throw parse_error.102 if to_unicode fails or surrogate error
    @throw parse_error.103 if to_unicode fails

    @complexity Linear in the length of the input. The parser is a predictive
    LL(1) parser. The complexity can be higher if the parser callback function
    @a cb or reading from the input @a i has a super-linear complexity.

    @note A UTF-8 byte order mark is silently ignored.

    @liveexample{The example below demonstrates the `parse()` function reading
    from an array.,parse__array__parser_callback_t}

    @liveexample{The example below demonstrates the `parse()` function with
    and without callback function.,parse__string__parser_callback_t}

    @liveexample{The example below demonstrates the `parse()` function with
    and without callback function.,parse__istream__parser_callback_t}

    @liveexample{The example below demonstrates the `parse()` function reading
    from a contiguous container.,parse__contiguouscontainer__parser_callback_t}

    @since version 2.0.3 (contiguous containers); version 3.9.0 allowed to
    ignore comments.
    */
    template<typename InputType>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json parse(InputType&& i,
                            const parser_callback_t cb = nullptr,
                            const bool allow_exceptions = true,
                            const bool ignore_comments = false)
    {
        basic_json result;
        parser(detail::input_adapter(std::forward<InputType>(i)), cb, allow_exceptions, ignore_comments).parse(true, result);
        return result;
    }

    /*!
    @brief deserialize from a pair of character iterators

    The value_type of the iterator must be a integral type with size of 1, 2 or
    4 bytes, which will be interpreted respectively as UTF-8, UTF-16 and UTF-32.

    @param[in] first iterator to start of character range
    @param[in] last  iterator to end of character range
    @param[in] cb  a parser callback function of type @ref parser_callback_t
    which is used to control the deserialization by filtering unwanted values
    (optional)
    @param[in] allow_exceptions  whether to throw exceptions in case of a
    parse error (optional, true by default)
    @param[in] ignore_comments  whether comments should be ignored and treated
    like whitespace (true) or yield a parse error (true); (optional, false by
    default)

    @return deserialized JSON value; in case of a parse error and
            @a allow_exceptions set to `false`, the return value will be
            value_t::discarded.

    @throw parse_error.101 if a parse error occurs; example: `""unexpected end
    of input; expected string literal""`
    @throw parse_error.102 if to_unicode fails or surrogate error
    @throw parse_error.103 if to_unicode fails
    */
    template<typename IteratorType>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json parse(IteratorType first,
                            IteratorType last,
                            const parser_callback_t cb = nullptr,
                            const bool allow_exceptions = true,
                            const bool ignore_comments = false)
    {
        basic_json result;
        parser(detail::input_adapter(std::move(first), std::move(last)), cb, allow_exceptions, ignore_comments).parse(true, result);
        return result;
    }

    JSON_HEDLEY_WARN_UNUSED_RESULT
    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, parse(ptr, ptr + len))
    static basic_json parse(detail::span_input_adapter&& i,
                            const parser_callback_t cb = nullptr,
                            const bool allow_exceptions = true,
                            const bool ignore_comments = false)
    {
        basic_json result;
        parser(i.get(), cb, allow_exceptions, ignore_comments).parse(true, result);
        return result;
    }

    /*!
    @brief check if the input is valid JSON

    Unlike the @ref parse(InputType&&, const parser_callback_t,const bool)
    function, this function neither throws an exception in case of invalid JSON
    input (i.e., a parse error) nor creates diagnostic information.

    @tparam InputType A compatible input, for instance
    - an std::istream object
    - a FILE pointer
    - a C-style array of characters
    - a pointer to a null-terminated string of single byte characters
    - an object obj for which begin(obj) and end(obj) produces a valid pair of
      iterators.

    @param[in] i input to read from
    @param[in] ignore_comments  whether comments should be ignored and treated
    like whitespace (true) or yield a parse error (true); (optional, false by
    default)

    @return Whether the input read from @a i is valid JSON.

    @complexity Linear in the length of the input. The parser is a predictive
    LL(1) parser.

    @note A UTF-8 byte order mark is silently ignored.

    @liveexample{The example below demonstrates the `accept()` function reading
    from a string.,accept__string}
    */
    template<typename InputType>
    static bool accept(InputType&& i,
                       const bool ignore_comments = false)
    {
        return parser(detail::input_adapter(std::forward<InputType>(i)), nullptr, false, ignore_comments).accept(true);
    }

    template<typename IteratorType>
    static bool accept(IteratorType first, IteratorType last,
                       const bool ignore_comments = false)
    {
        return parser(detail::input_adapter(std::move(first), std::move(last)), nullptr, false, ignore_comments).accept(true);
    }

    JSON_HEDLEY_WARN_UNUSED_RESULT
    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, accept(ptr, ptr + len))
    static bool accept(detail::span_input_adapter&& i,
                       const bool ignore_comments = false)
    {
        return parser(i.get(), nullptr, false, ignore_comments).accept(true);
    }

    /*!
    @brief generate SAX events

    The SAX event lister must follow the interface of @ref json_sax.

    This function reads from a compatible input. Examples are:
    - an std::istream object
    - a FILE pointer
    - a C-style array of characters
    - a pointer to a null-terminated string of single byte characters
    - an object obj for which begin(obj) and end(obj) produces a valid pair of
      iterators.

    @param[in] i  input to read from
    @param[in,out] sax  SAX event listener
    @param[in] format  the format to parse (JSON, CBOR, MessagePack, or UBJSON)
    @param[in] strict  whether the input has to be consumed completely
    @param[in] ignore_comments  whether comments should be ignored and treated
    like whitespace (true) or yield a parse error (true); (optional, false by
    default); only applies to the JSON file format.

    @return return value of the last processed SAX event

    @throw parse_error.101 if a parse error occurs; example: `""unexpected end
    of input; expected string literal""`
    @throw parse_error.102 if to_unicode fails or surrogate error
    @throw parse_error.103 if to_unicode fails

    @complexity Linear in the length of the input. The parser is a predictive
    LL(1) parser. The complexity can be higher if the SAX consumer @a sax has
    a super-linear complexity.

    @note A UTF-8 byte order mark is silently ignored.

    @liveexample{The example below demonstrates the `sax_parse()` function
    reading from string and processing the events with a user-defined SAX
    event consumer.,sax_parse}

    @since version 3.2.0
    */
    template <typename InputType, typename SAX>
    JSON_HEDLEY_NON_NULL(2)
    static bool sax_parse(InputType&& i, SAX* sax,
                          input_format_t format = input_format_t::json,
                          const bool strict = true,
                          const bool ignore_comments = false)
    {
        auto ia = detail::input_adapter(std::forward<InputType>(i));
        return format == input_format_t::json
               ? parser(std::move(ia), nullptr, true, ignore_comments).sax_parse(sax, strict)
               : detail::binary_reader<basic_json, decltype(ia), SAX>(std::move(ia)).sax_parse(format, sax, strict);
    }

    template<class IteratorType, class SAX>
    JSON_HEDLEY_NON_NULL(3)
    static bool sax_parse(IteratorType first, IteratorType last, SAX* sax,
                          input_format_t format = input_format_t::json,
                          const bool strict = true,
                          const bool ignore_comments = false)
    {
        auto ia = detail::input_adapter(std::move(first), std::move(last));
        return format == input_format_t::json
               ? parser(std::move(ia), nullptr, true, ignore_comments).sax_parse(sax, strict)
               : detail::binary_reader<basic_json, decltype(ia), SAX>(std::move(ia)).sax_parse(format, sax, strict);
    }

    template <typename SAX>
    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, sax_parse(ptr, ptr + len, ...))
    JSON_HEDLEY_NON_NULL(2)
    static bool sax_parse(detail::span_input_adapter&& i, SAX* sax,
                          input_format_t format = input_format_t::json,
                          const bool strict = true,
                          const bool ignore_comments = false)
    {
        auto ia = i.get();
        return format == input_format_t::json
               ? parser(std::move(ia), nullptr, true, ignore_comments).sax_parse(sax, strict)
               : detail::binary_reader<basic_json, decltype(ia), SAX>(std::move(ia)).sax_parse(format, sax, strict);
    }

    /*!
    @brief deserialize from stream
    @deprecated This stream operator is deprecated and will be removed in
                version 4.0.0 of the library. Please use
                @ref operator>>(std::istream&, basic_json&)
                instead; that is, replace calls like `j << i;` with `i >> j;`.
    @since version 1.0.0; deprecated since version 3.0.0
    */
    JSON_HEDLEY_DEPRECATED_FOR(3.0.0, operator>>(std::istream&, basic_json&))
    friend std::istream& operator<<(basic_json& j, std::istream& i)
    {
        return operator>>(i, j);
    }

    /*!
    @brief deserialize from stream

    Deserializes an input stream to a JSON value.

    @param[in,out] i  input stream to read a serialized JSON value from
    @param[in,out] j  JSON value to write the deserialized input to

    @throw parse_error.101 in case of an unexpected token
    @throw parse_error.102 if to_unicode fails or surrogate error
    @throw parse_error.103 if to_unicode fails

    @complexity Linear in the length of the input. The parser is a predictive
    LL(1) parser.

    @note A UTF-8 byte order mark is silently ignored.

    @liveexample{The example below shows how a JSON value is constructed by
    reading a serialization from a stream.,operator_deserialize}

    @sa parse(std::istream&, const parser_callback_t) for a variant with a
    parser callback function to filter values while parsing

    @since version 1.0.0
    */
    friend std::istream& operator>>(std::istream& i, basic_json& j)
    {
        parser(detail::input_adapter(i)).parse(false, j);
        return i;
    }

    /// @}

    ///////////////////////////
    // convenience functions //
    ///////////////////////////

    /*!
    @brief return the type as string

    Returns the type name as string to be used in error messages - usually to
    indicate that a function was called on a wrong JSON type.

    @return a string representation of a the @a m_type member:
            Value type  | return value
            ----------- | -------------
            null        | `"null"`
            boolean     | `"boolean"`
            string      | `"string"`
            number      | `"number"` (for all number types)
            object      | `"object"`
            array       | `"array"`
            binary      | `"binary"`
            discarded   | `"discarded"`

    @exceptionsafety No-throw guarantee: this function never throws exceptions.

    @complexity Constant.

    @liveexample{The following code exemplifies `type_name()` for all JSON
    types.,type_name}

    @sa @ref type() -- return the type of the JSON value
    @sa @ref operator value_t() -- return the type of the JSON value (implicit)

    @since version 1.0.0, public since 2.1.0, `const char*` and `noexcept`
    since 3.0.0
    */
    JSON_HEDLEY_RETURNS_NON_NULL
    const char* type_name() const noexcept
    {
        {
            switch (m_type)
            {
                case value_t::null:
                    return "null";
                case value_t::object:
                    return "object";
                case value_t::array:
                    return "array";
                case value_t::string:
                    return "string";
                case value_t::boolean:
                    return "boolean";
                case value_t::binary:
                    return "binary";
                case value_t::discarded:
                    return "discarded";
                default:
                    return "number";
            }
        }
    }


  private:
    //////////////////////
    // member variables //
    //////////////////////

    /// the type of the current element
    value_t m_type = value_t::null;

    /// the value of the current element
    json_value m_value = {};

    //////////////////////////////////////////
    // binary serialization/deserialization //
    //////////////////////////////////////////

    /// @name binary serialization/deserialization support
    /// @{

  public:
    /*!
    @brief create a CBOR serialization of a given JSON value

    Serializes a given JSON value @a j to a byte vector using the CBOR (Concise
    Binary Object Representation) serialization format. CBOR is a binary
    serialization format which aims to be more compact than JSON itself, yet
    more efficient to parse.

    The library uses the following mapping from JSON values types to
    CBOR types according to the CBOR specification (RFC 7049):

    JSON value type | value/range                                | CBOR type                          | first byte
    --------------- | ------------------------------------------ | ---------------------------------- | ---------------
    null            | `null`                                     | Null                               | 0xF6
    boolean         | `true`                                     | True                               | 0xF5
    boolean         | `false`                                    | False                              | 0xF4
    number_integer  | -9223372036854775808..-2147483649          | Negative integer (8 bytes follow)  | 0x3B
    number_integer  | -2147483648..-32769                        | Negative integer (4 bytes follow)  | 0x3A
    number_integer  | -32768..-129                               | Negative integer (2 bytes follow)  | 0x39
    number_integer  | -128..-25                                  | Negative integer (1 byte follow)   | 0x38
    number_integer  | -24..-1                                    | Negative integer                   | 0x20..0x37
    number_integer  | 0..23                                      | Integer                            | 0x00..0x17
    number_integer  | 24..255                                    | Unsigned integer (1 byte follow)   | 0x18
    number_integer  | 256..65535                                 | Unsigned integer (2 bytes follow)  | 0x19
    number_integer  | 65536..4294967295                          | Unsigned integer (4 bytes follow)  | 0x1A
    number_integer  | 4294967296..18446744073709551615           | Unsigned integer (8 bytes follow)  | 0x1B
    number_unsigned | 0..23                                      | Integer                            | 0x00..0x17
    number_unsigned | 24..255                                    | Unsigned integer (1 byte follow)   | 0x18
    number_unsigned | 256..65535                                 | Unsigned integer (2 bytes follow)  | 0x19
    number_unsigned | 65536..4294967295                          | Unsigned integer (4 bytes follow)  | 0x1A
    number_unsigned | 4294967296..18446744073709551615           | Unsigned integer (8 bytes follow)  | 0x1B
    number_float    | *any value representable by a float*       | Single-Precision Float             | 0xFA
    number_float    | *any value NOT representable by a float*   | Double-Precision Float             | 0xFB
    string          | *length*: 0..23                            | UTF-8 string                       | 0x60..0x77
    string          | *length*: 23..255                          | UTF-8 string (1 byte follow)       | 0x78
    string          | *length*: 256..65535                       | UTF-8 string (2 bytes follow)      | 0x79
    string          | *length*: 65536..4294967295                | UTF-8 string (4 bytes follow)      | 0x7A
    string          | *length*: 4294967296..18446744073709551615 | UTF-8 string (8 bytes follow)      | 0x7B
    array           | *size*: 0..23                              | array                              | 0x80..0x97
    array           | *size*: 23..255                            | array (1 byte follow)              | 0x98
    array           | *size*: 256..65535                         | array (2 bytes follow)             | 0x99
    array           | *size*: 65536..4294967295                  | array (4 bytes follow)             | 0x9A
    array           | *size*: 4294967296..18446744073709551615   | array (8 bytes follow)             | 0x9B
    object          | *size*: 0..23                              | map                                | 0xA0..0xB7
    object          | *size*: 23..255                            | map (1 byte follow)                | 0xB8
    object          | *size*: 256..65535                         | map (2 bytes follow)               | 0xB9
    object          | *size*: 65536..4294967295                  | map (4 bytes follow)               | 0xBA
    object          | *size*: 4294967296..18446744073709551615   | map (8 bytes follow)               | 0xBB
    binary          | *size*: 0..23                              | byte string                        | 0x40..0x57
    binary          | *size*: 23..255                            | byte string (1 byte follow)        | 0x58
    binary          | *size*: 256..65535                         | byte string (2 bytes follow)       | 0x59
    binary          | *size*: 65536..4294967295                  | byte string (4 bytes follow)       | 0x5A
    binary          | *size*: 4294967296..18446744073709551615   | byte string (8 bytes follow)       | 0x5B

    @note The mapping is **complete** in the sense that any JSON value type
          can be converted to a CBOR value.

    @note If NaN or Infinity are stored inside a JSON number, they are
          serialized properly. This behavior differs from the @ref dump()
          function which serializes NaN or Infinity to `null`.

    @note The following CBOR types are not used in the conversion:
          - UTF-8 strings terminated by "break" (0x7F)
          - arrays terminated by "break" (0x9F)
          - maps terminated by "break" (0xBF)
          - byte strings terminated by "break" (0x5F)
          - date/time (0xC0..0xC1)
          - bignum (0xC2..0xC3)
          - decimal fraction (0xC4)
          - bigfloat (0xC5)
          - expected conversions (0xD5..0xD7)
          - simple values (0xE0..0xF3, 0xF8)
          - undefined (0xF7)
          - half-precision floats (0xF9)
          - break (0xFF)

    @param[in] j  JSON value to serialize
    @return CBOR serialization as byte vector

    @complexity Linear in the size of the JSON value @a j.

    @liveexample{The example shows the serialization of a JSON value to a byte
    vector in CBOR format.,to_cbor}

    @sa http://cbor.io
    @sa @ref from_cbor(detail::input_adapter&&, const bool, const bool, const cbor_tag_handler_t) for the
        analogous deserialization
    @sa @ref to_msgpack(const basic_json&) for the related MessagePack format
    @sa @ref to_ubjson(const basic_json&, const bool, const bool) for the
             related UBJSON format

    @since version 2.0.9; compact representation of floating-point numbers
           since version 3.8.0
    */
    static std::vector<uint8_t> to_cbor(const basic_json& j)
    {
        std::vector<uint8_t> result;
        to_cbor(j, result);
        return result;
    }

    static void to_cbor(const basic_json& j, detail::output_adapter<uint8_t> o)
    {
        binary_writer<uint8_t>(o).write_cbor(j);
    }

    static void to_cbor(const basic_json& j, detail::output_adapter<char> o)
    {
        binary_writer<char>(o).write_cbor(j);
    }

    /*!
    @brief create a MessagePack serialization of a given JSON value

    Serializes a given JSON value @a j to a byte vector using the MessagePack
    serialization format. MessagePack is a binary serialization format which
    aims to be more compact than JSON itself, yet more efficient to parse.

    The library uses the following mapping from JSON values types to
    MessagePack types according to the MessagePack specification:

    JSON value type | value/range                       | MessagePack type | first byte
    --------------- | --------------------------------- | ---------------- | ----------
    null            | `null`                            | nil              | 0xC0
    boolean         | `true`                            | true             | 0xC3
    boolean         | `false`                           | false            | 0xC2
    number_integer  | -9223372036854775808..-2147483649 | int64            | 0xD3
    number_integer  | -2147483648..-32769               | int32            | 0xD2
    number_integer  | -32768..-129                      | int16            | 0xD1
    number_integer  | -128..-33                         | int8             | 0xD0
    number_integer  | -32..-1                           | negative fixint  | 0xE0..0xFF
    number_integer  | 0..127                            | positive fixint  | 0x00..0x7F
    number_integer  | 128..255                          | uint 8           | 0xCC
    number_integer  | 256..65535                        | uint 16          | 0xCD
    number_integer  | 65536..4294967295                 | uint 32          | 0xCE
    number_integer  | 4294967296..18446744073709551615  | uint 64          | 0xCF
    number_unsigned | 0..127                            | positive fixint  | 0x00..0x7F
    number_unsigned | 128..255                          | uint 8           | 0xCC
    number_unsigned | 256..65535                        | uint 16          | 0xCD
    number_unsigned | 65536..4294967295                 | uint 32          | 0xCE
    number_unsigned | 4294967296..18446744073709551615  | uint 64          | 0xCF
    number_float    | *any value representable by a float*     | float 32 | 0xCA
    number_float    | *any value NOT representable by a float* | float 64 | 0xCB
    string          | *length*: 0..31                   | fixstr           | 0xA0..0xBF
    string          | *length*: 32..255                 | str 8            | 0xD9
    string          | *length*: 256..65535              | str 16           | 0xDA
    string          | *length*: 65536..4294967295       | str 32           | 0xDB
    array           | *size*: 0..15                     | fixarray         | 0x90..0x9F
    array           | *size*: 16..65535                 | array 16         | 0xDC
    array           | *size*: 65536..4294967295         | array 32         | 0xDD
    object          | *size*: 0..15                     | fix map          | 0x80..0x8F
    object          | *size*: 16..65535                 | map 16           | 0xDE
    object          | *size*: 65536..4294967295         | map 32           | 0xDF
    binary          | *size*: 0..255                    | bin 8            | 0xC4
    binary          | *size*: 256..65535                | bin 16           | 0xC5
    binary          | *size*: 65536..4294967295         | bin 32           | 0xC6

    @note The mapping is **complete** in the sense that any JSON value type
          can be converted to a MessagePack value.

    @note The following values can **not** be converted to a MessagePack value:
          - strings with more than 4294967295 bytes
          - byte strings with more than 4294967295 bytes
          - arrays with more than 4294967295 elements
          - objects with more than 4294967295 elements

    @note Any MessagePack output created @ref to_msgpack can be successfully
          parsed by @ref from_msgpack.

    @note If NaN or Infinity are stored inside a JSON number, they are
          serialized properly. This behavior differs from the @ref dump()
          function which serializes NaN or Infinity to `null`.

    @param[in] j  JSON value to serialize
    @return MessagePack serialization as byte vector

    @complexity Linear in the size of the JSON value @a j.

    @liveexample{The example shows the serialization of a JSON value to a byte
    vector in MessagePack format.,to_msgpack}

    @sa http://msgpack.org
    @sa @ref from_msgpack for the analogous deserialization
    @sa @ref to_cbor(const basic_json& for the related CBOR format
    @sa @ref to_ubjson(const basic_json&, const bool, const bool) for the
             related UBJSON format

    @since version 2.0.9
    */
    static std::vector<uint8_t> to_msgpack(const basic_json& j)
    {
        std::vector<uint8_t> result;
        to_msgpack(j, result);
        return result;
    }

    static void to_msgpack(const basic_json& j, detail::output_adapter<uint8_t> o)
    {
        binary_writer<uint8_t>(o).write_msgpack(j);
    }

    static void to_msgpack(const basic_json& j, detail::output_adapter<char> o)
    {
        binary_writer<char>(o).write_msgpack(j);
    }

    /*!
    @brief create a UBJSON serialization of a given JSON value

    Serializes a given JSON value @a j to a byte vector using the UBJSON
    (Universal Binary JSON) serialization format. UBJSON aims to be more compact
    than JSON itself, yet more efficient to parse.

    The library uses the following mapping from JSON values types to
    UBJSON types according to the UBJSON specification:

    JSON value type | value/range                       | UBJSON type | marker
    --------------- | --------------------------------- | ----------- | ------
    null            | `null`                            | null        | `Z`
    boolean         | `true`                            | true        | `T`
    boolean         | `false`                           | false       | `F`
    number_integer  | -9223372036854775808..-2147483649 | int64       | `L`
    number_integer  | -2147483648..-32769               | int32       | `l`
    number_integer  | -32768..-129                      | int16       | `I`
    number_integer  | -128..127                         | int8        | `i`
    number_integer  | 128..255                          | uint8       | `U`
    number_integer  | 256..32767                        | int16       | `I`
    number_integer  | 32768..2147483647                 | int32       | `l`
    number_integer  | 2147483648..9223372036854775807   | int64       | `L`
    number_unsigned | 0..127                            | int8        | `i`
    number_unsigned | 128..255                          | uint8       | `U`
    number_unsigned | 256..32767                        | int16       | `I`
    number_unsigned | 32768..2147483647                 | int32       | `l`
    number_unsigned | 2147483648..9223372036854775807   | int64       | `L`
    number_unsigned | 2147483649..18446744073709551615  | high-precision | `H`
    number_float    | *any value*                       | float64     | `D`
    string          | *with shortest length indicator*  | string      | `S`
    array           | *see notes on optimized format*   | array       | `[`
    object          | *see notes on optimized format*   | map         | `{`

    @note The mapping is **complete** in the sense that any JSON value type
          can be converted to a UBJSON value.

    @note The following values can **not** be converted to a UBJSON value:
          - strings with more than 9223372036854775807 bytes (theoretical)

    @note The following markers are not used in the conversion:
          - `Z`: no-op values are not created.
          - `C`: single-byte strings are serialized with `S` markers.

    @note Any UBJSON output created @ref to_ubjson can be successfully parsed
          by @ref from_ubjson.

    @note If NaN or Infinity are stored inside a JSON number, they are
          serialized properly. This behavior differs from the @ref dump()
          function which serializes NaN or Infinity to `null`.

    @note The optimized formats for containers are supported: Parameter
          @a use_size adds size information to the beginning of a container and
          removes the closing marker. Parameter @a use_type further checks
          whether all elements of a container have the same type and adds the
          type marker to the beginning of the container. The @a use_type
          parameter must only be used together with @a use_size = true. Note
          that @a use_size = true alone may result in larger representations -
          the benefit of this parameter is that the receiving side is
          immediately informed on the number of elements of the container.

    @note If the JSON data contains the binary type, the value stored is a list
          of integers, as suggested by the UBJSON documentation.  In particular,
          this means that serialization and the deserialization of a JSON
          containing binary values into UBJSON and back will result in a
          different JSON object.

    @param[in] j  JSON value to serialize
    @param[in] use_size  whether to add size annotations to container types
    @param[in] use_type  whether to add type annotations to container types
                         (must be combined with @a use_size = true)
    @return UBJSON serialization as byte vector

    @complexity Linear in the size of the JSON value @a j.

    @liveexample{The example shows the serialization of a JSON value to a byte
    vector in UBJSON format.,to_ubjson}

    @sa http://ubjson.org
    @sa @ref from_ubjson(detail::input_adapter&&, const bool, const bool) for the
        analogous deserialization
    @sa @ref to_cbor(const basic_json& for the related CBOR format
    @sa @ref to_msgpack(const basic_json&) for the related MessagePack format

    @since version 3.1.0
    */
    static std::vector<uint8_t> to_ubjson(const basic_json& j,
                                          const bool use_size = false,
                                          const bool use_type = false)
    {
        std::vector<uint8_t> result;
        to_ubjson(j, result, use_size, use_type);
        return result;
    }

    static void to_ubjson(const basic_json& j, detail::output_adapter<uint8_t> o,
                          const bool use_size = false, const bool use_type = false)
    {
        binary_writer<uint8_t>(o).write_ubjson(j, use_size, use_type);
    }

    static void to_ubjson(const basic_json& j, detail::output_adapter<char> o,
                          const bool use_size = false, const bool use_type = false)
    {
        binary_writer<char>(o).write_ubjson(j, use_size, use_type);
    }


    /*!
    @brief Serializes the given JSON object `j` to BSON and returns a vector
           containing the corresponding BSON-representation.

    BSON (Binary JSON) is a binary format in which zero or more ordered key/value pairs are
    stored as a single entity (a so-called document).

    The library uses the following mapping from JSON values types to BSON types:

    JSON value type | value/range                       | BSON type   | marker
    --------------- | --------------------------------- | ----------- | ------
    null            | `null`                            | null        | 0x0A
    boolean         | `true`, `false`                   | boolean     | 0x08
    number_integer  | -9223372036854775808..-2147483649 | int64       | 0x12
    number_integer  | -2147483648..2147483647           | int32       | 0x10
    number_integer  | 2147483648..9223372036854775807   | int64       | 0x12
    number_unsigned | 0..2147483647                     | int32       | 0x10
    number_unsigned | 2147483648..9223372036854775807   | int64       | 0x12
    number_unsigned | 9223372036854775808..18446744073709551615| --   | --
    number_float    | *any value*                       | double      | 0x01
    string          | *any value*                       | string      | 0x02
    array           | *any value*                       | document    | 0x04
    object          | *any value*                       | document    | 0x03
    binary          | *any value*                       | binary      | 0x05

    @warning The mapping is **incomplete**, since only JSON-objects (and things
    contained therein) can be serialized to BSON.
    Also, integers larger than 9223372036854775807 cannot be serialized to BSON,
    and the keys may not contain U+0000, since they are serialized a
    zero-terminated c-strings.

    @throw out_of_range.407  if `j.is_number_unsigned() && j.get<std::uint64_t>() > 9223372036854775807`
    @throw out_of_range.409  if a key in `j` contains a NULL (U+0000)
    @throw type_error.317    if `!j.is_object()`

    @pre The input `j` is required to be an object: `j.is_object() == true`.

    @note Any BSON output created via @ref to_bson can be successfully parsed
          by @ref from_bson.

    @param[in] j  JSON value to serialize
    @return BSON serialization as byte vector

    @complexity Linear in the size of the JSON value @a j.

    @liveexample{The example shows the serialization of a JSON value to a byte
    vector in BSON format.,to_bson}

    @sa http://bsonspec.org/spec.html
    @sa @ref from_bson(detail::input_adapter&&, const bool strict) for the
        analogous deserialization
    @sa @ref to_ubjson(const basic_json&, const bool, const bool) for the
             related UBJSON format
    @sa @ref to_cbor(const basic_json&) for the related CBOR format
    @sa @ref to_msgpack(const basic_json&) for the related MessagePack format
    */
    static std::vector<uint8_t> to_bson(const basic_json& j)
    {
        std::vector<uint8_t> result;
        to_bson(j, result);
        return result;
    }

    /*!
    @brief Serializes the given JSON object `j` to BSON and forwards the
           corresponding BSON-representation to the given output_adapter `o`.
    @param j The JSON object to convert to BSON.
    @param o The output adapter that receives the binary BSON representation.
    @pre The input `j` shall be an object: `j.is_object() == true`
    @sa @ref to_bson(const basic_json&)
    */
    static void to_bson(const basic_json& j, detail::output_adapter<uint8_t> o)
    {
        binary_writer<uint8_t>(o).write_bson(j);
    }

    /*!
    @copydoc to_bson(const basic_json&, detail::output_adapter<uint8_t>)
    */
    static void to_bson(const basic_json& j, detail::output_adapter<char> o)
    {
        binary_writer<char>(o).write_bson(j);
    }


    /*!
    @brief create a JSON value from an input in CBOR format

    Deserializes a given input @a i to a JSON value using the CBOR (Concise
    Binary Object Representation) serialization format.

    The library maps CBOR types to JSON value types as follows:

    CBOR type              | JSON value type | first byte
    ---------------------- | --------------- | ----------
    Integer                | number_unsigned | 0x00..0x17
    Unsigned integer       | number_unsigned | 0x18
    Unsigned integer       | number_unsigned | 0x19
    Unsigned integer       | number_unsigned | 0x1A
    Unsigned integer       | number_unsigned | 0x1B
    Negative integer       | number_integer  | 0x20..0x37
    Negative integer       | number_integer  | 0x38
    Negative integer       | number_integer  | 0x39
    Negative integer       | number_integer  | 0x3A
    Negative integer       | number_integer  | 0x3B
    Byte string            | binary          | 0x40..0x57
    Byte string            | binary          | 0x58
    Byte string            | binary          | 0x59
    Byte string            | binary          | 0x5A
    Byte string            | binary          | 0x5B
    UTF-8 string           | string          | 0x60..0x77
    UTF-8 string           | string          | 0x78
    UTF-8 string           | string          | 0x79
    UTF-8 string           | string          | 0x7A
    UTF-8 string           | string          | 0x7B
    UTF-8 string           | string          | 0x7F
    array                  | array           | 0x80..0x97
    array                  | array           | 0x98
    array                  | array           | 0x99
    array                  | array           | 0x9A
    array                  | array           | 0x9B
    array                  | array           | 0x9F
    map                    | object          | 0xA0..0xB7
    map                    | object          | 0xB8
    map                    | object          | 0xB9
    map                    | object          | 0xBA
    map                    | object          | 0xBB
    map                    | object          | 0xBF
    False                  | `false`         | 0xF4
    True                   | `true`          | 0xF5
    Null                   | `null`          | 0xF6
    Half-Precision Float   | number_float    | 0xF9
    Single-Precision Float | number_float    | 0xFA
    Double-Precision Float | number_float    | 0xFB

    @warning The mapping is **incomplete** in the sense that not all CBOR
             types can be converted to a JSON value. The following CBOR types
             are not supported and will yield parse errors (parse_error.112):
             - date/time (0xC0..0xC1)
             - bignum (0xC2..0xC3)
             - decimal fraction (0xC4)
             - bigfloat (0xC5)
             - expected conversions (0xD5..0xD7)
             - simple values (0xE0..0xF3, 0xF8)
             - undefined (0xF7)

    @warning CBOR allows map keys of any type, whereas JSON only allows
             strings as keys in object values. Therefore, CBOR maps with keys
             other than UTF-8 strings are rejected (parse_error.113).

    @note Any CBOR output created @ref to_cbor can be successfully parsed by
          @ref from_cbor.

    @param[in] i  an input in CBOR format convertible to an input adapter
    @param[in] strict  whether to expect the input to be consumed until EOF
                       (true by default)
    @param[in] allow_exceptions  whether to throw exceptions in case of a
    parse error (optional, true by default)
    @param[in] tag_handler how to treat CBOR tags (optional, error by default)

    @return deserialized JSON value; in case of a parse error and
            @a allow_exceptions set to `false`, the return value will be
            value_t::discarded.

    @throw parse_error.110 if the given input ends prematurely or the end of
    file was not reached when @a strict was set to true
    @throw parse_error.112 if unsupported features from CBOR were
    used in the given input @a v or if the input is not valid CBOR
    @throw parse_error.113 if a string was expected as map key, but not found

    @complexity Linear in the size of the input @a i.

    @liveexample{The example shows the deserialization of a byte vector in CBOR
    format to a JSON value.,from_cbor}

    @sa http://cbor.io
    @sa @ref to_cbor(const basic_json&) for the analogous serialization
    @sa @ref from_msgpack(detail::input_adapter&&, const bool, const bool) for the
        related MessagePack format
    @sa @ref from_ubjson(detail::input_adapter&&, const bool, const bool) for the
        related UBJSON format

    @since version 2.0.9; parameter @a start_index since 2.1.1; changed to
           consume input adapters, removed start_index parameter, and added
           @a strict parameter since 3.0.0; added @a allow_exceptions parameter
           since 3.2.0; added @a tag_handler parameter since 3.9.0.
    */
    template<typename InputType>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json from_cbor(InputType&& i,
                                const bool strict = true,
                                const bool allow_exceptions = true,
                                const cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error)
    {
        basic_json result;
        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
        auto ia = detail::input_adapter(std::forward<InputType>(i));
        const bool res = binary_reader<decltype(ia)>(std::move(ia)).sax_parse(input_format_t::cbor, &sdp, strict, tag_handler);
        return res ? result : basic_json(value_t::discarded);
    }

    /*!
    @copydoc from_cbor(detail::input_adapter&&, const bool, const bool, const cbor_tag_handler_t)
    */
    template<typename IteratorType>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json from_cbor(IteratorType first, IteratorType last,
                                const bool strict = true,
                                const bool allow_exceptions = true,
                                const cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error)
    {
        basic_json result;
        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
        auto ia = detail::input_adapter(std::move(first), std::move(last));
        const bool res = binary_reader<decltype(ia)>(std::move(ia)).sax_parse(input_format_t::cbor, &sdp, strict, tag_handler);
        return res ? result : basic_json(value_t::discarded);
    }

    template<typename T>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_cbor(ptr, ptr + len))
    static basic_json from_cbor(const T* ptr, std::size_t len,
                                const bool strict = true,
                                const bool allow_exceptions = true,
                                const cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error)
    {
        return from_cbor(ptr, ptr + len, strict, allow_exceptions, tag_handler);
    }


    JSON_HEDLEY_WARN_UNUSED_RESULT
    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_cbor(ptr, ptr + len))
    static basic_json from_cbor(detail::span_input_adapter&& i,
                                const bool strict = true,
                                const bool allow_exceptions = true,
                                const cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error)
    {
        basic_json result;
        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
        auto ia = i.get();
        const bool res = binary_reader<decltype(ia)>(std::move(ia)).sax_parse(input_format_t::cbor, &sdp, strict, tag_handler);
        return res ? result : basic_json(value_t::discarded);
    }

    /*!
    @brief create a JSON value from an input in MessagePack format

    Deserializes a given input @a i to a JSON value using the MessagePack
    serialization format.

    The library maps MessagePack types to JSON value types as follows:

    MessagePack type | JSON value type | first byte
    ---------------- | --------------- | ----------
    positive fixint  | number_unsigned | 0x00..0x7F
    fixmap           | object          | 0x80..0x8F
    fixarray         | array           | 0x90..0x9F
    fixstr           | string          | 0xA0..0xBF
    nil              | `null`          | 0xC0
    false            | `false`         | 0xC2
    true             | `true`          | 0xC3
    float 32         | number_float    | 0xCA
    float 64         | number_float    | 0xCB
    uint 8           | number_unsigned | 0xCC
    uint 16          | number_unsigned | 0xCD
    uint 32          | number_unsigned | 0xCE
    uint 64          | number_unsigned | 0xCF
    int 8            | number_integer  | 0xD0
    int 16           | number_integer  | 0xD1
    int 32           | number_integer  | 0xD2
    int 64           | number_integer  | 0xD3
    str 8            | string          | 0xD9
    str 16           | string          | 0xDA
    str 32           | string          | 0xDB
    array 16         | array           | 0xDC
    array 32         | array           | 0xDD
    map 16           | object          | 0xDE
    map 32           | object          | 0xDF
    bin 8            | binary          | 0xC4
    bin 16           | binary          | 0xC5
    bin 32           | binary          | 0xC6
    ext 8            | binary          | 0xC7
    ext 16           | binary          | 0xC8
    ext 32           | binary          | 0xC9
    fixext 1         | binary          | 0xD4
    fixext 2         | binary          | 0xD5
    fixext 4         | binary          | 0xD6
    fixext 8         | binary          | 0xD7
    fixext 16        | binary          | 0xD8
    negative fixint  | number_integer  | 0xE0-0xFF

    @note Any MessagePack output created @ref to_msgpack can be successfully
          parsed by @ref from_msgpack.

    @param[in] i  an input in MessagePack format convertible to an input
                  adapter
    @param[in] strict  whether to expect the input to be consumed until EOF
                       (true by default)
    @param[in] allow_exceptions  whether to throw exceptions in case of a
    parse error (optional, true by default)

    @return deserialized JSON value; in case of a parse error and
            @a allow_exceptions set to `false`, the return value will be
            value_t::discarded.

    @throw parse_error.110 if the given input ends prematurely or the end of
    file was not reached when @a strict was set to true
    @throw parse_error.112 if unsupported features from MessagePack were
    used in the given input @a i or if the input is not valid MessagePack
    @throw parse_error.113 if a string was expected as map key, but not found

    @complexity Linear in the size of the input @a i.

    @liveexample{The example shows the deserialization of a byte vector in
    MessagePack format to a JSON value.,from_msgpack}

    @sa http://msgpack.org
    @sa @ref to_msgpack(const basic_json&) for the analogous serialization
    @sa @ref from_cbor(detail::input_adapter&&, const bool, const bool, const cbor_tag_handler_t) for the
        related CBOR format
    @sa @ref from_ubjson(detail::input_adapter&&, const bool, const bool) for
        the related UBJSON format
    @sa @ref from_bson(detail::input_adapter&&, const bool, const bool) for
        the related BSON format

    @since version 2.0.9; parameter @a start_index since 2.1.1; changed to
           consume input adapters, removed start_index parameter, and added
           @a strict parameter since 3.0.0; added @a allow_exceptions parameter
           since 3.2.0
    */
    template<typename InputType>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json from_msgpack(InputType&& i,
                                   const bool strict = true,
                                   const bool allow_exceptions = true)
    {
        basic_json result;
        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
        auto ia = detail::input_adapter(std::forward<InputType>(i));
        const bool res = binary_reader<decltype(ia)>(std::move(ia)).sax_parse(input_format_t::msgpack, &sdp, strict);
        return res ? result : basic_json(value_t::discarded);
    }

    /*!
    @copydoc from_msgpack(detail::input_adapter&&, const bool, const bool)
    */
    template<typename IteratorType>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json from_msgpack(IteratorType first, IteratorType last,
                                   const bool strict = true,
                                   const bool allow_exceptions = true)
    {
        basic_json result;
        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
        auto ia = detail::input_adapter(std::move(first), std::move(last));
        const bool res = binary_reader<decltype(ia)>(std::move(ia)).sax_parse(input_format_t::msgpack, &sdp, strict);
        return res ? result : basic_json(value_t::discarded);
    }


    template<typename T>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_msgpack(ptr, ptr + len))
    static basic_json from_msgpack(const T* ptr, std::size_t len,
                                   const bool strict = true,
                                   const bool allow_exceptions = true)
    {
        return from_msgpack(ptr, ptr + len, strict, allow_exceptions);
    }

    JSON_HEDLEY_WARN_UNUSED_RESULT
    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_msgpack(ptr, ptr + len))
    static basic_json from_msgpack(detail::span_input_adapter&& i,
                                   const bool strict = true,
                                   const bool allow_exceptions = true)
    {
        basic_json result;
        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
        auto ia = i.get();
        const bool res = binary_reader<decltype(ia)>(std::move(ia)).sax_parse(input_format_t::msgpack, &sdp, strict);
        return res ? result : basic_json(value_t::discarded);
    }


    /*!
    @brief create a JSON value from an input in UBJSON format

    Deserializes a given input @a i to a JSON value using the UBJSON (Universal
    Binary JSON) serialization format.

    The library maps UBJSON types to JSON value types as follows:

    UBJSON type | JSON value type                         | marker
    ----------- | --------------------------------------- | ------
    no-op       | *no value, next value is read*          | `N`
    null        | `null`                                  | `Z`
    false       | `false`                                 | `F`
    true        | `true`                                  | `T`
    float32     | number_float                            | `d`
    float64     | number_float                            | `D`
    uint8       | number_unsigned                         | `U`
    int8        | number_integer                          | `i`
    int16       | number_integer                          | `I`
    int32       | number_integer                          | `l`
    int64       | number_integer                          | `L`
    high-precision number | number_integer, number_unsigned, or number_float - depends on number string | 'H'
    string      | string                                  | `S`
    char        | string                                  | `C`
    array       | array (optimized values are supported)  | `[`
    object      | object (optimized values are supported) | `{`

    @note The mapping is **complete** in the sense that any UBJSON value can
          be converted to a JSON value.

    @param[in] i  an input in UBJSON format convertible to an input adapter
    @param[in] strict  whether to expect the input to be consumed until EOF
                       (true by default)
    @param[in] allow_exceptions  whether to throw exceptions in case of a
    parse error (optional, true by default)

    @return deserialized JSON value; in case of a parse error and
            @a allow_exceptions set to `false`, the return value will be
            value_t::discarded.

    @throw parse_error.110 if the given input ends prematurely or the end of
    file was not reached when @a strict was set to true
    @throw parse_error.112 if a parse error occurs
    @throw parse_error.113 if a string could not be parsed successfully

    @complexity Linear in the size of the input @a i.

    @liveexample{The example shows the deserialization of a byte vector in
    UBJSON format to a JSON value.,from_ubjson}

    @sa http://ubjson.org
    @sa @ref to_ubjson(const basic_json&, const bool, const bool) for the
             analogous serialization
    @sa @ref from_cbor(detail::input_adapter&&, const bool, const bool, const cbor_tag_handler_t) for the
        related CBOR format
    @sa @ref from_msgpack(detail::input_adapter&&, const bool, const bool) for
        the related MessagePack format
    @sa @ref from_bson(detail::input_adapter&&, const bool, const bool) for
        the related BSON format

    @since version 3.1.0; added @a allow_exceptions parameter since 3.2.0
    */
    template<typename InputType>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json from_ubjson(InputType&& i,
                                  const bool strict = true,
                                  const bool allow_exceptions = true)
    {
        basic_json result;
        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
        auto ia = detail::input_adapter(std::forward<InputType>(i));
        const bool res = binary_reader<decltype(ia)>(std::move(ia)).sax_parse(input_format_t::ubjson, &sdp, strict);
        return res ? result : basic_json(value_t::discarded);
    }

    /*!
    @copydoc from_ubjson(detail::input_adapter&&, const bool, const bool)
    */
    template<typename IteratorType>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json from_ubjson(IteratorType first, IteratorType last,
                                  const bool strict = true,
                                  const bool allow_exceptions = true)
    {
        basic_json result;
        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
        auto ia = detail::input_adapter(std::move(first), std::move(last));
        const bool res = binary_reader<decltype(ia)>(std::move(ia)).sax_parse(input_format_t::ubjson, &sdp, strict);
        return res ? result : basic_json(value_t::discarded);
    }

    template<typename T>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_ubjson(ptr, ptr + len))
    static basic_json from_ubjson(const T* ptr, std::size_t len,
                                  const bool strict = true,
                                  const bool allow_exceptions = true)
    {
        return from_ubjson(ptr, ptr + len, strict, allow_exceptions);
    }

    JSON_HEDLEY_WARN_UNUSED_RESULT
    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_ubjson(ptr, ptr + len))
    static basic_json from_ubjson(detail::span_input_adapter&& i,
                                  const bool strict = true,
                                  const bool allow_exceptions = true)
    {
        basic_json result;
        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
        auto ia = i.get();
        const bool res = binary_reader<decltype(ia)>(std::move(ia)).sax_parse(input_format_t::ubjson, &sdp, strict);
        return res ? result : basic_json(value_t::discarded);
    }


    /*!
    @brief Create a JSON value from an input in BSON format

    Deserializes a given input @a i to a JSON value using the BSON (Binary JSON)
    serialization format.

    The library maps BSON record types to JSON value types as follows:

    BSON type       | BSON marker byte | JSON value type
    --------------- | ---------------- | ---------------------------
    double          | 0x01             | number_float
    string          | 0x02             | string
    document        | 0x03             | object
    array           | 0x04             | array
    binary          | 0x05             | still unsupported
    undefined       | 0x06             | still unsupported
    ObjectId        | 0x07             | still unsupported
    boolean         | 0x08             | boolean
    UTC Date-Time   | 0x09             | still unsupported
    null            | 0x0A             | null
    Regular Expr.   | 0x0B             | still unsupported
    DB Pointer      | 0x0C             | still unsupported
    JavaScript Code | 0x0D             | still unsupported
    Symbol          | 0x0E             | still unsupported
    JavaScript Code | 0x0F             | still unsupported
    int32           | 0x10             | number_integer
    Timestamp       | 0x11             | still unsupported
    128-bit decimal float | 0x13       | still unsupported
    Max Key         | 0x7F             | still unsupported
    Min Key         | 0xFF             | still unsupported

    @warning The mapping is **incomplete**. The unsupported mappings
             are indicated in the table above.

    @param[in] i  an input in BSON format convertible to an input adapter
    @param[in] strict  whether to expect the input to be consumed until EOF
                       (true by default)
    @param[in] allow_exceptions  whether to throw exceptions in case of a
    parse error (optional, true by default)

    @return deserialized JSON value; in case of a parse error and
            @a allow_exceptions set to `false`, the return value will be
            value_t::discarded.

    @throw parse_error.114 if an unsupported BSON record type is encountered

    @complexity Linear in the size of the input @a i.

    @liveexample{The example shows the deserialization of a byte vector in
    BSON format to a JSON value.,from_bson}

    @sa http://bsonspec.org/spec.html
    @sa @ref to_bson(const basic_json&) for the analogous serialization
    @sa @ref from_cbor(detail::input_adapter&&, const bool, const bool, const cbor_tag_handler_t) for the
        related CBOR format
    @sa @ref from_msgpack(detail::input_adapter&&, const bool, const bool) for
        the related MessagePack format
    @sa @ref from_ubjson(detail::input_adapter&&, const bool, const bool) for the
        related UBJSON format
    */
    template<typename InputType>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json from_bson(InputType&& i,
                                const bool strict = true,
                                const bool allow_exceptions = true)
    {
        basic_json result;
        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
        auto ia = detail::input_adapter(std::forward<InputType>(i));
        const bool res = binary_reader<decltype(ia)>(std::move(ia)).sax_parse(input_format_t::bson, &sdp, strict);
        return res ? result : basic_json(value_t::discarded);
    }

    /*!
    @copydoc from_bson(detail::input_adapter&&, const bool, const bool)
    */
    template<typename IteratorType>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json from_bson(IteratorType first, IteratorType last,
                                const bool strict = true,
                                const bool allow_exceptions = true)
    {
        basic_json result;
        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
        auto ia = detail::input_adapter(std::move(first), std::move(last));
        const bool res = binary_reader<decltype(ia)>(std::move(ia)).sax_parse(input_format_t::bson, &sdp, strict);
        return res ? result : basic_json(value_t::discarded);
    }

    template<typename T>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_bson(ptr, ptr + len))
    static basic_json from_bson(const T* ptr, std::size_t len,
                                const bool strict = true,
                                const bool allow_exceptions = true)
    {
        return from_bson(ptr, ptr + len, strict, allow_exceptions);
    }

    JSON_HEDLEY_WARN_UNUSED_RESULT
    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_bson(ptr, ptr + len))
    static basic_json from_bson(detail::span_input_adapter&& i,
                                const bool strict = true,
                                const bool allow_exceptions = true)
    {
        basic_json result;
        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
        auto ia = i.get();
        const bool res = binary_reader<decltype(ia)>(std::move(ia)).sax_parse(input_format_t::bson, &sdp, strict);
        return res ? result : basic_json(value_t::discarded);
    }
    /// @}

    //////////////////////////
    // JSON Pointer support //
    //////////////////////////

    /// @name JSON Pointer functions
    /// @{

    /*!
    @brief access specified element via JSON Pointer

    Uses a JSON pointer to retrieve a reference to the respective JSON value.
    No bound checking is performed. Similar to @ref operator[](const typename
    object_t::key_type&), `null` values are created in arrays and objects if
    necessary.

    In particular:
    - If the JSON pointer points to an object key that does not exist, it
      is created an filled with a `null` value before a reference to it
      is returned.
    - If the JSON pointer points to an array index that does not exist, it
      is created an filled with a `null` value before a reference to it
      is returned. All indices between the current maximum and the given
      index are also filled with `null`.
    - The special value `-` is treated as a synonym for the index past the
      end.

    @param[in] ptr  a JSON pointer

    @return reference to the element pointed to by @a ptr

    @complexity Constant.

    @throw parse_error.106   if an array index begins with '0'
    @throw parse_error.109   if an array index was not a number
    @throw out_of_range.404  if the JSON pointer can not be resolved

    @liveexample{The behavior is shown in the example.,operatorjson_pointer}

    @since version 2.0.0
    */
    reference operator[](const json_pointer& ptr)
    {
        return ptr.get_unchecked(this);
    }

    /*!
    @brief access specified element via JSON Pointer

    Uses a JSON pointer to retrieve a reference to the respective JSON value.
    No bound checking is performed. The function does not change the JSON
    value; no `null` values are created. In particular, the special value
    `-` yields an exception.

    @param[in] ptr  JSON pointer to the desired element

    @return const reference to the element pointed to by @a ptr

    @complexity Constant.

    @throw parse_error.106   if an array index begins with '0'
    @throw parse_error.109   if an array index was not a number
    @throw out_of_range.402  if the array index '-' is used
    @throw out_of_range.404  if the JSON pointer can not be resolved

    @liveexample{The behavior is shown in the example.,operatorjson_pointer_const}

    @since version 2.0.0
    */
    const_reference operator[](const json_pointer& ptr) const
    {
        return ptr.get_unchecked(this);
    }

    /*!
    @brief access specified element via JSON Pointer

    Returns a reference to the element at with specified JSON pointer @a ptr,
    with bounds checking.

    @param[in] ptr  JSON pointer to the desired element

    @return reference to the element pointed to by @a ptr

    @throw parse_error.106 if an array index in the passed JSON pointer @a ptr
    begins with '0'. See example below.

    @throw parse_error.109 if an array index in the passed JSON pointer @a ptr
    is not a number. See example below.

    @throw out_of_range.401 if an array index in the passed JSON pointer @a ptr
    is out of range. See example below.

    @throw out_of_range.402 if the array index '-' is used in the passed JSON
    pointer @a ptr. As `at` provides checked access (and no elements are
    implicitly inserted), the index '-' is always invalid. See example below.

    @throw out_of_range.403 if the JSON pointer describes a key of an object
    which cannot be found. See example below.

    @throw out_of_range.404 if the JSON pointer @a ptr can not be resolved.
    See example below.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes in the JSON value.

    @complexity Constant.

    @since version 2.0.0

    @liveexample{The behavior is shown in the example.,at_json_pointer}
    */
    reference at(const json_pointer& ptr)
    {
        return ptr.get_checked(this);
    }

    /*!
    @brief access specified element via JSON Pointer

    Returns a const reference to the element at with specified JSON pointer @a
    ptr, with bounds checking.

    @param[in] ptr  JSON pointer to the desired element

    @return reference to the element pointed to by @a ptr

    @throw parse_error.106 if an array index in the passed JSON pointer @a ptr
    begins with '0'. See example below.

    @throw parse_error.109 if an array index in the passed JSON pointer @a ptr
    is not a number. See example below.

    @throw out_of_range.401 if an array index in the passed JSON pointer @a ptr
    is out of range. See example below.

    @throw out_of_range.402 if the array index '-' is used in the passed JSON
    pointer @a ptr. As `at` provides checked access (and no elements are
    implicitly inserted), the index '-' is always invalid. See example below.

    @throw out_of_range.403 if the JSON pointer describes a key of an object
    which cannot be found. See example below.

    @throw out_of_range.404 if the JSON pointer @a ptr can not be resolved.
    See example below.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes in the JSON value.

    @complexity Constant.

    @since version 2.0.0

    @liveexample{The behavior is shown in the example.,at_json_pointer_const}
    */
    const_reference at(const json_pointer& ptr) const
    {
        return ptr.get_checked(this);
    }

    /*!
    @brief return flattened JSON value

    The function creates a JSON object whose keys are JSON pointers (see [RFC
    6901](https://tools.ietf.org/html/rfc6901)) and whose values are all
    primitive. The original JSON value can be restored using the @ref
    unflatten() function.

    @return an object that maps JSON pointers to primitive values

    @note Empty objects and arrays are flattened to `null` and will not be
          reconstructed correctly by the @ref unflatten() function.

    @complexity Linear in the size the JSON value.

    @liveexample{The following code shows how a JSON object is flattened to an
    object whose keys consist of JSON pointers.,flatten}

    @sa @ref unflatten() for the reverse function

    @since version 2.0.0
    */
    basic_json flatten() const
    {
        basic_json result(value_t::object);
        json_pointer::flatten("", *this, result);
        return result;
    }

    /*!
    @brief unflatten a previously flattened JSON value

    The function restores the arbitrary nesting of a JSON value that has been
    flattened before using the @ref flatten() function. The JSON value must
    meet certain constraints:
    1. The value must be an object.
    2. The keys must be JSON pointers (see
       [RFC 6901](https://tools.ietf.org/html/rfc6901))
    3. The mapped values must be primitive JSON types.

    @return the original JSON from a flattened version

    @note Empty objects and arrays are flattened by @ref flatten() to `null`
          values and can not unflattened to their original type. Apart from
          this example, for a JSON value `j`, the following is always true:
          `j == j.flatten().unflatten()`.

    @complexity Linear in the size the JSON value.

    @throw type_error.314  if value is not an object
    @throw type_error.315  if object values are not primitive

    @liveexample{The following code shows how a flattened JSON object is
    unflattened into the original nested JSON object.,unflatten}

    @sa @ref flatten() for the reverse function

    @since version 2.0.0
    */
    basic_json unflatten() const
    {
        return json_pointer::unflatten(*this);
    }

    /// @}

    //////////////////////////
    // JSON Patch functions //
    //////////////////////////

    /// @name JSON Patch functions
    /// @{

    /*!
    @brief applies a JSON patch

    [JSON Patch](http://jsonpatch.com) defines a JSON document structure for
    expressing a sequence of operations to apply to a JSON) document. With
    this function, a JSON Patch is applied to the current JSON value by
    executing all operations from the patch.

    @param[in] json_patch  JSON patch document
    @return patched document

    @note The application of a patch is atomic: Either all operations succeed
          and the patched document is returned or an exception is thrown. In
          any case, the original value is not changed: the patch is applied
          to a copy of the value.

    @throw parse_error.104 if the JSON patch does not consist of an array of
    objects

    @throw parse_error.105 if the JSON patch is malformed (e.g., mandatory
    attributes are missing); example: `"operation add must have member path"`

    @throw out_of_range.401 if an array index is out of range.

    @throw out_of_range.403 if a JSON pointer inside the patch could not be
    resolved successfully in the current JSON value; example: `"key baz not
    found"`

    @throw out_of_range.405 if JSON pointer has no parent ("add", "remove",
    "move")

    @throw other_error.501 if "test" operation was unsuccessful

    @complexity Linear in the size of the JSON value and the length of the
    JSON patch. As usually only a fraction of the JSON value is affected by
    the patch, the complexity can usually be neglected.

    @liveexample{The following code shows how a JSON patch is applied to a
    value.,patch}

    @sa @ref diff -- create a JSON patch by comparing two JSON values

    @sa [RFC 6902 (JSON Patch)](https://tools.ietf.org/html/rfc6902)
    @sa [RFC 6901 (JSON Pointer)](https://tools.ietf.org/html/rfc6901)

    @since version 2.0.0
    */
    basic_json patch(const basic_json& json_patch) const
    {
        // make a working copy to apply the patch to
        basic_json result = *this;

        // the valid JSON Patch operations
        enum class patch_operations {add, remove, replace, move, copy, test, invalid};

        const auto get_op = [](const std::string & op)
        {
            if (op == "add")
            {
                return patch_operations::add;
            }
            if (op == "remove")
            {
                return patch_operations::remove;
            }
            if (op == "replace")
            {
                return patch_operations::replace;
            }
            if (op == "move")
            {
                return patch_operations::move;
            }
            if (op == "copy")
            {
                return patch_operations::copy;
            }
            if (op == "test")
            {
                return patch_operations::test;
            }

            return patch_operations::invalid;
        };

        // wrapper for "add" operation; add value at ptr
        const auto operation_add = [&result](json_pointer & ptr, basic_json val)
        {
            // adding to the root of the target document means replacing it
            if (ptr.empty())
            {
                result = val;
                return;
            }

            // make sure the top element of the pointer exists
            json_pointer top_pointer = ptr.top();
            if (top_pointer != ptr)
            {
                result.at(top_pointer);
            }

            // get reference to parent of JSON pointer ptr
            const auto last_path = ptr.back();
            ptr.pop_back();
            basic_json& parent = result[ptr];

            switch (parent.m_type)
            {
                case value_t::null:
                case value_t::object:
                {
                    // use operator[] to add value
                    parent[last_path] = val;
                    break;
                }

                case value_t::array:
                {
                    if (last_path == "-")
                    {
                        // special case: append to back
                        parent.push_back(val);
                    }
                    else
                    {
                        const auto idx = json_pointer::array_index(last_path);
                        if (JSON_HEDLEY_UNLIKELY(idx > parent.size()))
                        {
                            // avoid undefined behavior
                            JSON_THROW(out_of_range::create(401, "array index " + std::to_string(idx) + " is out of range"));
                        }

                        // default case: insert add offset
                        parent.insert(parent.begin() + static_cast<difference_type>(idx), val);
                    }
                    break;
                }

                // if there exists a parent it cannot be primitive
                default:            // LCOV_EXCL_LINE
                    JSON_ASSERT(false);  // LCOV_EXCL_LINE
            }
        };

        // wrapper for "remove" operation; remove value at ptr
        const auto operation_remove = [&result](json_pointer & ptr)
        {
            // get reference to parent of JSON pointer ptr
            const auto last_path = ptr.back();
            ptr.pop_back();
            basic_json& parent = result.at(ptr);

            // remove child
            if (parent.is_object())
            {
                // perform range check
                auto it = parent.find(last_path);
                if (JSON_HEDLEY_LIKELY(it != parent.end()))
                {
                    parent.erase(it);
                }
                else
                {
                    JSON_THROW(out_of_range::create(403, "key '" + last_path + "' not found"));
                }
            }
            else if (parent.is_array())
            {
                // note erase performs range check
                parent.erase(json_pointer::array_index(last_path));
            }
        };

        // type check: top level value must be an array
        if (JSON_HEDLEY_UNLIKELY(!json_patch.is_array()))
        {
            JSON_THROW(parse_error::create(104, 0, "JSON patch must be an array of objects"));
        }

        // iterate and apply the operations
        for (const auto& val : json_patch)
        {
            // wrapper to get a value for an operation
            const auto get_value = [&val](const std::string & op,
                                          const std::string & member,
                                          bool string_type) -> basic_json &
            {
                // find value
                auto it = val.m_value.object->find(member);

                // context-sensitive error message
                const auto error_msg = (op == "op") ? "operation" : "operation '" + op + "'";

                // check if desired value is present
                if (JSON_HEDLEY_UNLIKELY(it == val.m_value.object->end()))
                {
                    JSON_THROW(parse_error::create(105, 0, error_msg + " must have member '" + member + "'"));
                }

                // check if result is of type string
                if (JSON_HEDLEY_UNLIKELY(string_type && !it->second.is_string()))
                {
                    JSON_THROW(parse_error::create(105, 0, error_msg + " must have string member '" + member + "'"));
                }

                // no error: return value
                return it->second;
            };

            // type check: every element of the array must be an object
            if (JSON_HEDLEY_UNLIKELY(!val.is_object()))
            {
                JSON_THROW(parse_error::create(104, 0, "JSON patch must be an array of objects"));
            }

            // collect mandatory members
            const auto op = get_value("op", "op", true).template get<std::string>();
            const auto path = get_value(op, "path", true).template get<std::string>();
            json_pointer ptr(path);

            switch (get_op(op))
            {
                case patch_operations::add:
                {
                    operation_add(ptr, get_value("add", "value", false));
                    break;
                }

                case patch_operations::remove:
                {
                    operation_remove(ptr);
                    break;
                }

                case patch_operations::replace:
                {
                    // the "path" location must exist - use at()
                    result.at(ptr) = get_value("replace", "value", false);
                    break;
                }

                case patch_operations::move:
                {
                    const auto from_path = get_value("move", "from", true).template get<std::string>();
                    json_pointer from_ptr(from_path);

                    // the "from" location must exist - use at()
                    basic_json v = result.at(from_ptr);

                    // The move operation is functionally identical to a
                    // "remove" operation on the "from" location, followed
                    // immediately by an "add" operation at the target
                    // location with the value that was just removed.
                    operation_remove(from_ptr);
                    operation_add(ptr, v);
                    break;
                }

                case patch_operations::copy:
                {
                    const auto from_path = get_value("copy", "from", true).template get<std::string>();
                    const json_pointer from_ptr(from_path);

                    // the "from" location must exist - use at()
                    basic_json v = result.at(from_ptr);

                    // The copy is functionally identical to an "add"
                    // operation at the target location using the value
                    // specified in the "from" member.
                    operation_add(ptr, v);
                    break;
                }

                case patch_operations::test:
                {
                    bool success = false;
                    JSON_TRY
                    {
                        // check if "value" matches the one at "path"
                        // the "path" location must exist - use at()
                        success = (result.at(ptr) == get_value("test", "value", false));
                    }
                    JSON_INTERNAL_CATCH (out_of_range&)
                    {
                        // ignore out of range errors: success remains false
                    }

                    // throw an exception if test fails
                    if (JSON_HEDLEY_UNLIKELY(!success))
                    {
                        JSON_THROW(other_error::create(501, "unsuccessful: " + val.dump()));
                    }

                    break;
                }

                default:
                {
                    // op must be "add", "remove", "replace", "move", "copy", or
                    // "test"
                    JSON_THROW(parse_error::create(105, 0, "operation value '" + op + "' is invalid"));
                }
            }
        }

        return result;
    }

    /*!
    @brief creates a diff as a JSON patch

    Creates a [JSON Patch](http://jsonpatch.com) so that value @a source can
    be changed into the value @a target by calling @ref patch function.

    @invariant For two JSON values @a source and @a target, the following code
    yields always `true`:
    @code {.cpp}
    source.patch(diff(source, target)) == target;
    @endcode

    @note Currently, only `remove`, `add`, and `replace` operations are
          generated.

    @param[in] source  JSON value to compare from
    @param[in] target  JSON value to compare against
    @param[in] path    helper value to create JSON pointers

    @return a JSON patch to convert the @a source to @a target

    @complexity Linear in the lengths of @a source and @a target.

    @liveexample{The following code shows how a JSON patch is created as a
    diff for two JSON values.,diff}

    @sa @ref patch -- apply a JSON patch
    @sa @ref merge_patch -- apply a JSON Merge Patch

    @sa [RFC 6902 (JSON Patch)](https://tools.ietf.org/html/rfc6902)

    @since version 2.0.0
    */
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json diff(const basic_json& source, const basic_json& target,
                           const std::string& path = "")
    {
        // the patch
        basic_json result(value_t::array);

        // if the values are the same, return empty patch
        if (source == target)
        {
            return result;
        }

        if (source.type() != target.type())
        {
            // different types: replace value
            result.push_back(
            {
                {"op", "replace"}, {"path", path}, {"value", target}
            });
            return result;
        }

        switch (source.type())
        {
            case value_t::array:
            {
                // first pass: traverse common elements
                std::size_t i = 0;
                while (i < source.size() && i < target.size())
                {
                    // recursive call to compare array values at index i
                    auto temp_diff = diff(source[i], target[i], path + "/" + std::to_string(i));
                    result.insert(result.end(), temp_diff.begin(), temp_diff.end());
                    ++i;
                }

                // i now reached the end of at least one array
                // in a second pass, traverse the remaining elements

                // remove my remaining elements
                const auto end_index = static_cast<difference_type>(result.size());
                while (i < source.size())
                {
                    // add operations in reverse order to avoid invalid
                    // indices
                    result.insert(result.begin() + end_index, object(
                    {
                        {"op", "remove"},
                        {"path", path + "/" + std::to_string(i)}
                    }));
                    ++i;
                }

                // add other remaining elements
                while (i < target.size())
                {
                    result.push_back(
                    {
                        {"op", "add"},
                        {"path", path + "/-"},
                        {"value", target[i]}
                    });
                    ++i;
                }

                break;
            }

            case value_t::object:
            {
                // first pass: traverse this object's elements
                for (auto it = source.cbegin(); it != source.cend(); ++it)
                {
                    // escape the key name to be used in a JSON patch
                    const auto key = json_pointer::escape(it.key());

                    if (target.find(it.key()) != target.end())
                    {
                        // recursive call to compare object values at key it
                        auto temp_diff = diff(it.value(), target[it.key()], path + "/" + key);
                        result.insert(result.end(), temp_diff.begin(), temp_diff.end());
                    }
                    else
                    {
                        // found a key that is not in o -> remove it
                        result.push_back(object(
                        {
                            {"op", "remove"}, {"path", path + "/" + key}
                        }));
                    }
                }

                // second pass: traverse other object's elements
                for (auto it = target.cbegin(); it != target.cend(); ++it)
                {
                    if (source.find(it.key()) == source.end())
                    {
                        // found a key that is not in this -> add it
                        const auto key = json_pointer::escape(it.key());
                        result.push_back(
                        {
                            {"op", "add"}, {"path", path + "/" + key},
                            {"value", it.value()}
                        });
                    }
                }

                break;
            }

            default:
            {
                // both primitive type: replace value
                result.push_back(
                {
                    {"op", "replace"}, {"path", path}, {"value", target}
                });
                break;
            }
        }

        return result;
    }

    /// @}

    ////////////////////////////////
    // JSON Merge Patch functions //
    ////////////////////////////////

    /// @name JSON Merge Patch functions
    /// @{

    /*!
    @brief applies a JSON Merge Patch

    The merge patch format is primarily intended for use with the HTTP PATCH
    method as a means of describing a set of modifications to a target
    resource's content. This function applies a merge patch to the current
    JSON value.

    The function implements the following algorithm from Section 2 of
    [RFC 7396 (JSON Merge Patch)](https://tools.ietf.org/html/rfc7396):

    ```
    define MergePatch(Target, Patch):
      if Patch is an Object:
        if Target is not an Object:
          Target = {} // Ignore the contents and set it to an empty Object
        for each Name/Value pair in Patch:
          if Value is null:
            if Name exists in Target:
              remove the Name/Value pair from Target
          else:
            Target[Name] = MergePatch(Target[Name], Value)
        return Target
      else:
        return Patch
    ```

    Thereby, `Target` is the current object; that is, the patch is applied to
    the current value.

    @param[in] apply_patch  the patch to apply

    @complexity Linear in the lengths of @a patch.

    @liveexample{The following code shows how a JSON Merge Patch is applied to
    a JSON document.,merge_patch}

    @sa @ref patch -- apply a JSON patch
    @sa [RFC 7396 (JSON Merge Patch)](https://tools.ietf.org/html/rfc7396)

    @since version 3.0.0
    */
    void merge_patch(const basic_json& apply_patch)
    {
        if (apply_patch.is_object())
        {
            if (!is_object())
            {
                *this = object();
            }
            for (auto it = apply_patch.begin(); it != apply_patch.end(); ++it)
            {
                if (it.value().is_null())
                {
                    erase(it.key());
                }
                else
                {
                    operator[](it.key()).merge_patch(it.value());
                }
            }
        }
        else
        {
            *this = apply_patch;
        }
    }

    /// @}
};

/*!
@brief user-defined to_string function for JSON values

This function implements a user-defined to_string  for JSON objects.

@param[in] j  a JSON object
@return a std::string object
*/

NLOHMANN_BASIC_JSON_TPL_DECLARATION
std::string to_string(const NLOHMANN_BASIC_JSON_TPL& j)
{
    return j.dump();
}
} // namespace nlohmann

///////////////////////
// nonmember support //
///////////////////////

// specialization of std::swap, and std::hash
namespace std
{

/// hash value for JSON objects
template<>
struct hash<nlohmann::json>
{
    /*!
    @brief return a hash value for a JSON object

    @since version 1.0.0
    */
    std::size_t operator()(const nlohmann::json& j) const
    {
        return nlohmann::detail::hash(j);
    }
};

/// specialization for std::less<value_t>
/// @note: do not remove the space after '<',
///        see https://github.com/nlohmann/json/pull/679
template<>
struct less<::nlohmann::detail::value_t>
{
    /*!
    @brief compare two value_t enum values
    @since version 3.0.0
    */
    bool operator()(nlohmann::detail::value_t lhs,
                    nlohmann::detail::value_t rhs) const noexcept
    {
        return nlohmann::detail::operator<(lhs, rhs);
    }
};

// C++20 prohibit function specialization in the std namespace.
#ifndef JSON_HAS_CPP_20

/*!
@brief exchanges the values of two JSON objects

@since version 1.0.0
*/
template<>
inline void swap<nlohmann::json>(nlohmann::json& j1, nlohmann::json& j2) noexcept(
    is_nothrow_move_constructible<nlohmann::json>::value&&
    is_nothrow_move_assignable<nlohmann::json>::value
                              )
{
    j1.swap(j2);
}

#endif

} // namespace std

/*!
@brief user-defined string literal for JSON values

This operator implements a user-defined string literal for JSON objects. It
can be used by adding `"_json"` to a string literal and returns a JSON object
if no parse error occurred.

@param[in] s  a string representation of a JSON object
@param[in] n  the length of string @a s
@return a JSON object

@since version 1.0.0
*/
JSON_HEDLEY_NON_NULL(1)
inline nlohmann::json operator "" _json(const char* s, std::size_t n)
{
    return nlohmann::json::parse(s, s + n);
}

/*!
@brief user-defined string literal for JSON pointer

This operator implements a user-defined string literal for JSON Pointers. It
can be used by adding `"_json_pointer"` to a string literal and returns a JSON pointer
object if no parse error occurred.

@param[in] s  a string representation of a JSON Pointer
@param[in] n  the length of string @a s
@return a JSON pointer object

@since version 2.0.0
*/
JSON_HEDLEY_NON_NULL(1)
inline nlohmann::json::json_pointer operator "" _json_pointer(const char* s, std::size_t n)
{
    return nlohmann::json::json_pointer(std::string(s, n));
}

// #include <nlohmann/detail/macro_unscope.hpp>


// restore GCC/clang diagnostic settings
#if defined(__clang__) || defined(__GNUC__) || defined(__GNUG__)
    #pragma GCC diagnostic pop
#endif
#if defined(__clang__)
    #pragma GCC diagnostic pop
#endif

// clean up
#undef JSON_ASSERT
#undef JSON_INTERNAL_CATCH
#undef JSON_CATCH
#undef JSON_THROW
#undef JSON_TRY
#undef JSON_HAS_CPP_14
#undef JSON_HAS_CPP_17
#undef NLOHMANN_BASIC_JSON_TPL_DECLARATION
#undef NLOHMANN_BASIC_JSON_TPL
#undef JSON_EXPLICIT

// #include <nlohmann/thirdparty/hedley/hedley_undef.hpp>
#undef JSON_HEDLEY_ALWAYS_INLINE
#undef JSON_HEDLEY_ARM_VERSION
#undef JSON_HEDLEY_ARM_VERSION_CHECK
#undef JSON_HEDLEY_ARRAY_PARAM
#undef JSON_HEDLEY_ASSUME
#undef JSON_HEDLEY_BEGIN_C_DECLS
#undef JSON_HEDLEY_CLANG_HAS_ATTRIBUTE
#undef JSON_HEDLEY_CLANG_HAS_BUILTIN
#undef JSON_HEDLEY_CLANG_HAS_CPP_ATTRIBUTE
#undef JSON_HEDLEY_CLANG_HAS_DECLSPEC_DECLSPEC_ATTRIBUTE
#undef JSON_HEDLEY_CLANG_HAS_EXTENSION
#undef JSON_HEDLEY_CLANG_HAS_FEATURE
#undef JSON_HEDLEY_CLANG_HAS_WARNING
#undef JSON_HEDLEY_COMPCERT_VERSION
#undef JSON_HEDLEY_COMPCERT_VERSION_CHECK
#undef JSON_HEDLEY_CONCAT
#undef JSON_HEDLEY_CONCAT3
#undef JSON_HEDLEY_CONCAT3_EX
#undef JSON_HEDLEY_CONCAT_EX
#undef JSON_HEDLEY_CONST
#undef JSON_HEDLEY_CONSTEXPR
#undef JSON_HEDLEY_CONST_CAST
#undef JSON_HEDLEY_CPP_CAST
#undef JSON_HEDLEY_CRAY_VERSION
#undef JSON_HEDLEY_CRAY_VERSION_CHECK
#undef JSON_HEDLEY_C_DECL
#undef JSON_HEDLEY_DEPRECATED
#undef JSON_HEDLEY_DEPRECATED_FOR
#undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL
#undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_
#undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED
#undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES
#undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS
#undef JSON_HEDLEY_DIAGNOSTIC_POP
#undef JSON_HEDLEY_DIAGNOSTIC_PUSH
#undef JSON_HEDLEY_DMC_VERSION
#undef JSON_HEDLEY_DMC_VERSION_CHECK
#undef JSON_HEDLEY_EMPTY_BASES
#undef JSON_HEDLEY_EMSCRIPTEN_VERSION
#undef JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK
#undef JSON_HEDLEY_END_C_DECLS
#undef JSON_HEDLEY_FLAGS
#undef JSON_HEDLEY_FLAGS_CAST
#undef JSON_HEDLEY_GCC_HAS_ATTRIBUTE
#undef JSON_HEDLEY_GCC_HAS_BUILTIN
#undef JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE
#undef JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE
#undef JSON_HEDLEY_GCC_HAS_EXTENSION
#undef JSON_HEDLEY_GCC_HAS_FEATURE
#undef JSON_HEDLEY_GCC_HAS_WARNING
#undef JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK
#undef JSON_HEDLEY_GCC_VERSION
#undef JSON_HEDLEY_GCC_VERSION_CHECK
#undef JSON_HEDLEY_GNUC_HAS_ATTRIBUTE
#undef JSON_HEDLEY_GNUC_HAS_BUILTIN
#undef JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE
#undef JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE
#undef JSON_HEDLEY_GNUC_HAS_EXTENSION
#undef JSON_HEDLEY_GNUC_HAS_FEATURE
#undef JSON_HEDLEY_GNUC_HAS_WARNING
#undef JSON_HEDLEY_GNUC_VERSION
#undef JSON_HEDLEY_GNUC_VERSION_CHECK
#undef JSON_HEDLEY_HAS_ATTRIBUTE
#undef JSON_HEDLEY_HAS_BUILTIN
#undef JSON_HEDLEY_HAS_CPP_ATTRIBUTE
#undef JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS
#undef JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE
#undef JSON_HEDLEY_HAS_EXTENSION
#undef JSON_HEDLEY_HAS_FEATURE
#undef JSON_HEDLEY_HAS_WARNING
#undef JSON_HEDLEY_IAR_VERSION
#undef JSON_HEDLEY_IAR_VERSION_CHECK
#undef JSON_HEDLEY_IBM_VERSION
#undef JSON_HEDLEY_IBM_VERSION_CHECK
#undef JSON_HEDLEY_IMPORT
#undef JSON_HEDLEY_INLINE
#undef JSON_HEDLEY_INTEL_VERSION
#undef JSON_HEDLEY_INTEL_VERSION_CHECK
#undef JSON_HEDLEY_IS_CONSTANT
#undef JSON_HEDLEY_IS_CONSTEXPR_
#undef JSON_HEDLEY_LIKELY
#undef JSON_HEDLEY_MALLOC
#undef JSON_HEDLEY_MESSAGE
#undef JSON_HEDLEY_MSVC_VERSION
#undef JSON_HEDLEY_MSVC_VERSION_CHECK
#undef JSON_HEDLEY_NEVER_INLINE
#undef JSON_HEDLEY_NON_NULL
#undef JSON_HEDLEY_NO_ESCAPE
#undef JSON_HEDLEY_NO_RETURN
#undef JSON_HEDLEY_NO_THROW
#undef JSON_HEDLEY_NULL
#undef JSON_HEDLEY_PELLES_VERSION
#undef JSON_HEDLEY_PELLES_VERSION_CHECK
#undef JSON_HEDLEY_PGI_VERSION
#undef JSON_HEDLEY_PGI_VERSION_CHECK
#undef JSON_HEDLEY_PREDICT
#undef JSON_HEDLEY_PRINTF_FORMAT
#undef JSON_HEDLEY_PRIVATE
#undef JSON_HEDLEY_PUBLIC
#undef JSON_HEDLEY_PURE
#undef JSON_HEDLEY_REINTERPRET_CAST
#undef JSON_HEDLEY_REQUIRE
#undef JSON_HEDLEY_REQUIRE_CONSTEXPR
#undef JSON_HEDLEY_REQUIRE_MSG
#undef JSON_HEDLEY_RESTRICT
#undef JSON_HEDLEY_RETURNS_NON_NULL
#undef JSON_HEDLEY_SENTINEL
#undef JSON_HEDLEY_STATIC_ASSERT
#undef JSON_HEDLEY_STATIC_CAST
#undef JSON_HEDLEY_STRINGIFY
#undef JSON_HEDLEY_STRINGIFY_EX
#undef JSON_HEDLEY_SUNPRO_VERSION
#undef JSON_HEDLEY_SUNPRO_VERSION_CHECK
#undef JSON_HEDLEY_TINYC_VERSION
#undef JSON_HEDLEY_TINYC_VERSION_CHECK
#undef JSON_HEDLEY_TI_ARMCL_VERSION
#undef JSON_HEDLEY_TI_ARMCL_VERSION_CHECK
#undef JSON_HEDLEY_TI_CL2000_VERSION
#undef JSON_HEDLEY_TI_CL2000_VERSION_CHECK
#undef JSON_HEDLEY_TI_CL430_VERSION
#undef JSON_HEDLEY_TI_CL430_VERSION_CHECK
#undef JSON_HEDLEY_TI_CL6X_VERSION
#undef JSON_HEDLEY_TI_CL6X_VERSION_CHECK
#undef JSON_HEDLEY_TI_CL7X_VERSION
#undef JSON_HEDLEY_TI_CL7X_VERSION_CHECK
#undef JSON_HEDLEY_TI_CLPRU_VERSION
#undef JSON_HEDLEY_TI_CLPRU_VERSION_CHECK
#undef JSON_HEDLEY_TI_VERSION
#undef JSON_HEDLEY_TI_VERSION_CHECK
#undef JSON_HEDLEY_UNAVAILABLE
#undef JSON_HEDLEY_UNLIKELY
#undef JSON_HEDLEY_UNPREDICTABLE
#undef JSON_HEDLEY_UNREACHABLE
#undef JSON_HEDLEY_UNREACHABLE_RETURN
#undef JSON_HEDLEY_VERSION
#undef JSON_HEDLEY_VERSION_DECODE_MAJOR
#undef JSON_HEDLEY_VERSION_DECODE_MINOR
#undef JSON_HEDLEY_VERSION_DECODE_REVISION
#undef JSON_HEDLEY_VERSION_ENCODE
#undef JSON_HEDLEY_WARNING
#undef JSON_HEDLEY_WARN_UNUSED_RESULT
#undef JSON_HEDLEY_WARN_UNUSED_RESULT_MSG
#undef JSON_HEDLEY_FALL_THROUGH



#endif  // INCLUDE_NLOHMANN_JSON_HPP_

```

`efiXplorer/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.7)

project(efiXplorer CXX)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

if(APPLE)
  # to build Mach-O universal binaries with 2 architectures
  set(CMAKE_CXX_FLAGS ${CMAKE_CXX_FLAGS} "-fPIC -arch x86_64")
else()
  set(CMAKE_CXX_FLAGS ${CMAKE_CXX_FLAGS} "-fPIC")
endif()

if(BATCH)
  add_definitions(-DBATCH=1)
  set(BATCH 1)
  message(STATUS "efiXplorer plugin version for idat/idat64 binaries")
endif()

list(APPEND CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/../cmake)

find_package(IdaSdk REQUIRED)

include_directories(${PROJECT_SOURCE_DIR})
include_directories(${PROJECT_SOURCE_DIR}/3rd/nlohmann_json)

# efiXplorer sources
set(efiXplorer_src
    "efiAnalysis.cpp"
    "efiAnalysis.h"
    "efiDeps.cpp"
    "efiDeps.h"
    "efiGlobal.h"
    "efiGlobal.cpp"
    "efiSmmUtils.cpp"
    "efiSmmUtils.h"
    "efiUi.cpp"
    "efiUi.h"
    "efiUtils.cpp"
    "efiUtils.h"
    "efiXplorer.cpp"
    "efiXplorer.h")

if(HexRaysSdk_ROOT_DIR)
  add_definitions(-DHEX_RAYS=1)
  set(HexRaysSdk_INCLUDE_DIRS ${HexRaysSdk_ROOT_DIR}/include)
  include_directories(${HexRaysSdk_INCLUDE_DIRS})
  list(APPEND efiXplorer_src "efiHexRays.cpp" "efiHexRays.h")
endif()

add_ida_plugin(efiXplorer ${PROJECT_SOURCE_DIR}/efiXplorer.cpp)

set_ida_target_properties(efiXplorer PROPERTIES CXX_STANDARD 17)
ida_target_include_directories(efiXplorer PRIVATE ${IdaSdk_INCLUDE_DIRS})

add_ida_library(efiXplorer_lib ${efiXplorer_src})
ida_target_link_libraries(efiXplorer efiXplorer_lib)

```

`efiXplorer/efiAnalysis.cpp`:

```cpp
/*
 * efiXplorer
 * Copyright (C) 2020-2022 Binarly
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * efiAnalysis.cpp
 *
 */

#include "efiAnalysis.h"
#include "efiGlobal.h"
#include "efiUi.h"
#include "tables/efi_pei_tables.h"
#include "tables/efi_services.h"

#ifdef HEX_RAYS
#include "efiHexRays.h"
#endif

using namespace EfiAnalysis;

static const char plugin_name[] = "efiXplorer";
extern std::vector<ea_t> g_get_smst_location_calls;
extern std::vector<ea_t> g_smm_get_variable_calls;
extern std::vector<ea_t> g_smm_set_variable_calls;

std::vector<ea_t> gStList;
std::vector<ea_t> gPeiSvcList;
std::vector<ea_t> gBsList;
std::vector<ea_t> gRtList;
std::vector<ea_t> gSmstList;
std::vector<ea_t> gImageHandleList;
std::vector<ea_t> gRtServicesList;
std::vector<json> stackGuids;
std::vector<json> dataGuids;

// all .text and .data segments for compatibility with the efiLoader
std::vector<segment_t *> textSegments;
std::vector<segment_t *> dataSegments;

// for smm callouts finding
std::vector<ea_t> calloutAddrs;
std::vector<func_t *> excFunctions;
std::vector<func_t *> childSmiHandlers;
std::vector<ea_t> readSaveStateCalls;

// for GetVariable stack overflow finding
std::vector<ea_t> peiGetVariableOverflow;
std::vector<ea_t> getVariableOverflow;
std::vector<ea_t> smmGetVariableOverflow;

EfiAnalysis::EfiAnalyzer::EfiAnalyzer() {
    // 32-bit, 64-bit or UEFI (in loader instance)
    arch = getInputFileType();

    // get guids.json path
    guidsJsonPath /= getGuidsJsonFile();

    // get base address
    base = get_imagebase();

    func_t *start_func = nullptr;
    func_t *end_func = nullptr;

    // get start address for scan
    start_func = getn_func(0);
    if (start_func) {
        startAddress = start_func->start_ea;
    }

    // get end address for scan
    end_func = getn_func(get_func_qty() - 1);
    if (end_func) {
        endAddress = end_func->end_ea;
    }

    // save all funcs
    for (auto i = 0; i < get_func_qty(); i++) {
        auto func = getn_func(i);
        funcs.push_back(func->start_ea);
    }

    std::vector<ea_t> addrs;
    for (auto service : protBsNames) {
        bootServices[service] = addrs;
    }

    for (auto service : protSmmNames) {
        smmServices[service] = addrs;
    }

    // load protocols from guids/guids.json file
    std::ifstream in(guidsJsonPath);
    in >> dbProtocols;

    // get reverse dictionary
    for (auto g = dbProtocols.begin(); g != dbProtocols.end(); ++g) {
        dbProtocolsMap[static_cast<json>(g.value())] = static_cast<std::string>(g.key());
    }

    // import necessary types
    const til_t *idati = get_idati();
    import_type(idati, -1, "EFI_GUID");
    import_type(idati, -1, "EFI_SYSTEM_TABLE");
    import_type(idati, -1, "EFI_BOOT_SERVICES");
    import_type(idati, -1, "EFI_RUNTIME_SERVICES");
    import_type(idati, -1, "_EFI_SMM_SYSTEM_TABLE2");
    import_type(idati, -1, "EFI_PEI_SERVICES");
    import_type(idati, -1, "EFI_PEI_READ_ONLY_VARIABLE2_PPI");
    import_type(idati, -1, "EFI_SMM_VARIABLE_PROTOCOL");
}

EfiAnalysis::EfiAnalyzer::~EfiAnalyzer() {
    funcs.clear();

    gStList.clear();
    gPeiSvcList.clear();
    gBsList.clear();
    gRtList.clear();
    gSmstList.clear();
    gImageHandleList.clear();
    gRtServicesList.clear();
    stackGuids.clear();
    dataGuids.clear();

    textSegments.clear();
    dataSegments.clear();

    calloutAddrs.clear();
    excFunctions.clear();
    readSaveStateCalls.clear();

    peiGetVariableOverflow.clear();
    getVariableOverflow.clear();
    smmGetVariableOverflow.clear();

    g_get_smst_location_calls.clear();
    g_smm_get_variable_calls.clear();
    g_smm_set_variable_calls.clear();
}

void EfiAnalysis::EfiAnalyzer::setStrings() {

    if (fileType == FTYPE_DXE_AND_THE_LIKE) {
        if_name = " Protocol name ";
        if_pl = "protocols";
        if_key = "prot_name";
        if_tbl = &allProtocols;

    } else if (fileType == FTYPE_PEI) {
        if_name = " PPI name ";
        if_pl = "PPIs";
        if_key = "ppi_name";
        if_tbl = &allPPIs;
    }
}

//--------------------------------------------------------------------------
// Get all .text and .data segments
void EfiAnalysis::EfiAnalyzer::getSegments() {
    for (segment_t *s = get_first_seg(); s != NULL; s = get_next_seg(s->start_ea)) {
        qstring seg_name;
        get_segm_name(&seg_name, s);

        std::vector<std::string> codeSegNames{
            ".text", ".code"}; // for compatibility with ida-efitools2
        for (auto name : codeSegNames) {
            auto index = seg_name.find(name.c_str());
            if (index != std::string::npos) {
                textSegments.push_back(s);
                continue;
            }
        }

        auto index = seg_name.find(".data");
        if (index != std::string::npos) {
            dataSegments.push_back(s);
            continue;
        }
    }

    // print all .text and .code segments addresses
    for (auto seg : textSegments) {
        segment_t *s = seg;
        msg("[%s] code segment: 0x%016llX\n", plugin_name,
            static_cast<uint64_t>(s->start_ea));
    }

    // print all .data segments addresses
    for (auto seg : dataSegments) {
        segment_t *s = seg;
        msg("[%s] data segment: 0x%016llX\n", plugin_name,
            static_cast<uint64_t>(s->start_ea));
    }
}

//--------------------------------------------------------------------------
// Find gImageHandle address for X64 modules
bool EfiAnalysis::EfiAnalyzer::findImageHandleX64() {
    msg("[%s] gImageHandle finding\n", plugin_name);
    insn_t insn;
    for (int idx = 0; idx < get_entry_qty(); idx++) {

        // get address of entry point
        uval_t ord = get_entry_ordinal(idx);
        ea_t ea = get_entry(ord);

        // EFI_IMAGE_HANDLE finding, first 8 instructions checking
        for (auto i = 0; i < 8; i++) {
            decode_insn(&insn, ea);
            if (insn.itype == NN_mov && insn.ops[1].type == o_reg &&
                insn.ops[1].reg == REG_RCX && insn.ops[0].type == o_mem) {
                msg("[%s] found ImageHandle at 0x%016llX, address = 0x%016llX\n",
                    plugin_name, static_cast<uint64_t>(ea),
                    static_cast<uint64_t>(insn.ops[0].addr));
                set_cmt(ea, "EFI_IMAGE_HANDLE gImageHandle", true);

                // set type and name
                setTypeAndName(insn.ops[0].addr, "gImageHandle", "EFI_IMAGE_HANDLE");
                gImageHandleList.push_back(insn.ops[0].addr);
                break;
            }
            ea = next_head(ea, endAddress);
        }
    }
    return true;
}

//--------------------------------------------------------------------------
// Find gST address for X64 modules
bool EfiAnalysis::EfiAnalyzer::findSystemTableX64() {
    msg("[%s] gEfiSystemTable finding\n", plugin_name);
    insn_t insn;
    for (int idx = 0; idx < get_entry_qty(); idx++) {

        // get address of entry point
        uval_t ord = get_entry_ordinal(idx);
        ea_t ea = get_entry(ord);

        // EFI_SYSTEM_TABLE finding, first 16 instructions checking
        for (int i = 0; i < 16; i++) {
            decode_insn(&insn, ea);
            if (insn.itype == NN_mov && insn.ops[1].type == o_reg &&
                insn.ops[1].reg == REG_RDX && insn.ops[0].type == o_mem) {
                set_cmt(ea, "EFI_SYSTEM_TABLE *gST", true);
                setPtrTypeAndName(insn.ops[0].addr, "gST", "EFI_SYSTEM_TABLE");
                gStList.push_back(insn.ops[0].addr);
                return true;
            }
            ea = next_head(ea, BADADDR);
        }
    }
    return false;
}

//--------------------------------------------------------------------------
// Find and mark gSmst global variable address for X64 module
bool EfiAnalysis::EfiAnalyzer::findSmstX64() {
    msg("[%s] gSmst finding\n", plugin_name);
    std::vector<ea_t> gSmstListSmmBase = findSmstSmmBase(gBsList);
    std::vector<ea_t> gSmstListSwDispatch = findSmstSwDispatch(gBsList);
    gSmstList.insert(gSmstList.end(), gSmstListSwDispatch.begin(),
                     gSmstListSwDispatch.end());
    gSmstList.insert(gSmstList.end(), gSmstListSmmBase.begin(), gSmstListSmmBase.end());

    // Deduplicate
    auto last = std::unique(gSmstList.begin(), gSmstList.end());
    gSmstList.erase(last, gSmstList.end());

    for (auto smst : gSmstList) {
        msg("[%s] 0x%016llX: gSmst\n", plugin_name, smst);
    }
    return gSmstList.size();
}

//--------------------------------------------------------------------------
// Find and mark gSmst global and local variable address for X64 module
// after Hex-Rays based analysis
bool EfiAnalysis::EfiAnalyzer::findSmstPostProcX64() {
    for (auto ea : g_get_smst_location_calls) {
        msg("[%s] EfiSmmBase2Protocol->GetSmstLocation call: 0x%016llx\n", plugin_name,
            static_cast<uint64_t>(ea));
        insn_t insn;
        auto addr = ea;
        ea_t smst_addr = BADADDR;
        json smst_stack;
        while (true) {
            addr = prev_head(addr, 0);
            decode_insn(&insn, addr);

            if (insn.itype == NN_lea && insn.ops[0].type == o_reg &&
                insn.ops[0].reg == REG_RDX) {
                switch (insn.ops[1].type) {
                case o_displ:
                    if (insn.ops[1].reg == REG_RSP || insn.ops[1].reg == REG_RBP) {
                        smst_addr = insn.ops[1].addr;
                        smst_stack["addr"] = smst_addr;
                        smst_stack["reg"] = insn.ops[1].reg;
                        smst_stack["start"] = next_head(ea, BADADDR);
                        // get bounds
                        func_t *f = get_func(addr);
                        if (f == nullptr) {
                            smst_stack["end"] = BADADDR;
                        } else {
                            smst_stack["end"] = f->end_ea;
                        }
                        set_cmt(addr, "_EFI_SMM_SYSTEM_TABLE2 *gSmst;", true);
                    }
                    break;
                case o_mem:
                    smst_addr = insn.ops[1].addr;
                    set_cmt(addr, "_EFI_SMM_SYSTEM_TABLE2 *gSmst;", true);
                    break;
                }
            }

            // Exit loop if end of previous basic block found
            if (is_basic_block_end(insn, false)) {
                break;
            }
        }

        if (smst_stack.is_null() && smst_addr != BADADDR) {
            msg("[%s]   gSmst: 0x%016llx\n", plugin_name,
                static_cast<uint64_t>(smst_addr));
            if (!addrInVec(gSmstList, smst_addr)) {
                setPtrTypeAndName(smst_addr, "gSmst", "_EFI_SMM_SYSTEM_TABLE2");
                gSmstList.push_back(smst_addr);
            }
        }

        if (!smst_stack.is_null()) {
            auto reg = smst_stack["reg"] == REG_RSP ? "RSP" : "RBP";
            msg("[%s]   Smst: 0x%016llx, reg = %s\n", plugin_name,
                static_cast<uint64_t>(smst_addr), reg);

            // try to extract ChildSwSmiHandler
            auto counter = 0;
            ea_t ea = static_cast<ea_t>(smst_stack["start"]);
            uint16_t smst_reg = BAD_REG;
            uint64_t rcx_last = BADADDR;
            while (ea < static_cast<ea_t>(smst_stack["end"])) {

                counter += 1;
                if (counter > 500) {
                    break; // just in case
                }

                ea = next_head(ea, BADADDR);
                decode_insn(&insn, ea);

                if (insn.itype == NN_mov && insn.ops[0].type == o_reg &&
                    insn.ops[1].type == o_displ &&
                    smst_stack["addr"] == insn.ops[1].addr) {
                    switch (insn.ops[1].reg) {
                    case REG_RSP:
                        if (smst_stack["reg"] == REG_RSP) {
                            smst_reg = insn.ops[0].reg;
                        }
                        break;
                    case REG_RBP:
                        if (smst_stack["reg"] == REG_RBP) {
                            smst_reg = insn.ops[0].reg;
                        }
                    default:
                        break;
                    }
                }

                // Save potencial ChildSwSmiHandler address
                if (insn.itype == NN_lea && insn.ops[0].type == o_reg &&
                    insn.ops[0].reg == REG_RCX && insn.ops[1].type == o_mem) {
                    rcx_last = insn.ops[1].addr;
                }

                if (rcx_last == BADADDR || smst_reg == BAD_REG) {
                    continue;
                }

                if (insn.itype == NN_callni && insn.ops[0].type == o_displ &&
                    insn.ops[0].reg == smst_reg &&
                    insn.ops[0].addr == SmiHandlerRegisterOffset64) {
                    opStroff(ea, std::string("_EFI_SMM_SYSTEM_TABLE2"));
                    // save child SW SMI handler
                    func_t *handler_func = get_func(rcx_last);
                    if (handler_func != nullptr) {
                        childSmiHandlers.push_back(handler_func);
                        set_name(rcx_last, "ChildSwSmiHandler", SN_FORCE);
                        break;
                    }
                }
            }
        }
    }

    return true;
}

//--------------------------------------------------------------------------
// Find gBS addresses for 32-bit/64-bit modules
bool EfiAnalysis::EfiAnalyzer::findBootServicesTables() {

    // init architecture-specific constants
    auto BS_OFFSET = BS_OFFSET_64BIT;
    uint16_t REG_SP = static_cast<uint16_t>(REG_RSP);

    if (arch == X86) {
        BS_OFFSET = BS_OFFSET_32BIT;
        REG_SP = static_cast<uint16_t>(REG_ESP);
    }

    insn_t insn;
    for (auto seg : textSegments) {
        segment_t *s = seg;
        msg("[%s] gEfiBootServices finding from 0x%016llX to 0x%016llX\n", plugin_name,
            static_cast<uint64_t>(s->start_ea), static_cast<uint64_t>(s->end_ea));
        ea_t ea = s->start_ea;
        uint16_t bsRegister = 0;
        uint16_t stRegister = 0;
        ea_t var_addr = BADADDR; // current global variable address
        while (ea <= s->end_ea) {
            ea = next_head(ea, endAddress);
            decode_insn(&insn, ea);
            if (insn.itype == NN_mov && insn.ops[1].type == o_displ &&
                insn.ops[1].phrase != REG_SP) {
                if (insn.ops[0].type == o_reg && insn.ops[1].addr == BS_OFFSET) {
                    auto bsFound = false;
                    auto stFound = false;
                    ea_t baseInsnAddr = BADADDR;
                    bsRegister = insn.ops[0].reg;
                    stRegister = insn.ops[1].phrase;

                    // found BS_OFFSET, need to check 10 instructions below
                    for (auto i = 0; i < 10; i++) {
                        ea = next_head(ea, endAddress);
                        decode_insn(&insn, ea);
                        if (insn.itype == NN_mov && insn.ops[0].type == o_reg &&
                            insn.ops[1].type == o_imm) {
                            var_addr = insn.ops[1].value;
                            auto phrase_reg = insn.ops[0].phrase;
                            auto next_ea = next_head(ea, BADADDR);
                            insn_t next_insn;
                            decode_insn(&next_insn, next_ea);
                            if (next_insn.itype == NN_mov &&
                                next_insn.ops[0].type == o_phrase &&
                                next_insn.ops[0].phrase == phrase_reg &&
                                next_insn.ops[1].type == o_reg &&
                                next_insn.ops[1].reg == bsRegister) {
                                baseInsnAddr = ea;
                                if (!addrInVec(gBsList, var_addr)) {
                                    set_cmt(ea, "EFI_BOOT_SERVICES *gBS", true);
                                    setPtrTypeAndName(var_addr, "gBS",
                                                      "EFI_BOOT_SERVICES");
                                    gBsList.push_back(var_addr);
                                }
                                bsFound = true;
                            }
                        }

                        if (insn.itype == NN_mov && insn.ops[1].type == o_reg &&
                            insn.ops[0].type == o_mem) {
                            if (insn.ops[1].reg == bsRegister && !bsFound) {
                                baseInsnAddr = ea;
                                var_addr = insn.ops[0].addr;
                                if (!addrInVec(gBsList, var_addr)) {
                                    set_cmt(ea, "EFI_BOOT_SERVICES *gBS", true);
                                    setPtrTypeAndName(var_addr, "gBS",
                                                      "EFI_BOOT_SERVICES");
                                    gBsList.push_back(var_addr);
                                }
                                bsFound = true;
                            }

                            // here you can also find gST
                            if (insn.ops[1].reg == stRegister && !stFound &&
                                stRegister != bsRegister) {
                                var_addr = insn.ops[0].addr;
                                if (!addrInTables(gStList, gBsList, gRtList, var_addr)) {
                                    set_cmt(ea, "EFI_SYSTEM_TABLE *gST", true);
                                    setPtrTypeAndName(var_addr, "gST",
                                                      "EFI_SYSTEM_TABLE");
                                    gStList.push_back(var_addr);
                                }
                                stFound = true;
                            }
                        }

                        if (bsFound && stFound) {
                            break;
                        }

                        if (bsFound && !stFound) {
                            // check 8 instructions above baseInsnAddr
                            auto addr = baseInsnAddr;
                            for (auto i = 0; i < 8; i++) {
                                addr = prev_head(addr, startAddress);
                                decode_insn(&insn, addr);
                                if (insn.itype == NN_mov && insn.ops[1].type == o_reg &&
                                    insn.ops[1].reg == stRegister &&
                                    insn.ops[0].type == o_mem) {
                                    var_addr = insn.ops[0].addr;
                                    if (!addrInTables(gStList, gBsList, gRtList,
                                                      var_addr)) {
                                        set_cmt(addr, "EFI_SYSTEM_TABLE *gST", true);
                                        setPtrTypeAndName(var_addr, "gST",
                                                          "EFI_SYSTEM_TABLE");
                                        gStList.push_back(var_addr);
                                    }
                                    stFound = true;
                                    break;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return (gBsList.size() != 0);
}

//--------------------------------------------------------------------------
// Find gRT addresses for X86/X64 modules
bool EfiAnalysis::EfiAnalyzer::findRuntimeServicesTables() {

    // init architecture-specific constants
    auto RT_OFFSET = RT_OFFSET_64BIT;
    uint16_t REG_SP = static_cast<uint16_t>(REG_RSP);

    if (arch == X86) {
        RT_OFFSET = RT_OFFSET_32BIT;
        REG_SP = static_cast<uint16_t>(REG_ESP);
    }

    insn_t insn;
    for (auto seg : textSegments) {
        segment_t *s = seg;
        msg("[%s] gEfiRuntimeServices finding from 0x%016llX to 0x%016llX\n", plugin_name,
            static_cast<uint64_t>(s->start_ea), static_cast<uint64_t>(s->end_ea));
        ea_t ea = s->start_ea;
        uint16_t rtRegister = 0;
        uint16_t stRegister = 0;
        ea_t var_addr = BADADDR; // current global variable address
        while (ea <= s->end_ea) {
            ea = next_head(ea, endAddress);
            decode_insn(&insn, ea);
            if (insn.itype == NN_mov && insn.ops[1].type == o_displ &&
                insn.ops[1].phrase != REG_SP) {
                if (insn.ops[0].type == o_reg && insn.ops[1].addr == RT_OFFSET) {
                    rtRegister = insn.ops[0].reg;
                    stRegister = insn.ops[1].phrase;
                    auto rtFound = false;
                    auto stFound = false;
                    ea_t baseInsnAddr;

                    // found RT_OFFSET, need to check 10 instructions below
                    for (auto i = 0; i < 10; i++) {
                        ea = next_head(ea, endAddress);
                        decode_insn(&insn, ea);
                        if (insn.itype == NN_mov && insn.ops[0].type == o_reg &&
                            insn.ops[1].type == o_imm) {
                            var_addr = insn.ops[1].value;
                            auto phrase_reg = insn.ops[0].phrase;
                            auto next_ea = next_head(ea, BADADDR);
                            insn_t next_insn;
                            decode_insn(&next_insn, next_ea);
                            if (next_insn.itype == NN_mov &&
                                next_insn.ops[0].type == o_phrase &&
                                next_insn.ops[0].phrase == phrase_reg &&
                                next_insn.ops[1].type == o_reg &&
                                next_insn.ops[1].reg == rtRegister) {
                                baseInsnAddr = ea;
                                if (!addrInVec(gRtList, var_addr)) {
                                    set_cmt(ea, "EFI_RUNTIME_SERVICES *gRT", true);
                                    setPtrTypeAndName(var_addr, "gRT",
                                                      "EFI_RUNTIME_SERVICES");
                                    gRtList.push_back(var_addr);
                                }
                                rtFound = true;
                            }
                        }

                        if (insn.itype == NN_mov && insn.ops[1].type == o_reg &&
                            insn.ops[0].type == o_mem) {
                            if (insn.ops[1].reg == rtRegister && !rtFound) {
                                baseInsnAddr = ea;
                                var_addr = insn.ops[0].addr;
                                if (!addrInVec(gRtList, var_addr)) {
                                    set_cmt(ea, "EFI_RUNTIME_SERVICES *gRT", true);
                                    setPtrTypeAndName(var_addr, "gRT",
                                                      "EFI_RUNTIME_SERVICES");
                                    gRtList.push_back(var_addr);
                                }
                                rtFound = true;
                            }

                            // here you can also find gST
                            if (insn.ops[1].reg == stRegister && !stFound &&
                                stRegister != rtRegister) {
                                var_addr = insn.ops[0].addr;
                                if (!addrInTables(gStList, gBsList, gRtList, var_addr)) {
                                    set_cmt(ea, "EFI_SYSTEM_TABLE *gST", true);
                                    setPtrTypeAndName(insn.ops[0].addr, "gST",
                                                      "EFI_SYSTEM_TABLE");
                                    gStList.push_back(insn.ops[0].addr);
                                }
                                stFound = true;
                            }
                        }

                        if (rtFound && stFound) {
                            break;
                        }

                        if (rtFound && !stFound) {
                            // check 8 instructions above baseInsnAddr
                            auto addr = baseInsnAddr;
                            for (auto i = 0; i < 8; i++) {
                                addr = prev_head(addr, startAddress);
                                decode_insn(&insn, addr);
                                if (insn.itype == NN_mov && insn.ops[1].type == o_reg &&
                                    insn.ops[1].reg == stRegister &&
                                    insn.ops[0].type == o_mem) {
                                    if (!addrInTables(gStList, gBsList, gRtList,
                                                      var_addr)) {
                                        set_cmt(addr, "EFI_SYSTEM_TABLE *gST", true);
                                        setPtrTypeAndName(var_addr, "gST",
                                                          "EFI_SYSTEM_TABLE");
                                        gStList.push_back(var_addr);
                                    }
                                    stFound = true;
                                    break;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return (gRtList.size() != 0);
}

//--------------------------------------------------------------------------
// Get all boot services by xrefs for X86/X64 modules
void EfiAnalysis::EfiAnalyzer::getAllBootServices() {
    msg("[%s] BootServices finding (xrefs)\n", plugin_name);

    if (!gBsList.size()) {
        return;
    }

    insn_t insn;
    for (auto bs : gBsList) {

        msg("[%s] BootServices finding by xrefs to gBS (0x%016llX)\n", plugin_name,
            static_cast<uint64_t>(bs));

        auto xrefs = getXrefs(bs);
        for (auto ea : xrefs) {
            bool found = false;
            decode_insn(&insn, ea);

            if (!(insn.itype == NN_mov &&
                  (insn.ops[1].addr == bs || insn.ops[1].value == bs))) {
                continue;
            }

            auto bs_reg = insn.ops[0].reg;

            // 16 instructions below
            auto addr = ea;
            ea_t service_offset = BADADDR;
            for (auto i = 0; i < 16; i++) {
                addr = next_head(addr, BADADDR);
                decode_insn(&insn, addr);

                if (insn.itype == NN_mov && insn.ops[1].type == o_displ &&
                    insn.ops[1].reg == bs_reg && insn.ops[1].addr) {
                    service_offset = insn.ops[1].addr;
                }

                if (insn.itype == NN_callni && insn.ops[0].reg == bs_reg) {

                    if (insn.ops[0].addr) {
                        service_offset = insn.ops[0].addr;
                    }

                    for (int j = 0; j < bootServicesTableAllLength; j++) {

                        // architecture-specific variables
                        auto offset = bootServicesTableAll[j].offset64;
                        if (arch == X86) {
                            offset = bootServicesTableAll[j].offset32;
                        }

                        if (service_offset == static_cast<uint32_t>(offset)) {

                            // additional check for gBS->RegisterProtocolNotify
                            // (can be confused with
                            // gSmst->SmmInstallProtocolInterface)
                            if (static_cast<uint32_t>(offset) ==
                                RegisterProtocolNotifyOffset64) {
                                if (!bootServiceProtCheck(addr)) {
                                    break;
                                }
                            }

                            std::string cmt =
                                getBsComment(static_cast<uint32_t>(offset), arch);
                            set_cmt(addr, cmt.c_str(), true);
                            opStroff(addr, "EFI_BOOT_SERVICES");

                            msg("[%s] 0x%016llX : %s\n", plugin_name,
                                static_cast<uint64_t>(addr),
                                static_cast<char *>(
                                    bootServicesTableAll[j].service_name));
                            bootServices[static_cast<std::string>(
                                             bootServicesTableAll[j].service_name)]
                                .push_back(addr);

                            // add item to allBootServices
                            json bsItem;
                            bsItem["address"] = addr;
                            bsItem["service_name"] = static_cast<std::string>(
                                bootServicesTableAll[j].service_name);
                            bsItem["table_name"] =
                                static_cast<std::string>("EFI_BOOT_SERVICES");
                            bsItem["offset"] = offset;

                            // add code addresses for arguments
                            eavec_t args;
                            get_arg_addrs(&args, addr);
                            bsItem["args"] = args;

                            if (find(allServices.begin(), allServices.end(), bsItem) ==
                                allServices.end()) {
                                allServices.push_back(bsItem);
                            }

                            found = true;
                            break;
                        }
                    }
                }
                if (found) {
                    break;
                }
            }
        }
    }
}

//--------------------------------------------------------------------------
// Get all runtime services for X86/X64 modules by xrefs
void EfiAnalysis::EfiAnalyzer::getAllRuntimeServices() {
    msg("[%s] RuntimeServices finding (xrefs)\n", plugin_name);

    if (!gRtList.size()) {
        return;
    }

    insn_t insn;
    for (auto rt : gRtList) {
        auto xrefs = getXrefs(rt);

        msg("[%s] RuntimeServices finding by xrefs to gRT (0x%016llX)\n", plugin_name,
            static_cast<uint64_t>(rt));

        for (auto ea : xrefs) {
            decode_insn(&insn, ea);

            if (!(insn.itype == NN_mov &&
                  (insn.ops[1].addr == rt || insn.ops[1].value == rt))) {
                continue;
            }

            auto rt_reg = insn.ops[0].reg;

            // 16 instructions below
            ea_t addr = ea;
            ea_t service_offset = BADADDR;
            for (int i = 0; i < 16; i++) {
                addr = next_head(addr, BADADDR);
                decode_insn(&insn, addr);

                if (insn.itype == NN_mov && insn.ops[1].type == o_displ &&
                    insn.ops[1].reg == rt_reg && insn.ops[1].addr) {
                    service_offset = insn.ops[1].addr;
                }

                if (insn.itype == NN_callni && insn.ops[0].reg == REG_RAX) {

                    if (insn.ops[0].addr) {
                        service_offset = insn.ops[0].addr;
                    }

                    for (int j = 0; j < runtimeServicesTableAllLength; j++) {

                        // architecture-specific variables
                        auto offset = runtimeServicesTableAll[j].offset64;
                        if (arch == X86) {
                            offset = runtimeServicesTableAll[j].offset32;
                        }
                        if (service_offset == static_cast<uint32_t>(offset)) {
                            std::string cmt =
                                getRtComment(static_cast<uint32_t>(offset), arch);
                            set_cmt(addr, cmt.c_str(), true);
                            opStroff(addr, "EFI_RUNTIME_SERVICES");
                            msg("[%s] 0x%016llX : %s\n", plugin_name,
                                static_cast<uint64_t>(addr),
                                static_cast<char *>(
                                    runtimeServicesTableAll[j].service_name));
                            runtimeServicesAll[static_cast<std::string>(
                                                   runtimeServicesTableAll[j]
                                                       .service_name)]
                                .push_back(addr);

                            // add item to allRuntimeServices
                            json rtItem;
                            rtItem["address"] = addr;
                            rtItem["service_name"] = static_cast<std::string>(
                                runtimeServicesTableAll[j].service_name);
                            rtItem["table_name"] =
                                static_cast<std::string>("EFI_RUNTIME_SERVICES");
                            rtItem["offset"] = offset;

                            // add code addresses for arguments
                            eavec_t args;
                            get_arg_addrs(&args, addr);
                            rtItem["args"] = args;

                            if (find(allServices.begin(), allServices.end(), rtItem) ==
                                allServices.end()) {
                                allServices.push_back(rtItem);
                            }
                            gRtServicesList.push_back(addr);
                            break;
                        }
                    }
                }
            }
        }
    }
}

//--------------------------------------------------------------------------
// Get all smm services for X64 modules
void EfiAnalysis::EfiAnalyzer::getAllSmmServicesX64() {
    msg("[%s] SmmServices finding (xrefs)\n", plugin_name);

    if (!gSmstList.size()) {
        return;
    }

    insn_t insn;
    for (auto smms : gSmstList) {
        auto xrefs = getXrefs(smms);

        msg("[%s] SmmServices finding by xref to gSmst (0x%016llX)\n", plugin_name,
            static_cast<uint64_t>(smms));

        for (auto ea : xrefs) {
            decode_insn(&insn, ea);

            if (!(insn.itype == NN_mov && insn.ops[1].type == o_mem &&
                  insn.ops[1].addr == smms)) {
                continue;
            }

            auto smst_reg = insn.ops[0].reg;

            // 10 instructions below
            auto addr = ea;
            for (auto i = 0; i < 10; i++) {
                addr = next_head(addr, BADADDR);
                decode_insn(&insn, addr);
                // Add NN_jmpni insn type to handle such cases
                // jmp qword ptr [r9+0D0h]
                if ((insn.itype == NN_callni || insn.itype == NN_jmpni) &&
                    insn.ops[0].reg == smst_reg) {
                    for (int j = 0; j < smmServicesTableAllLength; j++) {
                        if (insn.ops[0].addr ==
                            static_cast<uint32_t>(smmServicesTableAll[j].offset64)) {

                            if (static_cast<uint32_t>(smmServicesTableAll[j].offset64) ==
                                SmiHandlerRegisterOffset64) {
                                // set name for Handler argument
                                auto smiHandlerAddr = markChildSwSmiHandler(addr);
                                // save SMI handler
                                func_t *childSmiHandler = get_func(smiHandlerAddr);
                                if (childSmiHandler != nullptr) {
                                    childSmiHandlers.push_back(childSmiHandler);
                                }
                            }

                            std::string cmt =
                                "gSmst->" + static_cast<std::string>(
                                                smmServicesTableAll[j].service_name);
                            set_cmt(addr, cmt.c_str(), true);
                            opStroff(addr, "_EFI_SMM_SYSTEM_TABLE2");
                            msg("[%s] 0x%016llX : %s\n", plugin_name,
                                static_cast<uint64_t>(addr),
                                static_cast<char *>(smmServicesTableAll[j].service_name));

                            // add address to smmServices[...]
                            if (find(protSmmNames.begin(), protSmmNames.end(),
                                     smmServicesTableAll[j].service_name) !=
                                protSmmNames.end()) {
                                smmServices[smmServicesTableAll[j].service_name]
                                    .push_back(addr);
                            }
                            smmServicesAll[static_cast<std::string>(
                                               smmServicesTableAll[j].service_name)]
                                .push_back(addr);

                            // add item to allSmmServices
                            json smmsItem;
                            smmsItem["address"] = addr;
                            smmsItem["service_name"] = static_cast<std::string>(
                                smmServicesTableAll[j].service_name);
                            smmsItem["table_name"] =
                                static_cast<std::string>("_EFI_SMM_SYSTEM_TABLE2");
                            smmsItem["offset"] = smmServicesTableAll[j].offset64;

                            // add code addresses for arguments
                            eavec_t args;
                            get_arg_addrs(&args, addr);
                            smmsItem["args"] = args;

                            if (find(allServices.begin(), allServices.end(), smmsItem) ==
                                allServices.end()) {
                                allServices.push_back(smmsItem);
                            }
                            break;
                        }
                    }
                }
            }
        }
    }
}

//--------------------------------------------------------------------------
// Get all Pei services for X86 modules
// Currently should cover all PeiServices except EFI_PEI_COPY_MEM,
// EFI_PEI_SET_MEM, EFI_PEI_RESET2_SYSTEM, and "Future Installed Services"
// (EFI_PEI_FFS_FIND_BY_NAME, etc.)
void EfiAnalysis::EfiAnalyzer::getAllPeiServicesX86() {
    msg("[%s] PeiServices finding from 0x%016llX to 0x%016llX (all)\n", plugin_name,
        static_cast<uint64_t>(startAddress), static_cast<uint64_t>(endAddress));
    ea_t ea = startAddress;
    insn_t insn;
    auto found = false;
    while (ea <= endAddress) {
        ea = next_head(ea, BADADDR);
        decode_insn(&insn, ea);
        if (insn.itype == NN_callni &&
            (insn.ops[0].reg == REG_EAX || insn.ops[0].reg == REG_ECX ||
             insn.ops[0].reg == REG_EDX)) {
            for (int j = 0; j < pei_services_table_size; j++) {
                if (insn.ops[0].addr ==
                    static_cast<uint32_t>(pei_services_table[j].offset)) {
                    bool found_src_reg = false;
                    ea_t address = ea;
                    insn_t aboveInst;
                    uint16_t src_reg = 0xffff;

                    // 15 instructions above
                    for (auto j = 0; j < 15; j++) {
                        address = prev_head(address, startAddress);
                        decode_insn(&aboveInst, address);
                        if (aboveInst.itype == NN_mov && aboveInst.ops[0].type == o_reg &&
                            aboveInst.ops[0].reg == insn.ops[0].reg &&
                            aboveInst.ops[1].type == o_phrase) {
                            found_src_reg = true;
                            src_reg = aboveInst.ops[1].reg;
                        }
                    }

                    bool found_push = false;

                    // 15 instructions above
                    address = ea;
                    for (auto j = 0; j < 15; j++) {
                        address = prev_head(address, startAddress);
                        decode_insn(&aboveInst, address);
                        if (aboveInst.itype == NN_push) {
                            if (aboveInst.ops[0].type == o_reg &&
                                aboveInst.ops[0].reg == src_reg) {
                                found_push = true;
                            }
                            break;
                        }
                    }

                    if (found_src_reg && found_push) {
                        std::string cmt = getPeiSvcComment(
                            static_cast<uint32_t>(pei_services_table[j].offset));
                        set_cmt(ea, cmt.c_str(), true);
                        // opStroff(ea, "EFI_PEI_SERVICES");
                        msg("[%s] 0x%016llX : %s\n", plugin_name,
                            static_cast<uint64_t>(ea),
                            static_cast<char *>(pei_services_table[j].name));
                        peiServicesAll[static_cast<std::string>(
                                           pei_services_table[j].name)]
                            .push_back(ea);
                        json psItem;
                        psItem["address"] = ea;
                        psItem["service_name"] =
                            static_cast<std::string>(pei_services_table[j].name);
                        psItem["table_name"] =
                            static_cast<std::string>("EFI_PEI_SERVICES");
                        psItem["offset"] = pei_services_table[j].offset;

                        // add code addresses for arguments
                        eavec_t args;
                        get_arg_addrs(&args, ea);
                        psItem["args"] = args;

                        if (find(allServices.begin(), allServices.end(), psItem) ==
                            allServices.end()) {
                            allServices.push_back(psItem);
                        }
                    }
                    break;
                }
            }
        }
    }
}

//--------------------------------------------------------------------------
// Get all EFI_PEI_READ_ONLY_VARIABLE2_PPI (GetVariable, NextVariableName)
void EfiAnalysis::EfiAnalyzer::getAllVariablePPICallsX86() {
    msg("[%s] Variable PPI calls finding from 0x%016llX to 0x%016llX (all)\n",
        plugin_name, static_cast<uint64_t>(startAddress),
        static_cast<uint64_t>(endAddress));
    ea_t ea = startAddress;
    insn_t insn;
    auto found = false;
    while (ea <= endAddress) {
        ea = next_head(ea, BADADDR);
        decode_insn(&insn, ea);
        if (insn.itype == NN_callni && insn.ops[0].type == o_phrase) {
            for (int j = 0; j < variable_ppi_table_size; j++) {
                if (insn.ops[0].addr ==
                    static_cast<uint32_t>(variable_ppi_table[j].offset)) {
                    uint16_t ppi_reg = insn.ops[0].reg;
                    insn_t aboveInst;
                    ea_t address = ea;
                    bool found_push = false;

                    for (auto j = 0; j < 15; j++) {
                        address = prev_head(address, startAddress);
                        decode_insn(&aboveInst, address);
                        if (aboveInst.itype == NN_push) {
                            if (aboveInst.ops[0].type == o_reg &&
                                aboveInst.ops[0].reg == ppi_reg) {
                                found_push = true;
                            }
                            break;
                        }
                    }

                    if (found_push) {
                        std::string cmt = getPPICallComment(
                            static_cast<uint32_t>(variable_ppi_table[j].offset),
                            static_cast<std::string>(variable_ppi_name));
                        set_cmt(ea, cmt.c_str(), true);
                        opStroff(ea, "EFI_PEI_READ_ONLY_VARIABLE2_PPI");
                        msg("[%s] 0x%016llX : %s\n", plugin_name,
                            static_cast<uint64_t>(ea),
                            static_cast<char *>(variable_ppi_table[j].name));
                        std::string ppi_call =
                            static_cast<std::string>(variable_ppi_name) + "." +
                            static_cast<std::string>(variable_ppi_table[j].name);
                        ppiCallsAll[ppi_call].push_back(ea);

                        // Injecting PPI call as service
                        json ppiItem;
                        ppiItem["address"] = ea;
                        ppiItem["service_name"] = ppi_call;
                        ppiItem["table_name"] =
                            static_cast<std::string>("EFI_PEI_READ_ONLY_VARIABLE2_PPI");
                        ppiItem["offset"] = variable_ppi_table[j].offset;

                        // add code addresses for arguments
                        eavec_t args;
                        get_arg_addrs(&args, ea);
                        ppiItem["args"] = args;

                        if (find(allServices.begin(), allServices.end(), ppiItem) ==
                            allServices.end()) {
                            allServices.push_back(ppiItem);
                        }
                    }
                    break;
                }
            }
        }
    }
}

//--------------------------------------------------------------------------
// Get PPI names for X86 PEI modules
void EfiAnalysis::EfiAnalyzer::getPpiNamesX86() {
    msg("[%s] PPI finding (PEI services)\n", plugin_name);
    ea_t start = startAddress;
    segment_t *seg_info = get_segm_by_name(".text");
    if (seg_info != nullptr) {
        start = seg_info->start_ea;
    }
    for (int i = 0; i < pei_services_table_size; i++) {
        if (pei_services_table[i].ppi_guid_push_number == PUSH_NONE ||
            !peiServicesAll.contains(pei_services_table[i].name)) {
            continue;
        }

        std::vector<ea_t> addrs = peiServicesAll[pei_services_table[i].name];

        // for each PEI service
        for (auto ea : addrs) {
            ea_t address = ea;

            insn_t insn;
            ea_t guidCodeAddress = 0;
            ea_t guidDataAddress = 0;
            auto found = false;

            uint16_t pushCounter = 0;
            msg("[%s] looking for PPIs in the 0x%016llX area (push number: %d)\n",
                plugin_name, static_cast<uint64_t>(address),
                pei_services_table[i].ppi_guid_push_number);

            // Check current basic block
            while (true) {
                address = prev_head(address, startAddress);
                decode_insn(&insn, address);

                if (insn.itype == NN_push) {
                    pushCounter += 1;
                }

                if (pushCounter == pei_services_table[i].ppi_guid_push_number &&
                    insn.ops[0].type == o_imm &&
                    (insn.ops[0].value & 0xffffffff) >= start &&
                    insn.ops[0].value != BADADDR) { // found "push gGuid" insn
                    guidCodeAddress = address;
                    guidDataAddress = insn.ops[0].value & 0xffffffff;
                    found = true;
                    break;
                }

                // Exit loop if end of previous basic block found
                if (is_basic_block_end(insn, false)) {
                    break;
                }
            }

            msg("[%s] GUID address: 0x%016llX\n", plugin_name,
                static_cast<uint64_t>(guidDataAddress));

            if (found) {
                msg("[%s] found PPI GUID parameter at 0x%016llX\n", plugin_name,
                    static_cast<uint64_t>(guidCodeAddress));
                auto guid = getGuidByAddr(guidDataAddress);
                if (!checkGuid(guid)) {
                    msg("[%s] Incorrect GUID at 0x%016llX\n", plugin_name,
                        static_cast<uint64_t>(guidCodeAddress));
                    continue;
                }

                // get PPI item
                json ppiItem;
                ppiItem["address"] = guidDataAddress;
                ppiItem["xref"] = guidCodeAddress;
                ppiItem["service"] = pei_services_table[i].name;
                ppiItem["guid"] = getGuidFromValue(guid);
                ppiItem["module"] = std::string("Current");

                // find GUID name
                auto it = dbProtocolsMap.find(guid);
                if (it != dbProtocolsMap.end()) {
                    std::string name = it->second;
                    ppiItem["ppi_name"] = name;

                    // check if item already exists
                    if (find(allPPIs.begin(), allPPIs.end(), ppiItem) == allPPIs.end()) {
                        allPPIs.push_back(ppiItem);
                    }
                    continue;
                }

                // proprietary PPI
                if (ppiItem["ppi_name"].is_null()) {
                    ppiItem["ppi_name"] = "ProprietaryPpi";

                    // check if item already exists
                    if (find(allPPIs.begin(), allPPIs.end(), ppiItem) == allPPIs.end()) {
                        allPPIs.push_back(ppiItem);
                    }
                    continue;
                }
            }
        }
    }
}

//--------------------------------------------------------------------------
// Get boot services by protocols for X64 modules
void EfiAnalysis::EfiAnalyzer::getProtBootServicesX64() {
    insn_t insn;
    for (auto seg : textSegments) {
        segment_t *s = seg;
        msg("[%s] BootServices finding from 0x%016llX to 0x%016llX (protocols)\n",
            plugin_name, static_cast<uint64_t>(s->start_ea),
            static_cast<uint64_t>(s->end_ea));
        ea_t ea = s->start_ea;
        uint16_t bsRegister = 0;
        while (ea <= s->end_ea) {
            ea = next_head(ea, endAddress);
            decode_insn(&insn, ea);
            if (insn.itype == NN_callni && insn.ops[0].reg == REG_RAX) {
                for (auto i = 0; i < bootServicesTable64Length; i++) {
                    if (insn.ops[0].addr ==
                        static_cast<uint32_t>(bootServicesTable64[i].offset)) {

                        // additional check for gBS->RegisterProtocolNotify
                        // (can be confused with gSmst->SmmInstallProtocolInterface)
                        if (static_cast<uint32_t>(bootServicesTable64[i].offset) ==
                            RegisterProtocolNotifyOffset64) {
                            if (!bootServiceProtCheck(ea)) {
                                break;
                            }
                        }

                        std::string cmt = getBsComment(
                            static_cast<uint32_t>(bootServicesTable64[i].offset), X64);
                        set_cmt(ea, cmt.c_str(), true);
                        opStroff(ea, "EFI_BOOT_SERVICES");
                        msg("[%s] 0x%016llX : %s\n", plugin_name,
                            static_cast<uint64_t>(ea),
                            static_cast<char *>(bootServicesTable64[i].service_name));
                        bootServices[static_cast<std::string>(
                                         bootServicesTable64[i].service_name)]
                            .push_back(ea);

                        // add item to allBootServices
                        json bsItem;
                        bsItem["address"] = ea;
                        bsItem["service_name"] =
                            static_cast<std::string>(bootServicesTable64[i].service_name);
                        bsItem["table_name"] =
                            static_cast<std::string>("EFI_BOOT_SERVICES");
                        bsItem["offset"] = bootServicesTable64[i].offset;

                        // add code addresses for arguments
                        eavec_t args;
                        get_arg_addrs(&args, ea);
                        bsItem["args"] = args;

                        if (find(allServices.begin(), allServices.end(), bsItem) ==
                            allServices.end()) {
                            allServices.push_back(bsItem);
                        }
                        break;
                    }
                }
            }
        }
    }
}

//--------------------------------------------------------------------------
// Get boot services by protocols for X86 modules
void EfiAnalysis::EfiAnalyzer::getProtBootServicesX86() {
    msg("[%s] BootServices finding from 0x%016llX to 0x%016llX (protocols)\n",
        plugin_name, static_cast<uint64_t>(startAddress),
        static_cast<uint64_t>(endAddress));
    ea_t ea = startAddress;
    insn_t insn;
    uint16_t bsRegister = 0;
    while (ea <= endAddress) {
        ea = next_head(ea, endAddress);
        decode_insn(&insn, ea);
        if (insn.itype == NN_callni && insn.ops[0].reg == REG_EAX) {
            for (auto i = 0; i < bootServicesTable32Length; i++) {
                if (insn.ops[0].addr ==
                    static_cast<uint32_t>(bootServicesTable32[i].offset)) {
                    std::string cmt = getBsComment(
                        static_cast<uint32_t>(bootServicesTable32[i].offset), X86);
                    set_cmt(ea, cmt.c_str(), true);
                    opStroff(ea, "EFI_BOOT_SERVICES");
                    msg("[%s] 0x%016llX : %s\n", plugin_name, static_cast<uint64_t>(ea),
                        static_cast<char *>(bootServicesTable32[i].service_name));
                    bootServices[static_cast<std::string>(
                                     bootServicesTable32[i].service_name)]
                        .push_back(ea);

                    // add item to allBootServices
                    json bsItem;
                    bsItem["address"] = ea;
                    bsItem["service_name"] =
                        static_cast<std::string>(bootServicesTable32[i].service_name);
                    bsItem["table_name"] = static_cast<std::string>("EFI_BOOT_SERVICES");
                    bsItem["offset"] = bootServicesTable32[i].offset;

                    // add code addresses for arguments
                    eavec_t args;
                    get_arg_addrs(&args, ea);
                    bsItem["args"] = args;

                    if (find(allServices.begin(), allServices.end(), bsItem) ==
                        allServices.end()) {
                        allServices.push_back(bsItem);
                    }
                    break;
                }
            }
        }
    }
}

//--------------------------------------------------------------------------
// find other addresses of global gBS vars for X64 modules
void EfiAnalysis::EfiAnalyzer::findOtherBsTablesX64() {
    msg("[%s] Finding of other addresses of global gBS variables\n", plugin_name);
    for (auto s : allServices) {
        json jService = s;
        std::string table_name = jService["table_name"];
        if (table_name.compare(static_cast<std::string>("EFI_BOOT_SERVICES"))) {
            continue;
        }
        auto offset = static_cast<uint32_t>(jService["offset"]);
        if (offset < 0xf0) {
            continue;
        }
        ea_t addr = static_cast<ea_t>(jService["address"]);
        msg("[%s] current service: 0x%016llX\n", plugin_name,
            static_cast<uint64_t>(addr));
        ea_t addrBs = findUnknownBsVarX64(addr);
        if (!addrBs || !(find(gBsList.begin(), gBsList.end(), addrBs) == gBsList.end())) {
            continue;
        }
        msg("[%s] found BootServices table at 0x%016llX, address = 0x%016llX\n",
            plugin_name, static_cast<uint64_t>(addr), static_cast<uint64_t>(addrBs));
        setPtrTypeAndName(addrBs, "gBS", "EFI_BOOT_SERVICES");
        if (find(gRtList.begin(), gRtList.end(), addrBs) == gRtList.end()) {
            gBsList.push_back(addrBs);
        }
    }
}

bool EfiAnalysis::EfiAnalyzer::AddProtocol(std::string serviceName, ea_t guidAddress,
                                           ea_t xrefAddress, ea_t callAddress) {

    if (arch != UEFI && guidAddress >= startAddress && guidAddress <= endAddress) {
        msg("[%s] wrong service call detection: 0x%016llX\n", plugin_name, callAddress);
        return false; // filter FP
    }

    json protocol;
    auto guid = getGuidByAddr(guidAddress);
    protocol["address"] = guidAddress;
    protocol["xref"] = xrefAddress;
    protocol["service"] = serviceName;
    protocol["guid"] = getGuidFromValue(guid);
    protocol["ea"] = callAddress;

    qstring moduleName("Current");
    if (getInputFileType() == UEFI) {
        moduleName = getModuleNameLoader(callAddress);
    }
    protocol["module"] = static_cast<std::string>(moduleName.c_str());

    // find GUID name
    auto it = dbProtocolsMap.find(guid);
    if (it != dbProtocolsMap.end()) {
        std::string name = it->second;
        protocol["prot_name"] = name;
    } else {
        protocol["prot_name"] = "ProprietaryProtocol";
    }
    if (!jsonInVec(allProtocols, protocol)) {
        allProtocols.push_back(protocol);
    }
    return true;
}

//--------------------------------------------------------------------------
// Extract protocols from InstallMultipleProtocolInterfaces service call
bool EfiAnalysis::EfiAnalyzer::InstallMultipleProtocolInterfacesHandler() {
    std::vector<ea_t> addrs = bootServices["InstallMultipleProtocolInterfaces"];
    std::map<ea_t, ea_t> stack_params;
    insn_t insn;

    for (auto ea : addrs) {
        ea_t address = ea;
        bool found = false;
        bool check_stack = true;
        ea_t handle_arg = BADADDR;
        stack_params.clear();

        // Check current basic block
        while (true) {
            address = prev_head(address, startAddress);
            decode_insn(&insn, address);

            if (!check_stack && found) {
                break; // installed only one protocol
            }

            // Exit loop if end of previous basic block found
            if (is_basic_block_end(insn, false)) {
                break;
            }

            // Get handle stack/data parameter
            if (handle_arg == BADADDR && insn.itype == NN_lea &&
                insn.ops[0].reg == REG_RCX) {
                switch (insn.ops[1].type) {
                case o_displ:
                    if (insn.ops[1].reg == REG_RSP || insn.ops[1].reg == REG_RBP) {
                        handle_arg = insn.ops[1].addr;
                    }
                    break;
                case o_mem:
                    handle_arg = insn.ops[1].addr;
                    break;
                }
            }

            // Exit from loop if found last argument (NULL)
            if (insn.itype == NN_xor && insn.ops[0].reg == REG_R9 &&
                insn.ops[1].reg == REG_R9) {
                check_stack = false;
            }

            if (insn.itype == NN_and && insn.ops[0].type == o_displ &&
                (insn.ops[0].reg == REG_RSP || insn.ops[0].reg == REG_RBP) &&
                insn.ops[0].addr != handle_arg && insn.ops[1].type == o_imm &&
                insn.ops[1].value == 0) {
                check_stack = false;
                break;
            }

            if (insn.itype == NN_lea && insn.ops[0].type == o_reg &&
                insn.ops[1].type == o_mem) {

                switch (insn.ops[0].reg) {
                case REG_RDX:
                case REG_R9:
                    AddProtocol("InstallMultipleProtocolInterfaces", insn.ops[1].addr,
                                address, ea);
                    found = true;
                    break;
                case REG_RAX:
                    stack_params.insert(std::make_pair(address, insn.ops[1].addr));
                    break;
                }
            }
        }

        // Enumerate all stack params
        auto index = 0;
        for (auto const &param : stack_params) {
            if (index++ % 2) {
                AddProtocol("InstallMultipleProtocolInterfaces", param.second,
                            param.first, ea);
            }
        }
    }

    return true;
}

//--------------------------------------------------------------------------
// Get boot services protocols names for X64 modules
void EfiAnalysis::EfiAnalyzer::getBsProtNamesX64() {
    if (!textSegments.size()) {
        return;
    }
    segment_t *s = textSegments.at(0);
    ea_t start = s->start_ea;
    msg("[%s] protocols finding (boot services, start address = 0x%016llX)\n",
        plugin_name, static_cast<uint64_t>(start));

    InstallMultipleProtocolInterfacesHandler();
    for (int i = 0; i < bootServicesTable64Length; i++) {

        if (bootServicesTable64[i].offset == InstallMultipleProtocolInterfacesOffset64) {
            // Handle InstallMultipleProtocolInterfaces separately
            continue;
        }

        std::vector<ea_t> addrs = bootServices[bootServicesTable64[i].service_name];
        for (auto ea : addrs) {
            ea_t address = ea;
            msg("[%s] looking for protocols in the 0x%016llX area\n", plugin_name,
                static_cast<uint64_t>(address));
            insn_t insn;
            ea_t guidCodeAddress = 0;
            ea_t guidDataAddress = 0;
            auto found = false;

            // check current basic block
            while (true) {
                address = prev_head(address, startAddress);
                decode_insn(&insn, address);

                // exit from loop if end of previous basic block found
                if (is_basic_block_end(insn, false)) {
                    break;
                }

                if (insn.itype == NN_lea && insn.ops[0].type == o_reg &&
                    insn.ops[0].reg == bootServicesTable64[i].reg &&
                    insn.ops[1].type == o_mem) {
                    guidCodeAddress = address;
                    guidDataAddress = insn.ops[1].addr;
                    if (insn.ops[1].addr > start && insn.ops[1].addr != BADADDR) {
                        found = true;
                        break;
                    }
                }

                if (insn.itype == NN_mov && insn.ops[0].type == o_reg &&
                    insn.ops[0].reg == bootServicesTable64[i].reg &&
                    insn.ops[1].type == o_imm) {
                    guidCodeAddress = address;
                    guidDataAddress = insn.ops[1].value;
                    if (insn.ops[1].value > start && insn.ops[1].value != BADADDR) {
                        found = true;
                        break;
                    }
                }
            }

            if (found) {
                msg("[%s] getBsProtNamesX64: found protocol GUID parameter at "
                    "0x%016llX\n",
                    plugin_name, static_cast<uint64_t>(guidCodeAddress));
                auto guid = getGuidByAddr(guidDataAddress);
                if (!checkGuid(guid)) {
                    msg("[%s] Incorrect GUID at 0x%016llX\n", plugin_name,
                        static_cast<uint64_t>(guidCodeAddress));
                    continue;
                }

                AddProtocol(bootServicesTable64[i].service_name, guidDataAddress,
                            guidCodeAddress, ea);
            }
        }
    }
}

//--------------------------------------------------------------------------
// Get boot services protocols names for X86 modules
void EfiAnalysis::EfiAnalyzer::getBsProtNamesX86() {
    msg("[%s] protocols finding (boot services)\n", plugin_name);
    ea_t start = startAddress;
    segment_t *seg_info = get_segm_by_name(".text");
    if (seg_info != nullptr) {
        start = seg_info->start_ea;
    }
    for (int i = 0; i < bootServicesTable32Length; i++) {
        std::vector<ea_t> addrs = bootServices[bootServicesTable32[i].service_name];

        // for each boot service
        for (auto ea : addrs) {
            ea_t address = ea;
            msg("[%s] looking for protocols in the 0x%016llX area\n", plugin_name,
                static_cast<uint64_t>(address));
            insn_t insn;
            ea_t guidCodeAddress = 0;
            ea_t guidDataAddress = 0;
            auto found = false;
            uint16_t pushNumber = bootServicesTable32[i].push_number;

            // if service is not currently being processed
            if (pushNumber == PUSH_NONE) {
                break;
            }

            // check current basic block
            uint16_t pushCounter = 0;
            while (true) {
                address = prev_head(address, startAddress);
                decode_insn(&insn, address);

                // exit from loop if end of previous basic block found
                if (is_basic_block_end(insn, false)) {
                    break;
                }

                if (insn.itype == NN_push) {
                    pushCounter += 1;
                    if (pushCounter > pushNumber) {
                        break;
                    }
                    if (pushCounter == pushNumber) {
                        guidCodeAddress = address;
                        guidDataAddress = insn.ops[0].value;
                        if (insn.ops[0].value > start && insn.ops[0].value != BADADDR) {
                            found = true;
                            break;
                        }
                    }
                }
            }

            if (found) {
                msg("[%s] getBsProtNamesX86: found protocol GUID parameter at "
                    "0x%016llX\n",
                    plugin_name, static_cast<uint64_t>(guidCodeAddress));
                auto guid = getGuidByAddr(guidDataAddress);
                if (!checkGuid(guid)) {
                    msg("[%s] Incorrect GUID at 0x%016llX\n", plugin_name,
                        static_cast<uint64_t>(guidCodeAddress));
                    continue;
                }

                AddProtocol(bootServicesTable32[i].service_name, guidDataAddress,
                            guidCodeAddress, ea);
            }
        }
    }
}

//--------------------------------------------------------------------------
// Get smm services protocols names for X64 modules
void EfiAnalysis::EfiAnalyzer::getSmmProtNamesX64() {
    if (!textSegments.size()) {
        return;
    }
    segment_t *s = textSegments.at(0);
    ea_t start = s->start_ea;
    msg("[%s] protocols finding (smm services, start address = 0x%016llX)\n", plugin_name,
        static_cast<uint64_t>(start));
    for (int i = 0; i < smmServicesProt64Length; i++) {
        auto addrs = smmServices[smmServicesProt64[i].service_name];

        // for each SMM service
        for (auto ea : addrs) {
            ea_t address = ea;
            msg("[%s] looking for protocols in the 0x%016llX area\n", plugin_name,
                static_cast<uint64_t>(address));
            insn_t insn;
            ea_t guidCodeAddress = 0;
            ea_t guidDataAddress = 0;
            auto found = false;

            // check current basic block
            while (true) {
                address = prev_head(address, startAddress);
                decode_insn(&insn, address);

                // exit from loop if end of previous basic block found
                if (is_basic_block_end(insn, false)) {
                    break;
                }

                if (insn.itype == NN_lea && insn.ops[0].type == o_reg &&
                    insn.ops[0].reg == smmServicesProt64[i].reg) {
                    guidCodeAddress = address;
                    guidDataAddress = insn.ops[1].addr;
                    if (insn.ops[1].addr > start && insn.ops[1].addr != BADADDR) {
                        found = true;
                        break;
                    }
                }
            }

            if (found) {
                msg("[%s] getSmmProtNamesX64: found protocol GUID parameter at "
                    "0x%016llX\n",
                    plugin_name, static_cast<uint64_t>(guidCodeAddress));
                auto guid = getGuidByAddr(guidDataAddress);
                if (!checkGuid(guid)) {
                    msg("[%s] Incorrect GUID at 0x%016llX\n", plugin_name,
                        static_cast<uint64_t>(guidCodeAddress));
                    continue;
                }

                AddProtocol(smmServicesProt64[i].service_name, guidDataAddress,
                            guidCodeAddress, ea);
            }
        }
    }
}

//--------------------------------------------------------------------------
// Mark protocols
void EfiAnalysis::EfiAnalyzer::markInterfaces() {
    msg("[%s] %s marking\n", plugin_name, if_pl);
    for (auto ifItemIt = if_tbl->begin(); ifItemIt != if_tbl->end(); ++ifItemIt) {
        json ifItem = *ifItemIt;
        ea_t address = static_cast<ea_t>(ifItem["address"]);

        // check if guid on this address already marked
        bool marked = false;
        for (auto markedAddress = markedInterfaces.begin();
             markedAddress != markedInterfaces.end(); ++markedAddress) {
            if (*markedAddress == address) {
                marked = true;
                break;
            }
        }

        if (!marked) {
            std::string svcName = static_cast<std::string>(ifItem[if_key]);
            set_name(address, svcName.c_str(), SN_FORCE);
            setGuidType(address);
            std::string comment = "EFI_GUID " + svcName;
            markedInterfaces.push_back(address);
            msg("[%s] address: 0x%016llX, comment: %s\n", plugin_name,
                static_cast<uint64_t>(address), comment.c_str());
        }
    }
}

//--------------------------------------------------------------------------
// Mark GUIDs found in the .data segment
void EfiAnalysis::EfiAnalyzer::markDataGuids() {
    for (auto seg : dataSegments) {
        segment_t *s = seg;
        msg("[%s] marking .data GUIDs from 0x%016llX to 0x%016llX\n", plugin_name,
            static_cast<uint64_t>(s->start_ea), static_cast<uint64_t>(s->end_ea));
        ea_t ea = s->start_ea;
        while (ea != BADADDR && ea <= s->end_ea - 15) {
            if (get_wide_dword(ea) == 0x00000000 || get_wide_dword(ea) == 0xffffffff) {
                ea += 1;
                continue;
            }
            auto guid = getGuidByAddr(ea);

            // find GUID name
            auto it = dbProtocolsMap.find(guid);
            if (it != dbProtocolsMap.end()) {
                std::string guidName = it->second;
                set_name(ea, guidName.c_str(), SN_FORCE);
                setGuidType(ea);

                std::string comment = "EFI_GUID " + guidName;
                msg("[%s] address: 0x%016llX, comment: %s\n", plugin_name,
                    static_cast<uint64_t>(ea), comment.c_str());

                json guid_item;
                guid_item["address"] = ea;
                guid_item["name"] = guidName;
                guid_item["guid"] = getGuidFromValue(guid);
                allGuids.push_back(guid_item);
                dataGuids.push_back(guid_item);
            }
            ea += 1;
        }
    }
}

//--------------------------------------------------------------------------
// Mark GUIDs found in local variables for X64 modules
void EfiAnalysis::EfiAnalyzer::markLocalGuidsX64() {
    for (auto seg : textSegments) {
        segment_t *s = seg;
        ea_t ea = s->start_ea;
        insn_t insn;
        insn_t insn_next;
        msg("[%s] local GUIDs finding from 0x%016llX to 0x%016llX\n", plugin_name,
            static_cast<uint64_t>(s->start_ea), static_cast<uint64_t>(s->end_ea));
        while (ea <= s->end_ea) {
            ea = next_head(ea, BADADDR);
            decode_insn(&insn, ea);

            // check if insn like mov dword ptr [...], data1
            if (!(insn.itype == NN_mov && insn.ops[0].type == o_displ &&
                  insn.ops[1].type == o_imm)) {
                continue;
            }

            // get guid->Data1 value
            uint32_t data1 = static_cast<uint32_t>(insn.ops[1].value);
            if (data1 == 0x00000000 || data1 == 0xffffffff) {
                ea = next_head(ea, BADADDR);
                continue;
            }

            // check 4 insns
            bool exit = false;
            for (auto i = 0; i < 4; i++) {
                auto ea_next = next_head(ea, BADADDR);
                decode_insn(&insn_next, ea_next);
                // check if insn like mov dword ptr [...], data2
                if (insn_next.itype == NN_mov && insn_next.ops[0].type == o_displ &&
                    insn_next.ops[1].type == o_imm) {

                    // get guid->Data2 value
                    uint16_t data2 = static_cast<uint16_t>(insn_next.ops[1].value);
                    if (data2 == 0x0000 || data2 == 0xffff) {
                        ea = next_head(ea, BADADDR);
                        continue;
                    }

                    // found guid->Data1 and guid->Data2 values, try to get
                    // guid name
                    for (auto dbItem = dbProtocols.begin(); dbItem != dbProtocols.end();
                         ++dbItem) {
                        auto guid = dbItem.value();
                        if (data1 == static_cast<uint32_t>(guid[0]) &&
                            data2 == static_cast<uint16_t>(guid[1])) {

                            // mark local GUID
                            std::string comment = "EFI_GUID " + dbItem.key();
                            msg("[%s] address: 0x%016llX, comment: %s\n", plugin_name,
                                static_cast<uint64_t>(ea), comment.c_str());
                            set_cmt(ea, comment.c_str(), true);

                            json guid_item;
                            guid_item["address"] = ea;
                            guid_item["name"] = dbItem.key();
                            guid_item["guid"] = getGuidFromValue(guid);
                            allGuids.push_back(guid_item);
                            stackGuids.push_back(guid_item);
                            exit = true;
                            break;
                        }
                    }
                }
                if (exit) {
                    break;
                }
            }
        }
    }
}

//--------------------------------------------------------------------------
// Search for callouts recursively
void findCalloutRec(func_t *func) {
    insn_t insn;
    for (ea_t ea = func->start_ea; ea < func->end_ea; ea = next_head(ea, BADADDR)) {
        decode_insn(&insn, ea);
        if (insn.itype == NN_call) {
            ea_t nextFuncAddr = insn.ops[0].addr;
            func_t *nextFunc = get_func(nextFuncAddr);
            if (nextFunc) {
                auto it = std::find(excFunctions.begin(), excFunctions.end(), nextFunc);
                if (it == excFunctions.end()) {
                    excFunctions.push_back(nextFunc);
                    findCalloutRec(nextFunc);
                }
            }
        }

        // find callouts with gBS
        for (auto bs : gBsList) {

            // check if insn is mov rax, cs:gBS
            if (insn.itype == NN_mov && insn.ops[0].type == o_reg &&
                insn.ops[1].type == o_mem && insn.ops[1].addr == bs) {
                msg("[%s] SMM callout found: 0x%016llX\n", plugin_name,
                    static_cast<uint64_t>(ea));
                // filter FP
                auto reg = insn.ops[0].reg;
                auto addr = ea;
                insn_t next_insn;
                auto fp = false;
                while (true) {
                    addr = next_head(addr, BADADDR);
                    decode_insn(&next_insn, addr);
                    if ((next_insn.itype == NN_jmpni || next_insn.itype == NN_callni) &&
                        next_insn.ops[0].type == o_displ && next_insn.ops[0].reg == reg &&
                        next_insn.ops[0].addr == FreePoolOffset64) {
                        fp = true;
                        break;
                    }
                    if (is_basic_block_end(next_insn, false)) {
                        break;
                    }
                }
                if (!fp) {
                    calloutAddrs.push_back(ea);
                }
            }
        }

        // find callouts with gRT
        for (auto rt : gRtList) {

            // check if insn is mov rax, cs:gRT
            if (insn.itype == NN_mov && insn.ops[0].type == o_reg &&
                insn.ops[1].type == o_mem && insn.ops[1].addr == rt) {
                msg("[%s] SMM callout found: 0x%016llX\n", plugin_name,
                    static_cast<uint64_t>(ea));
                calloutAddrs.push_back(ea);
            }
        }
    }
}

//--------------------------------------------------------------------------
// Find SmiHandler function inside SMM drivers
void EfiAnalysis::EfiAnalyzer::findSwSmiHandlers() {
    // Prefix: Sw, IoTrap, Sx, Gpi, Usb, StandbyButton, PeriodicTimer, PowerButton
    std::map<EfiGuid *, std::string> types = {
        {&sw_guid2, std::string("Sw")},
        {&sw_guid, std::string("Sw")},
        {&sx_guid2, std::string("Sx")},
        {&sx_guid, std::string("Sx")},
        {&io_trap_guid2, std::string("IoTrap")},
        {&io_trap_guid, std::string("IoTrap")},
        {&gpi_guid2, std::string("Gpi")},
        {&gpi_guid, std::string("Gpi")},
        {&usb_guid2, std::string("Usb")},
        {&usb_guid, std::string("Usb")},
        {&standby_button_guid2, std::string("StandbyButton")},
        {&standby_button_guid, std::string("StandbyButton")},
        {&periodic_timer_guid2, std::string("PeriodicTimer")},
        {&periodic_timer_guid, std::string("PeriodicTimer")},
        {&power_button_guid2, std::string("PowerButton")},
        {&power_button_guid, std::string("PowerButton")},
    };
    for (auto &[guid, prefix] : types) {
        auto res = findSmiHandlersSmmDispatch(*guid, prefix);
        smiHandlers.insert(smiHandlers.end(), res.begin(), res.end());
    }
}

//--------------------------------------------------------------------------
// Find callouts inside SwSmiHandler function:
//  * find SwSmiHandler function
//  * find gBS->service_name and gRT->service_name inside SmiHandler function
bool EfiAnalysis::EfiAnalyzer::findSmmCallout() {
    msg("[%s] Looking for SMM callout\n", plugin_name);
    if (!gBsList.size() && !gRtList.size()) {
        return false;
    }
    if (!smiHandlers.size() && !childSmiHandlers.size()) {
        msg("[%s] can't find a SwSmiHandler functions\n", plugin_name);
        return false;
    }
    for (auto func : smiHandlers) {
        findCalloutRec(func);
    }
    for (auto func : childSmiHandlers) {
        findCalloutRec(func);
    }
    return true;
}

bool EfiAnalysis::EfiAnalyzer::findPPIGetVariableStackOveflow() {
    msg("[%s] Looking for PPI GetVariable buffer overflow, "
        "allServices.size() = %lu\n",
        plugin_name, allServices.size());
    std::vector<ea_t> getVariableServicesCalls;
    std::string getVariableStr("VariablePPI.GetVariable");
    for (auto j_service : allServices) {
        json service = j_service;
        std::string service_name = static_cast<std::string>(service["service_name"]);
        std::string table_name = static_cast<std::string>(service["table_name"]);
        ea_t addr = static_cast<ea_t>(service["address"]);
        if (service_name.compare(getVariableStr) == 0) {
            getVariableServicesCalls.push_back(addr);
        }
    }
    msg("[%s] Finished iterating over allServices, "
        "getVariableServicesCalls.size() = "
        "%lu\n",
        plugin_name, getVariableServicesCalls.size());
    sort(getVariableServicesCalls.begin(), getVariableServicesCalls.end());
    if (getVariableServicesCalls.size() < 2) {
        msg("[%s] less than 2 VariablePPI.GetVariable calls found\n", plugin_name);
        return false;
    }
    ea_t prev_addr = getVariableServicesCalls.at(0);
    for (auto i = 1; i < getVariableServicesCalls.size(); ++i) {
        ea_t curr_addr = getVariableServicesCalls.at(i);
        msg("[%s] VariablePPI.GetVariable_1: 0x%016llX, "
            "VariablePPI.GetVariable_2: "
            "0x%016llX\n",
            plugin_name, static_cast<uint64_t>(prev_addr),
            static_cast<uint64_t>(curr_addr));

        // check code from GetVariable_1 to GetVariable_2
        ea_t ea = next_head(static_cast<ea_t>(prev_addr), BADADDR);
        bool ok = true;
        insn_t insn;
        while (ea < curr_addr) {
            decode_insn(&insn, ea);
            if (insn.itype == NN_callni || insn.itype == NN_call ||
                insn.itype == NN_retn) {
                ok = false;
                break;
            }
            ea = next_head(ea, BADADDR);
        }
        if (ok) {
            bool same_datasize = false;
            uint16_t pushNumber = 5;
            uint16_t pushCounter = 0;
            uint16_t arg5_reg = 0xffff;
            ea_t curr_datasize_addr = 0xffff;
            bool datasize_addr_found = false;
            ea_t address = curr_addr;
            for (auto j = 0; j < 15; j++) {
                address = prev_head(address, startAddress);
                decode_insn(&insn, address);
                if (insn.itype == NN_push) {
                    pushCounter += 1;
                    if (pushCounter == pushNumber) {
                        if (insn.ops[0].type == o_reg) {
                            arg5_reg = insn.ops[0].reg;
                        } else {
                            // if it's not push <reg>, just let the pattern
                            // trigger - for manual review
                            same_datasize = true;
                        }
                        break;
                    }
                }
            }

            if (same_datasize) {
                peiGetVariableOverflow.push_back(curr_addr);
                msg("[%s] overflow can occur here: 0x%016llX\n", plugin_name,
                    static_cast<uint64_t>(curr_addr));
                continue;
            }

            for (auto j = 0; j < 15; j++) {
                address = prev_head(address, startAddress);
                decode_insn(&insn, address);
                if (insn.itype == NN_lea && insn.ops[0].type == o_reg &&
                    insn.ops[0].reg == arg5_reg && insn.ops[1].type == o_displ) {
                    curr_datasize_addr = insn.ops[1].addr;
                    datasize_addr_found = true;
                    break;
                }
            }

            msg("[%s] curr_datasize_addr = 0x%016llx, datasize_addr_found = "
                "%d\n",
                plugin_name, static_cast<uint64_t>(curr_datasize_addr),
                datasize_addr_found);

            if (!datasize_addr_found) {
                // if datasize wasn't found, just let the pattern
                // trigger - for manual review
                peiGetVariableOverflow.push_back(curr_addr);
                msg("[%s] overflow can occur here: 0x%016llX\n", plugin_name,
                    static_cast<uint64_t>(curr_addr));
                continue;
            }

            pushCounter = 0;
            arg5_reg = 0xffff;
            ea_t prev_datasize_addr = 0xffff;
            datasize_addr_found = false;
            address = prev_addr;
            for (auto j = 0; j < 15; j++) {
                address = prev_head(address, startAddress);
                decode_insn(&insn, address);
                if (insn.itype == NN_push) {
                    pushCounter += 1;
                    if (pushCounter == pushNumber) {
                        if (insn.ops[0].type == o_reg) {
                            arg5_reg = insn.ops[0].reg;
                        } else {
                            // if it's not push <reg>, just let the pattern
                            // trigger - for manual review
                            same_datasize = true;
                        }
                        break;
                    }
                }
            }

            if (same_datasize) {
                peiGetVariableOverflow.push_back(curr_addr);
                msg("[%s] overflow can occur here: 0x%016llX\n", plugin_name,
                    static_cast<uint64_t>(curr_addr));
                continue;
            }

            for (auto j = 0; j < 15; j++) {
                address = prev_head(address, startAddress);
                decode_insn(&insn, address);
                if (insn.itype == NN_lea && insn.ops[0].type == o_reg &&
                    insn.ops[0].reg == arg5_reg && insn.ops[1].type == o_displ) {
                    prev_datasize_addr = insn.ops[1].addr;
                    datasize_addr_found = true;
                    break;
                }
            }

            msg("[%s] prev_datasize_addr = 0x%016llX, datasize_addr_found = "
                "%d, "
                "(prev_datasize_addr == curr_datasize_addr) = %d\n",
                plugin_name, static_cast<uint64_t>(prev_datasize_addr),
                datasize_addr_found, (prev_datasize_addr == curr_datasize_addr));

            if (!datasize_addr_found) {
                peiGetVariableOverflow.push_back(curr_addr);
                msg("[%s] overflow can occur here: 0x%016llX\n", plugin_name,
                    static_cast<uint64_t>(curr_addr));
            } else if (prev_datasize_addr == curr_datasize_addr) {
                peiGetVariableOverflow.push_back(curr_addr);
                msg("[%s] overflow can occur here: 0x%016llX "
                    "(prev_datasize_addr == "
                    "curr_datasize_addr)\n",
                    plugin_name, static_cast<uint64_t>(curr_addr));
            }
        }
        prev_addr = curr_addr;
    }
    return (peiGetVariableOverflow.size() > 0);
}

//--------------------------------------------------------------------------
// Find potential stack/heap overflow with double GetVariable calls
bool EfiAnalysis::EfiAnalyzer::findGetVariableOveflow(std::vector<json> allServices) {
    msg("[%s] Looking for GetVariable stack/heap overflow\n", plugin_name);
    std::vector<ea_t> getVariableServicesCalls;
    std::string getVariableStr("GetVariable");
    for (auto j_service : allServices) {
        json service = j_service;
        std::string service_name = static_cast<std::string>(service["service_name"]);
        ea_t addr = static_cast<ea_t>(service["address"]);
        if (service_name.compare(getVariableStr) == 0) {
            getVariableServicesCalls.push_back(addr);
        }
    }
    sort(getVariableServicesCalls.begin(), getVariableServicesCalls.end());
    if (getVariableServicesCalls.size() < 2) {
        msg("[%s] less than 2 GetVariable calls found\n", plugin_name);
        return false;
    }
    ea_t prev_addr = getVariableServicesCalls.at(0);
    ea_t ea;
    insn_t insn;
    for (auto i = 1; i < getVariableServicesCalls.size(); ++i) {
        ea_t curr_addr = getVariableServicesCalls.at(i);
        msg("[%s] GetVariable_1: 0x%016llX, GetVariable_2: 0x%016llX\n", plugin_name,
            static_cast<uint64_t>(prev_addr), static_cast<uint64_t>(curr_addr));

        // get dataSizeStackAddr
        int dataSizeStackAddr = 0;
        uint16 dataSizeOpReg = 0xFF;
        ea = prev_head(static_cast<ea_t>(curr_addr), 0);
        for (auto i = 0; i < 10; ++i) {
            decode_insn(&insn, ea);
            if (insn.itype == NN_lea && insn.ops[0].type == o_reg &&
                insn.ops[0].reg == REG_R9) {
                dataSizeStackAddr = insn.ops[1].addr;
                dataSizeOpReg = insn.ops[1].phrase;
                break;
            }
            ea = prev_head(ea, 0);
        }

        // check code from GetVariable_1 to GetVariable_2
        ea = next_head(static_cast<ea_t>(prev_addr), BADADDR);
        bool ok = true;
        size_t dataSizeUseCounter = 0;
        while (ea < curr_addr) {
            decode_insn(&insn, ea);
            if (((dataSizeStackAddr == insn.ops[0].addr) && (dataSizeOpReg == insn.ops[0].phrase)) ||
                ((dataSizeStackAddr == insn.ops[1].addr) && (dataSizeOpReg == insn.ops[1].phrase))){
                dataSizeUseCounter++;
            }
            if ((insn.itype == NN_callni && insn.ops[0].addr == 0x48) || insn.itype == NN_retn ||
                dataSizeUseCounter > 1) {
                ok = false;
                break;
            }
            ea = next_head(ea, BADADDR);
        }
        if (ok) {

            // check for wrong GetVariable detection
            bool wrong_detection = false;
            ea = prev_head(static_cast<ea_t>(curr_addr), 0);
            for (auto i = 0; i < 8; ++i) {
                decode_insn(&insn, ea);
                if (insn.itype == NN_mov && insn.ops[0].type == o_reg &&
                    insn.ops[1].type == o_mem) {
                    ea_t mem_addr = static_cast<ea_t>(insn.ops[1].addr);
                    if (find(gBsList.begin(), gBsList.end(), mem_addr) != gBsList.end()) {
                        wrong_detection = true;
                        break;
                    }
                }
                ea = prev_head(ea, 0);
            }

            // check DataSize initialization
            bool init_ok = false;
            decode_insn(&insn, prev_head(curr_addr, 0));
            if (!wrong_detection &&
                !(insn.itype == NN_mov && insn.ops[0].type == o_displ &&
                  (insn.ops[0].phrase == REG_RSP || insn.ops[0].phrase == REG_RBP) && (insn.ops[0].addr == dataSizeStackAddr))) {
                init_ok = true;
            }

            // check that the DataSize argument variable is the same for two
            // calls
            if (init_ok) {
                ea = prev_head(static_cast<ea_t>(prev_addr), 0);
                //for (auto i = 0; i < 10; ++i) {
                func_t *func_start = get_func(ea);
                if (func_start == nullptr){
                    return (getVariableOverflow.size() > 0);
                }
                uint16 stack_base_reg = 0xFF;
                decode_insn(&insn, func_start->start_ea);
                if (insn.itype == NN_mov && insn.ops[1].is_reg(REG_RSP) && insn.ops[0].type == o_reg){
                    stack_base_reg = insn.ops[0].reg;
                }
                
                while (ea >= func_start->start_ea){
                    decode_insn(&insn, ea);
                    if (insn.itype == NN_call)
                        break;
                    if (insn.itype == NN_lea && insn.ops[0].type == o_reg &&
                        insn.ops[0].reg == REG_R9) {
                        
                        ea_t stack_addr = insn.ops[1].addr;
                        sval_t sval = get_spd(func_start, ea)*-1;

                        if ((insn.ops[1].phrase == stack_base_reg && (sval + stack_addr) == dataSizeStackAddr) ||
                           (dataSizeStackAddr == insn.ops[1].addr)) {
                            getVariableOverflow.push_back(curr_addr);
                            msg("[%s] \toverflow can occur here: 0x%016llX\n",
                                plugin_name, static_cast<uint64_t>(curr_addr));
                            break;
                        }
                    }
                    ea = prev_head(ea, 0);
                }
            }
        }
        prev_addr = curr_addr;
    }
    return (getVariableOverflow.size() > 0);
}

//--------------------------------------------------------------------------
// Find potential stack/heap overflow with double SmmGetVariable calls
bool EfiAnalysis::EfiAnalyzer::findSmmGetVariableOveflow() {
    msg("[%s] Looking for SmmGetVariable stack/heap overflow\n", plugin_name);
    std::vector<ea_t> smmGetVariableCalls =
        findSmmGetVariableCalls(dataSegments, &allServices);
    sort(smmGetVariableCalls.begin(), smmGetVariableCalls.end());
    if (smmGetVariableCalls.size() < 2) {
        msg("[%s] less than 2 GetVariable calls found\n", plugin_name);
        return false;
    }
    ea_t prev_addr = smmGetVariableCalls.at(0);
    ea_t ea;
    insn_t insn;
    for (auto i = 1; i < smmGetVariableCalls.size(); ++i) {
        ea_t curr_addr = smmGetVariableCalls.at(i);
        msg("[%s] SmmGetVariable_1: 0x%016llX, SmmGetVariable_2: 0x%016llX\n",
            plugin_name, static_cast<uint64_t>(prev_addr),
            static_cast<uint64_t>(curr_addr));

        // get dataSizeStackAddr
        uint32_t dataSizeStackAddr = 0xffffffff;
        ea = prev_head(static_cast<ea_t>(curr_addr), 0);
        for (auto i = 0; i < 10; ++i) {
            decode_insn(&insn, ea);
            if (insn.itype == NN_lea && insn.ops[0].type == o_reg &&
                insn.ops[0].reg == REG_R9) {
                dataSizeStackAddr = insn.ops[1].addr;
                break;
            }
            ea = prev_head(ea, 0);
        }

        // check code from SmmGetVariable_1 to SmmGetVariable_2
        ea = next_head(static_cast<ea_t>(prev_addr), BADADDR);
        bool ok = true;
        size_t dataSizeUseCounter = 0;
        while (ea < curr_addr) {
            decode_insn(&insn, ea);
            if (insn.itype == NN_callni || insn.itype == NN_retn) {
                ok = false;
                break;
            }
            ea = next_head(ea, BADADDR);
        }

        if (ok) {

            // check DataSize initialization
            bool init_ok = false;
            decode_insn(&insn, prev_head(curr_addr, 0));
            if (!(insn.itype == NN_mov && insn.ops[0].type == o_displ &&
                  (insn.ops[0].phrase == REG_RSP || insn.ops[0].phrase == REG_RBP))) {
                init_ok = true;
            }

            // check that the DataSize argument variable is the same for two
            // calls
            if (init_ok) {
                ea = prev_head(static_cast<ea_t>(prev_addr), 0);
                for (auto i = 0; i < 10; ++i) {
                    decode_insn(&insn, ea);
                    if (insn.itype == NN_lea && insn.ops[0].type == o_reg &&
                        insn.ops[0].reg == REG_R9) {
                        if (dataSizeStackAddr == insn.ops[1].addr) {
                            smmGetVariableOverflow.push_back(curr_addr);
                            msg("[%s] \toverflow can occur here: 0x%016llX\n",
                                plugin_name, static_cast<uint64_t>(curr_addr));
                            break;
                        }
                        msg("[%s] \tDataSize argument variable is not the "
                            "same: 0x%016llX\n",
                            plugin_name, static_cast<uint64_t>(curr_addr));
                    }
                    ea = prev_head(ea, 0);
                }
            }
        }
        prev_addr = curr_addr;
    }
    return (smmGetVariableOverflow.size() > 0);
}

bool EfiAnalysis::EfiAnalyzer::AnalyzeVariableService(ea_t ea, std::string service_str) {
    msg("[%s] %s call: 0x%016llX\n", plugin_name, service_str.c_str(),
        static_cast<uint64_t>(ea));
    json item;
    item["addr"] = ea;
    insn_t insn;
    bool name_found = false;
    bool guid_found = false;
    func_t *f = get_func(ea);
    if (f == nullptr) {
        return false;
    }
    eavec_t args;
    get_arg_addrs(&args, ea);
    if (args.size() < 3) {
        return false;
    }

    auto addr = args[0]; // Get VariableName
    decode_insn(&insn, addr);
    if (insn.itype == NN_lea && insn.ops[0].type == o_reg && insn.ops[0].reg == REG_RCX &&
        insn.ops[1].type == o_mem) {
        msg("[%s]  VariableName address: 0x%016llX\n", plugin_name,
            static_cast<uint64_t>(insn.ops[1].addr));
        std::string var_name = getWideString(insn.ops[1].addr);
        msg("[%s]  VariableName: %s\n", plugin_name, var_name.c_str());
        item["VariableName"] = var_name;
        name_found = true;
    }

    addr = args[1]; // Get VendorGuid
    decode_insn(&insn, addr);
    // If GUID is global variable
    if (!guid_found && insn.itype == NN_lea && insn.ops[0].type == o_reg &&
        insn.ops[0].reg == REG_RDX && insn.ops[1].type == o_mem) {
        msg("[%s]  VendorGuid address (global): 0x%016llX\n", plugin_name,
            static_cast<uint64_t>(insn.ops[1].addr));
        EfiGuid guid = getGlobalGuid(insn.ops[1].addr);
        msg("[%s]  GUID: %s\n", plugin_name, guid.to_string().c_str());
        item["VendorGuid"] = guid.to_string();
        guid_found = true;
    }
    // If GUID is local variable
    if (!guid_found && insn.itype == NN_lea && insn.ops[0].type == o_reg &&
        insn.ops[0].reg == REG_RDX && insn.ops[1].type == o_displ) {
        switch (insn.ops[1].reg) {
        case REG_RBP: {
            msg("[%s]  VendorGuid address (regarding to RBP): 0x%016llX\n", plugin_name,
                static_cast<uint64_t>(insn.ops[1].addr));
            EfiGuid guid = getStackGuid(f, insn.ops[1].addr);
            msg("[%s]  GUID: %s\n", plugin_name, guid.to_string().c_str());
            item["VendorGuid"] = guid.to_string();
            guid_found = true;
        }
        case REG_RSP: {
            msg("[%s]  VendorGuid address (regarding to RSP): 0x%016llX\n", plugin_name,
                static_cast<uint64_t>(insn.ops[1].addr));
            EfiGuid guid = getStackGuid(f, insn.ops[1].addr);
            msg("[%s]  GUID: %s\n", plugin_name, guid.to_string().c_str());
            item["VendorGuid"] = guid.to_string();
            guid_found = true;
        }
        }
    }

    std::map<uint8_t, std::string> attributes_defs = {
        {0x00000001, std::string("NON_VOLATILE")},
        {0x00000002, std::string("BOOTSERVICE_ACCESS")},
        {0x00000004, std::string("RUNTIME_ACCESS")},
        {0x00000008, std::string("HARDWARE_ERROR_RECORD")},
        {0x00000010, std::string("AUTHENTICATED_WRITE_ACCESS")}};

    addr = args[2]; // Get Attributes
    decode_insn(&insn, addr);
    if (insn.itype == NN_xor && insn.ops[0].type == o_reg && insn.ops[1].type == o_reg &&
        insn.ops[0].reg == insn.ops[1].reg && insn.ops[0].reg == REG_R8) {
        item["Attributes"] = 0;
        std::string attributes_hr = std::string("No attributes");
        item["AttributesHumanReadable"] = attributes_hr;
        msg("[%s]  Attributes: %d (%s)\n", plugin_name, 0, attributes_hr.c_str());
    } else {
        // Extract attributes with Hex-Rays SDK
        auto res = VariablesInfoExtractAll(f, ea);
        item["Attributes"] = res;
        std::string attributes_hr = std::string();
        if (res == 0xff) {
            attributes_hr = std::string("Unknown attributes");
        } else {
            for (auto &[attr, attr_def] : attributes_defs) {
                if (res & attr & 0x0f) {
                    attributes_hr += attr_def + std::string(" | ");
                }
            }
            if (attributes_hr.size() >= 3) { // remove the last operation OR
                attributes_hr = attributes_hr.substr(0, attributes_hr.size() - 3);
            }
        }
        item["AttributesHumanReadable"] = attributes_hr;
        msg("[%s]  Attributes: %d (%s)\n", plugin_name, res, attributes_hr.c_str());
    }

    if (name_found && guid_found) { // if only name or only GUID found, it will
                                    // now saved (check the logs)
        item["service"] = service_str;
        nvramVariables.push_back(item);
    }

    return true;
}

bool EfiAnalysis::EfiAnalyzer::analyzeNvramVariables() {
    msg("[%s] Get NVRAM variables information\n", plugin_name);
    std::vector<std::string> nvram_services = {"GetVariable", "SetVariable"};
    for (auto service_str : nvram_services) {
        std::vector<ea_t> var_services;
        for (auto j_service : allServices) {
            json service = j_service;
            std::string service_name = static_cast<std::string>(service["service_name"]);
            ea_t addr = static_cast<ea_t>(service["address"]);
            if (!service_name.compare(service_str)) {
                var_services.push_back(addr);
            }
        }
        sort(var_services.begin(), var_services.end());
        for (auto ea : var_services) {
            AnalyzeVariableService(ea, service_str);
        }

        for (auto ea : g_smm_get_variable_calls) {
            AnalyzeVariableService(ea, "EFI_SMM_VARIABLE_PROTOCOL::SmmGetVariable");
        }

        for (auto ea : g_smm_set_variable_calls) {
            AnalyzeVariableService(ea, "EFI_SMM_VARIABLE_PROTOCOL::SmmSetVariable");
        }
    }
    return true;
}

//--------------------------------------------------------------------------
// Resolve EFI_SMM_CPU_PROTOCOL
bool EfiAnalysis::EfiAnalyzer::efiSmmCpuProtocolResolver() {
    readSaveStateCalls = resolveEfiSmmCpuProtocol(stackGuids, dataGuids, &allServices);
    return true;
}

//--------------------------------------------------------------------------
// Dump all info to JSON file
void EfiAnalysis::EfiAnalyzer::dumpInfo() {
    json info;
    if (gStList.size()) {
        info["gStList"] = gStList;
    }
    if (gBsList.size()) {
        info["gBsList"] = gBsList;
    }
    if (gRtList.size()) {
        info["gRtList"] = gRtList;
    }
    if (gSmstList.size()) {
        info["gSmstList"] = gSmstList;
    }
    if (gImageHandleList.size()) {
        info["gImageHandleList"] = gImageHandleList;
    }
    if (allPPIs.size()) {
        info["allPPIs"] = allPPIs;
    }
    if (allProtocols.size()) {
        info["allProtocols"] = allProtocols;
    }
    if (allServices.size()) {
        info["allServices"] = allServices;
    }
    if (allGuids.size()) {
        info["allGuids"] = allGuids;
    }
    if (nvramVariables.size()) {
        info["nvramVariables"] = nvramVariables;
    }
    if (readSaveStateCalls.size()) {
        info["readSaveStateCalls"] = readSaveStateCalls;
    }
    if (calloutAddrs.size()) {
        info["vulns"]["smm_callout"] = calloutAddrs;
    }
    if (peiGetVariableOverflow.size()) {
        info["vulns"]["pei_get_variable_buffer_overflow"] = peiGetVariableOverflow;
    }
    if (getVariableOverflow.size()) {
        info["vulns"]["get_variable_buffer_overflow"] = getVariableOverflow;
    }
    if (smmGetVariableOverflow.size()) {
        info["vulns"]["smm_get_variable_buffer_overflow"] = smmGetVariableOverflow;
    }

    std::vector<json> smiHandlersAddrs;
    if (smiHandlers.size() > 0) {
        for (auto f : smiHandlers) {
            func_t *func = f;
            smiHandlersAddrs.push_back(func->start_ea);
        }
        info["smiHandlersAddrs"] = smiHandlersAddrs;
    }

    std::string idbPath;
    idbPath = get_path(PATH_TYPE_IDB);
    std::filesystem::path logFile;
    logFile /= idbPath;
    logFile.replace_extension(".json");
    std::ofstream out(logFile);
    out << std::setw(4) << info << std::endl;
    msg("[%s] the log is saved in a JSON file\n", plugin_name);
}

//--------------------------------------------------------------------------
// Show all non-empty choosers windows
void showAllChoosers(EfiAnalysis::EfiAnalyzer analyzer) {
    qstring title;

    // open window with all services
    if (analyzer.allServices.size()) {
        title = "efiXplorer: services";
        services_show(analyzer.allServices, title);
    }

    // open window with protocols
    if (analyzer.fileType == FTYPE_PEI) {
        if (analyzer.allPPIs.size()) {
            title = "efiXplorer: PPIs";
            ppis_show(analyzer.allPPIs, title);
        }

    } else { // FTYPE_DXE_AND_THE_LIKE
        if (analyzer.allProtocols.size()) {
            title = "efiXplorer: protocols";
            protocols_show(analyzer.allProtocols, title);
        }
    }

    // open window with data guids
    if (analyzer.allGuids.size()) {
        qstring title = "efiXplorer: GUIDs";
        guids_show(analyzer.allGuids, title);
    }

    // open window with NVRAM variables
    if (analyzer.nvramVariables.size()) {
        qstring title = "efiXplorer: NVRAM";
        nvram_show(analyzer.nvramVariables, title);
    }

    // open window with vulnerabilities
    if (calloutAddrs.size() + peiGetVariableOverflow.size() + getVariableOverflow.size() +
        smmGetVariableOverflow.size()) {
        std::vector<json> vulns;
        std::map<std::string, std::vector<ea_t>> vulns_map = {
            {std::string("smm_callout"), calloutAddrs},
            {std::string("pei_get_variable_buffer_overflow"), peiGetVariableOverflow},
            {std::string("get_variable_buffer_overflow"), getVariableOverflow},
            {std::string("smm_get_variable_buffer_overflow"), smmGetVariableOverflow}};
        for (const auto &[type, addrs] : vulns_map) {
            for (auto addr : addrs) {
                json item;
                item["type"] = type;
                item["address"] = addr;
                vulns.push_back(item);
            }
        }
        qstring title = "efiXplorer: vulns";
        vulns_show(vulns, title);
    }
}

//--------------------------------------------------------------------------
// Main function for X64 modules
bool EfiAnalysis::efiAnalyzerMainX64() {
    EfiAnalysis::EfiAnalyzer analyzer;

    while (!auto_is_ok()) {
        auto_wait();
    };

    // find .text and .data segments
    analyzer.getSegments();

    // analyze all
    auto res = ASKBTN_NO;
    if (analyzer.arch == UEFI) {
        res = ask_yn(1, "Want to further analyze all drivers with auto_mark_range?");
    }
    if (res == ASKBTN_YES && textSegments.size() && dataSegments.size()) {
        segment_t *start_seg = textSegments.at(0);
        segment_t *end_seg = dataSegments.at(dataSegments.size() - 1);
        ea_t start_ea = start_seg->start_ea;
        ea_t end_ea = end_seg->end_ea;
        auto_mark_range(start_ea, end_ea, AU_USED);
        plan_and_wait(start_ea, end_ea, 1);
    }

    // mark GUIDs
    analyzer.markDataGuids();
    analyzer.markLocalGuidsX64();

    if (g_args.disable_ui) {
        analyzer.fileType = g_args.module_type == PEI
                                ? analyzer.fileType = FTYPE_PEI
                                : analyzer.fileType = FTYPE_DXE_AND_THE_LIKE;
    } else {
        analyzer.fileType = getFileType(&analyzer.allGuids);
    }

    analyzer.setStrings();

    // find global vars for gImageHandle, gST, gBS, gRT, gSmst
    if (analyzer.fileType == FTYPE_DXE_AND_THE_LIKE) {
        analyzer.findImageHandleX64();
        analyzer.findSystemTableX64();
        analyzer.findBootServicesTables();
        analyzer.findRuntimeServicesTables();

        analyzer.findSmstX64();

        // find Boot services and Runtime services
        analyzer.getProtBootServicesX64();
        analyzer.findOtherBsTablesX64();
        analyzer.getAllBootServices();
        analyzer.getAllRuntimeServices();

        analyzer.getBsProtNamesX64();

#ifdef HEX_RAYS
        applyAllTypesForInterfacesBootServices(analyzer.allProtocols);
        analyzer.findSmstPostProcX64();
#endif

        // find SMM services
        analyzer.getAllSmmServicesX64();
        analyzer.getSmmProtNamesX64();

        // mark protocols
        analyzer.markInterfaces();

        // search for copies of global variables
        markCopiesForGlobalVars(gSmstList, "gSmst");
        markCopiesForGlobalVars(gBsList, "gBS");
        markCopiesForGlobalVars(gRtList, "gRT");

        // search for vulnerabilities
        if (!g_args.disable_vuln_hunt) {

            // find potential SMM callouts
            analyzer.findSwSmiHandlers();
            analyzer.findSmmCallout();

            // find potential OOB RW with GetVariable function
            analyzer.findGetVariableOveflow(analyzer.allServices);

            // find potential OOB RW with SmmGetVariable function
            analyzer.findSmmGetVariableOveflow();
            analyzer.efiSmmCpuProtocolResolver();
        }

#ifdef HEX_RAYS
        applyAllTypesForInterfacesSmmServices(analyzer.allProtocols);
#endif

        analyzer.analyzeNvramVariables();

    } else {
        msg("[%s] Parsing of 64-bit PEI files is not supported yet\n", plugin_name);
    }

    // dump info to JSON file
    analyzer.dumpInfo();

    // show all choosers windows
    if (!g_args.disable_ui) {
        showAllChoosers(analyzer);
    }

    if (analyzer.arch == UEFI) {
        // Init public EdiDependencies members
        g_deps.getProtocolsChooser(analyzer.allProtocols);
        g_deps.getProtocolsByGuids(analyzer.allProtocols);

        // Save all protocols information to build dependencies
        attachActionProtocolsDeps();
        attachActionModulesSeq();
    }

    return true;
}

//--------------------------------------------------------------------------
// Main function for X86 modules
bool EfiAnalysis::efiAnalyzerMainX86() {
    EfiAnalysis::EfiAnalyzer analyzer;

    while (!auto_is_ok()) {
        auto_wait();
    };

    // find .text and .data segments
    analyzer.getSegments();

    // mark GUIDs
    analyzer.markDataGuids();

    if (g_args.disable_ui) {
        analyzer.fileType = g_args.module_type == PEI
                                ? analyzer.fileType = FTYPE_PEI
                                : analyzer.fileType = FTYPE_DXE_AND_THE_LIKE;
    } else {
        analyzer.fileType = getFileType(&analyzer.allGuids);
    }

    analyzer.setStrings();

    if (analyzer.fileType == FTYPE_DXE_AND_THE_LIKE) {

        // find global vars for gST, gBS, gRT
        analyzer.findBootServicesTables();
        analyzer.findRuntimeServicesTables();

        // find boot services and runtime services
        analyzer.getAllRuntimeServices();
        analyzer.getProtBootServicesX86();
        analyzer.getAllBootServices();

        // print and mark protocols
        analyzer.getBsProtNamesX86();
        analyzer.markInterfaces();

#ifdef HEX_RAYS
        applyAllTypesForInterfacesBootServices(analyzer.allProtocols);
        applyAllTypesForInterfacesSmmServices(analyzer.allProtocols);
#endif

    } else if (analyzer.fileType == FTYPE_PEI) {
        addStrucForShiftedPtr();
        setEntryArgToPeiSvc();
        analyzer.getAllPeiServicesX86();
        analyzer.getPpiNamesX86();
        analyzer.getAllVariablePPICallsX86();
        analyzer.markInterfaces();

        // search for vulnerabilities
        if (!g_args.disable_vuln_hunt) {
            analyzer.findPPIGetVariableStackOveflow();
        }
    }

    // dump info to JSON file
    analyzer.dumpInfo();

    // show all choosers windows
    if (!g_args.disable_ui) {
        showAllChoosers(analyzer);
    }

    return true;
}

```

`efiXplorer/efiAnalysis.h`:

```h
/*
 * efiXplorer
 * Copyright (C) 2020-2022 Binarly
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * efiAnalysis.h
 *
 */

#pragma once

#include "efiSmmUtils.h"
#include "efiUtils.h"

namespace EfiAnalysis {

class EfiAnalyzer {
  public:
    std::vector<json> allGuids;
    std::vector<json> allProtocols;
    std::vector<json> allPPIs;
    std::vector<json> allServices;
    std::vector<json> nvramVariables;
    std::vector<func_t *> smiHandlers;
    uint8_t arch;

    void getSegments();
    void setStrings();

    bool findImageHandleX64();
    bool findSystemTableX64();
    bool findBootServicesTables();
    bool findRuntimeServicesTables();
    bool findSmstX64();
    bool findSmstPostProcX64();
    void findOtherBsTablesX64();

    void getProtBootServicesX64();
    void getProtBootServicesX86();
    void getAllBootServices();
    void getAllRuntimeServices();
    void getAllSmmServicesX64();

    void getBsProtNamesX64();
    void getBsProtNamesX86();
    void getSmmProtNamesX64();

    void getAllPeiServicesX86();
    void getPpiNamesX86();
    void getAllVariablePPICallsX86();

    void printInterfaces();
    void markInterfaces();
    void markDataGuids();
    void markLocalGuidsX64();

    bool efiSmmCpuProtocolResolver();
    void findSwSmiHandlers();
    bool findGetVariableOveflow(std::vector<json> allServices);
    bool findPPIGetVariableStackOveflow();
    bool findSmmGetVariableOveflow();
    bool findSmmCallout();
    bool analyzeNvramVariables();
    void dumpInfo();

    EfiAnalyzer();
    ~EfiAnalyzer();

    uint8_t fileType = 0;

  private:
    ea_t base;
    ea_t startAddress = 0;
    ea_t endAddress = 0;
    std::vector<ea_t> funcs;

    std::filesystem::path guidsJsonPath;
    json bootServices;
    json peiServices;
    json peiServicesAll;
    json ppiCallsAll;
    json runtimeServicesAll;
    json smmServices;
    json smmServicesAll;
    json dbProtocols;
    std::map<json, std::string> dbProtocolsMap; // a map to look up a GUID name by value
    std::vector<ea_t> markedInterfaces;

    // Set boot services that work with protocols
    std::vector<std::string> protBsNames = {"InstallProtocolInterface",
                                            "ReinstallProtocolInterface",
                                            "UninstallProtocolInterface",
                                            "HandleProtocol",
                                            "RegisterProtocolNotify",
                                            "OpenProtocol",
                                            "CloseProtocol",
                                            "OpenProtocolInformation",
                                            "ProtocolsPerHandle",
                                            "LocateHandleBuffer",
                                            "LocateProtocol",
                                            "InstallMultipleProtocolInterfaces",
                                            "UninstallMultipleProtocolInterfaces"};

    // Set smm services that work with protocols
    std::vector<std::string> protSmmNames = {"SmmInstallProtocolInterface",
                                             "SmmUninstallProtocolInterface",
                                             "SmmHandleProtocol",
                                             "SmmRegisterProtocolNotify",
                                             "SmmLocateHandle",
                                             "SmmLocateProtocol"};

    // Set of PEI services that work with PPI
    std::vector<std::string> ppiPEINames = {"InstallPpi", "ReInstallPpi", "LocatePpi",
                                            "NotifyPpi"};

    // Format-dependent interface-related settings (protocols for DXE, PPIs for PEI)
    char *if_name;
    char *if_pl;
    char *if_key;
    std::vector<json> *if_tbl;
    bool AddProtocol(std::string serviceName, ea_t guidAddress, ea_t xrefAddress,
                     ea_t callAddress);
    bool InstallMultipleProtocolInterfacesHandler();
    bool AnalyzeVariableService(ea_t ea, std::string service_str);

    // EFI_SMM_SW_DISPATCH2_PROTOCOL_GUID
    EfiGuid sw_guid2 = {
        0x18a3c6dc, 0x5eea, 0x48c8, {0xa1, 0xc1, 0xb5, 0x33, 0x89, 0xf9, 0x89, 0x99}};
    // EFI_SMM_SW_DISPATCH_PROTOCOL_GUID
    EfiGuid sw_guid = {
        0xe541b773, 0xdd11, 0x420c, {0xb0, 0x26, 0xdf, 0x99, 0x36, 0x53, 0xf8, 0xbf}};
    // EFI_SMM_SX_DISPATCH2_PROTOCOL_GUID
    EfiGuid sx_guid2 = {
        0x456d2859, 0xa84b, 0x4e47, {0xa2, 0xee, 0x32, 0x76, 0xd8, 0x86, 0x99, 0x7d}};
    // EFI_SMM_SX_DISPATCH_PROTOCOL_GUID
    EfiGuid sx_guid = {
        0x14FC52BE, 0x01DC, 0x426C, {0x91, 0xAE, 0xA2, 0x3C, 0x3E, 0x22, 0x0A, 0xE8}};
    // EFI_SMM_IO_TRAP_DISPATCH2_PROTOCOL_GUID
    EfiGuid io_trap_guid2 = {
        0x58DC368D, 0x7BFA, 0x4E77, {0xAB, 0xBC, 0x0E, 0x29, 0x41, 0x8D, 0xF9, 0x30}};
    // EFI_SMM_IO_TRAP_DISPATCH_PROTOCOL_GUID
    EfiGuid io_trap_guid = {
        0xDB7F536B, 0xEDE4, 0x4714, {0xA5, 0xC8, 0xE3, 0x46, 0xEB, 0xAA, 0x20, 0x1D}};
    // EFI_SMM_GPI_DISPATCH2_PROTOCOL_GUID
    EfiGuid gpi_guid2 = {
        0x25566B03, 0xB577, 0x4CBF, {0x95, 0x8C, 0xED, 0x66, 0x3E, 0xA2, 0x43, 0x80}};
    // EFI_SMM_GPI_DISPATCH_PROTOCOL_GUID
    EfiGuid gpi_guid = {
        0xE0744B81, 0x9513, 0x49CD, {0x8C, 0xEA, 0xE9, 0x24, 0x5E, 0x70, 0x39, 0xDA}};
    // EFI_SMM_USB_DISPATCH2_PROTOCOL_GUID
    EfiGuid usb_guid2 = {
        0xEE9B8D90, 0xC5A6, 0x40A2, {0xBD, 0xE2, 0x52, 0x55, 0x8D, 0x33, 0xCC, 0xA1}};
    // EFI_SMM_USB_DISPATCH_PROTOCOL_GUID
    EfiGuid usb_guid = {
        0xA05B6FFD, 0x87AF, 0x4E42, {0x95, 0xC9, 0x62, 0x28, 0xB6, 0x3C, 0xF3, 0xF3}};
    // EFI_SMM_STANDBY_BUTTON_DISPATCH2_PROTOCOL_GUID
    EfiGuid standby_button_guid2 = {
        0x7300C4A1, 0x43F2, 0x4017, {0xA5, 0x1B, 0xC8, 0x1A, 0x7F, 0x40, 0x58, 0x5B}};
    // EFI_SMM_STANDBY_BUTTON_DISPATCH_PROTOCOL_GUID
    EfiGuid standby_button_guid = {
        0x78965B98, 0xB0BF, 0x449E, {0x8B, 0x22, 0xD2, 0x91, 0x4E, 0x49, 0x8A, 0x98}};
    // EFI_SMM_PERIODIC_TIMER_DISPATCH2_PROTOCOL_GUID
    EfiGuid periodic_timer_guid2 = {
        0x4CEC368E, 0x8E8E, 0x4D71, {0x8B, 0xE1, 0x95, 0x8C, 0x45, 0xFC, 0x8A, 0x53}};
    // EFI_SMM_PERIODIC_TIMER_DISPATCH_PROTOCOL_GUID
    EfiGuid periodic_timer_guid = {
        0x9CCA03FC, 0x4C9E, 0x4A19, {0x9B, 0x06, 0xED, 0x7B, 0x47, 0x9B, 0xDE, 0x55}};
    // EFI_SMM_POWER_BUTTON_DISPATCH2_PROTOCOL_GUID
    EfiGuid power_button_guid2 = {
        0x1B1183FA, 0x1823, 0x46A7, {0x88, 0x72, 0x9C, 0x57, 0x87, 0x55, 0x40, 0x9D}};
    // EFI_SMM_POWER_BUTTON_DISPATCH_PROTOCOL_GUID
    EfiGuid power_button_guid = {
        0xB709EFA0, 0x47A6, 0x4B41, {0xB9, 0x31, 0x12, 0xEC, 0xE7, 0xA8, 0xEE, 0x56}};
};

bool efiAnalyzerMainX64();
bool efiAnalyzerMainX86();
}; // namespace EfiAnalysis

void showAllChoosers(EfiAnalysis::EfiAnalyzer analyzer);

```

`efiXplorer/efiDeps.cpp`:

```cpp
/*
 * efiXplorer
 * Copyright (C) 2020-2022 Binarly
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * efiDeps.cpp
 *
 */

#include "efiDeps.h"

EfiDependencies::EfiDependencies() {
    // Read DEPEX (for protocols) from
    // .deps.json file if this file exists
    loadDepsFromUefiTool();
    // Get images names from IDB
    getImages();
    // Read images with GUIDs from
    // .images.json file if this file exists
    loadImagesWithGuids();
};

EfiDependencies::~EfiDependencies() {
    imagesInfo.clear();
    imagesGuids.clear();
    imagesFromIdb.clear();
    uefitoolDeps.clear();
    modulesSequence.clear();
    protocolsChooser.clear();
    protocolsByGuids.clear();
    additionalInstallers.clear();
    protocolsWithoutInstallers.clear();
};

json EfiDependencies::getDeps(std::string guid) {
    json res;
    std::vector installers({"InstallProtocolInterface",
                            "InstallMultipleProtocolInterfaces",
                            "SmmInstallProtocolInterface"});
    for (auto &it : protocolsChooser.items()) {
        auto p = it.value();
        if (p["guid"] != guid) {
            continue;
        }
        p["ea"] = getHex(static_cast<uint64_t>(p["ea"]));
        p["xref"] = getHex(static_cast<uint64_t>(p["xref"]));
        p["address"] = getHex(static_cast<uint64_t>(p["address"]));
        if (find(installers.begin(), installers.end(), p["service"]) !=
            installers.end()) {
            res["installed"].push_back(p);
        } else {
            res["used"].push_back(p);
        }
    }

    return res;
}

void EfiDependencies::getProtocolsByGuids(std::vector<json> protocols) {
    for (auto p : protocols) {
        // check if entry for GUID already exist
        std::string guid = p["guid"];
        auto deps = protocolsByGuids[guid];
        if (deps.is_null()) {
            protocolsByGuids[guid] = getDeps(guid);
        }
    }
}

void EfiDependencies::getProtocolsChooser(std::vector<json> protocols) {
    auto i = 0;
    for (auto p : protocols) {
        protocolsChooser[i] = p;
        ++i;
    }
}

bool EfiDependencies::loadDepsFromUefiTool() {
    std::filesystem::path deps_json;
    deps_json /= get_path(PATH_TYPE_IDB);
    deps_json.replace_extension(".deps.json");
    if (!std::filesystem::exists(deps_json)) {
        return false;
    }
    std::ifstream file(deps_json);
    file >> uefitoolDeps;
    return true;
}

bool EfiDependencies::loadImagesWithGuids() {
    std::filesystem::path images_json;
    images_json /= get_path(PATH_TYPE_IDB);
    images_json.replace_extension(".images.json");
    if (!std::filesystem::exists(images_json)) {
        return false;
    }
    std::ifstream file(images_json);
    file >> imagesGuids;
    return true;
}

bool EfiDependencies::installerFound(std::string protocol) {
    auto deps_prot = protocolsByGuids[protocol];
    if (deps_prot.is_null()) {
        return false;
    }
    auto installers = deps_prot["installed"];
    if (installers.is_null()) {
        return false;
    }
    return true;
}

void EfiDependencies::getProtocolsWithoutInstallers() {
    // Check DXE_DEPEX and MM_DEPEX
    std::vector<std::string> sections{"EFI_SECTION_DXE_DEPEX", "EFI_SECTION_MM_DEPEX"};
    for (auto section : sections) {
        auto images = uefitoolDeps[section];
        for (auto &element : images.items()) {
            auto protocols = element.value();
            for (auto p : protocols) {
                std::string ps = static_cast<std::string>(p);
                if (!installerFound(ps)) {
                    protocolsWithoutInstallers.insert(ps);
                }
            }
        }
    }
}

void EfiDependencies::getInstallersModules() {
    // search for this protocols in binary
    for (auto &protocol : protocolsWithoutInstallers) {
        auto addrs = searchProtocol(protocol);
        bool installerFound = false;
        for (auto addr : addrs) {
            auto xrefs = getXrefs(addr);
            if (!xrefs.size()) {
                continue;
            }
            if (xrefs.size() == 1) {
                func_t *func = get_func(xrefs.at(0));
                if (func == nullptr) {
                    xrefs = getXrefsToArray(xrefs.at(0));
                }
            }
            for (auto ea : xrefs) {
                if (checkInstallProtocol(ea)) {
                    auto module = getModuleNameLoader(ea);
                    additionalInstallers[protocol] =
                        static_cast<std::string>(module.c_str());
                    installerFound = true;
                    break;
                }
            }
            if (installerFound) {
                break;
            }
        }
        if (!installerFound) {
            untrackedProtocols.insert(protocol);
        }
    }
}

void EfiDependencies::getAdditionalInstallers() {
    getProtocolsWithoutInstallers();
    getInstallersModules();
    std::string installers = additionalInstallers.dump(2);
    msg("Additional installers: %s\n", installers.c_str());
    msg("Untracked protocols:\n");
    for (auto &protocol : untrackedProtocols) {
        msg("%s\n", protocol.c_str());
    }
}

void EfiDependencies::getImages() {
    for (segment_t *s = get_first_seg(); s != nullptr; s = get_next_seg(s->start_ea)) {
        qstring seg_name;
        get_segm_name(&seg_name, s);

        std::vector<std::string> codeSegNames{"_.text", "_.code"};
        for (auto name : codeSegNames) {
            auto index = seg_name.find(name.c_str());
            if (index != std::string::npos) {
                std::string image_name =
                    static_cast<std::string>(seg_name.c_str()).substr(0, index);
                if (!image_name.rfind("_", 0)) {
                    image_name = image_name.erase(0, 1);
                }
                imagesFromIdb.push_back(image_name);
            }
        }
    }
}

json EfiDependencies::getImageInfo(std::string image) {
    json info;
    std::vector<std::string> installedProtocols;
    json depsProtocols;
    std::vector installers({"InstallProtocolInterface",
                            "InstallMultipleProtocolInterfaces",
                            "SmmInstallProtocolInterface"});

    // Get installed protocols
    for (auto &p : additionalInstallers.items()) { // check additional installers
        std::string adInstImage = p.value();
        std::string adInstProtocol = p.key();
        if (adInstImage == image) {
            installedProtocols.push_back(adInstProtocol);
            break;
        }
    }

    for (auto &element : protocolsChooser.items()) { // check efiXplorer report
        json p = element.value();
        std::string image_name = p["module"];
        if (!image_name.rfind("_", 0)) {
            image_name = image_name.erase(0, 1);
        }
        if (image_name != image) {
            continue;
        }
        if (find(installers.begin(), installers.end(), p["service"]) !=
            installers.end()) {
            installedProtocols.push_back(p["guid"]);
        }
    }

    // Get deps
    bool found = false;
    std::vector<std::string> sections{"EFI_SECTION_DXE_DEPEX", "EFI_SECTION_MM_DEPEX"};
    for (auto section : sections) {
        json deps_images = uefitoolDeps[section];
        for (auto &element : deps_images.items()) {
            std::string dimage_guid = element.key();
            if (imagesGuids[dimage_guid].is_null()) {
                // Can not get name for image
                continue;
            }
            std::string dimage_name = imagesGuids[dimage_guid];
            if (dimage_name == image) {
                depsProtocols = element.value();
                found = true;
                break;
            }
        }
        if (found) {
            break;
        }
    }

    info["installed_protocols"] = installedProtocols;
    info["deps_protocols"] = depsProtocols;

    return info;
}

bool EfiDependencies::getImagesInfo() {
    if (imagesInfo.size()) {
        return true;
    }
    for (auto image : imagesFromIdb) {
        imagesInfo[image] = getImageInfo(image);
    }
    return true;
}

std::string EfiDependencies::getInstaller(std::string protocol) {
    std::string res;
    for (auto &e : imagesInfo.items()) {
        std::string image = e.key();
        std::vector<std::string> installers = imagesInfo[image]["installed_protocols"];
        if (find(installers.begin(), installers.end(), protocol) != installers.end()) {
            return image;
        }
    }
    return res;
}

bool EfiDependencies::buildModulesSequence() {
    if (modulesSequence.size()) {
        return true;
    }

    std::set<std::string> modulesSeq;
    std::set<std::string> installed_protocols;

    getProtocolsWithoutInstallers(); // hard to find installers for all protocols in
                                     // statiс
    getImagesInfo();

    size_t index = 0;
    while (modulesSeq.size() != imagesInfo.size()) {
        bool changed = false;
        for (auto &e : imagesInfo.items()) {
            std::string image = e.key(); // current module

            // check if the image is already loaded
            if (modulesSeq.find(image) != modulesSeq.end()) {
                continue;
            }

            std::vector<std::string> installers =
                imagesInfo[image]["installed_protocols"];

            // if there are no dependencies
            if (imagesInfo[image]["deps_protocols"].is_null()) {
                for (auto protocol : installers) {
                    installed_protocols.insert(protocol);
                }
                modulesSeq.insert(image);
                json info;
                info["module"] = image;
                modulesSequence[index++] = info;
                changed = true;
                continue;
            }

            std::vector<std::string> deps = imagesInfo[image]["deps_protocols"];
            std::vector<std::string> unresolved_deps;
            bool load = true;
            for (auto protocol : deps) {
                if (installed_protocols.find(protocol) != installed_protocols.end()) {
                    continue;
                }
                if (protocolsWithoutInstallers.find(protocol) !=
                    protocolsWithoutInstallers.end()) {
                    unresolved_deps.push_back(protocol);
                    continue;
                }
                load = false;
                break;
            }

            if (load) {
                for (auto protocol : installers) {
                    installed_protocols.insert(protocol);
                }
                modulesSeq.insert(image);
                json info;
                info["image"] = image;
                info["deps"] = deps;
                if (unresolved_deps.size()) {
                    info["unresolved_deps"] = unresolved_deps;
                }
                modulesSequence[index++] = info;
                changed = true;
            }
        }

        if (!changed) { // we are in a loop, we need to load a module that installs the
                        // most popular protocol
            std::map<std::string, size_t>
                protocols_usage; // get the most popular protocol
            for (auto &e : imagesInfo.items()) {
                std::string image = e.key();

                // check if the image is already loaded
                if (modulesSeq.find(image) != modulesSeq.end()) {
                    continue;
                }

                if (imagesInfo[image]["deps_protocols"].is_null()) {
                    continue;
                }

                std::vector<std::string> deps_protocols =
                    imagesInfo[image]["deps_protocols"];
                for (auto protocol : deps_protocols) {
                    if (installed_protocols.find(protocol) != installed_protocols.end()) {
                        continue;
                    }
                    if (protocolsWithoutInstallers.find(protocol) !=
                        protocolsWithoutInstallers.end()) {
                        continue;
                    }
                    if (protocols_usage.find(protocol) == protocols_usage.end()) {
                        protocols_usage[protocol] = 1;
                    } else {
                        protocols_usage[protocol] += 1;
                    }
                }
            }
            std::string mprotocol;
            size_t mnum = 0;
            for (auto const &[prot, counter] : protocols_usage) {
                if (counter > mnum) {
                    mnum = static_cast<size_t>(counter);
                    mprotocol = static_cast<std::string>(prot);
                }
            }
            if (!mnum) {
                break; // the most popular protocol was not found
            }
            // find installer module for mprotocol
            std::string installer_image = getInstaller(mprotocol);
            if (!installer_image.size()) {
                msg("Can not find installer for protocol %s\n", mprotocol.c_str());
                break; // something went wrong, extra mitigation for an infinite loop
            }
            // load installer_image
            std::vector<std::string> current_installers =
                imagesInfo[installer_image]["installed_protocols"];
            for (auto protocol : current_installers) {
                installed_protocols.insert(protocol);
            }
            modulesSeq.insert(installer_image);
            json info;
            info["image"] = installer_image;
            info["deps"] = imagesInfo[installer_image]["deps_protocols"];
            modulesSequence[index++] = info;
        }
    }

    return true;
}

```

`efiXplorer/efiDeps.h`:

```h
/*
 * efiXplorer
 * Copyright (C) 2020-2022 Binarly
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * efiDeps.h
 *
 */

#pragma once

#include "efiUtils.h"

class EfiDependencies {
  public:
    EfiDependencies();
    ~EfiDependencies();
    json protocolsByGuids; // protocols sorted by GUIDs
    json protocolsChooser; // numbered json with protocols
    json uefitoolDeps;
    json imagesGuids;
    json additionalInstallers; // getAdditionalInstallers result
    json imagesInfo;           // getImagesInfo result
    json modulesSequence;      // buildModulesSequence result
    std::vector<std::string> imagesFromIdb;
    std::set<std::string> untrackedProtocols;
    // Input: protocols from report
    void getProtocolsByGuids(std::vector<json> protocols);
    void getProtocolsChooser(std::vector<json> protocols);
    json getDeps(std::string protocol); // get dependencies for specific protocol
    void getAdditionalInstallers(); // get installers by protocol GUIDs by searching in
                                    // the firmware and analyzing xrefs
    bool buildModulesSequence();
    bool getImagesInfo();

  private:
    void getImages();
    std::set<std::string> protocolsWithoutInstallers;
    void getProtocolsWithoutInstallers();
    void getInstallersModules();
    bool loadDepsFromUefiTool();
    bool loadImagesWithGuids();
    bool installerFound(std::string protocol);
    json getImageInfo(std::string image);
    std::string getInstaller(std::string protocol);
};

```

`efiXplorer/efiGlobal.cpp`:

```cpp
/*
 * efiXplorer
 * Copyright (C) 2020-2022 Binarly
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * efiGlobal.cpp
 *
 */

#include "efiGlobal.h"

EfiDependencies g_deps;

```

`efiXplorer/efiGlobal.h`:

```h
/*
 * efiXplorer
 * Copyright (C) 2020-2022 Binarly
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * efiGlobal.h
 *
 */

#include "efiDeps.h"

enum module_types { DXE_SMM = 0, PEI = 1 };

struct args {
    int module_type;
    int disable_ui;
    int disable_vuln_hunt;
};

extern struct args g_args;
extern EfiDependencies g_deps;

```

`efiXplorer/efiHexRays.cpp`:

```cpp
/*
 * efiXplorer
 * Copyright (C) 2020-2022 Binarly, Rolf Rolles
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * efiHexRays.cpp
 *
 */

#include "efiHexRays.h"

// Given a tinfo_t specifying a user-defined type (UDT), look up the specified
// field by its name, and retrieve its offset.
bool offsetOf(tinfo_t tif, const char *name, unsigned int *offset) {
    // Get the udt details
    udt_type_data_t udt;
    if (!tif.get_udt_details(&udt)) {
        qstring str;
        tif.get_type_name(&str);
        return false;
    }

    // Find the udt member
    udt_member_t udm;
    udm.name = name;
    int fIdx = tif.find_udt_member(&udm, STRMEM_NAME);
    if (fIdx < 0) {
        qstring tstr;
        tif.get_type_name(&tstr);
        return false;
    }

    // Get the offset of the field
    *offset = static_cast<unsigned int>(udt.at(fIdx).offset >> 3ULL);
    return true;
}

// Utility function to set a Hex-Rays variable type and name
bool setHexRaysVariableInfo(ea_t funcEa, lvar_t &ll, tinfo_t tif, std::string name) {
    lvar_saved_info_t lsi;
    lsi.ll = ll;
    lsi.type = tif;
    modify_user_lvar_info(funcEa, MLI_TYPE, lsi);

    // Set lvar name
    if (ll.is_stk_var()) { // Rename local variable on stack
        sval_t stkoff = ll.get_stkoff();
        struc_t *frame = get_frame(funcEa);
        set_member_name(frame, stkoff, name.c_str());
    } else { // Modufy user lvar info
        lsi.name = static_cast<qstring>(name.c_str());
        modify_user_lvar_info(funcEa, MLI_NAME, lsi);
    }

    // Get xrefs to local variable
    xreflist_t xrefs = xrefsToStackVar(funcEa, static_cast<qstring>(name.c_str()));
    qstring typeName;
    ptr_type_data_t pi;
    tif.get_ptr_details(&pi);
    pi.obj_type.get_type_name(&typeName);
    // Handling all interface functions (to rename function arguments)
    opstroffForInterface(xrefs, typeName);

    return true;
}

// I added this bit of logic when I noticed that sometimes Hex-Rays will
// aggressively create arrays on the stack. So, I wanted to apply types to
// stack "variables" (whose pointers are passed to the protocol location
// functions), but according to Hex-Rays, they weren't "variables", they
// were arrays. This bit of logic generically detects arrays of either POD
// types, or perhaps pointers to POD types. The final argument allows the
// caller to specify the maximum depth "depth" of the pointers. E.g. at
// depth 1, "int *[10]" is acceptable. At depth 2, "int **[10]" is acceptable.
bool isPODArray(tinfo_t tif, unsigned int ptrDepth = 0) {
    // If it's not an array, we're done
    if (!tif.is_array())
        return false;

    qstring tstr;

    // If it is an array, we should be able to get its array details.
    array_type_data_t atd;
    if (!tif.get_array_details(&atd)) {
        tif.get_type_name(&tstr);
        return false;
    }

    // Get the element type from the array
    tinfo_t et = atd.elem_type;

    // Start off with depth + 1, so the loop will execute at least once
    int iDepth = ptrDepth + 1;

    // Loop over the user-specified depth
    while (iDepth > 0) {

        // Use typeid last checks. I should clean this up; I'm sure I can get rid
        // of one of them.
        bool b1 = is_typeid_last(et.get_realtype());
        bool b2 = et.is_decl_last();

        // Debug printing
        et.get_type_name(&tstr);

        // If it was an integer type, return true
        if (b1 || b2)
            return true;

        // Otherwise, this is where the "pointer depth" comes in.
        // If we haven't exhausted the pointer depth,
        if (--iDepth > 0) {
            // Remove one layer of indirection from the element type
            if (et.is_ptr())
                et = remove_pointer(et);

            // Unless it's not a pointer, then return false.
            else
                return false;
        }
    }

    // If the array wasn't pointers of POD types up to the specified depth, we
    // failed. Return false.
    return false;
}

// Utility function to get a printable qstring from a cexpr_t
const char *Expr2String(cexpr_t *e, qstring *out) {
    e->print1(out, NULL);
    tag_remove(out);
    return out->c_str();
}

void applyAllTypesForInterfacesBootServices(std::vector<json> protocols) {
    // Descriptors for EFI_BOOT_SERVICES functions
    struct TargetFunctionPointer BootServicesFunctions[3]{
        {"HandleProtocol", 0x98, 3, 1, 2},
        {"LocateProtocol", 0x140, 3, 0, 2},
        {"OpenProtocol", 0x118, 6, 1, 2}};

    // Initialize
    ServiceDescriptor sdBs;
    sdBs.Initialize("EFI_BOOT_SERVICES", BootServicesFunctions, 3);

    ServiceDescriptorMap mBs;
    mBs.Register(sdBs);

    GUIDRetyper retyperBs(mBs);
    retyperBs.SetProtocols(protocols);

    // Handle all protocols
    for (auto protocol : protocols) {
        auto code_addr = protocol["ea"];
        auto service = protocol["service"];

        func_t *f = get_func(code_addr);
        if (f == nullptr) {
            continue;
        }

        retyperBs.SetCodeEa(code_addr);
        retyperBs.SetFuncEa(f->start_ea);

        hexrays_failure_t hf;
        cfuncptr_t cfunc = decompile(f, &hf);

        // Сheck that the function is decompiled
        if (cfunc == nullptr) {
            continue;
        }

        retyperBs.apply_to(&cfunc->body, nullptr);
    }
}

void applyAllTypesForInterfacesSmmServices(std::vector<json> protocols) {
    // Descriptors for _EFI_SMM_SYSTEM_TABLE2 functions
    struct TargetFunctionPointer SmmServicesFunctions[2]{
        {"SmmHandleProtocol", 0xb8, 3, 1, 2},
        {"SmmLocateProtocol", 0xd0, 3, 0, 2},
    };

    // Initialize
    ServiceDescriptor sdSmm;
    sdSmm.Initialize("_EFI_SMM_SYSTEM_TABLE2", SmmServicesFunctions, 2);

    ServiceDescriptorMap mSmm;
    mSmm.Register(sdSmm);

    GUIDRetyper retyperSmm(mSmm);
    retyperSmm.SetProtocols(protocols);

    // Handle all protocols
    for (auto protocol : protocols) {
        auto code_addr = protocol["ea"];
        auto service = protocol["service"];

        func_t *f = get_func(code_addr);
        if (f == nullptr) {
            continue;
        }

        retyperSmm.SetCodeEa(code_addr);
        retyperSmm.SetFuncEa(f->start_ea);

        hexrays_failure_t hf;
        cfuncptr_t cfunc = decompile(f, &hf);

        // Сheck that the function is decompiled
        if (cfunc == nullptr) {
            continue;
        }

        retyperSmm.apply_to(&cfunc->body, nullptr);
    }
}

uint8_t VariablesInfoExtractAll(func_t *f, ea_t code_addr) {
    // check func
    if (f == nullptr) {
        return 0xff;
    }
    VariablesInfoExtractor extractor(code_addr);
    hexrays_failure_t hf;
    cfuncptr_t cfunc = decompile(f, &hf);
    // Сheck that the function is decompiled
    if (cfunc == nullptr) {
        return 0xff;
    }
    extractor.apply_to(&cfunc->body, nullptr);
    auto res = extractor.mAttributes;
    return res;
}

```

`efiXplorer/efiHexRays.h`:

```h
/*
 * efiXplorer
 * Copyright (C) 2020-2022 Binarly, Rolf Rolles
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * efiHexRays.h
 *
 */

#pragma once

#include "efiUtils.h"

uint8_t VariablesInfoExtractAll(func_t *f, ea_t code_addr);
void applyAllTypesForInterfacesBootServices(std::vector<json> guids);
void applyAllTypesForInterfacesSmmServices(std::vector<json> guids); // unused
bool setHexRaysVariableInfo(ea_t funcEa, lvar_t &ll, tinfo_t tif, std::string name);
bool offsetOf(tinfo_t tif, const char *name, unsigned int *offset);
bool isPODArray(tinfo_t tif, unsigned int ptrDepth);
const char *Expr2String(cexpr_t *e, qstring *out);

// Description of a function pointer within a structure. Ultimately, this
// plugin is looking for calls to specific UEFI functions. This structure
// describes basic information about those functions:
struct TargetFunctionPointer {
    char *name;            // Name of function pointer in structure
    int offset;            // Offset of function pointer (filled in later)
    unsigned int nArgs;    // Number of expected arguments
    unsigned int nGUIDArg; // Which argument has the EFI_GUID *
    unsigned int nOutArg;  // Which argument retrieves the output
};

// This class holds all function pointer descriptors for one structure, as well
// as providing a utility to look up function pointers by offset.
class ServiceDescriptor {
    // Instance data
  protected:
    // The type of the containing structure (e.g. EFI_BOOT_SERVICES)
    tinfo_t mType;

    // The name of the type (e.g. "EFI_BOOT_SERVICES")
    qstring mName;

    // The ordinal of the type (e.g. 4)
    uint32 mOrdinal;

    // A vector of the structures above, copied, and with the offsets filled in
    std::vector<TargetFunctionPointer> mTargets;

    bool bInitialized;

    // Ensure we can look up the type that this instance describes
    bool InitType(const char *name) {
        // Import type
        import_type(get_idati(), -1, name);

        // Get type by name
        if (!mType.get_named_type(get_idati(), name, BTF_STRUCT))
            return false;

        // Save ordinal and name
        mOrdinal = mType.get_ordinal();
        mName = name;
        return true;
    }

    // Look up the offsets for all function pointer targets; save the results
    // in the vector. Return false if offset lookup fails.
    bool InitTargets(TargetFunctionPointer *targets, size_t num) {
        // Iterate through all targets
        for (int i = 0; i < num; ++i) {

            // Copy the target structure into our local vector
            TargetFunctionPointer &tgt = mTargets.emplace_back();
            tgt = targets[i];

            // Retrieve the offsets of each named function pointer
            unsigned int offset;
            if (!offsetOf(mType, targets[i].name, &offset)) {
                return false;
            }
        }
        return true;
    }

  public:
    // Constructor does nothing
    ServiceDescriptor() : mOrdinal(0), bInitialized(false){};

    // Accessor for ordinal
    uint32 GetOrdinal() { return mOrdinal; };

    // Accessor for name
    const char *GetName() { return mName.c_str(); };

    // Needs to be called before the object can be used
    bool Initialize(const char *name, TargetFunctionPointer *targets, size_t num) {
        if (bInitialized)
            return true;
        bInitialized = InitType(name) && InitTargets(targets, num);
        return bInitialized;
    }

    // After initialization, look up a target by offset
    bool LookupOffset(unsigned int offset, TargetFunctionPointer **tgt) {
        // Iterating through a vector generally is inefficient compared to a map,
        // but there are at most 3 function pointers so far, so it outweighs the
        // overhead of the associative containers.
        for (auto &it : mTargets) {
            // Match by offset
            if (it.offset == offset) {
                *tgt = &it;
                return true;
            }
        }
        // If we don't find it, it's not necessarily "bad" from the point of view
        // of the plugin's logic. After all, we're looking at every access to the
        // selected structures, and so, quite rightly, we'll want to ignore the
        // function pointers that we're not tracking.
        return false;
    }
};

// This class manages multiple instances of the class above. Each such
// structure is associated with the ordinal of its containing structure type.
// Then, when the Hex-Rays visitor needs to look up a function pointer access
// into a structure, it just passes the structure ordinal and offset. This
// class looks up the ServiceDescriptor in a map by ordinal, and then looks up
// the offset if that succeeded.
class ServiceDescriptorMap {
  protected:
    // Our map for looking up ServiceDescriptor structures. I should probably
    // change the value type to a pointer.
    std::map<uint32, ServiceDescriptor> mServices;

  public:
    // Add a new ServiceDescriptor to the map. I should change the argument
    // type to match whatever I change the value type of the map to.
    bool Register(ServiceDescriptor sd) {

        // Get the ordinal from the ServiceDescriptor
        uint32 ord = sd.GetOrdinal();

        // Are we already tracking this structure?
        if (mServices.find(ord) != mServices.end()) {
            return false;
        }
        // If not, register it. Get rid of std::move
        mServices[ord] = std::move(sd);
        return true;
    }

    // This function could be protected, but whatever. Given an ordinal, get
    // the tracked ServiceDescriptor, if applicable.
    bool LookupOrdinal(uint32 ord, ServiceDescriptor **sd) {
        auto it = mServices.find(ord);
        if (it == mServices.end()) {
            return false;
        }
        *sd = &it->second;
        return true;
    }

    // This is the high-level function that clients call. Given a structure
    // ordinal and offset of a function pointer, see if it's something we're
    // tracking. If so, get pointers to the tracked objects and return true.
    bool LookupOffset(uint32 ord, unsigned int offset, ServiceDescriptor **sd,
                      TargetFunctionPointer **tgt) {
        if (!LookupOrdinal(ord, sd))
            return false;
        if (!(*sd)->LookupOffset(offset, tgt))
            return false;
        return true;
    }
};

// Base class for two visitors that require similar functionality. Here we
// collect all of the common data and functionality that will be used by both
// of those visitors. This allows the derivatives to be very succinct.
class GUIDRelatedVisitorBase : public ctree_visitor_t {
  public:
    // We need access to a ServiceDescriptorMap from above.
    GUIDRelatedVisitorBase(ServiceDescriptorMap &m)
        : ctree_visitor_t(CV_FAST), mDebug(true), mServices(m){};

    // We need the function ea when setting Hex-Rays variable types.
    void SetFuncEa(ea_t ea) { mFuncEa = ea; };
    void SetCodeEa(ea_t ea) { mCodeEa = ea; };
    void SetProtocols(std::vector<json> protocols) { mProtocols = protocols; };

  protected:
    //
    // Persistent variables
    //

    // Function address
    ea_t mFuncEa;
    ea_t mCodeEa;

    // Protocols
    std::vector<json> mProtocols;

    // Print debug messages?
    bool mDebug = false;

    // Used for looking up calls to function pointers in structures
    ServiceDescriptorMap &mServices;

    //
    // State variables, cleared on every iteration. I debated with myself
    // whether this was a nasty design decision. I think it's fine. These
    // variables are only valid to access after the client has called
    // ValidateCallAndGUID, and it returned true. If you called that and it
    // returned false, these will be in an inconsistent state. Don't touch them
    // if that's the case.
    //

    // Address of the indirect function call
    ea_t mEa;

    // The pointer type that's being accessed (that of the structure)
    tinfo_t mTif;

    // The structure type, with the pointer indirection removed
    tinfo_t mTifNoPtr;

    // The ServiceDescriptor for the containing structure
    ServiceDescriptor *mpService;

    // The ordinal of the structure type
    uint32 mOrdinal;

    // The offset of the function pointer in the structure
    unsigned int mOffset;

    // Details about the target of the indirect call (e.g. name)
    TargetFunctionPointer *mpTarget;

    // The list of arguments for the indirect call
    carglist_t *mArgs;

    // The argument that specifies the GUID for the indirect call
    cexpr_t *mGUIDArg;

    // The argument that gets the output for the indirect call
    cexpr_t *mOutArg;

    // The GUID argument will be &x; this is x
    cexpr_t *mGUIDArgRefTo;

    // The address of the GUID being passed to the indirect call
    ea_t mGUIDEa;

    // This function clears all the state variables above. Technically, it
    // doesn't need to exist, since the flow of logic in the functions below
    // always write to them before reading to them. But, it seems like good
    // programming practice not to have stale values, anyway.
    void Clear() {
        mEa = BADADDR;
        mTif.clear();
        mTifNoPtr.clear();
        mpService = nullptr;
        mOrdinal = 0;
        mOffset = -1;
        mpTarget = nullptr;
        mArgs = nullptr;
        mGUIDArg = nullptr;
        mOutArg = nullptr;
        mGUIDArgRefTo = nullptr;
        mGUIDEa = BADADDR;
    };

    // Debug print, if the instance debug variable says to
    void DebugPrint(const char *fmt, ...) {
        va_list va;
        va_start(va, fmt);
        if (mDebug)
            vmsg(fmt, va);
    };

    // This is the first function called every time the visitor visits an
    // expression. This function determines if the expression is a call to a
    // function pointer contained in a structure.
    bool GetICallOrdAndOffset(cexpr_t *e) {
        // Set instance variable for call address
        mEa = e->ea;

        if (mEa != mCodeEa) {
            return false;
        }

        // If it's not a call, we're done.
        if (e->op != cot_call)
            return false;

        // Set instance variable with call arguments
        mArgs = e->a;

        // If it's a direct call, we're done.
        cexpr_t *callDest = e->x;
        if (callDest->op == cot_obj)
            return false;

        // Eat any casts on the type of what's being called
        while (callDest->op == cot_cast)
            callDest = callDest->x;

        // If the destination is not a member of a structure, we're done.
        if (callDest->op != cot_memptr)
            return false;

        // Set instance variable with type of structure containing pointer
        mTif = callDest->x->type;

        // Ensure that the structure is being accessed via pointer, and not as a
        // reference (i.e., through a structure held on the stack as a local
        // variable).
        if (!mTif.is_ptr()) {
            return false;
        }

        // Remove pointer from containing structure type, set instance variable
        mTifNoPtr = remove_pointer(mTif);

        // Get the ordinal of the structure
        mOrdinal = mTifNoPtr.get_ordinal();

        // If we can't get a type for the structure, that's bad
        if (mOrdinal == 0)
            return false;

        // Get the offset of the function pointer in the structure
        mOffset = callDest->m;

        // Okay: now we know we're dealing with an indirect call to a function
        // pointer contained in a structure, where the structure is being
        // accessed by a pointer.
        return true;
    };

    // This is the second function called as part of indirect call validation.
    // Now we want to know: is it a call to something that we're tracking?
    bool ValidateICallDestination() {

        // Look up the structure ordinal and function offset; get the associated
        // ServiceDescriptor and TargetFunctionPointer (instance variables).
        if (!mServices.LookupOffset(mOrdinal, mOffset, &mpService, &mpTarget))
            return false;

        // Great, it was something that we were tracking. Now, sanity-check the
        // number of arguments on the function call. (Hex-Rays might have gotten
        // this wrong. The user can fix it via "set call type".)
        size_t mArgsSize = mArgs->size();
        size_t nArgs = mpTarget->nArgs;
        if (mArgsSize != nArgs) {
            return false;
        }

        // The TargetFunctionPointer tells us which argument takes an EFI_GUID *,
        // and which one retrieves the output. Get those arguments, and save them
        // as instance variables.
        mGUIDArg = &mArgs->at(mpTarget->nGUIDArg);
        mOutArg = &mArgs->at(mpTarget->nOutArg);

        // Great; now we know that the expression is an indirect call to
        // something that we're tracking, and that Hex-Rays decompiled the call
        // the way we expected it to.
        return true;
    };

    // This is a helper function used to get the thing being referred to. What
    // does that mean?
    //
    // * For GUID arguments, we'll usually have &globvar. Return globvar.
    // * For output arguments, we'll usually have &globvar or &locvar. Due to
    //   Hex-Rays internal heuristics, we might end up with "locarray", which
    //   does not actually have a "&" when passed as a call argument. There's
    //   a bit of extra logic to check for that case.
    cexpr_t *GetReferent(cexpr_t *e, const char *desc, bool bAcceptVar) {

        // Eat casts
        cexpr_t *x = e;
        while (x->op == cot_cast)
            x = x->x;

        qstring estr;
        // If we're accepting local variables, and this is a variable (note: not
        // a *reference* to a variable)
        if (bAcceptVar && x->op == cot_var) {
            // Get the variable details
            var_ref_t varRef = x->v;
            lvar_t destVar = varRef.mba->vars[varRef.idx];

            // Ensure that it's an array of POD types, or pointers to them
            bool bisPODArray = isPODArray(destVar.tif, 1);

            // If it is a POD array, good, we'll take it.
            return bisPODArray ? x : nullptr;
        }

        // For everything else, we really want it to be a reference: either to a
        // global or local variable. If it's not a reference, we can't get the
        // referent, so fail.
        if (x->op != cot_ref) {
            return nullptr;
        }

        // If we get here, we know it's a reference. Return the referent.
        return x->x;
    };

    // The third function in the validation logic. We already know the
    // expression is an indirect call to something that we're tracking, and
    // that Hex-Rays' decompilation matches on the number of arguments. Now,
    // we validate that the GUID argument does in fact point to a global
    // variable.
    bool ValidateGUIDArgument() {
        // Does the GUID argument point to a local variable?
        mGUIDArgRefTo = GetReferent(mGUIDArg, "GUID", false);
        if (!mGUIDArgRefTo)
            return false;

        // If we get here, we know it was a reference to *something*. Ensure that
        // something is a global variable.
        if (mGUIDArgRefTo->op != cot_obj) {
            return false;
        }

        // Save the address of the global variable to which the GUID argument is
        // pointing.
        mGUIDEa = mGUIDArgRefTo->obj_ea;

        // Great; now we know we're dealing with an indirect call to something
        // we're tracking; that Hex-Rays decompiled the call with the proper
        // number of arguments; and that the GUID argument did in fact point to
        // a global variable, whose address we now have in an instance variable.
        return true;
    };

    // Finally, this function combines all three checks above into one single
    // function. If you call this and it returns true, feel free to access the
    // instance variables, as they are guaranteed to be valid. If it returns
    // false, they aren't, so don't touch them.
    bool ValidateCallAndGUID(cexpr_t *e) {
        // Reset all instance variables. Not strictly necessary; call it
        // "defensive programming".
        Clear();

        // Validate according to the logic above.
        if (!GetICallOrdAndOffset(e) || !ValidateICallDestination() ||
            !ValidateGUIDArgument())
            return false;

        // Good, all checks passed
        return true;
    }
};

// Now that we've implemented all that validation logic, this class is pretty
// simple. This one is responsible for ensuring that the GUID is something that
// we know about, and setting the types of the output variables accordingly.
class GUIDRetyper : public GUIDRelatedVisitorBase {
  public:
    GUIDRetyper(ServiceDescriptorMap &m) : GUIDRelatedVisitorBase(m), mNumApplied(0){};

    // This is the callback function that Hex-Rays invokes for every expression
    // in the CTREE.
    int visit_expr(cexpr_t *e) {
        // Perform the checks from GUIDRelatedVisitorBase. If they fail, we're
        // not equipped to deal with this expression, so bail out.
        if (!ValidateCallAndGUID(e))
            return 0;

        mGUIDArgRefTo = GetReferent(mGUIDArg, "GUID", false);
        if (mGUIDArgRefTo == nullptr)
            return 0;
        ea_t guidAddr = mGUIDArgRefTo->obj_ea;

        // Get interface type name
        std::string GUIDName;
        for (auto g : mProtocols) {
            if (guidAddr == g["address"]) {
                GUIDName = g["prot_name"];
                break;
            }
        }
        if (GUIDName.empty()) {
            return 0;
        }
        std::string interfaceTypeName = GUIDName.substr(0, GUIDName.find("_GUID"));

        // Need to get the type for the interface variable here
        tinfo_t tif;
        import_type(get_idati(), -1, interfaceTypeName.c_str());
        if (!tif.get_named_type(get_idati(), interfaceTypeName.c_str())) {
            return 0;
        }

        qstring tStr;
        if (!tif.get_type_name(&tStr)) {
            return 0;
        }

        tinfo_t tifGuidPtr;
        if (!tifGuidPtr.create_ptr(tif)) {
            return 0;
        }

        // Get the referent for the interface argument.
        cexpr_t *outArgReferent = GetReferent(mOutArg, "ptr", true);
        if (outArgReferent == nullptr)
            return 0;

        // Apply the type to the output referent.
        ApplyType(outArgReferent, tifGuidPtr, tStr);
        return 1;
    }

  protected:
    unsigned int mNumApplied;

    // Given an expression (either a local or global variable) and a type to
    // apply, apply the type. This is just a bit of IDA/Hex-Rays type system
    // skullduggery.
    void ApplyType(cexpr_t *outArg, tinfo_t ptrTif, qstring tStr) {
        ea_t dest_ea = outArg->obj_ea;

        // For global variables
        if (outArg->op == cot_obj) {
            // Just apply the type information to the address
            apply_tinfo(dest_ea, ptrTif, TINFO_DEFINITE);
            ++mNumApplied;

            // Rename global variable
            auto name = "g" + typeToName(static_cast<std::string>(tStr.c_str()));
            set_name(dest_ea, name.c_str(), SN_FORCE);

            // Get xrefs to global variable
            auto xrefs = getXrefs(dest_ea);
            qstring typeName;
            ptr_type_data_t pi;
            ptrTif.get_ptr_details(&pi);
            pi.obj_type.get_type_name(&typeName);
            // Handling all interface functions (to rename function arguments)
            opstroffForGlobalInterface(xrefs, typeName);
        }

        // For local variables
        else if (outArg->op == cot_var) {
            var_ref_t varRef = outArg->v;
            lvar_t &destVar = varRef.mba->vars[varRef.idx];
            // Set the Hex-Rays variable type
            auto name = typeToName(static_cast<std::string>(tStr.c_str()));
            if (setHexRaysVariableInfo(mFuncEa, destVar, ptrTif, name)) {
                ++mNumApplied;
            }
        }
    }
};

class VariablesInfoExtractor : public ctree_visitor_t {
  public:
    VariablesInfoExtractor(ea_t code_addr) : ctree_visitor_t(CV_FAST) {
        mCodeAddr = code_addr;
    };

    uint8_t mAttributes = 0xff;

    // This is the callback function that Hex-Rays invokes for every expression
    // in the CTREE.
    int visit_expr(cexpr_t *e) {
        if (mCodeAddr == BADADDR) {
            return false;
        }

        if (e->ea != mCodeAddr) {
            return false;
        }

        if (e->op != cot_call)
            return false;

        carglist_t *args = e->a;
        if (args == nullptr) {
            return false;
        }

        size_t args_size = args->size();
        if (args_size < 3) {
            return false;
        }

        cexpr_t *attributes_arg = &args->at(2);
        if (attributes_arg->op == cot_num) {
            if (mDebug) {
                msg("Service call: %016llx, Attributes: %d\n",
                    static_cast<uint64_t>(mCodeAddr), attributes_arg->numval());
            }
            attributes_arg->numval();
            mAttributes = static_cast<uint8_t>(attributes_arg->numval());
        }

        return false;
    }

  protected:
    ea_t mCodeAddr = BADADDR;
    bool mDebug = false;
};

```

`efiXplorer/efiSmmUtils.cpp`:

```cpp
/*
 * efiXplorer
 * Copyright (C) 2020-2022 Binarly
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * efiSmmUtils.cpp
 *
 */

#include "efiSmmUtils.h"

static const char plugin_name[] = "efiXplorer";

//--------------------------------------------------------------------------
// Find and mark gSmst global variable via EFI_SMM_SW_DISPATCH(2)_PROTOCOL_GUID
std::vector<ea_t> findSmstSwDispatch(std::vector<ea_t> gBsList) {
    std::vector<ea_t> smst_addrs;
    EfiGuid guid2 = {0x18a3c6dc,
                     0x5eea,
                     0x48c8,
                     {0xa1, 0xc1, 0xb5, 0x33, 0x89, 0xf9, 0x89,
                      0x99}}; // EFI_SMM_SW_DISPATCH2_PROTOCOL_GUID
    EfiGuid guid = {0xe541b773,
                    0xdd11,
                    0x420c,
                    {0xb0, 0x26, 0xdf, 0x99, 0x36, 0x53, 0xf8,
                     0xbf}}; // EFI_SMM_SW_DISPATCH_PROTOCOL_GUID
    std::vector<ea_t> data_addrs = findData(0, BADADDR, guid.uchar_data().data(), 16);
    std::vector<ea_t> data2_addrs = findData(0, BADADDR, guid2.uchar_data().data(), 16);
    data_addrs.insert(data_addrs.end(), data2_addrs.begin(), data2_addrs.end());
    for (auto data_addr : data_addrs) {
        msg("[%s] EFI_SMM_SW_DISPATCH(2)_PROTOCOL_GUID: 0x%016llX\n", plugin_name,
            static_cast<uint64_t>(data_addr));
        std::vector<ea_t> xrefs = getXrefs(data_addr);
        insn_t insn;
        for (auto xref : xrefs) {
            ea_t res_addr = BADADDR;
            ea_t cur_addr = xref;
            // Check 4 instructions below
            for (auto i = 0; i < 4; i++) {
                cur_addr = prev_head(cur_addr, 0);
                decode_insn(&insn, cur_addr);
                if (insn.itype == NN_mov && insn.ops[0].type == o_reg &&
                    insn.ops[0].reg == REG_RAX && insn.ops[1].type == o_mem) {
                    msg("[%s] found gSmst at 0x%016llX, address = 0x%016llX\n",
                        plugin_name, static_cast<uint64_t>(cur_addr),
                        static_cast<uint64_t>(insn.ops[1].addr));
                    res_addr = insn.ops[1].addr;
                    if (find(gBsList.begin(), gBsList.end(), res_addr) != gBsList.end()) {
                        continue;
                    }
                    set_cmt(cur_addr, "_EFI_SMM_SYSTEM_TABLE2 *gSmst;", true);
                    setPtrTypeAndName(res_addr, "gSmst", "_EFI_SMM_SYSTEM_TABLE2");
                    smst_addrs.push_back(res_addr);
                    break;
                }
            }
        }
    }

    return smst_addrs;
}

//--------------------------------------------------------------------------
// Find and mark gSmst global variable via EFI_SMM_BASE2_PROTOCOL_GUID
std::vector<ea_t> findSmstSmmBase(std::vector<ea_t> gBsList) {
    std::vector<ea_t> smst_addrs;
    EfiGuid guid = {
        0xf4ccbfb7,
        0xf6e0,
        0x47fd,
        {0x9d, 0xd4, 0x10, 0xa8, 0xf1, 0x50, 0xc1, 0x91}}; // EFI_SMM_BASE2_PROTOCOL_GUID
    std::vector<ea_t> data_addrs = findData(0, BADADDR, guid.uchar_data().data(), 16);
    for (auto data_addr : data_addrs) {
        msg("[%s] EFI_SMM_BASE2_PROTOCOL_GUID: 0x%016llX\n", plugin_name,
            static_cast<uint64_t>(data_addr));
        std::vector<ea_t> data_xrefs = getXrefs(data_addr);
        insn_t insn;
        for (auto xref : data_xrefs) {
            ea_t res_addr = BADADDR;
            ea_t cur_addr = xref;
            // Check 16 instructions below
            for (auto i = 0; i < 16; i++) {
                cur_addr = next_head(cur_addr, BADADDR);
                decode_insn(&insn, cur_addr);
                if (insn.itype == NN_lea && insn.ops[0].type == o_reg &&
                    insn.ops[0].reg == REG_RDX && insn.ops[1].type == o_mem) {
                    msg("[%s] found gSmst at 0x%016llX, address = 0x%016llX\n",
                        plugin_name, static_cast<uint64_t>(cur_addr),
                        static_cast<uint64_t>(insn.ops[1].addr));
                    res_addr = insn.ops[1].addr;
                    if (addrInVec(gBsList, res_addr)) {
                        continue;
                    }
                    set_cmt(cur_addr, "_EFI_SMM_SYSTEM_TABLE2 *gSmst;", true);
                    setPtrTypeAndName(res_addr, "gSmst", "_EFI_SMM_SYSTEM_TABLE2");
                    smst_addrs.push_back(res_addr);
                    break;
                }
            }
        }
    }

    return smst_addrs;
}

//--------------------------------------------------------------------------
// Find SmiHandler in reg_smi_func function (prefix: Sw, TrapIo, Sx, Gpi, Usb,
// StandbyButton, PeriodicTimer, PowerButton)
std::vector<func_t *> findSmiHandlers(ea_t address, std::string prefix) {
    msg("[%s] Analyze xref to gEfiSmm%sDispatch(2)Protocol: 0x%016llx\n", plugin_name,
        prefix.c_str(), address);

    std::vector<func_t *> smiHandlers;
    insn_t insn;

    // Find Dispatch interface address (via gSmst->SmmLocateProtocol call)

    // Check instruction
    decode_insn(&insn, address);
    if (!(insn.ops[0].type == o_reg && insn.ops[0].reg == REG_RCX)) {
        msg("[%s] %sSmiHandler: wrong xref to dispatch(2) protocol\n", plugin_name,
            prefix.c_str());
        return smiHandlers;
    }

    // Analyze current basic block
    auto ea = address;

    // Search for SmmLocateProtocol
    bool found = false;
    uint64_t dispatch_interface = BADADDR;
    while (!is_basic_block_end(insn, false)) {
        ea = next_head(ea, BADADDR);
        decode_insn(&insn, ea);
        if (insn.itype == NN_callni && insn.ops[0].type == o_displ &&
            insn.ops[0].addr == 0xd0) {
            found = true;
            msg("[%s] %sSmiHandler: found = true\n", plugin_name, prefix.c_str());
            break;
        }
        // Interface in stack
        if (insn.itype == NN_lea && insn.ops[0].type == o_reg &&
            insn.ops[0].reg == REG_R8 && insn.ops[1].type == o_displ &&
            (insn.ops[1].reg == REG_RBP || insn.ops[1].reg == REG_RSP)) {
            if (dispatch_interface == BADADDR) {
                dispatch_interface = insn.ops[1].addr;
            }
        }
        // Interface in data
        if (insn.itype == NN_lea && insn.ops[0].type == o_reg &&
            insn.ops[0].reg == REG_R8 && insn.ops[1].type == o_mem) {
            if (dispatch_interface == BADADDR) {
                dispatch_interface = insn.ops[1].addr;
            }
        }
    }

    if (!found) {
        return smiHandlers;
    }

    if (dispatch_interface == BADADDR) {
        ea = address;
        while (!is_basic_block_end(insn, false)) {
            ea = prev_head(ea, 0);
            decode_insn(&insn, ea);
            // Interface in stack
            if (insn.itype == NN_lea && insn.ops[0].type == o_reg &&
                insn.ops[0].reg == REG_R8 && insn.ops[1].type == o_displ &&
                (insn.ops[1].reg == REG_RBP || insn.ops[1].reg == REG_RSP)) {
                dispatch_interface = insn.ops[1].addr;
                break;
            }
            // Interface in data
            if (insn.itype == NN_lea && insn.ops[0].type == o_reg &&
                insn.ops[0].reg == REG_R8 && insn.ops[1].type == o_mem) {
                dispatch_interface = insn.ops[1].addr;
                break;
            }
        }
    }

    if (dispatch_interface == BADADDR) {
        return smiHandlers;
    }

    msg("[%s] Found EfiSmm%sDispatch(2)Protocol interface: 0x%016llx\n", plugin_name,
        prefix.c_str(), dispatch_interface);

    // TODO: handle xrefs for globals
    // (fw71.bin.out/SmmHddSecurity-316b1230-0500-4592-8c09-eaba0fb6b07f.smm)

    // Track interface stack variable
    ea = address;
    uint16_t reg = BAD_REG;
    uint64_t dispatch_func = BADADDR;
    for (auto i = 0; i < 100; i++) {
        ea = next_head(ea, BADADDR);
        decode_insn(&insn, ea);
        // get Interface base register
        if (insn.itype == NN_mov && insn.ops[0].type == o_reg &&
            (insn.ops[1].type == o_displ || insn.ops[1].type == o_mem)) {
            if (insn.ops[1].addr == dispatch_interface) {
                reg = insn.ops[0].reg;
            } else {
                reg = BAD_REG; // resetting
            }
            continue;
        }

        // resetting (register overwrite or call)
        if (reg != BAD_REG && insn.ops[0].type == o_reg && insn.ops[0].reg == reg) {
            reg = BAD_REG;
            continue;
        }

        // resetting (call)
        if (insn.itype == NN_call) {
            reg = BAD_REG;
            continue;
        }

        // get DispatchFunction address
        if (insn.itype == NN_lea && insn.ops[0].type == o_reg &&
            insn.ops[0].reg == REG_RDX && insn.ops[1].type == o_mem) {
            dispatch_func = insn.ops[1].addr;
            continue;
        }
        if (insn.itype == NN_callni && insn.ops[0].type == o_phrase &&
            insn.ops[0].reg == reg) {
            msg("[%s] Found EfiSmm%sDispatch2Protocol->Register call (0x%016llx)\n",
                plugin_name, prefix.c_str(), static_cast<uint64_t>(ea));
            msg("[%s]  %sSmiHandler: 0x%016llx\n", plugin_name, prefix.c_str(),
                dispatch_func);
            auto handler_func = get_func(dispatch_func);
            if (handler_func == nullptr) {
                add_func(dispatch_func);                // create function
                handler_func = get_func(dispatch_func); // retry
            }
            if (handler_func != nullptr) {
                smiHandlers.push_back(handler_func); // add in result
            }
            reg = BAD_REG; // resetting

            // op_stroff + set_name
            std::string name = prefix + std::string("SmiHandler");
            set_name(dispatch_func, name.c_str(), SN_FORCE);
            std::string prefix_upper;
            std::transform(prefix.begin(), prefix.end(), prefix_upper.begin(), ::toupper);
            std::string type = std::string("EFI_SMM_") + prefix_upper +
                               std::string("_DISPATCH2_PROTOCOL");
            opStroff(ea, type);
        }

        if (insn.itype == NN_retn || insn.itype == NN_int3) {
            break;
        }
    }

    return smiHandlers;
}

//--------------------------------------------------------------------------
// Find {Prefix}SmiHandler function inside SMM drivers
//  * find GUID
//  * get xrefs to GUID
//  * xref will be inside RegSwSmi function
//  * find SmiHandler by pattern (instructions may be out of order)
//        lea     r9, ...
//        lea     r8, ...
//        lea     rdx, <func>
//        call    qword ptr [...]
std::vector<func_t *> findSmiHandlersSmmDispatch(EfiGuid guid, std::string prefix) {
    std::vector<func_t *> smiHandlers;
    std::vector<ea_t> data_addrs = findData(0, BADADDR, guid.uchar_data().data(), 16);
    msg("[%s] %sSmiHandler function finding\n", plugin_name, prefix.c_str());
    for (auto data_addr : data_addrs) {
        std::vector<ea_t> xrefs = getXrefs(data_addr);

        for (auto xref : xrefs) {
            msg("[%s] findSmiHandlers: 0x%016llx\n", plugin_name, xref);
            auto res = findSmiHandlers(xref, prefix);
            smiHandlers.insert(smiHandlers.end(), res.begin(), res.end());
        }
    }

    return smiHandlers;
}

//--------------------------------------------------------------------------
// Find SwSmiHandler function inside SMM drivers in case where
// EFI_SMM_SW_DISPATCH(2)_PROTOCOL_GUID is a local variable
std::vector<func_t *> findSmiHandlersSmmDispatchStack(std::vector<json> stackGuids,
                                                      std::string prefix) {
    // TODO: make it generic
    std::vector<func_t *> smiHandlers;

    for (auto guid : stackGuids) {
        std::string name = static_cast<std::string>(guid["name"]);

        if (name != "EFI_SMM_SW_DISPATCH2_PROTOCOL_GUID" &&
            name != "EFI_SMM_SW_DISPATCH_PROTOCOL_GUID") {
            continue;
        }

        ea_t address = static_cast<ea_t>(guid["address"]);
        msg("[%s] found EFI_SMM_SW_DISPATCH(2)_PROTOCOL_GUID on stack: "
            "0x%016llX\n",
            plugin_name, static_cast<uint64_t>(address));
        auto res = findSmiHandlers(address, prefix);
        smiHandlers.insert(smiHandlers.end(), res.begin(), res.end());
    }

    return smiHandlers;
}

//--------------------------------------------------------------------------
// Find gSmmVar->SmmGetVariable calls via EFI_SMM_VARIABLE_PROTOCOL_GUID
std::vector<ea_t> findSmmGetVariableCalls(std::vector<segment_t *> dataSegments,
                                          std::vector<json> *allServices) {
    msg("[%s] gSmmVar->SmmGetVariable calls finding via "
        "EFI_SMM_VARIABLE_PROTOCOL_GUID\n",
        plugin_name);
    std::vector<ea_t> smmGetVariableCalls;
    EfiGuid guid = {0xed32d533,
                    0x99e6,
                    0x4209,
                    {0x9c, 0xc0, 0x2d, 0x72, 0xcd, 0xd9, 0x98,
                     0xa7}}; // EFI_SMM_VARIABLE_PROTOCOL_GUID

    // Find all EFI_GUID EFI_SMM_VARIABLE_PROTOCOL_GUID addresses
    std::vector<ea_t> data_addrs = findData(0, BADADDR, guid.uchar_data().data(), 16);
    std::vector<ea_t> gSmmVarAddrs; // Find all gSmmVar variables
    for (auto data_addr : data_addrs) {
        std::vector<ea_t> xrefs = getXrefs(data_addr);

        for (auto xref : xrefs) {
            segment_t *seg = getseg(static_cast<ea_t>(xref));
            qstring seg_name;
            get_segm_name(&seg_name, seg);
            msg("[%s] EFI_SMM_VARIABLE_PROTOCOL_GUID xref address: 0x%016llX, "
                "segment: %s\n",
                plugin_name, static_cast<uint64_t>(xref), seg_name.c_str());

            size_t index = seg_name.find(".text");
            if (index == std::string::npos) {
                continue;
            }

            insn_t insn;
            ea_t ea = xref;
            for (auto i = 0; i < 8; i++) {
                // Find `lea r8, <gSmmVar_addr>` instruction
                ea = prev_head(ea, 0);
                decode_insn(&insn, ea);
                if (insn.itype == NN_lea && insn.ops[0].type == o_reg &&
                    insn.ops[0].reg == REG_R8 && insn.ops[1].type == o_mem) {
                    msg("[%s] gSmmVar address: 0x%016llX\n", plugin_name,
                        static_cast<uint64_t>(insn.ops[1].addr));
                    set_cmt(ea, "EFI_SMM_VARIABLE_PROTOCOL *gSmmVar", true);
                    setPtrTypeAndName(insn.ops[1].addr, "gSmmVar",
                                      "EFI_SMM_VARIABLE_PROTOCOL");
                    gSmmVarAddrs.push_back(insn.ops[1].addr);
                    break;
                }
            }
        }
    }

    if (!gSmmVarAddrs.size()) {
        msg("[%s] can't find gSmmVar addresses\n", plugin_name);
        return smmGetVariableCalls;
    }

    for (auto smmVarAddr : gSmmVarAddrs) {
        std::vector<ea_t> smmVarXrefs = getXrefs(static_cast<ea_t>(smmVarAddr));
        for (auto smmVarXref : smmVarXrefs) {
            segment_t *seg = getseg(static_cast<ea_t>(smmVarXref));
            qstring seg_name;
            get_segm_name(&seg_name, seg);
            msg("[%s] gSmmVar xref address: 0x%016llX, segment: %s\n", plugin_name,
                static_cast<uint64_t>(smmVarXref), seg_name.c_str());

            size_t index = seg_name.find(".text");
            if (index == std::string::npos) {
                continue;
            }

            uint16 gSmmVarReg = 0xffff;
            insn_t insn;
            ea_t ea = static_cast<ea_t>(smmVarXref);
            decode_insn(&insn, ea);

            if (insn.itype == NN_mov && insn.ops[0].type == o_reg &&
                insn.ops[1].type == o_mem) {
                gSmmVarReg = insn.ops[0].reg;
                for (auto i = 0; i < 16; i++) {
                    ea = next_head(ea, BADADDR);
                    decode_insn(&insn, ea);

                    if (insn.itype == NN_callni && gSmmVarReg == insn.ops[0].reg &&
                        insn.ops[0].addr == 0) {
                        msg("[%s] gSmmVar->SmmGetVariable found: 0x%016llX\n",
                            plugin_name, static_cast<uint64_t>(ea));

                        if (find(smmGetVariableCalls.begin(), smmGetVariableCalls.end(),
                                 ea) == smmGetVariableCalls.end()) {
                            smmGetVariableCalls.push_back(ea);
                        }

                        // Temporarily add a "virtual" smm service call
                        // for easier annotations and UI

                        std::string cmt = getSmmVarComment();
                        set_cmt(ea, cmt.c_str(), true);
                        opStroff(ea, "EFI_SMM_VARIABLE_PROTOCOL");
                        msg("[%s] 0x%016llX : %s\n", plugin_name,
                            static_cast<uint64_t>(ea), "SmmGetVariable");
                        std::string smm_call = "gSmmVar->SmmGetVariable";
                        json smm_item;
                        smm_item["address"] = ea;
                        smm_item["service_name"] = smm_call;
                        smm_item["table_name"] =
                            static_cast<std::string>("EFI_SMM_VARIABLE_PROTOCOL");
                        smm_item["offset"] = 0;

                        if (find(allServices->begin(), allServices->end(), smm_item) ==
                            allServices->end()) {
                            allServices->push_back(smm_item);
                        }

                        break;
                    }
                }
            }
        }
    }
    return smmGetVariableCalls;
}

std::vector<ea_t> resolveEfiSmmCpuProtocol(std::vector<json> stackGuids,
                                           std::vector<json> dataGuids,
                                           std::vector<json> *allServices) {
    std::vector<ea_t> readSaveStateCalls;
    msg("[%s] Looking for EFI_SMM_CPU_PROTOCOL\n", plugin_name);
    std::vector<ea_t> codeAddrs;
    std::vector<ea_t> gSmmCpuAddrs;
    for (auto guid : stackGuids) {
        std::string name = static_cast<std::string>(guid["name"]);
        if (name != "EFI_SMM_CPU_PROTOCOL_GUID")
            continue;
        ea_t address = static_cast<ea_t>(guid["address"]);
        msg("[%s] found EFI_SMM_CPU_PROTOCOL on stack: 0x%016llX\n", plugin_name,
            static_cast<uint64_t>(address));
        codeAddrs.push_back(address);
    }

    for (auto guid : dataGuids) {
        std::string name = static_cast<std::string>(guid["name"]);
        if (name != "EFI_SMM_CPU_PROTOCOL_GUID")
            continue;

        ea_t address = static_cast<ea_t>(guid["address"]);
        msg("[%s] found EFI_SMM_CPU_PROTOCOL: 0x%016llX\n", plugin_name,
            static_cast<uint64_t>(address));
        std::vector<ea_t> guidXrefs = getXrefs(address);

        for (auto guidXref : guidXrefs) {
            segment_t *seg = getseg(static_cast<ea_t>(guidXref));
            qstring seg_name;
            get_segm_name(&seg_name, seg);
            size_t index = seg_name.find(".text");
            if (index == std::string::npos) {
                continue;
            }
            codeAddrs.push_back(static_cast<ea_t>(guidXref));
        }
    }

    for (auto addr : codeAddrs) {
        msg("[%s] current address: 0x%016llX\n", plugin_name,
            static_cast<uint64_t>(addr));
        insn_t insn;
        ea_t ea = prev_head(addr, 0);

        for (auto i = 0; i < 8; i++) {
            // Find 'lea r8, <gSmmCpu_addr>' instruction
            decode_insn(&insn, ea);
            if (insn.itype == NN_lea && insn.ops[0].type == o_reg &&
                insn.ops[0].reg == REG_R8 && insn.ops[1].type == o_mem) {
                msg("[%s] gSmmCpu address: 0x%016llX\n", plugin_name,
                    static_cast<uint64_t>(insn.ops[1].addr));
                set_cmt(ea, "EFI_SMM_CPU_PROTOCOL *gSmmCpu", true);
                setPtrTypeAndName(insn.ops[1].addr, "gSmmCpu", "EFI_SMM_CPU_PROTOCOL");
                gSmmCpuAddrs.push_back(insn.ops[1].addr);
                break;
            }
            ea = prev_head(ea, 0);
        }
    }

    if (!gSmmCpuAddrs.size()) {
        msg("[%s] can't find gSmmCpu addresses\n", plugin_name);
        return readSaveStateCalls;
    }

    for (auto smmCpu : gSmmCpuAddrs) {
        std::vector<ea_t> smmCpuXrefs = getXrefs(static_cast<ea_t>(smmCpu));

        for (auto smmCpuXref : smmCpuXrefs) {
            segment_t *seg = getseg(static_cast<ea_t>(smmCpuXref));
            qstring seg_name;
            get_segm_name(&seg_name, seg);
            size_t index = seg_name.find(".text");

            if (index == std::string::npos) {
                continue;
            }

            uint16_t gSmmCpuReg = 0xffff;
            insn_t insn;
            ea_t ea = static_cast<ea_t>(smmCpuXref);
            decode_insn(&insn, ea);

            if (insn.itype == NN_mov && insn.ops[0].type == o_reg &&
                insn.ops[1].type == o_mem) {
                gSmmCpuReg = insn.ops[0].reg;

                for (auto i = 0; i < 16; i++) {
                    ea = next_head(ea, BADADDR);
                    decode_insn(&insn, ea);

                    if (insn.itype == NN_callni && gSmmCpuReg == insn.ops[0].reg &&
                        insn.ops[0].addr == 0) {
                        if (find(readSaveStateCalls.begin(), readSaveStateCalls.end(),
                                 ea) == readSaveStateCalls.end()) {
                            readSaveStateCalls.push_back(ea);
                        }

                        opStroff(ea, "EFI_SMM_CPU_PROTOCOL");
                        msg("[%s] 0x%016llX : %s\n", plugin_name,
                            static_cast<uint64_t>(ea), "gSmmCpu->ReadSaveState");
                        std::string smm_call = "gSmmCpu->ReadSaveState";
                        json smm_item;
                        smm_item["address"] = ea;
                        smm_item["service_name"] = smm_call;
                        smm_item["table_name"] =
                            static_cast<std::string>("EFI_SMM_CPU_PROTOCOL");
                        smm_item["offset"] = 0;

                        if (find(allServices->begin(), allServices->end(), smm_item) ==
                            allServices->end()) {
                            allServices->push_back(smm_item);
                        }

                        break;
                    }
                }
            }
        }
    }
    return readSaveStateCalls;
}

ea_t markChildSwSmiHandler(ea_t ea) {
    insn_t insn;
    auto addr = prev_head(ea, 0);
    decode_insn(&insn, addr);
    while (!is_basic_block_end(insn, false)) {
        // for next iteration
        decode_insn(&insn, addr);
        addr = prev_head(addr, 0);

        // check current instruction
        if (insn.itype == NN_lea && insn.ops[0].type == o_reg &&
            insn.ops[0].reg == REG_RCX) {
            if (insn.ops[1].type != o_mem) {
                continue;
            }
            set_name(insn.ops[1].addr, "ChildSwSmiHandler", SN_FORCE);
            return insn.ops[1].addr;
        }
    }
    return BADADDR;
}

```

`efiXplorer/efiSmmUtils.h`:

```h
/*
 * efiXplorer
 * Copyright (C) 2020-2022 Binarly
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * efiSmmUtils.h
 *
 */

#pragma once

#include "efiUtils.h"

std::vector<ea_t> findSmstSwDispatch(std::vector<ea_t> gBsList);
std::vector<ea_t> findSmstSmmBase(std::vector<ea_t> gBsList);
std::vector<func_t *> findSmiHandlers(ea_t address, std::string prefix);
std::vector<func_t *> findSmiHandlersSmmDispatch(EfiGuid guid, std::string prefix);
std::vector<func_t *> findSmiHandlersSmmDispatchStack(std::vector<json> stackGuids,
                                                      std::string prefix);
std::vector<ea_t> findSmmGetVariableCalls(std::vector<segment_t *> dataSegments,
                                          std::vector<json> *allServices);
std::vector<ea_t> resolveEfiSmmCpuProtocol(std::vector<json> stackGuids,
                                           std::vector<json> dataGuids,
                                           std::vector<json> *allServices);
ea_t markChildSwSmiHandler(ea_t ea);

```

`efiXplorer/efiUi.cpp`:

```cpp
/*
 * efiXplorer
 * Copyright (C) 2020-2022 Binarly
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * efiUi.cpp
 *
 */

#include "efiUi.h"
#include "efiDeps.h"
#include "efiGlobal.h"

static const char plugin_name[] = "efiXplorer";

// vulns column widths
const int vulns_chooser_t::widths_vulns[] = {
    16, // Address
    32, // Vuln type
};

// vulns column headers
const char *const vulns_chooser_t::header_vulns[] = {
    "Address", // 0
    "Type",    // 1
};

// guids column widths
const int guids_chooser_t::widths_guids[] = {
    16, // Address
    32, // GUID
    32  // Name
};

// guids column headers
const char *const guids_chooser_t::header_guids[] = {
    "Address", // 0
    "GUID",    // 1
    "Name"     // 2
};

// protocols column widths
const int protocols_chooser_t::widths_protocols[] = {
    16, // Address
    32, // GUID
    32, // Name
    32, // Service
    32  // Module
};

// protocols column headers
const char *const protocols_chooser_t::header_protocols[] = {
    "Address", // 0
    "GUID",    // 1
    "Name",    // 2
    "Service", // 3
    "Module"   // 4
};

// services column widths
const int s_chooser_t::widths_s[] = {
    16, // Address
    32, // Service name
    32, // Table name
};

// services column headers
const char *const s_chooser_t::header_s[] = {
    "Address",      // 0
    "Service name", // 1
    "Table name"    // 2
};

// services column widths
const int nvram_chooser_t::widths_nvram[] = {
    16, // Address
    32, // Variable name
    32, // Variable GUID
    32, // Service
    64, // Attributes
};

// NVRAMs column headers
const char *const nvram_chooser_t::header_nvram[] = {
    "Address",       // 0
    "Variable name", // 1
    "Variable GUID", // 2
    "Service",       // 3
    "Attributes"     // 4
};

inline nvram_chooser_t::nvram_chooser_t(const char *title_, bool ok,
                                        std::vector<json> nvram)
    : chooser_t(0, qnumber(widths_nvram), widths_nvram, header_nvram, title_), list() {
    CASSERT(qnumber(widths_nvram) == qnumber(header_nvram));
    build_list(ok, nvram);
}

void idaapi nvram_chooser_t::get_row(qstrvec_t *cols_, int *, chooser_item_attrs_t *,
                                     size_t n) const {
    ea_t ea = list[n];
    qstrvec_t &cols = *cols_;
    json item = chooser_nvram[n];
    std::string name = static_cast<std::string>(item["VariableName"]);
    std::string guid = static_cast<std::string>(item["VendorGuid"]);
    std::string service = static_cast<std::string>(item["service"]);
    std::string attributes = static_cast<std::string>(item["AttributesHumanReadable"]);
    cols[0].sprnt("%016llX", static_cast<uint64_t>(ea));
    cols[1].sprnt("%s", name.c_str());
    cols[2].sprnt("%s", guid.c_str());
    cols[3].sprnt("%s", service.c_str());
    cols[4].sprnt("%s", attributes.c_str());
    CASSERT(qnumber(header_nvram) == 5);
}

inline vulns_chooser_t::vulns_chooser_t(const char *title_, bool ok,
                                        std::vector<json> vulns)
    : chooser_t(0, qnumber(widths_vulns), widths_vulns, header_vulns, title_), list() {
    CASSERT(qnumber(widths_vulns) == qnumber(header_vulns));
    build_list(ok, vulns);
}

void idaapi vulns_chooser_t::get_row(qstrvec_t *cols_, int *, chooser_item_attrs_t *,
                                     size_t n) const {
    ea_t ea = list[n];
    qstrvec_t &cols = *cols_;
    json item = chooser_vulns[n];
    std::string type = static_cast<std::string>(item["type"]);
    cols[0].sprnt("%016llX", static_cast<uint64_t>(ea));
    cols[1].sprnt("%s", type.c_str());
    CASSERT(qnumber(header_vulns) == 2);
}

inline guids_chooser_t::guids_chooser_t(const char *title_, bool ok,
                                        std::vector<json> guids)
    : chooser_t(0, qnumber(widths_guids), widths_guids, header_guids, title_), list() {
    CASSERT(qnumber(widths_guids) == qnumber(header_guids));
    build_list(ok, guids);
}

void idaapi guids_chooser_t::get_row(qstrvec_t *cols_, int *, chooser_item_attrs_t *,
                                     size_t n) const {
    ea_t ea = list[n];
    qstrvec_t &cols = *cols_;
    json item = chooser_guids[n];
    std::string guid = static_cast<std::string>(item["guid"]);
    std::string name = static_cast<std::string>(item["name"]);
    cols[0].sprnt("%016llX", static_cast<uint64_t>(ea));
    cols[1].sprnt("%s", guid.c_str());
    cols[2].sprnt("%s", name.c_str());
    CASSERT(qnumber(header_guids) == 3);
}

inline protocols_chooser_t::protocols_chooser_t(const char *title_, bool ok,
                                                std::vector<json> protocols,
                                                std::string name_key_)
    : chooser_t(0, qnumber(widths_protocols), widths_protocols, header_protocols, title_),
      list() {
    CASSERT(qnumber(widths_protocols) == qnumber(header_protocols));
    name_key = name_key_;
    build_list(ok, protocols);
}

void idaapi protocols_chooser_t::get_row(qstrvec_t *cols_, int *, chooser_item_attrs_t *,
                                         size_t n) const {
    ea_t ea = list[n];
    qstrvec_t &cols = *cols_;
    json item = chooser_protocols[n];
    std::string name = static_cast<std::string>(item[name_key]);
    std::string service = static_cast<std::string>(item["service"]);
    std::string protGuid = static_cast<std::string>(item["guid"]);
    std::string moduleName = static_cast<std::string>(item["module"]);
    cols[0].sprnt("%016llX", static_cast<uint64_t>(ea));
    cols[1].sprnt("%s", protGuid.c_str());
    cols[2].sprnt("%s", name.c_str());
    cols[3].sprnt("%s", service.c_str());
    cols[4].sprnt("%s", moduleName.c_str());
    CASSERT(qnumber(header_protocols) == 5);
}

inline s_chooser_t::s_chooser_t(const char *title_, bool ok, std::vector<json> services)
    : chooser_t(0, qnumber(widths_s), widths_s, header_s, title_), list() {
    CASSERT(qnumber(widths_s) == qnumber(header_s));
    build_list(ok, services);
}

void idaapi s_chooser_t::get_row(qstrvec_t *cols_, int *, chooser_item_attrs_t *,
                                 size_t n) const {
    ea_t ea = list[n];
    qstrvec_t &cols = *cols_;
    json item = chooser_s[n];
    std::string service_name = static_cast<std::string>(item["service_name"]);
    std::string table_name = static_cast<std::string>(item["table_name"]);
    cols[0].sprnt("%016llX", static_cast<uint64_t>(ea));
    cols[1].sprnt("%s", service_name.c_str());
    cols[2].sprnt("%s", table_name.c_str());
    CASSERT(qnumber(header_s) == 3);
}

bool nvram_show(std::vector<json> nvram, qstring title) {
    bool ok;
    // open the window
    nvram_chooser_t *ch = new nvram_chooser_t(title.c_str(), ok, nvram);
    // default cursor position is 0 (first row)
    ch->choose();
    return true;
}

bool vulns_show(std::vector<json> vulns, qstring title) {
    bool ok;
    // open the window
    vulns_chooser_t *ch = new vulns_chooser_t(title.c_str(), ok, vulns);
    // default cursor position is 0 (first row)
    ch->choose();
    return true;
}

bool guids_show(std::vector<json> guids, qstring title) {
    bool ok;
    // open the window
    guids_chooser_t *ch = new guids_chooser_t(title.c_str(), ok, guids);
    // default cursor position is 0 (first row)
    ch->choose();
    return true;
}

bool protocols_show(std::vector<json> protocols, qstring title) {
    bool ok;
    // open the window
    protocols_chooser_t *ch =
        new protocols_chooser_t(title.c_str(), ok, protocols, "prot_name");
    // default cursor position is 0 (first row)
    ch->choose();
    return true;
}

bool ppis_show(std::vector<json> ppis, qstring title) {
    bool ok;
    // open the window
    protocols_chooser_t *ch =
        new protocols_chooser_t(title.c_str(), ok, ppis, "ppi_name");
    // default cursor position is 0 (first row)
    ch->choose();
    return true;
}

bool services_show(std::vector<json> services, qstring title) {
    bool ok;
    // open the window
    s_chooser_t *ch = new s_chooser_t(title.c_str(), ok, services);
    // default cursor position is 0 (first row)
    ch->choose();
    return true;
}

//-------------------------------------------------------------------------
// Action handler for protocols dependencies
struct protocols_deps_handler_t : public action_handler_t {
    virtual int idaapi activate(action_activation_ctx_t *ctx) {
        auto n = ctx->chooser_selection.at(0);
        json info = g_deps.protocolsChooser[n];

        if (info.is_null()) {
            return -1; // protocol not found
        }

        // get dependencies for protocol
        std::string guid = info["guid"];
        json d = g_deps.protocolsByGuids[guid];

        // print dependencies for current
        // protocol in output window
        std::string s = d.dump(2);
        msg("[%s] dependencies for protocol with GUID %s: %s\n", plugin_name,
            guid.c_str(), s.c_str());

        return 0;
    }

    virtual action_state_t idaapi update(action_update_ctx_t *ctx) {
        return AST_ENABLE_ALWAYS;
    }
};

static protocols_deps_handler_t protocols_deps_ah;
action_desc_t protocols_deps = ACTION_DESC_LITERAL(
    "efiXplorer:protocolsDeps", "Show dependencies", &protocols_deps_ah, NULL, NULL, -1);

void attachActionProtocolsDeps() {
    // Attach action in protocols chooser
    TWidget *widget = find_widget("efiXplorer: protocols");
    if (widget == nullptr) {
        msg("[%s] can not find efiXplorer: protocols chooser", plugin_name);
        return;
    }
    register_action(protocols_deps);
    attach_action_to_popup(widget, nullptr, protocols_deps.name);
}

//-------------------------------------------------------------------------
// Action handler for showing the sequence of modules execution
struct modules_seq_handler_t : public action_handler_t {
    virtual int idaapi activate(action_activation_ctx_t *ctx) {
        g_deps.buildModulesSequence();
        std::string s = g_deps.modulesSequence.dump(2);
        msg("[%s] sequence of modules execution: %s\n", plugin_name, s.c_str());

        return 0;
    }

    virtual action_state_t idaapi update(action_update_ctx_t *ctx) {
        return AST_ENABLE_ALWAYS;
    }
};

static modules_seq_handler_t modules_seq_ah;
action_desc_t modules_seq =
    ACTION_DESC_LITERAL("efiXplorer:modulesSeq", "Show the sequence of modules execution",
                        &modules_seq_ah, NULL, NULL, -1);

void attachActionModulesSeq() {
    // Attach action in protocols chooser
    TWidget *widget = find_widget("efiXplorer: protocols");
    if (widget == nullptr) {
        msg("[%s] can not find efiXplorer: protocols chooser", plugin_name);
        return;
    }
    register_action(modules_seq);
    attach_action_to_popup(widget, nullptr, modules_seq.name);
}

//-------------------------------------------------------------------------
// Action handler (load efiXplorer analysis report)
struct action_handler_loadreport_t : public action_handler_t {
    virtual int idaapi activate(action_activation_ctx_t *ctx) {
        std::filesystem::path reportPath;
        char *file = ask_file(false, "*.json", "Load efiXplorer analysis report");
        if (file == nullptr) {
            msg("[%s] report file not specified\n", plugin_name);
            return -1;
        }
        reportPath /= file;
        msg("[%s] loading report from %s file\n", plugin_name, reportPath.c_str());
        json reportData;
        std::ifstream in(reportPath);
        in >> reportData;

        // Initialize vuln types list
        std::vector<std::string> vulnTypes{
            "smm_callout", "pei_get_variable_buffer_overflow",
            "get_variable_buffer_overflow", "smm_get_variable_buffer_overflow"};

        // Show all choosers with data from report
        qstring title;

        auto protocols = reportData["allProtocols"];
        if (!protocols.is_null()) { // show protocols
            title = "efiXplorer: protocols";
            protocols_show(protocols, title);
        }
        auto ppis = reportData["allPPIs"];
        if (!ppis.is_null()) { // show PPIs
            title = "efiXplorer: PPIs";
            protocols_show(ppis, title);
        }
        auto services = reportData["allServices"];
        if (!services.is_null()) { // show services
            title = "efiXplorer: services";
            services_show(services, title);
        }
        auto guids = reportData["allGuids"];
        if (!guids.is_null()) { // show GUIDs
            title = "efiXplorer: GUIDs";
            guids_show(guids, title);
        }
        auto nvram = reportData["nvramVariables"];
        if (!nvram.is_null()) { // show NVRAM
            title = "efiXplorer: NVRAM";
            nvram_show(nvram, title);
        }
        auto vulns = reportData["vulns"];
        if (!vulns.is_null()) { // show vulns
            std::vector<json> vulnsRes;
            for (auto vulnType : vulnTypes) {
                // For each vuln type add list of vulns in `vulnsRes`
                auto vulnAddrs = vulns[vulnType];
                if (vulnAddrs.is_null()) {
                    continue;
                }
                for (auto addr : vulnAddrs) {
                    json item;
                    item["type"] = vulnType;
                    item["address"] = addr;
                    vulnsRes.push_back(item);
                }
            }
            if (vulnsRes.size()) {
                title = "efiXplorer: vulns";
                vulns_show(vulnsRes, title);
            }
        }

        // Init public EdiDependencies members
        g_deps.getProtocolsChooser(protocols);
        g_deps.getProtocolsByGuids(protocols);

        // Save all protocols information to build dependencies
        attachActionProtocolsDeps();
        attachActionModulesSeq();

        return 0;
    }

    virtual action_state_t idaapi update(action_update_ctx_t *ctx) {
        return AST_ENABLE_ALWAYS;
    }
};
static action_handler_loadreport_t load_report_handler;

//-------------------------------------------------------------------------
// Action to load efiXplorer analysis report
action_desc_t action_load_report =
    ACTION_DESC_LITERAL("efiXplorer:loadReport", "efiXplorer analysis report...",
                        &load_report_handler, NULL, NULL, -1);

```

`efiXplorer/efiUi.h`:

```h
/*
 * efiXplorer
 * Copyright (C) 2020-2022 Binarly
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * efiUi.h
 *
 */

#pragma once

#include "efiUtils.h"

//-------------------------------------------------------------------------
// Vulns chooser
class vulns_chooser_t : public chooser_t {
  protected:
    static const int widths_vulns[];
    static const char *const header_vulns[];

  public:
    eavec_t list;
    json chooser_vulns;

    // this object must be allocated using `new`
    vulns_chooser_t(const char *title, bool ok, std::vector<json> vulns);

    // function that is used to decide whether a new chooser should be opened or
    // we can use the existing one. The contents of the window are completely
    // determined by its title
    virtual const void *get_obj_id(size_t *len) const {
        *len = strlen(title);
        return title;
    }

    // function that returns number of lines in the list
    virtual size_t idaapi get_count() const { return list.size(); }

    // function that generates the list line
    virtual void idaapi get_row(qstrvec_t *cols, int *icon_, chooser_item_attrs_t *attrs,
                                size_t n) const;

    // function that is called when the user hits `Enter`
    virtual cbret_t idaapi enter(size_t n) {
        if (n < list.size())
            jumpto(list[n]);
        return cbret_t();
    }

  protected:
    void build_list(bool ok, std::vector<json> vulns) {
        size_t n = 0;
        for (auto vuln : vulns) {
            list.push_back(vuln["address"]);
            chooser_vulns[n] = vuln;
            n++;
        }
        ok = true;
    };
};

//-------------------------------------------------------------------------
// GUIDs chooser
class guids_chooser_t : public chooser_t {
  protected:
    static const int widths_guids[];
    static const char *const header_guids[];

  public:
    eavec_t list;
    json chooser_guids;

    // this object must be allocated using `new`
    guids_chooser_t(const char *title, bool ok, std::vector<json> guids);

    // function that is used to decide whether a new chooser should be opened or
    // we can use the existing one. The contents of the window are completely
    // determined by its title
    virtual const void *get_obj_id(size_t *len) const {
        *len = strlen(title);
        return title;
    }

    // function that returns number of lines in the list
    virtual size_t idaapi get_count() const { return list.size(); }

    // function that generates the list line
    virtual void idaapi get_row(qstrvec_t *cols, int *icon_, chooser_item_attrs_t *attrs,
                                size_t n) const;

    // function that is called when the user hits `Enter`
    virtual cbret_t idaapi enter(size_t n) {
        if (n < list.size())
            jumpto(list[n]);
        return cbret_t();
    }

  protected:
    void build_list(bool ok, std::vector<json> guids) {
        size_t n = 0;
        for (auto guid : guids) {
            list.push_back(guid["address"]);
            chooser_guids[n] = guid;
            n++;
        }
        ok = true;
    };
};

//-------------------------------------------------------------------------
// Protocols chooser
class protocols_chooser_t : public chooser_t {
  protected:
    static const int widths_protocols[];
    static const char *const header_protocols[];

  public:
    eavec_t list;
    json chooser_protocols;
    std::string name_key;

    // this object must be allocated using `new`
    protocols_chooser_t(const char *title, bool ok, std::vector<json> interfaces,
                        std::string name_key);

    // function that is used to decide whether a new chooser should be opened or
    // we can use the existing one. The contents of the window are completely
    // determined by its title
    virtual const void *get_obj_id(size_t *len) const {
        *len = strlen(title);
        return title;
    }

    // function that returns number of lines in the list
    virtual size_t idaapi get_count() const { return list.size(); }

    // function that generates the list line
    virtual void idaapi get_row(qstrvec_t *cols, int *icon_, chooser_item_attrs_t *attrs,
                                size_t n) const;

    // function that is called when the user hits `Enter`
    virtual cbret_t idaapi enter(size_t n) {
        if (n < list.size())
            jumpto(list[n]);
        return cbret_t();
    }

  protected:
    void build_list(bool ok, std::vector<json> protocols) {
        size_t n = 0;
        for (auto protocol : protocols) {
            list.push_back(protocol["xref"]);
            chooser_protocols[n] = protocol;
            n++;
        }
        ok = true;
    };
};

//-------------------------------------------------------------------------
// Service chooser (address : service_name)
class s_chooser_t : public chooser_t {
  protected:
    static const int widths_s[];
    static const char *const header_s[];

  public:
    eavec_t list;
    json chooser_s;

    // this object must be allocated using `new`
    s_chooser_t(const char *title, bool ok, std::vector<json> services);

    // function that is used to decide whether a new chooser should be opened or
    // we can use the existing one. The contents of the window are completely
    // determined by its title
    virtual const void *get_obj_id(size_t *len) const {
        *len = strlen(title);
        return title;
    }

    // function that returns number of lines in the list
    virtual size_t idaapi get_count() const { return list.size(); }

    // function that generates the list line
    virtual void idaapi get_row(qstrvec_t *cols, int *icon_, chooser_item_attrs_t *attrs,
                                size_t n) const;

    // function that is called when the user hits `Enter`
    virtual cbret_t idaapi enter(size_t n) {
        if (n < list.size())
            jumpto(list[n]);
        return cbret_t();
    }

  protected:
    void build_list(bool ok, std::vector<json> services) {
        size_t n = 0;
        for (auto j_service : services) {
            list.push_back(j_service["address"]);
            chooser_s[n] = j_service;
            n++;
        }
        ok = true;
    };
};

//-------------------------------------------------------------------------
// NVRAM chooser
class nvram_chooser_t : public chooser_t {
  protected:
    static const int widths_nvram[];
    static const char *const header_nvram[];

  public:
    eavec_t list;
    json chooser_nvram;

    // this object must be allocated using `new`
    nvram_chooser_t(const char *title, bool ok, std::vector<json> nvrams);

    // function that is used to decide whether a new chooser should be opened or
    // we can use the existing one. The contents of the window are completely
    // determined by its title
    virtual const void *get_obj_id(size_t *len) const {
        *len = strlen(title);
        return title;
    }

    // function that returns number of lines in the list
    virtual size_t idaapi get_count() const { return list.size(); }

    // function that generates the list line
    virtual void idaapi get_row(qstrvec_t *cols, int *icon_, chooser_item_attrs_t *attrs,
                                size_t n) const;

    // function that is called when the user hits `Enter`
    virtual cbret_t idaapi enter(size_t n) {
        if (n < list.size())
            jumpto(list[n]);
        return cbret_t();
    }

  protected:
    void build_list(bool ok, std::vector<json> nvrams) {
        size_t n = 0;
        for (auto nvram : nvrams) {
            list.push_back(nvram["addr"]);
            chooser_nvram[n] = nvram;
            n++;
        }
        ok = true;
    };
};

extern action_desc_t action_load_report;

bool nvram_show(std::vector<json> nvram, qstring title);
bool vulns_show(std::vector<json> vulns, qstring title);
bool guids_show(std::vector<json> guid, qstring title);
bool protocols_show(std::vector<json> protocols, qstring title);
bool ppis_show(std::vector<json> protocols, qstring title);
bool services_show(std::vector<json> services, qstring title);
void attachActionProtocolsDeps();
void attachActionModulesSeq();

```

`efiXplorer/efiUtils.cpp`:

```cpp
/*
 * efiXplorer
 * Copyright (C) 2020-2022 Binarly
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * efiUtils.cpp
 *
 */

#include "efiUtils.h"
#include "efiGlobal.h"
#include "tables/efi_system_tables.h"

struct pei_services_entry {
    char name[256];
    uint32_t offset;
    char description[1024];
    uint32_t nr_args;
    char prototype[512];
    uint32_t count;
    uint16_t ppi_guid_push_number;
    uint16_t guid_offset;
};

// can be used after Hex-Rays based analysis
std::vector<ea_t> g_get_smst_location_calls;
std::vector<ea_t> g_smm_get_variable_calls;
std::vector<ea_t> g_smm_set_variable_calls;

extern struct pei_services_entry pei_services_table[];
extern size_t pei_services_table_size;

struct variable_ppi_entry {
    char name[256];
    uint32_t offset;
    char description[1024];
    uint32_t nr_args;
    char prototype[512];
};

extern struct variable_ppi_entry variable_ppi_table[];
extern size_t variable_ppi_table_size;

static const char plugin_name[] = "efiXplorer";

//--------------------------------------------------------------------------
// Create EFI_GUID structure
void createGuidStructure(ea_t ea) {
    static const char struct_name[] = "_EFI_GUID";
    struc_t *sptr = get_struc(get_struc_id(struct_name));
    if (sptr == nullptr) {
        sptr = get_struc(add_struc(-1, struct_name));
        if (sptr == nullptr)
            return;
        add_struc_member(sptr, "data1", -1, dword_flag(), NULL, 4);
        add_struc_member(sptr, "data2", -1, word_flag(), NULL, 2);
        add_struc_member(sptr, "data3", -1, word_flag(), NULL, 2);
        add_struc_member(sptr, "data4", -1, byte_flag(), NULL, 8);
    }
    asize_t size = get_struc_size(sptr);
    create_struct(ea, size, sptr->id);
}

//--------------------------------------------------------------------------
// Set EFI_GUID type
void setGuidType(ea_t ea) {
    tinfo_t tinfo;
    if (tinfo.get_named_type(get_idati(), "EFI_GUID")) {
        apply_tinfo(ea, tinfo, TINFO_DEFINITE);
    }
}

//--------------------------------------------------------------------------
// Set type and name
void setTypeAndName(ea_t ea, std::string name, std::string type) {
    set_name(ea, name.c_str(), SN_FORCE);
    tinfo_t tinfo;
    if (tinfo.get_named_type(get_idati(), type.c_str())) {
        apply_tinfo(ea, tinfo, TINFO_DEFINITE);
    }
}

//--------------------------------------------------------------------------
// Get input file type (64-bit, 32-bit image or UEFI firmware)
uint8_t getInputFileType() {
    char fileType[256] = {};
    get_file_type_name(fileType, 256);
    auto fileTypeStr = static_cast<std::string>(fileType);
    size_t index = fileTypeStr.find("AMD64");
    if (index != std::string::npos) {
        // Portable executable for AMD64 (PE)
        return X64;
    }
    index = fileTypeStr.find("80386");
    if (index != std::string::npos) {
        // Portable executable for 80386 (PE)
        return X86;
    }
    index = fileTypeStr.find("UEFI");
    if (index != std::string::npos) {
        // UEFI firmware
        return UEFI;
    }
    return 0;
}

//--------------------------------------------------------------------------
// Get input file type (PEI or DXE-like). No reliable way to determine FFS
// file type given only its PE/TE image section, so hello heuristics
uint8_t guessFileType(uint8_t arch, std::vector<json> *allGuids) {
    if (arch == UEFI) {
        return FTYPE_DXE_AND_THE_LIKE;
    }
    segment_t *hdr_seg = get_segm_by_name("HEADER");
    if (hdr_seg == NULL) {
        return FTYPE_DXE_AND_THE_LIKE;
    }
    uint64_t signature = get_wide_word(hdr_seg->start_ea);
    bool hasPeiGuids = false;
    for (auto guid = allGuids->begin(); guid != allGuids->end(); guid++) {
        json guidVal = *guid;

        if (static_cast<std::string>(guidVal["name"]).find("PEI") != std::string::npos ||
            static_cast<std::string>(guidVal["name"]).find("Pei") != std::string::npos) {
            hasPeiGuids = true;
            break;
        }
    }

    bool hasPeiInPath = false;
    char fileName[0x1000] = {0};
    get_input_file_path(fileName, sizeof(fileName));
    auto fileNameStr = static_cast<std::string>(fileName);
    if ((fileNameStr.find("Pei") != std::string::npos ||
         fileNameStr.find("pei") != std::string::npos || signature == VZ) &&
        arch == X86) {
        hasPeiInPath = true;
    }

    if (arch == X86 && (signature == VZ || hasPeiGuids)) {
        msg("[%s] Parsing binary file as PEI, signature = %lx, hasPeiGuids = %d\n",
            plugin_name, signature, hasPeiGuids);
        return FTYPE_PEI;
    } else {
        msg("[%s] Parsing binary file as DXE/SMM, signature = %lx, hasPeiGuids = %d\n",
            plugin_name, signature, hasPeiGuids);
        return FTYPE_DXE_AND_THE_LIKE;
    }
}

uint8_t getFileType(std::vector<json> *allGuids) {
    uint8_t arch = getInputFileType();
    if (arch == UEFI || arch == X64) {
        return FTYPE_DXE_AND_THE_LIKE;
    }
    auto ftype = guessFileType(arch, allGuids);
    auto btnId =
        ask_buttons("DXE/SMM", "PEI", "", ftype == FTYPE_DXE_AND_THE_LIKE,
                    "Parse file as", ftype == FTYPE_DXE_AND_THE_LIKE ? "DXE/SMM" : "PEI");
    if (btnId == ASKBTN_YES) {
        return FTYPE_DXE_AND_THE_LIKE;
    } else {
        return FTYPE_PEI;
    }
}

//--------------------------------------------------------------------------
// Get boot service description comment
std::string getBsComment(uint32_t offset, uint8_t arch) {
    uint32_t offset_current;
    std::string cmt = "gBS->";
    for (auto i = 0; i < BTABLE_LEN; i++) {
        offset_current = boot_services_table[i].offset64;
        if (arch == X86) {
            offset_current = boot_services_table[i].offset32;
        }
        if (offset == offset_current) {
            cmt += static_cast<std::string>(boot_services_table[i].name) + "()\n" +
                   static_cast<std::string>(boot_services_table[i].prototype) + "\n" +
                   static_cast<std::string>(boot_services_table[i].parameters);
            break;
        }
    }
    return cmt;
}

//--------------------------------------------------------------------------
// Get Pei service description comment (X86 is assumed)
std::string getPeiSvcComment(uint32_t offset) {
    std::string cmt = "gPS->";
    for (auto i = 0; i < pei_services_table_size; i++) {
        if (offset == pei_services_table[i].offset) {
            cmt += static_cast<std::string>(pei_services_table[i].name) + "()\n" +
                   static_cast<std::string>(pei_services_table[i].prototype);
            break;
        }
    }
    return cmt;
}

//--------------------------------------------------------------------------
// Get PPI service description comment (X86 is assumed)
std::string getPPICallComment(uint32_t offset, std::string name) {
    std::string cmt = name + "->"; // VariablePpi
    for (auto i = 0; i < variable_ppi_table_size; i++) {
        if (offset == variable_ppi_table[i].offset) {
            cmt += static_cast<std::string>(variable_ppi_table[i].name) + "()\n" +
                   static_cast<std::string>(variable_ppi_table[i].prototype);
            break;
        }
    }
    return cmt;
}

//--------------------------------------------------------------------------
// Get SMM service description comment
std::string getSmmVarComment() {
    std::string name = "EFI_SMM_VARIABLE_PROTOCOL";
    std::string prototype = "EFI_STATUS (EFIAPI *EFI_GET_VARIABLE)"
                            "(IN CHAR16 *VariableName, "
                            "IN EFI_GUID *VendorGuid, "
                            "OUT UINT32 *Attributes, OPTIONAL "
                            "IN OUT UINTN *DataSize, "
                            "OUT VOID *Data OPTIONAL);";

    std::string cmt = name + "->SmmGetVariable()\n" + prototype;
    return cmt;
}

//--------------------------------------------------------------------------
// Get runtime service description comment
std::string getRtComment(uint32_t offset, uint8_t arch) {
    ea_t offset_arch;
    std::string cmt = "gRT->";
    for (auto i = 0; i < RTABLE_LEN; i++) {
        offset_arch = runtime_services_table[i].offset64;
        if (arch == X86) {
            offset_arch = runtime_services_table[i].offset32;
        }
        if (offset == offset_arch) {
            cmt += static_cast<std::string>(runtime_services_table[i].name) + "()\n" +
                   static_cast<std::string>(runtime_services_table[i].prototype) + "\n" +
                   static_cast<std::string>(runtime_services_table[i].parameters);
            break;
        }
    }
    return cmt;
}

//--------------------------------------------------------------------------
// Find address of global gBS var for X64 module for each service
ea_t findUnknownBsVarX64(ea_t ea) {
    ea_t resAddr = 0;
    insn_t insn;

    // Check 10 instructions below
    for (int i = 0; i < 10; i++) {
        decode_insn(&insn, ea);
        if (insn.itype == NN_mov && insn.ops[0].type == o_reg &&
            insn.ops[0].reg == REG_RAX && insn.ops[1].type == o_mem) {
            msg("[%s] found gBS at 0x%016llX, address = 0x%016llX\n", plugin_name,
                static_cast<uint64_t>(ea), static_cast<uint64_t>(insn.ops[1].addr));
            resAddr = insn.ops[1].addr;
            set_cmt(ea, "EFI_BOOT_SERVICES *gBS", true);
            break;
        }
        ea = prev_head(ea, 0);
    }
    return resAddr;
}

//--------------------------------------------------------------------------
// Get all xrefs for given address
std::vector<ea_t> getXrefs(ea_t addr) {
    std::vector<ea_t> xrefs;
    ea_t xref = get_first_dref_to(addr);
    while (xref != BADADDR) {
        xrefs.push_back(xref);
        xref = get_next_dref_to(addr, xref);
    }
    return xrefs;
}

//--------------------------------------------------------------------------
// Get all xrefs for given array element
std::vector<ea_t> getXrefsToArray(ea_t addr) {
    ea_t first_ea;
    ea_t ea = addr;
    while (true) {
        auto ptr = get_qword(ea);
        auto xrefs = getXrefs(ptr);
        if (std::find(xrefs.begin(), xrefs.end(), ea) == xrefs.end()) {
            break;
        }
        first_ea = ea;
        ea -= 8;
    }
    return getXrefs(first_ea);
}

//--------------------------------------------------------------------------
// Wrapper for op_stroff function
bool opStroff(ea_t addr, std::string type) {
    insn_t insn;
    decode_insn(&insn, addr);
    tid_t struc_id = get_struc_id(type.c_str());
    return op_stroff(insn, 0, &struc_id, 1, 0);
}

//--------------------------------------------------------------------------
// Get pointer to named type and apply it
bool setPtrType(ea_t addr, std::string type) {
    tinfo_t tinfo;
    if (!tinfo.get_named_type(get_idati(), type.c_str())) {
        return false;
    }
    tinfo_t ptrTinfo;
    ptrTinfo.create_ptr(tinfo);
    apply_tinfo(addr, ptrTinfo, TINFO_DEFINITE);
    return true;
}

//--------------------------------------------------------------------------
// Set name and apply pointer to named type
void setPtrTypeAndName(ea_t ea, std::string name, std::string type) {
    set_name(ea, name.c_str(), SN_FORCE);
    setPtrType(ea, type.c_str());
}

//--------------------------------------------------------------------------
// Check for guids.json file exist
bool guidsJsonExists() { return !getGuidsJsonFile().empty(); }

//--------------------------------------------------------------------------
// Get guids.json file name
std::filesystem::path getGuidsJsonFile() {
    std::filesystem::path guidsJsonPath;

    // check {idadir}/plugins/guids.json
    guidsJsonPath /= idadir("plugins");
    guidsJsonPath /= "guids.json";
    if (std::filesystem::exists(guidsJsonPath)) {
        return guidsJsonPath;
    }

    // check {idadir}/plugins/guids/guids.json
    guidsJsonPath.clear();
    guidsJsonPath /= idadir("plugins");
    guidsJsonPath /= "guids";
    guidsJsonPath /= "guids.json";
    if (std::filesystem::exists(guidsJsonPath)) {
        return guidsJsonPath;
    }

    // Try to load it from the per-user directory.
    guidsJsonPath.clear();
    guidsJsonPath /= get_user_idadir();
    guidsJsonPath /= "plugins";
    guidsJsonPath /= "guids.json";
    if (std::filesystem::exists(guidsJsonPath)) {
        return guidsJsonPath;
    }

    guidsJsonPath.clear();
    guidsJsonPath /= get_user_idadir();
    guidsJsonPath /= "plugins";
    guidsJsonPath /= "guids";
    guidsJsonPath /= "guids.json";
    if (std::filesystem::exists(guidsJsonPath)) {
        return guidsJsonPath;
    }

    // Does not exist.
    guidsJsonPath.clear();
    return guidsJsonPath;
}

//--------------------------------------------------------------------------
// Get json summary file name
std::filesystem::path getSummaryFile() {
    std::string idbPath;
    idbPath = get_path(PATH_TYPE_IDB);
    std::filesystem::path logFile;
    logFile /= idbPath;
    logFile.replace_extension(".json");
    return logFile;
}

//--------------------------------------------------------------------------
// Check for summary json file exist
bool summaryJsonExist() {
    std::string idbPath;
    idbPath = get_path(PATH_TYPE_IDB);
    std::filesystem::path logFile;
    logFile /= idbPath;
    logFile.replace_extension(".json");
    return std::filesystem::exists(logFile);
}

//--------------------------------------------------------------------------
// Change EFI_SYSTEM_TABLE *SystemTable to EFI_PEI_SERVICES **PeiService
// for ModuleEntryPoint
void setEntryArgToPeiSvc() {
    for (auto idx = 0; idx < get_entry_qty(); idx++) {
        uval_t ord = get_entry_ordinal(idx);
        ea_t start_ea = get_entry(ord);
        tinfo_t tif_ea;
        if (guess_tinfo(&tif_ea, start_ea) == GUESS_FUNC_FAILED) {
            msg("[%s] guess_tinfo failed, start_ea = 0x%016llX, idx=%d\n", plugin_name,
                static_cast<uint64_t>(start_ea), idx);
            continue;
        }
        func_type_data_t funcdata;
        if (!tif_ea.get_func_details(&funcdata)) {
            msg("[%s] get_func_details failed, %d\n", plugin_name, idx);
            continue;
        }
        tinfo_t tif_pei;
        bool res = tif_pei.get_named_type(get_idati(), "EFI_PEI_SERVICES");
        if (!res) {
            msg("[%s] get_named_type failed, res = %d, idx=%d\n", plugin_name, res, idx);
            continue;
        }
        tinfo_t ptrTinfo;
        tinfo_t ptrPtrTinfo;
        ptrTinfo.create_ptr(tif_pei);
        ptrPtrTinfo.create_ptr(ptrTinfo);
        if (funcdata.size() == 2) {
            funcdata[1].type = ptrPtrTinfo;
            funcdata[1].name = "PeiServices";
            tinfo_t func_tinfo;
            if (!func_tinfo.create_func(funcdata)) {
                msg("[%s] create_func failed, idx=%d\n", plugin_name, idx);
                continue;
            }
            if (!apply_tinfo(start_ea, func_tinfo, TINFO_DEFINITE)) {
                msg("[%s] get_named_type failed, idx=%d\n", plugin_name, idx);
                continue;
            }
        }
    }
}

//--------------------------------------------------------------------------
// Add EFI_PEI_SERVICES_4 structure
bool addStrucForShiftedPtr() {
    auto sid = add_struc(BADADDR, "EFI_PEI_SERVICES_4");
    if (sid == BADADDR) {
        return false;
    }

    auto new_struct = get_struc(sid);
    if (new_struct == nullptr) {
        return false;
    }

    add_struc_member(new_struct, nullptr, 0, dword_flag(), nullptr, 4);
    add_struc_member(new_struct, nullptr, 4, dword_flag(), nullptr, 4);
    set_member_name(new_struct, 0, "PeiServices");
    set_member_name(new_struct, 4, "PeiServices4");

    tinfo_t tinfo;
    if (!tinfo.get_named_type(get_idati(), "EFI_PEI_SERVICES")) {
        return false;
    }

    // set type "EFI_PEI_SERVICES **PeiServices"
    tinfo_t ptrTinfo;
    tinfo_t ptr2Tinfo;
    ptrTinfo.create_ptr(tinfo);
    ptr2Tinfo.create_ptr(ptrTinfo);

    auto member = get_member_by_name(new_struct, "PeiServices");
    set_member_tinfo(new_struct, member, 0, ptr2Tinfo, 0);

    return true;
}

//--------------------------------------------------------------------------
// Change the value of a number to match the data type
uval_t truncImmToDtype(uval_t value, op_dtype_t dtype) {
    switch (dtype) {
    case dt_byte:
        return value & ((1 << 8) - 1);
    case dt_word:
        return value & ((1 << 16) - 1);
    case dt_dword:
        return value & (((uval_t)1 << 32) - 1);
    default:
        return value;
    }
}

//--------------------------------------------------------------------------
// Get module name by address
qstring getModuleNameLoader(ea_t address) {
    segment_t *seg = getseg(address);
    qstring seg_name;
    get_segm_name(&seg_name, seg);
    return seg_name.remove(seg_name.size() - 7, seg_name.size());
}

//--------------------------------------------------------------------------
// Get GUID data by address
json getGuidByAddr(ea_t addr) {
    return json::array(
        {get_wide_dword(addr), get_wide_word(addr + 4), get_wide_word(addr + 6),
         get_wide_byte(addr + 8), get_wide_byte(addr + 9), get_wide_byte(addr + 10),
         get_wide_byte(addr + 11), get_wide_byte(addr + 12), get_wide_byte(addr + 13),
         get_wide_byte(addr + 14), get_wide_byte(addr + 15)});
}

//--------------------------------------------------------------------------
// Validate GUID value
bool checkGuid(json guid) {
    if (static_cast<uint32_t>(guid[0]) == 0x00000000 && (uint16_t)guid[1] == 0x0000) {
        return false;
    }
    if (static_cast<uint32_t>(guid[0]) == 0xffffffff && (uint16_t)guid[1] == 0xffff) {
        return false;
    }
    return true;
}

//--------------------------------------------------------------------------
// Convert GUID value to string
std::string getGuidFromValue(json guid) {
    char guidStr[37] = {0};
    snprintf(guidStr, 37, "%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X",
             static_cast<uint32_t>(guid[0]), static_cast<uint16_t>(guid[1]),
             static_cast<uint16_t>(guid[2]), static_cast<uint8_t>(guid[3]),
             static_cast<uint8_t>(guid[4]), static_cast<uint8_t>(guid[5]),
             static_cast<uint8_t>(guid[6]), static_cast<uint8_t>(guid[7]),
             static_cast<uint8_t>(guid[8]), static_cast<uint8_t>(guid[9]),
             static_cast<uint8_t>(guid[10]));
    return static_cast<std::string>(guidStr);
}

std::vector<uint8_t> unpackGuid(std::string guid) {
    std::vector<uint8_t> res;
    std::string delimiter = "-";
    std::string byte_str;
    uint8_t byte;
    size_t pos = 0;

    auto index = 0;
    while ((pos = guid.find(delimiter)) != std::string::npos) {
        std::vector<uint8_t> tmp;
        auto hex = guid.substr(0, pos);
        if (hex.size() % 2) {
            break;
        }
        for (auto i = 0; i < hex.size(); i += 2) {
            byte_str = hex.substr(i, 2);
            byte = static_cast<uint8_t>(strtol(byte_str.c_str(), NULL, 16));
            tmp.push_back(byte);
        }
        if (index != 3) {
            res.insert(res.end(), tmp.rbegin(), tmp.rend());
        } else {
            res.insert(res.end(), tmp.begin(), tmp.end());
        }
        index += 1;
        guid.erase(0, pos + delimiter.size());
        tmp.clear();
    }

    for (auto i = 0; i < guid.size(); i += 2) {
        byte_str = guid.substr(i, 2);
        byte = static_cast<uint8_t>(strtol(byte_str.c_str(), NULL, 16));
        res.push_back(byte);
    }

    return res;
}

std::vector<ea_t> searchProtocol(std::string protocol) {
    uchar bytes[17] = {0};
    std::vector<ea_t> res;
    auto guid_bytes = unpackGuid(protocol);
    std::copy(guid_bytes.begin(), guid_bytes.end(), bytes);
    ea_t start = 0;
    while (true) {
        ea_t addr = bin_search2(start, BADADDR, bytes, nullptr, 16, BIN_SEARCH_FORWARD);
        if (addr == BADADDR) {
            break;
        }
        res.push_back(addr);
        start = addr + 16;
    }
    return res;
}

bool checkInstallProtocol(ea_t ea) {
    insn_t insn;
    // search for `call [REG + offset]` insn
    // offset in [0x80, 0xA8, 0x148]
    ea_t addr = ea;
    for (auto i = 0; i < 16; i++) {
        addr = next_head(addr, BADADDR);
        decode_insn(&insn, addr);
        if ((insn.itype == NN_jmpni || insn.itype == NN_callni) &&
            insn.ops[0].type == o_displ) {
            auto service = insn.ops[0].addr;
            // check for InstallProtocolInterface, InstallMultipleProtocolInterfaces,
            // SmmInstallProtocolInterface
            if (service == 0x80 || service == 0xa8 || service == 0x148) {
                return true;
            }
        }
    }
    return false;
}

//--------------------------------------------------------------------------
// Convert 64-bit value to hex string
std::string getHex(uint64_t value) {
    char hexstr[21] = {};
    snprintf(hexstr, 21, "%llX", value);
    return static_cast<std::string>(hexstr);
}

//--------------------------------------------------------------------------
// Make sure the first argument looks like protocol
bool bootServiceProtCheck(ea_t callAddr) {
    bool valid = false;
    insn_t insn;
    auto addr = prev_head(callAddr, 0);
    decode_insn(&insn, addr);
    while (!is_basic_block_end(insn, false)) {

        // for next iteration
        decode_insn(&insn, addr);
        addr = prev_head(addr, 0);

        // check current instruction
        if (insn.itype == NN_lea && insn.ops[0].type == o_reg &&
            insn.ops[0].reg == REG_RCX) {
            if (insn.ops[1].type == o_mem) {
                // will still be a false positive if the Handle in
                // SmmInstallProtocolInterface is a global variable)
                valid = true;
            }
            break;
        }
    }
    return valid;
}

bool markCopy(ea_t codeAddr, ea_t varAddr, std::string type) {
    insn_t insn;
    int reg = -1;
    ea_t ea = codeAddr;
    ea_t varCopy = BADADDR;
    decode_insn(&insn, ea);

    // get `reg` value
    if (insn.itype == NN_mov && insn.ops[0].type == o_reg && insn.ops[1].type == o_mem &&
        insn.ops[1].addr == varAddr) {
        reg = insn.ops[0].reg;
    }

    if (reg == -1) {
        return false;
    }

    for (auto i = 0; i < 8; ++i) {
        ea = next_head(ea, BADADDR);
        decode_insn(&insn, ea);

        if (is_basic_block_end(insn, false)) {
            break;
        }

        if ((insn.itype == NN_callni || insn.itype == NN_call) ||
            (insn.ops[0].type == o_reg && insn.ops[0].reg == reg)) {
            break;
        }

        // get `varCopy`
        if (insn.itype == NN_mov && insn.ops[0].type == o_mem &&
            insn.ops[1].type == o_reg && insn.ops[1].reg == reg) {
            varCopy = insn.ops[0].addr;
            msg("[efiXplorer] Found copy for global variable: 0x%016llx\n",
                static_cast<uint64_t>(ea));
            break;
        }
    }

    if (varCopy == BADADDR) {
        return false;
    }

    std::string name;

    if (type == std::string("gSmst")) {
        setPtrTypeAndName(varCopy, "gSmst", "_EFI_SMM_SYSTEM_TABLE2");
    }

    if (type == std::string("gBS")) {
        setPtrTypeAndName(varCopy, "gBS", "EFI_BOOT_SERVICES");
    }

    if (type == std::string("gRT")) {
        setPtrTypeAndName(varCopy, "gRT", "EFI_RUNTIME_SERVICES");
    }

    return true;
}

bool markCopiesForGlobalVars(std::vector<ea_t> globalVars, std::string type) {
    for (auto var : globalVars) {
        auto xrefs = getXrefs(var);
        for (auto addr : xrefs) {
            markCopy(addr, var, type);
        }
    }
    return true;
}

//--------------------------------------------------------------------------
// Generate name string from type
std::string typeToName(std::string type) {
    std::string result;
    size_t counter = 0;
    for (char const &c : type) {
        if ((c >= 'a' && c <= 'z') || (c >= '0' && c <= '9')) {
            result.push_back(c);
            counter += 1;
            continue;
        }

        if (c >= 'A' && c <= 'Z') {
            if (counter > 0) {
                result.push_back(c + 32);
            } else
                result.push_back(c);
            counter += 1;
            continue;
        }

        if (c == '_') {
            counter = 0;
        } else {
            counter += 1;
        }
    }
    return result;
}

xreflist_t xrefsToStackVar(ea_t funcEa, qstring varName) {
    struc_t *frame = get_frame(funcEa);
    func_t *func = get_func(funcEa);
    member_t member; // Get member by name
    bool found = false;
    for (int i = 0; i < frame->memqty; i++) {
        member = frame->members[i];
        qstring name;
        get_member_name(&name, frame->members[i].id);
        if (name == varName) {
            found = true;
            break;
        }
    }
    xreflist_t xrefs_list; // Get xrefs
    if (found) {
        build_stkvar_xrefs(&xrefs_list, func, &member);
    }
    return xrefs_list;
}

void opstroffForAddress(ea_t ea, qstring typeName) {
    insn_t insn;

    for (auto i = 0; i < 16; i++) {
        ea = next_head(ea, BADADDR);
        decode_insn(&insn, ea);
        // Found interface function call
        if ((insn.itype == NN_call || insn.itype == NN_callfi ||
             insn.itype == NN_callni) &&
            (insn.ops[0].type == o_displ || insn.ops[0].type == o_phrase) &&
            insn.ops[0].reg == REG_RAX) {
            opStroff(ea, static_cast<std::string>(typeName.c_str()));
            msg("[%s] Mark arguments at address 0x%016llX (interface type: %s)\n",
                plugin_name, static_cast<uint64_t>(ea), typeName.c_str());

            // check for EfiSmmBase2Protocol->GetSmstLocation
            if (typeName == qstring("EFI_SMM_BASE2_PROTOCOL") &&
                insn.ops[0].type == o_displ && insn.ops[0].addr == 8) {
                if (!addrInVec(g_get_smst_location_calls, ea)) {
                    g_get_smst_location_calls.push_back(ea);
                }
            }

            if (typeName == qstring("EFI_SMM_VARIABLE_PROTOCOL") &&
                insn.ops[0].type == o_phrase) {
                if (!addrInVec(g_smm_get_variable_calls, ea)) {
                    g_smm_get_variable_calls.push_back(ea);
                }
            }

            if (typeName == qstring("EFI_SMM_VARIABLE_PROTOCOL") &&
                insn.ops[0].type == o_displ && insn.ops[0].addr == 0x10) {
                if (!addrInVec(g_smm_set_variable_calls, ea)) {
                    g_smm_set_variable_calls.push_back(ea);
                }
            }

            break;
        }
        // If the RAX value is overridden
        if (insn.ops[0].reg == REG_RAX) {
            break;
        }
    }
}

//--------------------------------------------------------------------------
// Mark the arguments of each function from an interface derived from
// a local variable
void opstroffForInterface(xreflist_t localXrefs, qstring typeName) {
    insn_t insn;
    for (auto xref : localXrefs) {
        decode_insn(&insn, xref.ea);
        if (insn.itype == NN_mov && insn.ops[0].reg == REG_RAX) {
            opstroffForAddress(xref.ea, typeName);
        }
    }
}

//--------------------------------------------------------------------------
// Mark the arguments of each function from an interface derived from
// a global variable
void opstroffForGlobalInterface(std::vector<ea_t> xrefs, qstring typeName) {
    insn_t insn;
    for (auto ea : xrefs) {
        decode_insn(&insn, ea);
        if (insn.itype == NN_mov && insn.ops[0].reg == REG_RAX) {
            opstroffForAddress(ea, typeName);
        }
    }
}

bool addrInVec(std::vector<ea_t> vec, ea_t addr) {
    return find(vec.begin(), vec.end(), addr) != vec.end();
}

bool jsonInVec(std::vector<json> vec, json item) {
    return find(vec.begin(), vec.end(), item) != vec.end();
}

bool addrInTables(std::vector<ea_t> gStList, std::vector<ea_t> gBsList,
                  std::vector<ea_t> gRtList, ea_t ea) {
    return (addrInVec(gStList, ea) || addrInVec(gBsList, ea) || addrInVec(gRtList, ea));
}

std::vector<ea_t> findData(ea_t start_ea, ea_t end_ea, uchar *data, size_t len) {
    std::vector<ea_t> res;
    ea_t start = start_ea;
    int counter = 0;
    while (true) {
        auto ea = bin_search2(start, end_ea, data, nullptr, len, BIN_SEARCH_FORWARD);
        if (ea == BADADDR) {
            break;
        }
        res.push_back(ea);
        start = ea + len;
    }
    return res;
}

//--------------------------------------------------------------------------
// Get wide string by address
std::string getWideString(ea_t addr) {
    std::string res;
    int index = 0;
    while (get_wide_word(addr + index)) {
        auto byte = get_wide_byte(addr + index);
        if (byte < 0x20 || byte > 0x7e) {
            return std::string("INVALID_STRING");
        }
        res.push_back(byte);
        index += 2;
    }
    return res;
}

//--------------------------------------------------------------------------
// Get EfiGuid by address
EfiGuid getGlobalGuid(ea_t addr) {
    EfiGuid guid;
    guid.data1 = get_wide_dword(addr);
    guid.data2 = get_wide_word(addr + 4);
    guid.data3 = get_wide_word(addr + 6);
    for (auto i = 0; i < 8; i++) {
        guid.data4[i] = static_cast<uint8_t>(get_wide_byte(addr + 8 + i));
    }
    return guid;
}

//--------------------------------------------------------------------------
// Get EfiGuid by stack offset
EfiGuid getStackGuid(func_t *f, uint64_t offset) {
    EfiGuid guid;
    insn_t insn;
    auto ea = f->start_ea;
    int counter = 0;
    while (ea <= f->end_ea) {
        if (counter == 16) {
            break;
        }
        ea = next_head(ea, BADADDR);
        decode_insn(&insn, ea);
        if (insn.itype == NN_mov && insn.ops[0].type == o_displ &&
            (insn.ops[0].reg == REG_RSP || insn.ops[0].reg == REG_RBP) &&
            insn.ops[1].type == o_imm) {
            if (insn.ops[0].addr == offset) {
                guid.data1 = insn.ops[1].value;
                counter += 4;
                continue;
            }
            if (insn.ops[0].addr == offset + 4) {
                guid.data2 = insn.ops[1].value & 0xffff;
                guid.data3 = (insn.ops[1].value >> 16) & 0xffff;
                counter += 4;
                continue;
            }
            if (insn.ops[0].addr == offset + 8) {
                auto dword = insn.ops[1].value;
                guid.data4[0] = dword & 0xff;
                guid.data4[1] = (dword >> 8) & 0xff;
                guid.data4[2] = (dword >> 16) & 0xff;
                guid.data4[3] = (dword >> 24) & 0xff;
                counter += 4;
                continue;
            }
            if (insn.ops[0].addr == offset + 12) {
                auto dword = insn.ops[1].value;
                guid.data4[4] = dword & 0xff;
                guid.data4[5] = (dword >> 8) & 0xff;
                guid.data4[6] = (dword >> 16) & 0xff;
                guid.data4[7] = (dword >> 24) & 0xff;
                counter += 4;
                continue;
            }
        }
    }
    return guid;
}

```

`efiXplorer/efiUtils.h`:

```h
/*
 * efiXplorer
 * Copyright (C) 2020-2022 Binarly
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * efiUtils.h
 *
 */

#pragma once

// 3rd party
#include "json.hpp"

#include <algorithm>
#include <allins.hpp>
#include <auto.hpp>
#include <bytes.hpp>
#include <diskio.hpp>
#include <entry.hpp>
#include <filesystem>
#include <frame.hpp>
#include <fstream>
#include <graph.hpp>
#include <ida.hpp>
#include <idp.hpp>
#include <iostream>
#include <kernwin.hpp>
#include <lines.hpp>
#include <loader.hpp>
#include <name.hpp>
#include <pro.h>
#include <stdio.h>
#include <string>
#include <struct.hpp>
#include <typeinf.hpp>

#ifdef HEX_RAYS
#include <hexrays.hpp>
#endif

using namespace nlohmann;

#define BTOA(x) ((x) ? "true" : "false")

#define VZ 0x5A56
#define MZ 0x5A4D

enum ArchFileType { X86 = 32, X64 = 64, UEFI = 96 };

enum FfsFileType { FTYPE_PEI = 6, FTYPE_DXE_AND_THE_LIKE = 7 };

enum BootServicesOffset { BS_OFFSET_64BIT = 0x60, BS_OFFSET_32BIT = 0x3c };

enum RuntimeServiesOffset { RT_OFFSET_64BIT = 0x58, RT_OFFSET_32BIT = 0x38 };

enum Registers32bit {
    REG_EAX,
    REG_ECX,
    REG_EDX,
    REG_EBX,
    REG_ESP,
    REG_EBP,
    REG_ESI,
    REG_EDI,
    REG_AL = 0x10,
    REG_DL = 0x12
};

enum Registers64bit {
    REG_RAX,
    REG_RCX,
    REG_RDX,
    REG_RBX,
    REG_RSP,
    REG_RBP,
    REG_RSI,
    REG_RDI,
    REG_R8,
    REG_R9,
    REG_R10,
    REG_R11,
    REG_R12,
    REG_R13,
    REG_R14,
};

enum HelperValues {
    GUID_OFFSET_DWORD = 4,
    GUID_OFFSET_NONE = 0xffff,
    PUSH_NONE = 0xffff,
    BAD_REG = 0xffff,
};

struct EfiGuid {
    uint32_t data1;
    uint16_t data2;
    uint16_t data3;
    uint8_t data4[8];
    std::vector<uchar> uchar_data() {
        std::vector<uchar> res;
        res.push_back(data1 & 0xff);
        res.push_back(data1 >> 8 & 0xff);
        res.push_back(data1 >> 16 & 0xff);
        res.push_back(data1 >> 24 & 0xff);
        res.push_back(data2 & 0xff);
        res.push_back(data2 >> 8 & 0xff);
        res.push_back(data3 & 0xff);
        res.push_back(data3 >> 8 & 0xff);
        for (auto i = 0; i < 8; i++) {
            res.push_back(data4[i]);
        }
        return res;
    }
    std::string to_string() {
        char res[37] = {0};
        snprintf(res, 37, "%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X", data1,
                 data2, data3, data4[0], data4[1], data4[2], data4[3], data4[4], data4[5],
                 data4[6], data4[7], data4[8]);
        return static_cast<std::string>(res);
    }
};

// Get input file type
// (64-bit, 32-bit image or UEFI firmware)
uint8_t getInputFileType();

// Get image type (PEI or DXE-like)
uint8_t getFileType(std::vector<json> *allGuids);

// Set EFI_GUID type
void setGuidType(ea_t ea);

// Get all data xrefs for address
std::vector<ea_t> getXrefs(ea_t addr);
std::vector<ea_t> getXrefsToArray(ea_t addr);

// Wrapper for op_stroff function
bool opStroff(ea_t addr, std::string type);

// Create EFI_GUID structure
void createGuidStructure(ea_t ea);

// Get boot service description comment
std::string getBsComment(uint32_t offset, uint8_t arch);

// Get PEI service description comment (X86 is assumed)
std::string getPeiSvcComment(uint32_t offset);

// Get PPI service description comment (X86 is assumed)
std::string getPPICallComment(uint32_t offset, std::string name);

// Get SMM service description comment
std::string getSmmVarComment();

// Get runtime service description comment
std::string getRtComment(uint32_t offset, uint8_t arch);

// Find address of global gBS variable
// for X64 module for each service
ea_t findUnknownBsVarX64(ea_t ea);

// Get pointer to named type and apply it
bool setPtrType(ea_t addr, std::string type);

// Set name and apply pointer to named type
void setPtrTypeAndName(ea_t ea, std::string name, std::string type);

// Check for guids.json file exist
bool guidsJsonExists();

// Get guids.json file name
std::filesystem::path getGuidsJsonFile();

// Get json summary file name
std::filesystem::path getSummaryFile();

// Check for summary json file exist
bool summaryJsonExist();

// Change EFI_SYSTEM_TABLE *SystemTable to EFI_PEI_SERVICES **PeiService
// for ModuleEntryPoint
void setEntryArgToPeiSvc();

// Set type and name
void setTypeAndName(ea_t ea, std::string name, std::string type);

// Get module name by address
qstring getModuleNameLoader(ea_t address);

// Print std::vector<json> object
void printVectorJson(std::vector<json> in);

// Change the value of a number to match the data type
uval_t truncImmToDtype(uval_t value, op_dtype_t dtype);

// Get GUID data by address
json getGuidByAddr(ea_t addr);

// Validate GUID value
bool checkGuid(json guid);

// Make sure the first argument looks like protocol
bool bootServiceProtCheck(ea_t callAddr);

// Convert GUID value to string
std::string getGuidFromValue(json guid);

// Convert string GUID to vector of bytes
std::vector<uint8_t> unpackGuid(std::string guid);

// Convert 64-bit value to hex string
std::string getHex(uint64_t value);

// Mark copies for global variables
bool markCopiesForGlobalVars(std::vector<ea_t> globalVars, std::string type);

//  Generate name string from type
std::string typeToName(std::string type);

// Get XREFs to stack variable
xreflist_t xrefsToStackVar(ea_t funcEa, qstring varName);

// Mark the arguments of each function from an interface derived from a local variable
void opstroffForInterface(xreflist_t localXrefs, qstring typeName);

// Mark the arguments of each function from an interface derived from a global variable
void opstroffForGlobalInterface(std::vector<ea_t> xrefs, qstring typeName);

// Find wrappers
bool addrInVec(std::vector<ea_t> vec, ea_t addr);
bool jsonInVec(std::vector<json> vec, json item);
bool addrInTables(std::vector<ea_t> gStList, std::vector<ea_t> gBsList,
                  std::vector<ea_t> gRtList, ea_t ea);

// Search protocol GUID bytes in binary
std::vector<ea_t> searchProtocol(std::string protocol);

bool checkInstallProtocol(ea_t ea);
std::vector<ea_t> findData(ea_t start_ea, ea_t end_ea, uchar *data, size_t len);
std::string getWideString(ea_t addr);
EfiGuid getGlobalGuid(ea_t addr);
EfiGuid getStackGuid(func_t *f, uint64_t offset);
bool addStrucForShiftedPtr();

```

`efiXplorer/efiXplorer.cpp`:

```cpp
/*
 * efiXplorer
 * Copyright (C) 2020-2022 Binarly
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * efiXplorer.cpp
 *
 */

#include "efiXplorer.h"
#include "efiAnalysis.h"
#include "efiGlobal.h"
#include "efiUi.h"

static const char plugin_name[] = "efiXplorer";
static const char plugin_hotkey[] = "Ctrl+Alt+E";
static const char plugin_comment[] =
    "This plugin performs automatic analysis of the input UEFI module";
static const char plugin_help[] =
    "This plugin performs automatic analysis of the input UEFI module";
static const char welcome_msg[] = "      ____ _  __     __\n"
                                  " ___ / _(_) |/_/__  / /__  _______ ____\n"
                                  "/ -_) _/ />  </ _ \\/ / _ \\/ __/ -_) __/\n"
                                  "\\__/_//_/_/|_/ .__/_/\\___/_/  \\__/_/\n"
                                  "            /_/\n";

// Default arguments
struct args g_args = {/* module_type */ DXE_SMM, /* disable_ui */ 0,
                      /* disable_vuln_hunt */ 0};

#if IDA_SDK_VERSION < 760
hexdsp_t *hexdsp = nullptr;
#endif

//--------------------------------------------------------------------------
static plugmod_t *idaapi init(void) {
    uint8_t arch = getInputFileType();
    if (arch != X86 && arch != X64 && arch != UEFI) {
        return PLUGIN_SKIP;
    }

    msg(welcome_msg);
    msg("%s\n\n", COPYRIGHT);

    // Register action
    register_action(action_load_report);
    attach_action_to_menu("File/Load file/", action_load_report.name, SETMENU_APP);

    return PLUGIN_KEEP;
}

//--------------------------------------------------------------------------
bool idaapi run(size_t arg) {

    if (arg >> 0 & 1) { // Parse arg value:
        //  * arg = 0 (000): default (DXE)
        //  * arg = 1 (001): default (PEI, 32-bit binaries only)
        //  * arg = 2 (010): disable_ui (DXE)
        //  * arg = 3 (011): disable_ui (PEI, 32-bit binaries only)
        //  * arg = 4 (100): disable_vuln_hunt (DXE)
        //  * arg = 5 (101): disable_vuln_hunt (PEI, 32-bit binaries only)
        //  * arg = 6 (110): disable_ui & disable_vuln_hunt (DXE)
        //  * arg = 7 (111): disable_ui & disable_vuln_hunt (PEI, 32-bit binaries only)
        g_args.module_type = PEI;
    }

    if (arg >> 1 & 1) {
        g_args.disable_ui = 1;
    }
    if (arg >> 2 & 1) {
        g_args.disable_vuln_hunt = 1;
    }

    msg("[%s] plugin run with argument %lu\n", plugin_name, arg);
    msg("[%s] disable_ui = %d, disable_vuln_hunt = %d\n", plugin_name, g_args.disable_ui,
        g_args.disable_vuln_hunt);

    bool guidsJsonOk = guidsJsonExists();
    msg("[%s] guids.json exists: %s\n", plugin_name, BTOA(guidsJsonOk));

    if (!guidsJsonOk) {
        std::string msg_text =
            "guids.json file not found, copy \"guids\" directory to <IDA_DIR>/plugins";
        msg("[%s] %s\n", plugin_name, msg_text.c_str());
        warning("%s: %s\n", plugin_name, msg_text.c_str());
        return false;
    }

    uint8_t arch = getInputFileType();
    if (arch == X64) {
        msg("[%s] input file is portable executable for AMD64 (PE)\n", plugin_name);
        EfiAnalysis::efiAnalyzerMainX64();
    }

    if (arch == X86) {
        msg("[%s] input file is portable executable for 80386 (PE)\n", plugin_name);
        EfiAnalysis::efiAnalyzerMainX86();
    }

    if (arch == UEFI) {
        warning("%s: analysis may take some time, please wait for it to complete\n",
                plugin_name);
        msg("[%s] input file is UEFI firmware\n", plugin_name);
        EfiAnalysis::efiAnalyzerMainX64();
    }

    // Reset arguments
    g_args = {DXE_SMM, 0, 0};

    return true;
}

//--------------------------------------------------------------------------
// PLUGIN DESCRIPTION BLOCK
plugin_t PLUGIN = {
    IDP_INTERFACE_VERSION,
    0,              // plugin flags
    init,           // initialize plugin
    nullptr,        // terminate plugin
    run,            // invoke plugin
    plugin_comment, // long comment about the plugin
    plugin_help,    // multiline help about the plugin
    plugin_name,    // the preferred short name of the plugin
    plugin_hotkey   // the preferred hotkey to run the plugin
};

```

`efiXplorer/efiXplorer.h`:

```h
/*
 * efiXplorer
 * Copyright (C) 2020-2022 Binarly
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * efiXplorer.h
 *
 */

#pragma once

#include "efiUtils.h"

#define COPYRIGHT "(c) 2020-2021, Binarly - https://github.com/binarly-io/efiXplorer"

```

`efiXplorer/tables/efi_pei_tables.h`:

```h
/*
 * ______________________.___
 * \_   _____/\_   _____/|   |
 *  |    __)_  |    __)  |   |
 *  |        \ |     \   |   |
 * /_______  / \___  /   |___|
 *         \/      \/
 *   _________       .__                 ____  __.      .__  _____
 *  /   _____/_  _  _|__| ______ _____  |    |/ _| ____ |__|/ ____\____
 *  \_____  \\ \/ \/ /  |/  ___//  ___/ |      <  /    \|  \   __\/ __ \
 *  /        \\     /|  |\___ \ \___ \  |    |  \|   |  \  ||  | \  ___/
 * /_______  / \/\_/ |__/____  >____  > |____|__ \___|  /__||__|  \___  >
 *         \/                \/     \/          \/    \/              \/
 *
 * EFI Swiss Knife
 * An IDA plugin to improve (U)EFI reversing
 *
 * Copyright (C) 2016, 2017  Pedro Vilaça (fG!) - reverser@put.as -
 * https://reverse.put.as
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * efi_system_tables.h
 *
 */

#include "stdint.h"

struct pei_services_entry {
    char name[256];
    uint32_t offset;
    char description[1024];
    uint32_t nr_args;
    char prototype[512];
    uint32_t count;
    // arg number with Ppi guid or PUSH_NONE if no Ppi guid applicable
    uint16_t ppi_guid_push_number;
    // GUID_OFFSET_NONE if the argument is Guid (or if no Guid arg exists)
    // Otherwise, if the arg is EFI_PEI_PPI_DESCRIPTOR/EFI_PEI_NOTIFY_DESCRIPTOR,
    // offset of Guid field inside a given structure (in bytes).
    uint16_t guid_offset;
};

struct pei_services_entry pei_services_table[] = {
    {"InstallPpi", 0x18,
     "This service is the first one provided by the PEI Foundation. This "
     "function installs an interface in the PEI PPI database by GUID. The "
     "purpose of the service is to publish an interface that other parties can "
     "use to call additional PEIMs.",
     2,
     "EFI_STATUS(EFIAPI * EFI_PEI_INSTALL_PPI) (IN CONST EFI_PEI_SERVICES "
     "**PeiServices, IN CONST EFI_PEI_PPI_DESCRIPTOR *PpiList)",
     0, 2, GUID_OFFSET_DWORD},
    {"ReInstallPpi", 0x1C,
     "This function reinstalls an interface in the PEI PPI database by GUID. "
     "The purpose of the service is to publish an interface that other parties "
     "can use to replace a same-named interface in the protocol database with "
     "a different interface.",
     3,
     "EFI_STATUS(EFIAPI * EFI_PEI_REINSTALL_PPI) (IN CONST EFI_PEI_SERVICES "
     "**PeiServices, IN CONST EFI_PEI_PPI_DESCRIPTOR *OldPpi, IN CONST "
     "EFI_PEI_PPI_DESCRIPTOR *NewPpi)",
     0, 3, GUID_OFFSET_DWORD},
    {"LocatePpi", 0x20,
     "This function locates an interface in the PEI PPI database by GUID.", 5,
     "EFI_STATUS(EFIAPI * EFI_PEI_LOCATE_PPI) (IN CONST EFI_PEI_SERVICES "
     "**PeiServices, IN CONST EFI_GUID *Guid, IN UINTN Instance, IN OUT "
     "EFI_PEI_PPI_DESCRIPTOR **PpiDescriptor OPTIONAL, IN OUT VOID **Ppi)",
     0, 2, GUID_OFFSET_NONE},
    {"NotifyPpi", 0x24,
     "This function installs a notification service to be called back when a "
     "given interface is installed or reinstalled. The purpose of the service "
     "is to publish an interface that other parties can use to call additional "
     "PPIs that may materialize later.",
     2,
     "EFI_STATUS(EFIAPI * EFI_PEI_NOTIFY_PPI) (IN CONST EFI_PEI_SERVICES "
     "**PeiServices, IN CONST EFI_PEI_NOTIFY_DESCRIPTOR *NotifyList)",
     0, PUSH_NONE, GUID_OFFSET_NONE},
    {"GetBootMode", 0x28, "This function returns the present value of the boot mode.", 2,
     "EFI_STATUS(EFIAPI * EFI_PEI_GET_BOOT_MODE) (IN CONST EFI_PEI_SERVICES "
     "**PeiServices, OUT EFI_BOOT_MODE *BootMode)",
     0, PUSH_NONE, GUID_OFFSET_NONE},
    {"SetBootMode", 0x2C, "This function sets the value of the boot mode.", 2,
     "EFI_STATUS(EFIAPI * EFI_PEI_SET_BOOT_MODE) (IN CONST EFI_PEI_SERVICES "
     "**PeiServices, IN EFI_BOOT_MODE BootMode)",
     0, PUSH_NONE, GUID_OFFSET_NONE},
    {"GetHobList", 0x30,
     "This function returns the pointer to the list of Hand-Off Blocks (HOBs) "
     "in memory.",
     2,
     "EFI_STATUS(EFIAPI * EFI_PEI_GET_HOB_LIST) (IN CONST EFI_PEI_SERVICES "
     "**PeiServices, OUT VOID **HobList)",
     0, PUSH_NONE, GUID_OFFSET_NONE},
    {"CreateHob", 0x34,
     "This service, published by the PEI Foundation, abstracts the creation of "
     "a Hand-Off Block's (HOB's) headers.",
     4,
     "EFI_STATUS(EFIAPI * EFI_PEI_CREATE_HOB) (IN CONST EFI_PEI_SERVICES "
     "**PeiServices, IN UINT16 Type, IN UINT16 Length, IN OUT VOID **Hob)",
     0, PUSH_NONE, GUID_OFFSET_NONE},
    {"FfsFindNextVolume", 0x38,
     "The purpose of the service is to abstract the capability of the PEI "
     "Foundation to discover instances of firmware volumes in the system. "
     "Given the input file pointer, this service searches for the next "
     "matching file in the Firmware File System (FFS) volume.",
     3,
     "EFI_STATUS (EFIAPI *EFI_PEI_FFS_FIND_NEXT_VOLUME) (IN struct "
     "_EFI_PEI_SERVICES **PeiServices, IN UINTN Instance, IN OUT "
     "EFI_FIRMWARE_VOLUME_HEADER **FwVolHeader)",
     0, PUSH_NONE, GUID_OFFSET_NONE},
    {"FfsFindNextFile", 0x3C,
     "The purpose of the service is to abstract the capability of the PEI "
     "Foundation to discover instances of firmware files in the system. Given "
     "the input file pointer, this service searches for the next matching file "
     "in the Firmware File System (FFS) volume.",
     4,
     "EFI_STATUS (EFIAPI *EFI_PEI_FFS_FIND_NEXT_FILE) (IN struct "
     "_EFI_PEI_SERVICES **PeiServices, IN EFI_FV_FILETYPE SearchType, IN "
     "EFI_FIRMWARE_VOLUME_HEADER *FwVolHeader, IN OUT EFI_FFS_FILE_HEADER "
     "**FileHeader);",
     0, PUSH_NONE, GUID_OFFSET_NONE},
    {"FfsFindSectionData", 0x40,
     "Given the input file pointer, this service searches for the next "
     "matching file in the Firmware File System (FFS) volume.",
     4,
     "EFI_STATUS (EFIAPI *EFI_PEI_FFS_FIND_SECTION_DATA) (IN struct "
     "_EFI_PEI_SERVICES **PeiServices, IN EFI_SECTION_TYPE SectionType, IN "
     "EFI_FFS_FILE_HEADER *FfsFileHeader, IN OUT VOID **SectionData);",
     0, PUSH_NONE, GUID_OFFSET_NONE},
    {"InstallPeiMemory", 0x44,
     "This function registers the found memory configuration with the PEI "
     "Foundation.",
     3,
     "EFI_STATUS(EFIAPI * EFI_PEI_INSTALL_PEI_MEMORY) (IN CONST "
     "EFI_PEI_SERVICES **PeiServices, IN EFI_PHYSICAL_ADDRESS MemoryBegin, IN "
     "UINT64 MemoryLength)",
     0, PUSH_NONE, GUID_OFFSET_NONE},
    {"AllocatePages", 0x48,
     "The purpose of the service is to publish an interface that allows PEIMs "
     "to allocate memory ranges that are managed by the PEI Foundation.",
     4,
     "EFI_STATUS(EFIAPI * EFI_PEI_ALLOCATE_PAGES) (IN CONST EFI_PEI_SERVICES "
     "**PeiServices, IN EFI_MEMORY_TYPE MemoryType, IN UINTN Pages, OUT "
     "EFI_PHYSICAL_ADDRESS *Memory)",
     0, PUSH_NONE, GUID_OFFSET_NONE},
    {"AllocatePool", 0x4C,
     "The purpose of this service is to publish an interface that allows PEIMs "
     "to allocate memory ranges that are managed by the PEI Foundation.",
     3,
     " EFI_STATUS(EFIAPI * EFI_PEI_ALLOCATE_POOL) (IN CONST EFI_PEI_SERVICES "
     "**PeiServices, IN UINTN Size, OUT VOID **Buffer)",
     0, PUSH_NONE, GUID_OFFSET_NONE},
    {"CopyMem", 0x50, "This service copies the contents of one buffer to another buffer.",
     3,
     "VOID(EFIAPI * EFI_PEI_COPY_MEM) (IN VOID *Destination, IN VOID *Source, "
     "IN UINTN Length)",
     0, PUSH_NONE, GUID_OFFSET_NONE},
    {"SetMem", 0x54, "The service fills a buffer with a specified value.", 3,
     "VOID(EFIAPI * EFI_PEI_SET_MEM) (IN VOID *Buffer, IN UINTN Size, IN UINT8 "
     "Value)",
     0, PUSH_NONE, GUID_OFFSET_NONE},
    {"ReportStatusCode", 0x58,
     "This service publishes an interface that allows PEIMs to report status codes. \
        ReportStatusCode() is called by PEIMs that wish to report status information on their progress. The principal use model is for a PEIM to emit one of the standard 32-bit error codes. This will allow a platform owner to ascertain the state of the system, especially under conditions where the full consoles might not have been installed.",
     6,
     "EFI_STATUS(EFIAPI * EFI_PEI_REPORT_STATUS_CODE) (IN CONST "
     "EFI_PEI_SERVICES **PeiServices, IN EFI_STATUS_CODE_TYPE Type, IN "
     "EFI_STATUS_CODE_VALUE Value, IN UINT32 Instance, IN CONST EFI_GUID "
     "*CallerId OPTIONAL, IN CONST EFI_STATUS_CODE_DATA *Data OPTIONAL)",
     0, PUSH_NONE, GUID_OFFSET_NONE},
    {"ResetSystem", 0x5C, "Resets the entire platform. \
        This service resets the entire platform, including all processors and devices, and reboots the system. This service will never return EFI_SUCCESS.",
     1,
     "EFI_STATUS(EFIAPI * EFI_PEI_RESET_SYSTEM) (IN CONST EFI_PEI_SERVICES "
     "**PeiServices)",
     0, PUSH_NONE, GUID_OFFSET_NONE},
    {"CpuIo", 0x60,
     "Provides an interface that a PEIM can call to execute an I/O "
     "transaction. This service is installed by an architectural PEI driver by "
     "copying the interface pointer into this table.",
     1, "", 0, PUSH_NONE, GUID_OFFSET_NONE},
    {"PciCfg", 0x64,
     "Provides an interface that a PEIM can call to execute PCI Configuration "
     "transactions. This service is installed by an architectural PEI driver "
     "by copying the interface pointer into this table.",
     1, "", 0, PUSH_NONE, GUID_OFFSET_NONE}};

size_t pei_services_table_size = sizeof(pei_services_table) / sizeof(pei_services_entry);

char variable_ppi_name[] = "VariablePPI";
struct variable_ppi_entry {
    char name[256];
    uint32_t offset;
    char description[1024];
    uint32_t nr_args;
    char prototype[512];
};

struct variable_ppi_entry variable_ppi_table[] = {
    {"GetVariable", 0x0,
     "This service retrieves a variable's value using its name and GUID."
     "Read the specified variable from the UEFI variable store. If the Data"
     "buffer is too small to hold the contents of the variable,"
     "the error EFI_BUFFER_TOO_SMALL is returned and DataSize is set to the"
     "required buffer size to obtain the data.",
     6,
     "EFI_STATUS (EFIAPI *EFI_PEI_GET_VARIABLE2)"
     "(IN CONSTEFI_PEI_READ_ONLY_VARIABLE2_PPI *This, "
     "IN CONST CHAR16 *VariableName, IN CONST EFI_GUID *VariableGuid,"
     "OUT UINT32 *Attributes, IN OUT UINTN *DataSize, OUT VOID *Data OPTIONAL);"},
    {"NextVariableName", 0x4,
     "This function is called multiple times to retrieve the VariableName"
     "and VariableGuid of all variables currently available in the system."
     "On each call, the previous results are passed into the interface, "
     "and, on return, the interface returns the data for the next "
     "interface. When the entire variable list has been returned, "
     "EFI_NOT_FOUND is returned.",
     4,
     "EFI_STATUS (EFIAPI *EFI_PEI_GET_NEXT_VARIABLE_NAME2)"
     "(IN CONST EFI_PEI_READ_ONLY_VARIABLE2_PPI *This,"
     "IN OUT UINTN *VariableNameSize, IN OUT CHAR16 *VariableName,"
     "IN OUT EFI_GUID *VariableGuid);"}};

size_t variable_ppi_table_size = sizeof(variable_ppi_table) / sizeof(variable_ppi_entry);

```

`efiXplorer/tables/efi_services.h`:

```h
/*
 * efiXplorer
 * Copyright (C) 2020-2022  Binarly
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 *
 * efi_services.h
 *
 */

enum BootServicesOffsets64bit {
    RaiseTPLOffset64 = 0x18,
    RestoreTPLOffset64 = 0x20,
    AllocatePagesOffset64 = 0x28,
    FreePagesOffset64 = 0x30,
    GetMemoryMapOffset64 = 0x38,
    AllocatePoolOffset64 = 0x40,
    FreePoolOffset64 = 0x48,
    CreateEventOffset64 = 0x50,
    SetTimerOffset64 = 0x58,
    WaitForEventOffset64 = 0x60,
    SignalEventOffset64 = 0x68,
    CloseEventOffset64 = 0x70,
    CheckEventOffset64 = 0x78,
    InstallProtocolInterfaceOffset64 = 0x80,
    RenstallProtocolInterfaceOffset64 = 0x88,
    UninstallProtocolInterfaceOffset64 = 0x90,
    HandleProtocolOffset64 = 0x98,
    RegisterProtocolNotifyOffset64 = 0xa8,
    LocateHandleOffset64 = 0xb0,
    LocateDevicePathOffset64 = 0xb8,
    InstallConfigurationTableOffset64 = 0xc0,
    LoadImageOffset64 = 0xc8,
    StartImageOffset64 = 0xd0,
    ExitOffset64 = 0xd8,
    UnloadImageOffset64 = 0xe0,
    ExitBootServicesOffset64 = 0xe8,
    GetNextMonotonicCountOffset64 = 0xf0,
    StallOffset64 = 0xf0,
    SetWatchdogTimerOffset64 = 0x100,
    ConnectControllerOffset64 = 0x108,
    DisconnectControllerOffset64 = 0x110,
    OpenProtocolOffset64 = 0x118,
    CloseProtocolOffset64 = 0x120,
    OpenProtocolInformationOffset64 = 0x128,
    ProtocolsPerHandleOffset64 = 0x130,
    LocateHandleBufferOffset64 = 0x138,
    LocateProtocolOffset64 = 0x140,
    InstallMultipleProtocolInterfacesOffset64 = 0x148,
    UninstallMultipleProtocolInterfacesOffset64 = 0x150,
    CalculateCrc32Offset64 = 0x158,
    CopyMemOffset64 = 0x160,
    SetMemOffset64 = 0x168,
    CreateEventExOffset64 = 0x170,
};

enum BootServicesOffsets32bit {
    RaiseTPLOffset32 = 0x18,
    RestoreTPLOffset32 = 0x1c,
    AllocatePagesOffset32 = 0x20,
    FreePagesOffset32 = 0x24,
    GetMemoryMapOffset32 = 0x28,
    AllocatePoolOffset32 = 0x2c,
    FreePoolOffset32 = 0x30,
    CreateEventOffset32 = 0x34,
    SetTimerOffset32 = 0x38,
    WaitForEventOffset32 = 0x3c,
    SignalEventOffset32 = 0x40,
    CloseEventOffset32 = 0x44,
    CheckEventOffset32 = 0x48,
    InstallProtocolInterfaceOffset32 = 0x4c,
    RenstallProtocolInterfaceOffset32 = 0x50,
    UninstallProtocolInterfaceOffset32 = 0x54,
    HandleProtocolOffset32 = 0x58,
    RegisterProtocolNotifyOffset32 = 0x60,
    LocateHandleOffset32 = 0x64,
    LocateDevicePathOffset32 = 0x68,
    InstallConfigurationTableOffset32 = 0x6c,
    LoadImageOffset32 = 0x70,
    StartImageOffset32 = 0x74,
    ExitOffset32 = 0x78,
    UnloadImageOffset32 = 0x7c,
    ExitBootServicesOffset32 = 0x80,
    GetNextMonotonicCountOffset32 = 0x84,
    StallOffset32 = 0x88,
    SetWatchdogTimerOffset32 = 0x8c,
    ConnectControllerOffset32 = 0x90,
    DisconnectControllerOffset32 = 0x94,
    OpenProtocolOffset32 = 0x98,
    CloseProtocolOffset32 = 0x9c,
    OpenProtocolInformationOffset32 = 0xa0,
    ProtocolsPerHandleOffset32 = 0xa4,
    LocateHandleBufferOffset32 = 0xa8,
    LocateProtocolOffset32 = 0xac,
    InstallMultipleProtocolInterfacesOffset32 = 0xb0,
    UninstallMultipleProtocolInterfacesOffset32 = 0xb4,
    CalculateCrc32Offset32 = 0xb8,
    CopyMemOffset32 = 0xbc,
    SetMemOffset32 = 0xc0,
    CreateEventExOffset32 = 0xc4,
};

enum RuntimeServicesOffsets64bit {
    GetTimeOffset64 = 0x18,
    SetTimeOffset64 = 0x20,
    GetWakeupTimeOffset64 = 0x28,
    SetWakeupTimeOffset64 = 0x30,
    SetVirtualAddressMapOffset64 = 0x38,
    ConvertPointerOffset64 = 0x40,
    GetVariableOffset64 = 0x48,
    GetNextVariableNameOffset64 = 0x50,
    SetVariableOffset64 = 0x58,
    GetNextHighMonotonicCountOffset64 = 0x60,
    ResetSystemOffset64 = 0x68,
    UpdateCapsuleOffset64 = 0x70,
    QueryCapsuleCapabilitiesOffset64 = 0x78,
    QueryVariableInfoOffset64 = 0x80,
};

enum RuntimeServicesOffsets32bit {
    GetTimeOffset32 = 0x18,
    SetTimeOffset32 = 0x1c,
    GetWakeupTimeOffset32 = 0x20,
    SetWakeupTimeOffset32 = 0x24,
    SetVirtualAddressMapOffset32 = 0x28,
    ConvertPointerOffset32 = 0x2c,
    GetVariableOffset32 = 0x30,
    GetNextVariableNameOffset32 = 0x34,
    SetVariableOffset32 = 0x38,
    GetNextHighMonotonicCountOffset32 = 0x3c,
    ResetSystemOffset32 = 0x40,
    UpdateCapsuleOffset32 = 0x44,
    QueryCapsuleCapabilitiesOffset32 = 0x48,
    QueryVariableInfoOffset32 = 0x4c,
};

enum SmmServicesOffsets64bit {
    SmmInstallConfigurationTableOffset64 = 0x28,
    SmmAllocatePoolOffset64 = 0x50,
    SmmFreePoolOffset64 = 0x58,
    SmmAllocatePagesOffset64 = 0x60,
    SmmFreePagesOffset64 = 0x68,
    SmmStartupThisApOffset64 = 0x70,
    SmmInstallProtocolInterfaceOffset64 = 0xa8,
    SmmUninstallProtocolInterfaceOffset64 = 0xb0,
    SmmHandleProtocolOffset64 = 0xb8,
    SmmRegisterProtocolNotifyOffset64 = 0xc0,
    SmmLocateHandleOffset64 = 0xc8,
    SmmLocateProtocolOffset64 = 0xd0,
    SmiManageOffset64 = 0xd8,
    SmiHandlerRegisterOffset64 = 0xe0,
    SmiHandlerUnRegisterOffset64 = 0xe8,
};

enum SmmServicesOffsets32bit {
    SmmInstallConfigurationTableOffset32 = 0x20,
    SmmAllocatePoolOffset32 = 0x34,
    SmmFreePoolOffset32 = 0x38,
    SmmAllocatePagesOffset32 = 0x3c,
    SmmFreePagesOffset32 = 0x40,
    SmmStartupThisApOffset32 = 0x44,
    SmmInstallProtocolInterfaceOffset32 = 0x60,
    SmmUninstallProtocolInterfaceOffset32 = 0x64,
    SmmHandleProtocolOffset32 = 0x68,
    SmmRegisterProtocolNotifyOffset32 = 0x6c,
    SmmLocateHandleOffset32 = 0x70,
    SmmLocateProtocolOffset32 = 0x74,
    SmiManageOffset32 = 0x78,
    SmiHandlerRegisterOffset32 = 0x7c,
    SmiHandlerUnRegisterOffset32 = 0x80,
};
struct service_info_64bit {
    char service_name[64];
    uint32_t offset;
    uint32_t reg;
};

struct service_info_32bit {
    char service_name[64];
    uint32_t offset;
    uint16_t push_number;
};

struct service {
    char service_name[64];
    uint32_t offset64;
    uint32_t offset32;
};

struct service_info_64bit bootServicesTable64[] = {
    {"InstallProtocolInterface", InstallProtocolInterfaceOffset64, REG_RDX},
    {"ReinstallProtocolInterface", RenstallProtocolInterfaceOffset64, REG_RDX},
    {"UninstallProtocolInterface", UninstallProtocolInterfaceOffset64, REG_RDX},
    {"HandleProtocol", HandleProtocolOffset64, REG_RDX},
    {"RegisterProtocolNotify", RegisterProtocolNotifyOffset64, REG_RCX},
    {"OpenProtocol", OpenProtocolOffset64, REG_RDX},
    {"CloseProtocol", CloseProtocolOffset64, REG_RDX},
    {"OpenProtocolInformation", OpenProtocolInformationOffset64, REG_RDX},
    {"LocateHandleBuffer", LocateHandleBufferOffset64, REG_RDX},
    {"LocateProtocol", LocateProtocolOffset64, REG_RCX},
    {"InstallMultipleProtocolInterfaces", InstallMultipleProtocolInterfacesOffset64,
     REG_RDX},
    {"UninstallMultipleProtocolInterfaces", UninstallMultipleProtocolInterfacesOffset64,
     REG_RDX}};
size_t bootServicesTable64Length =
    sizeof(bootServicesTable64) / sizeof(service_info_64bit);

struct service_info_32bit bootServicesTable32[] = {
    {"InstallProtocolInterface", InstallProtocolInterfaceOffset32, 2},
    {"ReinstallProtocolInterface", RenstallProtocolInterfaceOffset32, 2},
    {"UninstallProtocolInterface", UninstallProtocolInterfaceOffset32, 2},
    {"HandleProtocol", HandleProtocolOffset32, 2},
    {"RegisterProtocolNotify", RegisterProtocolNotifyOffset32, 1},
    {"OpenProtocol", OpenProtocolOffset32, 2},
    {"CloseProtocol", CloseProtocolOffset32, 2},
    {"OpenProtocolInformation", OpenProtocolInformationOffset32, 2},
    {"LocateHandleBuffer", LocateHandleBufferOffset32, 2},
    {"LocateProtocol", LocateProtocolOffset32, 1},
    {"InstallMultipleProtocolInterfaces", InstallMultipleProtocolInterfacesOffset32, 2},
    {"UninstallMultipleProtocolInterfaces", UninstallMultipleProtocolInterfacesOffset32,
     2}};
size_t bootServicesTable32Length =
    sizeof(bootServicesTable64) / sizeof(service_info_32bit);

struct service bootServicesTableAll[] = {
    // difficult to check false positives
    // {"RaiseTPL", RaiseTPLOffset64, RaiseTPLOffset32},
    // {"RestoreTPL", RestoreTPLOffset64, RestoreTPLOffset32},
    {"AllocatePages", AllocatePagesOffset64, AllocatePagesOffset32},
    {"FreePages", FreePagesOffset64, FreePagesOffset32},
    {"GetMemoryMap", GetMemoryMapOffset64, GetMemoryMapOffset32},
    {"AllocatePool", AllocatePoolOffset64, AllocatePoolOffset32},
    {"FreePool", FreePoolOffset64, FreePoolOffset32},
    {"CreateEvent", CreateEventOffset64, CreateEventOffset32},
    {"SetTimer", SetTimerOffset64, SetTimerOffset32},
    {"WaitForEvent", WaitForEventOffset64, WaitForEventOffset32},
    {"SignalEvent", SignalEventOffset64, SignalEventOffset32},
    {"CloseEvent", CloseEventOffset64, CloseEventOffset32},
    {"CheckEvent", CheckEventOffset64, CheckEventOffset32},
    {"InstallProtocolInterface", InstallProtocolInterfaceOffset64,
     InstallProtocolInterfaceOffset32},
    {"ReinstallProtocolInterface", RenstallProtocolInterfaceOffset64,
     RenstallProtocolInterfaceOffset32},
    {"UninstallProtocolInterface", UninstallProtocolInterfaceOffset64,
     UninstallProtocolInterfaceOffset32},
    {"HandleProtocol", HandleProtocolOffset64, HandleProtocolOffset32},
    {"RegisterProtocolNotify", RegisterProtocolNotifyOffset64,
     RegisterProtocolNotifyOffset32},
    {"LocateHandle", LocateHandleOffset64, LocateHandleOffset32},
    {"LocateDevicePath", LocateDevicePathOffset64, LocateDevicePathOffset32},
    {"InstallConfigurationTable", InstallConfigurationTableOffset64,
     InstallConfigurationTableOffset32},
    {"LoadImage", LoadImageOffset64, LoadImageOffset32},
    {"StartImage", StartImageOffset64, StartImageOffset32},
    {"Exit", ExitOffset64, ExitOffset32},
    {"UnloadImage", UnloadImageOffset64, UnloadImageOffset32},
    {"ExitBootServices", ExitBootServicesOffset64, ExitBootServicesOffset32},
    {"GetNextMonotonicCount", GetNextMonotonicCountOffset64,
     GetNextMonotonicCountOffset32},
    {"Stall", StallOffset64, StallOffset32},
    {"SetWatchdogTimer", SetWatchdogTimerOffset64, SetWatchdogTimerOffset32},
    {"ConnectController", ConnectControllerOffset64, ConnectControllerOffset32},
    {"DisconnectController", DisconnectControllerOffset64, DisconnectControllerOffset32},
    {"OpenProtocol", OpenProtocolOffset64, OpenProtocolOffset32},
    {"CloseProtocol", CloseProtocolOffset64, CloseProtocolOffset32},
    {"OpenProtocolInformation", OpenProtocolInformationOffset64,
     OpenProtocolInformationOffset32},
    {"ProtocolsPerHandle", ProtocolsPerHandleOffset64, ProtocolsPerHandleOffset32},
    {"LocateHandleBuffer", LocateHandleBufferOffset64, LocateHandleBufferOffset32},
    {"LocateProtocol", LocateProtocolOffset64, LocateProtocolOffset32},
    {"InstallMultipleProtocolInterfaces", InstallMultipleProtocolInterfacesOffset64,
     InstallMultipleProtocolInterfacesOffset32},
    {"UninstallMultipleProtocolInterfaces", UninstallMultipleProtocolInterfacesOffset64,
     UninstallMultipleProtocolInterfacesOffset32},
    {"CalculateCrc32", CalculateCrc32Offset64, CalculateCrc32Offset32},
    {"CopyMem", CopyMemOffset64, CopyMemOffset32},
    {"SetMem", SetMemOffset64, SetMemOffset32},
    {"CreateEventEx", CreateEventExOffset64, CreateEventExOffset32}};
size_t bootServicesTableAllLength = sizeof(bootServicesTableAll) / sizeof(service);

struct service runtimeServicesTableAll[] = {
    {"GetTime", GetTimeOffset64, GetTimeOffset32},
    {"SetTime", SetTimeOffset64, SetTimeOffset32},
    {"GetWakeupTime", GetWakeupTimeOffset64, GetWakeupTimeOffset32},
    {"SetWakeupTime", SetWakeupTimeOffset64, SetWakeupTimeOffset32},
    {"SetVirtualAddressMap", SetVirtualAddressMapOffset64, SetVirtualAddressMapOffset32},
    {"ConvertPointer", ConvertPointerOffset64, ConvertPointerOffset32},
    {"GetVariable", GetVariableOffset64, GetVariableOffset32},
    {"GetNextVariableName", GetNextVariableNameOffset64, GetNextVariableNameOffset32},
    {"SetVariable", SetVariableOffset64, SetVariableOffset32},
    {"GetNextHighMonotonicCount", GetNextHighMonotonicCountOffset64,
     GetNextHighMonotonicCountOffset32},
    {"ResetSystem", ResetSystemOffset64, ResetSystemOffset32},
    {"UpdateCapsule", UpdateCapsuleOffset64, UpdateCapsuleOffset32},
    {"QueryCapsuleCapabilities", QueryCapsuleCapabilitiesOffset64,
     QueryCapsuleCapabilitiesOffset32},
    {"QueryVariableInfo", QueryVariableInfoOffset64, QueryVariableInfoOffset32}};
size_t runtimeServicesTableAllLength = sizeof(runtimeServicesTableAll) / sizeof(service);

struct service_info_64bit smmServicesProt64[] = {
    {"SmmInstallProtocolInterface", SmmInstallProtocolInterfaceOffset64, REG_RDX},
    {"SmmUninstallProtocolInterface", SmmUninstallProtocolInterfaceOffset64, REG_RDX},
    {"SmmHandleProtocol", SmmHandleProtocolOffset64, REG_RDX},
    {"SmmRegisterProtocolNotify", SmmRegisterProtocolNotifyOffset64, REG_RCX},
    {"SmmLocateHandle", SmmLocateHandleOffset64, REG_RDX},
    {"SmmLocateProtocol", SmmLocateProtocolOffset64, REG_RCX}};
size_t smmServicesProt64Length = sizeof(smmServicesProt64) / sizeof(service_info_64bit);

struct service smmServicesTableAll[] = {
    {"SmmInstallConfigurationTable", SmmInstallConfigurationTableOffset64,
     SmmInstallConfigurationTableOffset32},
    {"SmmAllocatePool", SmmAllocatePoolOffset64, SmmAllocatePoolOffset32},
    {"SmmFreePool", SmmFreePoolOffset64, SmmFreePoolOffset32},
    {"SmmAllocatePages", SmmAllocatePagesOffset64, SmmAllocatePagesOffset32},
    {"SmmFreePages", SmmFreePagesOffset64, SmmFreePagesOffset32},
    {"SmmStartupThisAp", SmmStartupThisApOffset64, SmmStartupThisApOffset32},
    {"SmmInstallProtocolInterface", SmmInstallProtocolInterfaceOffset64,
     SmmInstallProtocolInterfaceOffset32},
    {"SmmUninstallProtocolInterface", SmmUninstallProtocolInterfaceOffset64,
     SmmUninstallProtocolInterfaceOffset32},
    {"SmmHandleProtocol", SmmHandleProtocolOffset64, SmmHandleProtocolOffset32},
    {"SmmRegisterProtocolNotify", SmmRegisterProtocolNotifyOffset64,
     SmmRegisterProtocolNotifyOffset32},
    {"SmmLocateHandle", SmmLocateHandleOffset64, SmmLocateHandleOffset32},
    {"SmmLocateProtocol", SmmLocateProtocolOffset64, SmmLocateProtocolOffset32},
    {"SmiManage", SmiManageOffset64, SmiManageOffset32},
    {"SmiHandlerRegister", SmiHandlerRegisterOffset64, SmiHandlerRegisterOffset32},
    {"SmiHandlerUnRegister", SmiHandlerUnRegisterOffset64, SmiHandlerUnRegisterOffset32}};
size_t smmServicesTableAllLength = sizeof(smmServicesTableAll) / sizeof(service);

```

`efiXplorer/tables/efi_system_tables.h`:

```h
/*
 * ______________________.___
 * \_   _____/\_   _____/|   |
 *  |    __)_  |    __)  |   |
 *  |        \ |     \   |   |
 * /_______  / \___  /   |___|
 *         \/      \/
 *   _________       .__                 ____  __.      .__  _____
 *  /   _____/_  _  _|__| ______ _____  |    |/ _| ____ |__|/ ____\____
 *  \_____  \\ \/ \/ /  |/  ___//  ___/ |      <  /    \|  \   __\/ __ \
 *  /        \\     /|  |\___ \ \___ \  |    |  \|   |  \  ||  | \  ___/
 * /_______  / \/\_/ |__/____  >____  > |____|__ \___|  /__||__|  \___  >
 *         \/                \/     \/          \/    \/              \/
 *
 * EFI Swiss Knife
 * An IDA plugin to improve (U)EFI reversing
 *
 * Copyright (C) 2016, 2017  Pedro Vilaça (fG!) - reverser@put.as -
 * https://reverse.put.as
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * efi_system_tables.h
 *
 */

#define BTABLE_LEN 43
#define RTABLE_LEN 14

struct services_entry {
    char name[256];
    uint32_t offset64;
    uint32_t offset32;
    char description[1024];
    uint32_t nr_args;
    char prototype[512];
    char parameters[2048];
    char rcx_param[256];
    char rdx_param[256];
    char r8_param[256];
    char r9_param[256];
    char stack1_param[256];
    char stack2_param[256];
    char stack3_param[256];
    char stack4_param[256];
    uint32_t count;
};

struct services_entry boot_services_table[] = {
    {"RaiseTPL", 0x18, 0x18,
     "Raises a task's priority level and returns its previous level.", 1,
     "EFI_TPL(EFIAPI * EFI_RAISE_TPL) (IN EFI_TPL NewTpl)",
     "NewTpl   The new task priority level.", "IN EFI_TPL NewTpl", "", "", "", "", "", "",
     "", 0},
    {"RestoreTPL", 0x20, 0x1c, "Restores a task's priority level to its previous value.",
     1, "VOID(EFIAPI * EFI_RESTORE_TPL) (IN EFI_TPL OldTpl)",
     "OldTpl   The previous task priority level to restore.", "IN EFI_TPL OldTpl", "", "",
     "", "", "", "", "", 0},
    {"AllocatePages", 0x28, 0x20, "Allocates memory pages from the system.", 4,
     "EFI_STATUS(EFIAPI * EFI_ALLOCATE_PAGES) (IN EFI_ALLOCATE_TYPE Type, IN "
     "EFI_MEMORY_TYPE MemoryType, IN UINTN Pages, IN OUT EFI_PHYSICAL_ADDRESS "
     "*Memory)",
     "Type         The type of allocation to perform.\n\
MemoryType   The type of memory to allocate.\n\
Pages        The number of contiguous 4 KB pages to allocate.\n\
Memory       The pointer to a physical address. On input, the way in which the address is used depends on the value of Type.",
     "IN EFI_ALLOCATE_TYPE Type", "IN EFI_MEMORY_TYPE MemoryType", "IN UINTN Pages",
     "IN OUT EFI_PHYSICAL_ADDRESS *Memory", "", "", "", "", 0},
    {"FreePages", 0x30, 0x24, "Frees memory pages.", 2,
     "EFI_STATUS(EFIAPI * EFI_FREE_PAGES) (IN EFI_PHYSICAL_ADDRESS Memory, IN "
     "UINTN Pages)",
     "Memory   The base physical address of the pages to be freed.\n\
Pages    The number of contiguous 4 KB pages to free.",
     "IN EFI_PHYSICAL_ADDRESS Memory", "IN UINTN Pages", "", "", "", "", "", "", 0},
    {"GetMemoryMap", 0x38, 0x28, "Returns the current memory map.", 5,
     "EFI_STATUS(EFIAPI * EFI_GET_MEMORY_MAP) (IN OUT UINTN *MemoryMapSize, IN "
     "OUT EFI_MEMORY_DESCRIPTOR *MemoryMap, OUT UINTN *MapKey, OUT UINTN "
     "*DescriptorSize, OUT UINT32 *DescriptorVersion)",
     "MemoryMapSize       A pointer to the size, in bytes, of the MemoryMap buffer. On input, this is the size of the buffer allocated by the caller.\n\
                    On output, it is the size of the buffer returned by the firmware if the buffer was large enough, or the size of the buffer\n\
                    needed to contain the map if the buffer was too small.\n\
MemoryMap           A pointer to the buffer in which firmware places the current memory map.\n\
MapKey              A pointer to the location in which firmware returns the key for the current memory map.\n\
DescriptorSize      A pointer to the location in which firmware returns the size, in bytes, of an individual EFI_MEMORY_DESCRIPTOR.\n\
DescriptorVersion   A pointer to the location in which firmware returns the version number associated with the EFI_MEMORY_DESCRIPTOR.",
     "IN OUT UINTN *MemoryMapSize", "IN OUT EFI_MEMORY_DESCRIPTOR *MemoryMap",
     "OUT UINTN *MapKey", "OUT UINTN *DescriptorSize", "OUT UINT32 *DescriptorVersion",
     "", "", "", 0},
    {"AllocatePool", 0x40, 0x2c, "Allocates pool memory.", 3,
     "EFI_STATUS(EFIAPI * EFI_ALLOCATE_POOL) (IN EFI_MEMORY_TYPE PoolType, IN "
     "UINTN Size, OUT VOID **Buffer)",
     "PoolType   The type of pool to allocate.\n\
Size       The number of bytes to allocate from the pool.\n\
Buffer     A pointer to a pointer to the allocated buffer if the call succeeds; undefined otherwise.",
     "IN EFI_MEMORY_TYPE PoolType", "IN UINTN Size", "OUT VOID **Buffer", "", "", "", "",
     "", 0},
    {"FreePool", 0x48, 0x30, "Returns pool memory to the system.", 1,
     "EFI_STATUS(EFIAPI * EFI_FREE_POOL) (IN VOID *Buffer)",
     "Buffer The pointer to the buffer to free.", "IN VOID *Buffer", "", "", "", "", "",
     "", "", 0},
    {"CreateEvent", 0x50, 0x34, "Creates an event.", 5,
     "EFI_STATUS(EFIAPI * EFI_CREATE_EVENT) (IN UINT32 Type, IN EFI_TPL "
     "NotifyTpl, IN EFI_EVENT_NOTIFY NotifyFunction, IN VOID *NotifyContext, "
     "OUT EFI_EVENT *Event)",
     "Type             The type of event to create and its mode and attributes.\n\
NotifyTpl        The task priority level of event notifications, if needed.\n\
NotifyFunction   The pointer to the event's notification function, if any.\n\
NotifyContext    The pointer to the notification function's context; corresponds to parameter Context in the notification function.\n\
Event            The pointer to the newly created event if the call succeeds; undefined otherwise.",
     "IN UINT32 Type", "IN EFI_TPL NotifyTpl", "IN EFI_EVENT_NOTIFY NotifyFunction",
     "IN VOID *NotifyContext", "OUT EFI_EVENT *Event", "", "", "", 0},
    {"SetTimer", 0x58, 0x38,
     "Sets the type of timer and the trigger time for a timer event.", 3,
     "EFI_STATUS(EFIAPI * EFI_SET_TIMER) (IN EFI_EVENT Event, IN "
     "EFI_TIMER_DELAY Type, IN UINT64 TriggerTime)",
     "Event         The timer event that is to be signaled at the specified time.\n\
Type          The type of time that is specified in TriggerTime.\n\
TriggerTime   The number of 100ns units until the timer expires. A TriggerTime of 0 is legal. If Type is TimerRelative and TriggerTime is 0, then the timer event will be signaled on the next timer tick. If Type is TimerPeriodic and TriggerTime is 0, then the timer event will be signaled on every timer tick.",
     "IN EFI_EVENT Event", "IN EFI_TIMER_DELAY Type", "IN UINT64 TriggerTime", "", "", "",
     "", "", 0},
    {"WaitForEvent", 0x60, 0x3c, "Stops execution until an event is signaled.", 3,
     "EFI_STATUS(EFIAPI * EFI_WAIT_FOR_EVENT) (IN UINTN NumberOfEvents, IN "
     "EFI_EVENT *Event, OUT UINTN *Index)",
     "NumberOfEvents   The number of events in the Event array.\n\
Event            An array of EFI_EVENT.\n\
Index            The pointer to the index of the event which satisfied the wait condition.",
     "IN UINTN NumberOfEvents", "IN EFI_EVENT *Event", "OUT UINTN *Index", "", "", "", "",
     "", 0},
    {"SignalEvent", 0x68, 0x40, "Signals an event.", 1,
     "EFI_STATUS(EFIAPI * EFI_SIGNAL_EVENT) (IN EFI_EVENT Event)",
     "Event The event to signal.", "IN EFI_EVENT Event", "", "", "", "", "", "", "", 0},
    {"CloseEvent", 0x70, 0x44, "Closes an event.", 1,
     "EFI_STATUS(EFIAPI * EFI_CLOSE_EVENT) (IN EFI_EVENT Event)",
     "Event The event to close.", "IN EFI_EVENT Event", "", "", "", "", "", "", "", 0},
    {"CheckEvent", 0x78, 0x48, "Checks whether an event is in the signaled state.", 1,
     "EFI_STATUS(EFIAPI * EFI_CHECK_EVENT) (IN EFI_EVENT Event)",
     "Event The event to check.", "IN EFI_EVENT Event", "", "", "", "", "", "", "", 0},
    {"InstallProtocolInterface", 0x80, 0x4c,
     "Installs a protocol interface on a device handle. If the handle does not "
     "exist, it is created and added to the list of handles in the system. "
     "InstallMultipleProtocolInterfaces() performs more error checking than "
     "InstallProtocolInterface(), so it is recommended that "
     "InstallMultipleProtocolInterfaces() be used in place of "
     "InstallProtocolInterface()",
     4,
     "EFI_STATUS(EFIAPI * EFI_INSTALL_PROTOCOL_INTERFACE) (IN OUT EFI_HANDLE "
     "*Handle, IN EFI_GUID *Protocol, IN EFI_INTERFACE_TYPE InterfaceType, IN "
     "VOID *Interface)",
     "Handle          A pointer to the EFI_HANDLE on which the interface is to be installed.\n\
Protocol        The numeric ID of the protocol interface.\n\
InterfaceType   Indicates whether Interface is supplied in native form.\n\
Interface       A pointer to the protocol interface.",
     "IN OUT EFI_HANDLE *Handle", "IN EFI_GUID *Protocol",
     "IN EFI_INTERFACE_TYPE InterfaceType", "IN VOID *Interface", "", "", "", "", 0},
    {"ReinstallProtocolInterface", 0x88, 0x50,
     "Reinstalls a protocol interface on a device handle.", 4,
     "EFI_STATUS(EFIAPI * EFI_REINSTALL_PROTOCOL_INTERFACE) (IN EFI_HANDLE "
     "Handle, IN EFI_GUID *Protocol, IN VOID *OldInterface, IN VOID "
     "*NewInterface)",
     "Handle         Handle on which the interface is to be reinstalled.\n\
Protocol       The numeric ID of the interface.\n\
OldInterface   A pointer to the old interface. NULL can be used if a structure is not associated with Protocol.\n\
NewInterface   A pointer to the new interface.",
     "IN EFI_HANDLE Handle", "IN EFI_GUID *Protocol", "IN VOID *OldInterface",
     "IN VOID *NewInterface", "", "", "", "", 0},
    {"UninstallProtocolInterface", 0x90, 0x54,
     "Removes a protocol interface from a device handle. It is recommended "
     "that UninstallMultipleProtocolInterfaces() be used in place of "
     "UninstallProtocolInterface().",
     3,
     "EFI_STATUS(EFIAPI * EFI_UNINSTALL_PROTOCOL_INTERFACE) (IN EFI_HANDLE "
     "Handle, IN EFI_GUID *Protocol, IN VOID *Interface)",
     "Handle      The handle on which the interface was installed.\n\
Protocol    The numeric ID of the interface.\n\
Interface   A pointer to the interface.",
     "IN EFI_HANDLE Handle", "IN EFI_GUID *Protocol", "IN VOID *Interface", "", "", "",
     "", "", 0},
    {"HandleProtocol", 0x98, 0x58,
     "Queries a handle to determine if it supports a specified protocol.", 3,
     "EFI_STATUS(EFIAPI * EFI_HANDLE_PROTOCOL) (IN EFI_HANDLE Handle, IN "
     "EFI_GUID *Protocol, OUT VOID **Interface)",
     "Handle      The handle being queried.\n\
Protocol    The published unique identifier of the protocol.\n\
Interface   Supplies the address where a pointer to the corresponding Protocol Interface is returned.",
     "IN EFI_HANDLE Handle", "IN EFI_GUID *Protocol", "OUT VOID **Interface", "", "", "",
     "", "", 0},
    {"RegisterProtocolNotify", 0xA8, 0x60,
     "Creates an event that is to be signaled whenever an interface is "
     "installed for a specified protocol.",
     3,
     "EFI_STATUS(EFIAPI * EFI_REGISTER_PROTOCOL_NOTIFY) (IN EFI_GUID "
     "*Protocol, IN EFI_EVENT Event, OUT VOID **Registration)",
     "Protocol       The numeric ID of the protocol for which the event is to be registered.\n\
Event          Event that is to be signaled whenever a protocol interface is registered for Protocol.\n\
Registration   A pointer to a memory location to receive the registration value.",
     "IN EFI_GUID *Protocol", "IN EFI_EVENT Event", "OUT VOID **Registration", "", "", "",
     "", "", 0},
    {"LocateHandle", 0xB0, 0x64,
     "Returns an array of handles that support a specified protocol.", 5,
     "EFI_STATUS(EFIAPI * EFI_LOCATE_HANDLE) (IN EFI_LOCATE_SEARCH_TYPE "
     "SearchType, IN EFI_GUID *Protocol, OPTIONAL IN VOID *SearchKey, OPTIONAL "
     "IN OUT UINTN *BufferSize, OUT EFI_HANDLE *Buffer)",
     "SearchType   Specifies which handle(s) are to be returned.\n\
Protocol     Specifies the protocol to search by.\n\
SearchKey    Specifies the search key.\n\
BufferSize   On input, the size in bytes of Buffer. On output, the size in bytes of the array returned in Buffer (if the buffer was large enough) or the size, in bytes, of the buffer needed to obtain the array (if the buffer was not large enough).\n\
Buffer       The buffer in which the array is returned.",
     "IN EFI_LOCATE_SEARCH_TYPE SearchType", "IN EFI_GUID *Protocol",
     "OPTIONAL IN VOID *SearchKey", "OPTIONAL IN OUT UINTN *BufferSize",
     "OUT EFI_HANDLE *Buffer", "", "", "", 0},
    {"LocateDevicePath", 0xB8, 0x68,
     "Locates the handle to a device on the device path that supports the "
     "specified protocol.",
     3,
     "EFI_STATUS(EFIAPI * EFI_LOCATE_DEVICE_PATH) (IN EFI_GUID *Protocol, IN "
     "OUT EFI_DEVICE_PATH_PROTOCOL **DevicePath, OUT EFI_HANDLE *Device)",
     "Protocol     Specifies the protocol to search for.\n\
DevicePath   On input, a pointer to a pointer to the device path. On output, the device path pointer is modified to point to the remaining part of the device path.\n\
Device       A pointer to the returned device handle.",
     "IN EFI_GUID *Protocol", "IN OUT EFI_DEVICE_PATH_PROTOCOL **DevicePath",
     "OUT EFI_HANDLE *Device", "", "", "", "", "", 0},
    {"InstallConfigurationTable", 0xC0, 0x6c,
     "Adds, updates, or removes a configuration table entry from the EFI "
     "System Table.",
     2,
     "EFI_STATUS(EFIAPI * EFI_INSTALL_CONFIGURATION_TABLE) (IN EFI_GUID *Guid, "
     "IN VOID *Table)",
     "Guid    A pointer to the GUID for the entry to add, update, or remove.\n\
Table   A pointer to the configuration table for the entry to add, update, or remove. May be NULL.",
     "IN EFI_GUID *Guid", "IN VOID *Table", "", "", "", "", "", "", 0},
    {"LoadImage", 0xC8, 0x70, "Loads an EFI image into memory.", 6,
     "EFI_STATUS(EFIAPI * EFI_IMAGE_LOAD) (IN BOOLEAN BootPolicy, IN "
     "EFI_HANDLE ParentImageHandle, IN EFI_DEVICE_PATH_PROTOCOL *DevicePath, "
     "IN VOID *SourceBuffer OPTIONAL, IN UINTN SourceSize, OUT EFI_HANDLE "
     "*ImageHandle)",
     "BootPolicy          If TRUE, indicates that the request originates from the boot manager, and that the boot manager is attempting to load FilePath as a boot selection. Ignored if SourceBuffer is not NULL.\n\
ParentImageHandle   The caller's image handle.\n\
DevicePath          The DeviceHandle specific file path from which the image is loaded.\n\
SourceBuffer        If not NULL, a pointer to the memory location containing a copy of the image to be loaded.\n\
SourceSize          The size in bytes of SourceBuffer. Ignored if SourceBuffer is NULL.\n\
ImageHandle         The pointer to the returned image handle that is created when the image is successfully loaded.",
     "IN BOOLEAN BootPolicy", "IN EFI_HANDLE ParentImageHandle",
     "IN EFI_DEVICE_PATH_PROTOCOL *DevicePath", "IN VOID *SourceBuffer OPTIONAL",
     "IN UINTN SourceSize", "OUT EFI_HANDLE *ImageHandle", "", "", 0},
    {"StartImage", 0xD0, 0x74, "Transfers control to a loaded image's entry point.", 3,
     "EFI_STATUS(EFIAPI * EFI_IMAGE_START) (IN EFI_HANDLE ImageHandle, OUT "
     "UINTN *ExitDataSize, OUT CHAR16 **ExitData OPTIONAL)",
     "ImageHandle    Handle of image to be started.\n\
ExitDataSize   The pointer to the size, in bytes, of ExitData.\n\
ExitData       The pointer to a pointer to a data buffer that includes a Null-terminated string, optionally followed by additional binary data.",
     "IN EFI_HANDLE ImageHandle", "OUT UINTN *ExitDataSize",
     "OUT CHAR16 **ExitData OPTIONAL", "", "", "", "", "", 0},
    {"Exit", 0xD8, 0x78,
     "Terminates a loaded EFI image and returns control to boot services.", 4,
     "EFI_STATUS(EFIAPI * EFI_EXIT) (IN EFI_HANDLE ImageHandle, IN EFI_STATUS "
     "ExitStatus, IN UINTN ExitDataSize, IN CHAR16 *ExitData OPTIONAL)",
     "ImageHandle    Handle that identifies the image. This parameter is passed to the image on entry.\n\
ExitStatus     The image's exit code.\n\
ExitDataSize   The size, in bytes, of ExitData. Ignored if ExitStatus is EFI_SUCCESS.\n\
ExitData       The pointer to a data buffer that includes a Null-terminated string, optionally followed by additional binary data. The string is a description that the caller may use to further indicate the reason for the image's exit. ExitData is only valid if ExitStatus is something other than EFI_SUCCESS. The ExitData buffer must be allocated by calling AllocatePool().",
     "IN EFI_HANDLE ImageHandle", "IN EFI_STATUS ExitStatus", "IN UINTN ExitDataSize",
     "IN CHAR16 *ExitData OPTIONAL", "", "", "", "", 0},
    {"UnloadImage", 0xE0, 0x7c, "Unloads an image.", 1,
     "EFI_STATUS(EFIAPI * EFI_IMAGE_UNLOAD) (IN EFI_HANDLE ImageHandle)",
     "ImageHandle Handle that identifies the image to be unloaded.",
     "IN EFI_HANDLE ImageHandle", "", "", "", "", "", "", "", 0},
    {"ExitBootServices", 0xE8, 0x80, "Terminates all boot services.", 2,
     "EFI_STATUS(EFIAPI * EFI_EXIT_BOOT_SERVICES) (IN EFI_HANDLE ImageHandle, "
     "IN UINTN MapKey)",
     "ImageHandle   Handle that identifies the exiting image.\n\
MapKey        Key to the latest memory map.",
     "IN EFI_HANDLE ImageHandle", "IN UINTN MapKey", "", "", "", "", "", "", 0},
    {"GetNextMonotonicCount", 0xF0, 0x84,
     "Returns a monotonically increasing count for the platform.", 1,
     "EFI_STATUS(EFIAPI * EFI_GET_NEXT_MONOTONIC_COUNT) (OUT UINT64 *Count)",
     "Count The pointer to returned value.", "OUT UINT64 *Count", "", "", "", "", "", "",
     "", 0},
    {"Stall", 0xF8, 0x88, "Induces a fine-grained stall.", 1,
     "EFI_STATUS(EFIAPI * EFI_STALL) (IN UINTN Microseconds)",
     "Microseconds The number of microseconds to stall execution.",
     "IN UINTN Microseconds", "", "", "", "", "", "", "", 0},
    {"SetWatchdogTimer", 0x100, 0x8c, "Sets the system's watchdog timer.", 4,
     "EFI_STATUS(EFIAPI * EFI_SET_WATCHDOG_TIMER) (IN UINTN Timeout, IN UINT64 "
     "WatchdogCode, IN UINTN DataSize, IN CHAR16 *WatchdogData OPTIONAL)",
     "Timeout        The number of seconds to set the watchdog timer to.\n\
WatchdogCode   The numeric code to log on a watchdog timer timeout event.\n\
DataSize       The size, in bytes, of WatchdogData.\n\
WatchdogData   A data buffer that includes a Null-terminated string, optionally followed by additional binary data.",
     "IN UINTN Timeout", "IN UINT64 WatchdogCode", "IN UINTN DataSize",
     "IN CHAR16 *WatchdogData OPTIONAL", "", "", "", "", 0},
    {"ConnectController", 0x108, 0x90, "Connects one or more drivers to a controller.", 4,
     "EFI_STATUS(EFIAPI * EFI_CONNECT_CONTROLLER) (IN EFI_HANDLE "
     "ControllerHandle, IN EFI_HANDLE *DriverImageHandle, OPTIONAL IN "
     "EFI_DEVICE_PATH_PROTOCOL *RemainingDevicePath, OPTIONAL IN BOOLEAN "
     "Recursive)",
     "ControllerHandle      The handle of the controller to which driver(s) are to be connected.\n\
DriverImageHandle     A pointer to an ordered list handles that support the EFI_DRIVER_BINDING_PROTOCOL.\n\
RemainingDevicePath   A pointer to the device path that specifies a child of the controller specified by ControllerHandle.\n\
Recursive             If TRUE, then ConnectController() is called recursively until the entire tree of controllers below the controller specified by ControllerHandle have been created. If FALSE, then the tree of controllers is only expanded one level.",
     "IN EFI_HANDLE ControllerHandle", "IN EFI_HANDLE *DriverImageHandle",
     "OPTIONAL IN EFI_DEVICE_PATH_PROTOCOL *RemainingDevicePath",
     "OPTIONAL IN BOOLEAN Recursive", "", "", "", "", 0},
    {"DisconnectController", 0x110, 0x94,
     "Disconnects one or more drivers from a controller.", 3,
     "EFI_STATUS(EFIAPI * EFI_DISCONNECT_CONTROLLER) (IN EFI_HANDLE "
     "ControllerHandle, IN EFI_HANDLE DriverImageHandle, OPTIONAL IN "
     "EFI_HANDLE ChildHandle OPTIONAL)",
     "ControllerHandle    The handle of the controller from which driver(s) are to be disconnected.\n\
DriverImageHandle   The driver to disconnect from ControllerHandle. If DriverImageHandle is NULL, then all the drivers currently managing ControllerHandle are disconnected from ControllerHandle.\n\
ChildHandle         The handle of the child to destroy. If ChildHandle is NULL, then all the children of ControllerHandle are destroyed before the drivers are disconnected from ControllerHandle.",
     "IN EFI_HANDLE ControllerHandle", "IN EFI_HANDLE DriverImageHandle",
     "OPTIONAL IN EFI_HANDLE ChildHandle OPTIONAL", "", "", "", "", "", 0},
    {"OpenProtocol", 0x118, 0x98,
     "Queries a handle to determine if it supports a specified protocol. If "
     "the protocol is supported by the handle, it opens the protocol on behalf "
     "of the calling agent.",
     6,
     "EFI_STATUS(EFIAPI * EFI_OPEN_PROTOCOL) (IN EFI_HANDLE Handle, IN "
     "EFI_GUID *Protocol, OUT VOID **Interface, OPTIONAL IN EFI_HANDLE "
     "AgentHandle, IN EFI_HANDLE ControllerHandle, IN UINT32 Attributes)",
     "Handle             The handle for the protocol interface that is being opened.\n\
Protocol           The published unique identifier of the protocol.\n\
Interface          Supplies the address where a pointer to the corresponding Protocol Interface is returned.\n\
AgentHandle        The handle of the agent that is opening the protocol interface specified by Protocol and Interface.\n\
ControllerHandle   If the agent that is opening a protocol is a driver that follows the UEFI Driver Model, then this parameter is the controller handle that requires the protocol interface. If the agent does not follow the UEFI Driver Model, then this parameter is optional and may be NULL.\n\
Attributes         The open mode of the protocol interface specified by Handle and Protocol.",
     "IN EFI_HANDLE Handle", "IN EFI_GUID *Protocol", "OUT VOID **Interface",
     "OPTIONAL IN EFI_HANDLE AgentHandle", "IN EFI_HANDLE ControllerHandle",
     "IN UINT32 Attributes", "", "", 0},
    {"CloseProtocol", 0x120, 0x9c,
     "Closes a protocol on a handle that was opened using OpenProtocol().", 4,
     "EFI_STATUS(EFIAPI * EFI_CLOSE_PROTOCOL) (IN EFI_HANDLE Handle, IN "
     "EFI_GUID *Protocol, IN EFI_HANDLE AgentHandle, IN EFI_HANDLE "
     "ControllerHandle)",
     "Handle             The handle for the protocol interface that was previously opened with OpenProtocol(), and is now being closed.\n\
Protocol           The published unique identifier of the protocol.\n\
AgentHandle        The handle of the agent that is closing the protocol interface.\n\
ControllerHandle   If the agent that opened a protocol is a driver that follows the UEFI Driver Model, then this parameter is the controller handle that required the protocol interface.",
     "IN EFI_HANDLE Handle", "IN EFI_GUID *Protocol", "IN EFI_HANDLE AgentHandle",
     "IN EFI_HANDLE ControllerHandle", "", "", "", "", 0},
    {"OpenProtocolInformation", 0x128, 0xa0,
     "Retrieves the list of agents that currently have a protocol interface "
     "opened.",
     4,
     "EFI_STATUS(EFIAPI * EFI_OPEN_PROTOCOL_INFORMATION) (IN EFI_HANDLE "
     "Handle, IN EFI_GUID *Protocol, OUT EFI_OPEN_PROTOCOL_INFORMATION_ENTRY "
     "**EntryBuffer, OUT UINTN *EntryCount)",
     "Handle        The handle for the protocol interface that is being queried.\n\
Protocol      The published unique identifier of the protocol.\n\
EntryBuffer   A pointer to a buffer of open protocol information in the form of EFI_OPEN_PROTOCOL_INFORMATION_ENTRY structures.\n\
EntryCount    A pointer to the number of entries in EntryBuffer.",
     "IN EFI_HANDLE Handle", "IN EFI_GUID *Protocol",
     "OUT EFI_OPEN_PROTOCOL_INFORMATION_ENTRY **EntryBuffer", "OUT UINTN *EntryCount", "",
     "", "", "", 0},
    {"ProtocolsPerHandle", 0x130, 0xa4,
     "Retrieves the list of protocol interface GUIDs that are installed on a "
     "handle in a buffer allocated from pool.",
     3,
     "EFI_STATUS(EFIAPI * EFI_PROTOCOLS_PER_HANDLE) (IN EFI_HANDLE Handle, OUT "
     "EFI_GUID ***ProtocolBuffer, OUT UINTN *ProtocolBufferCount)",
     "Handle                The handle from which to retrieve the list of protocol interface GUIDs.\n\
ProtocolBuffer        A pointer to the list of protocol interface GUID pointers that are installed on Handle.\n\
ProtocolBufferCount   A pointer to the number of GUID pointers present in ProtocolBuffer.",
     "IN EFI_HANDLE Handle", "OUT EFI_GUID ***ProtocolBuffer",
     "OUT UINTN *ProtocolBufferCount", "", "", "", "", "", 0},
    {"LocateHandleBuffer", 0x138, 0xa8,
     "Returns an array of handles that support the requested protocol in a "
     "buffer allocated from pool.",
     5,
     "EFI_STATUS(EFIAPI * EFI_LOCATE_HANDLE_BUFFER) (IN EFI_LOCATE_SEARCH_TYPE "
     "SearchType, IN EFI_GUID *Protocol, OPTIONAL IN VOID *SearchKey, OPTIONAL "
     "IN OUT UINTN *NoHandles, OUT EFI_HANDLE **Buffer)",
     "SearchType   Specifies which handle(s) are to be returned.\n\
Protocol     Provides the protocol to search by. This parameter is only valid for a SearchType of ByProtocol.\n\
SearchKey    Supplies the search key depending on the SearchType.\n\
NoHandles    The number of handles returned in Buffer.\n\
Buffer       A pointer to the buffer to return the requested array of handles that support Protocol.",
     "IN EFI_LOCATE_SEARCH_TYPE SearchType", "IN EFI_GUID *Protocol",
     "OPTIONAL IN VOID *SearchKey", "OPTIONAL IN OUT UINTN *NoHandles",
     "OUT EFI_HANDLE **Buffer", "", "", "", 0},
    {"LocateProtocol", 0x140, 0xac,
     "Returns the first protocol instance that matches the given protocol.", 3,
     "EFI_STATUS(EFIAPI * EFI_LOCATE_PROTOCOL) (IN EFI_GUID *Protocol, IN VOID "
     "*Registration, OPTIONAL OUT VOID **Interface)",
     "Protocol       Provides the protocol to search for.\n\
Registration   Optional registration key returned from RegisterProtocolNotify().\n\
Interface      On return, a pointer to the first interface that matches Protocol and Registration.",
     "IN EFI_GUID *Protocol", "IN VOID *Registration", "OPTIONAL OUT VOID **Interface",
     "", "", "", "", "", 0},
    {"InstallMultipleProtocolInterfaces", 0x148, 0xb0,
     "Installs one or more protocol interfaces into the boot services "
     "environment.",
     1,
     "EFI_STATUS(EFIAPI * EFI_INSTALL_MULTIPLE_PROTOCOL_INTERFACES) (IN OUT "
     "EFI_HANDLE *Handle,...)",
     "Handle   The pointer to a handle to install the new protocol interfaces on, or a pointer to NULL if a new handle is to be allocated.\n\
...      A variable argument list containing pairs of protocol GUIDs and protocol interfaces.",
     "IN OUT EFI_HANDLE *Handle", "", "", "", "", "", "", "", 0},
    {"UninstallMultipleProtocolInterfaces", 0x150, 0xb4,
     "Removes one or more protocol interfaces into the boot services "
     "environment.",
     1,
     "EFI_STATUS(EFIAPI * EFI_UNINSTALL_MULTIPLE_PROTOCOL_INTERFACES) (IN "
     "EFI_HANDLE Handle,...)",
     "Handle   The handle to remove the protocol interfaces from.\n\
...      A variable argument list containing pairs of protocol GUIDs and protocol interfaces.",
     "IN EFI_HANDLE Handle", "", "", "", "", "", "", "", 0},
    {"CalculateCrc32", 0x158, 0xb8,
     "Computes and returns a 32-bit CRC for a data buffer.", 3,
     "EFI_STATUS(EFIAPI * EFI_CALCULATE_CRC32) (IN VOID *Data, IN UINTN "
     "DataSize, OUT UINT32 *Crc32)",
     "Data       A pointer to the buffer on which the 32-bit CRC is to be computed.\n\
DataSize   The number of bytes in the buffer Data.\n\
Crc32      The 32-bit CRC that was computed for the data buffer specified by Data and DataSize.",
     "IN VOID *Data", "IN UINTN DataSize", "OUT UINT32 *Crc32", "", "", "", "", "", 0},
    {"CopyMem", 0x160, 0xbc, "Copies the contents of one buffer to another buffer.", 3,
     "VOID(EFIAPI * EFI_COPY_MEM) (IN VOID *Destination, IN VOID *Source, IN "
     "UINTN Length)",
     "Destination   The pointer to the destination buffer of the memory copy.\n\
Source        The pointer to the source buffer of the memory copy.\n\
Length        Number of bytes to copy from Source to Destination.",
     "IN VOID *Destination", "IN VOID *Source", "IN UINTN Length", "", "", "", "", "", 0},
    {"SetMem", 0x168, 0xc0,
     "The SetMem() function fills a buffer with a specified value.", 3,
     "VOID(EFIAPI * EFI_SET_MEM) (IN VOID *Buffer, IN UINTN Size, IN UINT8 "
     "Value)",
     "Buffer   The pointer to the buffer to fill.\n\
Size     Number of bytes in Buffer to fill.\n\
Value    Value to fill Buffer with.",
     "IN VOID *Buffer", "IN UINTN Size", "IN UINT8 Value", "", "", "", "", "", 0},
    {"CreateEventEx", 0x170, 0xc4, "Creates an event in a group.", 6,
     "EFI_STATUS(EFIAPI * EFI_CREATE_EVENT_EX) (IN UINT32 Type, IN EFI_TPL "
     "NotifyTpl, IN EFI_EVENT_NOTIFY NotifyFunction OPTIONAL, IN CONST VOID "
     "*NotifyContext OPTIONAL, IN CONST EFI_GUID *EventGroup OPTIONAL, OUT "
     "EFI_EVENT *Event)",
     "Type             The type of event to create and its mode and attributes.\n\
NotifyTpl        The task priority level of event notifications,if needed.\n\
NotifyFunction   The pointer to the event's notification function, if any.\n\
NotifyContext    The pointer to the notification function's context; corresponds to parameter Context in the notification function.\n\
EventGroup       The pointer to the unique identifier of the group to which this event belongs. If this is NULL, then the function behaves as if the parameters were passed to CreateEvent.\n\
Event            The pointer to the newly created event if the call succeeds; undefined otherwise.",
     "IN UINT32 Type", "IN EFI_TPL NotifyTpl",
     "IN EFI_EVENT_NOTIFY NotifyFunction OPTIONAL",
     "IN CONST VOID *NotifyContext OPTIONAL", "IN CONST EFI_GUID *EventGroup OPTIONAL",
     "OUT EFI_EVENT *Event", "", "", 0}};

struct services_entry runtime_services_table[] = {
    {"GetTime", 0x18, 0x18,
     "Returns the current time and date information, and the time-keeping "
     "capabilities of the hardware platform.",
     2,
     "EFI_STATUS(EFIAPI * EFI_GET_TIME) (OUT EFI_TIME *Time, OUT "
     "EFI_TIME_CAPABILITIES *Capabilities OPTIONAL)",
     "Time           A pointer to storage to receive a snapshot of the current time.\n\
Capabilities   An optional pointer to a buffer to receive the real time clock device's capabilities.",
     "OUT EFI_TIME *Time", "OUT EFI_TIME_CAPABILITIES *Capabilities OPTIONAL", "", "", "",
     "", "", "", 0},
    {"SetTime", 0x20, 0x1c, "Sets the current local time and date information.", 1,
     "EFI_STATUS(EFIAPI * EFI_SET_TIME) (IN EFI_TIME *Time)",
     "Time A pointer to the current time.", "IN EFI_TIME *Time", "", "", "", "", "", "",
     "", 0},
    {"GetWakeupTime", 0x28, 0x20, "Returns the current wakeup alarm clock setting.", 3,
     "EFI_STATUS(EFIAPI * EFI_GET_WAKEUP_TIME) (OUT BOOLEAN *Enabled, OUT "
     "BOOLEAN *Pending, OUT EFI_TIME *Time)",
     "Enabled   Indicates if the alarm is currently enabled or disabled.\n\
Pending   Indicates if the alarm signal is pending and requires acknowledgement.\n\
Time      The current alarm setting.",
     "OUT BOOLEAN *Enabled", "OUT BOOLEAN *Pending", "OUT EFI_TIME *Time", "", "", "", "",
     "", 0},
    {"SetWakeupTime", 0x30, 0x24, "Sets the system wakeup alarm clock time.", 2,
     "EFI_STATUS(EFIAPI * EFI_SET_WAKEUP_TIME) (IN BOOLEAN Enable, IN EFI_TIME "
     "*Time OPTIONAL)",
     "Enabled   Enable or disable the wakeup alarm.\n\
Time      If Enable is TRUE, the time to set the wakeup alarm for. If Enable is FALSE, then this parameter is optional, and may be NULL.",
     "IN BOOLEAN Enable", "IN EFI_TIME *Time OPTIONAL", "", "", "", "", "", "", 0},
    {"SetVirtualAddressMap", 0x38, 0x28,
     "Changes the runtime addressing mode of EFI firmware from physical to "
     "virtual.",
     4,
     "EFI_STATUS(EFIAPI * EFI_SET_VIRTUAL_ADDRESS_MAP) (IN UINTN "
     "MemoryMapSize, IN UINTN DescriptorSize, IN UINT32 DescriptorVersion, IN "
     "EFI_MEMORY_DESCRIPTOR *VirtualMap)",
     "MemoryMapSize       The size in bytes of VirtualMap.\n\
DescriptorSize      The size in bytes of an entry in the VirtualMap.\n\
DescriptorVersion   The version of the structure entries in VirtualMap.\n\
VirtualMap          An array of memory descriptors which contain new virtual address mapping information for all runtime ranges.",
     "IN UINTN MemoryMapSize", "IN UINTN DescriptorSize", "IN UINT32 DescriptorVersion",
     "IN EFI_MEMORY_DESCRIPTOR *VirtualMap", "", "", "", "", 0},
    {"ConvertPointer", 0x40, 0x2c,
     "Determines the new virtual address that is to be used on subsequent "
     "memory accesses.",
     2,
     "EFI_STATUS(EFIAPI * EFI_CONVERT_POINTER) (IN UINTN DebugDisposition, IN "
     "OUT VOID **Address)",
     "DebugDisposition   Supplies type information for the pointer being converted.\n\
Address            A pointer to a pointer that is to be fixed to be the value needed for the new virtual address mappings being applied.",
     "IN UINTN DebugDisposition", "IN OUT VOID **Address", "", "", "", "", "", "", 0},
    {"GetVariable", 0x48, 0x30, "Returns the value of a variable.", 5,
     "EFI_STATUS(EFIAPI * EFI_GET_VARIABLE) (IN CHAR16 *VariableName, IN "
     "EFI_GUID *VendorGuid, OUT UINT32 *Attributes, OPTIONAL IN OUT UINTN "
     "*DataSize, OUT VOID *Data)",
     "VariableName   A Null-terminated string that is the name of the vendor's variable.\n\
VendorGuid     A unique identifier for the vendor.\n\
Attributes     If not NULL, a pointer to the memory location to return the attributes bitmask for the variable.\n\
DataSize       On input, the size in bytes of the return Data buffer. On output the size of data returned in Data.\n\
Data           The buffer to return the contents of the variable.",
     "IN CHAR16 *VariableName", "IN EFI_GUID *VendorGuid", "OUT UINT32 *Attributes",
     "OPTIONAL IN OUT UINTN *DataSize", "OUT VOID *Data", "", "", "", 0},
    {"GetNextVariableName", 0x50, 0x3c, "Enumerates the current variable names.", 3,
     "EFI_STATUS(EFIAPI * EFI_GET_NEXT_VARIABLE_NAME) (IN OUT UINTN "
     "*VariableNameSize, IN OUT CHAR16 *VariableName, IN OUT EFI_GUID "
     "*VendorGuid)",
     "VariableNameSize   The size of the VariableName buffer.\n\
VariableName       On input, supplies the last VariableName that was returned by GetNextVariableName(). On output, returns the Nullterminated string of the current variable.\n\
VendorGuid         On input, supplies the last VendorGuid that was returned by GetNextVariableName(). On output, returns the VendorGuid of the current variable.",
     "IN OUT UINTN *VariableNameSize", "IN OUT CHAR16 *VariableName",
     "IN OUT EFI_GUID *VendorGuid", "", "", "", "", "", 0},
    {"SetVariable", 0x58, 0x38, "Sets the value of a variable.", 5,
     "EFI_STATUS(EFIAPI * EFI_SET_VARIABLE) (IN CHAR16 *VariableName, IN "
     "EFI_GUID *VendorGuid, IN UINT32 Attributes, IN UINTN DataSize, IN VOID "
     "*Data)",
     "VariableName   A Null-terminated string that is the name of the vendor's variable. Each VariableName is unique for each VendorGuid. VariableName must contain 1 or more characters. If VariableName is an empty string, then EFI_INVALID_PARAMETER is returned.\n\
VendorGuid     A unique identifier for the vendor.\n\
Attributes     Attributes bitmask to set for the variable.\n\
DataSize       The size in bytes of the Data buffer. Unless the EFI_VARIABLE_APPEND_WRITE, EFI_VARIABLE_AUTHENTICATED_WRITE_ACCESS, or EFI_VARIABLE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS attribute is set, a size of zero causes the variable to be deleted. When the EFI_VARIABLE_APPEND_WRITE attribute is set, \nthen a SetVariable() call with a DataSize of zero will not cause any change to the variable value (the timestamp associated with the variable may be updated however even if no new data value is provided,\n see the description of the EFI_VARIABLE_AUTHENTICATION_2 descriptor below. In this case the DataSize will not be zero since the EFI_VARIABLE_AUTHENTICATION_2 descriptor will be populated).\n\
Data           The contents for the variable.",
     "IN CHAR16 *VariableName", "IN EFI_GUID *VendorGuid", "IN UINT32 Attributes",
     "IN UINTN DataSize", "IN VOID *Data", "", "", "", 0},
    {"GetNextHighMonotonicCount", 0x60, 0x3c,
     "Returns the next high 32 bits of the platform's monotonic counter.", 1,
     "EFI_STATUS(EFIAPI * EFI_GET_NEXT_HIGH_MONO_COUNT) (OUT UINT32 "
     "*HighCount)",
     "HighCount The pointer to returned value.", "OUT UINT32 *HighCount", "", "", "", "",
     "", "", "", 0},
    {"ResetSystem", 0x68, 0x40, "Resets the entire platform.", 4,
     "VOID(EFIAPI * EFI_RESET_SYSTEM) (IN EFI_RESET_TYPE ResetType, IN "
     "EFI_STATUS ResetStatus, IN UINTN DataSize, IN VOID *ResetData OPTIONAL)",
     "ResetType     The type of reset to perform.\n\
ResetStatus   The status code for the reset.\n\
DataSize      The size, in bytes, of WatchdogData.\n\
ResetData     For a ResetType of EfiResetCold, EfiResetWarm, or EfiResetShutdown the data buffer starts with a Null-terminated string, optionally followed by additional binary data.",
     "IN EFI_RESET_TYPE ResetType", "IN EFI_STATUS ResetStatus", "IN UINTN DataSize",
     "IN VOID *ResetData OPTIONAL", "", "", "", "", 0},
    {"UpdateCapsule", 0x70, 0x44,
     "Passes capsules to the firmware with both virtual and physical mapping. "
     "Depending on the intended consumption, the firmware may process the "
     "capsule immediately. If the payload should persist across a system "
     "reset, the reset value returned from EFI_QueryCapsuleCapabilities must "
     "be passed into ResetSystem() and will cause the capsule to be processed "
     "by the firmware as part of the reset process.",
     3,
     "EFI_STATUS(EFIAPI * EFI_UPDATE_CAPSULE) (IN EFI_CAPSULE_HEADER "
     "**CapsuleHeaderArray, IN UINTN CapsuleCount, IN EFI_PHYSICAL_ADDRESS "
     "ScatterGatherList OPTIONAL)",
     "CapsuleHeaderArray   Virtual pointer to an array of virtual pointers to the capsules being passed into update capsule.\n\
CapsuleCount         Number of pointers to EFI_CAPSULE_HEADER in CaspuleHeaderArray.\n\
ScatterGatherList    Physical pointer to a set of EFI_CAPSULE_BLOCK_DESCRIPTOR that describes the location in physical memory of a set of capsules.",
     "IN EFI_CAPSULE_HEADER **CapsuleHeaderArray", "IN UINTN CapsuleCount",
     "IN EFI_PHYSICAL_ADDRESS ScatterGatherList OPTIONAL", "", "", "", "", "", 0},
    {"QueryCapsuleCapabilities", 0x78, 0x48,
     "Returns if the capsule can be supported via UpdateCapsule().", 4,
     "EFI_STATUS(EFIAPI * EFI_QUERY_CAPSULE_CAPABILITIES) (IN "
     "EFI_CAPSULE_HEADER **CapsuleHeaderArray, IN UINTN CapsuleCount, OUT "
     "UINT64 *MaximumCapsuleSize, OUT EFI_RESET_TYPE *ResetType)",
     "CapsuleHeaderArray   Virtual pointer to an array of virtual pointers to the capsules being passed into update capsule.\n\
CapsuleCount         Number of pointers to EFI_CAPSULE_HEADER in CaspuleHeaderArray.\n\
MaxiumCapsuleSize    On output the maximum size that UpdateCapsule() can support as an argument to UpdateCapsule() via CapsuleHeaderArray and ScatterGatherList.\n\
ResetType            Returns the type of reset required for the capsule update.",
     "IN EFI_CAPSULE_HEADER **CapsuleHeaderArray", "IN UINTN CapsuleCount",
     "OUT UINT64 *MaximumCapsuleSize", "OUT EFI_RESET_TYPE *ResetType", "", "", "", "",
     0},
    {"QueryVariableInfo", 0x80, 0x4c, "Returns information about the EFI variables.", 4,
     "EFI_STATUS(EFIAPI * EFI_QUERY_VARIABLE_INFO) (IN UINT32 Attributes, OUT "
     "UINT64 *MaximumVariableStorageSize, OUT UINT64 "
     "*RemainingVariableStorageSize, OUT UINT64 *MaximumVariableSize)",
     "Attributes                     Attributes bitmask to specify the type of variables on which to return information.\n\
MaximumVariableStorageSize     On output the maximum size of the storage space available for the EFI variables associated with the attributes specified.\n\
RemainingVariableStorageSize   Returns the remaining size of the storage space available for the EFI variables associated with the attributes specified.\n\
MaximumVariableSize            Returns the maximum size of the individual EFI variables associated with the attributes specified.",
     "IN UINT32 Attributes", "OUT UINT64 *MaximumVariableStorageSize",
     "OUT UINT64 *RemainingVariableStorageSize", "OUT UINT64 *MaximumVariableSize", "",
     "", "", "", 0}};

```

`guids/guids.json`:

```json
{
  "ACOUSTIC_SETUP_PROTOCOL_GUID": [
    3252127133,
    22297,
    18115,
    162,
    152,
    208,
    113,
    227,
    2,
    100,
    209
  ],
  "ADD_BOOT_OPTION_GUID": [
    433679679,
    27242,
    18386,
    177,
    149,
    123,
    36,
    50,
    218,
    59,
    226
  ],
  "ADVANCED_FORM_SET_GUID": [
    3780052218,
    34566,
    17235,
    146,
    242,
    156,
    36,
    36,
    116,
    111,
    159
  ],
  "AMICSM_PCI_BUS_NUM_XLAT_PROTOCOL_GUID": [
    3411825856,
    8973,
    17371,
    146,
    44,
    36,
    211,
    79,
    140,
    145,
    92
  ],
  "AMITSESETUP_GUID": [
    3356621368,
    17096,
    17785,
    169,
    187,
    96,
    233,
    78,
    221,
    251,
    52
  ],
  "AMI_TSE_DRIVER_HEALTH_CTRL_GUID": [
    1478990893,
    64281,
    18030,
    180,
    46,
    205,
    67,
    112,
    22,
    220,
    37
  ],
  "AMI_TSE_DRIVER_HEALTH_ENB_GUID": [
    142996104,
    16780,
    19425,
    166,
    175,
    139,
    173,
    97,
    218,
    8,
    254
  ],
  "AMI_TSE_DRIVER_HEALTH_GUID": [
    1952032724,
    25907,
    17536,
    187,
    167,
    121,
    226,
    90,
    68,
    67,
    201
  ],
  "AMI_APTIO_SIG_OWNER_GUID": [
    651970641,
    6495,
    19169,
    154,
    25,
    251,
    248,
    131,
    187,
    179,
    94
  ],
  "AMI_BBS_DEVICE_PATH_GUID": [
    498173102,
    33269,
    20082,
    133,
    68,
    43,
    171,
    12,
    44,
    172,
    92
  ],
  "AMI_BEFORE_CPU_RC_PROTOCOL_GUID": [
    489074115,
    45073,
    60972,
    33,
    119,
    137,
    187,
    170,
    204,
    51,
    146
  ],
  "AMI_BIOSPPI_FLAGS_MANAGEMENT_GUID": [
    3909127536,
    10830,
    18410,
    142,
    196,
    114,
    226,
    87,
    103,
    229,
    239
  ],
  "AMI_BOARD_INFO_PROTOCOL_GUID": [
    41096300,
    38596,
    17825,
    167,
    175,
    120,
    224,
    82,
    74,
    10,
    226
  ],
  "AMI_BOARD_INFO_SECTION_GUID": [
    2615963913,
    28026,
    16698,
    142,
    75,
    1,
    156,
    237,
    5,
    3,
    225
  ],
  "AMI_CALLBACK_GUID": [
    2633036174,
    31869,
    18910,
    181,
    170,
    187,
    186,
    214,
    178,
    16,
    7
  ],
  "AMI_CAPSULE_HOB_GUID": [
    3211197943,
    63052,
    19217,
    138,
    183,
    248,
    67,
    170,
    42,
    139,
    234
  ],
  "AMI_CCID_IO_PROTOCOL_GUID": [
    2976367349,
    57962,
    19967,
    142,
    28,
    8,
    7,
    199,
    240,
    42,
    136
  ],
  "AMI_CCID_PRESENCE_GUID": [
    1608441869,
    55872,
    16474,
    185,
    46,
    207,
    74,
    128,
    234,
    143,
    118
  ],
  "AMI_CMOS_BAD_FLAG_HOB_GUID": [
    2962814822,
    45434,
    16389,
    131,
    9,
    235,
    35,
    241,
    68,
    140,
    21
  ],
  "AMI_CPUID_CKSUM_HOB_GUID": [
    3570021041,
    45554,
    20467,
    180,
    117,
    102,
    231,
    184,
    25,
    42,
    59
  ],
  "AMI_CPU_INFO_2_PROTOCOL_GUID": [
    2895966376,
    58705,
    19426,
    173,
    10,
    225,
    181,
    100,
    238,
    162,
    115
  ],
  "AMI_CSM_THUNK_PROTOCOL_GUID": [
    593685148,
    34021,
    19967,
    131,
    188,
    181,
    172,
    236,
    181,
    124,
    187
  ],
  "AMI_DDDT_PRESENT_FLAG_HOB_GUID": [
    1316680727,
    49664,
    16394,
    157,
    24,
    134,
    90,
    218,
    211,
    8,
    150
  ],
  "AMI_DEBUGGER_CPU_PROTOCOL_GUID": [
    2871110851,
    47667,
    60972,
    102,
    188,
    18,
    86,
    119,
    17,
    26,
    178
  ],
  "AMI_DEBUGPORT_HOB_GUID": [
    3902059283,
    21706,
    19378,
    140,
    221,
    133,
    30,
    138,
    201,
    2,
    124
  ],
  "AMI_DEVICE_NAME_DEVICE_PATH_GUID": [
    761546735,
    15305,
    16800,
    172,
    25,
    77,
    81,
    208,
    27,
    76,
    230
  ],
  "AMI_DIGITAL_SIGNATURE_PROTOCOL_GUID": [
    1602730519,
    38269,
    17213,
    158,
    21,
    192,
    231,
    200,
    121,
    136,
    153
  ],
  "AMI_DIMM_SPD_DATA_HOB_GUID": [
    3570021043,
    45566,
    20471,
    176,
    115,
    96,
    237,
    187,
    22,
    34,
    51
  ],
  "AMI_EARLY_BIST_PPI_GUID": [
    2816659058,
    56370,
    19392,
    158,
    53,
    254,
    179,
    10,
    229,
    204,
    71
  ],
  "AMI_FAST_BOOT_PROTOCOL_GUID": [
    882287002,
    11929,
    16826,
    131,
    62,
    15,
    222,
    46,
    191,
    42,
    85
  ],
  "AMI_FW_RECOVERY_CAPSULE_GUID": [
    1585005335,
    41086,
    17887,
    148,
    187,
    28,
    153,
    125,
    98,
    50,
    202
  ],
  "AMI_HECI_SMM_GUID": [
    4237971649,
    35645,
    16592,
    153,
    18,
    110,
    38,
    215,
    137,
    108,
    186
  ],
  "AMI_INTERNAL_FACTORY_TDC_TDP_HOB_GUID": [
    2553121903,
    63222,
    16693,
    163,
    9,
    164,
    89,
    62,
    165,
    100,
    23
  ],
  "AMI_INTERNAL_UCODE_HOB_GUID": [
    2488695919,
    63401,
    16937,
    19,
    48,
    254,
    17,
    204,
    171,
    58,
    17
  ],
  "AMI_INT_SMM_COMM_PROTOCOL_GUID": [
    2994580280,
    38932,
    19974,
    165,
    162,
    101,
    174,
    154,
    20,
    37,
    143
  ],
  "AMI_IRQ_DMA_MASK_VARIABLE_GUID": [
    4237027175,
    35313,
    19822,
    128,
    153,
    111,
    2,
    30,
    188,
    135,
    204
  ],
  "AMI_ISO9660_MEDIA_GUID": [
    3128706769,
    40030,
    20424,
    148,
    61,
    26,
    73,
    31,
    35,
    254,
    1
  ],
  "AMI_LOAD_CSM_GUID": [
    371751844,
    23453,
    19864,
    145,
    159,
    123,
    123,
    120,
    203,
    43,
    224
  ],
  "AMI_MASKED_DEVICE_PATH_GUID": [
    2581755367,
    30112,
    19255,
    162,
    230,
    197,
    56,
    94,
    108,
    0,
    203
  ],
  "AMI_MEASURE_PCIOPROM_GUID": [
    3017467648,
    10871,
    20132,
    175,
    121,
    50,
    151,
    180,
    132,
    190,
    97
  ],
  "AMI_MEDIA_DEVICE_PATH_GUID": [
    1344518492,
    56102,
    17051,
    166,
    72,
    189,
    71,
    102,
    76,
    128,
    18
  ],
  "AMI_MEMORY_ERROR_REPORT_PPI_GUID": [
    2233623897,
    3567,
    18648,
    168,
    201,
    183,
    70,
    214,
    164,
    223,
    1
  ],
  "AMI_MRC_INFO_HOB_GUID": [
    2788498055,
    10597,
    18200,
    136,
    199,
    11,
    91,
    90,
    192,
    181,
    228
  ],
  "AMI_NB_MRC_INFO_GUID": [
    1731695435,
    41598,
    19461,
    173,
    91,
    106,
    184,
    98,
    115,
    104,
    11
  ],
  "AMI_NVRAM_SPD_MAP_GUID": [
    1904197968,
    43993,
    17940,
    128,
    21,
    11,
    51,
    35,
    234,
    185,
    92
  ],
  "AMI_OPROM_POLICY_PROTOCOL_GUID": [
    1412260424,
    16792,
    18784,
    159,
    89,
    35,
    132,
    100,
    109,
    99,
    180
  ],
  "AMI_OS_PPI_CONFIRMATION_OVERRIDE_GUID": [
    1595350879,
    33669,
    16518,
    166,
    155,
    31,
    207,
    6,
    174,
    74,
    61
  ],
  "AMI_PB_KEY_RSA2048_GUID": [
    73563035,
    14430,
    18244,
    144,
    33,
    230,
    99,
    25,
    242,
    3,
    148
  ],
  "AMI_PCI_BUS_EXT_PROTOCOL_GUID": [
    4096393373,
    38783,
    20232,
    148,
    64,
    188,
    165,
    163,
    190,
    217,
    175
  ],
  "AMI_PEIM_HOB_GUID": [
    4098431908,
    30322,
    18543,
    180,
    215,
    153,
    137,
    157,
    34,
    218,
    87
  ],
  "AMI_PEIM_LOAD_HOB_GUID": [
    3969660669,
    5698,
    19332,
    145,
    250,
    145,
    156,
    45,
    6,
    111,
    180
  ],
  "AMI_PEI_AFTER_MRC_GUID": [
    1690920704,
    27468,
    18444,
    163,
    225,
    184,
    189,
    232,
    246,
    2,
    178
  ],
  "AMI_PEI_CPUINIT_POLICY_PPI_GUID": [
    4163161275,
    55520,
    17698,
    138,
    168,
    101,
    240,
    75,
    70,
    61,
    181
  ],
  "AMI_PEI_END_MEMORY_DETECT_GUID": [
    2673402916,
    47467,
    17829,
    173,
    220,
    210,
    254,
    57,
    74,
    153,
    217
  ],
  "AMI_PEI_END_OF_MRC_GUID": [
    1664193726,
    5783,
    4577,
    181,
    240,
    44,
    178,
    72,
    36,
    1,
    155
  ],
  "AMI_PEI_MRC_DEFAULT_GUID": [
    3893616918,
    49305,
    19745,
    156,
    52,
    165,
    82,
    213,
    233,
    165,
    208
  ],
  "AMI_PEI_NBINIT_POLICY_PPI_GUID": [
    2632243512,
    40071,
    16848,
    158,
    85,
    52,
    146,
    63,
    175,
    139,
    79
  ],
  "AMI_PEI_NB_CPU_ONLY_RESET_PPI_GUID": [
    521077918,
    14952,
    19607,
    134,
    90,
    188,
    94,
    237,
    121,
    32,
    231
  ],
  "AMI_PEI_PCI_TABLE_INIT_PPI_GUID": [
    2549685880,
    59922,
    20134,
    183,
    179,
    123,
    6,
    120,
    194,
    134,
    115
  ],
  "AMI_PEI_SBINIT_POLICY_PPI_GUID": [
    2515014955,
    7064,
    20241,
    138,
    119,
    219,
    38,
    88,
    62,
    188,
    66
  ],
  "AMI_PEI_SB_CUSTOM_PPI_GUID": [
    949377973,
    32919,
    16629,
    183,
    66,
    140,
    193,
    74,
    100,
    155,
    100
  ],
  "AMI_PEI_SB_OEM_PLATFORM_POLICY_OVERRIDE_PPI_GUID": [
    1628993895,
    39543,
    16797,
    170,
    234,
    100,
    221,
    86,
    25,
    8,
    21
  ],
  "AMI_PEI_SET_NB_SUBID_PPI_GUID": [
    1481427359,
    19432,
    17361,
    164,
    90,
    147,
    61,
    195,
    148,
    121,
    252
  ],
  "AMI_PERF_TUNE_DATA_HOB_GUID": [
    1298924694,
    36324,
    19186,
    154,
    46,
    155,
    229,
    185,
    21,
    106,
    197
  ],
  "AMI_PLL_OVER_VOTAGE_FLAG_HOB_GUID": [
    404653901,
    49289,
    19609,
    142,
    194,
    109,
    103,
    97,
    52,
    130,
    32
  ],
  "AMI_POST_MANAGER_PROTOCOL_GUID": [
    2324804065,
    22215,
    19164,
    171,
    235,
    28,
    44,
    161,
    114,
    158,
    255
  ],
  "AMI_RECOVERY_IMAGE_HOB_GUID": [
    3670264728,
    8853,
    16686,
    130,
    109,
    253,
    238,
    163,
    32,
    207,
    49
  ],
  "AMI_RESET_TYPE_HOB_GUID": [
    971558305,
    27189,
    19677,
    169,
    2,
    209,
    167,
    149,
    247,
    3,
    128
  ],
  "AMI_RESET_TYPE_VARIABLE_GUID": [
    814600236,
    2347,
    16675,
    162,
    175,
    62,
    244,
    68,
    10,
    107,
    74
  ],
  "AMI_ROM_LAYOUT_HOB_GUID": [
    3613664323,
    34743,
    18482,
    150,
    7,
    14,
    30,
    168,
    28,
    29,
    134
  ],
  "AMI_SB_SMI_PROTOCOL_GUID": [
    1486603798,
    47951,
    18413,
    146,
    247,
    147,
    57,
    60,
    105,
    126,
    37
  ],
  "AMI_SETUP_NVRAM_UPDATE_GUID": [
    3628855280,
    5530,
    19296,
    154,
    185,
    172,
    92,
    71,
    75,
    211,
    177
  ],
  "AMI_SMBIOS_CPU_INFO_PROTOCOL_GUID": [
    1030544138,
    23327,
    17315,
    164,
    59,
    68,
    18,
    103,
    249,
    218,
    181
  ],
  "AMI_SMBIOS_MEMORY_INFO_HOB_GUID": [
    2104198964,
    46932,
    17471,
    181,
    136,
    119,
    67,
    132,
    58,
    211,
    241
  ],
  "AMI_SMBUS_HOB_GUID": [
    24949943,
    47116,
    16448,
    182,
    200,
    234,
    152,
    43,
    187,
    37,
    183
  ],
  "AMI_SMBUS_SMM_PROTOCOL_GUID": [
    1927544980,
    12001,
    18810,
    143,
    51,
    76,
    147,
    74,
    158,
    156,
    12
  ],
  "AMI_SMM_DIGITAL_SIGNATURE_PROTOCOL_GUID": [
    2443954224,
    5884,
    19870,
    161,
    137,
    95,
    200,
    187,
    65,
    20,
    2
  ],
  "AMI_SMM_INFO_PROTOCOL_GUID": [
    3947993323,
    59381,
    17825,
    156,
    203,
    229,
    51,
    100,
    187,
    73,
    146
  ],
  "AMI_STANDARD_DEFAULTS_VARIABLE_GUID": [
    1167708783,
    6673,
    18872,
    185,
    31,
    133,
    135,
    69,
    207,
    248,
    36
  ],
  "AMI_STATUS_CODE_CPU_BIST_DATA_GUID": [
    3444841847,
    26265,
    19254,
    163,
    30,
    26,
    164,
    197,
    213,
    185,
    70
  ],
  "AMI_TCG_CONFIRMATION_FLAGS_GUID": [
    2101202670,
    52174,
    20135,
    135,
    9,
    110,
    85,
    47,
    30,
    219,
    222
  ],
  "AMI_TCG_EFI_OS_VARIABLE_GUID": [
    2829191483,
    65274,
    17345,
    142,
    98,
    206,
    82,
    104,
    71,
    38,
    94
  ],
  "AMI_TCG_PERM_FLAGS_GUID": [
    589689596,
    22147,
    17992,
    151,
    196,
    154,
    82,
    13,
    251,
    227,
    37
  ],
  "AMI_TCG_PLATFORM_PPI_AFTER_MEM_GUID": [
    2299276527,
    17352,
    16905,
    167,
    141,
    174,
    20,
    170,
    23,
    152,
    180
  ],
  "AMI_TCG_PLATFORM_PPI_BEFORE_MEM_GUID": [
    3253106973,
    62299,
    17391,
    146,
    10,
    190,
    6,
    186,
    127,
    134,
    161
  ],
  "AMI_USB_SMM_PROTOCOL_GUID": [
    1056395278,
    53077,
    18255,
    142,
    126,
    0,
    158,
    14,
    172,
    236,
    210
  ],
  "AMT_FORCE_PUSH_PET_HOB_GUID": [
    1325010358,
    9948,
    19377,
    167,
    111,
    20,
    188,
    99,
    12,
    123,
    60
  ],
  "AMT_FORCE_PUSH_PET_POLICY_GUID": [
    2898846180,
    40863,
    20032,
    165,
    126,
    249,
    158,
    82,
    243,
    76,
    165
  ],
  "AMT_FORCE_PUSH_PET_VARIABLE_GUID": [
    3618411695,
    42136,
    17900,
    191,
    162,
    165,
    110,
    149,
    52,
    97,
    139
  ],
  "AMT_INT16_CSM_GUID": [
    1615259256,
    9455,
    16389,
    186,
    57,
    189,
    161,
    31,
    109,
    85,
    93
  ],
  "AMT_READY_TO_BOOT_PROTOCOL_GUID": [
    1085315930,
    61679,
    17959,
    147,
    213,
    39,
    240,
    75,
    117,
    77,
    5
  ],
  "AOAC_EC_WAKEUP_CUSTOM_PPI_GUID": [
    2187492047,
    55597,
    16749,
    138,
    111,
    120,
    60,
    172,
    217,
    18,
    35
  ],
  "AOAC_FFS_TABLE_STORAGE_GUID": [
    4211367346,
    22926,
    18522,
    186,
    48,
    93,
    123,
    27,
    27,
    213,
    77
  ],
  "APTIO_FW_CAPSULE_GUID": [
    1245488779,
    30499,
    18683,
    128,
    61,
    87,
    140,
    193,
    254,
    196,
    77
  ],
  "AUTHVAR_MAILBOX_VARIABLE_GUID": [
    1395352882,
    25753,
    17037,
    172,
    177,
    246,
    247,
    121,
    201,
    77,
    249
  ],
  "BDS_ALL_DRIVERS_CONNECTED_PROTOCOL_GUID": [
    3687447841,
    64216,
    17840,
    158,
    120,
    39,
    21,
    136,
    103,
    204,
    147
  ],
  "BLOCK_DEVICE_RECOVERY_CAPSULE_GUID": [
    195569212,
    43197,
    19117,
    180,
    2,
    106,
    106,
    242,
    247,
    231,
    125
  ],
  "BOOT_FLOW_VARIABLE_GUID": [
    4011143092,
    31535,
    17021,
    189,
    180,
    126,
    10,
    5,
    130,
    110,
    100
  ],
  "BOOT_FORM_SET_GUID": [
    2335440864,
    55068,
    20354,
    156,
    235,
    201,
    112,
    88,
    193,
    63,
    142
  ],
  "BOOT_MANAGER_GUID": [
    3029376243,
    31635,
    18257,
    155,
    216,
    91,
    168,
    34,
    11,
    155,
    178
  ],
  "BOOT_NOW_COUNT_GUID": [
    86929072,
    62016,
    17093,
    131,
    9,
    69,
    135,
    69,
    69,
    198,
    180
  ],
  "CHIPSET_FORM_SET_GUID": [
    2919118024,
    39649,
    20367,
    190,
    19,
    207,
    150,
    162,
    203,
    44,
    91
  ],
  "CMOS_MANAGER_HOB_GUID": [
    3577116674,
    47219,
    19471,
    181,
    68,
    49,
    183,
    204,
    245,
    197,
    85
  ],
  "CONSOLE_IN_DEVICES_STARTED_PROTOCOL_GUID": [
    770826321,
    36973,
    20223,
    134,
    157,
    36,
    230,
    83,
    120,
    251,
    158
  ],
  "CONSOLE_OUT_DEVICES_STARTED_PROTOCOL_GUID": [
    4019861873,
    49568,
    19091,
    189,
    64,
    90,
    161,
    101,
    242,
    220,
    58
  ],
  "CPU_MICROCODE_FILE_GUID": [
    386434418,
    14207,
    17647,
    143,
    78,
    176,
    159,
    255,
    70,
    160,
    112
  ],
  "CPU_WAKE_UP_BUFFER_VARIABLE_GUID": [
    3748024978,
    31191,
    16610,
    186,
    81,
    247,
    212,
    148,
    98,
    129,
    133
  ],
  "DCA_HOB_GUID": [
    1751499861,
    34342,
    16600,
    144,
    244,
    166,
    148,
    96,
    164,
    171,
    90
  ],
  "DEBUGGER_TERMINAL_VAR_GUID": [
    2546604635,
    46944,
    19743,
    165,
    75,
    209,
    144,
    146,
    3,
    44,
    144
  ],
  "DEL_BOOT_OPTION_GUID": [
    4140250905,
    62284,
    18332,
    179,
    47,
    39,
    127,
    203,
    188,
    254,
    79
  ],
  "DIMM_TS_INFO_GUID": [
    3462871592,
    32781,
    19274,
    131,
    22,
    38,
    97,
    249,
    179,
    217,
    198
  ],
  "DXE_CPU_CACHE_PROTOCOL_GUID": [
    1550820041,
    38760,
    17910,
    142,
    100,
    90,
    236,
    202,
    218,
    180,
    129
  ],
  "DXE_CPU_INFO_PROTOCOL_GUID": [
    3793997669,
    63182,
    16674,
    179,
    175,
    75,
    209,
    138,
    255,
    64,
    161
  ],
  "DXE_CPU_PLATFORM_POLICY_PROTOCOL_GUID": [
    3173436873,
    41106,
    17962,
    135,
    122,
    90,
    182,
    173,
    206,
    72,
    18
  ],
  "DXE_ENHANCED_SPEEDSTEP_PROTOCOL_GUID": [
    15302689,
    62718,
    18124,
    171,
    45,
    137,
    76,
    55,
    58,
    250,
    1
  ],
  "DXE_PCH_PLATFORM_POLICY_PROTOCOL_GUID": [
    1258382761,
    25046,
    20003,
    160,
    181,
    62,
    199,
    156,
    46,
    48,
    213
  ],
  "DXE_PLATFORM_AMT_POLICY_GUID": [
    2997555550,
    51382,
    16438,
    191,
    49,
    231,
    75,
    216,
    146,
    108,
    206
  ],
  "DXE_PLATFORM_SA_POLICY_GUID": [
    3441636311,
    27146,
    19574,
    131,
    80,
    36,
    10,
    218,
    54,
    162,
    199
  ],
  "DXE_PLATFORM_SG_POLICY_GUID": [
    1637473334,
    57620,
    19981,
    128,
    153,
    153,
    160,
    189,
    128,
    169,
    113
  ],
  "DXE_PLATFORM_TDT_POLICY_GUID": [
    551219452,
    21832,
    17628,
    164,
    42,
    96,
    234,
    240,
    162,
    46,
    71
  ],
  "DXE_TXT_POLICY_PROTOCOL_GUID": [
    1140223997,
    45704,
    16697,
    186,
    213,
    184,
    152,
    3,
    231,
    48,
    162
  ],
  "DYNAMIC_PAGE_COUNT_GUID": [
    3057383424,
    62055,
    20309,
    146,
    23,
    233,
    127,
    179,
    182,
    152,
    70
  ],
  "EFI_ABSOLUTE_POINTER_PROTOCOL_GUID": [
    2371474219,
    50773,
    19177,
    155,
    21,
    242,
    89,
    4,
    153,
    42,
    67
  ],
  "EFI_ACPI_20_TABLE_GUID": [
    2288576625,
    58609,
    4563,
    188,
    34,
    0,
    128,
    199,
    60,
    136,
    129
  ],
  "EFI_ACPI_SDT_PROTOCOL_GUID": [
    3952543886,
    53215,
    18886,
    190,
    75,
    217,
    6,
    165,
    178,
    14,
    134
  ],
  "EFI_ACPI_TABLE_PROTOCOL_GUID": [
    4292897757,
    24839,
    18086,
    123,
    178,
    90,
    156,
    126,
    197,
    39,
    92
  ],
  "EFI_ACPI_TABLE_STORAGE_GUID": [
    2117553701,
    36353,
    20462,
    135,
    242,
    57,
    12,
    35,
    198,
    6,
    205
  ],
  "EFI_ACPI_VARIABLE_GUID": [
    2946497895,
    60432,
    18570,
    157,
    252,
    108,
    191,
    94,
    226,
    44,
    46
  ],
  "EFI_ACTIVE_BIOS_PROTOCOL_GUID": [
    3955109147,
    5703,
    19418,
    171,
    154,
    120,
    99,
    227,
    150,
    212,
    26
  ],
  "EFI_ACTIVE_MANAGEMENT_PROTOCOL_GUID": [
    2237005120,
    5131,
    20284,
    144,
    94,
    59,
    243,
    120,
    160,
    153,
    250
  ],
  "EFI_AHCI_INT13_INIT_PROTOCOL_GUID": [
    1736574258,
    30227,
    19923,
    158,
    215,
    61,
    155,
    227,
    167,
    218,
    99
  ],
  "EFI_ALERT_STANDARD_FORMAT_PROTOCOL_GUID": [
    3432228619,
    60455,
    18885,
    139,
    52,
    19,
    147,
    30,
    254,
    214,
    226
  ],
  "EFI_ALTERNATE_FV_BLOCK_GUID": [
    4103508525,
    5935,
    19388,
    161,
    235,
    14,
    235,
    148,
    156,
    52,
    134
  ],
  "EFI_AMI_LEGACYBOOT_PROTOCOL_GUID": [
    302852266,
    26160,
    18160,
    129,
    87,
    192,
    173,
    194,
    56,
    59,
    245
  ],
  "EFI_APRIORI_GUID": [
    4233170663,
    65500,
    4564,
    189,
    65,
    0,
    128,
    199,
    60,
    136,
    129
  ],
  "EFI_ARP_PROTOCOL_GUID": [
    4105447355,
    47649,
    20246,
    188,
    78,
    67,
    228,
    22,
    171,
    97,
    156
  ],
  "EFI_ARP_SERVICE_BINDING_PROTOCOL_GUID": [
    4098621678,
    7980,
    18944,
    170,
    9,
    28,
    159,
    62,
    8,
    0,
    163
  ],
  "EFI_AUTHENTICATION_INFO_PROTOCOL_GUID": [
    1987172816,
    21467,
    16755,
    170,
    105,
    35,
    39,
    242,
    31,
    11,
    199
  ],
  "EFI_AUTHORIZATION_PROTOCOL_GUID": [
    2572257457,
    40854,
    4564,
    135,
    174,
    0,
    6,
    41,
    46,
    138,
    59
  ],
  "EFI_BDAT_ACCESS_GUID": [
    3111744618,
    35871,
    18987,
    151,
    228,
    120,
    233,
    58,
    113,
    167,
    10
  ],
  "EFI_BDS_ARCH_PROTOCOL_GUID": [
    1717452790,
    18124,
    4564,
    154,
    56,
    0,
    144,
    39,
    63,
    193,
    77
  ],
  "EFI_BIS_PROTOCOL_GUID": [
    191146672,
    21545,
    4564,
    152,
    22,
    0,
    160,
    201,
    31,
    173,
    207
  ],
  "EFI_BLOCK_IO_PROTOCOL_GUID": [
    2521717537,
    25689,
    4562,
    142,
    57,
    0,
    160,
    201,
    105,
    114,
    59
  ],
  "EFI_BOOT_SCRIPT_SAVE_PROTOCOL_GUID": [
    1192105257,
    47006,
    20018,
    160,
    254,
    106,
    21,
    109,
    41,
    249,
    178
  ],
  "EFI_BUS_SPECIFIC_DRIVER_OVERRIDE_PROTOCOL_GUID": [
    1002549893,
    35349,
    19074,
    170,
    191,
    77,
    125,
    19,
    251,
    50,
    101
  ],
  "EFI_CACHE_INSTALL_PPI_GUID": [
    3143797472,
    52559,
    18942,
    141,
    96,
    99,
    24,
    111,
    209,
    224,
    91
  ],
  "EFI_CAPSULE_AMI_GUID": [
    4207079341,
    34065,
    20020,
    156,
    174,
    22,
    162,
    87,
    186,
    148,
    136
  ],
  "EFI_CAPSULE_ARCH_PROTOCOL_GUID": [
    1347643774,
    11452,
    18457,
    144,
    217,
    5,
    128,
    222,
    238,
    87,
    84
  ],
  "EFI_CAPSULE_GUID": [
    996574909,
    3446,
    16432,
    183,
    14,
    181,
    81,
    158,
    47,
    197,
    160
  ],
  "EFI_CAPSULE_INFO_GUID": [
    2335500999,
    9872,
    17931,
    139,
    165,
    213,
    207,
    50,
    131,
    23,
    53
  ],
  "EFI_CAPSULE_VENDOR_GUID": [
    1897689151,
    49797,
    19216,
    163,
    176,
    54,
    236,
    189,
    60,
    139,
    226
  ],
  "EFI_CERT_RSA2048_GUID": [
    1012360936,
    9884,
    20020,
    170,
    20,
    237,
    119,
    110,
    133,
    179,
    182
  ],
  "EFI_CERT_RSA2048_SHA1_GUID": [
    1744323663,
    34627,
    18673,
    163,
    40,
    30,
    170,
    184,
    115,
    96,
    128
  ],
  "EFI_CERT_RSA2048_SHA256_GUID": [
    3803406736,
    34715,
    19005,
    173,
    141,
    242,
    231,
    187,
    163,
    39,
    132
  ],
  "EFI_CERT_SHA1_GUID": [
    2188158226,
    53008,
    19145,
    177,
    135,
    190,
    1,
    73,
    102,
    49,
    189
  ],
  "EFI_CERT_SHA256_GUID": [
    3250853414,
    20556,
    16530,
    172,
    169,
    65,
    249,
    54,
    147,
    67,
    40
  ],
  "EFI_CERT_TYPE_PKCS7_GUID": [
    1253036701,
    26847,
    18926,
    138,
    169,
    52,
    125,
    55,
    86,
    101,
    167
  ],
  "EFI_CERT_TYPE_RSA2048_SHA256_GUID": [
    2809230356,
    50710,
    18807,
    148,
    32,
    132,
    71,
    18,
    167,
    53,
    191
  ],
  "EFI_CLP_PROTOCOL_GUID": [
    3418284854,
    9858,
    19670,
    129,
    139,
    10,
    13,
    150,
    126,
    90,
    103
  ],
  "EFI_CMOS_DATA_HOB_INSTALLED_GUID": [
    1516934132,
    10503,
    18996,
    189,
    17,
    108,
    168,
    160,
    149,
    158,
    9
  ],
  "EFI_COMPATIBLE_MEMORY_TESTED_PROTOCOL_GUID": [
    1690596847,
    13387,
    18732,
    147,
    173,
    171,
    158,
    180,
    57,
    80,
    4
  ],
  "EFI_COMPONENT_NAME2_PROTOCOL_GUID": [
    1786404095,
    59609,
    20336,
    186,
    218,
    117,
    171,
    48,
    37,
    206,
    20
  ],
  "EFI_COMPONENT_NAME_PROTOCOL_GUID": [
    276461356,
    54753,
    4564,
    154,
    70,
    0,
    144,
    39,
    63,
    193,
    77
  ],
  "EFI_CONFIG_FILE_NAME_GUID": [
    2562250139,
    59578,
    18670,
    152,
    221,
    194,
    149,
    57,
    47,
    30,
    219
  ],
  "EFI_CONSOLE_IN_DEVICE_GUID": [
    3551751979,
    54609,
    4564,
    154,
    70,
    0,
    144,
    39,
    63,
    193,
    77
  ],
  "EFI_CONSOLE_LOCK_GUID": [
    915200525,
    53041,
    19355,
    140,
    246,
    231,
    209,
    191,
    255,
    21,
    126
  ],
  "EFI_CONSOLE_OUT_DEVICE_GUID": [
    3551751980,
    54609,
    4564,
    154,
    70,
    0,
    144,
    39,
    63,
    193,
    77
  ],
  "EFI_CPU_ARCH_PROTOCOL_GUID": [
    649776305,
    28482,
    4564,
    188,
    231,
    0,
    128,
    199,
    60,
    136,
    129
  ],
  "EFI_CPU_IO2_PROTOCOL_GUID": [
    2908877201,
    44639,
    19470,
    185,
    250,
    232,
    105,
    210,
    136,
    198,
    79
  ],
  "EFI_CPU_IO_PROTOCOL_GUID": [
    2960336166,
    14536,
    19264,
    136,
    119,
    97,
    199,
    176,
    106,
    172,
    69
  ],
  "EFI_CPU_TYPE_FRU_GUID": [
    4033136927,
    6284,
    20310,
    183,
    253,
    48,
    169,
    184,
    106,
    41,
    243
  ],
  "EFI_CRC32_GUIDED_SECTION_EXTRACTION_PROTOCOL_GUID": [
    4229680560,
    32049,
    18858,
    147,
    106,
    164,
    96,
    13,
    157,
    208,
    131
  ],
  "EFI_CUSTOMIZED_DECOMPRESS_PROTOCOL_GUID": [
    2588154254,
    42146,
    17638,
    138,
    31,
    57,
    190,
    253,
    172,
    137,
    111
  ],
  "EFI_DATA_HUB_PROTOCOL_GUID": [
    2927677473,
    24974,
    4564,
    188,
    215,
    0,
    128,
    199,
    60,
    136,
    129
  ],
  "EFI_DEBUG_ASSERT_PROTOCOL_GUID": [
    3192495250,
    32075,
    4564,
    188,
    238,
    0,
    128,
    199,
    60,
    136,
    129
  ],
  "EFI_DEBUG_IMAGE_INFO_TABLE_GUID": [
    1226124919,
    6874,
    18276,
    183,
    162,
    122,
    254,
    254,
    217,
    94,
    139
  ],
  "EFI_DEBUG_MASK_PPI_GUID": [
    1004089597,
    63523,
    18760,
    134,
    145,
    152,
    230,
    254,
    54,
    172,
    226
  ],
  "EFI_DEBUG_MASK_PROTOCOL_GUID": [
    1284121681,
    49671,
    16475,
    150,
    148,
    153,
    234,
    19,
    37,
    19,
    65
  ],
  "EFI_DEBUG_SUPPORT_PROTOCOL_GUID": [
    659904780,
    28476,
    17146,
    158,
    164,
    163,
    186,
    84,
    60,
    218,
    37
  ],
  "EFI_DECOMPRESS_PROTOCOL_GUID": [
    3625024766,
    38054,
    4564,
    154,
    58,
    0,
    144,
    39,
    63,
    193,
    77
  ],
  "EFI_DEFERRED_IMAGE_LOAD_PROTOCOL_GUID": [
    361053564,
    15839,
    17376,
    161,
    203,
    235,
    248,
    91,
    143,
    135,
    44
  ],
  "EFI_DEVICE_IO_PROTOCOL_GUID": [
    2943009553,
    33987,
    4562,
    142,
    60,
    0,
    160,
    201,
    105,
    114,
    59
  ],
  "EFI_DEVICE_PATH_FROM_TEXT_PROTOCOL_GUID": [
    97098273,
    50959,
    19154,
    138,
    95,
    53,
    223,
    51,
    67,
    245,
    30
  ],
  "EFI_DEVICE_PATH_PROTOCOL_GUID": [
    156724881,
    27967,
    4562,
    142,
    57,
    0,
    160,
    201,
    105,
    114,
    59
  ],
  "EFI_DEVICE_PATH_TO_TEXT_PROTOCOL_GUID": [
    2340699680,
    33074,
    18514,
    144,
    204,
    85,
    26,
    78,
    74,
    127,
    28
  ],
  "EFI_DEVICE_PATH_UTILITIES_PROTOCOL_GUID": [
    58310222,
    55046,
    17277,
    176,
    55,
    237,
    184,
    47,
    183,
    114,
    164
  ],
  "EFI_DHCP4_PROTOCOL_GUID": [
    2317457176,
    20213,
    18273,
    145,
    200,
    192,
    240,
    75,
    218,
    158,
    86
  ],
  "EFI_DHCP4_SERVICE_BINDING_PROTOCOL_GUID": [
    2644130264,
    48450,
    19059,
    164,
    213,
    142,
    233,
    75,
    225,
    19,
    128
  ],
  "EFI_DISK_INFO_AHCI_INTERFACE_GUID": [
    2655619378,
    19132,
    17839,
    163,
    77,
    2,
    71,
    120,
    123,
    231,
    198
  ],
  "EFI_DISK_INFO_IDE_INTERFACE_GUID": [
    1586794467,
    9939,
    17077,
    175,
    23,
    97,
    2,
    135,
    24,
    141,
    236
  ],
  "EFI_DISK_INFO_PROTOCOL_GUID": [
    3560089215,
    5340,
    18507,
    179,
    187,
    63,
    2,
    145,
    132,
    147,
    39
  ],
  "EFI_DISK_INFO_SCSI_INTERFACE_GUID": [
    150424490,
    59958,
    16857,
    149,
    33,
    33,
    167,
    15,
    135,
    128,
    188
  ],
  "EFI_DISK_INFO_USB_INTERFACE_GUID": [
    3414627698,
    49434,
    18357,
    180,
    146,
    103,
    94,
    175,
    167,
    119,
    39
  ],
  "EFI_DISK_IO_PROTOCOL_GUID": [
    3459535217,
    47627,
    4562,
    142,
    79,
    0,
    160,
    201,
    105,
    114,
    59
  ],
  "EFI_DMI_FORMAT_FRU_GUID": [
    1743747699,
    9620,
    19038,
    147,
    10,
    225,
    102,
    250,
    188,
    210,
    200
  ],
  "EFI_DRIVER_BINDING_PROTOCOL_GUID": [
    413151659,
    46147,
    19738,
    165,
    192,
    12,
    9,
    38,
    30,
    159,
    113
  ],
  "EFI_DRIVER_CONFIGURATION2_PROTOCOL_GUID": [
    3218594845,
    9457,
    16601,
    130,
    231,
    46,
    9,
    187,
    107,
    78,
    190
  ],
  "EFI_DRIVER_CONFIGURATION_PROTOCOL_GUID": [
    276461355,
    54753,
    4564,
    154,
    70,
    0,
    144,
    39,
    63,
    193,
    77
  ],
  "EFI_DRIVER_DIAGNOSTICS2_PROTOCOL_GUID": [
    1295188769,
    607,
    19116,
    144,
    216,
    94,
    217,
    0,
    23,
    59,
    99
  ],
  "EFI_DRIVER_DIAGNOSTICS_PROTOCOL_GUID": [
    126128719,
    58006,
    4564,
    154,
    73,
    0,
    144,
    39,
    63,
    193,
    77
  ],
  "EFI_DRIVER_FAMILY_OVERRIDE_PROTOCOL_GUID": [
    2985169566,
    55862,
    16769,
    145,
    248,
    4,
    164,
    146,
    55,
    102,
    167
  ],
  "EFI_DRIVER_HEALTH_PROTOCOL_GUID": [
    710099472,
    37504,
    16856,
    174,
    121,
    202,
    218,
    1,
    162,
    177,
    39
  ],
  "EFI_DRIVER_SUPPORTED_EFI_VERSION_PROTOCOL_GUID": [
    1545176929,
    5800,
    20073,
    151,
    44,
    137,
    214,
    121,
    84,
    248,
    29
  ],
  "EFI_DXE_IPL_PPI_GUID": [
    183029341,
    58440,
    17463,
    168,
    215,
    235,
    245,
    241,
    148,
    247,
    49
  ],
  "EFI_DXE_SERVICES_TABLE_GUID": [
    95237306,
    28418,
    16916,
    149,
    46,
    77,
    160,
    57,
    142,
    43,
    185
  ],
  "EFI_DXE_SMM_READY_TO_LOCK_PROTOCOL_GUID": [
    1627359588,
    59654,
    16848,
    175,
    237,
    242,
    65,
    233,
    116,
    224,
    142
  ],
  "EFI_EBC_INTERPRETER_PROTOCOL_GUID": [
    330067409,
    29648,
    4564,
    176,
    107,
    0,
    170,
    0,
    189,
    109,
    231
  ],
  "EFI_EDID_ACTIVE_PROTOCOL_GUID": [
    3180073046,
    40758,
    17644,
    146,
    168,
    166,
    51,
    127,
    129,
    121,
    134
  ],
  "EFI_EDID_DISCOVERED_PROTOCOL_GUID": [
    470562038,
    54144,
    16890,
    160,
    73,
    138,
    208,
    108,
    26,
    102,
    170
  ],
  "EFI_EDID_OVERRIDE_PROTOCOL_GUID": [
    1223472177,
    64370,
    17856,
    169,
    34,
    244,
    88,
    254,
    4,
    11,
    213
  ],
  "EFI_EMUL6064KBDINPUT_PROTOCOL_GUID": [
    1657728858,
    7548,
    18755,
    155,
    58,
    149,
    226,
    73,
    76,
    137,
    144
  ],
  "EFI_EMUL6064MSINPUT_PROTOCOL_GUID": [
    1970844423,
    45659,
    17657,
    137,
    46,
    32,
    155,
    14,
    57,
    147,
    198
  ],
  "EFI_EMUL6064TRAP_PROTOCOL_GUID": [
    1856042780,
    24906,
    17278,
    143,
    73,
    36,
    58,
    212,
    232,
    50,
    104
  ],
  "EFI_EVENT_LEGACY_BOOT_GUID": [
    710349313,
    18790,
    18422,
    139,
    134,
    243,
    30,
    65,
    243,
    47,
    16
  ],
  "EFI_EXTENDED_SAL_BASE_IO_SERVICES_PROTOCOL_GUID": [
    1525301941,
    12769,
    17685,
    188,
    49,
    184,
    213,
    37,
    117,
    101,
    166
  ],
  "EFI_EXTENDED_SAL_BASE_SERVICES_PROTOCOL_GUID": [
    3655989766,
    4064,
    16835,
    150,
    251,
    131,
    66,
    90,
    51,
    148,
    248
  ],
  "EFI_EXTENDED_SAL_CACHE_SERVICES_PROTOCOL_GUID": [
    249336980,
    10051,
    19365,
    136,
    24,
    10,
    239,
    82,
    19,
    241,
    136
  ],
  "EFI_EXTENDED_SAL_ELOG_SERVICES_PROTOCOL_GUID": [
    3588550239,
    15882,
    17724,
    167,
    37,
    182,
    146,
    187,
    6,
    54,
    90
  ],
  "EFI_EXTENDED_SAL_FV_BLOCK_SERVICES_PROTOCOL_GUID": [
    2720472561,
    48315,
    20253,
    152,
    169,
    6,
    188,
    23,
    47,
    7,
    26
  ],
  "EFI_EXTENDED_SAL_LOCK_SERVICES_PROTOCOL_GUID": [
    1991728163,
    65103,
    19991,
    162,
    173,
    26,
    101,
    61,
    187,
    73,
    74
  ],
  "EFI_EXTENDED_SAL_MCA_LOG_SERVICES_PROTOCOL_GUID": [
    3409959022,
    14499,
    19459,
    154,
    92,
    144,
    207,
    163,
    162,
    171,
    122
  ],
  "EFI_EXTENDED_SAL_MCA_SERVICES_PROTOCOL_GUID": [
    710480168,
    27847,
    17073,
    138,
    240,
    88,
    147,
    59,
    104,
    45,
    187
  ],
  "EFI_EXTENDED_SAL_MP_SERVICES_PROTOCOL_GUID": [
    1769832866,
    53016,
    19904,
    158,
    13,
    6,
    17,
    59,
    97,
    138,
    63
  ],
  "EFI_EXTENDED_SAL_MTC_SERVICES_PROTOCOL_GUID": [
    2308635928,
    30184,
    16523,
    164,
    26,
    110,
    46,
    126,
    205,
    244,
    84
  ],
  "EFI_EXTENDED_SAL_PAL_SERVICES_PROTOCOL_GUID": [
    3788348705,
    4034,
    17293,
    151,
    3,
    4,
    230,
    109,
    150,
    30,
    87
  ],
  "EFI_EXTENDED_SAL_PCI_SERVICES_PROTOCOL_GUID": [
    2758482481,
    44390,
    18693,
    146,
    246,
    43,
    70,
    89,
    220,
    48,
    99
  ],
  "EFI_EXTENDED_SAL_RESET_SERVICES_PROTOCOL_GUID": [
    2097256848,
    36065,
    18165,
    167,
    118,
    60,
    81,
    152,
    103,
    106,
    160
  ],
  "EFI_EXTENDED_SAL_RTC_SERVICES_PROTOCOL_GUID": [
    2123867248,
    61403,
    19714,
    143,
    206,
    97,
    144,
    210,
    123,
    162,
    150
  ],
  "EFI_EXTENDED_SAL_SENSOR_SERVICES_PROTOCOL_GUID": [
    1242905454,
    34209,
    18818,
    152,
    244,
    106,
    140,
    252,
    164,
    171,
    161
  ],
  "EFI_EXTENDED_SAL_SM_COM_LAYER_SERVICES_PROTOCOL_GUID": [
    70608793,
    33207,
    19976,
    163,
    141,
    217,
    120,
    250,
    71,
    186,
    66
  ],
  "EFI_EXTENDED_SAL_SST_GUID": [
    947922688,
    34442,
    19278,
    129,
    212,
    79,
    27,
    220,
    207,
    180,
    111
  ],
  "EFI_EXTENDED_SAL_STALL_SERVICES_PROTOCOL_GUID": [
    1403358470,
    44071,
    19852,
    181,
    233,
    240,
    138,
    128,
    101,
    65,
    112
  ],
  "EFI_EXTENDED_SAL_STATUS_CODE_SERVICES_PROTOCOL_GUID": [
    14407965,
    21993,
    16911,
    150,
    57,
    94,
    159,
    132,
    55,
    180,
    79
  ],
  "EFI_EXTENDED_SAL_VARIABLE_SERVICES_PROTOCOL_GUID": [
    1321954387,
    50753,
    17264,
    140,
    178,
    59,
    14,
    73,
    110,
    131,
    120
  ],
  "EFI_EXTENDED_SAL_VIRTUAL_SERVICES_PROTOCOL_GUID": [
    3248963670,
    9742,
    18545,
    160,
    49,
    230,
    69,
    166,
    91,
    110,
    17
  ],
  "EFI_EXT_SCSI_PASS_THRU_PROTOCOL_GUID": [
    339441202,
    47131,
    19639,
    171,
    211,
    182,
    37,
    165,
    185,
    191,
    254
  ],
  "EFI_FAULT_TOLERANT_WRITE_PROTOCOL_GUID": [
    1052614274,
    11384,
    19942,
    151,
    134,
    141,
    75,
    252,
    183,
    200,
    129
  ],
  "EFI_FILE_SYSTEM_INFO_ID_GUID": [
    156724883,
    27967,
    4562,
    142,
    57,
    0,
    160,
    201,
    105,
    114,
    59
  ],
  "EFI_FILE_SYSTEM_VOLUME_LABEL_INFO_ID_GUID": [
    3678918611,
    65153,
    4563,
    154,
    53,
    0,
    144,
    39,
    63,
    193,
    77
  ],
  "EFI_FIRMWARE_FILE_SYSTEM2_GUID": [
    2358044024,
    35389,
    20252,
    153,
    53,
    137,
    97,
    133,
    195,
    45,
    211
  ],
  "EFI_FIRMWARE_FILE_SYSTEM_GUID": [
    2056475865,
    1128,
    17482,
    129,
    206,
    11,
    246,
    23,
    216,
    144,
    223
  ],
  "EFI_FIRMWARE_VOLUME2_PROTOCOL_GUID": [
    571372470,
    27611,
    17427,
    132,
    5,
    185,
    116,
    177,
    8,
    97,
    154
  ],
  "EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL_GUID": [
    2405715881,
    59472,
    19889,
    156,
    226,
    11,
    68,
    105,
    142,
    141,
    164
  ],
  "EFI_FIRMWARE_VOLUME_DISPATCH_PROTOCOL_GUID": [
    2057525865,
    20588,
    17487,
    167,
    175,
    105,
    75,
    245,
    111,
    113,
    200
  ],
  "EFI_FIRMWARE_VOLUME_PROTOCOL_GUID": [
    949974303,
    6200,
    17288,
    131,
    144,
    205,
    129,
    84,
    189,
    39,
    248
  ],
  "EFI_FORM_BROWSER2_PROTOCOL_GUID": [
    3117728608,
    48379,
    20379,
    146,
    152,
    83,
    193,
    54,
    152,
    34,
    88
  ],
  "EFI_FORM_BROWSER_PROTOCOL_GUID": [
    3852546878,
    57780,
    19797,
    206,
    235,
    53,
    195,
    239,
    19,
    52,
    67
  ],
  "EFI_FORM_CALLBACK_PROTOCOL_GUID": [
    4091827261,
    53045,
    27887,
    53,
    196,
    79,
    230,
    52,
    77,
    252,
    84
  ],
  "EFI_FRAMEWORK_DEVICE_PATH_GUID": [
    3070774883,
    18103,
    19738,
    134,
    119,
    227,
    11,
    83,
    219,
    240,
    80
  ],
  "EFI_FTW_LITE_PROTOCOL_GUID": [
    1062564233,
    36270,
    17838,
    160,
    179,
    43,
    153,
    202,
    122,
    167,
    160
  ],
  "EFI_FVB_EXTENSION_PROTOCOL_GUID": [
    1403307803,
    46465,
    16752,
    145,
    179,
    141,
    184,
    122,
    75,
    92,
    70
  ],
  "EFI_GENERIC_MEMORY_TEST_PROTOCOL_GUID": [
    815654897,
    32606,
    19150,
    180,
    156,
    83,
    27,
    229,
    170,
    149,
    239
  ],
  "EFI_GENERIC_VARIABLE_GUID": [
    1506918991,
    20721,
    16410,
    177,
    1,
    243,
    62,
    13,
    174,
    212,
    67
  ],
  "EFI_GLOBAL_NVS_AREA_PROTOCOL_GUID": [
    122560072,
    33074,
    18337,
    140,
    44,
    63,
    20,
    173,
    154,
    102,
    220
  ],
  "EFI_GPIO_PROTOCOL_GUID": [
    3050344580,
    32941,
    18265,
    181,
    28,
    39,
    84,
    138,
    251,
    139,
    141
  ],
  "EFI_GRAPHICS_OUTPUT_PROTOCOL_GUID": [
    2420287966,
    9180,
    19000,
    150,
    251,
    122,
    222,
    208,
    128,
    81,
    106
  ],
  "EFI_HARDWARE_ERROR_VARIABLE_GUID": [
    1095658461,
    58491,
    18380,
    178,
    68,
    187,
    97,
    2,
    12,
    245,
    22
  ],
  "EFI_HASH_ALGORITHM_SHA1_GUID": [
    719968271,
    16306,
    16533,
    183,
    177,
    233,
    49,
    87,
    185,
    70,
    182
  ],
  "EFI_HASH_ALGORITHM_SHA224_GUID": [
    2381322758,
    39893,
    19447,
    176,
    33,
    219,
    79,
    217,
    204,
    244,
    91
  ],
  "EFI_HASH_ALGORITHM_SHA256_GUID": [
    1370118622,
    65010,
    20131,
    188,
    99,
    135,
    95,
    183,
    132,
    46,
    233
  ],
  "EFI_HASH_ALGORITHM_SHA384_GUID": [
    4020855858,
    56883,
    19922,
    174,
    230,
    50,
    140,
    51,
    223,
    119,
    122
  ],
  "EFI_HASH_ALGORITHM_SHA512_GUID": [
    3399759902,
    29964,
    18288,
    184,
    112,
    122,
    35,
    180,
    228,
    33,
    48
  ],
  "EFI_HASH_PROTOCOL_GUID": [
    3306703154,
    56229,
    18139,
    165,
    186,
    204,
    11,
    218,
    156,
    20,
    53
  ],
  "EFI_HASH_SERVICE_BINDING_PROTOCOL_GUID": [
    1116216472,
    42227,
    17584,
    163,
    157,
    223,
    161,
    134,
    103,
    216,
    205
  ],
  "EFI_HII_CONFIG_ACCESS_PROTOCOL_GUID": [
    856508166,
    62112,
    20047,
    163,
    105,
    182,
    111,
    168,
    213,
    67,
    133
  ],
  "EFI_HII_CONFIG_ROUTING_PROTOCOL_GUID": [
    1484681943,
    52304,
    20345,
    130,
    9,
    202,
    41,
    31,
    193,
    161,
    15
  ],
  "EFI_HII_DATABASE_PROTOCOL_GUID": [
    4020224370,
    41394,
    18067,
    179,
    39,
    109,
    50,
    252,
    65,
    96,
    66
  ],
  "EFI_HII_DRIVER_HEALTH_FORMSET_GUID": [
    4063216140,
    36084,
    17899,
    142,
    6,
    173,
    78,
    80,
    185,
    93,
    211
  ],
  "EFI_HII_EXT_PROTOCOL_GUID": [
    710389365,
    35706,
    19556,
    134,
    86,
    219,
    81,
    221,
    195,
    111,
    123
  ],
  "EFI_HII_FONT_PROTOCOL_GUID": [
    3922347893,
    34391,
    18428,
    151,
    231,
    126,
    214,
    90,
    8,
    67,
    36
  ],
  "EFI_HII_FRONT_PAGE_CLASS_GUID": [
    2496926135,
    30313,
    17859,
    186,
    59,
    243,
    165,
    138,
    113,
    86,
    129
  ],
  "EFI_HII_IMAGE_PROTOCOL_GUID": [
    832979050,
    27615,
    20038,
    178,
    162,
    235,
    170,
    137,
    196,
    9,
    32
  ],
  "EFI_HII_NEW_PROTOCOL_GUID": [
    3934350636,
    52965,
    20226,
    153,
    181,
    211,
    144,
    92,
    187,
    208,
    119
  ],
  "EFI_HII_OLD_PROTOCOL_GUID": [
    3442874711,
    44990,
    16990,
    163,
    88,
    95,
    88,
    137,
    207,
    254,
    123
  ],
  "EFI_HII_PACKAGE_LIST_PROTOCOL_GUID": [
    1780410211,
    54394,
    17332,
    170,
    190,
    239,
    29,
    226,
    171,
    86,
    252
  ],
  "EFI_HII_PLATFORM_SETUP_FORMSET_GUID": [
    2466486641,
    34117,
    19204,
    180,
    94,
    50,
    235,
    131,
    38,
    4,
    14
  ],
  "EFI_HII_PROTOCOL_GUID": [
    3618464622,
    47511,
    17819,
    191,
    63,
    136,
    70,
    137,
    121,
    128,
    225
  ],
  "EFI_HII_SET_KEYBOARD_LAYOUT_EVENT_GUID": [
    345516623,
    45293,
    17848,
    168,
    17,
    90,
    122,
    155,
    194,
    50,
    223
  ],
  "EFI_HII_STRING_PROTOCOL_GUID": [
    265906548,
    9130,
    19676,
    185,
    203,
    152,
    209,
    119,
    80,
    50,
    42
  ],
  "EFI_HII_USER_CREDENTIAL_FORMSET_GUID": [
    863978503,
    23278,
    19331,
    178,
    167,
    78,
    173,
    202,
    48,
    136,
    205
  ],
  "EFI_HOB_MEMORY_ALLOC_BSP_STORE_GUID": [
    1447769037,
    51498,
    17811,
    144,
    191,
    36,
    115,
    228,
    60,
    99,
    34
  ],
  "EFI_HOB_MEMORY_ALLOC_STACK_GUID": [
    1322565415,
    16530,
    17129,
    128,
    125,
    82,
    123,
    29,
    0,
    201,
    189
  ],
  "EFI_HOT_KEYS_PROTOCOL_GUID": [
    4058284679,
    16353,
    17717,
    137,
    171,
    72,
    214,
    195,
    218,
    39,
    89
  ],
  "EFI_HT_BIST_HOB_GUID": [
    3194241025,
    59348,
    18609,
    176,
    150,
    139,
    160,
    71,
    188,
    122,
    231
  ],
  "EFI_IDER_CONTROLLER_DRIVER_PROTOCOL_GUID": [
    2506763984,
    42703,
    16538,
    184,
    245,
    53,
    241,
    76,
    62,
    60,
    2
  ],
  "EFI_IDE_CONTROLLER_INIT_PROTOCOL_GUID": [
    2716037202,
    32985,
    20069,
    163,
    23,
    62,
    154,
    85,
    196,
    62,
    201
  ],
  "EFI_IFR_TIANO_GUID": [
    252385077,
    34720,
    16787,
    178,
    102,
    83,
    140,
    56,
    175,
    72,
    206
  ],
  "EFI_IMAGE_SECURITY_DATABASE_GUID": [
    3608785611,
    15674,
    17814,
    163,
    188,
    218,
    208,
    14,
    103,
    101,
    111
  ],
  "EFI_INCOMPATIBLE_PCI_DEVICE_SUPPORT_PROTOCOL_GUID": [
    3945002330,
    30819,
    19138,
    141,
    61,
    149,
    101,
    53,
    222,
    3,
    117
  ],
  "EFI_INTEL_MFG_FORMAT_FRU_GUID": [
    2045299143,
    4434,
    20224,
    184,
    49,
    20,
    241,
    196,
    4,
    26,
    224
  ],
  "EFI_IOBASE_HOB_GUID": [
    3567422014,
    56562,
    17359,
    162,
    183,
    243,
    87,
    42,
    124,
    171,
    9
  ],
  "EFI_IP4_CONFIG_PROTOCOL_GUID": [
    999664177,
    14227,
    17227,
    134,
    103,
    200,
    7,
    8,
    146,
    224,
    94
  ],
  "EFI_IP4_PROTOCOL_GUID": [
    1104760018,
    13750,
    17754,
    130,
    88,
    212,
    229,
    19,
    52,
    170,
    221
  ],
  "EFI_IP4_SERVICE_BINDING_PROTOCOL_GUID": [
    3306623463,
    46271,
    16458,
    191,
    184,
    10,
    4,
    142,
    241,
    255,
    228
  ],
  "EFI_IP_PROTOCOL_GUID": [
    2313088823,
    12760,
    18076,
    149,
    182,
    1,
    105,
    188,
    134,
    108,
    251
  ],
  "EFI_ISA_ACPI_PROTOCOL_GUID": [
    1688769244,
    21857,
    17718,
    146,
    199,
    121,
    155,
    252,
    24,
    51,
    85
  ],
  "EFI_ISA_IO_PROTOCOL_GUID": [
    2128788804,
    15776,
    4564,
    154,
    56,
    0,
    144,
    39,
    63,
    193,
    77
  ],
  "EFI_ISCSI_INITIATOR_NAME_PROTOCOL_GUID": [
    1496467781,
    60484,
    19469,
    177,
    205,
    157,
    177,
    57,
    223,
    7,
    12
  ],
  "EFI_LEGACY_8259_PROTOCOL_GUID": [
    942808506,
    20448,
    19991,
    138,
    236,
    65,
    48,
    85,
    234,
    237,
    193
  ],
  "EFI_LEGACY_BIOS_EXT_PROTOCOL_GUID": [
    2382398736,
    39857,
    17789,
    159,
    112,
    137,
    122,
    186,
    134,
    93,
    185
  ],
  "EFI_LEGACY_BIOS_PLATFORM_PROTOCOL_GUID": [
    2016827555,
    16754,
    17441,
    162,
    153,
    224,
    9,
    7,
    156,
    12,
    180
  ],
  "EFI_LEGACY_BIOS_PROTOCOL_GUID": [
    3684310589,
    17867,
    19131,
    133,
    59,
    229,
    56,
    127,
    219,
    46,
    45
  ],
  "EFI_LEGACY_BIOS_THUNK_PROTOCOL_GUID": [
    1280419770,
    29077,
    17453,
    135,
    146,
    190,
    234,
    110,
    47,
    246,
    236
  ],
  "EFI_LEGACY_INTERRUPT_PROTOCOL_GUID": [
    835606845,
    4234,
    18525,
    173,
    178,
    120,
    242,
    31,
    41,
    102,
    190
  ],
  "EFI_LEGACY_SREDIR_PROTOCOL_GUID": [
    2690830111,
    33907,
    19107,
    135,
    147,
    96,
    11,
    196,
    255,
    169,
    169
  ],
  "EFI_LIGHT_ISA_IO_PROTOCOL_GUID": [
    2093477248,
    39528,
    18305,
    128,
    228,
    218,
    22,
    153,
    16,
    90,
    254
  ],
  "EFI_LOADED_IMAGE_DEVICE_PATH_PROTOCOL_GUID": [
    3160544638,
    15923,
    20460,
    153,
    32,
    45,
    59,
    54,
    215,
    80,
    223
  ],
  "EFI_LOADED_IMAGE_PROTOCOL_GUID": [
    1528508833,
    38242,
    4562,
    142,
    63,
    0,
    160,
    201,
    105,
    114,
    59
  ],
  "EFI_LOAD_FILE2_PROTOCOL_GUID": [
    1074184385,
    64691,
    16446,
    153,
    109,
    74,
    108,
    135,
    36,
    224,
    109
  ],
  "EFI_MANAGED_NETWORK_PROTOCOL_GUID": [
    2058566289,
    44261,
    17190,
    181,
    114,
    231,
    238,
    51,
    211,
    159,
    22
  ],
  "EFI_MANAGED_NETWORK_SERVICE_BINDING_PROTOCOL_GUID": [
    4084201328,
    42977,
    17103,
    158,
    210,
    86,
    240,
    242,
    113,
    244,
    76
  ],
  "EFI_MEMORY_CONFIG_DATA_GUID": [
    2161890608,
    46924,
    20241,
    140,
    3,
    65,
    134,
    101,
    83,
    40,
    49
  ],
  "EFI_MEMORY_PRODUCER_GUID": [
    494591342,
    45786,
    19211,
    178,
    159,
    73,
    203,
    66,
    244,
    99,
    86
  ],
  "EFI_MEMORY_SUBCLASS_DRIVER_GUID": [
    392679149,
    56194,
    18381,
    191,
    43,
    104,
    69,
    138,
    140,
    207,
    255
  ],
  "EFI_MEMORY_TYPE_FRU_GUID": [
    3573691636,
    28491,
    17384,
    160,
    19,
    60,
    30,
    51,
    217,
    185,
    177
  ],
  "EFI_METRONOME_ARCH_PROTOCOL_GUID": [
    649776306,
    28482,
    4564,
    188,
    231,
    0,
    128,
    199,
    60,
    136,
    129
  ],
  "EFI_ME_BIOS_EXTENSION_SETUP_GUID": [
    464351516,
    54353,
    16961,
    177,
    243,
    133,
    55,
    129,
    46,
    12,
    112
  ],
  "EFI_ME_FW_SKU_VARIABLE_GUID": [
    3785498004,
    18976,
    19982,
    174,
    9,
    169,
    162,
    31,
    36,
    187,
    158
  ],
  "EFI_MINI_SHELL_FILE_GUID": [
    2259493675,
    54074,
    18012,
    191,
    95,
    65,
    55,
    11,
    169,
    47,
    226
  ],
  "EFI_MISC_PRODUCER_GUID": [
    1649486994,
    25540,
    19840,
    130,
    177,
    193,
    164,
    220,
    68,
    128,
    229
  ],
  "EFI_MISC_SUBCLASS_DRIVER_GUID": [
    4111364140,
    34387,
    19678,
    187,
    206,
    67,
    180,
    213,
    91,
    52,
    184
  ],
  "EFI_MPS_TABLE_GUID": [
    3952946479,
    11656,
    4563,
    154,
    22,
    0,
    144,
    39,
    63,
    193,
    77
  ],
  "EFI_MTFTP4_PROTOCOL_GUID": [
    2015657047,
    25563,
    18184,
    153,
    194,
    168,
    180,
    169,
    166,
    31,
    107
  ],
  "EFI_MTFTP4_SERVICE_BINDING_PROTOCOL_GUID": [
    803733694,
    36609,
    19110,
    148,
    107,
    215,
    19,
    136,
    225,
    131,
    63
  ],
  "EFI_NB_ERROR_LOG_DISPATCH_PROTOCOL_GUID": [
    4281160916,
    23637,
    19462,
    133,
    73,
    195,
    98,
    124,
    184,
    185,
    149
  ],
  "EFI_NB_MRC_INFO_GUID": [
    3619508912,
    45788,
    20232,
    180,
    103,
    222,
    80,
    215,
    40,
    246,
    189
  ],
  "EFI_NETWORK_INTERFACE_IDENTIFIER_PROTOCOL_GUID": [
    3783606733,
    63317,
    20339,
    146,
    141,
    100,
    60,
    138,
    121,
    178,
    41
  ],
  "EFI_NIC_IP4_CONFIG_PROTOCOL_GUID": [
    231357773,
    4826,
    18216,
    191,
    126,
    134,
    206,
    185,
    40,
    208,
    103
  ],
  "EFI_NIC_IP4_CONFIG_VARIABLE_GUID": [
    3633595731,
    50397,
    16884,
    155,
    48,
    225,
    57,
    124,
    251,
    38,
    123
  ],
  "EFI_NONSMMEMUL6064TRAP_PROTOCOL_GUID": [
    1756896849,
    9603,
    17794,
    149,
    219,
    197,
    114,
    50,
    54,
    196,
    241
  ],
  "EFI_OEM_BADGING_PROTOCOL_GUID": [
    386798528,
    48923,
    16920,
    135,
    29,
    42,
    189,
    198,
    248,
    135,
    188
  ],
  "EFI_PART_TYPE_EFI_SYSTEM_PART_GUID": [
    3240784680,
    63519,
    4562,
    186,
    75,
    0,
    160,
    201,
    62,
    201,
    59
  ],
  "EFI_PART_TYPE_LEGACY_MBR_GUID": [
    38661697,
    13287,
    4563,
    157,
    105,
    0,
    8,
    199,
    129,
    243,
    159
  ],
  "EFI_PATH_FILE_NAME_GUID": [
    1984217473,
    64110,
    18138,
    128,
    203,
    4,
    185,
    144,
    64,
    98,
    232
  ],
  "EFI_PCCARD_CS_PROTOCOL_GUID": [
    3394565187,
    7922,
    19883,
    158,
    126,
    109,
    183,
    183,
    32,
    181,
    135
  ],
  "EFI_PCCARD_SS_PROTOCOL_GUID": [
    3280891188,
    23167,
    19449,
    190,
    87,
    148,
    221,
    48,
    56,
    2,
    118
  ],
  "EFI_PCH_INFO_PROTOCOL_GUID": [
    3542025216,
    32022,
    17174,
    191,
    136,
    96,
    101,
    136,
    59,
    64,
    43
  ],
  "EFI_PCH_S3_IMAGE_GUID": [
    656266994,
    21707,
    17894,
    133,
    133,
    140,
    146,
    60,
    26,
    199,
    6
  ],
  "EFI_PCH_S3_SUPPORT_PROTOCOL_GUID": [
    3800551947,
    55447,
    19998,
    165,
    217,
    151,
    119,
    99,
    147,
    106,
    4
  ],
  "EFI_PCI_EXPRESS_BASE_ADDRESS_GUID": [
    913823017,
    12911,
    17923,
    169,
    38,
    234,
    172,
    224,
    29,
    203,
    176
  ],
  "EFI_PCI_HOTPLUG_DEVICE_GUID": [
    187172886,
    21223,
    20049,
    170,
    87,
    17,
    189,
    65,
    203,
    239,
    195
  ],
  "EFI_PCI_HOT_PLUG_INIT_PROTOCOL_GUID": [
    2853080001,
    55996,
    18096,
    168,
    68,
    55,
    184,
    22,
    155,
    43,
    234
  ],
  "EFI_PCI_IO_PROTOCOL_GUID": [
    1291170304,
    26808,
    19621,
    158,
    236,
    178,
    62,
    63,
    80,
    2,
    154
  ],
  "EFI_PCI_OPTION_ROM_TABLE_GUID": [
    1952605711,
    7357,
    18650,
    173,
    17,
    145,
    113,
    121,
    19,
    131,
    28
  ],
  "EFI_PCI_PLATFORM_PROTOCOL_GUID": [
    131551872,
    10196,
    19817,
    144,
    208,
    86,
    67,
    226,
    56,
    179,
    65
  ],
  "EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL_GUID": [
    795901627,
    18970,
    4564,
    154,
    56,
    0,
    144,
    39,
    63,
    193,
    77
  ],
  "EFI_PCMCIA_REQUEST_PROTOCOL_GUID": [
    4063818876,
    7657,
    20107,
    129,
    185,
    204,
    146,
    78,
    107,
    91,
    229
  ],
  "EFI_PC_ANSI_GUID": [
    3770763091,
    63934,
    4562,
    154,
    12,
    0,
    144,
    39,
    63,
    193,
    77
  ],
  "EFI_PEI_AMI_KEYCODE_PPI_GUID": [
    548467138,
    45272,
    19549,
    170,
    217,
    244,
    69,
    128,
    223,
    223,
    139
  ],
  "EFI_PEI_APRIORI_FILE_NAME_GUID": [
    457559050,
    5482,
    17034,
    175,
    98,
    73,
    134,
    77,
    160,
    230,
    230
  ],
  "EFI_PEI_CAPSULE_PPI_GUID": [
    986657774,
    55442,
    16628,
    162,
    252,
    56,
    84,
    210,
    225,
    50,
    61
  ],
  "EFI_PEI_CMOS_ACCESS_GUID": [
    3435079558,
    52588,
    17160,
    189,
    250,
    98,
    88,
    112,
    206,
    191,
    129
  ],
  "EFI_PEI_CONSPLIT_AMI_KEYCODE_PPI_GUID": [
    1943909857,
    24500,
    18257,
    175,
    30,
    131,
    207,
    117,
    190,
    203,
    182
  ],
  "EFI_PEI_CORE_PRIVATE_GUID": [
    3594625269,
    52092,
    18502,
    163,
    128,
    29,
    1,
    180,
    217,
    227,
    185
  ],
  "EFI_PEI_CPU_IO_PPI_INSTALLED_GUID": [
    3870236539,
    64575,
    18138,
    168,
    40,
    163,
    180,
    87,
    164,
    66,
    130
  ],
  "EFI_PEI_DECOMPRESS_PPI_GUID": [
    439805159,
    64182,
    18282,
    142,
    117,
    105,
    90,
    5,
    118,
    253,
    215
  ],
  "EFI_PEI_DEVICE_RECOVERY_MODULE_PPI_GUID": [
    232967717,
    17514,
    17831,
    191,
    201,
    55,
    218,
    38,
    52,
    75,
    55
  ],
  "EFI_PEI_END_OF_PEI_PHASE_PPI_GUID": [
    1616815696,
    50780,
    17121,
    186,
    128,
    145,
    165,
    42,
    182,
    24,
    198
  ],
  "EFI_PEI_FIRMWARE_VOLUME_INFO_PPI_GUID": [
    1240314305,
    48929,
    18273,
    187,
    18,
    235,
    0,
    49,
    170,
    187,
    57
  ],
  "EFI_PEI_FLUSH_INSTRUCTION_CACHE_GUID": [
    3625024764,
    38054,
    4564,
    154,
    58,
    0,
    144,
    39,
    63,
    193,
    77
  ],
  "EFI_PEI_LOADED_IMAGE_PPI_GUID": [
    3254572104,
    25344,
    17496,
    184,
    100,
    40,
    223,
    1,
    83,
    100,
    188
  ],
  "EFI_PEI_LOAD_FILE_PPI_GUID": [
    3118509054,
    22905,
    18708,
    151,
    127,
    109,
    238,
    120,
    194,
    120,
    166
  ],
  "EFI_PEI_PCI_CFG2_PPI_GUID": [
    91899034,
    8156,
    19462,
    191,
    201,
    245,
    63,
    106,
    153,
    187,
    146
  ],
  "EFI_PEI_PERFORMANCE_HOB_GUID": [
    284439262,
    57068,
    17969,
    128,
    205,
    71,
    246,
    93,
    143,
    128,
    187
  ],
  "EFI_PEI_PE_COFF_LOADER_GUID": [
    3625024767,
    38054,
    4564,
    154,
    58,
    0,
    144,
    39,
    63,
    193,
    77
  ],
  "EFI_PEI_PLATFORMPEI_EXECUTED_PPI_GUID": [
    2356331374,
    56012,
    20097,
    141,
    96,
    255,
    166,
    29,
    136,
    255,
    84
  ],
  "EFI_PEI_READ_ONLY_VARIABLE2_PPI_GUID": [
    716730101,
    60597,
    16692,
    181,
    86,
    56,
    84,
    202,
    31,
    225,
    180
  ],
  "EFI_PEI_RECOVERY_MODULE_PPI_GUID": [
    4218262850,
    24877,
    20293,
    135,
    47,
    92,
    255,
    82,
    233,
    61,
    207
  ],
  "EFI_PEI_REPORT_PROGRESS_CODE_PPI_GUID": [
    580399827,
    31280,
    19254,
    184,
    39,
    244,
    12,
    183,
    212,
    84,
    54
  ],
  "EFI_PEI_RESET_PPI_GUID": [
    4013526360,
    40445,
    16643,
    191,
    148,
    120,
    198,
    244,
    254,
    113,
    47
  ],
  "EFI_PEI_RSC_HANDLER_PPI_GUID": [
    6673300,
    39249,
    16708,
    130,
    163,
    10,
    252,
    133,
    121,
    194,
    81
  ],
  "EFI_PEI_S3_RESUME2_PPI_GUID": [
    1834495420,
    56197,
    17684,
    143,
    204,
    90,
    223,
    98,
    39,
    177,
    71
  ],
  "EFI_PEI_SECTION_EXTRACTION_PPI_GUID": [
    1334436360,
    57668,
    18436,
    158,
    200,
    15,
    137,
    79,
    126,
    54,
    215
  ],
  "EFI_PEI_SECURITY2_PPI_GUID": [
    3704667683,
    38278,
    16628,
    182,
    67,
    6,
    82,
    44,
    237,
    78,
    222
  ],
  "EFI_PEI_STALL_PPI_GUID": [
    525102992,
    45163,
    18648,
    162,
    1,
    186,
    229,
    241,
    205,
    125,
    86
  ],
  "EFI_PEI_TEMPORARY_RAM_SUPPORT_PPI_GUID": [
    3689036457,
    41797,
    19351,
    133,
    182,
    178,
    38,
    241,
    97,
    115,
    137
  ],
  "EFI_PEI_TRANSFER_CONTROL_GUID": [
    3625024770,
    38054,
    4564,
    154,
    58,
    0,
    144,
    39,
    63,
    193,
    77
  ],
  "EFI_PERFORMANCE_PROTOCOL_GUID": [
    4293722111,
    37436,
    5330,
    158,
    63,
    34,
    160,
    201,
    105,
    86,
    59
  ],
  "EFI_PI_MP_SERVICES_PROTOCOL_GUID": [
    1071490565,
    42862,
    20294,
    173,
    41,
    18,
    244,
    83,
    27,
    61,
    8
  ],
  "EFI_PLATFORM_DRIVER_OVERRIDE_PROTOCOL_GUID": [
    1798358840,
    41873,
    4564,
    154,
    59,
    0,
    144,
    39,
    63,
    193,
    77
  ],
  "EFI_PLATFORM_GOP_POLICY_PROTOCOL_GUID": [
    3962475291,
    12929,
    18597,
    129,
    7,
    223,
    138,
    139,
    237,
    60,
    93
  ],
  "EFI_PLATFORM_INFO_PROTOCOL_GUID": [
    3640873333,
    36066,
    18398,
    168,
    184,
    204,
    152,
    229,
    226,
    168,
    133
  ],
  "EFI_PLATFORM_MEMTEST_PROTOCOL_GUID": [
    140098072,
    32215,
    20183,
    168,
    142,
    16,
    156,
    99,
    145,
    123,
    221
  ],
  "EFI_PLATFORM_TO_DRIVER_CONFIGURATION_CLP_GUID": [
    878627854,
    3254,
    19317,
    187,
    87,
    27,
    18,
    156,
    71,
    51,
    62
  ],
  "EFI_PLATFORM_TO_DRIVER_CONFIGURATION_PROTOCOL_GUID": [
    1680659856,
    32857,
    19466,
    169,
    88,
    197,
    236,
    7,
    210,
    60,
    75
  ],
  "EFI_POWER_ON_HOB_GUID": [
    73967105,
    50485,
    18173,
    169,
    93,
    187,
    171,
    153,
    27,
    23,
    140
  ],
  "EFI_PPM_GLOBAL_NVS_AREA_PROTOCOL_GUID": [
    1817234891,
    32582,
    19916,
    141,
    221,
    217,
    240,
    163,
    198,
    17,
    40
  ],
  "EFI_PPM_INFO_PROTOCOL_GUID": [
    3609047302,
    58157,
    16933,
    191,
    244,
    222,
    109,
    119,
    135,
    23,
    97
  ],
  "EFI_PRIMARY_CONSOLE_IN_DEVICE_GUID": [
    3830570174,
    38561,
    18217,
    165,
    207,
    107,
    156,
    44,
    255,
    71,
    253
  ],
  "EFI_PRIMARY_CONSOLE_OUT_DEVICE_GUID": [
    1656615818,
    58325,
    18732,
    149,
    12,
    35,
    167,
    246,
    110,
    103,
    46
  ],
  "EFI_PRIMARY_STANDARD_ERROR_DEVICE_GUID": [
    1516771611,
    39831,
    18258,
    153,
    70,
    227,
    106,
    93,
    169,
    66,
    177
  ],
  "EFI_PRINT_PROTOCOL_GUID": [
    3744302734,
    13052,
    19696,
    142,
    107,
    255,
    217,
    93,
    19,
    67,
    208
  ],
  "EFI_PROCESSOR_PRODUCER_GUID": [
    468740842,
    23532,
    19085,
    149,
    118,
    116,
    155,
    9,
    86,
    45,
    48
  ],
  "EFI_PS2_POLICY_PROTOCOL_GUID": [
    1307677273,
    56433,
    19782,
    190,
    241,
    53,
    123,
    181,
    120,
    196,
    24
  ],
  "EFI_PXE_BASE_CODE_CALLBACK_PROTOCOL_GUID": [
    610126369,
    64379,
    4563,
    143,
    1,
    0,
    160,
    201,
    105,
    114,
    59
  ],
  "EFI_PXE_BASE_CODE_PROTOCOL_GUID": [
    63235587,
    44072,
    4563,
    154,
    45,
    0,
    144,
    39,
    63,
    193,
    77
  ],
  "EFI_PXE_DHCP4_CALLBACK_PROTOCOL_GUID": [
    3243527169,
    37540,
    16792,
    138,
    132,
    119,
    133,
    131,
    194,
    54,
    33
  ],
  "EFI_PXE_DHCP4_PROTOCOL_GUID": [
    63235620,
    44072,
    4563,
    154,
    45,
    0,
    144,
    41,
    63,
    193,
    77
  ],
  "EFI_REAL_TIME_CLOCK_ARCH_PROTOCOL_GUID": [
    667921543,
    18124,
    4564,
    154,
    56,
    0,
    144,
    39,
    63,
    193,
    77
  ],
  "EFI_RESET_ARCH_PROTOCOL_GUID": [
    667921544,
    18124,
    4564,
    154,
    56,
    0,
    144,
    39,
    63,
    193,
    77
  ],
  "EFI_S3_SAVE_STATE_PROTOCOL_GUID": [
    3898067702,
    49222,
    17884,
    190,
    63,
    238,
    7,
    101,
    251,
    168,
    135
  ],
  "EFI_S3_SMM_SAVE_STATE_PROTOCOL_GUID": [
    839581282,
    58771,
    18891,
    169,
    241,
    212,
    194,
    244,
    175,
    1,
    76
  ],
  "EFI_SAL_SYSTEM_TABLE_GUID": [
    3952946482,
    11656,
    4563,
    154,
    22,
    0,
    144,
    39,
    63,
    193,
    77
  ],
  "EFI_SA_INFO_PROTOCOL_GUID": [
    1228626860,
    48030,
    19445,
    131,
    121,
    32,
    226,
    172,
    169,
    133,
    65
  ],
  "EFI_SB_PCIE_ERROR_LOG_DISPATCH_PROTOCOL_GUID": [
    4068605038,
    62660,
    17180,
    150,
    43,
    47,
    19,
    174,
    121,
    132,
    236
  ],
  "EFI_SCSI_IO_PROTOCOL_GUID": [
    2469349350,
    9058,
    16386,
    128,
    62,
    60,
    213,
    75,
    19,
    143,
    133
  ],
  "EFI_SCSI_PASS_THRU_PROTOCOL_GUID": [
    2778632143,
    48544,
    17339,
    144,
    177,
    211,
    115,
    46,
    202,
    168,
    119
  ],
  "EFI_SECTION_EXTRACTION_PROTOCOL_GUID": [
    1150246308,
    28119,
    20449,
    147,
    7,
    105,
    34,
    65,
    146,
    33,
    93
  ],
  "EFI_SECURITY_ARCH_PROTOCOL_GUID": [
    2758026211,
    17943,
    18929,
    185,
    255,
    209,
    191,
    169,
    17,
    88,
    57
  ],
  "EFI_SECURITY_POLICY_PROTOCOL_GUID": [
    2028261957,
    52557,
    18949,
    162,
    186,
    71,
    67,
    232,
    108,
    252,
    171
  ],
  "EFI_SERIAL_GPIO_PROTOCOL_GUID": [
    4113315928,
    24312,
    19777,
    131,
    78,
    195,
    158,
    239,
    138,
    69,
    163
  ],
  "EFI_SERIAL_IO_PROTOCOL_GUID": [
    3139817327,
    61908,
    4562,
    154,
    12,
    0,
    144,
    39,
    63,
    193,
    253
  ],
  "EFI_SHELL_FILE_GUID": [
    3313161911,
    1301,
    16552,
    157,
    33,
    85,
    22,
    82,
    133,
    78,
    55
  ],
  "EFI_SIMPLE_AUDIO_OUT_PROTOCOL_GUID": [
    3341021832,
    21241,
    19840,
    182,
    51,
    225,
    82,
    249,
    48,
    160,
    220
  ],
  "EFI_SIMPLE_FILE_SYSTEM_PROTOCOL_GUID": [
    2521717538,
    25689,
    4562,
    142,
    57,
    0,
    160,
    201,
    105,
    114,
    59
  ],
  "EFI_SIMPLE_NETWORK_PROTOCOL_GUID": [
    2711106233,
    44069,
    4563,
    154,
    45,
    0,
    144,
    39,
    63,
    193,
    77
  ],
  "EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL_GUID": [
    3718149428,
    30562,
    18072,
    140,
    20,
    245,
    133,
    23,
    166,
    37,
    170
  ],
  "EFI_SIMPLE_TEXT_INPUT_PROTOCOL_GUID": [
    947156929,
    27079,
    4562,
    142,
    57,
    0,
    160,
    201,
    105,
    114,
    59
  ],
  "EFI_SIO_PROTOCOL_GUID": [
    559930648,
    48464,
    20459,
    137,
    11,
    88,
    202,
    11,
    71,
    57,
    233
  ],
  "EFI_SMBIOS_BOARD_PROTOCOL_GUID": [
    151248148,
    11424,
    17802,
    181,
    235,
    12,
    12,
    163,
    13,
    120,
    92
  ],
  "EFI_SMBIOS_DYNAMIC_DATA_GUID": [
    3816826892,
    19509,
    19107,
    185,
    97,
    122,
    228,
    137,
    162,
    185,
    38
  ],
  "EFI_SMBIOS_NVRAM_DATA_GUID": [
    1261470371,
    32966,
    19838,
    156,
    208,
    88,
    57,
    23,
    38,
    93,
    241
  ],
  "EFI_SMBIOS_PROTOCOL_GUID": [
    56115190,
    52022,
    18752,
    148,
    126,
    185,
    179,
    159,
    74,
    250,
    247
  ],
  "EFI_SMBIOS_STATIC_DATA_GUID": [
    3673472905,
    52849,
    18711,
    181,
    34,
    200,
    157,
    50,
    251,
    197,
    159
  ],
  "EFI_SMBIOS_TABLE_GUID": [
    3952946481,
    11656,
    4563,
    154,
    22,
    0,
    144,
    39,
    63,
    193,
    77
  ],
  "EFI_SMBUS_ARP_MAP_GUID": [
    1887168574,
    3062,
    16549,
    190,
    100,
    52,
    192,
    58,
    160,
    184,
    226
  ],
  "EFI_SMBUS_HC_PROTOCOL_GUID": [
    3835507693,
    20797,
    17972,
    182,
    152,
    111,
    85,
    170,
    117,
    28,
    27
  ],
  "EFI_SMM_ACCESS_PROTOCOL_GUID": [
    932317530,
    58121,
    19486,
    170,
    1,
    133,
    245,
    101,
    90,
    23,
    241
  ],
  "EFI_SMM_BASE_PROTOCOL_GUID": [
    328242509,
    55957,
    16935,
    147,
    40,
    114,
    130,
    194,
    23,
    218,
    168
  ],
  "EFI_SMM_BIOS_WRITE_DISPATCH_PROTOCOL_GUID": [
    3843219428,
    48964,
    18445,
    155,
    122,
    119,
    123,
    11,
    227,
    39,
    117
  ],
  "EFI_SMM_COMMUNICATION_PROTOCOL_GUID": [
    3331250402,
    40390,
    19645,
    157,
    148,
    219,
    101,
    172,
    197,
    195,
    50
  ],
  "EFI_SMM_CONTROL_PROTOCOL_GUID": [
    2366825009,
    50791,
    20433,
    152,
    242,
    36,
    73,
    167,
    231,
    178,
    229
  ],
  "EFI_SMM_CPU_IO2_PROTOCOL_GUID": [
    843229656,
    52848,
    19104,
    149,
    93,
    94,
    123,
    20,
    13,
    228,
    210
  ],
  "EFI_SMM_CPU_IO_GUID": [
    1598265867,
    17880,
    18050,
    164,
    244,
    240,
    87,
    107,
    81,
    52,
    65
  ],
  "EFI_SMM_CPU_PROTOCOL_GUID": [
    3946081175,
    38751,
    19103,
    139,
    34,
    248,
    233,
    43,
    179,
    213,
    105
  ],
  "EFI_SMM_CPU_SAVE_STATE_PROTOCOL_GUID": [
    569574061,
    28308,
    18203,
    132,
    188,
    177,
    72,
    0,
    64,
    58,
    29
  ],
  "EFI_SMM_GPI_DISPATCH2_PROTOCOL_GUID": [
    626420483,
    46455,
    19647,
    149,
    140,
    237,
    102,
    62,
    162,
    67,
    128
  ],
  "EFI_SMM_GPI_DISPATCH_PROTOCOL_GUID": [
    3765717889,
    38163,
    18893,
    140,
    234,
    233,
    36,
    94,
    112,
    57,
    218
  ],
  "EFI_SMM_ICHN_DISPATCH_EX_PROTOCOL_GUID": [
    958414939,
    51351,
    17626,
    136,
    243,
    76,
    73,
    138,
    111,
    247,
    54
  ],
  "EFI_SMM_ICHN_DISPATCH_PROTOCOL_GUID": [
    3305845310,
    36981,
    20266,
    172,
    142,
    210,
    89,
    106,
    16,
    133,
    204
  ],
  "EFI_SMM_IO_TRAP_DISPATCH2_PROTOCOL_GUID": [
    1490826893,
    31738,
    20087,
    171,
    188,
    14,
    41,
    65,
    141,
    249,
    48
  ],
  "EFI_SMM_IO_TRAP_DISPATCH_PROTOCOL_GUID": [
    3172480669,
    49730,
    17866,
    130,
    173,
    19,
    138,
    194,
    226,
    155,
    171
  ],
  "EFI_SMM_PCI_ROOT_BRIDGE_IO_PROTOCOL_GUID": [
    2344710477,
    65483,
    16835,
    137,
    220,
    108,
    116,
    208,
    109,
    152,
    234
  ],
  "EFI_SMM_PERIODIC_TIMER_DISPATCH2_PROTOCOL_GUID": [
    1290548878,
    36494,
    19825,
    139,
    225,
    149,
    140,
    69,
    252,
    138,
    83
  ],
  "EFI_SMM_PERIODIC_TIMER_DISPATCH_PROTOCOL_GUID": [
    2630484988,
    19614,
    18969,
    155,
    6,
    237,
    123,
    71,
    155,
    222,
    85
  ],
  "EFI_SMM_POWER_BUTTON_DISPATCH2_PROTOCOL_GUID": [
    454132730,
    6179,
    18087,
    136,
    114,
    156,
    87,
    135,
    85,
    64,
    157
  ],
  "EFI_SMM_POWER_BUTTON_DISPATCH_PROTOCOL_GUID": [
    3070881696,
    18342,
    19265,
    185,
    49,
    18,
    236,
    231,
    168,
    238,
    86
  ],
  "EFI_SMM_RC_TO_APTIO_BRIDGE_GUID": [
    4242503560,
    30840,
    4607,
    204,
    119,
    136,
    204,
    204,
    119,
    136,
    204
  ],
  "EFI_SMM_READY_TO_LOCK_PROTOCOL_GUID": [
    1203239564,
    62653,
    19190,
    130,
    0,
    51,
    48,
    134,
    240,
    210,
    200
  ],
  "EFI_SMM_RSC_HANDLER_PROTOCOL_GUID": [
    804429735,
    24192,
    20185,
    179,
    128,
    1,
    125,
    60,
    85,
    79,
    244
  ],
  "EFI_SMM_RUNTIME_PROTOCOL_GUID": [
    2775095201,
    42879,
    17920,
    132,
    219,
    34,
    176,
    168,
    1,
    250,
    154
  ],
  "EFI_SMM_RUNTIME_SERVICES_TABLE_GUID": [
    962343934,
    10367,
    16702,
    160,
    85,
    128,
    136,
    192,
    225,
    212,
    62
  ],
  "EFI_SMM_SPI_PROTOCOL_GUID": [
    3641125941,
    60303,
    17325,
    162,
    32,
    52,
    212,
    14,
    42,
    130,
    133
  ],
  "EFI_SMM_STANDBY_BUTTON_DISPATCH2_PROTOCOL_GUID": [
    1929430177,
    17394,
    16407,
    165,
    27,
    200,
    26,
    127,
    64,
    88,
    91
  ],
  "EFI_SMM_STANDBY_BUTTON_DISPATCH_PROTOCOL_GUID": [
    2023119768,
    45247,
    17566,
    139,
    34,
    210,
    145,
    78,
    73,
    138,
    152
  ],
  "EFI_SMM_STATUS_CODE_PROTOCOL_GUID": [
    1794976631,
    39105,
    19149,
    166,
    249,
    138,
    148,
    57,
    222,
    15,
    177
  ],
  "EFI_SMM_SW_DISPATCH2_PROTOCOL_GUID": [
    413386460,
    24298,
    18632,
    161,
    193,
    181,
    51,
    137,
    249,
    137,
    153
  ],
  "EFI_SMM_SW_DISPATCH_PROTOCOL_GUID": [
    3846289267,
    56593,
    16908,
    176,
    38,
    223,
    153,
    54,
    83,
    248,
    191
  ],
  "EFI_SMM_SX_DISPATCH2_PROTOCOL_GUID": [
    1164781657,
    43083,
    20039,
    162,
    238,
    50,
    118,
    216,
    134,
    153,
    125
  ],
  "EFI_SMM_TCO_DISPATCH_PROTOCOL_GUID": [
    237857713,
    50724,
    17517,
    153,
    130,
    105,
    60,
    209,
    129,
    166,
    7
  ],
  "EFI_SMM_THUNK_PROTOCOL_GUID": [
    713227494,
    35766,
    16702,
    185,
    235,
    69,
    223,
    192,
    82,
    45,
    243
  ],
  "EFI_SMM_USB_DISPATCH2_PROTOCOL_GUID": [
    4003171728,
    50598,
    16546,
    189,
    226,
    82,
    85,
    141,
    51,
    204,
    161
  ],
  "EFI_SMM_USB_DISPATCH_PROTOCOL_GUID": [
    2690347005,
    34735,
    20034,
    149,
    201,
    98,
    40,
    182,
    60,
    243,
    243
  ],
  "EFI_SMM_VARIABLE_PROTOCOL_GUID": [
    3979531571,
    39398,
    16905,
    156,
    192,
    45,
    114,
    205,
    217,
    152,
    167
  ],
  "EFI_SMRAM_NVS_HEADER_GUID": [
    3967766433,
    45591,
    17148,
    167,
    247,
    2,
    12,
    67,
    5,
    213,
    186
  ],
  "EFI_SMTP_PROTOCOL_GUID": [
    1600640012,
    7430,
    20030,
    139,
    74,
    210,
    113,
    63,
    70,
    225,
    220
  ],
  "EFI_SPEAKER_INTERFACE_PROTOCOL_GUID": [
    1074480246,
    12417,
    4566,
    135,
    237,
    0,
    6,
    41,
    69,
    195,
    185
  ],
  "EFI_SPI_PROTOCOL_GUID": [
    290910150,
    59954,
    17302,
    181,
    213,
    38,
    147,
    46,
    131,
    195,
    19
  ],
  "EFI_STANDARD_CALLER_ID_GUID": [
    3386700905,
    42948,
    4565,
    135,
    218,
    0,
    6,
    41,
    69,
    195,
    185
  ],
  "EFI_STANDARD_ERROR_DEVICE_GUID": [
    3551751981,
    54609,
    4564,
    154,
    70,
    0,
    144,
    39,
    63,
    193,
    77
  ],
  "EFI_STATUS_CODE_ARCH_PROTOCOL_GUID": [
    3649978019,
    28473,
    19428,
    130,
    206,
    90,
    137,
    12,
    203,
    44,
    149
  ],
  "EFI_STATUS_CODE_DATA_TYPE_ASSERT_GUID": [
    3663140245,
    19865,
    18556,
    130,
    124,
    38,
    34,
    103,
    125,
    51,
    7
  ],
  "EFI_STATUS_CODE_DATA_TYPE_DEBUG_GUID": [
    2588840518,
    54611,
    4565,
    135,
    226,
    0,
    6,
    41,
    69,
    195,
    185
  ],
  "EFI_STATUS_CODE_DATA_TYPE_ERROR_GUID": [
    2872417507,
    39347,
    44568,
    200,
    157,
    149,
    211,
    176,
    114,
    225,
    155
  ],
  "EFI_STATUS_CODE_DATA_TYPE_EXCEPTION_HANDLER_GUID": [
    1002618130,
    44334,
    4565,
    135,
    221,
    0,
    6,
    41,
    69,
    195,
    185
  ],
  "EFI_STATUS_CODE_DATA_TYPE_PROGRESS_CODE_GUID": [
    2740366137,
    13764,
    13786,
    179,
    122,
    248,
    234,
    158,
    139,
    54,
    163
  ],
  "EFI_STATUS_CODE_DATA_TYPE_STRING_GUID": [
    2463174784,
    18799,
    19861,
    190,
    126,
    3,
    116,
    136,
    56,
    43,
    10
  ],
  "EFI_STATUS_CODE_SPECIFIC_DATA_GUID": [
    861504701,
    59397,
    16538,
    184,
    248,
    210,
    126,
    206,
    95,
    247,
    166
  ],
  "EFI_STORAGE_SECURITY_COMMAND_PROTOCOL_GUID": [
    3364555629,
    3580,
    18855,
    156,
    180,
    73,
    7,
    75,
    76,
    58,
    120
  ],
  "EFI_SWAP_ADDRESS_RANGE_PROTOCOL_GUID": [
    307885581,
    46932,
    18062,
    167,
    137,
    77,
    184,
    93,
    85,
    232,
    126
  ],
  "EFI_SYSTEM_NV_DATA_FV_GUID": [
    4293995405,
    30358,
    19595,
    169,
    133,
    39,
    71,
    7,
    91,
    79,
    80
  ],
  "EFI_SYSTEM_NV_DATA_HOB_GUID": [
    3605334317,
    51122,
    18546,
    175,
    102,
    253,
    192,
    230,
    249,
    94,
    120
  ],
  "EFI_SYSTEM_TYPE_FRU_GUID": [
    2863751192,
    26525,
    17505,
    186,
    32,
    231,
    12,
    247,
    134,
    106,
    155
  ],
  "EFI_TAPE_IO_PROTOCOL_GUID": [
    513009203,
    54874,
    17822,
    171,
    132,
    147,
    217,
    236,
    38,
    109,
    24
  ],
  "EFI_TCG_PLATFORM_PROTOCOL_GUID": [
    2353830465,
    48982,
    17959,
    158,
    10,
    200,
    56,
    109,
    102,
    17,
    92
  ],
  "EFI_TCG_PRIVATE_INTERFACE_GUID": [
    2049459050,
    57619,
    16490,
    175,
    249,
    13,
    191,
    127,
    100,
    62,
    2
  ],
  "EFI_TCG_PROTOCOL_GUID": [
    4114708845,
    42542,
    18772,
    167,
    117,
    149,
    132,
    246,
    27,
    156,
    221
  ],
  "EFI_TCP4_PROTOCOL_GUID": [
    1699941319,
    41817,
    16655,
    176,
    16,
    90,
    173,
    199,
    236,
    43,
    98
  ],
  "EFI_TCP4_SERVICE_BINDING_PROTOCOL_GUID": [
    7472741,
    26603,
    19097,
    186,
    247,
    211,
    195,
    58,
    28,
    124,
    201
  ],
  "EFI_TCP_PROTOCOL_GUID": [
    45340146,
    44072,
    4563,
    154,
    45,
    0,
    144,
    39,
    63,
    193,
    77
  ],
  "EFI_TCP_SOCK_PROTOCOL_GUID": [
    1367815579,
    30989,
    16987,
    165,
    147,
    202,
    28,
    219,
    60,
    235,
    173
  ],
  "EFI_TDT_PROTOCOL_GUID": [
    200736871,
    54587,
    17119,
    183,
    112,
    233,
    44,
    145,
    198,
    20,
    17
  ],
  "EFI_TELNET_SERVER_PROTOCOL_GUID": [
    1832217044,
    34277,
    18755,
    174,
    70,
    238,
    103,
    166,
    225,
    171,
    90
  ],
  "EFI_TIANO_DECOMPRESS_PROTOCOL_GUID": [
    3897356956,
    6431,
    20142,
    150,
    225,
    244,
    106,
    236,
    234,
    234,
    11
  ],
  "EFI_TIMER_ARCH_PROTOCOL_GUID": [
    649776307,
    28482,
    4564,
    188,
    231,
    0,
    128,
    199,
    60,
    136,
    129
  ],
  "EFI_TIME_VARIABLE_GUID": [
    2634916713,
    21515,
    18168,
    133,
    160,
    43,
    95,
    44,
    48,
    30,
    21
  ],
  "EFI_TPM_STATE_INIT_HUB_GUID": [
    2697386264,
    36334,
    16827,
    157,
    146,
    103,
    83,
    165,
    114,
    182,
    82
  ],
  "EFI_TXT_INFO_PROTOCOL_GUID": [
    1611796956,
    2834,
    19465,
    174,
    39,
    171,
    14,
    201,
    105,
    36,
    104
  ],
  "EFI_UDP4_PROTOCOL_GUID": [
    987356969,
    17665,
    18317,
    177,
    248,
    127,
    127,
    231,
    14,
    80,
    243
  ],
  "EFI_UDP4_SERVICE_BINDING_PROTOCOL_GUID": [
    2213549156,
    39357,
    17893,
    179,
    131,
    175,
    99,
    5,
    216,
    233,
    230
  ],
  "EFI_UDP_PROTOCOL_GUID": [
    3312431538,
    379,
    18820,
    163,
    246,
    63,
    115,
    79,
    250,
    158,
    51
  ],
  "EFI_UGA_DRAW_PROTOCOL_GUID": [
    2553031051,
    62714,
    16843,
    184,
    56,
    119,
    170,
    104,
    143,
    184,
    57
  ],
  "EFI_UGA_IO_PROTOCOL_GUID": [
    1638192286,
    28520,
    20251,
    185,
    34,
    168,
    110,
    237,
    11,
    7,
    162
  ],
  "EFI_UGA_SPLASH_PROTOCOL_GUID": [
    2757442061,
    11861,
    19459,
    173,
    156,
    39,
    212,
    130,
    11,
    80,
    126
  ],
  "EFI_UNICODE_COLLATION2_PROTOCOL_GUID": [
    2764526076,
    9134,
    19518,
    146,
    233,
    73,
    100,
    207,
    99,
    243,
    73
  ],
  "EFI_UNICODE_COLLATION_PROTOCOL_GUID": [
    495308159,
    62525,
    4562,
    154,
    12,
    0,
    144,
    39,
    63,
    193,
    77
  ],
  "EFI_USB2_HC_PROTOCOL_GUID": [
    1047810598,
    38936,
    17846,
    162,
    172,
    215,
    205,
    14,
    139,
    162,
    188
  ],
  "EFI_USB_ATAPI_PROTOCOL_GUID": [
    724527322,
    3282,
    17615,
    142,
    139,
    187,
    162,
    11,
    27,
    91,
    117
  ],
  "EFI_USB_HC_PROTOCOL_GUID": [
    4110979686,
    6816,
    18771,
    151,
    216,
    86,
    47,
    138,
    115,
    181,
    25
  ],
  "EFI_USB_IO_PROTOCOL_GUID": [
    724527318,
    3282,
    17615,
    142,
    139,
    187,
    162,
    11,
    27,
    91,
    117
  ],
  "EFI_USB_POLICY_PROTOCOL_GUID": [
    1482279798,
    27631,
    18058,
    190,
    45,
    179,
    221,
    26,
    39,
    240,
    18
  ],
  "EFI_USB_PROTOCOL_GUID": [
    718856914,
    11921,
    19665,
    149,
    245,
    231,
    143,
    229,
    235,
    227,
    22
  ],
  "EFI_USER_CREDENTIAL_PROTOCOL_GUID": [
    1911447188,
    26041,
    17877,
    130,
    26,
    58,
    77,
    134,
    207,
    230,
    190
  ],
  "EFI_USER_INFO_ACCESS_SETUP_ADMIN_GUID": [
    2243384839,
    63438,
    18206,
    183,
    228,
    42,
    234,
    95,
    114,
    50,
    238
  ],
  "EFI_USER_INFO_ACCESS_SETUP_NORMAL_GUID": [
    498244320,
    40395,
    17340,
    141,
    135,
    93,
    161,
    73,
    100,
    221,
    226
  ],
  "EFI_USER_INFO_ACCESS_SETUP_RESTRICTED_GUID": [
    3182657829,
    19811,
    18932,
    130,
    18,
    97,
    207,
    90,
    25,
    10,
    248
  ],
  "EFI_USER_MANAGER_PROTOCOL_GUID": [
    1876275212,
    54310,
    17027,
    152,
    135,
    108,
    245,
    207,
    28,
    177,
    254
  ],
  "EFI_VARIABLE_ARCH_PROTOCOL_GUID": [
    508979426,
    33921,
    4564,
    188,
    241,
    0,
    128,
    199,
    60,
    136,
    129
  ],
  "EFI_VARIABLE_STORE_PROTOCOL_GUID": [
    4035497361,
    41030,
    4562,
    142,
    66,
    0,
    160,
    201,
    105,
    114,
    59
  ],
  "EFI_VARIABLE_WRITE_ARCH_PROTOCOL_GUID": [
    1682044952,
    25442,
    20036,
    181,
    112,
    125,
    186,
    49,
    221,
    36,
    83
  ],
  "EFI_VGA_MINI_PORT_PROTOCOL_GUID": [
    3346225711,
    35061,
    18562,
    174,
    99,
    250,
    172,
    140,
    139,
    134,
    179
  ],
  "EFI_VIRTUAL_MEMORY_ACCESS_PROTOCOL_GUID": [
    1952266106,
    47496,
    18354,
    177,
    143,
    187,
    200,
    13,
    197,
    102,
    152
  ],
  "EFI_VT_100_GUID": [
    3752222821,
    46105,
    4563,
    154,
    45,
    0,
    144,
    39,
    63,
    193,
    77
  ],
  "EFI_VT_100_PLUS_GUID": [
    2075051787,
    22496,
    19574,
    142,
    135,
    47,
    158,
    40,
    8,
    131,
    67
  ],
  "EFI_VT_UTF8_GUID": [
    2903875798,
    35820,
    19151,
    160,
    115,
    208,
    29,
    231,
    126,
    45,
    136
  ],
  "EFI_WATCHDOG_TIMER_ARCH_PROTOCOL_GUID": [
    1717452789,
    18124,
    4564,
    154,
    56,
    0,
    144,
    39,
    63,
    193,
    77
  ],
  "ERROR_MANAGER_GUID": [
    2917056386,
    42336,
    18105,
    162,
    128,
    120,
    198,
    171,
    97,
    174,
    218
  ],
  "EXIT_FORM_SET_GUID": [
    2755331036,
    49546,
    16817,
    145,
    200,
    63,
    249,
    170,
    162,
    87,
    19
  ],
  "FAST_BOOT_TSE_PROTOCOL_GUID": [
    263865272,
    44251,
    20194,
    171,
    49,
    15,
    164,
    213,
    182,
    195,
    197
  ],
  "FAST_BOOT_VARIABLE_GUID": [
    3040912688,
    27000,
    19879,
    145,
    203,
    114,
    7,
    215,
    100,
    210,
    98
  ],
  "FID_TABLE_GUID": [
    1070715810,
    39415,
    16907,
    188,
    105,
    139,
    177,
    212,
    146,
    163,
    50
  ],
  "FID_TABLE_SECTION_GUID": [
    784204405,
    25688,
    19193,
    145,
    237,
    211,
    244,
    237,
    177,
    0,
    170
  ],
  "FIRMWARE_PERFORMANCE_PROTOCOL_GUID": [
    3158388085,
    10025,
    19514,
    177,
    147,
    91,
    154,
    88,
    143,
    246,
    111
  ],
  "FLASH_UPDATE_GUID": [
    2537697749,
    60747,
    17617,
    136,
    112,
    206,
    81,
    92,
    193,
    77,
    104
  ],
  "FONT_FFS_FILE_GUID": [
    3670192407,
    46587,
    18788,
    163,
    18,
    13,
    204,
    119,
    6,
    27,
    155
  ],
  "FPDT_PERFORMANCE_PROTOCOL_GUID": [
    1145844227,
    63665,
    17063,
    171,
    233,
    46,
    88,
    2,
    91,
    225,
    42
  ],
  "FW_VERSION_GUID": [
    3049623687,
    65196,
    19265,
    157,
    128,
    121,
    11,
    165,
    170,
    7,
    15
  ],
  "HOT_PLUG_DEVICE_GUID": [
    571130930,
    7491,
    18917,
    167,
    79,
    76,
    157,
    166,
    122,
    210,
    59
  ],
  "ICC_OVERCLOCKING_PROTOCOL_GUID": [
    2391587928,
    33612,
    16867,
    184,
    202,
    240,
    12,
    207,
    90,
    113,
    124
  ],
  "ICC_PERSISTENT_DATA_GUID": [
    1679371722,
    53300,
    18898,
    166,
    222,
    101,
    168,
    41,
    235,
    76,
    116
  ],
  "ICC_VOLATILE_SETUP_DATA_GUID": [
    2071460747,
    7693,
    19838,
    149,
    63,
    57,
    128,
    162,
    97,
    224,
    119
  ],
  "IDE_BUS_DRIVER_BINDING_PROTOCOL_GUID": [
    2326163569,
    35820,
    18347,
    131,
    200,
    205,
    14,
    183,
    35,
    208,
    114
  ],
  "IDE_CONTROLLER_PROTOCOL_GUID": [
    551716743,
    57138,
    19418,
    183,
    231,
    203,
    189,
    163,
    55,
    30,
    248
  ],
  "IDE_SECURITY_PWNV_GUID": [
    1771469452,
    4441,
    17698,
    170,
    137,
    116,
    205,
    198,
    229,
    153,
    160
  ],
  "IDE_SETUP_PROTOCOL_GUID": [
    1433972246,
    61897,
    20111,
    177,
    41,
    186,
    7,
    248,
    252,
    248,
    74
  ],
  "IFFS_ACPI_TABLE_STORAGE_GUID": [
    1621899919,
    19814,
    19668,
    137,
    90,
    195,
    240,
    110,
    102,
    101,
    238
  ],
  "IFFS_GLOBAL_NVS_AREA_PROTOCOL_GUID": [
    2773851910,
    25621,
    18265,
    136,
    105,
    222,
    21,
    249,
    205,
    156,
    155
  ],
  "IFFS_GPT_GUID": [
    3552568030,
    15791,
    4575,
    186,
    64,
    227,
    165,
    86,
    216,
    149,
    147
  ],
  "IFFS_INFO_PROTOCOL_GUID": [
    3526482779,
    19100,
    16530,
    168,
    197,
    156,
    160,
    188,
    125,
    106,
    166
  ],
  "IFFS_PARTITION_STATUS_PROTOCOL_GUID": [
    1701024068,
    54418,
    17192,
    164,
    152,
    244,
    181,
    84,
    94,
    74,
    48
  ],
  "IFFS_PERSISTENT_DATA_GUID": [
    4193300785,
    62278,
    20246,
    128,
    221,
    249,
    65,
    7,
    43,
    58,
    125
  ],
  "IFFS_PLATFORM_POLICY_PROTOCOL_GUID": [
    1119595683,
    29025,
    18577,
    172,
    16,
    199,
    94,
    46,
    77,
    246,
    20
  ],
  "IFFS_PPI_GUID": [
    1024353850,
    56434,
    17545,
    135,
    197,
    228,
    158,
    231,
    115,
    164,
    82
  ],
  "INTEL_MEBX_PROTOCOL_GUID": [
    27990057,
    52941,
    19706,
    161,
    140,
    234,
    117,
    214,
    111,
    62,
    116
  ],
  "MAIN_FORM_SET_GUID": [
    2556358289,
    48300,
    16952,
    135,
    120,
    87,
    239,
    220,
    147,
    242,
    78
  ],
  "MDES_STATUS_CODE_PROTOCOL_GUID": [
    3855648602,
    63047,
    19990,
    190,
    77,
    149,
    2,
    64,
    41,
    204,
    68
  ],
  "MEBX_FILE_GUID": [
    2088879722,
    20241,
    18347,
    130,
    211,
    103,
    196,
    214,
    53,
    174,
    209
  ],
  "MEM_INFO_PROTOCOL_GUID": [
    1864431560,
    58863,
    20257,
    141,
    25,
    237,
    197,
    240,
    196,
    150,
    174
  ],
  "MEUD_ERROR_GUID": [
    120765753,
    54960,
    16441,
    182,
    194,
    150,
    84,
    70,
    109,
    229,
    37
  ],
  "MEUD_FILE_GUID": [
    4272596902,
    52117,
    18032,
    180,
    153,
    135,
    127,
    166,
    202,
    107,
    174
  ],
  "ME_ALERT_AT_HANDLER_GUID": [
    3024215943,
    36244,
    18449,
    133,
    247,
    15,
    154,
    123,
    248,
    157,
    42
  ],
  "ME_BIOS_PAYLOAD_DATA_PROTOCOL_GUID": [
    1906414740,
    10934,
    20118,
    133,
    129,
    207,
    52,
    37,
    66,
    115,
    254
  ],
  "ME_INFO_SETUP_GUID": [
    2015728691,
    31597,
    19891,
    154,
    232,
    54,
    196,
    194,
    195,
    161,
    125
  ],
  "ME_PLATFORM_GET_RESET_TYPE_GUID": [
    3100495575,
    48580,
    17508,
    154,
    26,
    255,
    63,
    189,
    247,
    72,
    105
  ],
  "MICROCODE_LOADER_PPI_GUID": [
    2607738102,
    64476,
    19894,
    149,
    98,
    210,
    95,
    64,
    213,
    118,
    97
  ],
  "MINI_SETUP_RESOURCE_SECTION_GUID": [
    2548304358,
    19649,
    4569,
    129,
    246,
    0,
    0,
    0,
    0,
    0,
    0
  ],
  "MXM30_PEI_GUID": [
    787593754,
    51254,
    19024,
    191,
    137,
    82,
    95,
    242,
    159,
    247,
    135
  ],
  "MXM3_EFI_GUID": [
    1319752958,
    59126,
    16651,
    144,
    55,
    15,
    152,
    181,
    150,
    139,
    101
  ],
  "MXMOEM1_GUID": [
    1728533358,
    18095,
    17107,
    143,
    108,
    21,
    242,
    242,
    2,
    194,
    52
  ],
  "NBCI_EFI_GUID": [
    1319752958,
    59126,
    16651,
    128,
    55,
    15,
    152,
    181,
    150,
    139,
    101
  ],
  "NVRAM_MAILBOX_ADDRESS_VARIABLE_GUID": [
    1418803821,
    62702,
    19675,
    132,
    117,
    116,
    6,
    43,
    252,
    236,
    245
  ],
  "OEM_RECOVERY_CAPSULE_GUID": [
    1499098844,
    27948,
    18250,
    144,
    130,
    59,
    153,
    40,
    81,
    223,
    254
  ],
  "OEM_ROM_HOLE_0_GUID": [
    97124860,
    4033,
    4572,
    144,
    17,
    0,
    23,
    49,
    83,
    235,
    168
  ],
  "OEM_ROM_HOLE_1_GUID": [
    97124861,
    4033,
    4572,
    144,
    17,
    0,
    23,
    49,
    83,
    235,
    168
  ],
  "OPROM_START_END_PROTOCOL_GUID": [
    4070648063,
    9595,
    17774,
    157,
    232,
    99,
    231,
    199,
    220,
    223,
    172
  ],
  "PARTITION_VARIABLE_GUID": [
    2377554380,
    48257,
    16866,
    170,
    198,
    216,
    29,
    83,
    0,
    215,
    89
  ],
  "PASSWORD_HOB_GUID": [
    2043545978,
    37290,
    16895,
    179,
    168,
    83,
    69,
    89,
    179,
    13,
    177
  ],
  "PCH_DMI_TC_VC_PPI_GUID": [
    3976819538,
    36929,
    17498,
    128,
    182,
    178,
    157,
    80,
    158,
    136,
    69
  ],
  "PCH_EFI_RAID_DRIVER_EXECUTION_GUID": [
    2580903292,
    55558,
    4576,
    141,
    120,
    141,
    228,
    72,
    36,
    1,
    155
  ],
  "PCH_INIT_PPI_GUID": [
    166365514,
    48653,
    16944,
    160,
    3,
    237,
    198,
    147,
    180,
    142,
    149
  ],
  "PCH_INIT_VARIABLE_GUID": [
    3871536906,
    46596,
    18551,
    133,
    186,
    222,
    236,
    137,
    225,
    23,
    235
  ],
  "PCH_ME_UMA_PPI_GUID": [
    2352439312,
    9216,
    19837,
    180,
    123,
    157,
    133,
    29,
    243,
    201,
    209
  ],
  "PCH_PLATFORM_POLICY_PPI_GUID": [
    355747443,
    54117,
    19426,
    133,
    19,
    20,
    151,
    204,
    7,
    97,
    29
  ],
  "PCH_RESET_CALLBACK_PROTOCOL_GUID": [
    976421035,
    51497,
    18557,
    171,
    52,
    21,
    155,
    193,
    53,
    98,
    192
  ],
  "PCH_RESET_PROTOCOL_GUID": [
    3680721196,
    47308,
    17608,
    145,
    140,
    81,
    245,
    52,
    89,
    138,
    90
  ],
  "PCH_SATA_CONTROLLER_DRIVER_GUID": [
    3146948009,
    26871,
    16437,
    178,
    44,
    163,
    187,
    63,
    35,
    218,
    85
  ],
  "PCH_USB_POLICY_PPI_GUID": [
    3224044915,
    11086,
    18993,
    163,
    26,
    148,
    86,
    123,
    80,
    68,
    44
  ],
  "PEI_AMT_PLATFORM_POLICY_PPI_GUID": [
    3030458510,
    19866,
    20130,
    157,
    107,
    228,
    26,
    97,
    230,
    197,
    172
  ],
  "PEI_AMT_STATUS_CODE_PPI_GUID": [
    2283276242,
    39121,
    20169,
    175,
    160,
    119,
    70,
    196,
    47,
    36,
    73
  ],
  "PEI_AP_STARTUP_FILE_GUID": [
    3521486672,
    59587,
    17733,
    191,
    97,
    17,
    240,
    2,
    35,
    60,
    151
  ],
  "PEI_ATA_CONTROLLER_PPI_GUID": [
    2757648593,
    50969,
    17578,
    176,
    122,
    170,
    119,
    127,
    133,
    144,
    109
  ],
  "PEI_ATA_POLICY_PPI_GUID": [
    462282404,
    57010,
    16722,
    145,
    194,
    183,
    60,
    177,
    108,
    228,
    100
  ],
  "PEI_BIOS_ACM_FILE_GUID": [
    757581336,
    32205,
    16885,
    187,
    16,
    33,
    22,
    107,
    231,
    225,
    67
  ],
  "PEI_BLOCK_IO_PPI_GUID": [
    3160385104,
    60859,
    19725,
    179,
    163,
    217,
    137,
    7,
    248,
    71,
    223
  ],
  "PEI_BOOT_SCRIPT_DONE_PPI_GUID": [
    4252780133,
    13502,
    17003,
    177,
    248,
    58,
    183,
    83,
    206,
    68,
    176
  ],
  "PEI_CACHE_PPI_GUID": [
    3243450458,
    59544,
    19492,
    134,
    137,
    164,
    180,
    188,
    197,
    200,
    162
  ],
  "PEI_CPU_PLATFORM_POLICY_PPI_GUID": [
    2072962977,
    20021,
    17750,
    187,
    86,
    103,
    151,
    226,
    68,
    69,
    194
  ],
  "PEI_FLASH_MAP_PPI_GUID": [
    4081856416,
    56968,
    17008,
    132,
    20,
    150,
    18,
    34,
    244,
    82,
    28
  ],
  "PEI_HECI_PPI_GUID": [
    3993937937,
    64473,
    18295,
    185,
    90,
    186,
    79,
    113,
    16,
    31,
    116
  ],
  "PEI_IDE_RECOVERY_NATIVE_MODE_PPI_GUID": [
    2115199866,
    50168,
    17361,
    176,
    81,
    237,
    25,
    215,
    8,
    236,
    122
  ],
  "PEI_IFFS_TRANSITION_START_PPI_GUID": [
    3733923960,
    14037,
    18830,
    186,
    89,
    22,
    140,
    38,
    71,
    179,
    53
  ],
  "PEI_IN_MEMORY_GUID": [
    1681622918,
    46103,
    18642,
    143,
    94,
    120,
    25,
    147,
    28,
    174,
    216
  ],
  "PEI_PLATFORM_MEMORY_RANGE_PPI_GUID": [
    820717945,
    45303,
    19808,
    178,
    220,
    26,
    44,
    150,
    206,
    177,
    244
  ],
  "PEI_PLATFORM_MEMORY_SIZE_PPI_GUID": [
    2592011294,
    49472,
    19409,
    184,
    132,
    30,
    17,
    36,
    11,
    76,
    230
  ],
  "PEI_SMBUS_POLICY_PPI_GUID": [
    1672930357,
    12988,
    18886,
    129,
    189,
    183,
    161,
    160,
    254,
    26,
    108
  ],
  "PEI_SPI_PPI_GUID": [
    2743888024,
    11100,
    20470,
    147,
    38,
    46,
    99,
    33,
    46,
    86,
    194
  ],
  "PEI_STATUS_CODE_MEMORY_PPI_GUID": [
    653830913,
    54221,
    18588,
    152,
    79,
    223,
    222,
    247,
    104,
    57,
    91
  ],
  "PEI_TCG_INTERNAL_FLAGS_GUID": [
    1895821567,
    42307,
    17849,
    139,
    227,
    27,
    219,
    144,
    65,
    32,
    128
  ],
  "PEI_TCG_PPI_GUID": [
    394082770,
    17336,
    16584,
    154,
    225,
    60,
    81,
    152,
    214,
    148,
    30
  ],
  "PEI_TPM_INITIALIZED_PPI_GUID": [
    3923447128,
    54413,
    18422,
    156,
    110,
    111,
    64,
    232,
    108,
    123,
    65
  ],
  "PEI_TPM_PPI_2_GUID": [
    3393737716,
    59723,
    17076,
    134,
    66,
    205,
    226,
    138,
    127,
    172,
    45
  ],
  "PEI_TXT_MEMORY_UNLOCKED_PPI_GUID": [
    953012491,
    30333,
    20334,
    167,
    68,
    103,
    238,
    29,
    254,
    47,
    165
  ],
  "PEI_USB_CONTROLLER_PPI_GUID": [
    1002567390,
    26942,
    17735,
    163,
    0,
    33,
    130,
    60,
    164,
    32,
    178
  ],
  "PERF_TUNE_PPI_GUID": [
    3297872371,
    7500,
    19159,
    164,
    57,
    208,
    19,
    171,
    114,
    9,
    49
  ],
  "PERF_TUNE_PROTOCOL_GUID": [
    3714867514,
    23159,
    19279,
    166,
    30,
    59,
    221,
    42,
    226,
    29,
    129
  ],
  "PERF_TUNE_WDT_PPI_GUID": [
    2814939054,
    60396,
    17901,
    167,
    197,
    95,
    167,
    85,
    23,
    115,
    6
  ],
  "PERF_TUNE_WDT_PROTOCOL_GUID": [
    3226828525,
    39561,
    18288,
    150,
    38,
    252,
    160,
    81,
    242,
    186,
    9
  ],
  "PKPUB_KEY_GUID": [
    2797658398,
    37534,
    17075,
    144,
    204,
    79,
    119,
    142,
    3,
    255,
    87
  ],
  "PK_PUB_FFS_FILE_EFI_AUTH_VAR_GUID": [
    2657245735,
    18496,
    18380,
    166,
    181,
    30,
    147,
    17,
    207,
    198,
    14
  ],
  "PLATFORM_ME_HOOK_PPI_GUID": [
    3892724303,
    54309,
    19226,
    188,
    38,
    95,
    105,
    3,
    137,
    161,
    90
  ],
  "POWER_MANAGEMENT_ACPI_TABLE_STORAGE_GUID": [
    370926999,
    59845,
    18907,
    174,
    80,
    196,
    98,
    171,
    84,
    238,
    218
  ],
  "PPM_PLATFORM_POLICY_PROTOCOL_GUID": [
    3719036588,
    61283,
    17708,
    143,
    57,
    237,
    127,
    174,
    216,
    38,
    94
  ],
  "PPM_PROCESSOR_SUPPORT_PROTOCOL_3_GUID": [
    2785836493,
    20783,
    20226,
    177,
    128,
    82,
    46,
    1,
    94,
    6,
    183
  ],
  "PR_KEY_FFS_FILE_RAW_GUID": [
    1072613458,
    61772,
    20095,
    151,
    253,
    76,
    58,
    140,
    91,
    190,
    204
  ],
  "PR_KEY_GUID": [
    1309645780,
    58168,
    19238,
    132,
    62,
    189,
    58,
    217,
    178,
    131,
    123
  ],
  "PTID_FFS_TABLE_STORAGE_GUID": [
    2514471653,
    47912,
    19819,
    177,
    226,
    58,
    243,
    166,
    191,
    67,
    79
  ],
  "RECOVERY_FORM_SET_GUID": [
    2162237486,
    9879,
    16996,
    156,
    201,
    128,
    118,
    44,
    62,
    88,
    99
  ],
  "ROM_CACHE_ENABLE_PPI_GUID": [
    921187771,
    26141,
    19767,
    141,
    229,
    136,
    83,
    37,
    218,
    233,
    16
  ],
  "ROM_IMAGE_ADDRESS_GUID": [
    3722558578,
    54366,
    16905,
    171,
    133,
    20,
    70,
    45,
    47,
    80,
    116
  ],
  "ROM_IMAGE_MEMORY_HOB_GUID": [
    3996075474,
    23460,
    17438,
    138,
    29,
    170,
    34,
    223,
    163,
    182,
    197
  ],
  "ROM_LAYOUT_FFS_GUID": [
    231373114,
    60054,
    17112,
    189,
    123,
    220,
    127,
    104,
    78,
    56,
    193
  ],
  "ROM_LAYOUT_SECTION_GUID": [
    2292275791,
    38781,
    18050,
    177,
    124,
    218,
    31,
    49,
    108,
    31,
    50
  ],
  "RSDP_PLUS_PROTOCOL_GUID": [
    2738035125,
    36577,
    17888,
    140,
    159,
    128,
    159,
    91,
    9,
    2,
    204
  ],
  "SA_PEG_DATA_HOB_GUID": [
    1599943938,
    35403,
    16586,
    136,
    162,
    35,
    5,
    66,
    122,
    19,
    26
  ],
  "SA_PEG_DATA_VARIABLE_GUID": [
    3298251264,
    25841,
    20406,
    151,
    115,
    246,
    169,
    248,
    157,
    152,
    94
  ],
  "SA_PLATFORM_POLICY_PPI_GUID": [
    353166358,
    61027,
    18102,
    139,
    163,
    115,
    34,
    187,
    224,
    70,
    55
  ],
  "SECURITY_FORM_SET_GUID": [
    2552031982,
    37660,
    18967,
    185,
    200,
    102,
    199,
    188,
    253,
    119,
    225
  ],
  "SERIAL_RECOVERY_CAPSULE_GUID": [
    1771756912,
    34132,
    18835,
    131,
    246,
    210,
    205,
    192,
    129,
    221,
    133
  ],
  "SETUP_DEFAULTS_FFS_GUID": [
    2451648859,
    12475,
    18101,
    129,
    62,
    27,
    27,
    244,
    113,
    43,
    211
  ],
  "SETUP_GUID": [
    3346911490,
    7604,
    18839,
    174,
    55,
    78,
    140,
    82,
    30,
    245,
    103
  ],
  "SGOEM_ACPI_SSDT_GUID": [
    1529028742,
    13578,
    17095,
    167,
    14,
    52,
    151,
    181,
    118,
    93,
    133
  ],
  "SGTPV_ACPI_SSDT_GUID": [
    1778782483,
    65108,
    18951,
    162,
    142,
    10,
    105,
    53,
    158,
    176,
    105
  ],
  "SG_ACPI_TABLE_STORAGE_GUID": [
    3402315799,
    33254,
    18814,
    135,
    255,
    200,
    250,
    143,
    36,
    236,
    40
  ],
  "SG_INFO_HOB_GUID": [
    1686954107,
    44637,
    18803,
    189,
    60,
    140,
    145,
    83,
    192,
    93,
    197
  ],
  "SG_PEI_INIT_PPI_GUID": [
    2856374286,
    23451,
    19885,
    164,
    135,
    252,
    27,
    203,
    239,
    129,
    112
  ],
  "SG_PLATFORM_POLICY_PPI_GUID": [
    2744248354,
    28740,
    19700,
    190,
    91,
    52,
    94,
    68,
    184,
    98,
    124
  ],
  "SIO_DEV_STATUS_VAR_GUID": [
    1478549144,
    64654,
    19211,
    164,
    185,
    10,
    148,
    13,
    22,
    42,
    126
  ],
  "SIO_IO_PROTOCOL_GUID": [
    2521717537,
    24576,
    9170,
    158,
    57,
    1,
    160,
    201,
    105,
    114,
    59
  ],
  "SMBIOS_FLASH_DATA_FFS_GUID": [
    4249125387,
    61867,
    16832,
    174,
    78,
    12,
    85,
    85,
    110,
    185,
    189
  ],
  "SMM_CHILD_DISPATCHER2_GUID": [
    2500606502,
    57538,
    18716,
    182,
    178,
    3,
    116,
    245,
    199,
    59,
    150
  ],
  "SMM_COMMUNICATE_HEADER_GUID": [
    4079543148,
    9142,
    19093,
    133,
    75,
    50,
    225,
    149,
    52,
    205,
    117
  ],
  "SMM_HECI_PROTOCOL_GUID": [
    2187863222,
    52379,
    19810,
    142,
    122,
    15,
    251,
    246,
    1,
    60,
    190
  ],
  "SMRAM_CPU_DATA_HEADER_GUID": [
    1481178413,
    54959,
    18251,
    130,
    117,
    149,
    221,
    231,
    10,
    232,
    35
  ],
  "SMRAM_CPU_DATA_VARIABLE_GUID": [
    1117061593,
    58439,
    16628,
    134,
    123,
    117,
    201,
    58,
    29,
    181,
    78
  ],
  "SM_BUS_CONTROLLER_IDENTIFIER_GUID": [
    2284791110,
    61215,
    16528,
    159,
    156,
    147,
    132,
    90,
    215,
    132,
    28
  ],
  "SYSTEM_ACCESS_GUID": [
    3882924905,
    48308,
    19716,
    158,
    151,
    35,
    255,
    148,
    86,
    254,
    172
  ],
  "TCG_EFI_ACPI_TABLE_GUID": [
    3952946480,
    11656,
    4563,
    154,
    22,
    0,
    144,
    39,
    63,
    193,
    77
  ],
  "TCG_EFI_HOB_LIST_GUID": [
    2000286284,
    37847,
    4564,
    154,
    58,
    0,
    144,
    39,
    63,
    193,
    77
  ],
  "TCG_LOCK_DOWN_VAR_GUID": [
    1851807030,
    41738,
    19798,
    147,
    158,
    28,
    55,
    63,
    121,
    141,
    123
  ],
  "TCG_PLATFORM_SETUP_PEI_POLICY_GUID": [
    2808827426,
    46346,
    16413,
    139,
    53,
    81,
    36,
    176,
    186,
    65,
    4
  ],
  "TCG_PLATFORM_SETUP_POLICY_GUID": [
    3144466175,
    57458,
    16594,
    166,
    235,
    186,
    183,
    91,
    222,
    135,
    231
  ],
  "TCG_PPI_SYNC_FLAG_GUID": [
    4092433887,
    33422,
    16839,
    188,
    160,
    22,
    196,
    25,
    101,
    166,
    52
  ],
  "TDTHI_PROTOCOL_FIXED_GUID": [
    4203697640,
    43810,
    17117,
    185,
    22,
    125,
    206,
    57,
    0,
    37,
    116
  ],
  "TDTHI_PROTOCOL_GUID": [
    1011372758,
    54395,
    20294,
    176,
    94,
    181,
    237,
    193,
    170,
    67,
    10
  ],
  "TDT_VOLATILE_SETUP_DATA_GUID": [
    2071460747,
    7693,
    19838,
    149,
    63,
    57,
    128,
    162,
    97,
    224,
    118
  ],
  "TPM_BOOT_FLOW_VARIABLE_GUID": [
    3058043465,
    2753,
    18511,
    174,
    88,
    241,
    110,
    178,
    57,
    219,
    61
  ],
  "TXT_INFO_HOB_GUID": [
    696682559,
    35040,
    18640,
    75,
    130,
    32,
    194,
    105,
    72,
    221,
    172
  ],
  "TXT_ONE_TOUCH_GUID": [
    1033409649,
    53164,
    18103,
    155,
    28,
    8,
    67,
    1,
    9,
    64,
    45
  ],
  "TXT_ONE_TOUCH_OP_PROTOCOL_GUID": [
    4196612269,
    32991,
    18896,
    147,
    150,
    207,
    113,
    69,
    208,
    58,
    118
  ],
  "USB_TIMING_POLICY_PROTOCOL_GUID": [
    2313404892,
    46563,
    19764,
    174,
    173,
    221,
    126,
    178,
    130,
    140,
    24
  ],
  "USER_DEFAULTS_GUID": [
    3301707240,
    1671,
    17442,
    153,
    193,
    101,
    53,
    26,
    93,
    95,
    149
  ],
  "WDT_APP_PROTOCOL_GUID": [
    2462568635,
    26526,
    18333,
    135,
    141,
    212,
    184,
    41,
    104,
    87,
    139
  ],
  "WDT_HOB_GUID": [
    1701271430,
    44234,
    19217,
    138,
    183,
    248,
    67,
    170,
    42,
    139,
    234
  ],
  "WDT_PERSISTENT_DATA_GUID": [
    2026775380,
    53180,
    17987,
    174,
    186,
    7,
    162,
    127,
    168,
    146,
    191
  ],
  "WDT_PPI_GUID": [
    4086108984,
    44922,
    20406,
    145,
    219,
    26,
    156,
    33,
    131,
    87,
    13
  ],
  "WDT_PROTOCOL_GUID": [
    3022753042,
    10955,
    18842,
    169,
    32,
    221,
    91,
    230,
    207,
    9,
    177
  ],
  "ASROCK_ACPIS4_DXE_GUID": [
    69196166,
    45078,
    18382,
    175,
    197,
    34,
    105,
    237,
    212,
    173,
    100
  ],
  "ASROCK_USBRT_GUID": [
    82487969,
    10657,
    4567,
    136,
    56,
    0,
    80,
    4,
    115,
    212,
    235
  ],
  "ASROCK_RAID_SETUP_GUID": [
    152494882,
    14144,
    12750,
    173,
    98,
    189,
    23,
    44,
    236,
    202,
    54
  ],
  "ASROCK_RAID_LOADER_GUID": [
    164506669,
    19843,
    17592,
    151,
    208,
    16,
    133,
    235,
    84,
    144,
    184
  ],
  "ASROCK_SIOSLPSMI_GUID": [
    204970154,
    53806,
    19926,
    140,
    180,
    60,
    156,
    251,
    29,
    134,
    211
  ],
  "ASROCK_PLEDDXE_GUID": [
    260599413,
    12329,
    20175,
    182,
    148,
    34,
    137,
    77,
    63,
    33,
    67
  ],
  "ASROCK_A_DEFAULT_DXE_GUID": [
    303480106,
    49246,
    19565,
    145,
    231,
    235,
    142,
    55,
    173,
    59,
    122
  ],
  "ASROCK_USER_DEF_SETUP_DXE_GUID": [
    321832763,
    48422,
    20415,
    177,
    147,
    138,
    203,
    80,
    239,
    189,
    137
  ],
  "ASROCK_WAKEUP_CTRL_SMM_GUID": [
    460234064,
    4836,
    19285,
    129,
    217,
    26,
    191,
    236,
    89,
    212,
    252
  ],
  "ASROCK_AMI_AGESA_DXE_GUID": [
    503020538,
    49038,
    19729,
    151,
    102,
    47,
    176,
    208,
    68,
    35,
    16
  ],
  "ASROCK_HDD_READY_SMI_GUID": [
    560462180,
    29336,
    19087,
    154,
    42,
    191,
    228,
    152,
    214,
    0,
    168
  ],
  "ASROCK_MOUSE_DRIVER_GUID": [
    719032155,
    51156,
    20094,
    190,
    42,
    35,
    99,
    77,
    246,
    104,
    161
  ],
  "ASROCK_IDESMM_GUID": [
    829100592,
    1280,
    17810,
    140,
    9,
    234,
    186,
    15,
    182,
    176,
    127
  ],
  "ASROCK_BFGSMI_GUID": [
    978522445,
    22131,
    19929,
    181,
    179,
    203,
    114,
    195,
    71,
    102,
    155
  ],
  "ASROCK_ASRLOGODXE_GUID": [
    1033880909,
    6629,
    19152,
    185,
    134,
    2,
    214,
    135,
    215,
    96,
    229
  ],
  "ASROCK_ASM104_X_DXE_GUID": [
    1080004582,
    21011,
    19333,
    184,
    33,
    151,
    183,
    122,
    255,
    121,
    91
  ],
  "ASROCK_HDAUDIO_SMI_GUID": [
    1254707048,
    58961,
    19256,
    161,
    216,
    45,
    93,
    239,
    250,
    15,
    96
  ],
  "ASROCK_SM_BUS_DXE_GUID": [
    1265110573,
    3427,
    20322,
    185,
    48,
    122,
    233,
    149,
    185,
    179,
    163
  ],
  "ASROCK_USBINT13_GUID": [
    1275096281,
    6586,
    17943,
    132,
    131,
    96,
    145,
    148,
    161,
    172,
    252
  ],
  "ASROCK_SLP_SUPPORT_GUID": [
    1279872597,
    22601,
    21314,
    69,
    84,
    84,
    69,
    82,
    33,
    33,
    33
  ],
  "ASROCK_PATA_CONTROLLER_GUID": [
    1334921163,
    38702,
    20316,
    184,
    105,
    160,
    33,
    130,
    201,
    217,
    60
  ],
  "ASROCK_SATA_CONTROLLER_GUID": [
    1359869601,
    46785,
    18760,
    174,
    231,
    89,
    242,
    32,
    248,
    152,
    189
  ],
  "ASROCK_ACPIS4_SMM_GUID": [
    1368992111,
    10248,
    19194,
    148,
    196,
    153,
    246,
    176,
    108,
    135,
    30
  ],
  "ASROCK_POST_REPORT_GUID": [
    1413923475,
    13211,
    18381,
    183,
    25,
    88,
    93,
    227,
    148,
    8,
    204
  ],
  "ASROCK_CLOCK_GEN_DXE_GUID": [
    1447053695,
    25694,
    17937,
    185,
    21,
    230,
    130,
    200,
    189,
    71,
    131
  ],
  "ASROCK_UHCD_GUID": [
    1477302528,
    14429,
    4567,
    136,
    58,
    0,
    80,
    4,
    115,
    212,
    235
  ],
  "ASROCK_LEGACY_REGION_GUID": [
    1495543256,
    59343,
    18809,
    182,
    14,
    166,
    6,
    126,
    42,
    24,
    95
  ],
  "ASROCK_SLEEP_SMI_GUID": [
    1654193688,
    54767,
    17079,
    187,
    12,
    41,
    83,
    40,
    63,
    87,
    4
  ],
  "ASROCK_CMOS_MANAGER_SMM_GUID": [
    1751762355,
    44173,
    18803,
    139,
    55,
    227,
    84,
    219,
    243,
    74,
    221
  ],
  "ASROCK_AMD_AGESA_DXE_DRIVER_GUID": [
    1766895615,
    28387,
    4573,
    173,
    139,
    8,
    0,
    32,
    12,
    154,
    102
  ],
  "ASROCK_RE_FLASH_GUID": [
    1893836824,
    3041,
    17481,
    191,
    212,
    158,
    246,
    140,
    127,
    2,
    168
  ],
  "ASROCK_LEGACY_INTERRUPT_GUID": [
    1911362257,
    9483,
    17147,
    140,
    23,
    16,
    220,
    250,
    119,
    23,
    1
  ],
  "ASROCK_SMM_CHILD_DISPATCHER_GUID": [
    1966485705,
    64229,
    18345,
    187,
    191,
    136,
    214,
    33,
    205,
    114,
    130
  ],
  "ASROCK_BFGDXE_GUID": [
    1988600983,
    65358,
    18687,
    188,
    170,
    103,
    219,
    246,
    92,
    66,
    209
  ],
  "ASROCK_IFLASHSETUP_GUID": [
    2011543064,
    9746,
    19496,
    188,
    223,
    162,
    177,
    77,
    138,
    62,
    254
  ],
  "ASROCK_S4_SLEEPDELAY_GUID": [
    2075935011,
    23902,
    19484,
    149,
    209,
    48,
    235,
    164,
    135,
    1,
    202
  ],
  "ASROCK_HDD_READY_DXE_GUID": [
    2179248970,
    9868,
    20428,
    142,
    57,
    28,
    29,
    62,
    111,
    110,
    105
  ],
  "ASROCK_RTLANDXE_GUID": [
    2332955475,
    13708,
    20015,
    147,
    69,
    238,
    191,
    29,
    171,
    152,
    155
  ],
  "ASROCK_AMD_SB900_DXE_GUID": [
    2333274783,
    28981,
    20139,
    175,
    218,
    5,
    18,
    247,
    75,
    101,
    234
  ],
  "ASROCK_SB900_SMBUS_LIGHT_GUID": [
    2551896525,
    34437,
    19115,
    175,
    218,
    5,
    18,
    247,
    75,
    101,
    234
  ],
  "ASROCK_AAFTBL_SMI_GUID": [
    2667102838,
    46054,
    19161,
    143,
    231,
    199,
    79,
    113,
    196,
    114,
    72
  ],
  "ASROCK_NVRAMID_GUID": [
    2708185858,
    25876,
    17031,
    190,
    227,
    98,
    35,
    183,
    222,
    44,
    33
  ],
  "ASROCK_IDE_SECURITY_GUID": [
    2847342799,
    414,
    19851,
    163,
    167,
    136,
    225,
    234,
    1,
    105,
    158
  ],
  "ASROCK_ASM1061_DXE_GUID": [
    2848876245,
    27959,
    17694,
    169,
    191,
    245,
    143,
    122,
    11,
    60,
    194
  ],
  "ASROCK_ASM104_X_SMI_GUID": [
    2904508538,
    47702,
    18652,
    142,
    170,
    232,
    251,
    234,
    116,
    184,
    242
  ],
  "ASROCK_RTLANSMI_GUID": [
    3005543067,
    24215,
    19449,
    180,
    224,
    81,
    37,
    193,
    246,
    5,
    213
  ],
  "ASROCK_GEC_UPDATE_SMI_GUID": [
    3092850716,
    5882,
    17832,
    146,
    1,
    28,
    56,
    48,
    169,
    115,
    189
  ],
  "ASROCK_APMOFF_GUID": [
    3146872289,
    16021,
    19326,
    135,
    80,
    157,
    106,
    163,
    78,
    183,
    246
  ],
  "ASROCK_SMIFLASH_GUID": [
    3157425597,
    47490,
    20309,
    159,
    121,
    5,
    106,
    215,
    233,
    135,
    197
  ],
  "ASROCK_RAID_X64_GUID": [
    3295196034,
    17744,
    18697,
    173,
    87,
    36,
    150,
    20,
    27,
    63,
    74
  ],
  "ASROCK_AMD_SB900_SMM_GUID": [
    3351810409,
    6722,
    20062,
    179,
    75,
    230,
    131,
    6,
    113,
    201,
    166
  ],
  "ASROCK_FIREWIRE_GUID": [
    3367390790,
    38937,
    17835,
    135,
    93,
    9,
    223,
    218,
    109,
    139,
    27
  ],
  "ASROCK_IDE_SMART_GUID": [
    3581707566,
    32927,
    17871,
    163,
    119,
    215,
    123,
    192,
    203,
    120,
    238
  ],
  "ASROCK_SB_INTERFACE_DXE_GUID": [
    3622218689,
    38683,
    17947,
    181,
    228,
    60,
    55,
    102,
    38,
    122,
    217
  ],
  "ASROCK_AMD_SB900_SMM_DISPATCHER_GUID": [
    3748899802,
    31298,
    20062,
    179,
    75,
    230,
    131,
    6,
    113,
    201,
    166
  ],
  "ASROCK_AMDCPU_DXE_GUID": [
    3786566962,
    16719,
    18139,
    154,
    238,
    66,
    0,
    119,
    243,
    93,
    190
  ],
  "ASROCK_SMBIOS_DMIEDIT_GUID": [
    3802613560,
    35124,
    18677,
    132,
    18,
    153,
    233,
    72,
    200,
    220,
    27
  ],
  "ASROCK_SECURITY_SELECT_DXE_GUID": [
    3832130086,
    37480,
    20144,
    160,
    135,
    221,
    76,
    238,
    55,
    64,
    75
  ],
  "ASROCK_FILE_EXPLORER_LITE_GUID": [
    3875982164,
    33976,
    16573,
    131,
    47,
    127,
    178,
    213,
    203,
    135,
    179
  ],
  "ASROCK_PLEDSMM_GUID": [
    3911953940,
    15869,
    19568,
    159,
    230,
    56,
    153,
    243,
    108,
    120,
    70
  ],
  "ASROCK_CPU_SMBIOS_DRIVER_GUID": [
    3930959592,
    43089,
    19103,
    171,
    244,
    183,
    159,
    162,
    82,
    130,
    145
  ],
  "ASROCK_AAFTBL_DXE_GUID": [
    4279363330,
    35107,
    18380,
    173,
    48,
    217,
    224,
    226,
    64,
    221,
    16
  ],
  "DELL_COMPUTRACE_BINARY_GUID": [
    623147636,
    37952,
    18389,
    191,
    10,
    237,
    146,
    164,
    214,
    235,
    164
  ],
  "DELL_MEBX_SETUP_BINARY_GUID": [
    393683817,
    53858,
    19344,
    159,
    49,
    189,
    196,
    31,
    38,
    99,
    165
  ],
  "DELL_ERROR_LOG_CONFIG_GUID": [
    59564679,
    47110,
    17846,
    168,
    25,
    81,
    77,
    175,
    75,
    145,
    185
  ],
  "DELL_FP_THUNK_GUID": [
    69003667,
    26231,
    18208,
    166,
    101,
    55,
    91,
    128,
    255,
    224,
    18
  ],
  "DELL_INTEL_LOM_SMM_GUID": [
    145481829,
    50009,
    19349,
    141,
    89,
    193,
    181,
    142,
    182,
    87,
    181
  ],
  "DELL_LEGACY_VIDEO_ROM_GUID": [
    149252656,
    25325,
    16838,
    146,
    64,
    183,
    69,
    94,
    230,
    83,
    215
  ],
  "DELL_PCH_S3_SUPPORT_GUID": [
    150128187,
    2270,
    19661,
    134,
    112,
    172,
    254,
    100,
    74,
    28,
    72
  ],
  "DELL_SPI_PART_MICRON_GUID": [
    152362504,
    17229,
    20383,
    147,
    179,
    111,
    164,
    138,
    234,
    247,
    224
  ],
  "DELL_DCP_REGISTER_GUID": [
    161470591,
    19257,
    17398,
    171,
    71,
    248,
    1,
    249,
    146,
    9,
    247
  ],
  "DELL_AHCI_DXE_GUID": [
    163151961,
    11636,
    17349,
    151,
    9,
    173,
    10,
    0,
    81,
    134,
    125
  ],
  "DELL_SIMPLE_BOOT_FLAG_SRC_GUID": [
    175448545,
    2545,
    17582,
    155,
    95,
    39,
    129,
    183,
    137,
    113,
    214
  ],
  "DELL_EDIAGS_DXE_GUID": [
    186863089,
    128,
    16683,
    135,
    22,
    138,
    129,
    163,
    161,
    31,
    170
  ],
  "DELL_ACPI_OEM_CONFIG_GUID": [
    187580522,
    60763,
    18024,
    188,
    209,
    43,
    29,
    176,
    24,
    65,
    252
  ],
  "DELL_SPI_PART_MXIC_GUID": [
    192673644,
    29210,
    17659,
    167,
    88,
    82,
    225,
    60,
    164,
    87,
    241
  ],
  "DELL_DTWLAN_SMM_GUID": [
    195268242,
    5450,
    19426,
    165,
    224,
    190,
    128,
    87,
    28,
    219,
    113
  ],
  "DELL_LEGACY16_ROM_GUID": [
    196160684,
    53161,
    18489,
    164,
    194,
    23,
    151,
    36,
    129,
    9,
    208
  ],
  "DELL_DEVICE_NAME_CONFIG_GUID": [
    197273096,
    60613,
    18361,
    160,
    56,
    79,
    10,
    104,
    55,
    46,
    68
  ],
  "DELL_AI13_ROM_GUID": [
    215208698,
    45597,
    18357,
    186,
    149,
    216,
    192,
    11,
    56,
    243,
    36
  ],
  "DELL_JPEG_DECODER_GUID": [
    220504629,
    39954,
    17516,
    142,
    203,
    239,
    193,
    245,
    40,
    2,
    9
  ],
  "DELL_DA_HDD_PROTECTION_GUID": [
    220775721,
    34772,
    17048,
    138,
    84,
    64,
    242,
    42,
    159,
    226,
    74
  ],
  "DELL_DCCS_SMM_DRIVER_GUID": [
    226622917,
    52120,
    19359,
    185,
    59,
    112,
    169,
    192,
    102,
    58,
    190
  ],
  "DELL_INTRUSION_DETECT_SMM_GUID": [
    232691254,
    33569,
    20191,
    159,
    20,
    11,
    252,
    163,
    180,
    115,
    245
  ],
  "DELL_VIRT_RTC_SMM_GUID": [
    242451377,
    33774,
    16804,
    147,
    158,
    36,
    200,
    134,
    240,
    58,
    214
  ],
  "DELL_SMM_HWM_DRIVER_GUID": [
    245618257,
    18868,
    18393,
    189,
    195,
    228,
    163,
    121,
    243,
    222,
    118
  ],
  "DELL_SM_BIOS_STRUC_DB_GUID": [
    246741696,
    41964,
    20461,
    151,
    131,
    168,
    208,
    255,
    209,
    174,
    51
  ],
  "DELL_CENTURY_ROLLOVER_SMM_GUID": [
    293724525,
    44817,
    19538,
    132,
    126,
    81,
    109,
    208,
    155,
    211,
    118
  ],
  "DELL_SMM_SECURITY_VAULT_GUID": [
    295647076,
    42946,
    17193,
    178,
    92,
    230,
    48,
    94,
    116,
    48,
    73
  ],
  "DELL_DXE_SW_SMI_GUID": [
    299700076,
    8347,
    18382,
    138,
    152,
    65,
    140,
    155,
    124,
    199,
    86
  ],
  "DELL_SMM_SB_ACPI_GUID": [
    311836245,
    22566,
    18078,
    169,
    52,
    163,
    203,
    179,
    7,
    110,
    197
  ],
  "DELL_SMM_ACCESS_GUID": [
    321112056,
    56021,
    16678,
    165,
    75,
    122,
    5,
    251,
    244,
    21,
    21
  ],
  "DELL_MFG_MODE_SMM_DRIVER_GUID": [
    343426378,
    17796,
    19658,
    176,
    210,
    18,
    10,
    206,
    18,
    157,
    187
  ],
  "DELL_SPI_PART_ATMEL_GUID": [
    350738878,
    30772,
    18302,
    169,
    66,
    255,
    95,
    130,
    62,
    226,
    73
  ],
  "DELL_EDIAGS_CONFIG_GUID": [
    353288559,
    2998,
    17064,
    182,
    5,
    121,
    121,
    75,
    137,
    209,
    91
  ],
  "DELL_VARIABLE_SMM_GUID": [
    376426563,
    59923,
    18504,
    187,
    60,
    111,
    162,
    149,
    185,
    70,
    39
  ],
  "DELL_SMM_GPIO_POLICY_GUID": [
    381905150,
    61812,
    18561,
    146,
    206,
    56,
    134,
    153,
    211,
    77,
    149
  ],
  "DELL_ACPI_GUID": [
    382771774,
    49308,
    16509,
    161,
    74,
    173,
    5,
    143,
    221,
    12,
    161
  ],
  "DELL_RUNTIME_ACPI_DXE_GUID": [
    389612339,
    19686,
    18600,
    175,
    185,
    14,
    245,
    91,
    102,
    107,
    116
  ],
  "DELL_SERVICE_MENU_GUID": [
    420935486,
    51236,
    20369,
    172,
    156,
    191,
    31,
    210,
    142,
    68,
    49
  ],
  "DELL_MONOTONIC_COUNTER_GUID": [
    424600875,
    766,
    16781,
    170,
    16,
    46,
    97,
    229,
    28,
    184,
    148
  ],
  "DELL_CSM_OEM_ROM_GUID": [
    438112772,
    58245,
    18755,
    168,
    146,
    83,
    52,
    206,
    56,
    9,
    172
  ],
  "DELL_DIAGS_SB_CONTROL_SMM_GUID": [
    452881360,
    51653,
    17620,
    183,
    189,
    143,
    94,
    125,
    15,
    37,
    96
  ],
  "DELL_AMT_PLATFORM_POLICY_GUID": [
    468079106,
    37656,
    18733,
    165,
    81,
    8,
    223,
    43,
    214,
    10,
    238
  ],
  "DELL_MFG_AUTHENTICATION_GUID": [
    473155928,
    65188,
    17247,
    147,
    239,
    10,
    156,
    20,
    174,
    135,
    228
  ],
  "DELL_SM_BIOS_STRUC_DA_GUID": [
    477314229,
    19599,
    17625,
    187,
    240,
    149,
    71,
    112,
    137,
    235,
    8
  ],
  "DELL_DXE_COMPUTRACE_GUID": [
    484872944,
    13079,
    17780,
    139,
    87,
    72,
    0,
    237,
    9,
    31,
    64
  ],
  "DELL_SMM_STATUS_CODE_GUID": [
    495067551,
    14447,
    20262,
    175,
    172,
    97,
    63,
    36,
    44,
    7,
    96
  ],
  "DELL_POWER_BUTTON_CONFIG_GUID": [
    519056625,
    49001,
    18883,
    143,
    220,
    91,
    181,
    93,
    34,
    76,
    250
  ],
  "DELL_REBOOT_DXE_GUID": [
    536913970,
    50804,
    18538,
    129,
    190,
    203,
    70,
    112,
    164,
    247,
    253
  ],
  "DELL_FLASH_IO_DXE_GUID": [
    560621596,
    40529,
    16735,
    154,
    218,
    203,
    159,
    188,
    208,
    95,
    93
  ],
  "DELL_SM_BIOS_STRUC_B1_GUID": [
    589118053,
    37954,
    17671,
    164,
    228,
    233,
    210,
    23,
    101,
    120,
    241
  ],
  "DELL_IO_TRAP_GUID": [
    594865631,
    61955,
    20416,
    162,
    14,
    97,
    186,
    215,
    48,
    137,
    214
  ],
  "DELL_SM_BIOS_DXE_DRIVER_GUID": [
    596042289,
    43471,
    20306,
    148,
    106,
    111,
    107,
    108,
    19,
    59,
    70
  ],
  "DELL_UPDATE_MEMORY_RECORD_GUID": [
    617403252,
    15862,
    16769,
    134,
    246,
    227,
    198,
    105,
    32,
    161,
    69
  ],
  "DELL_BIOS_BLK_IO_SRC_GUID": [
    632090968,
    56673,
    20068,
    154,
    73,
    85,
    133,
    30,
    154,
    38,
    199
  ],
  "DELL_ACPIS3_SAVE_GUID": [
    648169502,
    17444,
    18082,
    153,
    67,
    204,
    64,
    57,
    234,
    216,
    248
  ],
  "DELL_SB_SERVICES_SMM_GUID": [
    650136819,
    62971,
    18792,
    141,
    87,
    199,
    250,
    10,
    147,
    39,
    131
  ],
  "DELL_SYSTEM_ID_CONFIG_DXE_GUID": [
    656963409,
    34426,
    18125,
    145,
    175,
    65,
    111,
    246,
    174,
    61,
    254
  ],
  "DELL_OROM_KB_ACCESS_GUID": [
    660110193,
    14329,
    19016,
    181,
    112,
    88,
    182,
    209,
    79,
    109,
    236
  ],
  "DELL_SMSC5544_DXE_GUID": [
    670270351,
    47655,
    20474,
    179,
    116,
    53,
    190,
    162,
    138,
    67,
    27
  ],
  "DELL_AMT_PET_ALERT_GUID": [
    688824905,
    28296,
    16956,
    176,
    218,
    117,
    205,
    222,
    121,
    32,
    204
  ],
  "DELL_CSM_VIDEO_GUID": [
    701453816,
    46709,
    20317,
    143,
    47,
    184,
    122,
    62,
    207,
    208,
    99
  ],
  "DELL_BINDINGS_SMM_GUID": [
    720216299,
    5010,
    16946,
    164,
    249,
    197,
    122,
    60,
    47,
    162,
    217
  ],
  "DELL_EDIAGS_SMM_GUID": [
    762170232,
    51938,
    17497,
    146,
    124,
    100,
    166,
    183,
    230,
    74,
    117
  ],
  "DELL_PBA_UPEK_DPBA_GUID": [
    762651386,
    26608,
    18280,
    182,
    224,
    253,
    118,
    241,
    127,
    75,
    4
  ],
  "DELL_PPM_POLICY_INIT_DXE_GUID": [
    770768916,
    53025,
    17024,
    140,
    63,
    229,
    57,
    184,
    238,
    81,
    80
  ],
  "DELL_GENERIC_SIO_DXE_GUID": [
    771101699,
    49536,
    17829,
    162,
    43,
    26,
    61,
    184,
    143,
    233,
    186
  ],
  "DELL_SM_BIOS_SMM_DA_CI_GUID": [
    775889525,
    35277,
    19940,
    189,
    132,
    190,
    191,
    217,
    75,
    205,
    204
  ],
  "DELL_USB_MOUSE_GUID": [
    788490211,
    22919,
    18152,
    129,
    17,
    128,
    255,
    166,
    122,
    235,
    147
  ],
  "DELL_DXE_GPIO_POLICY_GUID": [
    800200429,
    19047,
    18483,
    159,
    92,
    36,
    129,
    36,
    205,
    154,
    172
  ],
  "DELL_GSET_GUID": [
    800665338,
    12000,
    19374,
    158,
    182,
    116,
    68,
    18,
    94,
    30,
    247
  ],
  "DELL_UHCI_GUID": [
    800665338,
    12000,
    19374,
    158,
    182,
    116,
    100,
    18,
    94,
    30,
    247
  ],
  "DELL_SPI_PART_PROM_JET_GUID": [
    805154634,
    43445,
    20214,
    170,
    59,
    168,
    150,
    17,
    170,
    178,
    132
  ],
  "DELL_PCI_HOT_PLUG_GUID": [
    807593234,
    47434,
    20242,
    128,
    109,
    126,
    241,
    23,
    120,
    153,
    216
  ],
  "DELL_SMB_PROTOCOL_ACCESS_GUID": [
    849285743,
    10654,
    19397,
    131,
    16,
    23,
    159,
    16,
    235,
    70,
    201
  ],
  "DELL_ALERT_STANDARD_FORMAT_DXE_GUID": [
    868630637,
    12139,
    16821,
    135,
    5,
    82,
    186,
    251,
    99,
    60,
    9
  ],
  "DELL_LEG_USB_MEM_SMM_GUID": [
    917420886,
    8075,
    19393,
    142,
    254,
    64,
    133,
    165,
    212,
    196,
    10
  ],
  "DELL_ERROR_HANDLER_SMM_GUID": [
    925400203,
    56467,
    17877,
    154,
    175,
    60,
    210,
    233,
    6,
    177,
    43
  ],
  "DELL_DEFAULT_BOOT_LIST_SMM_GUID": [
    925400203,
    56467,
    17877,
    154,
    175,
    60,
    210,
    233,
    6,
    255,
    255
  ],
  "DELL_TPMDXE_GUID": [
    946780090,
    25412,
    17640,
    152,
    92,
    57,
    120,
    253,
    71,
    145,
    107
  ],
  "DELL_OEM_SX_SMM_GUID": [
    948378608,
    50762,
    18582,
    184,
    228,
    98,
    212,
    133,
    12,
    126,
    104
  ],
  "DELL_AC_LOSS_SMM_GUID": [
    948378608,
    50762,
    18582,
    184,
    228,
    98,
    215,
    117,
    12,
    125,
    104
  ],
  "DELL_DIAGS_SB_CONTROL_DXE_GUID": [
    955198347,
    53053,
    18402,
    151,
    227,
    85,
    113,
    21,
    228,
    57,
    133
  ],
  "DELL_SMM_LEGACY_REGION_GUID": [
    962780853,
    65014,
    18473,
    136,
    156,
    213,
    68,
    145,
    142,
    132,
    217
  ],
  "DELL_PS2_EMUL_GUID": [
    967310044,
    39460,
    17747,
    140,
    189,
    155,
    114,
    178,
    76,
    34,
    253
  ],
  "DELL_MEMORY_S4_GUID": [
    975822105,
    11396,
    19056,
    154,
    1,
    251,
    221,
    175,
    251,
    100,
    97
  ],
  "DELL_SB_SERVICES_DXE_GUID": [
    977290450,
    62996,
    16676,
    167,
    114,
    32,
    123,
    205,
    190,
    61,
    176
  ],
  "DELL_STOP_SHIP_CONFIG_GUID": [
    993507108,
    19191,
    18997,
    151,
    179,
    210,
    251,
    143,
    79,
    86,
    60
  ],
  "DELL_BLOCK_IO_GUID": [
    1002555495,
    8820,
    17400,
    164,
    186,
    147,
    154,
    91,
    214,
    212,
    115
  ],
  "DELL_PCI_BUS_GUID": [
    1008591775,
    53767,
    16522,
    170,
    204,
    115,
    28,
    251,
    127,
    29,
    215
  ],
  "DELL_TX_TDXE_GUID": [
    1029076176,
    44661,
    18211,
    145,
    89,
    29,
    101,
    59,
    64,
    64,
    47
  ],
  "DELL_SM_BIOS_STRUC_D3_GUID": [
    1037980905,
    36120,
    20136,
    148,
    35,
    194,
    232,
    70,
    225,
    142,
    35
  ],
  "DELL_SMB_BOOT_PRIORITY_GUID": [
    1099196974,
    31402,
    17560,
    188,
    38,
    181,
    172,
    212,
    159,
    146,
    225
  ],
  "DELL_SPI_CONTROLLER_SMM_GUID": [
    1099935596,
    11215,
    16705,
    137,
    131,
    157,
    51,
    225,
    182,
    123,
    76
  ],
  "DELL_ME_PCI_PLATFORM_CONFIG_DXE_GUID": [
    1106536082,
    38163,
    19740,
    139,
    179,
    182,
    161,
    104,
    24,
    45,
    228
  ],
  "DELL_PBA_UPEK_DXE_GUID": [
    1120087503,
    62042,
    18419,
    143,
    76,
    171,
    212,
    120,
    215,
    127,
    80
  ],
  "DELL_GPE_CONFIG_GUID": [
    1174254635,
    8085,
    19027,
    155,
    164,
    28,
    139,
    251,
    139,
    203,
    1
  ],
  "DELL_POWER_OFF_SMM_GUID": [
    1190974936,
    43443,
    17123,
    144,
    74,
    1,
    47,
    7,
    188,
    95,
    92
  ],
  "DELL_GPE_GUID": [
    1198704346,
    20589,
    19605,
    172,
    23,
    174,
    102,
    136,
    95,
    109,
    83
  ],
  "DELL_PASSWORD_MGR_SMM_GUID": [
    1202852751,
    23147,
    19557,
    145,
    103,
    135,
    64,
    89,
    93,
    22,
    173
  ],
  "DELL_SMM_SB_GPIO_CONTROL_GUID": [
    1206402316,
    10996,
    18061,
    145,
    145,
    156,
    228,
    104,
    193,
    142,
    158
  ],
  "DELL_RAID_ROM_GUID": [
    1226990052,
    1625,
    16972,
    130,
    182,
    115,
    39,
    67,
    137,
    231,
    167
  ],
  "DELL_SMM_DISPATCHER_GUID": [
    1245131275,
    16307,
    17253,
    151,
    48,
    158,
    137,
    198,
    0,
    57,
    93
  ],
  "DELL_DXE_SIO_GPIO_CONTROL_GUID": [
    1248129536,
    63900,
    17139,
    128,
    199,
    13,
    145,
    226,
    211,
    235,
    93
  ],
  "DELL_VARIABLE_DXE_GUID": [
    1267189915,
    14761,
    18319,
    164,
    182,
    129,
    106,
    158,
    220,
    80,
    135
  ],
  "DELL_CPU_SMM_GUID": [
    1318627838,
    57178,
    16694,
    185,
    34,
    79,
    185,
    112,
    203,
    215,
    51
  ],
  "DELL_CHASSIS_CONFIG_SMM_GUID": [
    1373013960,
    6510,
    19710,
    138,
    12,
    131,
    104,
    152,
    14,
    168,
    182
  ],
  "DELL_SMM_DELAY_GUID": [
    1378954463,
    54441,
    17726,
    169,
    223,
    159,
    218,
    245,
    28,
    214,
    34
  ],
  "DELL_SPI_PART_EON_GUID": [
    1386777386,
    26109,
    18769,
    139,
    37,
    6,
    251,
    101,
    152,
    18,
    139
  ],
  "DELL_CHASSIS_CONFIG_DXE_GUID": [
    1421699677,
    14578,
    17597,
    132,
    171,
    16,
    139,
    228,
    244,
    89,
    20
  ],
  "DELL_HIIPARSER_DXE_DRIVER_GUID": [
    1436706812,
    26119,
    16419,
    136,
    78,
    72,
    229,
    211,
    211,
    244,
    226
  ],
  "DELL_BINDINGS_DXE_GUID": [
    1438341707,
    15167,
    17452,
    191,
    9,
    15,
    135,
    166,
    126,
    142,
    231
  ],
  "DELL_HECI_DXE_GUID": [
    1441228356,
    30885,
    19074,
    169,
    0,
    113,
    38,
    165,
    121,
    136,
    146
  ],
  "DELL_SMM_BBSMANAGER_LEGACY_GUID": [
    1442227219,
    10255,
    16867,
    147,
    148,
    101,
    128,
    242,
    157,
    215,
    208
  ],
  "DELL_GRASSLAKE_CONFIG_GUID": [
    1458496326,
    20492,
    18742,
    149,
    26,
    45,
    165,
    240,
    255,
    57,
    187
  ],
  "DELL_IDE_SMM_GUID": [
    1461526225,
    49881,
    16782,
    149,
    58,
    36,
    142,
    188,
    104,
    112,
    72
  ],
  "DELL_PASSWORD_MGR_DXE_GUID": [
    1475622312,
    7223,
    18484,
    173,
    97,
    176,
    61,
    148,
    221,
    206,
    243
  ],
  "DELL_ME_FW_DOWNGRADE_GUID": [
    1478553268,
    49461,
    18516,
    157,
    42,
    170,
    158,
    252,
    68,
    117,
    233
  ],
  "DELL_CSM_CONFIG_GUID": [
    1484687255,
    49915,
    16823,
    174,
    155,
    245,
    58,
    108,
    86,
    45,
    245
  ],
  "DELL_GPE_OROM_GUID": [
    1489880953,
    56460,
    18715,
    186,
    195,
    248,
    110,
    6,
    209,
    134,
    95
  ],
  "DELL_SM_BIOS_SMM_DRIVER_GUID": [
    1493767628,
    34338,
    19809,
    190,
    100,
    195,
    62,
    231,
    96,
    20,
    31
  ],
  "DELL_PCH_SMBUS_SMM_GUID": [
    1495822712,
    22962,
    18890,
    188,
    99,
    83,
    43,
    18,
    234,
    44,
    83
  ],
  "DELL_DASH_BIOS_MANAGER_GUID": [
    1496809990,
    34331,
    17280,
    163,
    73,
    47,
    47,
    79,
    3,
    12,
    75
  ],
  "DELL_WDT_DXE_GUID": [
    1521189861,
    61479,
    19623,
    191,
    208,
    22,
    53,
    140,
    201,
    228,
    83
  ],
  "DELL_CORE_DXE_GUID": [
    1524888446,
    20142,
    16814,
    130,
    64,
    53,
    70,
    91,
    94,
    129,
    235
  ],
  "DELL_PASSWORD_UI_GUID": [
    1564786295,
    22121,
    16848,
    182,
    133,
    27,
    243,
    248,
    62,
    251,
    152
  ],
  "DELL_HOT_SOS_SMM_DRIVER_GUID": [
    1571415364,
    56365,
    18032,
    163,
    213,
    152,
    82,
    54,
    213,
    222,
    69
  ],
  "DELL_SIO_CONFIG_DXE_GUID": [
    1572044380,
    12011,
    17400,
    173,
    160,
    36,
    55,
    2,
    211,
    148,
    93
  ],
  "DELL_TCG_DXE_GUID": [
    1587325859,
    62129,
    18810,
    173,
    172,
    36,
    245,
    117,
    233,
    205,
    233
  ],
  "DELL_ACPI_CONFIG_GUID": [
    1591357731,
    2112,
    17911,
    173,
    171,
    19,
    166,
    85,
    239,
    59,
    183
  ],
  "DELL_FLASH_SCREEN_DXE_GUID": [
    1626069668,
    5477,
    19866,
    153,
    200,
    136,
    223,
    166,
    85,
    73,
    165
  ],
  "DELL_TXT_DXE_GUID": [
    1630407945,
    23825,
    17686,
    130,
    238,
    109,
    214,
    5,
    254,
    38,
    95
  ],
  "DELL_DIAGS_DXE_DRIVER_GUID": [
    1662733815,
    47850,
    19487,
    160,
    97,
    91,
    100,
    98,
    101,
    40,
    34
  ],
  "DELL_FLASH_UPDATE_DXE_GUID": [
    1680263188,
    24602,
    16662,
    158,
    159,
    191,
    157,
    111,
    143,
    37,
    79
  ],
  "DELL_SMM_GPE_GUID": [
    1709829021,
    33069,
    16737,
    153,
    197,
    5,
    172,
    75,
    204,
    164,
    148
  ],
  "DELL_RTC_AUTO_ON_SMM_GUID": [
    1732878212,
    62181,
    19922,
    158,
    86,
    198,
    227,
    137,
    221,
    97,
    115
  ],
  "DELL_SMM_FLASH_WRITE_PROTECT_GUID": [
    1777301692,
    15217,
    20172,
    131,
    79,
    59,
    116,
    249,
    20,
    132,
    48
  ],
  "DELL_DIAGS_CONFIG_GUID": [
    1777957454,
    5013,
    17226,
    165,
    211,
    255,
    156,
    234,
    40,
    72,
    133
  ],
  "DELL_AUDIO_CONFIG_DXE_GUID": [
    1788978124,
    21188,
    19203,
    153,
    247,
    40,
    143,
    52,
    92,
    29,
    179
  ],
  "DELL_SPECIAL_BOOT_STUB_GUID": [
    1797814372,
    30108,
    17092,
    180,
    53,
    167,
    74,
    182,
    148,
    205,
    59
  ],
  "DELL_DA_SERVICE_TAG_GUID": [
    1854722743,
    46646,
    18521,
    133,
    237,
    198,
    55,
    189,
    202,
    89,
    25
  ],
  "DELL_DXE_SB_ACPI_GUID": [
    1855444212,
    6296,
    17416,
    166,
    45,
    153,
    202,
    222,
    211,
    47,
    216
  ],
  "DELL_MONOTONIC_COUNTER_SMM_GUID": [
    1898086669,
    52435,
    19209,
    160,
    171,
    141,
    16,
    118,
    69,
    201,
    120
  ],
  "DELL_SMM_SB_GENERIC_GUID": [
    1898475784,
    48984,
    16874,
    183,
    28,
    179,
    98,
    45,
    235,
    202,
    157
  ],
  "DELL_ACPI_MODE_ENABLE_GUID": [
    1963495590,
    31439,
    20303,
    129,
    189,
    180,
    0,
    194,
    190,
    169,
    90
  ],
  "DELL_SMM_SIO_EMI_GUID": [
    1971880107,
    19618,
    19882,
    168,
    62,
    209,
    249,
    173,
    242,
    194,
    241
  ],
  "DELL_PSTATE_CONTROL_GUID": [
    1975412348,
    18657,
    17709,
    176,
    252,
    54,
    49,
    56,
    237,
    135,
    255
  ],
  "DELL_DA_EPPID_GUID": [
    1990319997,
    30028,
    16609,
    188,
    114,
    63,
    202,
    216,
    66,
    222,
    246
  ],
  "DELL_PROGRESS_BAR_GUID": [
    1992170175,
    7710,
    12829,
    183,
    240,
    158,
    9,
    132,
    253,
    218,
    188
  ],
  "DELL_PBA_MGR_SMM_GUID": [
    1994516974,
    24519,
    17939,
    185,
    111,
    250,
    121,
    119,
    150,
    87,
    58
  ],
  "DELL_AMT_SETUP_GUID": [
    2000466059,
    20762,
    19413,
    133,
    173,
    65,
    212,
    244,
    182,
    74,
    82
  ],
  "DELL_STORAGE_AGENTS_DXE_GUID": [
    2013853122,
    40112,
    17929,
    144,
    127,
    177,
    132,
    83,
    195,
    99,
    180
  ],
  "DELL_VARIABLE_RUNTIME_DXE_GUID": [
    2021476419,
    26796,
    19496,
    190,
    83,
    186,
    194,
    114,
    186,
    236,
    249
  ],
  "DELL_PBA_SCARD_DXE_GUID": [
    2044959363,
    53267,
    19246,
    131,
    106,
    169,
    154,
    113,
    71,
    53,
    28
  ],
  "DELL_SOL_POST_MESSAGE_GUID": [
    2047396760,
    59836,
    16835,
    190,
    25,
    179,
    2,
    243,
    241,
    245,
    35
  ],
  "DELL_TERMINAL_GUID": [
    2047396760,
    59836,
    16835,
    190,
    25,
    179,
    2,
    243,
    241,
    245,
    149
  ],
  "DELL_SM_BIOS_STRUC_D0_GUID": [
    2075890981,
    38842,
    17686,
    182,
    96,
    27,
    14,
    183,
    135,
    68,
    165
  ],
  "DELL_SMM_RUNTIME_GUID": [
    2088348812,
    24172,
    20029,
    186,
    111,
    194,
    96,
    238,
    124,
    23,
    46
  ],
  "DELL_FLASH_IO_SMM_GUID": [
    2092505544,
    54425,
    17961,
    172,
    179,
    34,
    118,
    158,
    52,
    61,
    219
  ],
  "DELL_SYSTEM_PW_SMM_GUID": [
    2158681357,
    32851,
    19367,
    148,
    27,
    54,
    244,
    139,
    178,
    48,
    1
  ],
  "DELL_PCI_ROOT_BRIDGE_GUID": [
    2162585098,
    52433,
    17402,
    167,
    177,
    45,
    94,
    224,
    241,
    57,
    16
  ],
  "DELL_POWER_OFF_CONFIG_GUID": [
    2163227679,
    35261,
    16960,
    147,
    168,
    172,
    153,
    233,
    169,
    41,
    252
  ],
  "DELL_DXE_HWM_DRIVER_GUID": [
    2189636628,
    51444,
    19298,
    171,
    106,
    228,
    213,
    218,
    171,
    19,
    15
  ],
  "DELL_PXE_UNDI_ROM_GUID": [
    2197545579,
    21460,
    17551,
    146,
    76,
    123,
    224,
    18,
    110,
    202,
    79
  ],
  "DELL_PW_BY_PASS_SMM_GUID": [
    2209781945,
    520,
    20175,
    187,
    131,
    206,
    66,
    208,
    190,
    252,
    74
  ],
  "DELL_HOT_KEY_HANDLER_SMM_GUID": [
    2221392131,
    28662,
    19814,
    134,
    246,
    225,
    18,
    76,
    17,
    30,
    148
  ],
  "DELL_POWER_MANAGEMENT_DXE_GUID": [
    2224624263,
    16368,
    20428,
    156,
    17,
    199,
    224,
    65,
    134,
    44,
    118
  ],
  "DELL_AC_RECOVERY_SMM_GUID": [
    2239859116,
    3786,
    18022,
    186,
    184,
    153,
    114,
    64,
    153,
    83,
    200
  ],
  "DELL_SMM_SIO_DASH_GUID": [
    2277981212,
    5417,
    20213,
    163,
    250,
    8,
    215,
    62,
    248,
    200,
    39
  ],
  "DELL_SMM_EVENT_DXE_GUID": [
    2295339961,
    9338,
    18166,
    187,
    110,
    187,
    164,
    159,
    17,
    36,
    248
  ],
  "DELL_SETUP_PREP_GUID": [
    2308179927,
    39422,
    17368,
    154,
    33,
    121,
    236,
    50,
    140,
    172,
    33
  ],
  "DELL_DXE_PREREQ_GUID": [
    2311005263,
    58729,
    16751,
    177,
    16,
    138,
    229,
    239,
    213,
    23,
    28
  ],
  "DELL_SPI_PART_ST_MICRO_GUID": [
    2325708028,
    23548,
    17807,
    152,
    111,
    188,
    61,
    27,
    167,
    172,
    137
  ],
  "DELL_DIAGS_LEGACY_GUID": [
    2337444691,
    8140,
    19136,
    161,
    33,
    144,
    190,
    159,
    156,
    191,
    122
  ],
  "DELL_ACPI_PLATFORM_GUID": [
    2338306749,
    62751,
    18754,
    191,
    22,
    22,
    170,
    163,
    138,
    229,
    43
  ],
  "DELL_POWER_MANAGEMENT_GUID": [
    2356689264,
    61482,
    19021,
    175,
    9,
    135,
    151,
    165,
    30,
    236,
    141
  ],
  "DELL_AHCI_SMM_GUID": [
    3157411261,
    47490,
    20309,
    159,
    121,
    5,
    106,
    215,
    233,
    135,
    197
  ],
  "DELL_ME_PLATFORM_CONFIG_DXE_GUID": [
    2368893290,
    24799,
    19422,
    134,
    71,
    61,
    23,
    140,
    200,
    43,
    108
  ],
  "DELL_PCI_HOST_BRIDGE_GUID": [
    2372359865,
    58718,
    19818,
    163,
    165,
    94,
    77,
    114,
    221,
    247,
    114
  ],
  "DELL_SMM_SERVICES_GUID": [
    2379094359,
    55156,
    20442,
    185,
    15,
    11,
    35,
    28,
    178,
    224,
    204
  ],
  "DELL_MOD_BAY_CONFIG_GUID": [
    2384466983,
    17978,
    19748,
    160,
    244,
    37,
    168,
    117,
    246,
    27,
    170
  ],
  "DELL_SERVICE_RESET_SMM_GUID": [
    2395179049,
    42399,
    16611,
    186,
    208,
    133,
    248,
    21,
    161,
    87,
    209
  ],
  "DELL_EC_CONFIG_DXE_GUID": [
    2395213747,
    16901,
    19799,
    144,
    57,
    161,
    146,
    131,
    44,
    124,
    237
  ],
  "DELL_ERROR_HANDLER_DXE_GUID": [
    2403573131,
    1970,
    16673,
    170,
    149,
    138,
    201,
    21,
    113,
    170,
    117
  ],
  "DELL_DEFAULT_BOOT_LIST_DXE_GUID": [
    2403573131,
    1970,
    16673,
    170,
    149,
    138,
    201,
    21,
    113,
    255,
    255
  ],
  "DELL_AHCISRC_GUID": [
    2405051906,
    21388,
    19801,
    185,
    32,
    196,
    120,
    106,
    203,
    197,
    82
  ],
  "DELL_SB_ACCESS_SMM_GUID": [
    2411212196,
    50110,
    17062,
    138,
    112,
    123,
    148,
    214,
    9,
    114,
    166
  ],
  "DELL_IMG_SRV_BASE_ROM_GUID": [
    2419529971,
    22365,
    19868,
    188,
    120,
    101,
    161,
    19,
    129,
    160,
    38
  ],
  "DELL_SMART_TIMER_GUID": [
    2429253083,
    29180,
    18589,
    170,
    207,
    148,
    52,
    119,
    236,
    114,
    18
  ],
  "DELL_PBA_FP_DXE_GUID": [
    2444894238,
    5665,
    18172,
    130,
    90,
    176,
    54,
    62,
    202,
    212,
    188
  ],
  "DELL_HECI_SMM_GUID": [
    2451363715,
    15906,
    17785,
    167,
    31,
    0,
    215,
    65,
    151,
    252,
    200
  ],
  "DELL_SMM_COMPUTRACE_GUID": [
    2462551630,
    51604,
    20382,
    130,
    171,
    175,
    29,
    186,
    104,
    88,
    201
  ],
  "DELL_FILE_SYSTEM_GUID": [
    2466393996,
    7945,
    18415,
    187,
    178,
    88,
    20,
    255,
    96,
    157,
    245
  ],
  "DELL_DIRTY_SHUTDOWN_DXE_GUID": [
    2474053840,
    61200,
    17086,
    146,
    225,
    132,
    148,
    114,
    43,
    23,
    181
  ],
  "DELL_SB_ACPI_CONFIG_GUID": [
    2492620721,
    61172,
    16877,
    189,
    122,
    205,
    176,
    74,
    170,
    129,
    199
  ],
  "DELL_TCG_SETUP_GUID": [
    2498613546,
    16795,
    17535,
    148,
    52,
    155,
    59,
    112,
    120,
    57,
    3
  ],
  "DELL_SERVICE_RESET_DXE_GUID": [
    2537284199,
    2400,
    16583,
    152,
    86,
    250,
    115,
    201,
    42,
    70,
    186
  ],
  "DELL_BIOS_EXTENSION_LOADER_GUID": [
    2546758024,
    31177,
    17567,
    185,
    105,
    6,
    91,
    100,
    191,
    156,
    105
  ],
  "DELL_HOT_SOS_DXE_DRIVER_GUID": [
    2564335444,
    33922,
    18146,
    130,
    140,
    187,
    99,
    47,
    52,
    217,
    247
  ],
  "DELL_SM_BIOS_STRUC_DE_GUID": [
    2573047489,
    26193,
    18096,
    191,
    62,
    131,
    192,
    23,
    180,
    59,
    29
  ],
  "DELL_SB_SMM_HOOKS_GUID": [
    2577523701,
    2183,
    17351,
    176,
    10,
    241,
    74,
    100,
    107,
    193,
    66
  ],
  "DELL_BBSMANAGER_DXE_GUID": [
    2595435247,
    33241,
    17361,
    134,
    122,
    3,
    221,
    87,
    78,
    133,
    102
  ],
  "DELL_GSET_CONFIG_GUID": [
    2599541285,
    61548,
    17339,
    190,
    136,
    131,
    69,
    80,
    191,
    118,
    91
  ],
  "DELL_MULTI_DISPLAY_DXE_GUID": [
    2617192461,
    54855,
    18446,
    159,
    243,
    32,
    6,
    211,
    215,
    204,
    198
  ],
  "DELL_AMI_BOARD_INFO_GUID": [
    2671378454,
    44629,
    17032,
    130,
    157,
    210,
    47,
    211,
    68,
    195,
    71
  ],
  "DELL_DA_NON_VOLITILE_STORAGE_GUID": [
    2679520249,
    46370,
    16899,
    154,
    83,
    32,
    236,
    133,
    74,
    49,
    42
  ],
  "DELL_DXE_MAIN_GUID": [
    2681197550,
    14531,
    19119,
    149,
    18,
    236,
    65,
    99,
    113,
    246,
    74
  ],
  "DELL_SIO_POLICY_CONFIG_DXE_GUID": [
    2688661718,
    16151,
    17794,
    170,
    199,
    90,
    97,
    86,
    114,
    226,
    149
  ],
  "DELL_CSMCORE_GUID": [
    2690830111,
    33907,
    19107,
    135,
    147,
    96,
    11,
    196,
    255,
    233,
    168
  ],
  "DELL_HDD_PW_SMM_GUID": [
    2696445586,
    25490,
    18430,
    154,
    160,
    144,
    32,
    49,
    71,
    236,
    4
  ],
  "DELL_SMM_CONTROL_GUID": [
    2696600055,
    43896,
    18715,
    181,
    131,
    197,
    43,
    127,
    132,
    185,
    224
  ],
  "DELL_PCI_EXPRESS_DXE_GUID": [
    2711597294,
    1524,
    19670,
    143,
    40,
    89,
    183,
    130,
    255,
    149,
    198
  ],
  "DELL_SPI_PART_SST_GUID": [
    2726778251,
    55773,
    17947,
    169,
    41,
    236,
    42,
    210,
    254,
    245,
    145
  ],
  "DELL_SPI_CONTROLLER_DXE_GUID": [
    2742722115,
    36983,
    17721,
    155,
    144,
    189,
    113,
    155,
    3,
    43,
    35
  ],
  "DELL_SMB_FACT_DEFAULT_GUID": [
    2748922409,
    20507,
    20334,
    134,
    154,
    111,
    212,
    188,
    239,
    144,
    167
  ],
  "DELL_SMM_SIO_GPIO_CONTROL_GUID": [
    2806725359,
    9474,
    16581,
    131,
    169,
    53,
    36,
    119,
    98,
    115,
    234
  ],
  "DELL_IMAGE_SERVER_SMM_GUID": [
    2812134215,
    57012,
    19022,
    132,
    151,
    202,
    95,
    142,
    127,
    6,
    1
  ],
  "DELL_PBA_MGR_DXE_GUID": [
    2813554127,
    51034,
    19432,
    190,
    47,
    228,
    132,
    12,
    190,
    22,
    59
  ],
  "DELL_IMAGE_SERVER_DXE_GUID": [
    2821932058,
    3232,
    16434,
    133,
    154,
    60,
    255,
    123,
    102,
    70,
    167
  ],
  "DELL_LOM_CONFIG_GUID": [
    2826249488,
    55358,
    16394,
    133,
    222,
    253,
    21,
    135,
    136,
    42,
    254
  ],
  "DELL_LEGACY_USB_SMM_GUID": [
    2829252321,
    28514,
    19707,
    158,
    71,
    147,
    207,
    214,
    214,
    228,
    118
  ],
  "DELL_AMT_SMBIOS_GUID": [
    2831577685,
    57385,
    19226,
    150,
    142,
    236,
    166,
    233,
    193,
    28,
    115
  ],
  "DELL_TCG_MOR_GUID": [
    2906746083,
    42115,
    17841,
    148,
    194,
    75,
    78,
    77,
    87,
    85,
    98
  ],
  "DELL_DO_SIODIAG_LED_DXE_GUID": [
    2907311365,
    32877,
    20452,
    150,
    173,
    59,
    214,
    45,
    140,
    76,
    224
  ],
  "DELL_AUDIO_DXE_GUID": [
    2921628957,
    58388,
    16482,
    149,
    157,
    95,
    67,
    234,
    153,
    54,
    60
  ],
  "DELL_FV_MAINNESTED_GUID": [
    2926672943,
    6722,
    20267,
    136,
    97,
    120,
    183,
    156,
    160,
    126,
    7
  ],
  "DELL_SMM_CRYPTO_ALGORITHM_GUID": [
    2951172549,
    1492,
    18584,
    191,
    148,
    26,
    75,
    80,
    243,
    95,
    212
  ],
  "DELL_PCH_SMI_DISPATCHER_GUID": [
    2966875475,
    47172,
    17397,
    189,
    47,
    97,
    9,
    82,
    100,
    231,
    126
  ],
  "DELL_SMBIOS64_GUID": [
    2973687096,
    26700,
    16877,
    163,
    5,
    215,
    183,
    227,
    36,
    151,
    223
  ],
  "DELL_AMI_TSE_GUID": [
    2983856863,
    20343,
    16496,
    168,
    142,
    191,
    254,
    28,
    96,
    82,
    154
  ],
  "DELL_DXE_DELAY_GUID": [
    3021497697,
    35175,
    16659,
    188,
    95,
    40,
    75,
    118,
    112,
    196,
    160
  ],
  "DELL_LEG_USB_MEM_INFO_DXE_GUID": [
    3025887172,
    54950,
    17699,
    162,
    41,
    231,
    119,
    32,
    151,
    239,
    20
  ],
  "DELL_SECURITY_CONFIG_GUID": [
    3072249106,
    57374,
    17419,
    170,
    82,
    77,
    110,
    89,
    212,
    91,
    60
  ],
  "DELL_SMB_VERSION_MANIFEST_GUID": [
    3108097809,
    58952,
    16412,
    146,
    161,
    52,
    42,
    112,
    198,
    183,
    66
  ],
  "DELL_SMBIOSUPDATE_DATA_GUID": [
    3112802724,
    59759,
    18266,
    153,
    252,
    118,
    33,
    38,
    245,
    15,
    90
  ],
  "DELL_PCH_RESET_GUID": [
    3139419471,
    11824,
    18323,
    155,
    237,
    116,
    246,
    114,
    188,
    143,
    254
  ],
  "DELL_SATA_CONTROLLER_GUID": [
    3143996459,
    21023,
    20163,
    186,
    249,
    169,
    37,
    64,
    207,
    96,
    210
  ],
  "DELL_ALERT_STANDARD_FORMAT_SMM_GUID": [
    3146232605,
    62310,
    18409,
    136,
    94,
    232,
    22,
    176,
    155,
    151,
    182
  ],
  "DELL_DA_TAA_MAC_GUID": [
    3165370077,
    16031,
    18402,
    184,
    251,
    16,
    179,
    154,
    246,
    52,
    44
  ],
  "DELL_HOT_KEY_HANDLER_DXE_GUID": [
    3166386450,
    10746,
    19237,
    182,
    25,
    60,
    13,
    115,
    159,
    239,
    81
  ],
  "DELL_CMOS_MANAGER_DXE_SRC_GUID": [
    3175457368,
    51133,
    19440,
    178,
    84,
    208,
    212,
    94,
    2,
    248,
    119
  ],
  "DELL_DXE_GPIO_CONTROL_GUID": [
    3184242748,
    21598,
    17345,
    138,
    168,
    240,
    88,
    196,
    250,
    129,
    168
  ],
  "DELL_DT_LEG_USB_POLICY_GUID": [
    3186172457,
    63909,
    18583,
    129,
    228,
    139,
    171,
    103,
    146,
    163,
    149
  ],
  "DELL_PXE_BASE_ROM_GUID": [
    3187322150,
    19839,
    17574,
    135,
    25,
    55,
    94,
    203,
    74,
    164,
    7
  ],
  "DELL_SMI_VARIABLE_GUID": [
    3189861288,
    14532,
    17717,
    166,
    202,
    93,
    202,
    91,
    67,
    173,
    223
  ],
  "DELL_POWER_BUTTON_DXE_GUID": [
    3207045736,
    62313,
    17314,
    178,
    149,
    36,
    45,
    238,
    127,
    60,
    41
  ],
  "DELL_ACTIVE_BIOS_GUID": [
    3218447682,
    65039,
    16977,
    183,
    114,
    75,
    9,
    138,
    26,
    236,
    133
  ],
  "DELL_D010_ALEGACY_VIDEO_ROM_GUID": [
    3233357934,
    46763,
    19952,
    179,
    214,
    40,
    106,
    199,
    102,
    152,
    189
  ],
  "DELL_SMM_DIAG_LEDS_GUID": [
    3238698573,
    48564,
    19226,
    130,
    204,
    217,
    1,
    248,
    111,
    87,
    57
  ],
  "DELL_FLASH_WRITE_PROTECT_GUID": [
    3242472502,
    47444,
    17338,
    130,
    120,
    193,
    228,
    66,
    194,
    21,
    57
  ],
  "DELL_LEGACY_INTERRUPT_GUID": [
    3250854137,
    22813,
    17948,
    130,
    162,
    185,
    205,
    150,
    223,
    234,
    134
  ],
  "DELL_SAVE_MEMORY_CONFIG_DXE_GUID": [
    3289668034,
    41601,
    16595,
    179,
    10,
    43,
    157,
    255,
    63,
    61,
    160
  ],
  "DELL_SPI_PART_WINBOND_GUID": [
    3291682642,
    35756,
    20266,
    169,
    195,
    65,
    138,
    223,
    176,
    51,
    196
  ],
  "DELL_DA_ASSET_TAG_GUID": [
    3301417385,
    54841,
    17453,
    179,
    88,
    9,
    208,
    106,
    225,
    139,
    252
  ],
  "DELL_IDE_RCONTROLLER_GUID": [
    3304247303,
    14333,
    16941,
    182,
    61,
    126,
    215,
    56,
    134,
    230,
    202
  ],
  "DELL_PBA_USH_GUID": [
    3327848673,
    33459,
    16746,
    143,
    10,
    221,
    208,
    211,
    9,
    140,
    88
  ],
  "DELL_LEGACY_TCG_SUPPORT_GUID": [
    3330062921,
    46022,
    19642,
    150,
    113,
    191,
    39,
    136,
    113,
    33,
    40
  ],
  "DELL_SMB_STRUC_B2_CONFIG_GUID": [
    3350273852,
    35305,
    17503,
    169,
    114,
    103,
    27,
    139,
    23,
    88,
    13
  ],
  "DELL_TDT_AM_GUID": [
    3356510302,
    53484,
    20120,
    170,
    181,
    18,
    12,
    126,
    85,
    68,
    40
  ],
  "DELL_HOT_KEYS_CONFIG_GUID": [
    3361833421,
    45964,
    18909,
    161,
    118,
    125,
    195,
    89,
    24,
    22,
    169
  ],
  "DELL_SMM_EVENT_SMM_GUID": [
    3363683096,
    39645,
    16853,
    128,
    215,
    76,
    141,
    121,
    90,
    217,
    66
  ],
  "DELL_DASH_CONFIG_GUID": [
    3365727239,
    50414,
    17420,
    191,
    197,
    162,
    47,
    67,
    55,
    47,
    34
  ],
  "DELL_SMM_MULTI_PLATFORM_GUID": [
    3386494532,
    28813,
    20007,
    185,
    137,
    227,
    90,
    51,
    153,
    156,
    40
  ],
  "DELL_RUNTIME_GUID": [
    3418725450,
    14394,
    16875,
    168,
    238,
    68,
    152,
    174,
    165,
    103,
    228
  ],
  "DELL_SM_BIOS_STRUC_D2_GUID": [
    3435955970,
    48488,
    17841,
    130,
    55,
    199,
    221,
    0,
    76,
    219,
    55
  ],
  "DELL_CSP_LIB_DXE_GUID": [
    3448002092,
    26724,
    16547,
    160,
    129,
    200,
    211,
    94,
    130,
    185,
    32
  ],
  "DELL_TCG_SMM_GUID": [
    3451984617,
    487,
    17099,
    136,
    235,
    253,
    255,
    216,
    129,
    152,
    147
  ],
  "DELL_SMBIOS_BOARD_GUID": [
    3472264294,
    1707,
    20403,
    163,
    237,
    95,
    250,
    136,
    91,
    87,
    37
  ],
  "DELL_SMM_BASE_GUID": [
    3496160400,
    45015,
    17554,
    177,
    134,
    37,
    124,
    99,
    20,
    60,
    97
  ],
  "DELL_SLP_MARKER_CTRL_GUID": [
    3511775422,
    54546,
    18580,
    184,
    99,
    157,
    14,
    111,
    245,
    197,
    97
  ],
  "DELL_THROTTLING_DRIVER_GUID": [
    3564284724,
    36385,
    17219,
    139,
    255,
    1,
    236,
    222,
    41,
    35,
    117
  ],
  "DELL_TERMINAL_PLATFORM_POLICY_GUID": [
    3567753741,
    46717,
    20099,
    142,
    251,
    69,
    89,
    36,
    55,
    41,
    52
  ],
  "DELL_DIAGS_SMM_GUID": [
    3568703808,
    29611,
    18597,
    158,
    38,
    83,
    164,
    202,
    74,
    44,
    55
  ],
  "DELL_HDD_SMART_SMM_GUID": [
    3592121466,
    25914,
    17833,
    138,
    243,
    99,
    168,
    165,
    7,
    102,
    57
  ],
  "DELL_PCH_POLICY_INIT_DXE_GUID": [
    3601615554,
    35778,
    19677,
    135,
    118,
    40,
    14,
    20,
    105,
    222,
    2
  ],
  "DELL_NB_CONFIG_DXE_GUID": [
    3607159740,
    17041,
    18249,
    135,
    175,
    67,
    42,
    2,
    61,
    230,
    88
  ],
  "DELL_I_AMTDXE_GUID": [
    3610900841,
    64301,
    19394,
    175,
    231,
    8,
    19,
    39,
    211,
    254,
    222
  ],
  "DELL_AMT_WRAPPER_DXE_GUID": [
    3615264781,
    41415,
    16837,
    185,
    137,
    12,
    61,
    55,
    252,
    164,
    50
  ],
  "DELL_PHYSICAL_PRESENCE_GUID": [
    3629795852,
    11891,
    17553,
    146,
    225,
    220,
    239,
    195,
    136,
    42,
    104
  ],
  "DELL_SMM_GPIO_CONTROL_GUID": [
    3644366586,
    11418,
    18070,
    139,
    182,
    252,
    95,
    57,
    141,
    141,
    243
  ],
  "DELL_SM_BIOS_STRUC_D9_GUID": [
    3654093472,
    49679,
    18448,
    153,
    158,
    217,
    145,
    253,
    4,
    132,
    217
  ],
  "DELL_STORAGE_AGENTS_SMM_GUID": [
    3661961974,
    35025,
    20439,
    184,
    110,
    68,
    188,
    71,
    238,
    31,
    126
  ],
  "DELL_SMB_BBS_INFO_GUID": [
    3698353148,
    57373,
    18287,
    155,
    243,
    222,
    1,
    8,
    132,
    188,
    83
  ],
  "DELL_SM_BIOS_STRUC_B2_GUID": [
    3701255400,
    35886,
    20455,
    158,
    65,
    225,
    140,
    117,
    254,
    155,
    102
  ],
  "DELL_TDT_DXE_GUID": [
    3702147936,
    16527,
    19373,
    153,
    185,
    184,
    128,
    212,
    239,
    9,
    80
  ],
  "DELL_SA_INIT_DXE_GUID": [
    3726879982,
    53077,
    20406,
    170,
    119,
    152,
    74,
    181,
    61,
    232,
    17
  ],
  "DELL_PCH_INIT_DXE_GUID": [
    3726879982,
    53077,
    20406,
    170,
    119,
    152,
    74,
    181,
    61,
    232,
    35
  ],
  "DELL_SMBIOS_GET_FLASH_DATA64_GUID": [
    3738670445,
    32288,
    20256,
    145,
    161,
    25,
    4,
    57,
    176,
    77,
    91
  ],
  "DELL_IDE_DXE_GUID": [
    3741056122,
    52226,
    16933,
    136,
    173,
    60,
    65,
    230,
    33,
    120,
    91
  ],
  "DELL_MFG_MODE_DXE_DRIVER_GUID": [
    3756519012,
    54525,
    17444,
    191,
    31,
    133,
    218,
    82,
    66,
    54,
    251
  ],
  "DELL_DA_OWNER_TAG_GUID": [
    3757369032,
    9036,
    17726,
    169,
    45,
    250,
    80,
    94,
    144,
    213,
    57
  ],
  "DELL_DA_BFA_GUID": [
    3761655790,
    5184,
    19009,
    173,
    62,
    80,
    224,
    177,
    6,
    168,
    61
  ],
  "DELL_CPU_DXE_GUID": [
    3761945311,
    58678,
    20104,
    179,
    160,
    183,
    127,
    120,
    235,
    52,
    254
  ],
  "DELL_PCH_SMBUS_DXE_GUID": [
    3763525798,
    8778,
    19506,
    141,
    55,
    46,
    10,
    225,
    98,
    54,
    77
  ],
  "DELL_DA_PASSWORDS_GUID": [
    3775216056,
    7221,
    19332,
    133,
    147,
    129,
    85,
    93,
    6,
    93,
    213
  ],
  "DELL_SLP_CONFIG_GUID": [
    3805262678,
    14761,
    18811,
    182,
    177,
    149,
    185,
    210,
    235,
    40,
    23
  ],
  "DELL_DXE_SB_GPIO_CONTROL_GUID": [
    3808813313,
    37178,
    19025,
    142,
    14,
    180,
    97,
    140,
    93,
    179,
    38
  ],
  "DELL_SMB_DA_TOKENS_CONFIG_GUID": [
    3816052554,
    10975,
    17371,
    167,
    120,
    136,
    167,
    95,
    192,
    128,
    38
  ],
  "DELL_OEM_BADGING_SUPPORT_GUID": [
    3818072628,
    22313,
    20260,
    159,
    177,
    215,
    64,
    155,
    69,
    106,
    21
  ],
  "DELL_SMM_CIRC_BUFF_GUID": [
    3823991841,
    40376,
    18375,
    142,
    125,
    125,
    185,
    127,
    226,
    6,
    62
  ],
  "DELL_POWER_BUTTON_GUID": [
    3848712343,
    17272,
    18527,
    145,
    208,
    28,
    9,
    124,
    25,
    12,
    226
  ],
  "DELL_ASF_TABLE_GUID": [
    3877971919,
    20571,
    19280,
    153,
    205,
    163,
    36,
    103,
    250,
    74,
    164
  ],
  "DELL_RUNTIME_ACPI_SMM_GUID": [
    3883815845,
    42424,
    17884,
    186,
    235,
    102,
    200,
    111,
    26,
    200,
    17
  ],
  "DELL_TAGS_CONFIG_GUID": [
    3892811838,
    54118,
    16585,
    132,
    106,
    14,
    215,
    230,
    2,
    44,
    150
  ],
  "DELL_SM_BIOS_STRUC_FAN_GUID": [
    3916771658,
    5220,
    16671,
    133,
    228,
    4,
    29,
    144,
    60,
    182,
    196
  ],
  "DELL_SMM_ASF_INIT_GUID": [
    3950562942,
    16647,
    20213,
    134,
    203,
    34,
    232,
    216,
    172,
    73,
    80
  ],
  "DELL_SM_BIOS_STRUC_D8_GUID": [
    3973583987,
    1331,
    18500,
    188,
    119,
    72,
    240,
    222,
    39,
    81,
    155
  ],
  "DELL_SM_BIOS_MEMORY_GUID": [
    3986920450,
    62325,
    17558,
    146,
    211,
    131,
    180,
    60,
    184,
    167,
    106
  ],
  "DELL_S3_RESUME_GUID": [
    4023800524,
    3737,
    16624,
    150,
    192,
    224,
    140,
    8,
    144,
    112,
    252
  ],
  "DELL_DXE_DIAG_LEDS_GUID": [
    4040744618,
    50325,
    16697,
    177,
    252,
    120,
    183,
    1,
    104,
    38,
    10
  ],
  "DELL_WARM_BOOT_SMM_GUID": [
    4043307108,
    33876,
    18149,
    159,
    43,
    207,
    20,
    240,
    164,
    26,
    72
  ],
  "DELL_BOOT_SCRIPT_SMI_HANDLER_GUID": [
    4053894950,
    64889,
    19957,
    163,
    38,
    226,
    11,
    140,
    196,
    107,
    6
  ],
  "DELL_TPM_SMM_GUID": [
    4078416539,
    32201,
    16660,
    144,
    134,
    215,
    19,
    126,
    244,
    241,
    24
  ],
  "DELL_DXE_SIO_EMI_GUID": [
    4078728889,
    2901,
    17494,
    153,
    254,
    80,
    169,
    197,
    236,
    17,
    108
  ],
  "DELL_GT2_LEGACY_VIDEO_ROM_GUID": [
    4132371130,
    53417,
    17091,
    181,
    232,
    57,
    27,
    72,
    100,
    123,
    241
  ],
  "DELL_SM_BIOS_STRUC_THERM_GUID": [
    4140673760,
    45825,
    16898,
    137,
    246,
    134,
    35,
    230,
    174,
    210,
    110
  ],
  "DELL_VIDEO_CONFIG_DXE_GUID": [
    4158125896,
    52446,
    18463,
    155,
    134,
    46,
    245,
    237,
    172,
    194,
    29
  ],
  "DELL_SMB_RUN_ROM_GUID": [
    4173021602,
    18526,
    19357,
    136,
    207,
    21,
    30,
    98,
    248,
    77,
    222
  ],
  "DELL_BBSMANAGER_SMM_GUID": [
    4178613140,
    58787,
    20065,
    177,
    104,
    220,
    52,
    213,
    52,
    69,
    30
  ],
  "DELL_PHYSICAL_PRESENCE_SMM_GUID": [
    4181065499,
    45040,
    16627,
    183,
    122,
    183,
    149,
    167,
    167,
    215,
    20
  ],
  "DELL_ME_LOCAL_FW_UPDATE_DXE_GUID": [
    4182422346,
    32873,
    19103,
    173,
    8,
    149,
    52,
    239,
    55,
    217,
    190
  ],
  "DELL_PCI_SERIAL_GUID": [
    4212403097,
    57175,
    18123,
    188,
    105,
    11,
    248,
    88,
    167,
    52,
    249
  ],
  "DELL_PCH_SERIAL_GPIO_GUID": [
    4229658176,
    13414,
    19462,
    177,
    204,
    28,
    147,
    83,
    148,
    181,
    194
  ],
  "DELL_SMI_CPU_DECODE_GUID": [
    4236726303,
    63239,
    18850,
    182,
    118,
    119,
    113,
    125,
    217,
    4,
    220
  ],
  "DELL_SMM_S3_GUID": [
    160950128,
    30062,
    16697,
    191,
    63,
    127,
    194,
    163,
    8,
    23,
    126
  ],
  "DELL_CPU_PEI_BEFORE_MEM_GUID": [
    357936371,
    48391,
    18053,
    182,
    104,
    168,
    105,
    69,
    164,
    18,
    77
  ],
  "DELL_WDT_PEI_GUID": [
    495502658,
    40439,
    16970,
    170,
    144,
    2,
    182,
    31,
    40,
    105,
    56
  ],
  "DELL_PEI_HWM_INIT_GUID": [
    572352352,
    19136,
    19474,
    186,
    150,
    156,
    99,
    228,
    217,
    193,
    200
  ],
  "DELL_CPU_PEI_GUID": [
    733327273,
    65331,
    16763,
    132,
    151,
    203,
    119,
    60,
    43,
    147,
    191
  ],
  "DELL_AUDIO_CONFIG_PEI_GUID": [
    862772714,
    43816,
    19532,
    159,
    100,
    95,
    224,
    57,
    31,
    235,
    184
  ],
  "DELL_TCG_PEI_GUID": [
    882417038,
    37642,
    19093,
    171,
    4,
    46,
    108,
    253,
    255,
    102,
    49
  ],
  "DELL_MEMORY_INIT_GUID": [
    994242391,
    5843,
    17611,
    134,
    50,
    159,
    219,
    6,
    180,
    20,
    81
  ],
  "DELL_ALERT_STANDARD_FORMAT_PEI_GUID": [
    1044912125,
    10050,
    17233,
    181,
    159,
    145,
    73,
    50,
    128,
    50,
    156
  ],
  "DELL_AMT_CONFIG_PEI_GUID": [
    1240117670,
    44847,
    16484,
    155,
    41,
    217,
    101,
    91,
    59,
    141,
    237
  ],
  "DELL_OP_PRESENCE_GUID": [
    1340568296,
    65086,
    16518,
    182,
    56,
    140,
    73,
    60,
    73,
    4,
    136
  ],
  "DELL_START_WATCH_DOG_GUID": [
    1417273500,
    11892,
    18459,
    137,
    248,
    176,
    23,
    46,
    56,
    141,
    31
  ],
  "DELL_ERROR_HANDLER_PEI_GUID": [
    1495580163,
    40408,
    19371,
    128,
    143,
    194,
    28,
    171,
    254,
    11,
    75
  ],
  "DELL_PCH_SMBUS_ARP_DISABLED_GUID": [
    1681782647,
    62226,
    17133,
    129,
    204,
    27,
    31,
    87,
    225,
    138,
    214
  ],
  "DELL_PCH_USB_GUID": [
    1800395730,
    18401,
    18953,
    186,
    142,
    142,
    4,
    31,
    32,
    139,
    149
  ],
  "DELL_TCG_PEI2_GUID": [
    1894142482,
    62381,
    18783,
    179,
    161,
    122,
    99,
    84,
    46,
    215,
    213
  ],
  "DELL_SB_POWER_OFF_PEI_GUID": [
    2035578841,
    6022,
    19850,
    139,
    137,
    63,
    167,
    98,
    63,
    126,
    248
  ],
  "DELL_CMOS_MANAGER_PEI_SRC_GUID": [
    2104986061,
    64800,
    19461,
    165,
    121,
    145,
    37,
    61,
    94,
    61,
    158
  ],
  "DELL_MFG_MODE_PEI_DRIVER_GUID": [
    2180037874,
    61869,
    19934,
    158,
    91,
    117,
    235,
    52,
    39,
    171,
    196
  ],
  "DELL_CORE_PEI_GUID": [
    2456312131,
    55312,
    18431,
    161,
    18,
    204,
    132,
    144,
    119,
    106,
    31
  ],
  "DELL_HECI_PEI_GUID": [
    2633171749,
    56412,
    17750,
    168,
    176,
    116,
    33,
    92,
    95,
    127,
    196
  ],
  "DELL_AUDIO_PEI_GUID": [
    2698503429,
    24020,
    17497,
    164,
    211,
    54,
    17,
    149,
    99,
    196,
    249
  ],
  "DELL_FLASH_UPDATE_PEI_GUID": [
    2726198370,
    9375,
    19323,
    189,
    92,
    128,
    114,
    2,
    3,
    93,
    236
  ],
  "DELL_WARM_BOOT_PEI_GUID": [
    2977490346,
    2166,
    16906,
    180,
    15,
    227,
    155,
    78,
    110,
    224,
    91
  ],
  "DELL_PEI_MAIN_GUID": [
    2981029912,
    47449,
    18555,
    167,
    149,
    22,
    194,
    165,
    76,
    179,
    110
  ],
  "DELL_DO_SIODIAG_LED_PEI_GUID": [
    3062824394,
    48866,
    19446,
    184,
    110,
    69,
    220,
    60,
    203,
    254,
    60
  ],
  "DELL_PCH_ME_UMA_GUID": [
    3064115187,
    30332,
    22104,
    195,
    122,
    209,
    200,
    46,
    247,
    101,
    67
  ],
  "DELL_PEI_DIAG_LEDS_GUID": [
    3355234115,
    22617,
    19134,
    188,
    181,
    76,
    22,
    38,
    237,
    139,
    3
  ],
  "DELL_TXT_PEI_GUID": [
    3399321111,
    54866,
    16443,
    182,
    197,
    186,
    71,
    87,
    1,
    22,
    173
  ],
  "DELL_TXT_CONFIG_PEI_GUID": [
    3451279361,
    18765,
    18222,
    166,
    168,
    175,
    245,
    183,
    110,
    141,
    31
  ],
  "DELL_PEI_SIO_EMI_GUID": [
    3493973952,
    30320,
    17242,
    165,
    18,
    244,
    92,
    146,
    59,
    40,
    93
  ],
  "DELL_SYSTEM_ID_CONFIG_PEI_GUID": [
    3733609004,
    55176,
    18427,
    160,
    181,
    32,
    202,
    142,
    88,
    223,
    236
  ],
  "DELL_NB_CONFIG_PEI_GUID": [
    3844102995,
    38744,
    17579,
    164,
    77,
    219,
    59,
    228,
    29,
    103,
    66
  ],
  "DELL_DIRTY_SHUTDOWN_PEI_GUID": [
    3848613761,
    60425,
    18332,
    186,
    255,
    231,
    86,
    241,
    130,
    144,
    22
  ],
  "DELL_SIO_POLICY_CONFIG_PEI_GUID": [
    3880245503,
    6036,
    18630,
    150,
    215,
    164,
    25,
    217,
    198,
    15,
    17
  ],
  "DELL_ACLOSS_PEI_GUID": [
    3919974292,
    31371,
    17850,
    156,
    50,
    52,
    133,
    82,
    107,
    87,
    22
  ],
  "DELL_SB_CONFIG_PEI_GUID": [
    3921022868,
    31243,
    18637,
    156,
    136,
    132,
    132,
    82,
    108,
    87,
    25
  ],
  "DELL_VIDEO_CONFIG_PEI_GUID": [
    4133865501,
    61406,
    19295,
    136,
    232,
    33,
    96,
    183,
    72,
    210,
    180
  ],
  "DELL_EC_CONFIG_PEI_GUID": [
    4219737527,
    60030,
    20077,
    147,
    129,
    0,
    92,
    59,
    209,
    218,
    215
  ],
  "DELL_SA_INIT_PEIM_GUID": [
    4246956775,
    1937,
    18628,
    178,
    158,
    41,
    189,
    238,
    225,
    168,
    17
  ],
  "DELL_PCH_INIT_PEIM_GUID": [
    4246956775,
    1937,
    18628,
    178,
    158,
    41,
    189,
    238,
    225,
    168,
    56
  ],
  "ARM_TOKEN_SPACE_GUID": [
    3138514174,
    33295,
    18792,
    187,
    166,
    247,
    106,
    254,
    48,
    37,
    150
  ],
  "ARM_MP_CORE_INFO_GUID": [
    2767062824,
    58839,
    19141,
    178,
    30,
    101,
    142,
    216,
    87,
    232,
    52
  ],
  "ARM_SCMI_BASE_PROTOCOL_GUID": [
    3622153193,
    13227,
    16782,
    159,
    145,
    114,
    218,
    226,
    186,
    142,
    47
  ],
  "ARM_SCMI_CLOCK_PROTOCOL_GUID": [
    2446223272,
    57514,
    16402,
    185,
    159,
    182,
    252,
    243,
    4,
    142,
    170
  ],
  "ARM_SCMI_CLOCK2_PROTOCOL_GUID": [
    3101215474,
    40596,
    17964,
    168,
    52,
    108,
    153,
    252,
    5,
    239,
    207
  ],
  "ARM_SCMI_PERFORMANCE_PROTOCOL_GUID": [
    163101316,
    15827,
    18854,
    160,
    90,
    49,
    52,
    165,
    240,
    123,
    173
  ],
  "ARM_MP_CORE_INFO_PPI_GUID": [
    1749535860,
    59884,
    20367,
    162,
    157,
    171,
    68,
    231,
    84,
    168,
    252
  ],
  "ARM_PLATFORM_TOKEN_SPACE_GUID": [
    2617945812,
    29893,
    16451,
    180,
    23,
    163,
    34,
    56,
    20,
    206,
    118
  ],
  "EARLY_P_L011_BASE_ADDRESS_GUID": [
    2979651241,
    64860,
    19076,
    128,
    130,
    47,
    65,
    112,
    120,
    3,
    5
  ],
  "ARM_VIRT_VARIABLE_GUID": [
    1354670565,
    41669,
    18153,
    155,
    58,
    89,
    89,
    101,
    22,
    176,
    10
  ],
  "FDT_CLIENT_PROTOCOL_GUID": [
    3776949408,
    18192,
    19598,
    167,
    162,
    1,
    186,
    162,
    89,
    27,
    76
  ],
  "EDKII_CONFIGURATION_MANAGER_PROTOCOL_GUID": [
    3629795381,
    23170,
    18580,
    172,
    2,
    112,
    111,
    67,
    213,
    151,
    142
  ],
  "EDKII_DYNAMIC_TABLE_FACTORY_PROTOCOL_GUID": [
    2446451495,
    65114,
    18872,
    171,
    101,
    14,
    206,
    45,
    219,
    69,
    236
  ],
  "EMBEDDED_TOKEN_SPACE_GUID": [
    3772303895,
    17014,
    17286,
    187,
    121,
    72,
    203,
    129,
    61,
    60,
    79
  ],
  "FDT_TABLE_GUID": [
    2981503445,
    61852,
    16805,
    131,
    11,
    217,
    21,
    44,
    105,
    170,
    224
  ],
  "FDT_HOB_GUID": [
    378897478,
    6583,
    18443,
    176,
    71,
    116,
    133,
    173,
    63,
    113,
    109
  ],
  "FDT_VARIABLE_GUID": [
    631569738,
    38659,
    19369,
    161,
    144,
    183,
    200,
    78,
    251,
    62,
    87
  ],
  "EDKII_PLATFORM_HAS_DEVICE_TREE_GUID": [
    2126221837,
    6831,
    18137,
    178,
    175,
    84,
    30,
    29,
    206,
    20,
    139
  ],
  "DT_PLATFORM_FORM_SET_GUID": [
    729424909,
    54701,
    20438,
    190,
    28,
    223,
    164,
    65,
    95,
    85,
    38
  ],
  "DT_PLATFORM_DEFAULT_DTB_FILE_GUID": [
    625355994,
    8735,
    18399,
    172,
    29,
    37,
    156,
    250,
    164,
    227,
    38
  ],
  "CONSOLE_PREF_FORM_SET_GUID": [
    757291188,
    59756,
    18509,
    178,
    221,
    124,
    46,
    223,
    199,
    213,
    111
  ],
  "EDKII_NV_VAR_STORE_FORMATTED_GUID": [
    3517476415,
    1799,
    19509,
    131,
    205,
    220,
    44,
    41,
    200,
    145,
    163
  ],
  "HARDWARE_INTERRUPT_PROTOCOL_GUID": [
    680571882,
    1341,
    5699,
    173,
    12,
    214,
    72,
    8,
    218,
    63,
    241
  ],
  "HARDWARE_INTERRUPT2_PROTOCOL_GUID": [
    847872802,
    11681,
    18250,
    186,
    170,
    243,
    247,
    207,
    86,
    148,
    112
  ],
  "EMBEDDED_EXTERNAL_DEVICE_PROTOCOL_GUID": [
    1935641700,
    54934,
    17616,
    189,
    242,
    68,
    127,
    208,
    90,
    84,
    6
  ],
  "EMBEDDED_GPIO_PROTOCOL_GUID": [
    396403671,
    49317,
    17973,
    187,
    213,
    7,
    33,
    135,
    223,
    226,
    238
  ],
  "PE_COFF_LOADER_PROTOCOL_GUID": [
    3005421467,
    38907,
    18302,
    176,
    254,
    216,
    133,
    145,
    250,
    17,
    171
  ],
  "EFI_MMC_HOST_PROTOCOL_GUID": [
    1046027264,
    40522,
    4575,
    146,
    68,
    0,
    2,
    165,
    213,
    197,
    27
  ],
  "ANDROID_FASTBOOT_TRANSPORT_PROTOCOL_GUID": [
    1958584288,
    35074,
    4579,
    185,
    211,
    247,
    34,
    56,
    252,
    154,
    49
  ],
  "ANDROID_FASTBOOT_PLATFORM_PROTOCOL_GUID": [
    1380353440,
    35232,
    4579,
    157,
    77,
    191,
    169,
    246,
    164,
    3,
    8
  ],
  "USB_DEVICE_PROTOCOL_GUID": [
    35377866,
    20946,
    4579,
    142,
    86,
    183,
    84,
    23,
    199,
    11,
    68
  ],
  "PLATFORM_BOOT_MANAGER_PROTOCOL_GUID": [
    1905772711,
    25945,
    19603,
    147,
    213,
    138,
    132,
    249,
    136,
    121,
    139
  ],
  "PLATFORM_GPIO_PROTOCOL_GUID": [
    1389271109,
    23284,
    17378,
    186,
    253,
    35,
    8,
    18,
    84,
    122,
    194
  ],
  "PLATFORM_VIRTUAL_KEYBOARD_PROTOCOL_GUID": [
    238421714,
    7619,
    20079,
    190,
    101,
    57,
    73,
    130,
    162,
    101,
    71
  ],
  "ANDROID_BOOT_IMG_PROTOCOL_GUID": [
    2556017433,
    16508,
    20363,
    188,
    225,
    248,
    218,
    101,
    101,
    244,
    165
  ],
  "EDKII_EMBEDDED_GPIO_PPI_GUID": [
    566472981,
    19979,
    18188,
    133,
    199,
    225,
    5,
    165,
    117,
    201,
    123
  ],
  "EMU_THUNK_PROTOCOL_GUID": [
    1559440907,
    36575,
    11844,
    156,
    218,
    147,
    32,
    94,
    153,
    236,
    28
  ],
  "EMU_IO_THUNK_PROTOCOL_GUID": [
    1160997110,
    31877,
    17226,
    169,
    138,
    114,
    209,
    183,
    255,
    169,
    38
  ],
  "EMU_GRAPHICS_WINDOW_PROTOCOL_GUID": [
    821899626,
    26408,
    11841,
    166,
    144,
    13,
    19,
    51,
    216,
    202,
    193
  ],
  "EMU_THREAD_THUNK_PROTOCOL_GUID": [
    991841148,
    2520,
    37967,
    164,
    8,
    19,
    9,
    235,
    139,
    68,
    39
  ],
  "EMU_BLOCK_IO_PROTOCOL_GUID": [
    1753785518,
    45006,
    59467,
    145,
    2,
    247,
    185,
    218,
    230,
    160,
    48
  ],
  "EMU_SNP_PROTOCOL_GUID": [
    4250910292,
    35893,
    45893,
    138,
    15,
    122,
    200,
    165,
    253,
    5,
    33
  ],
  "EMU_THUNK_PPI_GUID": [
    3109599116,
    7486,
    60992,
    139,
    244,
    240,
    99,
    45,
    6,
    57,
    22
  ],
  "EMULATOR_PKG_TOKEN_SPACE_GUID": [
    1333341800,
    59592,
    31054,
    177,
    216,
    55,
    3,
    243,
    242,
    213,
    165
  ],
  "EMU_SYSTEM_CONFIG_GUID": [
    4167197029,
    27883,
    37450,
    186,
    252,
    241,
    58,
    185,
    214,
    87,
    40
  ],
  "FMP_DEVICE_PKG_TOKEN_SPACE_GUID": [
    1085462884,
    65041,
    16604,
    130,
    131,
    46,
    251,
    218,
    41,
    83,
    86
  ],
  "EDKII_CAPSULE_UPDATE_POLICY_PROTOCOL_GUID": [
    1215792325,
    25241,
    19366,
    176,
    150,
    92,
    197,
    39,
    124,
    247,
    87
  ],
  "FSP_READY_FOR_NOTIFY_PHASE_PPI_GUID": [
    3440802846,
    28171,
    17075,
    130,
    246,
    227,
    233,
    6,
    25,
    152,
    16
  ],
  "FSP_IN_API_MODE_PPI_GUID": [
    2716773255,
    51289,
    18333,
    137,
    181,
    20,
    97,
    244,
    6,
    26,
    62
  ],
  "FSPM_ARCH_CONFIG_PPI_GUID": [
    2186107450,
    44946,
    19468,
    159,
    25,
    25,
    82,
    109,
    202,
    74,
    187
  ],
  "FSP_TEMP_RAM_EXIT_PPI_GUID": [
    3156016091,
    32336,
    17086,
    180,
    135,
    34,
    224,
    169,
    12,
    176,
    82
  ],
  "INTEL_FSP2_PKG_TOKEN_SPACE_GUID": [
    3983410481,
    63253,
    19005,
    155,
    18,
    193,
    202,
    94,
    246,
    152,
    162
  ],
  "FSP_HEADER_FILE_GUID": [
    2435268798,
    8836,
    18228,
    185,
    113,
    132,
    176,
    39,
    53,
    63,
    12
  ],
  "FSP_RESERVED_MEMORY_RESOURCE_HOB_GUID": [
    1772590937,
    4979,
    17255,
    166,
    196,
    199,
    245,
    158,
    253,
    152,
    110
  ],
  "FSP_NON_VOLATILE_STORAGE_HOB_GUID": [
    1914359554,
    19831,
    19498,
    179,
    220,
    39,
    11,
    123,
    169,
    228,
    176
  ],
  "FSP_BOOT_LOADER_TOLUM_HOB_GUID": [
    1946111830,
    43662,
    17489,
    179,
    22,
    54,
    53,
    54,
    103,
    173,
    68
  ],
  "FSP_PERFORMANCE_DATA_GUID": [
    1458381238,
    47651,
    17054,
    137,
    50,
    55,
    109,
    142,
    24,
    46,
    227
  ],
  "FSP_EVENT_END_OF_FIRMWARE_GUID": [
    3175413289,
    60135,
    16792,
    135,
    241,
    57,
    250,
    176,
    253,
    113,
    126
  ],
  "INTEL_FSP2_WRAPPER_TOKEN_SPACE_GUID": [
    2739728514,
    3920,
    20237,
    137,
    138,
    61,
    57,
    48,
    43,
    197,
    30
  ],
  "FSP_API_PERFORMANCE_GUID": [
    3373408917,
    22253,
    19790,
    6,
    166,
    80,
    141,
    137,
    77,
    62,
    64
  ],
  "FSP_HOB_GUID": [
    1837562678,
    47760,
    18220,
    181,
    131,
    63,
    190,
    211,
    251,
    32,
    154
  ],
  "FSP_SILICON_INIT_DONE_PPI_GUID": [
    1320607900,
    53846,
    19998,
    181,
    10,
    135,
    75,
    210,
    132,
    179,
    222
  ],
  "TOP_OF_TEMPORARY_RAM_PPI_GUID": [
    792289970,
    22469,
    17644,
    158,
    252,
    166,
    159,
    211,
    2,
    3,
    43
  ],
  "ADD_PERF_RECORD_PROTOCOL_GUID": [
    3299183981,
    13943,
    18891,
    160,
    10,
    148,
    112,
    118,
    95,
    181,
    94
  ],
  "EFI_MDE_MODULE_PKG_TOKEN_SPACE_GUID": [
    2712662089,
    65003,
    17450,
    179,
    32,
    19,
    171,
    76,
    183,
    43,
    188
  ],
  "PCD_DATA_BASE_HOB_GUID": [
    3928583570,
    2921,
    16956,
    140,
    40,
    51,
    180,
    224,
    169,
    18,
    104
  ],
  "PCD_DATA_BASE_SIGNATURE_GUID": [
    1014831420,
    26668,
    19476,
    166,
    143,
    85,
    45,
    234,
    79,
    67,
    126
  ],
  "EDKII_IFR_BIT_VARSTORE_GUID": [
    2195576459,
    37219,
    16775,
    155,
    39,
    32,
    168,
    253,
    96,
    167,
    29
  ],
  "EFI_IFR_FRAMEWORK_GUID": [
    835345690,
    54545,
    18737,
    183,
    130,
    174,
    107,
    43,
    23,
    140,
    215
  ],
  "EDKII_WORKING_BLOCK_SIGNATURE_GUID": [
    2656577835,
    31848,
    18813,
    160,
    206,
    101,
    0,
    253,
    159,
    27,
    149
  ],
  "EDKII_FAULT_TOLERANT_WRITE_GUID": [
    490642616,
    17327,
    18699,
    131,
    10,
    53,
    22,
    170,
    83,
    32,
    71
  ],
  "EFI_MEMORY_TYPE_INFORMATION_GUID": [
    1276707999,
    16695,
    19923,
    156,
    16,
    139,
    151,
    168,
    63,
    253,
    250
  ],
  "EFI_VARIABLE_GUID": [
    3721344534,
    12917,
    16740,
    152,
    182,
    254,
    133,
    112,
    127,
    254,
    125
  ],
  "EFI_AUTHENTICATED_VARIABLE_GUID": [
    2868063352,
    38011,
    17306,
    161,
    128,
    46,
    20,
    78,
    195,
    119,
    146
  ],
  "EFI_VARIABLE_INDEX_TABLE_GUID": [
    2365438152,
    54962,
    16627,
    142,
    151,
    2,
    48,
    124,
    201,
    139,
    124
  ],
  "PERFORMANCE_PROTOCOL_GUID": [
    1991687674,
    10957,
    17506,
    158,
    63,
    203,
    88,
    201,
    105,
    217,
    55
  ],
  "SMM_PERFORMANCE_PROTOCOL_GUID": [
    4167443050,
    60069,
    20314,
    169,
    10,
    108,
    251,
    165,
    124,
    88,
    142
  ],
  "PERFORMANCE_EX_PROTOCOL_GUID": [
    514333676,
    61466,
    19864,
    162,
    1,
    74,
    97,
    206,
    47,
    192,
    34
  ],
  "SMM_PERFORMANCE_EX_PROTOCOL_GUID": [
    2468331592,
    50973,
    17493,
    137,
    48,
    71,
    6,
    48,
    227,
    14,
    229
  ],
  "EDKII_PERFORMANCE_MEASUREMENT_PROTOCOL_GUID": [
    3361539774,
    24437,
    18638,
    168,
    15,
    18,
    54,
    186,
    59,
    135,
    177
  ],
  "EDKII_SMM_PERFORMANCE_MEASUREMENT_PROTOCOL_GUID": [
    3580587379,
    6779,
    16405,
    155,
    180,
    123,
    7,
    23,
    41,
    237,
    36
  ],
  "STATUS_CODE_CALLBACK_GUID": [
    3875620236,
    18688,
    19621,
    183,
    114,
    61,
    55,
    148,
    159,
    121,
    39
  ],
  "MEMORY_STATUS_CODE_RECORD_GUID": [
    101498918,
    19469,
    19930,
    143,
    65,
    89,
    95,
    239,
    0,
    165,
    2
  ],
  "IDLE_LOOP_EVENT_GUID": [
    1015884108,
    24515,
    17489,
    187,
    49,
    196,
    192,
    50,
    41,
    94,
    108
  ],
  "RECOVERY_ON_FAT_NVME_DISK_GUID": [
    3346047615,
    38250,
    18810,
    133,
    72,
    224,
    97,
    151,
    88,
    139,
    246
  ],
  "EFI_SMM_LOCK_BOX_COMMUNICATION_GUID": [
    708640445,
    10216,
    19722,
    139,
    121,
    214,
    136,
    194,
    163,
    225,
    192
  ],
  "EFI_ACPI_S3_CONTEXT_GUID": [
    251235642,
    15923,
    18810,
    164,
    1,
    119,
    190,
    62,
    183,
    79,
    56
  ],
  "EFI_BOOT_SCRIPT_EXECUTOR_VARIABLE_GUID": [
    813269388,
    18132,
    19059,
    174,
    243,
    227,
    228,
    108,
    241,
    238,
    219
  ],
  "EFI_BOOT_SCRIPT_EXECUTOR_CONTEXT_GUID": [
    2043369668,
    44113,
    17455,
    175,
    215,
    152,
    228,
    125,
    46,
    153,
    8
  ],
  "USB_KEYBOARD_LAYOUT_PACKAGE_GUID": [
    202324803,
    17630,
    18695,
    180,
    120,
    34,
    95,
    111,
    98,
    137,
    220
  ],
  "USB_KEYBOARD_LAYOUT_KEY_GUID": [
    978156156,
    394,
    19266,
    129,
    179,
    220,
    16,
    227,
    181,
    145,
    189
  ],
  "DRIVER_SAMPLE_FORM_SET_GUID": [
    2689214452,
    57088,
    19778,
    181,
    82,
    57,
    81,
    19,
    2,
    17,
    61
  ],
  "DRIVER_SAMPLE_INVENTORY_GUID": [
    3019203696,
    24897,
    17953,
    143,
    25,
    112,
    78,
    87,
    122,
    169,
    232
  ],
  "EFI_IFR_REFRESH_ID_OP_GUID": [
    4125513177,
    678,
    18162,
    158,
    118,
    184,
    190,
    142,
    96,
    171,
    34
  ],
  "PLATFORM_OVERRIDES_MANAGER_GUID": [
    2249479805,
    13758,
    17429,
    141,
    136,
    189,
    125,
    12,
    156,
    112,
    192
  ],
  "MTC_VENDOR_GUID": [
    3950002193,
    5122,
    4563,
    142,
    119,
    0,
    160,
    201,
    105,
    114,
    59
  ],
  "EFI_FIRMWARE_PERFORMANCE_GUID": [
    3231021338,
    12289,
    18354,
    128,
    201,
    234,
    199,
    49,
    159,
    47,
    164
  ],
  "FIRMWARE_PERFORMANCE_S3_POINTER_GUID": [
    231103196,
    43379,
    16688,
    141,
    240,
    42,
    219,
    235,
    158,
    74,
    49
  ],
  "EVENT_EXIT_BOOT_SERVICES_FAILED_GUID": [
    1332499719,
    9007,
    18311,
    185,
    94,
    114,
    248,
    98,
    73,
    12,
    177
  ],
  "CONNECT_CON_IN_EVENT_GUID": [
    3679355217,
    22509,
    19437,
    136,
    51,
    103,
    81,
    181,
    209,
    168,
    215
  ],
  "EDKII_STATUS_CODE_DATA_TYPE_VARIABLE_GUID": [
    4142820795,
    54911,
    20128,
    139,
    150,
    106,
    113,
    177,
    157,
    132,
    173
  ],
  "EDKII_MEMORY_PROFILE_GUID": [
    2182912521,
    21530,
    16630,
    159,
    67,
    10,
    209,
    147,
    161,
    44,
    254
  ],
  "EDKII_SMM_MEMORY_PROFILE_GUID": [
    3794517194,
    20842,
    18088,
    128,
    226,
    103,
    69,
    232,
    54,
    147,
    189
  ],
  "EDKII_VAR_ERROR_FLAG_GUID": [
    78872552,
    63150,
    18443,
    189,
    213,
    55,
    217,
    140,
    94,
    137,
    170
  ],
  "BROTLI_CUSTOM_DECOMPRESS_GUID": [
    1028857936,
    23770,
    20432,
    135,
    158,
    15,
    127,
    99,
    13,
    90,
    251
  ],
  "LZMA_CUSTOM_DECOMPRESS_GUID": [
    3998111896,
    14612,
    16985,
    157,
    110,
    220,
    123,
    215,
    148,
    3,
    207
  ],
  "LZMA_F86_CUSTOM_DECOMPRESS_GUID": [
    3559581373,
    4946,
    19451,
    144,
    154,
    202,
    114,
    166,
    234,
    232,
    137
  ],
  "EFI_TTY_TERM_GUID": [
    2106682752,
    23473,
    17804,
    164,
    143,
    226,
    95,
    221,
    81,
    239,
    148
  ],
  "EDKII_LINUX_TERM_GUID": [
    3828763263,
    63525,
    17166,
    157,
    58,
    156,
    155,
    230,
    129,
    124,
    165
  ],
  "EDKII_XTERM_R6_GUID": [
    4227638635,
    47926,
    19320,
    170,
    171,
    190,
    27,
    151,
    236,
    124,
    203
  ],
  "EDKII_VT400_GUID": [
    2387008989,
    15689,
    19101,
    184,
    117,
    60,
    8,
    111,
    106,
    162,
    189
  ],
  "EDKII_SCO_TERM_GUID": [
    4236105440,
    33084,
    17229,
    180,
    218,
    59,
    214,
    73,
    233,
    225,
    90
  ],
  "EFI_IFR_BOOT_MAINTENANCE_GUID": [
    3000949905,
    54687,
    18642,
    137,
    138,
    18,
    73,
    12,
    116,
    164,
    224
  ],
  "EFI_IFR_FRONT_PAGE_GUID": [
    3850897912,
    64449,
    18658,
    136,
    58,
    163,
    15,
    220,
    75,
    68,
    30
  ],
  "RAM_DISK_FORM_SET_GUID": [
    709259615,
    13697,
    19029,
    142,
    115,
    43,
    118,
    154,
    170,
    48,
    197
  ],
  "EDKII_PI_SMM_COMMUNICATION_REGION_TABLE_GUID": [
    1311296080,
    54658,
    17580,
    161,
    31,
    227,
    213,
    101,
    38,
    219,
    52
  ],
  "EDKII_PI_SMM_MEMORY_ATTRIBUTES_TABLE_GUID": [
    1805636599,
    5855,
    17896,
    189,
    57,
    185,
    74,
    102,
    84,
    26,
    93
  ],
  "SMI_HANDLER_PROFILE_GUID": [
    1226261314,
    28936,
    16539,
    139,
    190,
    101,
    253,
    168,
    83,
    137,
    245
  ],
  "EDKII_NON_DISCOVERABLE_AHCI_DEVICE_GUID": [
    3352516504,
    58578,
    19091,
    177,
    69,
    84,
    136,
    159,
    2,
    88,
    75
  ],
  "EDKII_NON_DISCOVERABLE_AMBA_DEVICE_GUID": [
    2487485241,
    52371,
    17670,
    180,
    198,
    238,
    141,
    15,
    76,
    161,
    145
  ],
  "EDKII_NON_DISCOVERABLE_EHCI_DEVICE_GUID": [
    3941488149,
    3325,
    17916,
    135,
    105,
    160,
    216,
    86,
    149,
    175,
    133
  ],
  "EDKII_NON_DISCOVERABLE_NVME_DEVICE_GUID": [
    3320993090,
    10873,
    18982,
    129,
    187,
    78,
    166,
    50,
    51,
    179,
    9
  ],
  "EDKII_NON_DISCOVERABLE_OHCI_DEVICE_GUID": [
    2986345904,
    47917,
    18799,
    134,
    156,
    35,
    11,
    68,
    121,
    231,
    209
  ],
  "EDKII_NON_DISCOVERABLE_SDHCI_DEVICE_GUID": [
    500291097,
    63928,
    17982,
    134,
    129,
    209,
    220,
    124,
    7,
    183,
    44
  ],
  "EDKII_NON_DISCOVERABLE_UFS_DEVICE_GUID": [
    782727442,
    32936,
    18759,
    190,
    105,
    205,
    208,
    10,
    251,
    229,
    86
  ],
  "EDKII_NON_DISCOVERABLE_UHCI_DEVICE_GUID": [
    2832048290,
    20279,
    18971,
    142,
    16,
    142,
    243,
    204,
    59,
    243,
    168
  ],
  "EDKII_NON_DISCOVERABLE_XHCI_DEVICE_GUID": [
    2982022085,
    27688,
    17453,
    170,
    55,
    21,
    27,
    66,
    87,
    189,
    120
  ],
  "EDKII_PLATFORM_HAS_ACPI_GUID": [
    4036389697,
    49727,
    16825,
    150,
    4,
    15,
    247,
    225,
    17,
    150,
    90
  ],
  "EDKII_FPDT_EXTENDED_FIRMWARE_PERFORMANCE_GUID": [
    993557501,
    31420,
    19698,
    160,
    202,
    182,
    161,
    108,
    27,
    27,
    37
  ],
  "EDKII_END_OF_S3_RESUME_GUID": [
    2532649325,
    1527,
    20284,
    132,
    103,
    228,
    86,
    137,
    14,
    12,
    181
  ],
  "EDKII_S3_SMM_INIT_DONE_GUID": [
    2409449509,
    31101,
    18684,
    132,
    113,
    132,
    80,
    37,
    121,
    46,
    246
  ],
  "S3_STORAGE_DEVICE_INIT_LIST_GUID": [
    823040908,
    53136,
    16926,
    142,
    155,
    158,
    239,
    182,
    23,
    200,
    239
  ],
  "EDKII_SERIAL_PORT_LIB_VENDOR_GUID": [
    3549986123,
    38682,
    17247,
    140,
    175,
    73,
    103,
    235,
    98,
    114,
    65
  ],
  "EDKII_CAPSULE_ON_DISK_NAME_GUID": [
    2563246671,
    57707,
    19729,
    147,
    154,
    171,
    229,
    97,
    38,
    3,
    48
  ],
  "PEI_USB_HOST_CONTROLLER_PPI_GUID": [
    1697331369,
    30708,
    17727,
    137,
    213,
    231,
    189,
    195,
    82,
    252,
    83
  ],
  "PEI_USB2_HOST_CONTROLLER_PPI_GUID": [
    2815467489,
    29908,
    19365,
    132,
    124,
    18,
    237,
    91,
    25,
    173,
    228
  ],
  "PEI_USB_IO_PPI_GUID": [
    2083092572,
    26297,
    18940,
    183,
    151,
    28,
    165,
    85,
    14,
    242,
    131
  ],
  "PEI_SEC_PERFORMANCE_PPI_GUID": [
    248276587,
    18018,
    18425,
    157,
    213,
    208,
    150,
    255,
    125,
    164,
    158
  ],
  "EFI_PEI_SMM_COMMUNICATION_PPI_GUID": [
    2928885276,
    52295,
    20024,
    143,
    14,
    226,
    246,
    29,
    38,
    5,
    223
  ],
  "PEI_SERIAL_PORT_PPI_GUID": [
    1225694597,
    35567,
    16787,
    142,
    86,
    247,
    52,
    169,
    255,
    172,
    139
  ],
  "EDKII_PEI_UFS_HOST_CONTROLLER_PPI_GUID": [
    3696538243,
    6775,
    19670,
    131,
    187,
    253,
    218,
    70,
    154,
    46,
    198
  ],
  "PEI_IPMI_PPI_GUID": [
    2842891313,
    55656,
    17015,
    183,
    82,
    163,
    169,
    166,
    174,
    24,
    152
  ],
  "EDKII_PEI_SD_MMC_HOST_CONTROLLER_PPI_GUID": [
    3004038893,
    38015,
    17302,
    177,
    90,
    223,
    189,
    185,
    22,
    220,
    36
  ],
  "EDKII_IO_MMU_PPI_GUID": [
    1890627366,
    63559,
    19382,
    170,
    185,
    205,
    232,
    79,
    198,
    20,
    49
  ],
  "EDKII_PLATFORM_SPECIFIC_RESET_FILTER_PPI_GUID": [
    2359250403,
    31632,
    18415,
    147,
    8,
    40,
    124,
    236,
    214,
    109,
    232
  ],
  "EDKII_PLATFORM_SPECIFIC_RESET_NOTIFICATION_PPI_GUID": [
    3768530269,
    56040,
    18704,
    177,
    74,
    146,
    120,
    15,
    220,
    247,
    203
  ],
  "EDKII_PLATFORM_SPECIFIC_RESET_HANDLER_PPI_GUID": [
    1976505518,
    13377,
    18908,
    170,
    16,
    187,
    53,
    167,
    186,
    139,
    171
  ],
  "EDKII_PEI_NVM_EXPRESS_HOST_CONTROLLER_PPI_GUID": [
    3403917923,
    26479,
    19875,
    189,
    80,
    108,
    197,
    237,
    222,
    154,
    173
  ],
  "EDKII_PEI_ATA_AHCI_HOST_CONTROLLER_PPI_GUID": [
    1641886698,
    16927,
    19648,
    137,
    41,
    255,
    238,
    169,
    161,
    162,
    97
  ],
  "EDKII_PEI_STORAGE_SECURITY_COMMAND_PPI_GUID": [
    903744334,
    12539,
    18115,
    189,
    132,
    31,
    219,
    161,
    88,
    187,
    86
  ],
  "EDKII_PEI_ATA_PASS_THRU_PPI_GUID": [
    2707715069,
    54388,
    19593,
    174,
    199,
    144,
    184,
    60,
    115,
    134,
    9
  ],
  "EDKII_DEBUG_PPI_GUID": [
    2577295772,
    45075,
    18270,
    177,
    123,
    243,
    168,
    174,
    92,
    72,
    117
  ],
  "EDKII_PEI_NVM_EXPRESS_PASS_THRU_PPI_GUID": [
    1794317100,
    958,
    18113,
    177,
    45,
    234,
    74,
    54,
    223,
    167,
    76
  ],
  "EDKII_PEI_CAPSULE_ON_DISK_PPI_GUID": [
    1906960993,
    23093,
    19037,
    172,
    239,
    156,
    248,
    109,
    109,
    103,
    224
  ],
  "EDKII_PEI_BOOT_IN_CAPSULE_ON_DISK_MODE_PPI_GUID": [
    2961838564,
    58039,
    19317,
    181,
    21,
    175,
    97,
    6,
    104,
    191,
    209
  ],
  "EFI_LOAD_PE_IMAGE_PROTOCOL_GUID": [
    1555416950,
    24789,
    17902,
    136,
    60,
    69,
    39,
    8,
    205,
    116,
    63
  ],
  "EFI_PRINT2_PROTOCOL_GUID": [
    4032394991,
    33777,
    20285,
    134,
    25,
    247,
    89,
    93,
    65,
    229,
    56
  ],
  "EFI_PRINT_2S_PROTOCOL_GUID": [
    214061778,
    49414,
    18017,
    181,
    189,
    49,
    71,
    164,
    248,
    31,
    146
  ],
  "EFI_DEBUGGER_CONFIGURATION_PROTOCOL_GUID": [
    1467848092,
    59751,
    17734,
    134,
    32,
    199,
    120,
    250,
    229,
    218,
    5
  ],
  "EFI_SMM_FAULT_TOLERANT_WRITE_PROTOCOL_GUID": [
    946404411,
    32325,
    17319,
    144,
    108,
    75,
    164,
    125,
    225,
    117,
    77
  ],
  "EFI_SMM_SWAP_ADDRESS_RANGE_PROTOCOL_GUID": [
    1740960018,
    13189,
    20053,
    156,
    91,
    192,
    91,
    113,
    124,
    66,
    40
  ],
  "EDKII_VARIABLE_LOCK_PROTOCOL_GUID": [
    3443329541,
    40484,
    17276,
    168,
    145,
    30,
    224,
    83,
    219,
    118,
    56
  ],
  "EDKII_VAR_CHECK_PROTOCOL_GUID": [
    2938352448,
    38836,
    18053,
    141,
    79,
    163,
    242,
    129,
    105,
    178,
    29
  ],
  "EDKII_SMM_VAR_CHECK_PROTOCOL_GUID": [
    2967008193,
    47070,
    19473,
    188,
    137,
    47,
    181,
    98,
    200,
    196,
    17
  ],
  "EFI_SMM_FIRMWARE_VOLUME_BLOCK_PROTOCOL_GUID": [
    3542536257,
    48433,
    19457,
    181,
    168,
    98,
    139,
    232,
    127,
    6,
    83
  ],
  "EFI_LOCK_BOX_PROTOCOL_GUID": [
    3175374201,
    47021,
    20228,
    154,
    216,
    41,
    189,
    32,
    64,
    235,
    60
  ],
  "EFI_EBC_VM_TEST_PROTOCOL_GUID": [
    2867514621,
    62075,
    19479,
    182,
    16,
    117,
    202,
    31,
    45,
    251,
    82
  ],
  "EFI_EBC_SIMPLE_DEBUGGER_PROTOCOL_GUID": [
    712167710,
    29558,
    16630,
    156,
    104,
    35,
    250,
    47,
    227,
    99,
    241
  ],
  "EFI_BOOT_LOGO_PROTOCOL_GUID": [
    3454675923,
    64549,
    19484,
    185,
    124,
    179,
    17,
    134,
    6,
    73,
    144
  ],
  "EDKII_BOOT_LOGO2_PROTOCOL_GUID": [
    1264435679,
    7850,
    18610,
    167,
    233,
    234,
    196,
    137,
    160,
    11,
    92
  ],
  "EDKII_FORM_DISPLAY_ENGINE_PROTOCOL_GUID": [
    2612931049,
    64929,
    16876,
    173,
    82,
    69,
    34,
    19,
    116,
    45,
    46
  ],
  "EDKII_FORM_BROWSER_EX2_PROTOCOL_GUID": [
    2809185111,
    46739,
    20077,
    166,
    207,
    210,
    28,
    114,
    142,
    85,
    11
  ],
  "EDKII_UFS_HOST_CONTROLLER_PROTOCOL_GUID": [
    3955235573,
    1961,
    18590,
    183,
    206,
    220,
    8,
    158,
    69,
    155,
    47
  ],
  "EDKII_UFS_HC_PLATFORM_PROTOCOL_GUID": [
    1025030675,
    55729,
    19924,
    185,
    22,
    211,
    7,
    150,
    83,
    158,
    216
  ],
  "ESRT_MANAGEMENT_PROTOCOL_GUID": [
    2738929764,
    29244,
    19100,
    164,
    221,
    213,
    180,
    122,
    38,
    251,
    176
  ],
  "EDKII_SMM_EXIT_BOOT_SERVICES_PROTOCOL_GUID": [
    695120920,
    50376,
    19973,
    171,
    89,
    57,
    232,
    175,
    86,
    240,
    10
  ],
  "EDKII_SMM_LEGACY_BOOT_PROTOCOL_GUID": [
    2242423639,
    1604,
    16656,
    133,
    15,
    152,
    19,
    34,
    4,
    112,
    112
  ],
  "EDKII_SMM_READY_TO_BOOT_PROTOCOL_GUID": [
    1845853903,
    64153,
    20281,
    149,
    188,
    89,
    249,
    146,
    29,
    23,
    228
  ],
  "EDKII_PLATFORM_LOGO_PROTOCOL_GUID": [
    2605807992,
    60321,
    17639,
    186,
    101,
    124,
    44,
    208,
    139,
    248,
    233
  ],
  "EFI_FILE_EXPLORER_PROTOCOL_GUID": [
    738444598,
    17812,
    17685,
    158,
    122,
    211,
    210,
    4,
    254,
    19,
    99
  ],
  "IPMI_PROTOCOL_GUID": [
    3687200799,
    21844,
    19732,
    143,
    253,
    118,
    215,
    135,
    184,
    172,
    191
  ],
  "SMM_IPMI_PROTOCOL_GUID": [
    1365880672,
    35930,
    16963,
    179,
    233,
    86,
    197,
    109,
    24,
    238,
    38
  ],
  "EDKII_NON_DISCOVERABLE_DEVICE_PROTOCOL_GUID": [
    223449179,
    46974,
    17706,
    162,
    192,
    236,
    160,
    204,
    141,
    81,
    74
  ],
  "EDKII_IO_MMU_PROTOCOL_GUID": [
    1318297065,
    55624,
    19215,
    136,
    237,
    230,
    225,
    206,
    81,
    124,
    30
  ],
  "EDKII_DEVICE_SECURITY_PROTOCOL_GUID": [
    1567307976,
    21776,
    17496,
    180,
    141,
    149,
    129,
    207,
    167,
    176,
    13
  ],
  "EDKII_DEVICE_IDENTIFIER_TYPE_PCI_GUID": [
    621392625,
    40994,
    19658,
    175,
    112,
    249,
    211,
    33,
    251,
    102,
    73
  ],
  "EDKII_DEVICE_IDENTIFIER_TYPE_USB_GUID": [
    1939141456,
    14669,
    18572,
    187,
    117,
    12,
    171,
    123,
    18,
    10,
    197
  ],
  "EDKII_SMM_MEMORY_ATTRIBUTE_PROTOCOL_GUID": [
    1773638378,
    14798,
    16429,
    162,
    166,
    247,
    33,
    222,
    53,
    29,
    254
  ],
  "EDKII_SD_MMC_OVERRIDE_PROTOCOL_GUID": [
    3942245313,
    51661,
    18139,
    165,
    229,
    90,
    18,
    76,
    131,
    35,
    35
  ],
  "EDKII_PLATFORM_SPECIFIC_RESET_FILTER_PROTOCOL_GUID": [
    1767733301,
    36167,
    19473,
    171,
    34,
    250,
    138,
    204,
    231,
    174,
    122
  ],
  "EDKII_PLATFORM_SPECIFIC_RESET_HANDLER_PROTOCOL_GUID": [
    771144203,
    28818,
    17421,
    189,
    4,
    251,
    9,
    30,
    195,
    243,
    193
  ],
  "EDKII_FIRMWARE_MANAGEMENT_PROGRESS_PROTOCOL_GUID": [
    407485858,
    26962,
    20102,
    161,
    219,
    85,
    154,
    60,
    71,
    157,
    241
  ],
  "EDKII_ATA_ATAPI_POLICY_PROTOCOL_GUID": [
    3852261225,
    20611,
    20262,
    144,
    148,
    108,
    145,
    159,
    145,
    108,
    78
  ],
  "EDKII_PE_COFF_IMAGE_EMULATOR_PROTOCOL_GUID": [
    2532598099,
    38823,
    18323,
    172,
    193,
    250,
    25,
    191,
    120,
    234,
    151
  ],
  "EDKII_PLATFORM_BOOT_MANAGER_PROTOCOL_GUID": [
    2853678548,
    30060,
    17933,
    148,
    184,
    67,
    136,
    215,
    251,
    62,
    89
  ],
  "EFI_UART_DEVICE_PATH_GUID": [
    927570589,
    21551,
    19593,
    160,
    38,
    53,
    218,
    20,
    32,
    148,
    228
  ],
  "EFI_SAS_DEVICE_PATH_GUID": [
    3565673908,
    139,
    4569,
    175,
    220,
    0,
    16,
    131,
    255,
    202,
    77
  ],
  "EFI_AUTHENTICATION_CHAP_LOCAL_GUID": [
    3263219518,
    5578,
    4570,
    176,
    202,
    0,
    16,
    131,
    255,
    202,
    77
  ],
  "EFI_AUTHENTICATION_CHAP_RADIUS_GUID": [
    3590728528,
    5578,
    4570,
    146,
    25,
    0,
    16,
    131,
    255,
    202,
    77
  ],
  "EFI_FILE_INFO_GUID": [
    156724882,
    27967,
    4562,
    142,
    57,
    0,
    160,
    201,
    105,
    114,
    59
  ],
  "BOOT_OBJECT_AUTHORIZATION_PARMSET_GUID": [
    3990052401,
    1977,
    4562,
    131,
    163,
    0,
    160,
    201,
    31,
    173,
    207
  ],
  "EFI_HASH_ALGORITHM_M_D5_GUID": [
    184010652,
    26037,
    17177,
    176,
    174,
    68,
    236,
    72,
    78,
    74,
    215
  ],
  "EFI_EVENT_READY_TO_BOOT_GUID": [
    2095615923,
    19415,
    18041,
    135,
    168,
    168,
    216,
    222,
    229,
    13,
    43
  ],
  "EFI_EVENT_MEMORY_MAP_CHANGE_GUID": [
    2025777446,
    26927,
    18685,
    158,
    219,
    1,
    66,
    46,
    240,
    215,
    171
  ],
  "EFI_EVENT_VIRTUAL_ADDRESS_CHANGE_GUID": [
    335181464,
    51249,
    18887,
    135,
    234,
    143,
    67,
    252,
    194,
    81,
    150
  ],
  "EFI_EVENT_EXIT_BOOT_SERVICES_GUID": [
    665579605,
    45496,
    19494,
    128,
    72,
    116,
    143,
    55,
    186,
    162,
    223
  ],
  "EFI_DEBUG_PORT_DEVICE_PATH_GUID": [
    3953453266,
    14424,
    16876,
    162,
    129,
    38,
    71,
    186,
    150,
    96,
    208
  ],
  "EFI_HII_STANDARD_FORM_GUID": [
    1003681004,
    58660,
    18148,
    169,
    216,
    81,
    1,
    23,
    66,
    85,
    98
  ],
  "EFI_MEMORY_OVERWRITE_CONTROL_DATA_GUID": [
    3792255422,
    13012,
    16830,
    161,
    80,
    137,
    127,
    133,
    212,
    152,
    41
  ],
  "EFI_MEMORY_OVERWRITE_REQUEST_CONTROL_LOCK_GUID": [
    3147316431,
    5405,
    16609,
    160,
    123,
    74,
    23,
    190,
    22,
    130,
    146
  ],
  "EFI_EVENT_NOTIFICATION_TYPE_CMC_GUID": [
    768510897,
    48599,
    17678,
    185,
    173,
    156,
    244,
    235,
    212,
    248,
    144
  ],
  "EFI_EVENT_NOTIFICATION_TYPE_CPE_GUID": [
    1311322006,
    55363,
    19029,
    168,
    194,
    212,
    129,
    242,
    126,
    190,
    238
  ],
  "EFI_EVENT_NOTIFICATION_TYPE_MCE_GUID": [
    3908399102,
    37276,
    19653,
    186,
    136,
    101,
    171,
    225,
    73,
    19,
    187
  ],
  "EFI_EVENT_NOTIFICATION_TYPE_PCIE_GUID": [
    3482566687,
    6678,
    19964,
    184,
    188,
    156,
    77,
    175,
    103,
    193,
    4
  ],
  "EFI_EVENT_NOTIFICATION_TYPE_INIT_GUID": [
    3427951592,
    37640,
    17738,
    137,
    208,
    52,
    11,
    211,
    155,
    201,
    142
  ],
  "EFI_EVENT_NOTIFICATION_TYPE_NMI_GUID": [
    1538099711,
    47078,
    17097,
    129,
    74,
    207,
    36,
    133,
    214,
    233,
    138
  ],
  "EFI_EVENT_NOTIFICATION_TYPE_BOOT_GUID": [
    1029809254,
    43840,
    16538,
    166,
    152,
    243,
    98,
    212,
    100,
    179,
    143
  ],
  "EFI_EVENT_NOTIFICATION_TYPE_DMAR_GUID": [
    1719523217,
    50867,
    19495,
    138,
    107,
    15,
    142,
    114,
    45,
    235,
    65
  ],
  "EFI_PROCESSOR_SPECIFIC_ERROR_SECTION_GUID": [
    3695091888,
    41284,
    18327,
    185,
    91,
    83,
    250,
    36,
    43,
    110,
    29
  ],
  "EFI_DM_AR_GENERIC_ERROR_SECTION_GUID": [
    1532100343,
    51101,
    17460,
    143,
    27,
    170,
    98,
    222,
    62,
    44,
    100
  ],
  "EFI_DIRECTED_IO_DM_AR_ERROR_SECTION_GUID": [
    1903566135,
    12978,
    17869,
    167,
    208,
    176,
    254,
    221,
    147,
    232,
    207
  ],
  "EFI_IOMMU_DM_AR_ERROR_SECTION_GUID": [
    57640161,
    32567,
    17036,
    167,
    158,
    87,
    95,
    223,
    170,
    132,
    236
  ],
  "EFI_EVENT_USER_PROFILE_CHANGED_GUID": [
    3136415454,
    8350,
    19163,
    141,
    150,
    253,
    139,
    113,
    243,
    246,
    131
  ],
  "EFI_USER_CREDENTIAL_CLASS_UNKNOWN_GUID": [
    1559441000,
    30304,
    17563,
    128,
    230,
    126,
    163,
    110,
    3,
    246,
    168
  ],
  "EFI_USER_CREDENTIAL_CLASS_PASSWORD_GUID": [
    4175758732,
    52406,
    18196,
    178,
    32,
    63,
    126,
    58,
    100,
    11,
    209
  ],
  "EFI_USER_CREDENTIAL_CLASS_SMART_CARD_GUID": [
    1594079795,
    35947,
    19492,
    170,
    46,
    20,
    162,
    101,
    123,
    212,
    84
  ],
  "EFI_USER_CREDENTIAL_CLASS_FINGERPRINT_GUID": [
    852206111,
    62216,
    19644,
    154,
    181,
    245,
    163,
    105,
    159,
    4,
    74
  ],
  "EFI_USER_CREDENTIAL_CLASS_HANDPRINT_GUID": [
    1494740758,
    63267,
    19385,
    166,
    75,
    216,
    197,
    50,
    244,
    216,
    181
  ],
  "EFI_USER_CREDENTIAL_CLASS_SECURE_CARD_GUID": [
    2322287235,
    17150,
    17874,
    162,
    239,
    70,
    240,
    108,
    125,
    152,
    82
  ],
  "EFI_CERT_X509_GUID": [
    2780846497,
    38116,
    19111,
    135,
    181,
    171,
    21,
    92,
    43,
    240,
    114
  ],
  "EFI_KMS_FORMAT_RSASHA2563072_GUID": [
    1309890242,
    3821,
    17983,
    129,
    71,
    153,
    51,
    171,
    219,
    199,
    213
  ],
  "EFI_CERT_SHA224_GUID": [
    191779379,
    42588,
    17609,
    148,
    7,
    217,
    171,
    131,
    191,
    200,
    189
  ],
  "EFI_CERT_SHA384_GUID": [
    4282274567,
    40912,
    18633,
    133,
    241,
    138,
    213,
    108,
    112,
    30,
    1
  ],
  "EFI_CERT_SHA512_GUID": [
    155062190,
    42692,
    20304,
    159,
    27,
    212,
    30,
    43,
    137,
    193,
    154
  ],
  "EFI_HASH_ALGORITHM_SHA1_NO_PAD_GUID": [
    616946735,
    21474,
    16586,
    158,
    214,
    165,
    217,
    164,
    159,
    70,
    59
  ],
  "EFI_HASH_ALGORITHM_SHA256_NO_PAD_GUID": [
    2250798378,
    27831,
    18452,
    150,
    252,
    36,
    168,
    21,
    172,
    34,
    38
  ],
  "EFI_FMP_CAPSULE_GUID": [
    1842075117,
    59437,
    19524,
    189,
    161,
    113,
    148,
    25,
    154,
    217,
    42
  ],
  "EFI_CERT_X509_SHA256_GUID": [
    1003660434,
    38592,
    16505,
    180,
    32,
    252,
    249,
    142,
    241,
    3,
    237
  ],
  "EFI_CERT_X509_SHA384_GUID": [
    1886816110,
    32962,
    20198,
    170,
    210,
    40,
    179,
    73,
    166,
    134,
    91
  ],
  "EFI_CERT_X509_SHA512_GUID": [
    1148043107,
    9474,
    19674,
    188,
    250,
    36,
    101,
    210,
    176,
    254,
    157
  ],
  "EFI_RNG_ALGORITHM_SP80090_HASH256_GUID": [
    2813290443,
    24635,
    19778,
    186,
    33,
    112,
    191,
    182,
    41,
    63,
    150
  ],
  "EFI_RNG_ALGORITHM_SP80090_HMAC256_GUID": [
    3306462019,
    44677,
    20307,
    153,
    130,
    185,
    67,
    53,
    211,
    169,
    231
  ],
  "EFI_RNG_ALGORITHM_SP80090_CTR256_GUID": [
    1156636270,
    19852,
    16453,
    168,
    199,
    77,
    209,
    104,
    133,
    107,
    158
  ],
  "EFI_RNG_ALGORITHM_X9313_DES_GUID": [
    1673820250,
    51764,
    16402,
    163,
    200,
    11,
    106,
    50,
    79,
    85,
    70
  ],
  "EFI_RNG_ALGORITHM_X931_AES_GUID": [
    2899325729,
    30590,
    19773,
    177,
    200,
    32,
    207,
    216,
    136,
    32,
    201
  ],
  "EFI_RNG_ALGORITHM_RAW": [
    3828446935,
    46824,
    18471,
    183,
    132,
    127,
    253,
    196,
    182,
    133,
    97
  ],
  "EFI_ADAPTER_INFO_MEDIA_STATE_GUID": [
    3620160007,
    43057,
    18982,
    177,
    245,
    209,
    147,
    6,
    92,
    232,
    182
  ],
  "EFI_ADAPTER_INFO_NETWORK_BOOT_GUID": [
    532490592,
    16688,
    16869,
    148,
    172,
    210,
    207,
    3,
    127,
    179,
    124
  ],
  "EFI_ADAPTER_INFO_SAN_MAC_ADDRESS_GUID": [
    290301423,
    11505,
    19986,
    155,
    187,
    196,
    112,
    181,
    82,
    5,
    217
  ],
  "EFI_CAPSULE_REPORT_GUID": [
    968264774,
    63483,
    17435,
    182,
    236,
    22,
    176,
    246,
    152,
    33,
    243
  ],
  "EFI_PROPERTIES_TABLE_GUID": [
    2282400931,
    19164,
    18948,
    144,
    121,
    183,
    71,
    52,
    8,
    37,
    229
  ],
  "EFI_SYSTEM_RESOURCE_TABLE_GUID": [
    2971837027,
    13921,
    20328,
    153,
    41,
    120,
    248,
    176,
    214,
    33,
    128
  ],
  "EFI_ADAPTER_INFO_UNDI_IPV6_SUPPORT_GUID": [
    1272277987,
    18805,
    19850,
    160,
    173,
    196,
    145,
    32,
    75,
    93,
    77
  ],
  "EFI_REGEX_SYNTAX_TYPE_POSIX_EXTENDED_GUID": [
    1594208783,
    19030,
    49713,
    250,
    11,
    167,
    177,
    241,
    16,
    4,
    29
  ],
  "EFI_REGEX_SYNTAX_TYPE_ECMA262_GUID": [
    2588359242,
    19691,
    47450,
    65,
    94,
    91,
    160,
    188,
    99,
    155,
    46
  ],
  "EFI_REGEX_SYNTAX_TYPE_PERL_GUID": [
    1676020305,
    18813,
    54311,
    196,
    165,
    184,
    171,
    220,
    58,
    174,
    182
  ],
  "EFI_PLATFORM_MEMORY2_ERROR_SECTION_GUID": [
    1642857724,
    18662,
    55315,
    37,
    201,
    141,
    170,
    68,
    117,
    11,
    18
  ],
  "EFI_BLOCK_IO_CRYPTO_ALGO_AES_XTS_GUID": [
    797424234,
    23556,
    17285,
    167,
    128,
    243,
    191,
    120,
    169,
    123,
    236
  ],
  "EFI_BLOCK_IO_CRYPTO_ALGO_AES_CBC_MS_BITLOCKER_GUID": [
    1755204706,
    28863,
    19699,
    136,
    187,
    51,
    179,
    24,
    38,
    134,
    112
  ],
  "EFI_PADDING_RSASSA_PKCS1_V1P5_GUID": [
    2467818532,
    31920,
    19726,
    139,
    50,
    46,
    217,
    32,
    156,
    216,
    175
  ],
  "EFI_PADDING_RSASSA_PSS_GUID": [
    2065910240,
    21037,
    20366,
    185,
    39,
    105,
    217,
    124,
    158,
    121,
    95
  ],
  "EFI_PADDING_NONE_GUID": [
    908713393,
    8844,
    17710,
    182,
    22,
    9,
    237,
    49,
    106,
    151,
    0
  ],
  "EFI_PADDING_RSAES_PKCS1_V1_P5_GUID": [
    3787575465,
    16561,
    17970,
    189,
    204,
    217,
    214,
    229,
    41,
    86,
    49
  ],
  "EFI_PADDING_RSAES_OAEP_GUID": [
    3253091012,
    53455,
    19686,
    131,
    91,
    238,
    208,
    230,
    168,
    164,
    91
  ],
  "EFI_SMBIOS3_TABLE_GUID": [
    4076672324,
    38804,
    18988,
    153,
    46,
    229,
    187,
    207,
    32,
    227,
    148
  ],
  "EFI_BOOT_MANAGER_POLICY_CONSOLE_GUID": [
    3400591692,
    57695,
    4579,
    145,
    141,
    184,
    232,
    86,
    44,
    186,
    250
  ],
  "EFI_BOOT_MANAGER_POLICY_NETWORK_GUID": [
    3493943772,
    57695,
    4579,
    178,
    97,
    184,
    232,
    86,
    44,
    186,
    250
  ],
  "EFI_BOOT_MANAGER_POLICY_CONNECT_ALL_GUID": [
    289087782,
    64650,
    4579,
    189,
    108,
    184,
    232,
    86,
    44,
    186,
    250
  ],
  "EFI_VIRTUAL_DISK_GUID": [
    2007716698,
    17916,
    25163,
    85,
    96,
    247,
    178,
    129,
    209,
    249,
    110
  ],
  "EFI_VIRTUAL_CD_GUID": [
    1029356848,
    16757,
    34766,
    109,
    100,
    210,
    173,
    229,
    35,
    196,
    187
  ],
  "EFI_PERSISTENT_VIRTUAL_DISK_GUID": [
    1558840009,
    19719,
    27091,
    38,
    159,
    68,
    150,
    251,
    224,
    150,
    249
  ],
  "EFI_PERSISTENT_VIRTUAL_CD_GUID": [
    134316424,
    17101,
    47944,
    16,
    15,
    83,
    135,
    213,
    61,
    237,
    61
  ],
  "EFI_MEMORY_ATTRIBUTES_TABLE_GUID": [
    3707408669,
    9963,
    18079,
    162,
    32,
    56,
    183,
    220,
    70,
    18,
    32
  ],
  "EFI_ARM_PROCESSOR_ERROR_SECTION_GUID": [
    3785243926,
    48145,
    4580,
    156,
    170,
    194,
    5,
    29,
    93,
    70,
    176
  ],
  "EFI_HII_IMAGE_DECODER_NAME_JPEG_GUID": [
    4025471123,
    3483,
    18155,
    168,
    86,
    72,
    53,
    7,
    0,
    201,
    8
  ],
  "EFI_HII_IMAGE_DECODER_NAME_PNG_GUID": [
    2936406416,
    24122,
    16421,
    175,
    189,
    225,
    249,
    5,
    191,
    170,
    76
  ],
  "EFI_BTT_ABSTRACTION_GUID": [
    409156604,
    5941,
    16919,
    138,
    201,
    23,
    35,
    146,
    130,
    211,
    248
  ],
  "EFI_FIRMWARE_VOLUME_TOP_FILE_GUID": [
    463472174,
    51065,
    17794,
    133,
    102,
    51,
    106,
    232,
    247,
    143,
    9
  ],
  "EFI_HOB_MEMORY_ALLOC_MODULE_GUID": [
    4175567221,
    2201,
    20312,
    164,
    190,
    85,
    37,
    169,
    198,
    215,
    122
  ],
  "EFI_MDE_PKG_TOKEN_SPACE_GUID": [
    2437606375,
    17973,
    17819,
    170,
    28,
    17,
    226,
    25,
    176,
    58,
    16
  ],
  "EFI_FIRMWARE_FILE_SYSTEM3_GUID": [
    1416872058,
    15819,
    19914,
    189,
    111,
    30,
    150,
    137,
    231,
    52,
    154
  ],
  "EFI_END_OF_DXE_EVENT_GROUP_GUID": [
    47093370,
    56702,
    20476,
    158,
    231,
    129,
    12,
    240,
    71,
    8,
    128
  ],
  "EFI_FIRMWARE_CONTENTS_SIGNED_GUID": [
    261982696,
    37465,
    20342,
    165,
    175,
    12,
    137,
    227,
    64,
    35,
    223
  ],
  "EFI_VECTOR_HANDOFF_TABLE_GUID": [
    2574172444,
    21399,
    20083,
    181,
    143,
    130,
    126,
    82,
    144,
    109,
    239
  ],
  "ADAPTER_INFO_PLATFORM_SECURITY_GUID": [
    1810002631,
    4896,
    19661,
    144,
    23,
    212,
    97,
    44,
    1,
    43,
    37
  ],
  "EFI_DISK_INFO_NVME_INTERFACE_GUID": [
    984696448,
    23871,
    19021,
    188,
    220,
    204,
    56,
    0,
    24,
    199,
    247
  ],
  "EFI_GRAPHICS_INFO_HOB_GUID": [
    972434638,
    26661,
    18025,
    187,
    86,
    84,
    26,
    186,
    117,
    58,
    7
  ],
  "EFI_DISK_INFO_UFS_INTERFACE_GUID": [
    1261447628,
    27544,
    18427,
    188,
    150,
    118,
    220,
    184,
    4,
    65,
    240
  ],
  "EFI_GRAPHICS_DEVICE_INFO_HOB_GUID": [
    3855297225,
    54109,
    17456,
    147,
    110,
    29,
    227,
    50,
    71,
    141,
    231
  ],
  "EFI_DISK_INFO_SD_MMC_INTERFACE_GUID": [
    2381236626,
    54172,
    19036,
    171,
    107,
    152,
    110,
    20,
    36,
    43,
    157
  ],
  "TIANO_CUSTOM_DECOMPRESS_GUID": [
    2735898797,
    18462,
    16822,
    149,
    232,
    18,
    127,
    76,
    152,
    71,
    121
  ],
  "EFI_IA32_X64_ERROR_TYPE_CACHE_CHECK_GUID": [
    2773942773,
    58351,
    17374,
    172,
    114,
    36,
    155,
    87,
    63,
    173,
    44
  ],
  "EFI_IA32_X64_ERROR_TYPE_TLB_CHECK_GUID": [
    4228298037,
    24095,
    17762,
    159,
    37,
    10,
    59,
    154,
    219,
    99,
    195
  ],
  "EFI_IA32_X64_ERROR_TYPE_BUS_CHECK_GUID": [
    485750963,
    50609,
    18850,
    170,
    89,
    94,
    239,
    146,
    255,
    166,
    60
  ],
  "EFI_IA32_X64_ERROR_TYPE_MS_CHECK_GUID": [
    1219198807,
    56372,
    20332,
    167,
    211,
    176,
    181,
    176,
    167,
    67,
    20
  ],
  "EFI_PEI_MASTER_BOOT_MODE_PPI_GUID": [
    1946736456,
    64652,
    20198,
    146,
    136,
    196,
    190,
    192,
    146,
    164,
    16
  ],
  "EFI_PEI_BOOT_IN_RECOVERY_MODE_PPI_GUID": [
    401492330,
    55524,
    19354,
    148,
    209,
    206,
    130,
    114,
    48,
    8,
    80
  ],
  "EFI_SEC_PLATFORM_INFORMATION_PPI_GUID": [
    1871457077,
    65268,
    17549,
    130,
    86,
    225,
    27,
    25,
    214,
    16,
    119
  ],
  "EFI_PEI_SMBUS2_PPI_GUID": [
    2628335143,
    46683,
    17188,
    162,
    2,
    192,
    180,
    97,
    118,
    69,
    67
  ],
  "PCD_PPI_GUID": [
    115874904,
    19159,
    17596,
    131,
    144,
    241,
    2,
    101,
    247,
    36,
    128
  ],
  "GET_PCD_INFO_PPI_GUID": [
    1300960603,
    49241,
    19599,
    137,
    38,
    6,
    253,
    67,
    49,
    219,
    138
  ],
  "EFI_PEI_PCD_PPI_GUID": [
    32722213,
    19938,
    9133,
    63,
    243,
    54,
    53,
    63,
    243,
    35,
    241
  ],
  "EFI_GET_PCD_INFO_PPI_GUID": [
    2785831769,
    58457,
    16989,
    156,
    105,
    11,
    204,
    156,
    178,
    125,
    129
  ],
  "EFI_ISA_HC_PPI_GUID": [
    2370354544,
    51363,
    19462,
    144,
    27,
    116,
    121,
    70,
    170,
    195,
    88
  ],
  "EFI_SIO_PPI_GUID": [
    597976237,
    52099,
    18616,
    148,
    171,
    26,
    111,
    239,
    207,
    229,
    34
  ],
  "EFI_PEI_I2C_MASTER_PPI_GUID": [
    3015682971,
    40860,
    20107,
    173,
    55,
    127,
    140,
    81,
    252,
    98,
    128
  ],
  "EFI_PEI_FIRMWARE_VOLUME_INFO2_PPI_GUID": [
    3934036555,
    57045,
    19885,
    163,
    137,
    191,
    130,
    126,
    143,
    155,
    56
  ],
  "EFI_PEI_GRAPHICS_PPI_GUID": [
    1858933859,
    19018,
    17947,
    175,
    95,
    90,
    51,
    227,
    178,
    22,
    43
  ],
  "EFI_PEI_MP_SERVICES_PPI_GUID": [
    3994424842,
    59582,
    18342,
    130,
    10,
    198,
    144,
    13,
    176,
    37,
    10
  ],
  "EFI_PEI_RESET2_PPI_GUID": [
    1824806757,
    52452,
    17149,
    188,
    86,
    1,
    26,
    170,
    198,
    201,
    168
  ],
  "EFI_PEI_VIRTUAL_BLOCK_IO2_PPI_GUID": [
    650907565,
    48819,
    18314,
    145,
    178,
    12,
    24,
    143,
    114,
    97,
    152
  ],
  "EFI_SEC_PLATFORM_INFORMATION2_PPI_GUID": [
    2661234507,
    36630,
    16944,
    152,
    36,
    88,
    70,
    238,
    118,
    106,
    151
  ],
  "EFI_SEC_HOB_DATA_PPI_GUID": [
    1052618528,
    26215,
    16600,
    180,
    238,
    245,
    153,
    154,
    193,
    183,
    31
  ],
  "EFI_PEI_SMM_ACCESS_PPI_GUID": [
    646919081,
    52429,
    18622,
    136,
    23,
    134,
    5,
    58,
    195,
    46,
    214
  ],
  "EFI_PEI_SMM_CONTROL_PPI_GUID": [
    1640400642,
    19838,
    20291,
    141,
    239,
    167,
    67,
    5,
    206,
    116,
    197
  ],
  "EFI_PEI_CORE_FV_LOCATION_PPI_GUID": [
    1384681134,
    23312,
    18384,
    168,
    127,
    184,
    34,
    171,
    160,
    202,
    244
  ],
  "PCD_PROTOCOL_GUID": [
    296960006,
    55387,
    19722,
    162,
    144,
    213,
    165,
    113,
    49,
    14,
    247
  ],
  "GET_PCD_INFO_PROTOCOL_GUID": [
    1541672791,
    64104,
    17936,
    187,
    191,
    233,
    197,
    252,
    218,
    211,
    101
  ],
  "EFI_MONOTONIC_COUNTER_ARCH_PROTOCOL_GUID": [
    497643634,
    48604,
    19248,
    153,
    241,
    114,
    160,
    181,
    111,
    255,
    42
  ],
  "EFI_RUNTIME_ARCH_PROTOCOL_GUID": [
    3084891361,
    1327,
    17567,
    135,
    190,
    152,
    24,
    252,
    145,
    183,
    51
  ],
  "EFI_STATUS_CODE_RUNTIME_PROTOCOL_GUID": [
    3534927912,
    2086,
    18599,
    179,
    223,
    152,
    60,
    0,
    96,
    36,
    240
  ],
  "EFI_PCI_HOST_BRIDGE_RESOURCE_ALLOCATION_PROTOCOL_GUID": [
    3481285822,
    26472,
    19851,
    183,
    57,
    124,
    206,
    104,
    58,
    159,
    190
  ],
  "EFI_PCI_OVERRIDE_PROTOCOL_GUID": [
    3048429412,
    17932,
    18950,
    153,
    252,
    119,
    161,
    124,
    27,
    92,
    235
  ],
  "EFI_PCI_ENUMERATION_COMPLETE_PROTOCOL_GUID": [
    818930663,
    15841,
    17798,
    190,
    32,
    222,
    171,
    161,
    179,
    183,
    147
  ],
  "EFI_PCI_HOT_PLUG_REQUEST_PROTOCOL_GUID": [
    432768939,
    11449,
    18021,
    131,
    96,
    221,
    207,
    96,
    84,
    247,
    157
  ],
  "EFI_RSC_HANDLER_PROTOCOL_GUID": [
    2250320182,
    3702,
    16840,
    160,
    58,
    42,
    242,
    252,
    28,
    57,
    226
  ],
  "EFI_SMM_BASE2_PROTOCOL_GUID": [
    4107059127,
    63200,
    18429,
    157,
    212,
    16,
    168,
    241,
    80,
    193,
    145
  ],
  "EFI_SMM_ACCESS2_PROTOCOL_GUID": [
    3262131060,
    32780,
    16689,
    135,
    70,
    143,
    181,
    184,
    156,
    228,
    172
  ],
  "EFI_SMM_CONTROL2_PROTOCOL_GUID": [
    2218641184,
    43806,
    17099,
    147,
    87,
    138,
    0,
    120,
    243,
    86,
    27
  ],
  "EFI_SMM_CONFIGURATION_PROTOCOL_GUID": [
    653177822,
    46729,
    18734,
    128,
    240,
    190,
    139,
    215,
    218,
    75,
    167
  ],
  "EFI_PCD_PROTOCOL_GUID": [
    329511158,
    9802,
    16112,
    242,
    224,
    222,
    197,
    18,
    52,
    47,
    52
  ],
  "EFI_LEGACY_REGION2_PROTOCOL_GUID": [
    1880104623,
    133,
    17420,
    179,
    86,
    142,
    227,
    111,
    239,
    36,
    240
  ],
  "EFI_SECURITY2_ARCH_PROTOCOL_GUID": [
    2494246744,
    5176,
    20209,
    145,
    82,
    24,
    148,
    26,
    58,
    14,
    104
  ],
  "EFI_SMM_END_OF_DXE_PROTOCOL_GUID": [
    619118658,
    54725,
    16992,
    140,
    57,
    10,
    211,
    170,
    50,
    233,
    61
  ],
  "EFI_ISA_HC_PROTOCOL_GUID": [
    3168465024,
    7134,
    20002,
    174,
    106,
    67,
    84,
    30,
    18,
    142,
    196
  ],
  "EFI_ISA_HC_SERVICE_BINDING_PROTOCOL_GUID": [
    4208431930,
    27681,
    16948,
    164,
    52,
    10,
    138,
    13,
    43,
    7,
    129
  ],
  "EFI_SIO_CONTROL_PROTOCOL_GUID": [
    3105454303,
    40897,
    17021,
    187,
    5,
    76,
    130,
    132,
    85,
    202,
    39
  ],
  "EFI_GET_PCD_INFO_PROTOCOL_GUID": [
    4245636216,
    3837,
    17949,
    186,
    45,
    229,
    140,
    69,
    253,
    95,
    94
  ],
  "EFI_I2C_MASTER_PROTOCOL_GUID": [
    3446835231,
    17845,
    20459,
    152,
    200,
    49,
    61,
    168,
    17,
    116,
    98
  ],
  "EFI_I2C_IO_PROTOCOL_GUID": [
    3054124651,
    6340,
    18149,
    162,
    154,
    201,
    161,
    6,
    101,
    162,
    142
  ],
  "EFI_I2C_ENUMERATE_PROTOCOL_GUID": [
    3666663364,
    7168,
    18914,
    128,
    62,
    82,
    20,
    231,
    1,
    137,
    76
  ],
  "EFI_I2C_HOST_PROTOCOL_GUID": [
    2779429347,
    50983,
    18637,
    139,
    191,
    66,
    114,
    51,
    133,
    73,
    72
  ],
  "EFI_I2C_BUS_CONFIGURATION_MANAGEMENT_PROTOCOL_GUID": [
    1438064565,
    6086,
    16654,
    181,
    189,
    95,
    162,
    227,
    212,
    70,
    107
  ],
  "EFI_SMM_MP_PROTOCOL_GUID": [
    1565806807,
    39180,
    16768,
    168,
    3,
    142,
    99,
    240,
    96,
    131,
    7
  ],
  "EFI_SMM_SX_DISPATCH_PROTOCOL_GUID": [
    352080574,
    476,
    17004,
    145,
    174,
    162,
    60,
    62,
    34,
    10,
    232
  ],
  "EFI_LEGACY_SPI_CONTROLLER_PROTOCOL_GUID": [
    957575111,
    6673,
    18910,
    191,
    53,
    14,
    120,
    221,
    181,
    36,
    252
  ],
  "EFI_LEGACY_SPI_FLASH_PROTOCOL_GUID": [
    4028362071,
    1212,
    20287,
    150,
    96,
    214,
    242,
    234,
    34,
    130,
    89
  ],
  "EFI_LEGACY_SPI_SMM_CONTROLLER_PROTOCOL_GUID": [
    1647516536,
    55504,
    19596,
    140,
    203,
    210,
    125,
    254,
    50,
    219,
    155
  ],
  "EFI_LEGACY_SPI_SMM_FLASH_PROTOCOL_GUID": [
    1580746964,
    3509,
    20416,
    151,
    41,
    63,
    53,
    61,
    79,
    135,
    159
  ],
  "EFI_SPI_CONFIGURATION_PROTOCOL_GUID": [
    2242302950,
    46683,
    19196,
    179,
    143,
    198,
    213,
    74,
    246,
    221,
    200
  ],
  "EFI_SPI_HC_PROTOCOL_GUID": [
    3343801778,
    64150,
    19170,
    179,
    153,
    21,
    151,
    127,
    227,
    0,
    45
  ],
  "EFI_SPI_NOR_FLASH_PROTOCOL_GUID": [
    3044983806,
    63539,
    19366,
    133,
    120,
    42,
    125,
    106,
    135,
    68,
    75
  ],
  "EFI_SPI_SMM_CONFIGURATION_PROTOCOL_GUID": [
    2572971722,
    5915,
    17917,
    163,
    170,
    253,
    76,
    156,
    157,
    239,
    89
  ],
  "EFI_SPI_SMM_HC_PROTOCOL_GUID": [
    3924828695,
    8339,
    17520,
    138,
    84,
    92,
    44,
    255,
    231,
    62,
    203
  ],
  "EFI_SPI_SMM_NOR_FLASH_PROTOCOL_GUID": [
    2863763225,
    65044,
    18022,
    134,
    4,
    135,
    255,
    109,
    102,
    44,
    154
  ],
  "EFI_SIMPLE_POINTER_PROTOCOL_GUID": [
    830966919,
    2933,
    4565,
    154,
    79,
    0,
    144,
    39,
    63,
    193,
    77
  ],
  "EFI_LOAD_FILE_PROTOCOL_GUID": [
    1458319505,
    38220,
    4562,
    142,
    63,
    0,
    160,
    201,
    105,
    114,
    59
  ],
  "EFI_NETWORK_INTERFACE_IDENTIFIER_PROTOCOL_GUID_31": [
    449762662,
    30445,
    16920,
    188,
    129,
    118,
    127,
    31,
    151,
    122,
    137
  ],
  "EFI_TR_EE_PROTOCOL_GUID": [
    1618966124,
    29781,
    17086,
    147,
    11,
    228,
    215,
    109,
    178,
    114,
    15
  ],
  "EFI_TCG2_FINAL_EVENTS_TABLE_GUID": [
    506384534,
    12514,
    16980,
    189,
    137,
    134,
    59,
    190,
    248,
    35,
    37
  ],
  "EFI_IP6_SERVICE_BINDING_PROTOCOL_GUID": [
    3968032211,
    65039,
    24955,
    166,
    33,
    179,
    80,
    195,
    225,
    51,
    136
  ],
  "EFI_IP6_PROTOCOL_GUID": [
    747067861,
    23597,
    26351,
    146,
    95,
    182,
    108,
    16,
    25,
    87,
    226
  ],
  "EFI_IP6_CONFIG_PROTOCOL_GUID": [
    2474632481,
    38318,
    19738,
    137,
    41,
    72,
    188,
    217,
    10,
    211,
    26
  ],
  "EFI_MTFTP6_SERVICE_BINDING_PROTOCOL_GUID": [
    3648393203,
    15562,
    16999,
    128,
    249,
    117,
    39,
    250,
    250,
    66,
    35
  ],
  "EFI_MTFTP6_PROTOCOL_GUID": [
    3205134522,
    60457,
    18895,
    161,
    201,
    122,
    229,
    78,
    171,
    106,
    81
  ],
  "EFI_DHCP6_SERVICE_BINDING_PROTOCOL_GUID": [
    2679744673,
    12106,
    17318,
    136,
    156,
    208,
    247,
    182,
    196,
    122,
    213
  ],
  "EFI_DHCP6_PROTOCOL_GUID": [
    2278079191,
    1429,
    16467,
    130,
    151,
    222,
    222,
    57,
    95,
    93,
    91
  ],
  "EFI_UDP6_SERVICE_BINDING_PROTOCOL_GUID": [
    1726826273,
    15512,
    19774,
    129,
    227,
    208,
    61,
    211,
    154,
    114,
    84
  ],
  "EFI_UDP6_PROTOCOL_GUID": [
    1335134229,
    46265,
    17355,
    138,
    51,
    144,
    224,
    96,
    179,
    73,
    85
  ],
  "EFI_TCP6_SERVICE_BINDING_PROTOCOL_GUID": [
    3961580409,
    27674,
    18020,
    154,
    13,
    210,
    228,
    204,
    22,
    214,
    100
  ],
  "EFI_TCP6_PROTOCOL_GUID": [
    1189365845,
    48480,
    19127,
    171,
    13,
    166,
    121,
    185,
    68,
    125,
    119
  ],
  "EFI_VLAN_CONFIG_PROTOCOL_GUID": [
    2653149032,
    54003,
    17254,
    159,
    195,
    58,
    122,
    186,
    134,
    67,
    116
  ],
  "EFI_EAP_PROTOCOL_GUID": [
    1570739931,
    59185,
    19626,
    160,
    13,
    114,
    225,
    135,
    205,
    119,
    98
  ],
  "EFI_EAP_MANAGEMENT_PROTOCOL_GUID": [
    3143820899,
    25181,
    16562,
    160,
    136,
    187,
    232,
    54,
    35,
    162,
    69
  ],
  "EFI_FTP4_SERVICE_BINDING_PROTOCOL_GUID": [
    262859953,
    8814,
    18306,
    170,
    206,
    125,
    185,
    188,
    191,
    77,
    175
  ],
  "EFI_FTP4_PROTOCOL_GUID": [
    3946022950,
    26651,
    17045,
    179,
    86,
    43,
    54,
    76,
    117,
    123,
    9
  ],
  "EFI_IP_SEC_CONFIG_PROTOCOL_GUID": [
    3462289705,
    51107,
    17922,
    173,
    158,
    201,
    218,
    249,
    78,
    191,
    207
  ],
  "EFI_ATA_PASS_THRU_PROTOCOL_GUID": [
    490596336,
    2055,
    16975,
    170,
    105,
    17,
    165,
    78,
    25,
    164,
    111
  ],
  "EFI_FIRMWARE_MANAGEMENT_PROTOCOL_GUID": [
    2261219943,
    2967,
    17971,
    161,
    135,
    73,
    16,
    77,
    6,
    133,
    199
  ],
  "EFI_IP_SEC_PROTOCOL_GUID": [
    3753084663,
    57600,
    17325,
    156,
    154,
    237,
    144,
    208,
    138,
    94,
    18
  ],
  "EFI_IP_SEC2_PROTOCOL_GUID": [
    2744622692,
    44264,
    19932,
    188,
    7,
    77,
    102,
    184,
    253,
    9,
    119
  ],
  "EFI_KMS_PROTOCOL_GUID": [
    3963262861,
    31822,
    18682,
    154,
    190,
    106,
    217,
    28,
    200,
    248,
    17
  ],
  "EFI_BLOCK_IO2_PROTOCOL_GUID": [
    2809865330,
    57986,
    20127,
    162,
    69,
    194,
    192,
    226,
    123,
    188,
    193
  ],
  "EFI_USER_CREDENTIAL2_PROTOCOL_GUID": [
    3918191363,
    47289,
    19192,
    186,
    32,
    38,
    233,
    17,
    76,
    188,
    229
  ],
  "EFI_DISK_IO2_PROTOCOL_GUID": [
    354193070,
    32556,
    18220,
    158,
    84,
    152,
    40,
    25,
    79,
    106,
    136
  ],
  "EFI_TIMESTAMP_PROTOCOL_GUID": [
    2948587073,
    11886,
    16994,
    186,
    101,
    98,
    185,
    35,
    110,
    84,
    149
  ],
  "EFI_RNG_PROTOCOL_GUID": [
    827505829,
    60126,
    17213,
    134,
    46,
    192,
    28,
    220,
    41,
    31,
    68
  ],
  "EFI_ADAPTER_INFORMATION_PROTOCOL_GUID": [
    3856471043,
    54818,
    49742,
    132,
    136,
    199,
    27,
    23,
    245,
    232,
    2
  ],
  "EFI_NVM_EXPRESS_PASS_THRU_PROTOCOL_GUID": [
    1388806930,
    36572,
    16947,
    152,
    242,
    26,
    26,
    165,
    227,
    136,
    165
  ],
  "EFI_HASH2_SERVICE_BINDING_PROTOCOL_GUID": [
    3666046861,
    8575,
    19616,
    153,
    194,
    28,
    164,
    225,
    96,
    119,
    234
  ],
  "EFI_HASH2_PROTOCOL_GUID": [
    1437718324,
    50657,
    18907,
    150,
    71,
    177,
    106,
    251,
    14,
    48,
    91
  ],
  "EFI_BLOCK_IO_CRYPTO_PROTOCOL_GUID": [
    2684653754,
    16154,
    19276,
    171,
    144,
    79,
    169,
    151,
    38,
    161,
    232
  ],
  "EFI_SMART_CARD_READER_PROTOCOL_GUID": [
    709696223,
    8668,
    19329,
    164,
    47,
    139,
    142,
    226,
    56,
    0,
    96
  ],
  "EFI_SMART_CARD_EDGE_PROTOCOL_GUID": [
    3541562011,
    41765,
    18194,
    155,
    241,
    198,
    25,
    84,
    220,
    25,
    140
  ],
  "EFI_USB_FUNCTION_IO_PROTOCOL_GUID": [
    852661818,
    65117,
    20272,
    182,
    51,
    110,
    93,
    197,
    88,
    3,
    204
  ],
  "EFI_BLUETOOTH_HC_PROTOCOL_GUID": [
    3012756849,
    48826,
    20421,
    146,
    3,
    148,
    39,
    36,
    46,
    106,
    67
  ],
  "EFI_BLUETOOTH_IO_SERVICE_BINDING_PROTOCOL_GUID": [
    948074707,
    31621,
    17136,
    171,
    169,
    251,
    75,
    253,
    105,
    245,
    171
  ],
  "EFI_BLUETOOTH_IO_PROTOCOL_GUID": [
    1181946846,
    20016,
    17393,
    148,
    62,
    50,
    63,
    137,
    132,
    93,
    181
  ],
  "EFI_BLUETOOTH_CONFIG_PROTOCOL_GUID": [
    1654000883,
    16639,
    16995,
    167,
    124,
    223,
    222,
    189,
    25,
    27,
    75
  ],
  "EFI_REGULAR_EXPRESSION_PROTOCOL_GUID": [
    3019349402,
    17260,
    56337,
    176,
    82,
    205,
    133,
    223,
    82,
    76,
    230
  ],
  "EFI_BOOT_MANAGER_POLICY_PROTOCOL_GUID": [
    4276063756,
    57671,
    4579,
    153,
    3,
    184,
    232,
    86,
    44,
    186,
    250
  ],
  "EFI_CONFIG_KEYWORD_HANDLER_PROTOCOL_GUID": [
    176926165,
    952,
    19737,
    177,
    40,
    123,
    143,
    14,
    218,
    165,
    150
  ],
  "EFI_WIFI_PROTOCOL_GUID": [
    228940745,
    17912,
    19380,
    135,
    25,
    82,
    36,
    241,
    138,
    77,
    69
  ],
  "EFI_EAP_MANAGEMENT2_PROTOCOL_GUID": [
    1586743367,
    17773,
    16563,
    166,
    180,
    120,
    176,
    201,
    207,
    127,
    32
  ],
  "EFI_EAP_CONFIGURATION_PROTOCOL_GUID": [
    3853880763,
    30344,
    17588,
    151,
    191,
    95,
    29,
    75,
    124,
    200,
    219
  ],
  "EFI_PKCS7_VERIFY_PROTOCOL_GUID": [
    1200136114,
    54897,
    20395,
    160,
    202,
    223,
    14,
    68,
    223,
    112,
    214
  ],
  "EFI_IP4_CONFIG2_PROTOCOL_GUID": [
    1531211473,
    58123,
    20394,
    135,
    26,
    54,
    84,
    236,
    163,
    96,
    128
  ],
  "EFI_DNS4_SERVICE_BINDING_PROTOCOL_GUID": [
    3055923590,
    57443,
    17655,
    137,
    5,
    106,
    116,
    220,
    111,
    82,
    180
  ],
  "EFI_DNS4_PROTOCOL_GUID": [
    2923243724,
    57435,
    20385,
    160,
    17,
    126,
    181,
    90,
    63,
    20,
    1
  ],
  "EFI_DNS6_SERVICE_BINDING_PROTOCOL_GUID": [
    2132166600,
    46958,
    17586,
    165,
    101,
    247,
    15,
    241,
    156,
    209,
    158
  ],
  "EFI_DNS6_PROTOCOL_GUID": [
    3392650271,
    41767,
    19177,
    130,
    138,
    140,
    64,
    216,
    80,
    106,
    23
  ],
  "EFI_HTTP_SERVICE_BINDING_PROTOCOL_GUID": [
    3184060079,
    55740,
    17273,
    167,
    42,
    224,
    196,
    231,
    93,
    174,
    28
  ],
  "EFI_HTTP_PROTOCOL_GUID": [
    2052698779,
    37131,
    16753,
    130,
    66,
    168,
    90,
    13,
    242,
    91,
    91
  ],
  "EFI_HTTP_UTILITIES_PROTOCOL_GUID": [
    1043710307,
    16500,
    17885,
    67,
    30,
    35,
    152,
    157,
    216,
    107,
    50
  ],
  "EFI_TLS_SERVICE_BINDING_PROTOCOL_GUID": [
    2502735765,
    65334,
    18639,
    162,
    73,
    77,
    244,
    134,
    214,
    171,
    141
  ],
  "EFI_TLS_PROTOCOL_GUID": [
    13276575,
    27898,
    19889,
    149,
    188,
    228,
    108,
    71,
    81,
    67,
    144
  ],
  "EFI_TLS_CONFIGURATION_PROTOCOL_GUID": [
    377683524,
    48506,
    17415,
    183,
    199,
    220,
    163,
    124,
    163,
    146,
    45
  ],
  "EFI_REST_PROTOCOL_GUID": [
    229935670,
    20052,
    60060,
    155,
    9,
    30,
    165,
    190,
    58,
    102,
    11
  ],
  "EFI_SUPPLICANT_SERVICE_BINDING_PROTOCOL_GUID": [
    1170004366,
    22957,
    16756,
    149,
    70,
    52,
    74,
    7,
    72,
    88,
    152
  ],
  "EFI_SUPPLICANT_PROTOCOL_GUID": [
    1425851454,
    43657,
    17203,
    154,
    133,
    205,
    234,
    36,
    5,
    30,
    158
  ],
  "EFI_WI_FI2_PROTOCOL_GUID": [
    454015423,
    27037,
    20445,
    167,
    195,
    37,
    70,
    104,
    27,
    246,
    59
  ],
  "EFI_RAM_DISK_PROTOCOL_GUID": [
    2872615135,
    26739,
    17577,
    135,
    230,
    212,
    235,
    86,
    20,
    132,
    73
  ],
  "EFI_HII_IMAGE_DECODER_PROTOCOL_GUID": [
    2657546833,
    29308,
    16780,
    191,
    214,
    194,
    180,
    37,
    40,
    24,
    234
  ],
  "EFI_HII_IMAGE_EX_PROTOCOL_GUID": [
    437404134,
    36633,
    16809,
    188,
    14,
    232,
    239,
    57,
    224,
    101,
    70
  ],
  "EFI_SD_MMC_PASS_THRU_PROTOCOL_GUID": [
    1903096025,
    65411,
    20329,
    129,
    233,
    81,
    139,
    211,
    154,
    142,
    112
  ],
  "EFI_ERASE_BLOCK_PROTOCOL_GUID": [
    2510924094,
    43118,
    18726,
    170,
    239,
    153,
    24,
    231,
    114,
    217,
    135
  ],
  "EFI_BLUETOOTH_ATTRIBUTE_PROTOCOL_GUID": [
    2307428585,
    33970,
    20282,
    140,
    88,
    216,
    87,
    120,
    19,
    224,
    172
  ],
  "EFI_BLUETOOTH_ATTRIBUTE_SERVICE_BINDING_PROTOCOL_GUID": [
    1446610554,
    35982,
    16525,
    172,
    47,
    75,
    97,
    189,
    192,
    187,
    187
  ],
  "EFI_BLUETOOTH_LE_CONFIG_PROTOCOL_GUID": [
    2406931032,
    8089,
    17013,
    164,
    236,
    71,
    86,
    81,
    91,
    28,
    232
  ],
  "EFI_UFS_DEVICE_CONFIG_PROTOCOL_GUID": [
    3088841392,
    3763,
    19705,
    132,
    101,
    127,
    169,
    134,
    54,
    22,
    100
  ],
  "EFI_HTTP_BOOT_CALLBACK_PROTOCOL_GUID": [
    3122901777,
    13373,
    4582,
    145,
    133,
    88,
    32,
    177,
    214,
    82,
    153
  ],
  "EFI_RESET_NOTIFICATION_PROTOCOL_GUID": [
    2644724448,
    60153,
    19391,
    142,
    195,
    253,
    96,
    34,
    108,
    68,
    190
  ],
  "EFI_PARTITION_INFO_PROTOCOL_GUID": [
    2364732972,
    48283,
    18465,
    128,
    141,
    236,
    158,
    196,
    33,
    161,
    160
  ],
  "EFI_HII_POPUP_PROTOCOL_GUID": [
    1125248448,
    24660,
    18132,
    158,
    64,
    137,
    62,
    169,
    82,
    252,
    204
  ],
  "EFI_NVDIMM_LABEL_PROTOCOL_GUID": [
    3557518208,
    38869,
    17026,
    187,
    29,
    34,
    58,
    22,
    145,
    128,
    88
  ],
  "EFI_SHELL_PROTOCOL_GUID": [
    1661128712,
    32667,
    20272,
    135,
    172,
    96,
    201,
    254,
    245,
    218,
    78
  ],
  "EFI_SHELL_PARAMETERS_PROTOCOL_GUID": [
    1966027062,
    19990,
    20444,
    162,
    42,
    229,
    244,
    104,
    18,
    244,
    202
  ],
  "EFI_SHELL_DYNAMIC_COMMAND_PROTOCOL_GUID": [
    1014104297,
    95,
    20132,
    135,
    222,
    163,
    223,
    172,
    138,
    39,
    195
  ],
  "EFI_NETWORK_PKG_TOKEN_SPACE_GUID": [
    1088447666,
    2784,
    18609,
    160,
    125,
    248,
    207,
    30,
    26,
    35,
    16
  ],
  "IP6_CONFIG_NV_DATA_GUID": [
    49193223,
    39131,
    16398,
    152,
    48,
    70,
    10,
    21,
    66,
    215,
    153
  ],
  "ISCSI_CONFIG_GUID": [
    1262999062,
    43222,
    17746,
    157,
    68,
    204,
    173,
    46,
    15,
    76,
    249
  ],
  "HTTP_BOOT_CONFIG_GUID": [
    1293965370,
    30565,
    20090,
    138,
    103,
    220,
    222,
    116,
    238,
    62,
    197
  ],
  "TLS_AUTH_CONFIG_GUID": [
    2968184056,
    39428,
    19565,
    167,
    72,
    121,
    61,
    170,
    15,
    101,
    223
  ],
  "EFI_TLS_CA_CERTIFICATE_GUID": [
    4246946000,
    15787,
    17225,
    166,
    199,
    59,
    79,
    18,
    180,
    142,
    174
  ],
  "EDKII_HTTP_TLS_CIPHER_LIST_GUID": [
    1188934677,
    21060,
    18887,
    147,
    116,
    240,
    226,
    152,
    231,
    211,
    134
  ],
  "WIFI_CONFIG_GUID": [
    2677330727,
    2840,
    16965,
    143,
    242,
    131,
    46,
    48,
    13,
    44,
    239
  ],
  "IP4_CONFIG2_NV_DATA_GUID": [
    2610177863,
    5454,
    19753,
    164,
    54,
    191,
    113,
    0,
    200,
    181,
    59
  ],
  "VLAN_CONFIG_FORM_SET_GUID": [
    3617453744,
    61252,
    17341,
    151,
    151,
    67,
    233,
    59,
    207,
    95,
    168
  ],
  "IP4_ISCSI_CONFIG_GUID": [
    1683418465,
    13689,
    16841,
    138,
    38,
    10,
    11,
    214,
    43,
    120,
    252
  ],
  "I_SCSI_CHAP_AUTH_INFO_GUID": [
    2020524204,
    26030,
    19739,
    177,
    55,
    13,
    17,
    10,
    72,
    55,
    151
  ],
  "EFI_DPC_PROTOCOL_GUID": [
    1208978153,
    3142,
    19113,
    188,
    137,
    219,
    159,
    186,
    97,
    152,
    6
  ],
  "UEFI_OVMF_PKG_TOKEN_SPACE_GUID": [
    2478544559,
    47602,
    20152,
    148,
    98,
    224,
    186,
    116,
    86,
    66,
    54
  ],
  "EFI_XEN_INFO_GUID": [
    3551817531,
    54337,
    4676,
    154,
    18,
    0,
    18,
    39,
    63,
    193,
    77
  ],
  "OVMF_PK_KEK1_APP_PREFIX_GUID": [
    1311921773,
    36510,
    20306,
    129,
    211,
    91,
    185,
    113,
    95,
    151,
    39
  ],
  "OVMF_PLATFORM_CONFIG_GUID": [
    1916126492,
    3200,
    19627,
    135,
    172,
    59,
    8,
    74,
    99,
    4,
    177
  ],
  "VIRTIO_MMIO_TRANSPORT_GUID": [
    2206059166,
    59508,
    19842,
    178,
    154,
    35,
    254,
    14,
    35,
    209,
    226
  ],
  "QEMU_RAMFB_GUID": [
    1433674657,
    25515,
    16492,
    190,
    126,
    145,
    205,
    188,
    8,
    196,
    87
  ],
  "XEN_BUS_ROOT_DEVICE_GUID": [
    2805081119,
    14397,
    19868,
    138,
    225,
    142,
    9,
    131,
    117,
    137,
    215
  ],
  "ROOT_BRIDGES_CONNECTED_EVENT_GROUP_GUID": [
    614651503,
    61149,
    16518,
    144,
    66,
    242,
    110,
    71,
    151,
    238,
    105
  ],
  "MICROSOFT_VENDOR_GUID": [
    2012912317,
    857,
    19762,
    189,
    96,
    40,
    244,
    231,
    143,
    120,
    75
  ],
  "EFI_LEGACY_DEV_ORDER_VARIABLE_GUID": [
    2774562011,
    26110,
    17911,
    189,
    33,
    45,
    43,
    221,
    142,
    150,
    82
  ],
  "VIRTIO_DEVICE_PROTOCOL_GUID": [
    4203872272,
    26501,
    18753,
    182,
    236,
    73,
    140,
    87,
    159,
    22,
    10
  ],
  "XEN_BUS_PROTOCOL_GUID": [
    1027383952,
    47525,
    4579,
    183,
    93,
    184,
    172,
    111,
    125,
    101,
    230
  ],
  "XEN_IO_PROTOCOL_GUID": [
    1861929039,
    2736,
    18247,
    129,
    190,
    133,
    85,
    98,
    89,
    4,
    73
  ],
  "IO_MMU_ABSENT_PROTOCOL_GUID": [
    4168572240,
    35517,
    19167,
    146,
    172,
    133,
    62,
    81,
    246,
    200,
    220
  ],
  "PC_AT_CHIPSET_PKG_TOKEN_SPACE_GUID": [
    845866787,
    44594,
    17801,
    152,
    184,
    202,
    194,
    60,
    220,
    193,
    177
  ],
  "EFI_SECURITY_PKG_TOKEN_SPACE_GUID": [
    222278006,
    38249,
    19793,
    163,
    239,
    125,
    97,
    198,
    79,
    234,
    186
  ],
  "EFI_SECURE_BOOT_ENABLE_DISABLE_GUID": [
    4037217223,
    44808,
    17750,
    153,
    196,
    0,
    16,
    9,
    201,
    58,
    68
  ],
  "EFI_CUSTOM_MODE_ENABLE_GUID": [
    3229019148,
    28712,
    17305,
    160,
    114,
    113,
    238,
    92,
    68,
    139,
    159
  ],
  "EFI_VENDOR_KEYS_NV_GUID": [
    2423514336,
    24812,
    19310,
    153,
    3,
    76,
    34,
    60,
    38,
    15,
    60
  ],
  "EFI_CERT_DB_GUID": [
    3653166446,
    30172,
    18905,
    180,
    215,
    181,
    52,
    33,
    15,
    99,
    122
  ],
  "TCG_EVENT_ENTRY_HOB_GUID": [
    731904850,
    6931,
    16751,
    168,
    123,
    188,
    147,
    13,
    239,
    146,
    168
  ],
  "TCG_EVENT2_ENTRY_HOB_GUID": [
    3530301982,
    9264,
    19594,
    145,
    112,
    63,
    203,
    69,
    0,
    65,
    63
  ],
  "TPM_ERROR_HOB_GUID": [
    4015621273,
    45662,
    18234,
    191,
    175,
    231,
    229,
    125,
    206,
    130,
    196
  ],
  "TPM2_STARTUP_LOCALITY_HOB_GUID": [
    60272841,
    8936,
    17822,
    164,
    255,
    153,
    188,
    101,
    39,
    9,
    41
  ],
  "TCG800155_PLATFORM_ID_EVENT_HOB_GUID": [
    3804478569,
    24924,
    19291,
    142,
    92,
    160,
    51,
    169,
    194,
    94,
    214
  ],
  "EFI_TCG2_PHYSICAL_PRESENCE_GUID": [
    2931410369,
    38129,
    19714,
    191,
    217,
    70,
    2,
    219,
    45,
    60,
    84
  ],
  "USER_IDENTIFY_MANAGER_GUID": [
    1020083672,
    36165,
    20461,
    150,
    45,
    43,
    56,
    205,
    130,
    179,
    196
  ],
  "TCG_CONFIG_FORM_SET_GUID": [
    2969108964,
    50212,
    17886,
    144,
    129,
    149,
    226,
    11,
    222,
    111,
    181
  ],
  "TCG2_CONFIG_FORM_SET_GUID": [
    1664734343,
    9914,
    16971,
    154,
    93,
    104,
    126,
    37,
    215,
    64,
    188
  ],
  "SECURE_BOOT_CONFIG_FORM_SET_GUID": [
    1571770533,
    60033,
    19938,
    143,
    155,
    202,
    189,
    169,
    207,
    92,
    20
  ],
  "EFI_TPM_DEVICE_INSTANCE_NONE_GUID": [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ],
  "EFI_TPM_DEVICE_INSTANCE_TPM12_GUID": [
    2332157366,
    20249,
    18152,
    171,
    147,
    28,
    83,
    103,
    27,
    144,
    204
  ],
  "EFI_TPM_DEVICE_INSTANCE_TPM20_DTPM_GUID": [
    678163034,
    49859,
    16524,
    179,
    180,
    37,
    230,
    117,
    139,
    115,
    23
  ],
  "EFI_TPM_DEVICE_SELECTED_GUID": [
    2134989011,
    1869,
    17773,
    140,
    178,
    1,
    249,
    200,
    247,
    157,
    170
  ],
  "OPAL_EXTRA_INFO_VARIABLE_GUID": [
    1151511901,
    24876,
    18355,
    176,
    110,
    200,
    245,
    11,
    251,
    240,
    125
  ],
  "PEI_LOCK_PHYSICAL_PRESENCE_PPI_GUID": [
    4019908581,
    11219,
    16433,
    175,
    125,
    94,
    254,
    90,
    187,
    154,
    13
  ],
  "PEI_TPM_INITIALIZATION_DONE_PPI_GUID": [
    2687553813,
    21725,
    17531,
    144,
    100,
    242,
    6,
    136,
    61,
    124,
    204
  ],
  "EFI_PEI_FIRMWARE_VOLUME_INFO_MEASUREMENT_EXCLUDED_PPI_GUID": [
    1845850105,
    50837,
    17252,
    158,
    44,
    97,
    38,
    245,
    206,
    234,
    174
  ],
  "EDKII_PEI_FIRMWARE_VOLUME_INFO_PREHASHED_FV_PPI_GUID": [
    1021437489,
    28680,
    18300,
    173,
    167,
    93,
    207,
    199,
    193,
    73,
    75
  ],
  "EDKII_PEI_FIRMWARE_VOLUME_INFO_STORED_HASH_FV_PPI_GUID": [
    2136886833,
    33201,
    18405,
    158,
    33,
    30,
    75,
    91,
    194,
    246,
    29
  ],
  "EFI_SHELL_ENVIRONMENT2_EXT_GUID": [
    3535898166,
    16613,
    20149,
    163,
    27,
    54,
    105,
    95,
    212,
    44,
    135
  ],
  "EFI_SHELL_PKG_TOKEN_SPACE_GUID": [
    387879304,
    12755,
    16629,
    177,
    12,
    83,
    155,
    45,
    185,
    64,
    205
  ],
  "SHELL_VARIABLE_GUID": [
    361623386,
    63062,
    16796,
    176,
    39,
    122,
    49,
    146,
    192,
    121,
    210
  ],
  "SHELL_MAP_GUID": [
    1361518099,
    32227,
    17327,
    139,
    194,
    113,
    173,
    59,
    130,
    67,
    37
  ],
  "HANDLE_PARSING_HII_GUID": [
    3096876599,
    33246,
    17327,
    188,
    154,
    36,
    217,
    137,
    19,
    242,
    246
  ],
  "SHELL_DEBUG1_HII_GUID": [
    636616874,
    54219,
    18186,
    191,
    81,
    231,
    209,
    98,
    210,
    46,
    111
  ],
  "SHELL_DRIVER1_HII_GUID": [
    183547714,
    25580,
    17853,
    141,
    182,
    113,
    173,
    127,
    47,
    232,
    232
  ],
  "SHELL_INSTALL1_HII_GUID": [
    2102873428,
    54116,
    19786,
    149,
    227,
    73,
    69,
    219,
    122,
    211,
    238
  ],
  "SHELL_LEVEL1_HII_GUID": [
    3737508516,
    26497,
    18464,
    156,
    99,
    167,
    176,
    228,
    241,
    219,
    49
  ],
  "SHELL_LEVEL2_HII_GUID": [
    4183456972,
    19541,
    17446,
    167,
    180,
    220,
    137,
    97,
    149,
    11,
    174
  ],
  "SHELL_LEVEL3_HII_GUID": [
    1128551821,
    20217,
    18213,
    177,
    228,
    51,
    118,
    232,
    214,
    151,
    79
  ],
  "SHELL_NETWORK1_HII_GUID": [
    4090692027,
    62629,
    17832,
    176,
    183,
    250,
    153,
    156,
    98,
    55,
    174
  ],
  "SHELL_NETWORK2_HII_GUID": [
    24425141,
    62725,
    19218,
    170,
    96,
    89,
    223,
    248,
    214,
    234,
    55
  ],
  "SHELL_TFTP_HII_GUID": [
    1938461460,
    33473,
    17810,
    143,
    247,
    193,
    189,
    241,
    178,
    14,
    212
  ],
  "SHELL_BCFG_HII_GUID": [
    1600086109,
    5507,
    18989,
    166,
    178,
    235,
    18,
    218,
    180,
    162,
    182
  ],
  "SHELL_ACPI_VIEW_HII_GUID": [
    3666660852,
    60815,
    20476,
    181,
    239,
    46,
    245,
    94,
    36,
    147,
    42
  ],
  "UEFI_SHELL_FILE_GUID": [
    2080679299,
    40510,
    20252,
    173,
    101,
    224,
    82,
    104,
    208,
    180,
    209
  ],
  "EFI_SIGNED_CAPSULE_PKG_TOKEN_SPACE_GUID": [
    3790299439,
    7276,
    18525,
    157,
    6,
    101,
    8,
    68,
    136,
    21,
    105
  ],
  "EDKII_SYSTEM_FIRMWARE_IMAGE_DESCRIPTOR_FILE_GUID": [
    2427631686,
    51821,
    19822,
    168,
    211,
    193,
    64,
    168,
    225,
    16,
    172
  ],
  "EDKII_SYSTEM_FMP_CAPSULE_CONFIG_FILE_GUID": [
    2166437587,
    19770,
    17210,
    148,
    24,
    41,
    187,
    155,
    247,
    143,
    110
  ],
  "EDKII_SYSTEM_FMP_CAPSULE_DRIVER_FV_FILE_GUID": [
    3461853543,
    45284,
    16872,
    168,
    151,
    95,
    79,
    235,
    120,
    29,
    64
  ],
  "EFI_DEBUG_AGENT_GUID": [
    2254068379,
    47197,
    18252,
    132,
    85,
    101,
    209,
    190,
    132,
    75,
    226
  ],
  "EFI_SOURCE_LEVEL_DEBUG_PKG_TOKEN_SPACE_GUID": [
    2254068395,
    47197,
    18252,
    132,
    85,
    101,
    209,
    190,
    132,
    75,
    226
  ],
  "STANDALONE_SMM_PKG_TOKEN_SPACE_GUID": [
    419329586,
    62920,
    20067,
    141,
    232,
    23,
    165,
    92,
    89,
    19,
    189
  ],
  "MP_INFORMATION_HOB_GUID": [
    3123966301,
    16384,
    17857,
    142,
    136,
    249,
    22,
    146,
    212,
    87,
    227
  ],
  "MM_FV_DISPATCH_GUID": [
    3059127500,
    2531,
    19515,
    181,
    205,
    5,
    244,
    77,
    60,
    219,
    255
  ],
  "MM_CORE_DATA_HOB_GUID": [
    2707472281,
    10916,
    19837,
    153,
    147,
    137,
    156,
    177,
    45,
    243,
    118
  ],
  "EFI_SMM_PEI_MMRAM_MEMORY_RESERVE_GUID": [
    117700882,
    49037,
    20010,
    190,
    7,
    171,
    39,
    37,
    37,
    197,
    146
  ],
  "EFI_STANDALONE_SMM_NON_SECURE_BUFFER_GUID": [
    4026832867,
    49058,
    16801,
    157,
    41,
    84,
    194,
    233,
    55,
    33,
    197
  ],
  "EFI_ARM_TF_CPU_DRIVER_EP_DESCRIPTOR_GUID": [
    1858852257,
    49400,
    18178,
    131,
    1,
    79,
    194,
    197,
    71,
    10,
    81
  ],
  "UEFI_CPU_PKG_TOKEN_SPACE_GUID": [
    2886057779,
    39258,
    20180,
    170,
    184,
    239,
    122,
    232,
    15,
    92,
    176
  ],
  "MSEG_SMRAM_GUID": [
    1476574436,
    61166,
    20019,
    161,
    48,
    235,
    173,
    39,
    240,
    228,
    57
  ],
  "EDKII_CPU_FEATURES_SET_DONE_GUID": [
    2820965838,
    44395,
    16641,
    153,
    211,
    225,
    53,
    140,
    158,
    126,
    55
  ],
  "EDKII_CPU_FEATURES_INIT_DONE_GUID": [
    3346807361,
    25003,
    16707,
    152,
    62,
    51,
    57,
    40,
    6,
    40,
    229
  ],
  "EDKII_MICROCODE_PATCH_HOB_GUID": [
    3514364189,
    34582,
    16782,
    161,
    49,
    150,
    125,
    42,
    196,
    40,
    67
  ],
  "EFI_SMM_CPU_SERVICE_PROTOCOL_GUID": [
    488647851,
    51371,
    19804,
    148,
    247,
    60,
    252,
    192,
    211,
    211,
    53
  ],
  "EFI_SM_MONITOR_INIT_PROTOCOL_GUID": [
    579810381,
    46046,
    17339,
    164,
    215,
    234,
    32,
    11,
    27,
    20,
    130
  ],
  "EDKII_PEI_MP_SERVICES2_PPI_GUID": [
    1555680061,
    12708,
    18444,
    148,
    152,
    41,
    210,
    105,
    186,
    207,
    186
  ],
  "UEFI_PAYLOAD_PKG_TOKEN_SPACE_GUID": [
    30484458,
    63217,
    20214,
    148,
    21,
    138,
    0,
    0,
    147,
    248,
    157
  ],
  "BMP_IMAGE_GUID": [
    2274017996,
    21315,
    18162,
    181,
    99,
    81,
    248,
    157,
    175,
    86,
    186
  ],
  "UEFI_SYSTEM_TABLE_INFO_GUID": [
    382248656,
    65162,
    16514,
    162,
    8,
    207,
    137,
    196,
    41,
    4,
    51
  ],
  "UEFI_ACPI_BOARD_INFO_GUID": [
    181654299,
    46040,
    17670,
    174,
    113,
    46,
    241,
    16,
    6,
    217,
    15
  ],
  "UEFI_SERIAL_PORT_INFO_GUID": [
    1818784510,
    22185,
    17411,
    187,
    152,
    149,
    141,
    98,
    222,
    135,
    241
  ],
  "LOADER_MEMORY_MAP_INFO_GUID": [
    2717873188,
    31258,
    18318,
    169,
    228,
    146,
    243,
    87,
    209,
    40,
    50
  ],
  "EFI_PAY_LOAD_HOB_BASE_PPI_GUID": [
    3689036449,
    41794,
    19351,
    133,
    182,
    178,
    38,
    241,
    97,
    115,
    137
  ],
  "APPLE_REMOVABLE_MEDIA_PROTOCOL_GUID": [
    782857274,
    9177,
    16990,
    135,
    44,
    246,
    21,
    170,
    25,
    87,
    136
  ],
  "ARM_GLOBAL_VARIABLE_PPI_GUID": [
    2870745110,
    54594,
    20079,
    155,
    30,
    142,
    205,
    146,
    83,
    226,
    231
  ],
  "ARM_HOB_GLOBAL_VARIABLE_GUID": [
    3273997456,
    41551,
    17817,
    166,
    100,
    31,
    136,
    19,
    119,
    143,
    201
  ],
  "BDS_LIB_STRING_PACKAGE_GUID": [
    994941731,
    38316,
    17654,
    159,
    205,
    14,
    149,
    148,
    88,
    108,
    114
  ],
  "BLOCK_MMIO_PROTOCOL_GUID": [
    1800768739,
    27109,
    19559,
    166,
    52,
    247,
    254,
    114,
    173,
    190,
    132
  ],
  "DP_HII_GUID": [
    3951243225,
    37001,
    18584,
    131,
    201,
    65,
    97,
    143,
    92,
    72,
    185
  ],
  "DXE_CORE_FILE_NAME_GUID": [
    3600993151,
    27160,
    20015,
    180,
    59,
    153,
    32,
    167,
    51,
    112,
    10
  ],
  "ECP_PEI_PCI_CFG_PPI_GUID": [
    2968409044,
    41033,
    19065,
    178,
    255,
    25,
    217,
    250,
    239,
    170,
    148
  ],
  "EFI_ACPI_VARIABLE_COMPATIBILITY_GUID": [
    3223341214,
    28082,
    20210,
    154,
    165,
    202,
    6,
    252,
    17,
    211,
    106
  ],
  "EFI_CONSOLE_CONTROL_PROTOCOL_GUID": [
    4096751490,
    302,
    19474,
    153,
    86,
    73,
    249,
    67,
    4,
    247,
    33
  ],
  "EFI_DATA_HUB_STATUS_CODE_RECORD_GUID": [
    3498305868,
    25952,
    17124,
    182,
    212,
    45,
    247,
    90,
    223,
    106,
    42
  ],
  "EFI_DEBUG_SERIAL_IO_PROTOCOL_GUID": [
    3867401295,
    2541,
    20258,
    134,
    107,
    142,
    64,
    70,
    148,
    124,
    108
  ],
  "EFI_DEBUG_SUPPORT_PERIODIC_CALLBACK_PROTOCOL_GUID": [
    2504450172,
    11451,
    19592,
    152,
    108,
    205,
    52,
    16,
    134,
    240,
    68
  ],
  "EFI_DEFAULT_BMP_LOGO_GUID": [
    2075298713,
    25019,
    4565,
    154,
    93,
    0,
    144,
    39,
    63,
    193,
    77
  ],
  "EFI_EMU_SYSTEM_CONFIG_GUID": [
    2622469398,
    14878,
    55367,
    161,
    161,
    112,
    88,
    182,
    152,
    103,
    50
  ],
  "EFI_ERROR_SECTION_FW_ERROR_RECORD_GUID": [
    2166434454,
    2541,
    18838,
    148,
    113,
    141,
    114,
    156,
    142,
    105,
    237
  ],
  "EFI_ERROR_SECTION_PCI_PCIX_BUS_GUID": [
    3312793955,
    15236,
    16533,
    191,
    120,
    237,
    218,
    211,
    249,
    201,
    221
  ],
  "EFI_EVENT_GROUP_DXE_DISPATCH_GUID": [
    1887560239,
    51910,
    16467,
    148,
    104,
    103,
    87,
    130,
    207,
    136,
    229
  ],
  "EFI_FORM_BROWSER_COMPATIBILITY_PROTOCOL_GUID": [
    263702610,
    44490,
    18515,
    141,
    15,
    251,
    167,
    27,
    28,
    225,
    26
  ],
  "EFI_HII_COMPATIBILITY_PROTOCOL_GUID": [
    1430441185,
    57180,
    19739,
    171,
    202,
    54,
    79,
    119,
    211,
    153,
    251
  ],
  "EFI_KMS_FORMAT_AESCBC_128_GUID": [
    2699619946,
    3730,
    17620,
    134,
    27,
    14,
    170,
    74,
    202,
    68,
    162
  ],
  "EFI_KMS_FORMAT_AESCBC_256_GUID": [
    3622213513,
    8040,
    17896,
    150,
    239,
    59,
    100,
    7,
    165,
    178,
    220
  ],
  "EFI_KMS_FORMAT_AESXTS_128_GUID": [
    1198973759,
    56135,
    18330,
    162,
    95,
    161,
    205,
    10,
    250,
    179,
    139
  ],
  "EFI_KMS_FORMAT_AESXTS_256_GUID": [
    3699279379,
    50363,
    19888,
    132,
    98,
    19,
    81,
    19,
    87,
    171,
    226
  ],
  "EFI_KMS_FORMAT_GENERIC_1024_GUID": [
    1136528196,
    34635,
    20141,
    176,
    156,
    36,
    26,
    79,
    189,
    126,
    179
  ],
  "EFI_KMS_FORMAT_GENERIC_128_GUID": [
    3968482665,
    28127,
    16648,
    148,
    118,
    115,
    55,
    252,
    82,
    33,
    54
  ],
  "EFI_KMS_FORMAT_GENERIC_160_GUID": [
    2746476280,
    61386,
    19393,
    136,
    251,
    203,
    135,
    51,
    155,
    37,
    121
  ],
  "EFI_KMS_FORMAT_GENERIC_2048_GUID": [
    1074347811,
    25356,
    17958,
    156,
    72,
    64,
    55,
    59,
    25,
    203,
    190
  ],
  "EFI_KMS_FORMAT_GENERIC_256_GUID": [
    1895188371,
    49955,
    16993,
    172,
    44,
    216,
    118,
    242,
    124,
    83,
    69
  ],
  "EFI_KMS_FORMAT_GENERIC_3072_GUID": [
    3106108691,
    27716,
    17425,
    169,
    144,
    33,
    229,
    86,
    224,
    90,
    222
  ],
  "EFI_KMS_FORMAT_GENERIC_512_GUID": [
    2542788675,
    55215,
    16942,
    138,
    146,
    43,
    72,
    228,
    99,
    189,
    230
  ],
  "EFI_KMS_FORMAT_MD2_128_GUID": [
    2025722308,
    60996,
    18978,
    159,
    5,
    3,
    133,
    46,
    197,
    201,
    120
  ],
  "EFI_KMS_FORMAT_MD4_128_GUID": [
    3519117985,
    51909,
    16399,
    190,
    23,
    226,
    162,
    174,
    6,
    103,
    124
  ],
  "EFI_KMS_FORMAT_MD5SHA_128_GUID": [
    471302711,
    26775,
    17822,
    157,
    54,
    103,
    206,
    142,
    249,
    79,
    118
  ],
  "EFI_KMS_FORMAT_MD5_128_GUID": [
    3703322210,
    40154,
    19282,
    160,
    76,
    130,
    235,
    29,
    35,
    72,
    199
  ],
  "EFI_KMS_FORMAT_MDC2_128_GUID": [
    4155334904,
    61352,
    17571,
    145,
    19,
    35,
    31,
    57,
    158,
    180,
    199
  ],
  "EFI_KMS_FORMAT_MDC4_128_GUID": [
    1067776071,
    55531,
    19956,
    189,
    73,
    16,
    58,
    10,
    132,
    123,
    188
  ],
  "EFI_KMS_FORMAT_RSASHA1_1024_GUID": [
    1447132141,
    27582,
    18562,
    134,
    160,
    58,
    232,
    187,
    23,
    248,
    249
  ],
  "EFI_KMS_FORMAT_RSASHA1_2048_GUID": [
    4133767124,
    30118,
    17982,
    168,
    25,
    7,
    127,
    45,
    218,
    5,
    233
  ],
  "EFI_KMS_FORMAT_RSASHA256_2048_GUID": [
    2759307027,
    34685,
    16480,
    186,
    161,
    37,
    209,
    190,
    160,
    138,
    211
  ],
  "EFI_KMS_FORMAT_SHA1_160_GUID": [
    1161584218,
    18477,
    17392,
    135,
    201,
    89,
    65,
    243,
    163,
    138,
    194
  ],
  "EFI_KMS_FORMAT_SHA256_256_GUID": [
    1807021517,
    32802,
    17549,
    188,
    109,
    119,
    27,
    174,
    147,
    95,
    198
  ],
  "EFI_KMS_FORMAT_SHA512_512_GUID": [
    790892050,
    57677,
    18268,
    131,
    176,
    239,
    255,
    34,
    215,
    123,
    231
  ],
  "EFI_LEGACY_REGION_PROTOCOL_GUID": [
    264831290,
    1384,
    19369,
    155,
    126,
    201,
    195,
    144,
    166,
    96,
    155
  ],
  "EFI_LOAD_FIXED_ADDRESS_CONFIGURATION_TABLE_GUID": [
    749243219,
    53910,
    16512,
    164,
    165,
    202,
    217,
    186,
    226,
    75,
    9
  ],
  "EFI_MEASURED_FV_HOB_GUID": [
    2989886274,
    29043,
    16906,
    134,
    150,
    70,
    202,
    107,
    171,
    16,
    96
  ],
  "EFI_NIC_IP4_CONFIG_NVDATA_GUID": [
    165000511,
    62640,
    20313,
    160,
    177,
    123,
    87,
    211,
    92,
    14,
    5
  ],
  "EFI_NT_LOAD_AS_DLL_PPI_GUID": [
    3435478891,
    41018,
    20184,
    131,
    154,
    3,
    217,
    156,
    2,
    180,
    227
  ],
  "EFI_PEI_BOOT_SCRIPT_EXECUTER_PPI_GUID": [
    2882807957,
    30927,
    18546,
    132,
    68,
    27,
    92,
    24,
    11,
    251,
    255
  ],
  "EFI_PEI_FIND_FV_PPI_GUID": [
    907429906,
    40995,
    17637,
    189,
    133,
    5,
    191,
    60,
    119,
    0,
    170
  ],
  "EFI_PEI_PERMANENT_MEMORY_INSTALLED_PPI_GUID": [
    4170474557,
    50249,
    17105,
    142,
    168,
    133,
    189,
    216,
    198,
    91,
    222
  ],
  "EFI_PEI_READ_ONLY_VARIABLE_ACCESS_PPI_GUID": [
    1021087942,
    5115,
    19061,
    158,
    121,
    89,
    233,
    221,
    120,
    185,
    250
  ],
  "EFI_PEI_RECOVERY_BLOCK_IO_PPI_GUID": [
    1767738017,
    17134,
    19526,
    128,
    92,
    110,
    166,
    188,
    231,
    153,
    227
  ],
  "EFI_PEI_S3_RESUME_PPI_GUID": [
    1143393458,
    59012,
    19082,
    174,
    64,
    32,
    212,
    176,
    37,
    183,
    16
  ],
  "EFI_PEI_SECURITY_PPI_GUID": [
    327681646,
    14935,
    20218,
    152,
    243,
    193,
    47,
    58,
    149,
    138,
    41
  ],
  "EFI_PEI_SMBUS_PPI_GUID": [
    2882807957,
    30927,
    18546,
    132,
    68,
    27,
    92,
    24,
    11,
    251,
    218
  ],
  "EFI_PEI_TEMPORARY_RAM_DONE_PPI_GUID": [
    3467339836,
    60502,
    18989,
    169,
    6,
    64,
    83,
    250,
    78,
    156,
    22
  ],
  "EFI_PEI_VECTOR_HANDOFF_INFO_PPI_GUID": [
    1020678836,
    27955,
    19918,
    137,
    219,
    131,
    223,
    151,
    102,
    252,
    202
  ],
  "EFI_PHYSICAL_PRESENCE_DATA_GUID": [
    258251185,
    59821,
    18749,
    185,
    194,
    47,
    144,
    129,
    92,
    108,
    188
  ],
  "EFI_RUNTIME_CRYPT_PROTOCOL_GUID": [
    3779550732,
    5958,
    18434,
    134,
    46,
    1,
    28,
    44,
    45,
    157,
    134
  ],
  "EFI_SAL_MCA_INIT_PMI_PROTOCOL_GUID": [
    3054356200,
    15215,
    4565,
    175,
    9,
    0,
    160,
    201,
    68,
    160,
    91
  ],
  "EFI_SCSI_BUS_PROTOCOL_GUID": [
    1382097213,
    14909,
    17438,
    179,
    175,
    33,
    211,
    247,
    164,
    202,
    23
  ],
  "EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL_GUID": [
    947156930,
    27079,
    4562,
    142,
    57,
    0,
    160,
    201,
    105,
    114,
    59
  ],
  "EFI_SMM_BASE_HELPER_READY_PROTOCOL_GUID": [
    2433600007,
    8084,
    20199,
    175,
    47,
    255,
    114,
    243,
    21,
    67,
    83
  ],
  "EFI_SMM_VARIABLE_WRITE_GUID": [
    2478446630,
    57339,
    17885,
    130,
    167,
    231,
    220,
    170,
    59,
    189,
    243
  ],
  "EFI_TCG_EVENT_HOB_GUID": [
    774915244,
    34719,
    18703,
    151,
    96,
    187,
    223,
    175,
    105,
    95,
    80
  ],
  "EFI_TSC_FREQUENCY_GUID": [
    3685132259,
    47959,
    19431,
    138,
    248,
    213,
    120,
    219,
    126,
    86,
    135
  ],
  "EFI_UNIX_CONSOLE_GUID": [
    4073479430,
    35205,
    4571,
    187,
    25,
    0,
    64,
    208,
    43,
    24,
    53
  ],
  "EFI_UNIX_CPU_MODEL_GUID": [
    4073960240,
    35205,
    4571,
    138,
    163,
    0,
    64,
    208,
    43,
    24,
    53
  ],
  "EFI_UNIX_CPU_SPEED_GUID": [
    4074196570,
    35205,
    4571,
    151,
    5,
    0,
    64,
    208,
    43,
    24,
    53
  ],
  "EFI_UNIX_FILE_SYSTEM_GUID": [
    4072762270,
    35205,
    4571,
    146,
    200,
    0,
    64,
    208,
    43,
    24,
    53
  ],
  "EFI_UNIX_GOP_GUID": [
    3134064578,
    35207,
    4571,
    165,
    154,
    0,
    64,
    208,
    43,
    24,
    53
  ],
  "EFI_UNIX_IO_PROTOCOL_GUID": [
    4074913620,
    35205,
    4571,
    172,
    121,
    0,
    64,
    208,
    43,
    24,
    53
  ],
  "EFI_UNIX_MEMORY_GUID": [
    4073719500,
    35205,
    4571,
    164,
    114,
    0,
    64,
    208,
    43,
    24,
    53
  ],
  "EFI_UNIX_NETWORK_GUID": [
    135660468,
    3869,
    16418,
    182,
    253,
    76,
    227,
    94,
    9,
    161,
    166
  ],
  "EFI_UNIX_PHYSICAL_DISKS_GUID": [
    4072524950,
    35205,
    4571,
    135,
    25,
    0,
    64,
    208,
    43,
    24,
    53
  ],
  "EFI_UNIX_SERIAL_PORT_GUID": [
    1832546941,
    26312,
    19737,
    135,
    230,
    2,
    21,
    134,
    20,
    144,
    243
  ],
  "EFI_UNIX_THUNK_PROTOCOL_GUID": [
    4075391080,
    35205,
    4571,
    154,
    89,
    0,
    64,
    208,
    43,
    24,
    53
  ],
  "EFI_UNIX_UGA_GUID": [
    4073240590,
    35205,
    4571,
    147,
    241,
    0,
    64,
    208,
    43,
    24,
    53
  ],
  "EFI_UNIX_UGA_IO_PROTOCOL_GUID": [
    4075152070,
    35205,
    4571,
    161,
    145,
    0,
    64,
    208,
    43,
    24,
    53
  ],
  "EFI_UNIX_VIRTUAL_DISKS_GUID": [
    4072289050,
    35205,
    4571,
    164,
    6,
    0,
    64,
    208,
    43,
    24,
    53
  ],
  "EFI_UPDATE_DATA_FILE_GUID": [
    675259118,
    21292,
    18509,
    147,
    131,
    159,
    147,
    179,
    111,
    11,
    126
  ],
  "EFI_USB_BUS_PROTOCOL_GUID": [
    724527308,
    3282,
    17615,
    142,
    139,
    187,
    162,
    11,
    27,
    91,
    117
  ],
  "EFI_UXIX_SYSTEM_CONFIG_GUID": [
    928950646,
    15565,
    20084,
    168,
    69,
    38,
    185,
    179,
    36,
    177,
    60
  ],
  "EFI_WIN_NT_CONSOLE_GUID": [
    3128125228,
    42451,
    4564,
    189,
    0,
    0,
    128,
    199,
    60,
    136,
    129
  ],
  "EFI_WIN_NT_CPU_MODEL_GUID": [
    3202987726,
    12170,
    4564,
    189,
    13,
    0,
    128,
    199,
    60,
    136,
    129
  ],
  "EFI_WIN_NT_CPU_SPEED_GUID": [
    3572666453,
    57851,
    4564,
    189,
    13,
    0,
    128,
    199,
    60,
    136,
    129
  ],
  "EFI_WIN_NT_FILE_SYSTEM_GUID": [
    211134773,
    40966,
    4564,
    188,
    250,
    0,
    128,
    199,
    60,
    136,
    129
  ],
  "EFI_WIN_NT_GOP_GUID": [
    1309796693,
    52426,
    4564,
    189,
    13,
    0,
    128,
    199,
    60,
    136,
    129
  ],
  "EFI_WIN_NT_MEMORY_GUID": [
    2567186706,
    4650,
    4564,
    189,
    13,
    0,
    128,
    199,
    60,
    136,
    129
  ],
  "EFI_WIN_NT_PASS_THROUGH_GUID": [
    3429256888,
    15396,
    16518,
    182,
    246,
    52,
    232,
    86,
    188,
    227,
    110
  ],
  "EFI_WIN_NT_PHYSICAL_DISKS_GUID": [
    211134767,
    40966,
    4564,
    188,
    250,
    0,
    128,
    199,
    60,
    136,
    129
  ],
  "EFI_WIN_NT_SYSTEM_CONFIG_GUID": [
    3007836231,
    44940,
    18702,
    172,
    7,
    10,
    169,
    183,
    229,
    56,
    88
  ],
  "EFI_WIN_NT_UGA_GUID": [
    2871299737,
    44001,
    4564,
    189,
    13,
    0,
    128,
    199,
    60,
    136,
    129
  ],
  "EFI_WIN_NT_VIRTUAL_DISKS_GUID": [
    211134760,
    40966,
    4564,
    188,
    250,
    0,
    128,
    199,
    60,
    136,
    129
  ],
  "EMBEDDED_DEVICE_PROTOCOL_GUID": [
    3209403664,
    5100,
    17373,
    136,
    128,
    233,
    11,
    113,
    143,
    39,
    222
  ],
  "FORM_BROWSER_EXTENSION_PROTOCOL_GUID": [
    527675789,
    17968,
    17345,
    161,
    222,
    111,
    128,
    133,
    93,
    125,
    164
  ],
  "FRAMEWORK_EFI_MP_SERVICES_PROTOCOL_GUID": [
    4080165351,
    9163,
    4565,
    189,
    92,
    0,
    128,
    199,
    60,
    136,
    129
  ],
  "HD_BOOT_DEVICE_PATH_VARIABLE_GUID": [
    4206356961,
    14813,
    20267,
    132,
    8,
    226,
    14,
    144,
    108,
    182,
    222
  ],
  "HII_RESOURCE_SAMPLE_FORM_SET_GUID": [
    1330575344,
    43561,
    19689,
    186,
    65,
    100,
    62,
    1,
    35,
    169,
    159
  ],
  "ISCSI_V4_PRIVATE_GUID": [
    4198293068,
    34754,
    17021,
    174,
    222,
    125,
    208,
    150,
    200,
    140,
    88
  ],
  "ISCSI_V6_PRIVATE_GUID": [
    683550693,
    26316,
    18993,
    163,
    21,
    219,
    20,
    195,
    116,
    77,
    133
  ],
  "LAST_ENUM_LANGUAGE_GUID": [
    244077659,
    41710,
    18189,
    142,
    38,
    189,
    161,
    161,
    60,
    10,
    163
  ],
  "LDR_MEMORY_DESCRIPTOR_GUID": [
    1996609509,
    32029,
    17458,
    164,
    104,
    103,
    61,
    171,
    138,
    222,
    96
  ],
  "LOCAL_EFI_WIN_NT_BUS_DRIVER_IO_PROTOCOL_GUID": [
    2532002518,
    41770,
    4564,
    188,
    253,
    0,
    128,
    199,
    60,
    136,
    129
  ],
  "LOCAL_EFI_WIN_NT_SERIAL_PORT_GUID": [
    211134781,
    40966,
    4564,
    188,
    250,
    0,
    128,
    199,
    60,
    136,
    129
  ],
  "LOCAL_EFI_WIN_NT_THUNK_PROTOCOL_GUID": [
    1489311921,
    30451,
    4564,
    188,
    234,
    0,
    128,
    199,
    60,
    136,
    129
  ],
  "MY_GUID": [
    305419896,
    43707,
    52445,
    238,
    255,
    17,
    34,
    51,
    68,
    85,
    102
  ],
  "NT_FWH_PPI_GUID": [
    1316393615,
    20653,
    17204,
    176,
    107,
    168,
    66,
    19,
    16,
    138,
    87
  ],
  "PEI_NT_THUNK_PPI_GUID": [
    2562884069,
    63750,
    17373,
    169,
    43,
    176,
    3,
    191,
    39,
    101,
    218
  ],
  "PEI_OPERATOR_PRESENCE_PPI_GUID": [
    547829644,
    43651,
    19681,
    130,
    31,
    71,
    64,
    238,
    27,
    63,
    159
  ],
  "PEI_UNIX_AUTOSCAN_PPI_GUID": [
    4075633940,
    35205,
    4571,
    176,
    87,
    0,
    64,
    208,
    43,
    24,
    53
  ],
  "PEI_UNIX_THUNK_PPI_GUID": [
    4076351730,
    35205,
    4571,
    128,
    107,
    0,
    64,
    208,
    43,
    24,
    53
  ],
  "PRE_PI_EXTRACT_GUIDED_SECTION_DATA_GUID": [
    945461292,
    12105,
    16451,
    165,
    30,
    73,
    1,
    2,
    92,
    139,
    107
  ],
  "PWD_CREDENTIAL_PROVIDER_GUID": [
    2025450635,
    49152,
    18117,
    172,
    147,
    36,
    160,
    193,
    187,
    0,
    206
  ],
  "SHELL_ALIAS_VARIABLE_GUID": [
    5495254,
    9817,
    17817,
    162,
    107,
    239,
    69,
    54,
    230,
    49,
    169
  ],
  "SHELL_ENVIRONMENT_PROTOCOL_GUID": [
    1204269601,
    50218,
    4562,
    142,
    87,
    0,
    160,
    201,
    105,
    114,
    59
  ],
  "SHELL_INTERFACE_PROTOCOL_GUID": [
    1204269603,
    50218,
    4562,
    142,
    87,
    0,
    160,
    201,
    105,
    114,
    59
  ],
  "SYSTEM_ROM_FILE_GUID": [
    357020915,
    16010,
    20463,
    129,
    200,
    50,
    142,
    214,
    71,
    171,
    26
  ],
  "UNIX_FWH_PPI_GUID": [
    4075871280,
    35205,
    4571,
    161,
    91,
    0,
    64,
    208,
    43,
    24,
    53
  ],
  "UNIX_PEI_LOAD_FILE_GUID": [
    4076111720,
    35205,
    4571,
    184,
    218,
    0,
    64,
    208,
    43,
    24,
    53
  ],
  "USB_CREDENTIAL_PROVIDER_GUID": [
    3498352337,
    43148,
    19366,
    177,
    214,
    171,
    80,
    226,
    128,
    183,
    169
  ],
  "USER_PROFILE_MANAGER_GUID": [
    3277793068,
    38850,
    18010,
    162,
    22,
    105,
    107,
    102,
    138,
    140,
    254
  ],
  "VIRTUAL_UNCACHED_PAGES_PROTOCOL_GUID": [
    2909084797,
    15394,
    19903,
    146,
    232,
    56,
    167,
    205,
    174,
    135,
    178
  ],
  "LENOVO_SYSTEM_USB_SWITCH_DXE_GUID": [
    1293931,
    8600,
    17393,
    147,
    186,
    42,
    126,
    215,
    177,
    225,
    204
  ],
  "LENOVO_SYSTEM_SCSI_BUS_DXE_GUID": [
    23579844,
    53495,
    20257,
    163,
    239,
    158,
    100,
    183,
    205,
    206,
    139
  ],
  "LENOVO_SYSTEM_AHCI_BUS_DXE_GUID": [
    23579844,
    53495,
    20257,
    163,
    239,
    158,
    100,
    183,
    205,
    206,
    140
  ],
  "LENOVO_MNP_DXE_BIN_GUID": [
    39567303,
    59049,
    19339,
    130,
    173,
    104,
    21,
    161,
    174,
    175,
    74
  ],
  "LENOVO_ISSC_SMM_GUID": [
    62871161,
    22345,
    19397,
    165,
    63,
    71,
    71,
    29,
    167,
    103,
    200
  ],
  "LENOVO_EC_IO_SMM_GUID": [
    65788747,
    38586,
    20288,
    131,
    41,
    127,
    58,
    168,
    134,
    87,
    7
  ],
  "LENOVO_EN25_QH32_FLASH_PART_DXE_GUID": [
    85592951,
    49254,
    17936,
    153,
    4,
    191,
    37,
    194,
    150,
    214,
    230
  ],
  "LENOVO_MTM_FORMAT_SMM_GUID": [
    104351088,
    5760,
    17952,
    157,
    0,
    106,
    217,
    227,
    204,
    177,
    159
  ],
  "LENOVO_DXE_RICOH_INIT_GUID": [
    110529390,
    63008,
    20109,
    166,
    166,
    82,
    85,
    35,
    84,
    221,
    117
  ],
  "LENOVO_SECURITY_VARIABLE_DXE_GUID": [
    115245642,
    42210,
    17045,
    163,
    246,
    3,
    179,
    254,
    245,
    177,
    9
  ],
  "LENOVO_IBEX_PEAK_FLASH_CONTROLLER_DXE_GUID": [
    119797899,
    33039,
    20036,
    146,
    160,
    165,
    200,
    59,
    67,
    54,
    152
  ],
  "LENOVO_BOARD_INFO_SMM_GUID": [
    124839840,
    39994,
    18844,
    163,
    17,
    47,
    131,
    133,
    8,
    5,
    86
  ],
  "LENOVO_SYSTEM_METRONOME_DXE_GUID": [
    128529162,
    62279,
    4564,
    154,
    73,
    0,
    144,
    39,
    63,
    193,
    77
  ],
  "LENOVO_SLP2_DXE_GUID": [
    142514016,
    8117,
    18935,
    135,
    154,
    133,
    61,
    43,
    33,
    76,
    199
  ],
  "LENOVO_CRYPT_SERVICE_SMM_GUID": [
    150721327,
    34431,
    17707,
    177,
    52,
    112,
    81,
    97,
    247,
    51,
    51
  ],
  "LENOVO_SYSTEM_SCSI_DISK_DXE_GUID": [
    174514978,
    14144,
    19662,
    173,
    98,
    189,
    23,
    44,
    236,
    202,
    53
  ],
  "LENOVO_SYSTEM_USB_SWITCH_SMM_GUID": [
    191532512,
    25217,
    16546,
    142,
    154,
    9,
    241,
    161,
    138,
    109,
    64
  ],
  "LENOVO_EC_FW_UPDATE_DXE_GUID": [
    205090762,
    27610,
    18965,
    182,
    163,
    166,
    250,
    69,
    68,
    189,
    183
  ],
  "LENOVO_SETUP_UNDER_OS_DXE_GUID": [
    224691302,
    14013,
    17094,
    178,
    135,
    124,
    59,
    170,
    37,
    117,
    192
  ],
  "LENOVO_BDS_CTRL_GUID": [
    266426805,
    1903,
    19510,
    191,
    38,
    215,
    36,
    242,
    131,
    18,
    82
  ],
  "LENOVO_SYSTEM_FIRMWARE_DEVICE_DXE_GUID": [
    269784614,
    21891,
    17252,
    130,
    47,
    164,
    89,
    184,
    18,
    19,
    2
  ],
  "LENOVO_EC_IO_DXE_GUID": [
    290235916,
    55653,
    19475,
    190,
    247,
    196,
    6,
    34,
    72,
    225,
    250
  ],
  "LENOVO_SYSTEM_SMM_AHCI_ASPI_LEGACY_RT_GUID": [
    306851450,
    6473,
    18494,
    137,
    159,
    96,
    50,
    144,
    76,
    160,
    167
  ],
  "LENOVO_BOOT_MENU_DXE_GUID": [
    308966957,
    22360,
    20426,
    133,
    49,
    32,
    26,
    127,
    87,
    248,
    80
  ],
  "LENOVO_FP_PBA_GUID": [
    317155615,
    7918,
    20180,
    135,
    147,
    105,
    226,
    128,
    29,
    96,
    42
  ],
  "LENOVO_SYSTEM_EBC_DXE_GUID": [
    330067408,
    29648,
    4564,
    176,
    107,
    0,
    170,
    0,
    189,
    109,
    231
  ],
  "LENOVO_SYSTEM_SMM_SERVICES_SMM_GUID": [
    352631419,
    22776,
    19730,
    150,
    56,
    180,
    148,
    167,
    4,
    67,
    118
  ],
  "LENOVO_EC_SERVICE_GUID": [
    365429572,
    63872,
    19445,
    170,
    160,
    191,
    190,
    2,
    122,
    239,
    22
  ],
  "LENOVO_SECURE_FLASH_VERIFY_SMM_GUID": [
    366827126,
    9849,
    20004,
    156,
    170,
    133,
    178,
    45,
    216,
    147,
    235
  ],
  "LENOVO_EN25_QH128_FLASH_PART_SMM_GUID": [
    386766184,
    51561,
    20385,
    165,
    51,
    219,
    103,
    121,
    191,
    190,
    98
  ],
  "LENOVO_COMPUTRACE_SMI_SERVICES_GUID": [
    408391285,
    53363,
    16899,
    144,
    210,
    135,
    136,
    168,
    113,
    228,
    77
  ],
  "LENOVO_SMM_VIDEO_INT10_GUID": [
    431419749,
    30805,
    17128,
    170,
    111,
    35,
    97,
    202,
    135,
    224,
    36
  ],
  "LENOVO_TCP_DXE_BIN_GUID": [
    444482664,
    12117,
    19030,
    144,
    60,
    1,
    38,
    94,
    183,
    98,
    43
  ],
  "LENOVO_SYSTEM_BOOT_SCRIPT_SAVE_DXE_GUID": [
    476786607,
    55485,
    17617,
    169,
    30,
    115,
    33,
    180,
    194,
    243,
    209
  ],
  "LENOVO_EAIA_DXE_GUID": [
    488641077,
    12096,
    20412,
    134,
    80,
    133,
    2,
    9,
    45,
    98,
    171
  ],
  "LENOVO_SYSTEM_PS2_MOUSE_DXE_GUID": [
    539634446,
    39473,
    18450,
    178,
    145,
    135,
    71,
    223,
    21,
    36,
    57
  ],
  "LENOVO_SMART_CARD_DETECT_DXE_GUID": [
    582945669,
    20147,
    18331,
    169,
    233,
    165,
    247,
    207,
    204,
    167,
    135
  ],
  "LENOVO_PLATFORM_FLASH_DXE_GUID": [
    590885754,
    18352,
    19521,
    156,
    167,
    1,
    96,
    251,
    148,
    223,
    244
  ],
  "LENOVO_MX25_L3206_EFLASH_PART_SMM_GUID": [
    596469069,
    42669,
    16840,
    163,
    27,
    103,
    163,
    32,
    134,
    37,
    195
  ],
  "LENOVO_TPM_ENABLER_DXE_GUID": [
    601439914,
    1827,
    17753,
    183,
    104,
    94,
    34,
    223,
    118,
    45,
    228
  ],
  "LENOVO_SYSTEM_USB_SUPPORT_POLICY_SMM_GUID": [
    604377783,
    41059,
    4564,
    154,
    58,
    0,
    144,
    39,
    63,
    193,
    76
  ],
  "LENOVO_SYSTEM_USB_BUS_DXE_GUID": [
    604377783,
    41059,
    4564,
    154,
    58,
    0,
    144,
    39,
    63,
    193,
    77
  ],
  "LENOVO_SYSTEM_USB_SUPPORT_POLICY_DXE_GUID": [
    604377783,
    41059,
    4564,
    154,
    58,
    0,
    144,
    39,
    63,
    193,
    78
  ],
  "LENOVO_SMM_OEMINT15_GUID": [
    607947914,
    48080,
    19113,
    190,
    23,
    207,
    155,
    88,
    49,
    48,
    236
  ],
  "LENOVO_SYSTEM_STATUS_CODE_GENERIC_RT_GUID": [
    611294986,
    4579,
    17818,
    174,
    6,
    55,
    43,
    220,
    77,
    232,
    6
  ],
  "LENOVO_CRYPT_SERVICE_GUID": [
    626323294,
    51658,
    19016,
    157,
    148,
    36,
    158,
    177,
    232,
    124,
    45
  ],
  "LENOVO_TCG_SERVICES_DXE_GUID": [
    636784743,
    42587,
    18677,
    187,
    190,
    53,
    65,
    140,
    72,
    136,
    54
  ],
  "LENOVO_FDISK_OEM_GUID": [
    652065439,
    23309,
    20096,
    134,
    178,
    128,
    218,
    228,
    208,
    27,
    14
  ],
  "LENOVO_PCH_SPI_SMM_GUID": [
    670339451,
    42759,
    19117,
    150,
    118,
    38,
    223,
    22,
    140,
    191,
    13
  ],
  "LENOVO_IVB_GOP_DRIVER_GUID": [
    682992732,
    52317,
    16929,
    157,
    255,
    134,
    176,
    244,
    45,
    220,
    1
  ],
  "LENOVO_SYSTEM_STATUS_CODE_PORT80_RT_GUID": [
    698459927,
    14057,
    18912,
    179,
    129,
    234,
    59,
    95,
    247,
    9,
    66
  ],
  "LENOVO_W25_Q64_FLASH_PART_DXE_GUID": [
    708977825,
    9737,
    16551,
    136,
    226,
    166,
    141,
    192,
    241,
    209,
    128
  ],
  "LENOVO_SYSTEM_USB_MEMORY_MANAGER_SMM_GUID": [
    717954629,
    57252,
    20467,
    143,
    129,
    145,
    247,
    215,
    135,
    210,
    45
  ],
  "LENOVO_SYSTEM_ACPI_S3_SAVE_DXE_GUID": [
    736024197,
    63283,
    17759,
    168,
    64,
    67,
    162,
    43,
    121,
    31,
    179
  ],
  "LENOVO_SA_LATE_INIT_SMM_GUID": [
    756954652,
    31551,
    19733,
    139,
    31,
    102,
    229,
    81,
    250,
    189,
    199
  ],
  "LENOVO_SYSTEM_USB_MOUSE_DXE_GUID": [
    758014634,
    40655,
    17335,
    130,
    25,
    148,
    231,
    252,
    113,
    61,
    254
  ],
  "LENOVO_SYSTEM_USB_KB_DXE_GUID": [
    758014671,
    40655,
    17335,
    130,
    25,
    148,
    231,
    252,
    113,
    61,
    254
  ],
  "LENOVO_PLATFORM_DXE_GUID": [
    762263487,
    39676,
    19109,
    160,
    38,
    50,
    178,
    252,
    243,
    15,
    185
  ],
  "LENOVO_PCH_BIOS_WRITE_PROTECT_GUID": [
    786963147,
    25778,
    16814,
    134,
    53,
    112,
    48,
    209,
    108,
    74,
    168
  ],
  "LENOVO_TP_ACPI_NVS_INIT_DXE_GUID": [
    807013315,
    47638,
    18937,
    133,
    139,
    222,
    224,
    95,
    145,
    231,
    184
  ],
  "LENOVO_SNB_GOP_DRIVER_GUID": [
    823145156,
    39078,
    19974,
    140,
    3,
    216,
    21,
    253,
    31,
    231,
    9
  ],
  "LENOVO_SYSTEM_USB_DATABASE_SMM_GUID": [
    828477649,
    24136,
    19477,
    172,
    114,
    55,
    83,
    47,
    58,
    30,
    193
  ],
  "LENOVO_SYSTEM_FORM_BROWSER_CORE_DXE_GUID": [
    843328777,
    7441,
    20007,
    138,
    171,
    144,
    254,
    106,
    203,
    4,
    137
  ],
  "LENOVO_BIOS_EXTENSION_LOADER_GUID": [
    851560952,
    54591,
    16840,
    148,
    208,
    246,
    115,
    159,
    35,
    16,
    17
  ],
  "LENOVO_SYSTEM_HII_DATABASE_DXE_GUID": [
    881610082,
    49085,
    18562,
    158,
    206,
    200,
    11,
    177,
    196,
    120,
    59
  ],
  "LENOVO_ATP_DXE_GUID": [
    886382265,
    30427,
    19631,
    148,
    174,
    147,
    72,
    86,
    232,
    149,
    246
  ],
  "LENOVO_DXE_MAIN_GUID": [
    901290186,
    46761,
    18894,
    140,
    114,
    144,
    71,
    53,
    204,
    73,
    183
  ],
  "LENOVO_SYSTEM_SPLASH_DXE_GUID": [
    923302804,
    61249,
    18807,
    147,
    226,
    63,
    106,
    223,
    221,
    6,
    225
  ],
  "LENOVO_SYSTEM_IMAGE_DISPLAY_DXE_GUID": [
    924820664,
    32834,
    20182,
    173,
    167,
    169,
    135,
    189,
    44,
    223,
    10
  ],
  "LENOVO_SYSTEM_RTC_RT_GUID": [
    932019045,
    36265,
    18291,
    182,
    228,
    164,
    120,
    38,
    168,
    51,
    225
  ],
  "LENOVO_SYSTEM_IDE_ATA_ATAPI_PASS_THRU_DXE_GUID": [
    933285920,
    52433,
    4573,
    173,
    139,
    8,
    0,
    32,
    12,
    154,
    102
  ],
  "LENOVO_SETUP_MAIN_DXE_GUID": [
    934268757,
    11916,
    18210,
    185,
    80,
    180,
    139,
    145,
    101,
    197,
    107
  ],
  "LENOVO_ME_PCI_UPDATE_GUID": [
    937281513,
    31773,
    19995,
    178,
    203,
    78,
    213,
    209,
    37,
    39,
    179
  ],
  "LENOVO_PHX_GOP_DXE_GUID": [
    938270500,
    33875,
    18282,
    171,
    88,
    244,
    207,
    139,
    254,
    103,
    66
  ],
  "LENOVO_MX25_L64_XFLASH_PART_DXE_GUID": [
    949109979,
    15726,
    20048,
    131,
    93,
    90,
    119,
    90,
    50,
    93,
    137
  ],
  "LENOVO_AOAC_SMM_GUID": [
    975891559,
    30648,
    16558,
    146,
    129,
    3,
    81,
    156,
    158,
    127,
    8
  ],
  "LENOVO_SYSTEM_HII_IMAGE_DISPLAY_DXE_GUID": [
    1007992985,
    12611,
    18159,
    175,
    24,
    222,
    74,
    210,
    195,
    167,
    153
  ],
  "LENOVO_SYSTEM_PS2_KEYBOARD_DXE_GUID": [
    1036526454,
    25467,
    16550,
    168,
    252,
    165,
    101,
    65,
    127,
    44,
    56
  ],
  "LENOVO_REBOOT_CP_GUID": [
    1039934815,
    40070,
    18620,
    151,
    45,
    229,
    34,
    83,
    55,
    104,
    219
  ],
  "LENOVO_SYSTEM_CRYPT_SVC_RT_GUID": [
    1044688137,
    55435,
    19538,
    180,
    27,
    184,
    192,
    5,
    54,
    71,
    74
  ],
  "LENOVO_PLATFORM_PCI_DXE_GUID": [
    1064784879,
    54127,
    17868,
    138,
    26,
    46,
    170,
    255,
    16,
    56,
    182
  ],
  "LENOVO_FIT_DIAGNOSTICS_LOADER_GUID": [
    1065247067,
    3397,
    20352,
    136,
    220,
    38,
    178,
    52,
    149,
    133,
    96
  ],
  "LENOVO_IBEX_PEAK_GLOBAL_SMI_CONTROL_GUID": [
    1069045413,
    51376,
    18272,
    180,
    154,
    46,
    221,
    79,
    163,
    91,
    250
  ],
  "LENOVO_VPRO_IDER_ASF_BOOT_GUID": [
    1075081700,
    40569,
    18020,
    191,
    176,
    23,
    149,
    36,
    35,
    5,
    103
  ],
  "LENOVO_SYSTEM_CON_SPLITTER_DXE_GUID": [
    1083104492,
    53101,
    18300,
    165,
    168,
    180,
    132,
    78,
    61,
    226,
    129
  ],
  "LENOVO_I_FFS_SMM_GUID": [
    1125591121,
    53118,
    17221,
    159,
    224,
    215,
    1,
    43,
    177,
    123,
    136
  ],
  "LENOVO_SYSTEM_PARTITION_DXE_GUID": [
    1136210482,
    44990,
    4564,
    189,
    15,
    0,
    128,
    199,
    60,
    136,
    129
  ],
  "LENOVO_MAIL_BOX_DXE_GUID": [
    1136369323,
    32087,
    19951,
    176,
    162,
    163,
    169,
    249,
    198,
    234,
    227
  ],
  "LENOVO_VARIABLE_INIT_SMM_GUID": [
    1154448672,
    57334,
    16905,
    154,
    31,
    246,
    205,
    95,
    92,
    232,
    139
  ],
  "LENOVO_SYSTEM_AHCI_ATA_ATAPI_PASS_THRU_DXE_GUID": [
    1156724112,
    56456,
    4573,
    173,
    139,
    8,
    0,
    32,
    12,
    154,
    102
  ],
  "LENOVO_COMPUTRACE_LOADER_DXE_GUID": [
    1166658547,
    1017,
    18840,
    157,
    111,
    38,
    52,
    60,
    105,
    86,
    42
  ],
  "LENOVO_SYSTEM_CMOS_SMM_GUID": [
    1188605149,
    10691,
    16403,
    129,
    232,
    55,
    164,
    37,
    171,
    79,
    153
  ],
  "LENOVO_MISC_GA_IO_DXE_GUID": [
    1246898131,
    3055,
    19626,
    172,
    189,
    236,
    132,
    68,
    108,
    92,
    108
  ],
  "LENOVO_AT24_RF08_EEPROM_SMM_GUID": [
    1265312161,
    62059,
    16463,
    134,
    148,
    219,
    28,
    99,
    161,
    217,
    42
  ],
  "LENOVO_SECURITY_SMI_DISPATCH_GUID": [
    1283265896,
    53107,
    18038,
    160,
    121,
    22,
    247,
    249,
    96,
    12,
    204
  ],
  "LENOVO_SYSTEM_PPIS_NEEDED_BY_DXE_CORE_GUID": [
    1295505986,
    14860,
    20186,
    185,
    235,
    188,
    14,
    29,
    180,
    113,
    59
  ],
  "LENOVO_SYSTEM_ERROR_LOG_SMM_GUID": [
    1298314729,
    29128,
    16682,
    134,
    4,
    135,
    140,
    146,
    29,
    154,
    209
  ],
  "LENOVO_VPRO_HII_DXE_GUID": [
    1322172828,
    28255,
    18453,
    131,
    66,
    181,
    95,
    44,
    197,
    223,
    193
  ],
  "LENOVO_COMPUTRACE_ENABLER_DXE_GUID": [
    1325158874,
    9126,
    18320,
    162,
    146,
    73,
    133,
    199,
    245,
    205,
    239
  ],
  "LENOVO_EN25_QH64_FLASH_PART_SMM_GUID": [
    1344002362,
    61865,
    20300,
    169,
    70,
    120,
    103,
    223,
    151,
    85,
    55
  ],
  "LENOVO_PCH_EMULATE_KBC_GUID": [
    1359302880,
    48078,
    20159,
    187,
    160,
    148,
    110,
    61,
    24,
    231,
    5
  ],
  "LENOVO_SYSTEM_SMBIOS_EVENT_LOG_DXE_GUID": [
    1360175786,
    57717,
    18302,
    164,
    228,
    208,
    183,
    230,
    137,
    186,
    159
  ],
  "LENOVO_HPM_SMM_GUID": [
    1364927051,
    45145,
    17931,
    133,
    199,
    194,
    134,
    88,
    244,
    184,
    152
  ],
  "LENOVO_SYSTEM_CRC32_SECTION_EXTRACT_DXE_GUID": [
    1372189708,
    21059,
    17523,
    178,
    101,
    179,
    200,
    255,
    175,
    249,
    250
  ],
  "LENOVO_SYSTEM_CON_PLATFORM_DXE_GUID": [
    1372386201,
    20447,
    20053,
    164,
    91,
    225,
    35,
    248,
    77,
    69,
    106
  ],
  "LENOVO_PLATFORM_S3_SAVE_DXE_GUID": [
    1372895948,
    59146,
    16694,
    148,
    38,
    84,
    105,
    115,
    237,
    147,
    140
  ],
  "LENOVO_TDT_AM_GUID": [
    1376754776,
    40861,
    18630,
    160,
    160,
    217,
    254,
    109,
    143,
    222,
    119
  ],
  "LENOVO_ARP_DXE_BIN_GUID": [
    1386037139,
    59625,
    20083,
    177,
    225,
    189,
    246,
    169,
    213,
    1,
    19
  ],
  "LENOVO_HPM_DXE_GUID": [
    1402833581,
    50860,
    17004,
    182,
    31,
    34,
    142,
    109,
    21,
    1,
    182
  ],
  "LENOVO_SYSTEM_DATA_HUB_DXE_GUID": [
    1404879183,
    49743,
    17228,
    178,
    148,
    142,
    210,
    212,
    204,
    24,
    96
  ],
  "LENOVO_SYSTEM_FLASH_COMMUNICATION_DXE_GUID": [
    1416286869,
    3172,
    19686,
    160,
    111,
    251,
    156,
    208,
    75,
    65,
    205
  ],
  "LENOVO_SYSTEM_FIRMWARE_DEVICE_SMM_GUID": [
    1422077119,
    41913,
    19662,
    156,
    67,
    224,
    89,
    227,
    34,
    85,
    223
  ],
  "LENOVO_DRIVE_ERASE_DXE_GUID": [
    1426260946,
    61491,
    17512,
    133,
    122,
    68,
    44,
    16,
    225,
    153,
    233
  ],
  "LENOVO_SMM_BASE_RUNTIME_GUID": [
    1431459674,
    32256,
    19809,
    163,
    164,
    247,
    84,
    115,
    81,
    180,
    158
  ],
  "LENOVO_DRIVE_ERASE_SMM_GUID": [
    1442418698,
    49072,
    19248,
    131,
    238,
    127,
    67,
    127,
    175,
    174,
    51
  ],
  "LENOVO_PRIOR_BOOT_GUID": [
    1475642899,
    12298,
    16641,
    167,
    109,
    79,
    115,
    197,
    51,
    181,
    184
  ],
  "LENOVO_DISK_CONTROLLER_SMBIOS_GUID": [
    1514093521,
    47014,
    16459,
    160,
    247,
    40,
    94,
    27,
    137,
    139,
    0
  ],
  "LENOVO_DXE_REALTEK_CRC_INIT_GUID": [
    1534379841,
    19039,
    19086,
    182,
    137,
    216,
    4,
    171,
    67,
    104,
    253
  ],
  "LENOVO_PLATFORM_CSM_DXE_GUID": [
    1541268997,
    45319,
    16798,
    149,
    16,
    170,
    60,
    67,
    78,
    187,
    228
  ],
  "LENOVO_SECURE_ERROR_MANAGER_DXE_GUID": [
    1541333558,
    3253,
    19846,
    166,
    8,
    238,
    123,
    12,
    95,
    41,
    86
  ],
  "LENOVO_IP6_DXE_BIN_GUID": [
    1542305228,
    55344,
    20146,
    135,
    66,
    45,
    76,
    201,
    181,
    79,
    44
  ],
  "LENOVO_SETUP_RESTART_DXE_GUID": [
    1567984635,
    45859,
    20332,
    144,
    23,
    163,
    35,
    140,
    230,
    81,
    99
  ],
  "LENOVO_SYSTEM_IMAGE_DECODER_DXE_GUID": [
    1600508442,
    34919,
    17875,
    164,
    26,
    82,
    111,
    159,
    226,
    197,
    152
  ],
  "LENOVO_SETUP_CONFIG_DXE_GUID": [
    1607003872,
    39922,
    18831,
    180,
    211,
    197,
    30,
    212,
    200,
    123,
    180
  ],
  "LENOVO_SMBIOS_COMPATI_INFO_GUID": [
    1616789944,
    59683,
    18380,
    135,
    177,
    166,
    227,
    133,
    38,
    231,
    141
  ],
  "LENOVO_SYSTEM_KBC_INIT_DXE_GUID": [
    1628708000,
    5188,
    19534,
    161,
    109,
    182,
    1,
    224,
    160,
    148,
    102
  ],
  "LENOVO_REMOTE_CONFIG_UPDATE_DXE_GUID": [
    1646126790,
    3934,
    20195,
    161,
    2,
    11,
    222,
    118,
    154,
    10,
    212
  ],
  "LENOVO_CPU_INIT_DXE_GUID": [
    1657893323,
    30925,
    17536,
    134,
    120,
    198,
    162,
    167,
    151,
    168,
    222
  ],
  "LENOVO_CPU_INIT_PHNX_DXE_GUID": [
    1665371246,
    38684,
    20032,
    143,
    11,
    17,
    9,
    69,
    123,
    227,
    51
  ],
  "LENOVO_SYSTEM_VARIABLE_SMM_GUID": [
    1696885307,
    13295,
    20350,
    182,
    87,
    164,
    166,
    51,
    241,
    48,
    176
  ],
  "LENOVO_SETUP_UNDER_OS_SMM_GUID": [
    1705451568,
    45102,
    19443,
    132,
    36,
    186,
    95,
    47,
    197,
    109,
    231
  ],
  "LENOVO_RN_RCONFIG_GUID": [
    1717387104,
    44350,
    19629,
    142,
    38,
    219,
    70,
    238,
    233,
    241,
    181
  ],
  "LENOVO_VARIABLE_DXE_GUID": [
    1726926656,
    25362,
    18970,
    168,
    58,
    179,
    178,
    248,
    216,
    167,
    26
  ],
  "LENOVO_MISC_GA_IO_SMM_GUID": [
    1739578975,
    61206,
    18360,
    186,
    25,
    194,
    27,
    57,
    7,
    219,
    241
  ],
  "LENOVO_W25_Q32_FLASH_PART_DXE_GUID": [
    1757163669,
    34873,
    19095,
    143,
    234,
    190,
    224,
    110,
    202,
    123,
    187
  ],
  "LENOVO_SYSTEM_IDE_BUS_DXE_GUID": [
    1778224711,
    41313,
    17744,
    176,
    26,
    85,
    148,
    206,
    178,
    178,
    178
  ],
  "LENOVO_OEM_MILESTONE_GUID": [
    1784844030,
    13954,
    20444,
    163,
    30,
    198,
    53,
    189,
    241,
    140,
    200
  ],
  "LENOVO_SETUP_SECURITY_DXE_GUID": [
    1786453126,
    22798,
    18343,
    151,
    26,
    196,
    155,
    64,
    141,
    94,
    215
  ],
  "LENOVO_SECURE_KEY_DXE_GUID": [
    1787443551,
    19463,
    18897,
    185,
    76,
    34,
    237,
    80,
    212,
    37,
    248
  ],
  "LENOVO_UDP4_DXE_BIN_GUID": [
    1835623339,
    36973,
    19045,
    167,
    202,
    189,
    64,
    229,
    214,
    175,
    43
  ],
  "LENOVO_N25_Q064_FLASH_PART_SMM_GUID": [
    1848830710,
    13009,
    17376,
    182,
    225,
    220,
    246,
    218,
    129,
    223,
    118
  ],
  "LENOVO_SMBIOS_VPRO_GUID": [
    1850878195,
    37694,
    18785,
    149,
    115,
    15,
    30,
    97,
    181,
    34,
    172
  ],
  "LENOVO_W25_Q64_FLASH_PART_SMM_GUID": [
    1852721781,
    61204,
    18427,
    180,
    58,
    103,
    236,
    67,
    184,
    125,
    34
  ],
  "LENOVO_SYSTEM_ISA_KBC_DXE_GUID": [
    1852769708,
    9035,
    18011,
    148,
    80,
    195,
    110,
    109,
    117,
    102,
    197
  ],
  "LENOVO_PLATFORM_FLASH_SMM_GUID": [
    1886133772,
    17660,
    16402,
    155,
    113,
    61,
    191,
    236,
    118,
    47,
    53
  ],
  "LENOVO_PI_SAVE_STATE_ACCESS_GUID": [
    1887124590,
    39334,
    19991,
    132,
    160,
    64,
    40,
    76,
    27,
    63,
    56
  ],
  "LENOVO_SYSTEM_ACPI_SUPPORT_DXE_GUID": [
    1903824554,
    39704,
    17946,
    182,
    236,
    172,
    9,
    121,
    76,
    166,
    49
  ],
  "LENOVO_SYSTEM_SETUP2_DXE_GUID": [
    1914473318,
    17004,
    20102,
    142,
    153,
    52,
    87,
    196,
    106,
    176,
    185
  ],
  "LENOVO_SYSTEM_IDE_ATA_ATAPI_PASS_THRU_SMM_GUID": [
    1938925920,
    52433,
    4573,
    173,
    139,
    8,
    0,
    32,
    12,
    154,
    102
  ],
  "LENOVO_SYSTEM_BOOT_MANAGER_DXE_GUID": [
    1943712527,
    16284,
    16736,
    176,
    100,
    67,
    156,
    225,
    108,
    62,
    222
  ],
  "LENOVO_BLOCK_POWER_BUTTON_DXE_GUID": [
    1956648660,
    20043,
    17845,
    174,
    151,
    78,
    110,
    51,
    214,
    81,
    37
  ],
  "LENOVO_SYSTEM_ACPI_NUMA_DXE_GUID": [
    1972041895,
    10756,
    18743,
    153,
    224,
    131,
    125,
    31,
    151,
    199,
    111
  ],
  "LENOVO_SYSTEM_ACPI_TABLE_LOADER_DXE_GUID": [
    2002878155,
    57897,
    20000,
    184,
    249,
    223,
    130,
    69,
    98,
    77,
    122
  ],
  "LENOVO_DIGITAL_THERMAL_SENSOR_SMM_GUID": [
    2007367838,
    4462,
    17997,
    142,
    248,
    179,
    82,
    1,
    160,
    34,
    221
  ],
  "LENOVO_SYSTEM_FIXED_BUS_NUMBERS_DXE_GUID": [
    2030029397,
    18537,
    17299,
    190,
    233,
    114,
    229,
    139,
    211,
    190,
    56
  ],
  "LENOVO_SYSTEM_VARIABLE_DXE_GUID": [
    2034024096,
    55894,
    18418,
    130,
    100,
    36,
    49,
    12,
    183,
    81,
    150
  ],
  "LENOVO_SYSTEM_SW_SMI_ALLOCATOR_RT_GUID": [
    2034634970,
    53486,
    18027,
    129,
    179,
    129,
    151,
    33,
    58,
    105,
    120
  ],
  "LENOVO_SYSTEM8259_INTERRUPT_CONTROLLER_DXE_GUID": [
    2043298312,
    48033,
    19098,
    132,
    86,
    225,
    230,
    106,
    129,
    72,
    78
  ],
  "LENOVO_WMA_POLICY_DXE_GUID": [
    2044784087,
    40221,
    20289,
    174,
    26,
    248,
    150,
    22,
    158,
    82,
    22
  ],
  "LENOVO_LAN_UEFI_GUID": [
    2046361940,
    33780,
    18316,
    128,
    191,
    135,
    138,
    195,
    46,
    10,
    44
  ],
  "LENOVO_POP_MANAGER_DXE_GUID": [
    2070879654,
    59983,
    18744,
    167,
    159,
    12,
    88,
    225,
    68,
    42,
    161
  ],
  "LENOVO_SYSTEM_USB_MEMORY_MANAGER_DXE_GUID": [
    2078746034,
    62828,
    16839,
    159,
    3,
    30,
    123,
    86,
    182,
    89,
    113
  ],
  "LENOVO_ATP_SMI_SERVICES_GUID": [
    2091593354,
    47001,
    17728,
    133,
    23,
    88,
    100,
    77,
    3,
    204,
    159
  ],
  "LENOVO_MODULES_SMM_THUNK_SMM_GUID": [
    2121356880,
    4326,
    19323,
    137,
    106,
    77,
    197,
    252,
    116,
    43,
    197
  ],
  "LENOVO_VPRO_PET_ALERT_GUID": [
    2124901688,
    50554,
    16685,
    175,
    29,
    213,
    139,
    238,
    43,
    133,
    177
  ],
  "LENOVO_SMM_RELOC_DXE_GUID": [
    2146267886,
    368,
    18452,
    152,
    120,
    168,
    251,
    24,
    100,
    223,
    175
  ],
  "LENOVO_IGD_CUSTOMIZE_GUID": [
    2167621142,
    34510,
    18882,
    182,
    249,
    24,
    4,
    230,
    28,
    115,
    246
  ],
  "LENOVO_SETUP_DATE_TIME_DXE_GUID": [
    2182649437,
    8384,
    19926,
    129,
    160,
    132,
    92,
    82,
    39,
    7,
    67
  ],
  "LENOVO_TRANSLATE_SERVICE_GUID": [
    2188103510,
    47812,
    17396,
    142,
    161,
    140,
    223,
    10,
    18,
    26,
    189
  ],
  "LENOVO_ME_CONFIG_GUID": [
    2191033376,
    29799,
    17552,
    144,
    89,
    254,
    180,
    72,
    221,
    25,
    99
  ],
  "LENOVO_SYSTEM_OEM_ACTIVATION_DXE_GUID": [
    2233099093,
    52752,
    20327,
    157,
    19,
    145,
    179,
    40,
    26,
    149,
    211
  ],
  "LENOVO_SYSTEM_PCI_ISA_BUS_DXE_GUID": [
    2253066494,
    15710,
    18696,
    136,
    204,
    240,
    141,
    78,
    220,
    0,
    80
  ],
  "LENOVO_LEGACY_BIOS_MISC_SMM_GUID": [
    2263362243,
    54959,
    18340,
    140,
    147,
    12,
    118,
    199,
    179,
    204,
    211
  ],
  "LENOVO_INIT_ME_POLICY_GUID": [
    2279811321,
    37797,
    17269,
    186,
    105,
    147,
    167,
    167,
    122,
    93,
    155
  ],
  "LENOVO_SETUP_AUTOMATION_SMM_GUID": [
    2282586559,
    55944,
    18913,
    149,
    67,
    165,
    130,
    71,
    254,
    173,
    26
  ],
  "LENOVO_N25_Q064_FLASH_PART_DXE_GUID": [
    2288700192,
    30912,
    20360,
    157,
    60,
    186,
    220,
    227,
    126,
    218,
    71
  ],
  "LENOVO_HDP_MANAGER_SMM_GUID": [
    2299999890,
    39618,
    19590,
    158,
    204,
    243,
    119,
    130,
    221,
    235,
    170
  ],
  "LENOVO_SYSTEM_XHCI_RESET_SYSTEM_GUID": [
    2388413418,
    13567,
    20018,
    131,
    88,
    51,
    99,
    218,
    1,
    230,
    40
  ],
  "LENOVO_NATIONAL_LPC_PC87393_GUID": [
    2392276867,
    43978,
    18916,
    169,
    64,
    78,
    173,
    90,
    109,
    138,
    30
  ],
  "LENOVO_SYSTEM_ENGLISH_DXE_GUID": [
    2401693450,
    20351,
    20043,
    152,
    2,
    140,
    34,
    183,
    0,
    255,
    172
  ],
  "LENOVO_ABSOLUTE_COMPUTRACE_INSTALLER_WIN8_GUID": [
    2414800113,
    48381,
    19064,
    146,
    49,
    72,
    1,
    86,
    107,
    53,
    103
  ],
  "LENOVO_WMA_PCI_DXE_GUID": [
    2430603523,
    63364,
    16416,
    145,
    172,
    197,
    30,
    139,
    245,
    83,
    178
  ],
  "LENOVO_DPTF_GUID": [
    2441787952,
    15757,
    19381,
    184,
    73,
    69,
    204,
    79,
    199,
    222,
    124
  ],
  "LENOVO_SYSTEM_ISA_SERIAL_DXE_GUID": [
    2478309379,
    40883,
    4564,
    154,
    58,
    0,
    144,
    39,
    63,
    193,
    77
  ],
  "LENOVO_SYSTEM_PCI_BUS_DXE_GUID": [
    2478309380,
    40883,
    4564,
    154,
    58,
    0,
    144,
    39,
    63,
    193,
    77
  ],
  "LENOVO_DHCP4_DXE_BIN_GUID": [
    2490582808,
    3004,
    18427,
    150,
    165,
    238,
    122,
    90,
    230,
    162,
    173
  ],
  "LENOVO_SYSTEM_XHCI_DXE_GUID": [
    2492998332,
    9939,
    19398,
    149,
    75,
    242,
    197,
    129,
    52,
    45,
    225
  ],
  "LENOVO_DXE_CMOS_INIT_GUID": [
    2512357037,
    41440,
    16707,
    180,
    135,
    0,
    75,
    28,
    46,
    5,
    250
  ],
  "LENOVO_TCG_SERVICES_SMM_GUID": [
    2512409029,
    61731,
    17198,
    147,
    131,
    185,
    207,
    17,
    63,
    8,
    46
  ],
  "LENOVO_DHCP6_DXE_BIN_GUID": [
    2514708125,
    13502,
    18293,
    166,
    81,
    126,
    164,
    27,
    105,
    216,
    158
  ],
  "LENOVO_SYSTEM_ENHANCED_FAT_DXE_GUID": [
    2517989630,
    46775,
    17603,
    175,
    53,
    107,
    199,
    5,
    205,
    43,
    31
  ],
  "LENOVO_SYSTEM_NULL_MEMORY_TEST_DXE_GUID": [
    2528493618,
    57164,
    19310,
    130,
    50,
    67,
    141,
    207,
    68,
    141,
    14
  ],
  "LENOVO_SMM_CF9_TRAP_GUID": [
    2534382554,
    35068,
    18764,
    158,
    161,
    38,
    65,
    150,
    99,
    206,
    17
  ],
  "LENOVO_MTFTP6_DXE_BIN_GUID": [
    2582657945,
    39128,
    18909,
    168,
    211,
    50,
    25,
    208,
    255,
    228,
    30
  ],
  "LENOVO_PLATFORM_RESET_RUNTIME_DXE_GUID": [
    2593820971,
    24403,
    17798,
    136,
    32,
    112,
    68,
    133,
    162,
    157,
    33
  ],
  "LENOVO_SYSTEM_DEVICE_PATH_DXE_GUID": [
    2607288270,
    44395,
    20282,
    182,
    11,
    245,
    152,
    153,
    0,
    52,
    67
  ],
  "LENOVO_SMM_CORE_DISPATCHER_GUID": [
    2630180221,
    64511,
    17180,
    188,
    20,
    51,
    78,
    174,
    166,
    5,
    43
  ],
  "LENOVO_MEBX_GUID": [
    2633859116,
    2465,
    17366,
    130,
    23,
    170,
    73,
    193,
    249,
    13,
    44
  ],
  "LENOVO_EN25_QH128_FLASH_PART_DXE_GUID": [
    2639791502,
    51421,
    19103,
    177,
    118,
    223,
    203,
    146,
    53,
    72,
    21
  ],
  "LENOVO_ISSC_DXE_GUID": [
    2640230712,
    39492,
    17768,
    129,
    146,
    193,
    86,
    59,
    235,
    170,
    1
  ],
  "LENOVO_SYSTEM_TERMINAL_DXE_GUID": [
    2659596550,
    41999,
    18549,
    151,
    127,
    91,
    147,
    255,
    35,
    127,
    198
  ],
  "LENOVO_SYSTEM_CAPSULE_RT_GUID": [
    2661670671,
    41820,
    18625,
    186,
    201,
    246,
    52,
    82,
    180,
    124,
    62
  ],
  "LENOVO_PCH_CONFIG_GUID": [
    2678257669,
    15750,
    17084,
    169,
    195,
    43,
    38,
    165,
    223,
    9,
    249
  ],
  "LENOVO_IP4_DXE_BIN_GUID": [
    2679218675,
    15217,
    17188,
    179,
    154,
    116,
    92,
    187,
    1,
    95,
    255
  ],
  "LENOVO_SYSTEM_USB_MASS_STORAGE_DXE_GUID": [
    2679420071,
    17088,
    19405,
    133,
    64,
    155,
    204,
    103,
    17,
    248,
    62
  ],
  "LENOVO_SYSTEM_ERROR_LOG_DXE_GUID": [
    2711009863,
    36563,
    16776,
    167,
    101,
    250,
    150,
    77,
    215,
    237,
    122
  ],
  "LENOVO_DPC_DXE_BIN_GUID": [
    2719021427,
    8861,
    20301,
    170,
    55,
    152,
    149,
    230,
    201,
    234,
    186
  ],
  "LENOVO_SNP_DXE_BIN_GUID": [
    2733913834,
    41255,
    20216,
    149,
    124,
    128,
    72,
    96,
    111,
    246,
    112
  ],
  "LENOVO_SECURE_UPDATE_DXE_GUID": [
    2761067649,
    1795,
    19159,
    163,
    43,
    117,
    37,
    188,
    63,
    225,
    245
  ],
  "LENOVO_OEM_HOOK_SMM_GUID": [
    2763630598,
    46452,
    17236,
    191,
    199,
    5,
    33,
    125,
    192,
    250,
    244
  ],
  "LENOVO_PLATFORM_SETUP_DXE_GUID": [
    2767360156,
    24106,
    17290,
    145,
    186,
    39,
    43,
    9,
    35,
    4,
    154
  ],
  "LENOVO_MX25_L3206_EFLASH_PART_DXE_GUID": [
    2768044243,
    33306,
    17689,
    133,
    187,
    46,
    25,
    135,
    166,
    244,
    225
  ],
  "LENOVO_SYSTEM_ACPI_TABLES_DXE_GUID": [
    2791868560,
    49136,
    20227,
    155,
    30,
    118,
    174,
    134,
    238,
    197,
    171
  ],
  "LENOVO_SM_BIOS_HOLE_GUID": [
    2795618352,
    63830,
    19102,
    149,
    64,
    208,
    232,
    29,
    46,
    51,
    242
  ],
  "LENOVO_SYSTEM_DIAGNOSTIC_SPLASH_SCREEN_APP_GUID": [
    2816006566,
    27312,
    19179,
    173,
    157,
    22,
    62,
    89,
    167,
    163,
    128
  ],
  "LENOVO_PCI_EXPRESS_GUID": [
    2828978400,
    2977,
    16554,
    160,
    62,
    171,
    221,
    165,
    41,
    92,
    222
  ],
  "LENOVO_SYSTEM_SECURE_BOOT_DXE_GUID": [
    2840226543,
    54939,
    16400,
    186,
    36,
    249,
    30,
    31,
    230,
    42,
    218
  ],
  "LENOVO_PROMPT_SERVICE_GUID": [
    2855807077,
    4784,
    17637,
    167,
    49,
    109,
    239,
    77,
    243,
    76,
    231
  ],
  "LENOVO_SYSTEM_FORM_BROWSER_SIMPLE_TEXT_VIEW_LAYOUT_DXE_GUID": [
    2866782636,
    59683,
    18035,
    177,
    184,
    113,
    74,
    216,
    73,
    247,
    144
  ],
  "LENOVO_SMM_RELOC_PEIM_GUID": [
    2880917328,
    64813,
    16498,
    163,
    33,
    202,
    252,
    114,
    151,
    126,
    250
  ],
  "LENOVO_SYSTEM_FRAMEWORK_HII_DATABASE_DXE_GUID": [
    2889102779,
    45523,
    20216,
    149,
    124,
    128,
    72,
    96,
    111,
    246,
    113
  ],
  "LENOVO_INIT_VPRO_POLICY_GUID": [
    2891520473,
    61751,
    20359,
    134,
    159,
    216,
    99,
    237,
    168,
    142,
    210
  ],
  "LENOVO_VARIABLE_INIT_DXE_GUID": [
    2892033439,
    21054,
    20315,
    148,
    202,
    57,
    97,
    52,
    106,
    0,
    186
  ],
  "LENOVO_VPRO_MEBX_HOTKEY_GUID": [
    2893010282,
    15681,
    20221,
    161,
    185,
    135,
    2,
    147,
    129,
    26,
    40
  ],
  "LENOVO_EN25_QH64_FLASH_PART_DXE_GUID": [
    2896228620,
    1225,
    19534,
    157,
    123,
    183,
    160,
    151,
    245,
    225,
    236
  ],
  "LENOVO_PCH_PCIE_SMM_GUID": [
    2897128058,
    49209,
    17444,
    136,
    218,
    244,
    34,
    18,
    234,
    14,
    85
  ],
  "LENOVO_SYSTEM_MONOTONIC_COUNTER_RT_GUID": [
    2908783218,
    53375,
    18788,
    128,
    30,
    123,
    211,
    183,
    136,
    134,
    82
  ],
  "LENOVO_INCOMPATIBLE_PCI_DEVICE_GUID": [
    2909832542,
    3269,
    19135,
    137,
    121,
    190,
    118,
    42,
    148,
    158,
    163
  ],
  "LENOVO_PCH_RESET_GUID": [
    2941907701,
    24104,
    19971,
    128,
    226,
    71,
    39,
    84,
    90,
    248,
    17
  ],
  "LENOVO_AOAC_DXE_GUID": [
    2996974341,
    37973,
    18588,
    170,
    129,
    33,
    219,
    72,
    196,
    30,
    171
  ],
  "LENOVO_SYSTEM_AHCI_BUS_SMM_GUID": [
    3005214816,
    33635,
    4575,
    131,
    149,
    8,
    0,
    32,
    12,
    154,
    102
  ],
  "LENOVO_SYSTEM_RUNTIME_DXE_GUID": [
    3053582532,
    17335,
    18308,
    149,
    177,
    244,
    34,
    108,
    180,
    12,
    238
  ],
  "LENOVO_MEBX_SETUP_BROWSER_GUID": [
    3056532411,
    14627,
    19641,
    166,
    232,
    219,
    129,
    142,
    130,
    138,
    128
  ],
  "LENOVO_OS_OPT_DEFAULT_DXE_GUID": [
    3057565518,
    53654,
    16570,
    171,
    99,
    31,
    169,
    166,
    6,
    142,
    132
  ],
  "LENOVO_SOUND_SERVICE_GUID": [
    3059315134,
    47807,
    18925,
    157,
    210,
    72,
    236,
    141,
    180,
    171,
    211
  ],
  "LENOVO_I_FFS_DXE_GUID": [
    3065588063,
    51903,
    19692,
    187,
    20,
    254,
    66,
    70,
    242,
    23,
    58
  ],
  "LENOVO_SYSTEM_SMM_COMMUNICATION_SMM_GUID": [
    3075191674,
    60578,
    20345,
    165,
    68,
    144,
    86,
    154,
    190,
    107,
    153
  ],
  "LENOVO_USER_MANAGER_DXE_GUID": [
    3097946053,
    47357,
    16988,
    166,
    126,
    16,
    9,
    223,
    31,
    16,
    181
  ],
  "LENOVO_UEFI_PXE_BC_DXE_BIN_GUID": [
    3109986266,
    9950,
    18642,
    136,
    7,
    31,
    145,
    7,
    172,
    94,
    58
  ],
  "LENOVO_BOARD_INFO_DXE_GUID": [
    3114529140,
    6966,
    19180,
    153,
    226,
    242,
    133,
    94,
    180,
    195,
    222
  ],
  "LENOVO_SYSTEM_FLASH_COMMUNICATION_SMM_GUID": [
    3117071003,
    58821,
    16860,
    134,
    226,
    231,
    206,
    248,
    123,
    129,
    203
  ],
  "LENOVO_SMBIOS_TCG_DXE_GUID": [
    3120117304,
    13813,
    17533,
    185,
    8,
    162,
    184,
    82,
    170,
    11,
    137
  ],
  "LENOVO_CPU_IO_GUID": [
    3135723935,
    15467,
    17335,
    189,
    240,
    156,
    224,
    122,
    169,
    26,
    166
  ],
  "LENOVO_OS_OPT_DEFAULT_SMM_GUID": [
    3136301472,
    45811,
    17902,
    139,
    82,
    212,
    2,
    23,
    123,
    230,
    184
  ],
  "LENOVO_SYSTEM_AHCI_ATA_ATAPI_PASS_THRU_SMM_GUID": [
    3166018704,
    56454,
    4573,
    173,
    139,
    8,
    0,
    32,
    12,
    154,
    102
  ],
  "LENOVO_SYSTEM_ERROR_MENU_DXE_GUID": [
    3177658028,
    45350,
    20458,
    157,
    29,
    23,
    77,
    74,
    137,
    159,
    34
  ],
  "LENOVO_SYSTEM_EHCI_DXE_GUID": [
    3187557134,
    36650,
    19888,
    153,
    145,
    111,
    133,
    101,
    148,
    119,
    126
  ],
  "LENOVO_STATUS_CODE_ME_DEBUG_DXE_GUID": [
    3212038847,
    44172,
    19843,
    163,
    185,
    74,
    15,
    66,
    0,
    116,
    179
  ],
  "LENOVO_SYSTEM_TEXT_CONSOLE_VGA_DXE_GUID": [
    3213488397,
    45573,
    18255,
    150,
    227,
    122,
    123,
    177,
    180,
    164,
    7
  ],
  "LENOVO_MAIL_BOX_SMM_GUID": [
    3220075714,
    24765,
    18043,
    146,
    97,
    183,
    42,
    136,
    30,
    73,
    238
  ],
  "LENOVO_SMM_FDISK_OEM_GUID": [
    3229404412,
    46271,
    18992,
    162,
    95,
    31,
    87,
    192,
    82,
    38,
    41
  ],
  "LENOVO_SYSTEM_STATUS_CODE_PORT80_SMM_GUID": [
    3234851723,
    28385,
    17467,
    188,
    201,
    133,
    78,
    124,
    155,
    65,
    109
  ],
  "LENOVO_PCH_SPI_RUNTIME_GUID": [
    3247752938,
    46732,
    18817,
    182,
    75,
    155,
    210,
    113,
    71,
    75,
    32
  ],
  "LENOVO_SMM_ASL_SMI_GUID": [
    3287170800,
    25574,
    20313,
    164,
    55,
    175,
    166,
    60,
    70,
    200,
    53
  ],
  "LENOVO_VARIABLE_DEFAULT_GUID": [
    3332108939,
    5827,
    17231,
    164,
    164,
    41,
    43,
    219,
    15,
    77,
    18
  ],
  "LENOVO_PCH_S3_SUPPORT_GUID": [
    3354040199,
    51722,
    17332,
    177,
    229,
    37,
    239,
    135,
    57,
    31,
    141
  ],
  "LENOVO_SVP_MANAGER_DXE_GUID": [
    3356403955,
    41929,
    16933,
    170,
    96,
    118,
    157,
    212,
    199,
    78,
    67
  ],
  "LENOVO_SYSTEM_DIAGNOSTIC_SUMMARY_SCREEN_DXE_GUID": [
    3358136790,
    13309,
    17389,
    128,
    12,
    99,
    90,
    51,
    105,
    208,
    243
  ],
  "LENOVO_SYSTEM_ACCELERATOR_KEY_DXE_GUID": [
    3365425629,
    24224,
    17102,
    137,
    52,
    235,
    142,
    166,
    8,
    251,
    169
  ],
  "LENOVO_SYSTEM_FLASH_UPDATE_DRIVER_DXE_GUID": [
    3366653774,
    9982,
    16625,
    149,
    121,
    234,
    141,
    48,
    213,
    3,
    164
  ],
  "LENOVO_SMAPI_SMM_GUID": [
    3380087232,
    24464,
    17510,
    139,
    56,
    52,
    29,
    122,
    103,
    207,
    84
  ],
  "LENOVO_SYSTEM_DISK_IO_DXE_GUID": [
    3391494694,
    30488,
    19355,
    138,
    7,
    81,
    120,
    177,
    174,
    58,
    2
  ],
  "LENOVO_SYSTEM_DATA_HUB_STD_ERR_DXE_GUID": [
    3394327302,
    206,
    16434,
    135,
    78,
    17,
    183,
    85,
    255,
    104,
    102
  ],
  "LENOVO_SYSTEM_KEY_DESC_DXE_GUID": [
    3397046003,
    4481,
    19168,
    149,
    167,
    15,
    31,
    216,
    175,
    210,
    237
  ],
  "LENOVO_HDP_MANAGER_DXE_GUID": [
    3398903232,
    4837,
    20396,
    173,
    88,
    217,
    170,
    176,
    59,
    143,
    17
  ],
  "LENOVO_PLATFORM_SMM_GUID": [
    3413361625,
    12033,
    17218,
    174,
    103,
    4,
    221,
    229,
    38,
    64,
    146
  ],
  "LENOVO_EN25_QH32_FLASH_PART_SMM_GUID": [
    3419028872,
    51998,
    18883,
    180,
    72,
    95,
    242,
    135,
    197,
    141,
    64
  ],
  "LENOVO_VIDEO_INIT_DXE_GUID": [
    3430002758,
    52999,
    19886,
    174,
    173,
    112,
    70,
    132,
    91,
    205,
    138
  ],
  "LENOVO_SYSTEM_FONT_DXE_GUID": [
    3431257893,
    55838,
    18087,
    158,
    117,
    75,
    172,
    241,
    253,
    57,
    2
  ],
  "LENOVO_SYSTEM_SETUP_ADVANCED_DXE_GUID": [
    3433812521,
    20932,
    19943,
    174,
    47,
    58,
    175,
    113,
    249,
    236,
    229
  ],
  "LENOVO_SYSTEM_GRAPHICS_CONSOLE_DXE_GUID": [
    3435858984,
    19236,
    4565,
    154,
    90,
    0,
    144,
    39,
    63,
    193,
    77
  ],
  "LENOVO_SYSTEM_SM_BIOS_SMM_GUID": [
    3448945081,
    11596,
    18027,
    132,
    88,
    149,
    68,
    125,
    142,
    74,
    254
  ],
  "LENOVO_SYSTEM_BUS_ISA_RTC_SMM_GUID": [
    3451918622,
    6289,
    16665,
    129,
    126,
    11,
    106,
    54,
    133,
    165,
    17
  ],
  "LENOVO_SYSTEM_ACPI_SMI_SERVICES_DXE2_GUID": [
    3482740983,
    45296,
    19839,
    180,
    30,
    174,
    199,
    148,
    238,
    199,
    252
  ],
  "LENOVO_PLATFORM_HII_ADVANCED_DXE_GUID": [
    3488584900,
    16743,
    18026,
    136,
    147,
    135,
    121,
    69,
    157,
    250,
    134
  ],
  "LENOVO_VARIABLE_SMM_GUID": [
    3575212162,
    43376,
    17680,
    143,
    185,
    215,
    88,
    59,
    105,
    6,
    231
  ],
  "LENOVO_SYSTEM_FORM_BROWSER_SIMPLE_TEXT_VIEW_DXE_GUID": [
    3599230073,
    56119,
    19406,
    134,
    74,
    2,
    238,
    246,
    129,
    157,
    241
  ],
  "LENOVO_N25_Q032_FLASH_PART_SMM_GUID": [
    3599366343,
    50004,
    16917,
    170,
    72,
    182,
    173,
    102,
    199,
    126,
    175
  ],
  "LENOVO_MFG_BENCH_EVENT_DXE_GUID": [
    3627644895,
    13507,
    18977,
    161,
    4,
    54,
    155,
    141,
    79,
    167,
    183
  ],
  "LENOVO_UDP6_DXE_BIN_GUID": [
    3641886652,
    61592,
    17255,
    146,
    186,
    233,
    17,
    8,
    60,
    123,
    14
  ],
  "LENOVO_SYSTEM_STATUS_CODE_GENERIC_SMM_GUID": [
    3663567235,
    828,
    18467,
    147,
    73,
    139,
    27,
    106,
    121,
    128,
    48
  ],
  "LENOVO_MX25_L64_XFLASH_PART_SMM_GUID": [
    3679301914,
    3676,
    16565,
    142,
    70,
    23,
    208,
    68,
    134,
    162,
    27
  ],
  "LENOVO_MTFTP4_DXE_BIN_GUID": [
    3694543288,
    12200,
    20179,
    188,
    31,
    249,
    150,
    42,
    3,
    69,
    75
  ],
  "LENOVO_I_FFS_DXE_POLICY_INIT_GUID": [
    3719565990,
    58355,
    20126,
    144,
    163,
    42,
    153,
    18,
    112,
    33,
    156
  ],
  "LENOVO_WMA_USB_DXE_GUID": [
    3769480574,
    57782,
    17644,
    191,
    46,
    132,
    40,
    116,
    162,
    108,
    131
  ],
  "LENOVO_SYSTEM_SCSI_OPROM_PASS_THRU_DXE_GUID": [
    3786228562,
    9744,
    19926,
    187,
    143,
    139,
    178,
    176,
    51,
    131,
    163
  ],
  "LENOVO_PASSWORD_CP_GUID": [
    3841094362,
    9087,
    17740,
    136,
    104,
    252,
    240,
    150,
    207,
    28,
    108
  ],
  "LENOVO_SYSTEM_DIAGNOSTIC_SPLASH_SCREEN_DXE_GUID": [
    3855662044,
    7100,
    18871,
    168,
    182,
    103,
    170,
    240,
    161,
    205,
    158
  ],
  "LENOVO_IBEX_PEAK_FLASH_CONTROLLER_SMM_GUID": [
    3897225109,
    31910,
    19247,
    163,
    152,
    177,
    77,
    28,
    103,
    160,
    177
  ],
  "LENOVO_SMM_SLEEP_EVENT_GUID": [
    3906732218,
    16671,
    19794,
    185,
    37,
    80,
    120,
    84,
    54,
    172,
    129
  ],
  "LENOVO_AT24_RF08_EEPROM_DXE_GUID": [
    3914184057,
    1563,
    17275,
    131,
    194,
    101,
    192,
    174,
    124,
    20,
    226
  ],
  "LENOVO_KBD_CONFIG_GUID": [
    3920933158,
    19987,
    16885,
    158,
    76,
    155,
    248,
    139,
    60,
    27,
    12
  ],
  "LENOVO_SYSTEM_LEGACY_BIOS_DXE_GUID": [
    3928933378,
    12245,
    18271,
    146,
    44,
    152,
    234,
    224,
    55,
    99,
    18
  ],
  "LENOVO_VPRO_CIRA_HOT_KEY_GUID": [
    3936260833,
    8943,
    19295,
    165,
    238,
    19,
    23,
    177,
    231,
    123,
    16
  ],
  "LENOVO_OEM_HOOK_GUID": [
    3937366281,
    60461,
    18992,
    191,
    79,
    98,
    20,
    8,
    99,
    14,
    76
  ],
  "LENOVO_SYSTEM_SMBIOS_DXE_GUID": [
    3941964814,
    48454,
    16698,
    154,
    233,
    221,
    159,
    109,
    26,
    146,
    125
  ],
  "LENOVO_SECURE_KEY_SMM_GUID": [
    3949915124,
    7875,
    19817,
    157,
    130,
    101,
    191,
    108,
    87,
    155,
    52
  ],
  "LENOVO_ME_CON_OUT_READY_GUID": [
    3965343067,
    25476,
    19456,
    134,
    37,
    44,
    23,
    104,
    185,
    91,
    56
  ],
  "LENOVO_FINGERPRINT_CP_GUID": [
    3996187942,
    5412,
    19618,
    181,
    109,
    52,
    88,
    48,
    220,
    156,
    219
  ],
  "LENOVO_SYSTEM_SMM_USB_LEGACY_SMM_GUID": [
    4013146774,
    63052,
    16710,
    173,
    4,
    52,
    120,
    153,
    112,
    44,
    132
  ],
  "LENOVO_SYSTEM_WATCHDOG_TIMER_DXE_GUID": [
    4036613759,
    29102,
    19510,
    178,
    163,
    220,
    235,
    14,
    178,
    183,
    216
  ],
  "LENOVO_N25_Q032_FLASH_PART_DXE_GUID": [
    4055748295,
    12753,
    20239,
    175,
    98,
    208,
    42,
    68,
    7,
    96,
    38
  ],
  "LENOVO_SYSTEM_SECURITY_STUB_DXE_GUID": [
    4059018531,
    15705,
    18568,
    187,
    113,
    234,
    165,
    169,
    102,
    40,
    250
  ],
  "LENOVO_SVP_MANAGER_SMM_GUID": [
    4100820646,
    19047,
    18546,
    176,
    209,
    212,
    253,
    234,
    11,
    105,
    47
  ],
  "LENOVO_STARTUP_MENU_DXE_GUID": [
    4100908788,
    18309,
    17315,
    146,
    61,
    127,
    120,
    108,
    60,
    132,
    121
  ],
  "LENOVO_PLATFORM_S3_SAVE_SMM_GUID": [
    4121718871,
    22096,
    18030,
    182,
    146,
    118,
    164,
    114,
    35,
    239,
    176
  ],
  "LENOVO_SYSTEM_CMOS_DXE_GUID": [
    4131563991,
    9911,
    18379,
    172,
    200,
    19,
    89,
    81,
    172,
    147,
    248
  ],
  "LENOVO_FINGERPRINT_SMM_GUID": [
    4148614015,
    63174,
    17344,
    148,
    219,
    70,
    111,
    95,
    16,
    224,
    48
  ],
  "LENOVO_POWER_MANAGEMENT2_GUID": [
    4151515980,
    22690,
    19956,
    137,
    128,
    86,
    69,
    211,
    158,
    206,
    88
  ],
  "LENOVO_W25_Q32_FLASH_PART_SMM_GUID": [
    4174016692,
    27269,
    17942,
    139,
    222,
    62,
    197,
    105,
    100,
    74,
    195
  ],
  "LENOVO_SYSTEM_USB_DATABASE_DXE_GUID": [
    4182180003,
    62623,
    19666,
    191,
    37,
    25,
    226,
    128,
    183,
    46,
    59
  ],
  "LENOVO_TCG_SMM_GUID": [
    4182377611,
    32708,
    19132,
    133,
    166,
    134,
    22,
    166,
    211,
    205,
    206
  ],
  "LENOVO_SLP2_SMM_GUID": [
    4199507776,
    47450,
    17401,
    144,
    181,
    120,
    216,
    20,
    124,
    2,
    25
  ],
  "LENOVO_FIT_DIAGNOSTICS_GUID": [
    4222873731,
    22407,
    17839,
    186,
    220,
    102,
    72,
    84,
    16,
    15,
    32
  ],
  "LENOVO_SYSTEM_SECURE_FLASH_SLEEP_TRAP_SMM_GUID": [
    4242832462,
    24268,
    19009,
    185,
    14,
    11,
    171,
    9,
    150,
    141,
    2
  ],
  "LENOVO_TXT_DXE_GUID": [
    4287725090,
    41512,
    17549,
    189,
    170,
    104,
    239,
    204,
    221,
    165,
    211
  ],
  "LENOVO_EAIA_PEI_GUID": [
    512609513,
    13340,
    16921,
    167,
    144,
    241,
    76,
    40,
    181,
    28,
    238
  ],
  "LENOVO_PLATFORM_STAGE2_PEI_GUID": [
    591261847,
    12824,
    18354,
    158,
    9,
    254,
    88,
    194,
    178,
    13,
    34
  ],
  "LENOVO_MISC_GA_IO_PEIM_GUID": [
    913773309,
    27738,
    17920,
    190,
    162,
    154,
    31,
    129,
    170,
    204,
    8
  ],
  "LENOVO_PEI_MAIN_GUID": [
    1388337940,
    2968,
    18796,
    188,
    59,
    4,
    181,
    2,
    17,
    214,
    128
  ],
  "LENOVO_PLATFORM_STAGE1_PEI_GUID": [
    1402489962,
    6986,
    16756,
    149,
    18,
    166,
    94,
    91,
    200,
    178,
    120
  ],
  "LENOVO_FLASH_PROTECT_PEI_GUID": [
    1403787592,
    3792,
    17034,
    180,
    221,
    210,
    255,
    242,
    245,
    119,
    111
  ],
  "LENOVO_SYSTEM_ACPI_TABLES_PEI_GUID": [
    1436701486,
    10618,
    19197,
    144,
    191,
    19,
    155,
    255,
    91,
    180,
    215
  ],
  "LENOVO_OEM_SEC_PEI_GUID": [
    1495331846,
    22632,
    17653,
    169,
    185,
    109,
    64,
    49,
    72,
    28,
    201
  ],
  "LENOVO_SYSTEM_USB_BOT_PEI_GUID": [
    2214699078,
    28528,
    17669,
    132,
    113,
    112,
    21,
    180,
    3,
    85,
    227
  ],
  "LENOVO_SYSTEM_BOOT_MODE_PEI_GUID": [
    2251331032,
    15348,
    17532,
    174,
    16,
    21,
    179,
    174,
    153,
    54,
    253
  ],
  "LENOVO_PEI_CPU_IO_GUID": [
    2323165447,
    4061,
    19656,
    183,
    186,
    220,
    62,
    19,
    203,
    133,
    36
  ],
  "LENOVO_SYSTEM_S3_RESUME_PEI_GUID": [
    2345590231,
    57989,
    16744,
    155,
    63,
    9,
    175,
    102,
    201,
    63,
    254
  ],
  "LENOVO_VIDEO_INIT_PEIM_GUID": [
    2630869420,
    30796,
    17981,
    177,
    69,
    57,
    109,
    112,
    20,
    213,
    89
  ],
  "LENOVO_AT24_RF08_EEPROM_PEI_GUID": [
    2648253477,
    26423,
    17869,
    130,
    156,
    26,
    194,
    205,
    32,
    200,
    115
  ],
  "LENOVO_POST_VALIDATOR_PEI_GUID": [
    3116595505,
    61545,
    16780,
    158,
    25,
    49,
    176,
    188,
    3,
    24,
    135
  ],
  "LENOVO_SYSTEM_FV_FILE_LOADER_GUID": [
    3257022987,
    32979,
    19509,
    137,
    31,
    189,
    12,
    196,
    233,
    144,
    240
  ],
  "LENOVO_MAIL_BOX_PEI_GUID": [
    3272721920,
    34025,
    20254,
    191,
    68,
    191,
    54,
    227,
    65,
    81,
    88
  ],
  "LENOVO_EC_IO_PEIM_GUID": [
    3279067084,
    16345,
    16422,
    152,
    144,
    122,
    22,
    40,
    24,
    70,
    32
  ],
  "LENOVO_MODULE_S3_RESUME_PEIM_GUID": [
    3350021305,
    42869,
    18433,
    183,
    114,
    169,
    100,
    38,
    43,
    185,
    46
  ],
  "LENOVO_CPU_S3_PEIM_GUID": [
    3362176369,
    31865,
    19441,
    169,
    59,
    6,
    107,
    131,
    13,
    143,
    154
  ],
  "LENOVO_USER_MANAGER_PEI_GUID": [
    3759193290,
    14907,
    19203,
    188,
    244,
    174,
    31,
    100,
    168,
    92,
    137
  ],
  "LENOVO_PROTECT_PBPEI_GUID": [
    3930240486,
    24065,
    19566,
    129,
    137,
    193,
    239,
    166,
    172,
    253,
    1
  ],
  "LENOVO_ISSC_PEI_GUID": [
    3972789634,
    61153,
    17848,
    137,
    38,
    6,
    127,
    64,
    179,
    229,
    94
  ],
  "LENOVO_PLATFORM_STAGE0_PEI_GUID": [
    3981613134,
    28375,
    17477,
    157,
    93,
    32,
    12,
    50,
    1,
    245,
    30
  ],
  "APP_PKG_TOKEN_SPACE_GUID": [
    3890343846,
    30215,
    19064,
    167,
    221,
    67,
    228,
    189,
    114,
    192,
    153
  ],
  "ARM_JUNO_TOKEN_SPACE_GUID": [
    2702473760,
    12612,
    20365,
    130,
    149,
    180,
    131,
    17,
    200,
    228,
    164
  ],
  "VARIABLE_RUNTIME_DXE_FILE_GUID": [
    3419595989,
    28776,
    20469,
    180,
    98,
    152,
    34,
    180,
    173,
    141,
    96
  ],
  "ARM_BOOT_MON_FS_FILE_INFO_GUID": [
    1105357724,
    44454,
    17843,
    128,
    142,
    35,
    87,
    163,
    91,
    96,
    214
  ],
  "ARM_PLATFORM_UPDATE_FDT_EVENT_GUID": [
    2952663387,
    34185,
    17773,
    186,
    181,
    143,
    46,
    218,
    83,
    174,
    183
  ],
  "ARM_REAL_VIEW_EB_PKG_TOKEN_SPACE_GUID": [
    1146583565,
    13850,
    17842,
    179,
    61,
    187,
    158,
    230,
    13,
    90,
    79
  ],
  "ARM_VIRTUALIZATION_TOKEN_SPACE_GUID": [
    191847591,
    20307,
    17498,
    183,
    110,
    46,
    54,
    91,
    128,
    99,
    102
  ],
  "BEAGLE_BOARD_TOKEN_SPACE_GUID": [
    1748303429,
    19182,
    20422,
    188,
    181,
    255,
    69,
    183,
    168,
    113,
    226
  ],
  "EFI_ACPI_DESCRIPTION_GUID": [
    1013551511,
    2364,
    19561,
    176,
    107,
    18,
    138,
    227,
    72,
    29,
    201
  ],
  "EFI_FLASH_MAP_HOB_GUID": [
    2962352082,
    1440,
    16792,
    148,
    240,
    116,
    183,
    184,
    197,
    84,
    89
  ],
  "DUET_CONSOLE_OUT_CONFIG_GUID": [
    3977578260,
    57136,
    16509,
    178,
    74,
    75,
    116,
    47,
    213,
    206,
    162
  ],
  "EFI_SMM_BASE_THUNK_COMMUNICATION_GUID": [
    1701356502,
    351,
    19274,
    156,
    137,
    29,
    20,
    99,
    20,
    19,
    10
  ],
  "EFI_BOOT_STATE_GUID": [
    1622534457,
    4047,
    16935,
    186,
    131,
    107,
    190,
    212,
    91,
    192,
    227
  ],
  "EFI_EDK_COMPATIBILITY_PKG_TOKEN_SPACE_GUID": [
    592761632,
    16051,
    19585,
    153,
    244,
    204,
    74,
    225,
    67,
    70,
    62
  ],
  "FRAMEWORK_BDS_FRONT_PAGE_FORMSET_GUID": [
    2651599036,
    16134,
    19366,
    130,
    136,
    9,
    23,
    155,
    133,
    93,
    190
  ],
  "EFI_EBL_ADD_COMMAND_PROTOCOL_GUID": [
    2933531688,
    39458,
    17975,
    155,
    33,
    84,
    94,
    40,
    251,
    184,
    41
  ],
  "EFI_INTEL_FRAMEWORK_MODULE_PKG_TOKEN_SPACE_GUID": [
    3547353105,
    48153,
    19191,
    190,
    22,
    246,
    128,
    48,
    55,
    140,
    21
  ],
  "BLOCK_IO_VENDOR_GUID": [
    3476159173,
    49742,
    4562,
    133,
    243,
    0,
    160,
    201,
    62,
    201,
    59
  ],
  "BOOT_MANAGER_FORM_SET_GUID": [
    2222703614,
    47476,
    17517,
    148,
    73,
    90,
    213,
    65,
    46,
    153,
    59
  ],
  "DEVICE_MANAGER_FORM_SET_GUID": [
    1052748006,
    20765,
    19291,
    169,
    95,
    251,
    56,
    38,
    15,
    28,
    39
  ],
  "DRIVER_HEALTH_FORM_SET_GUID": [
    4151183984,
    46573,
    19512,
    172,
    154,
    229,
    245,
    75,
    241,
    110,
    52
  ],
  "BOOT_MAINT_FORM_SET_GUID": [
    1679964103,
    13780,
    18221,
    131,
    101,
    18,
    224,
    204,
    242,
    122,
    34
  ],
  "FILE_EXPLORE_FORM_SET_GUID": [
    523068385,
    65213,
    19911,
    156,
    197,
    186,
    43,
    28,
    239,
    156,
    91
  ],
  "EXIT_PM_AUTH_PROTOCOL_GUID": [
    3498615827,
    2672,
    16919,
    186,
    85,
    154,
    60,
    182,
    92,
    65,
    179
  ],
  "EFI_CACHE_SUB_CLASS_GUID": [
    2130711463,
    56441,
    19234,
    128,
    153,
    17,
    247,
    95,
    220,
    130,
    157
  ],
  "EFI_MEMORY_SUB_CLASS_GUID": [
    1318014651,
    25785,
    19973,
    155,
    24,
    76,
    254,
    73,
    35,
    80,
    151
  ],
  "EFI_MISC_SUB_CLASS_GUID": [
    1998881970,
    29826,
    19345,
    159,
    154,
    173,
    67,
    248,
    28,
    88,
    129
  ],
  "EFI_PROCESSOR_SUB_CLASS_GUID": [
    654175102,
    47279,
    19663,
    170,
    151,
    2,
    99,
    60,
    228,
    140,
    167
  ],
  "EFI_SMM_PEI_SMRAM_MEMORY_RESERVE_GUID": [
    1840116177,
    54476,
    18704,
    187,
    110,
    130,
    177,
    253,
    128,
    255,
    61
  ],
  "EFI_PEI144_FLOPPY_BLOCK_IO_PPI_GUID": [
    3664270781,
    1975,
    19461,
    158,
    216,
    226,
    89,
    253,
    54,
    14,
    34
  ],
  "EFI_PCI_CFG_PPI_IN_SERVICE_TABLE_GUID": [
    3790793632,
    63417,
    18982,
    134,
    32,
    19,
    18,
    33,
    100,
    42,
    144
  ],
  "EFI_PEI_FV_FILE_LOADER_PPI_GUID": [
    2115964293,
    1279,
    19378,
    134,
    106,
    49,
    162,
    153,
    106,
    72,
    168
  ],
  "EFI_ACPI_S3_SAVE_PROTOCOL_GUID": [
    308227553,
    64389,
    17420,
    165,
    76,
    77,
    153,
    53,
    138,
    141,
    56
  ],
  "EFI_ACPI_SUPPORT_PROTOCOL_GUID": [
    3690962261,
    35255,
    18138,
    189,
    223,
    103,
    125,
    61,
    192,
    36,
    29
  ],
  "FRAMERWORK_EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL_GUID": [
    3727211609,
    25128,
    16829,
    189,
    246,
    163,
    185,
    173,
    181,
    141,
    161
  ],
  "INTEL_FSP_PKG_TOKEN_SPACE_GUID": [
    2202799199,
    44467,
    17266,
    174,
    235,
    3,
    228,
    233,
    230,
    197,
    145
  ],
  "FSP_BOOT_LOADER_TEMPORARY_MEMORY_GUID": [
    3150967916,
    51411,
    16659,
    137,
    133,
    185,
    212,
    243,
    179,
    246,
    78
  ],
  "FSP_RESERVED_MEMORY_RESOURCE_HOB_TSEG_GUID": [
    3493360764,
    53260,
    18816,
    179,
    25,
    73,
    1,
    153,
    164,
    125,
    85
  ],
  "FSP_RESERVED_MEMORY_RESOURCE_HOB_GFX_GUID": [
    2625387175,
    21298,
    18711,
    130,
    185,
    86,
    165,
    243,
    230,
    42,
    7
  ],
  "FSP_RESERVED_MEMORY_RESOURCE_HOB_MISC_GUID": [
    14070091,
    32208,
    16482,
    136,
    33,
    229,
    249,
    106,
    42,
    27,
    0
  ],
  "FSP_WRAPPER_TOKEN_SPACE_GUID": [
    734119754,
    4655,
    16562,
    178,
    35,
    8,
    43,
    116,
    101,
    34,
    93
  ],
  "FSP_INIT_DONE_PPI_GUID": [
    4126082532,
    54584,
    18292,
    143,
    27,
    233,
    119,
    48,
    17,
    224,
    56
  ],
  "EFI_EXTENDED_SAL_BOOT_SERVICE_PROTOCOL_GUID": [
    3725519268,
    15482,
    17650,
    183,
    139,
    227,
    204,
    214,
    156,
    58,
    247
  ],
  "EFI_NT32_PKG_TOKEN_SPACE_GUID": [
    226076229,
    7569,
    16550,
    168,
    31,
    97,
    230,
    152,
    43,
    50,
    180
  ],
  "PEI_NT_AUTO_SCAN_PPI_GUID": [
    231618637,
    124,
    19365,
    148,
    189,
    15,
    110,
    182,
    77,
    42,
    169
  ],
  "NT_PEI_LOAD_FILE_PPI_GUID": [
    4245448171,
    1029,
    19666,
    138,
    238,
    244,
    0,
    239,
    19,
    186,
    194
  ],
  "WIN_NT_BUS_DRIVER_GUID": [
    68810114,
    1573,
    17713,
    138,
    51,
    133,
    169,
    150,
    92,
    149,
    188
  ],
  "OMAP35XX_TOKEN_SPACE_GUID": [
    615553726,
    20039,
    18460,
    169,
    173,
    206,
    241,
    44,
    57,
    35,
    39
  ],
  "OPTION_ROM_PKG_TOKEN_SPACE_GUID": [
    507718031,
    13432,
    16807,
    181,
    119,
    134,
    6,
    70,
    53,
    199,
    40
  ],
  "PERFORMANCE_PKG_TOKEN_SPACE_GUID": [
    1720927983,
    64941,
    19179,
    8,
    166,
    33,
    70,
    45,
    63,
    239,
    125
  ],
  "PEI_CAPSULE_ON_DATA_CD_GUID": [
    1554776217,
    3529,
    18661,
    128,
    104,
    187,
    149,
    245,
    64,
    10,
    159
  ],
  "PEI_CAPSULE_ON_FAT_FLOPPY_DISK_GUID": [
    775761525,
    39726,
    16685,
    180,
    177,
    112,
    65,
    107,
    135,
    0,
    255
  ],
  "PEI_CAPSULE_ON_FAT_IDE_DISK_GUID": [
    3011867574,
    25088,
    19141,
    181,
    29,
    130,
    230,
    89,
    56,
    215,
    131
  ],
  "PEI_CAPSULE_ON_FAT_USB_DISK_GUID": [
    268160537,
    12876,
    18064,
    160,
    9,
    152,
    198,
    174,
    46,
    177,
    134
  ],
  "DXE_DEBUGPORT_EXT_PROTOCOL_GUID": [
    832866191,
    8973,
    20418,
    144,
    187,
    218,
    95,
    65,
    164,
    75,
    27
  ],
  "DXE_DEBUG_CMD_PROTOCOL_GUID": [
    3392879184,
    22168,
    17745,
    139,
    24,
    206,
    174,
    239,
    145,
    125,
    80
  ],
  "DXE_DEBUG_DISPATCH_PROTOCOL_GUID": [
    807072841,
    57559,
    17315,
    139,
    27,
    188,
    22,
    114,
    93,
    55,
    75
  ],
  "PDM_WINDOW_BUTTON_GUID": [
    1600511963,
    44064,
    20291,
    155,
    33,
    38,
    158,
    129,
    160,
    234,
    126
  ],
  "PDM_WINDOW_SPIN_GUID": [
    1622310426,
    54878,
    19888,
    178,
    187,
    193,
    111,
    167,
    30,
    68,
    171
  ],
  "PEI_DEBUG_DISPATCH_PPI_GUID": [
    3379788064,
    49837,
    16835,
    177,
    51,
    15,
    156,
    37,
    27,
    103,
    67
  ],
  "PEI_POST_BOOT_SCRIPT_TABLE_PPI_GUID": [
    2294928134,
    2304,
    20149,
    130,
    96,
    62,
    45,
    190,
    218,
    31,
    137
  ],
  "PHOENIX_DESKTOP_MESSAGE_PROTOCOL_GUID": [
    2279421241,
    1639,
    19383,
    159,
    178,
    71,
    211,
    197,
    11,
    2,
    27
  ],
  "PHOENIX_DESKTOP_WINDOW_PROTOCOL_GUID": [
    1878968205,
    32191,
    20363,
    150,
    141,
    47,
    67,
    160,
    128,
    193,
    63
  ],
  "PHOENIX_GDI_PROTOCOL_GUID": [
    1062892722,
    49024,
    18512,
    133,
    145,
    79,
    45,
    245,
    249,
    203,
    43
  ],
  "PHOENIX_SMM_CORE_SERVICES_PROTOCOL_GUID": [
    394159041,
    44758,
    19848,
    145,
    126,
    155,
    79,
    185,
    254,
    64,
    146
  ],
  "PHOENIX_EFI_SMM_SW_SMI_PROTOCOL_GUID": [
    4278527235,
    6905,
    19179,
    131,
    196,
    194,
    212,
    206,
    177,
    12,
    163
  ],
  "PHOENIX_SMM_WATCHDOG_TIMER_PROTOCOL_GUID": [
    1876835064,
    14253,
    17404,
    183,
    40,
    244,
    211,
    65,
    243,
    146,
    64
  ],
  "SCT_ISA_HC_PROTOCOL_GUID": [
    1605137248,
    54514,
    19614,
    167,
    237,
    242,
    89,
    94,
    103,
    8,
    137
  ],
  "PEI_SPEAKER_INTERFACE_PPI_GUID": [
    816588638,
    47920,
    19332,
    161,
    205,
    10,
    241,
    50,
    44,
    137,
    192
  ],
  "PEI_MFG_MEMORY_TEST_PPI_GUID": [
    2871610002,
    60149,
    19699,
    171,
    43,
    45,
    75,
    237,
    77,
    182,
    61
  ],
  "PEI_SHA256_HASH_PPI_GUID": [
    2500729115,
    34084,
    20305,
    128,
    161,
    92,
    79,
    27,
    3,
    243,
    92
  ],
  "EFI_PLATFORM_BOOT_MODE_GUID": [
    3464779524,
    5763,
    19768,
    164,
    249,
    125,
    11,
    80,
    119,
    87,
    147
  ],
  "EFI_PLATFORM_INFO_GUID": [
    506121281,
    57962,
    18493,
    175,
    199,
    160,
    86,
    195,
    78,
    8,
    123
  ],
  "PLATFORM_MODULE_TOKEN_SPACE_GUID": [
    1775320048,
    44945,
    19862,
    170,
    159,
    33,
    132,
    197,
    206,
    59,
    192
  ],
  "EFI_SERIAL_PORT_TOKEN_SPACE_GUID": [
    2888256351,
    19833,
    18641,
    150,
    223,
    254,
    227,
    84,
    207,
    112,
    131
  ],
  "EFI_ICH_TOKEN_SPACE_GUID": [
    2305297068,
    17707,
    19268,
    174,
    247,
    128,
    11,
    107,
    250,
    241,
    149
  ],
  "EFI_PCH_TOKEN_SPACE_GUID": [
    2309075576,
    41377,
    19959,
    177,
    55,
    222,
    90,
    215,
    196,
    121,
    19
  ],
  "EFI_SIO_VARIABLE_GUID": [
    1443624330,
    7693,
    19838,
    149,
    63,
    41,
    128,
    162,
    97,
    224,
    49
  ],
  "EFI_PLATFORM_CPU_INFO_GUID": [
    3147594423,
    47321,
    19443,
    156,
    41,
    155,
    243,
    65,
    226,
    23,
    188
  ],
  "EFI_BIOS_ID_GUID": [
    3286461705,
    33428,
    19351,
    168,
    87,
    213,
    40,
    143,
    227,
    62,
    40
  ],
  "EFI_BOARD_FEATURES_GUID": [
    2495211694,
    34935,
    18330,
    152,
    66,
    245,
    151,
    75,
    130,
    206,
    211
  ],
  "ITK_DATA_VAR_GUID": [
    940732989,
    32328,
    20009,
    188,
    39,
    245,
    163,
    154,
    201,
    78,
    241
  ],
  "DMI_DATA_GUID": [
    1894083678,
    10252,
    17584,
    164,
    151,
    9,
    104,
    26,
    188,
    55,
    94
  ],
  "IDCC_DATA_HUB_GUID": [
    2022579615,
    7851,
    18386,
    162,
    243,
    120,
    202,
    232,
    125,
    96,
    18
  ],
  "EFI_SETUP_VARIABLE_GUID": [
    3968325187,
    60324,
    19381,
    161,
    229,
    63,
    62,
    54,
    178,
    13,
    169
  ],
  "MFG_MODE_VARIABLE_GUID": [
    4011130232,
    1939,
    20011,
    172,
    109,
    6,
    40,
    71,
    224,
    23,
    145
  ],
  "ACPI_OSFR_REF_DATA_BLOCK_VARIABLE_GUID": [
    1914913299,
    4055,
    18593,
    165,
    159,
    180,
    27,
    193,
    7,
    251,
    205
  ],
  "ACPIOSFR_MODEL_STRING_VARIABLE_GUID": [
    3390819033,
    57377,
    17735,
    161,
    176,
    91,
    34,
    199,
    246,
    135,
    244
  ],
  "EFI_PCI_LAN_INFO_GUID": [
    228201511,
    57386,
    17277,
    146,
    107,
    170,
    82,
    31,
    215,
    34,
    186
  ],
  "FIRMWARE_ID_GUID": [
    1582668835,
    8106,
    19169,
    141,
    74,
    198,
    207,
    2,
    108,
    118,
    111
  ],
  "OS_SELECTION_VARIABLE_GUID": [
    2256813910,
    26461,
    16549,
    149,
    48,
    188,
    133,
    131,
    114,
    241,
    3
  ],
  "EFI_TPM_MP_DRIVER_PROTOCOL_GUID": [
    3725991166,
    7776,
    17057,
    140,
    195,
    238,
    126,
    240,
    115,
    82,
    18
  ],
  "EFI_LPC_WPCE791_POLICY_PROTOCOL_GUID": [
    2871782959,
    49574,
    17305,
    133,
    61,
    192,
    124,
    119,
    79,
    253,
    13
  ],
  "USB_POLICY_GUID": [
    4128748376,
    4815,
    16714,
    160,
    105,
    96,
    103,
    123,
    218,
    19,
    180
  ],
  "DXE_VLV_PLATFORM_POLICY_GUID": [
    1537968314,
    57570,
    18036,
    182,
    173,
    184,
    18,
    246,
    136,
    28,
    214
  ],
  "EFI_SMBIOS_SLOT_POPULATION_GUID": [
    4017878998,
    63743,
    19062,
    130,
    71,
    192,
    208,
    209,
    204,
    73,
    192
  ],
  "OBSERVABLE_PROTOCOL_GUID": [
    3794257186,
    54782,
    19027,
    135,
    177,
    15,
    190,
    87,
    15,
    152,
    233
  ],
  "EFI_CK505_CLOCK_PLATFORM_INFO_GUID": [
    1011375780,
    17562,
    18126,
    187,
    8,
    42,
    51,
    110,
    169,
    107,
    78
  ],
  "EFI_LPC_WPC83627_POLICY_PROTOCOL_GUID": [
    3555509607,
    40917,
    17601,
    134,
    207,
    93,
    167,
    162,
    79,
    75,
    93
  ],
  "EFI_TCO_RESET_PROTOCOL_GUID": [
    2795999586,
    58149,
    19504,
    188,
    195,
    89,
    55,
    48,
    100,
    239,
    179
  ],
  "EFI_WATCHDOG_TIMER_DRIVER_PROTOCOL_GUID": [
    3585109270,
    11937,
    19951,
    152,
    208,
    160,
    93,
    64,
    114,
    132,
    23
  ],
  "EFI_PLATFORM_IDE_INIT_PROTOCOL_GUID": [
    930899619,
    36839,
    20200,
    133,
    184,
    241,
    162,
    130,
    86,
    158,
    59
  ],
  "ENHANCED_SPEEDSTEP_PROTOCOL_GUID": [
    2443304399,
    21364,
    18745,
    137,
    81,
    215,
    41,
    63,
    26,
    120,
    111
  ],
  "EFI_GOP_DISPLAY_BRIGHTNESS_PROTOCOL_GUID": [
    1878146845,
    34684,
    19227,
    147,
    252,
    241,
    66,
    178,
    238,
    166,
    167
  ],
  "EFI_USB_KEYBOARD_CONNECT_GUID": [
    2912699265,
    7902,
    17164,
    141,
    66,
    35,
    118,
    124,
    70,
    93,
    82
  ],
  "EFI_MMIO_DEVICE_PROTOCOL_GUID": [
    608723494,
    63682,
    16885,
    185,
    221,
    120,
    62,
    158,
    86,
    222,
    160
  ],
  "EFI_I2C_BUS_CONFIGURATION_MANAGEMENT_PROTOCOL2_GUID": [
    1963139093,
    53590,
    16958,
    191,
    163,
    122,
    101,
    171,
    164,
    113,
    5
  ],
  "EFI_I2C_ACPI_PROTOCOL_GUID": [
    4077660437,
    22402,
    20074,
    168,
    70,
    5,
    186,
    188,
    231,
    182,
    160
  ],
  "EFI_I2C_MASTER_PROTOCOL2_GUID": [
    1468805466,
    26831,
    20097,
    181,
    198,
    34,
    219,
    64,
    208,
    16,
    188
  ],
  "EFI_I2C_HOST_PROTOCOL2_GUID": [
    1890722223,
    65023,
    20446,
    153,
    104,
    26,
    246,
    35,
    169,
    86,
    217
  ],
  "EFI_I2C_BUS_PROTOCOL_GUID": [
    2678174245,
    13126,
    17947,
    160,
    105,
    237,
    1,
    182,
    115,
    210,
    64
  ],
  "EFI_I2C_SLAVE_PROTOCOL_GUID": [
    4072771854,
    62921,
    19314,
    178,
    67,
    109,
    89,
    9,
    106,
    121,
    240
  ],
  "EFI_SPI_ACPI_PROTOCOL_GUID": [
    2672404601,
    15729,
    17075,
    160,
    173,
    221,
    177,
    243,
    48,
    16,
    163
  ],
  "EFI_SPI_HOST_PROTOCOL_GUID": [
    2501600741,
    34930,
    16877,
    173,
    29,
    213,
    104,
    31,
    74,
    240,
    51
  ],
  "EFI_SPI_BUS_PROTOCOL_GUID": [
    326840388,
    63191,
    18238,
    166,
    37,
    159,
    185,
    37,
    5,
    193,
    128
  ],
  "LPSS_DUMMY_PROTOCOL_GUID": [
    2941043042,
    54300,
    17754,
    171,
    69,
    109,
    188,
    193,
    205,
    50,
    243
  ],
  "EFI_GPIO_OPERATION_PROTOCOL_GUID": [
    954072719,
    35217,
    17578,
    152,
    137,
    131,
    244,
    145,
    132,
    101,
    176
  ],
  "EFI_ESRT_OPERATION_PROTOCOL_GUID": [
    1162455879,
    28256,
    17043,
    185,
    29,
    49,
    182,
    16,
    173,
    128,
    86
  ],
  "EFI_FW_DISPLAY_CAPSULE_GUID": [
    999063906,
    6284,
    18084,
    174,
    201,
    190,
    67,
    241,
    214,
    86,
    151
  ],
  "EFI_FIRMWARE_CLASS_GUID": [
    2971837026,
    13649,
    20296,
    136,
    146,
    85,
    246,
    192,
    97,
    66,
    144
  ],
  "EFI_DFU_VER_GUID": [
    231160557,
    52214,
    18981,
    166,
    141,
    89,
    200,
    15,
    68,
    199,
    195
  ],
  "EFI_CAPSULE_CRASH_LOG_VAR_GUID": [
    4093580392,
    1210,
    18790,
    159,
    178,
    228,
    167,
    144,
    5,
    70,
    80
  ],
  "EFI_CAPSULE_CRASH_GUID": [
    236792178,
    26031,
    19137,
    191,
    163,
    206,
    244,
    171,
    12,
    56,
    254
  ],
  "EFI_TR_EE_PHYSICAL_PRESENCE_GUID": [
    4064691138,
    50722,
    18766,
    138,
    13,
    70,
    50,
    87,
    156,
    45,
    91
  ],
  "TR_EE_CONFIG_FORM_SET_GUID": [
    3310043743,
    43641,
    18612,
    152,
    31,
    153,
    139,
    60,
    75,
    100,
    28
  ],
  "STD_LIB_TOKEN_SPACE_GUID": [
    1148541424,
    53294,
    19697,
    153,
    188,
    202,
    17,
    101,
    64,
    84,
    194
  ],
  "EFI_SOCKET_PROTOCOL_GUID": [
    1491529059,
    5780,
    17419,
    147,
    136,
    233,
    143,
    237,
    107,
    101,
    175
  ],
  "EFI_SOCKET_SERVICE_BINDING_PROTOCOL_GUID": [
    2326715178,
    42683,
    18374,
    148,
    206,
    27,
    128,
    150,
    66,
    63,
    42
  ],
  "VLV_POLICY_PPI_GUID": [
    2105848514,
    8865,
    17266,
    177,
    44,
    235,
    178,
    50,
    211,
    166,
    163
  ],
  "VLV_MMIO_POLICY_PPI_GUID": [
    3882336127,
    19894,
    23348,
    16,
    17,
    79,
    190,
    76,
    167,
    175,
    210
  ],
  "SE_CF_TPM_PPI_GUID": [
    283274737,
    34677,
    20193,
    181,
    10,
    58,
    232,
    40,
    147,
    112,
    58
  ],
  "VLV_PEI_INIT_PPI_GUID": [
    166365457,
    48653,
    16944,
    160,
    3,
    237,
    198,
    147,
    180,
    142,
    17
  ],
  "SEC_UMA_PPI_GUID": [
    3419956855,
    13871,
    19460,
    148,
    89,
    167,
    65,
    50,
    110,
    5,
    207
  ],
  "PEI_SEC_PLATFORM_POLICY_PPI_GUID": [
    2061749943,
    12002,
    18682,
    170,
    73,
    53,
    16,
    188,
    131,
    202,
    191
  ],
  "PEI_SDHC_PPI_GUID": [
    4109344122,
    39109,
    19482,
    180,
    217,
    216,
    216,
    114,
    101,
    190,
    12
  ],
  "SEC_FTPM_POLICY_PPI_GUID": [
    1339144777,
    36752,
    18202,
    162,
    201,
    23,
    60,
    122,
    115,
    47,
    208
  ],
  "PCH_PEI_INIT_PPI_GUID": [
    2897820424,
    23772,
    19087,
    147,
    212,
    6,
    227,
    66,
    223,
    24,
    46
  ],
  "EFI_SD_HOST_IO_PROTOCOL_GUID": [
    3057618631,
    43465,
    17522,
    164,
    192,
    77,
    139,
    243,
    101,
    204,
    81
  ],
  "EFI_PCH_EXTENDED_RESET_PROTOCOL_GUID": [
    4038851744,
    26702,
    18611,
    186,
    226,
    108,
    132,
    184,
    158,
    83,
    57
  ],
  "DXE_ICH_PLATFORM_POLICY_PROTOCOL_GUID": [
    4128748376,
    4815,
    16714,
    160,
    105,
    96,
    103,
    123,
    218,
    19,
    179
  ],
  "IGD_OP_REGION_PROTOCOL_GUID": [
    3452296671,
    59293,
    16876,
    169,
    176,
    101,
    101,
    73,
    13,
    185,
    211
  ],
  "EFI_HECI_PROTOCOL_GUID": [
    3484629008,
    28295,
    17028,
    178,
    3,
    166,
    106,
    190,
    7,
    246,
    232
  ],
  "PLATFORM_SEC_HOOK_PROTOCOL_GUID": [
    3159508846,
    63102,
    17153,
    178,
    98,
    54,
    156,
    72,
    120,
    170,
    194
  ],
  "EFI_SEC_RC_INFO_PROTOCOL_GUID": [
    301727227,
    4306,
    17382,
    181,
    177,
    180,
    56,
    110,
    220,
    203,
    154
  ],
  "DXE_PLATFORM_SE_C_POLICY_GUID": [
    4173328404,
    6395,
    20217,
    177,
    12,
    174,
    34,
    115,
    141,
    190,
    237
  ],
  "EFI_EMMC_CARD_INFO_PROTOCOL_GUID": [
    515791545,
    8489,
    18919,
    132,
    215,
    238,
    185,
    252,
    229,
    222,
    221
  ],
  "EFI_TDT_OPERATION_PROTOCOL_GUID": [
    4247788452,
    24162,
    18041,
    160,
    111,
    224,
    154,
    171,
    221,
    42,
    145
  ],
  "EFI_DFU_RESULT_GUID": [
    346539119,
    48130,
    16455,
    159,
    24,
    165,
    215,
    37,
    216,
    189,
    25
  ],
  "EFI_CP_TOKEN_SPACE_GUID": [
    2441220558,
    41426,
    17312,
    160,
    78,
    117,
    181,
    191,
    68,
    80,
    14
  ],
  "EFI_VLV_TOKEN_SPACE_GUID": [
    3393530984,
    57100,
    17865,
    130,
    251,
    234,
    228,
    43,
    49,
    41,
    70
  ],
  "DXE_PCH_POLICY_UPDATE_PROTOCOL_GUID": [
    444702281,
    55534,
    18635,
    154,
    156,
    10,
    160,
    210,
    129,
    10,
    56
  ],
  "VLV_REF_CODE_PKG_TOKEN_SPACE_GUID": [
    2239139402,
    27868,
    17486,
    147,
    223,
    147,
    102,
    133,
    181,
    223,
    204
  ],
  "SEC_PLATFORM_READY_TO_BOOT_GUID": [
    66974065,
    7527,
    19150,
    169,
    4,
    62,
    54,
    211,
    56,
    250,
    116
  ],
  "EFI_VLV2_VARIABLE_GUID": [
    280652734,
    43390,
    16835,
    154,
    7,
    96,
    122,
    217,
    189,
    96,
    229
  ],
  "AMI_CHIPSET_MODULE_PKG_TOKEN_SPACE_GUID": [
    3912812990,
    53186,
    19101,
    163,
    205,
    150,
    83,
    216,
    19,
    48,
    9
  ],
  "AMI_PERIODIC_SMI_CONTROL_PROTOCOL_GUID": [
    2149490159,
    56763,
    19619,
    150,
    152,
    201,
    21,
    142,
    184,
    106,
    234
  ],
  "AMI_SIO_PORT_COMPATIBILITY_PROTOCOL_GUID": [
    1112592066,
    56795,
    16395,
    140,
    98,
    207,
    152,
    100,
    246,
    209,
    84
  ],
  "AMI_PCI_PORT_COMPATIBILITY_PROTOCOL_GUID": [
    3930785397,
    7990,
    19134,
    187,
    58,
    109,
    96,
    118,
    10,
    2,
    162
  ],
  "HII_UTILITIES_PROTOCOL_GUID": [
    1739946108,
    3690,
    18326,
    148,
    62,
    160,
    147,
    183,
    58,
    2,
    103
  ],
  "SECURE_SMI_FLASH_PROTOCOL_GUID": [
    1005891350,
    43900,
    19267,
    137,
    141,
    171,
    38,
    172,
    93,
    220,
    108
  ],
  "FLASH_UPD_BOOT_MODE_PPI_GUID": [
    711888939,
    61939,
    17013,
    188,
    123,
    64,
    253,
    75,
    84,
    129,
    231
  ],
  "EFI_AMI_SIO_PROTOCOL_GUID": [
    1374270713,
    21853,
    18284,
    139,
    181,
    189,
    24,
    217,
    166,
    136,
    120
  ],
  "AMI_EFI_KEYCODE_PROTOCOL_GUID": [
    182433325,
    65396,
    18508,
    137,
    68,
    248,
    92,
    75,
    234,
    135,
    168
  ],
  "AMI_MULTI_LANG_SUPPORT_PROTOCOL_GUID": [
    2996157724,
    25571,
    18659,
    178,
    101,
    247,
    223,
    162,
    7,
    1,
    35
  ],
  "EFI_SATA_CONTROLLER_PROTOCOL_GUID": [
    717973031,
    57090,
    20003,
    180,
    249,
    106,
    147,
    250,
    110,
    157,
    166
  ],
  "AMI_SMBIOS_PROTOCOL_GUID": [
    1586537741,
    26965,
    19017,
    144,
    50,
    218,
    56,
    18,
    248,
    232,
    229
  ],
  "AMI_SMBIOS_FLASH_DATA_PROTOCOL_GUID": [
    3724236119,
    15918,
    17769,
    180,
    89,
    190,
    255,
    225,
    137,
    184,
    176
  ],
  "AMI_CMOS_ACCESS_DXE_PROTOCOL_GUID": [
    2555474956,
    8928,
    17421,
    144,
    144,
    239,
    45,
    113,
    194,
    81,
    201
  ],
  "AMI_CMOS_ACCESS_SMM_PROTOCOL_GUID": [
    3855811178,
    7333,
    16624,
    143,
    182,
    75,
    26,
    250,
    60,
    110,
    170
  ],
  "AMI_CPU_INFO_PROTOCOL_GUID": [
    4043961185,
    14092,
    19868,
    177,
    171,
    124,
    162,
    212,
    200,
    179,
    255
  ],
  "AMI_SMBRUN_GUID": [
    730480737,
    37169,
    19754,
    162,
    11,
    216,
    69,
    208,
    235,
    29,
    131
  ],
  "AMI_CRB_PKG_TOKEN_SPACE_GUID": [
    3888952027,
    49536,
    19266,
    134,
    4,
    70,
    137,
    167,
    246,
    16,
    173
  ],
  "VIDEO_INIT_DONE_SENT_GUID": [
    2311341847,
    32484,
    18555,
    143,
    92,
    142,
    96,
    149,
    86,
    169,
    15
  ],
  "EFI_ACPI_EN_DISPATCH_PROTOCOL_GUID": [
    3179867240,
    60388,
    20347,
    147,
    90,
    79,
    102,
    102,
    66,
    231,
    95
  ],
  "EFI_ACPI_DIS_DISPATCH_PROTOCOL_GUID": [
    2626919334,
    8140,
    18166,
    180,
    225,
    16,
    45,
    190,
    24,
    101,
    103
  ],
  "AMI_DXE_SB_GUID": [
    3083965585,
    58714,
    18189,
    133,
    8,
    133,
    165,
    223,
    164,
    25,
    116
  ],
  "AMI_CRYPTO_PKG_TOKEN_SPACE_GUID": [
    2059323795,
    21462,
    17999,
    131,
    113,
    255,
    175,
    217,
    127,
    57,
    40
  ],
  "PKEY_FILE_SHA256_GUID": [
    1535481436,
    17757,
    19654,
    156,
    76,
    127,
    8,
    105,
    103,
    210,
    176
  ],
  "PKEY_FILE_X509_GUID": [
    979789144,
    17379,
    19749,
    145,
    105,
    219,
    129,
    245,
    219,
    66,
    225
  ],
  "AMI_DIGITAL_SIGNATURE_PPI_GUID": [
    2260900517,
    3504,
    17219,
    189,
    82,
    122,
    114,
    159,
    55,
    201,
    109
  ],
  "EFI_AMI_DEBUG_RX_PKG_TOKEN_SPACE_GUID": [
    2999441655,
    20095,
    18089,
    140,
    222,
    249,
    251,
    109,
    39,
    98,
    120
  ],
  "GPNV_ERROR_LOGGING_TOKEN_GUID": [
    2983702867,
    4492,
    18667,
    152,
    44,
    181,
    95,
    206,
    153,
    246,
    244
  ],
  "AMI_EVENT_LOGS_FORMSET_GUID": [
    2347469849,
    16364,
    20395,
    163,
    120,
    201,
    3,
    232,
    144,
    252,
    174
  ],
  "AMI_SMBIOS_ELOG_SUPPORT_GUID": [
    240677092,
    1317,
    16557,
    149,
    168,
    15,
    255,
    21,
    91,
    143,
    192
  ],
  "AMI_SMM_DUMMY_PROTOCOL_REDIR_GUID": [
    2624780283,
    34486,
    16495,
    184,
    110,
    243,
    128,
    154,
    134,
    193,
    56
  ],
  "AMI_EVENT_LOGS_HII_HANDLE_GUID": [
    1439661262,
    1311,
    17091,
    156,
    169,
    32,
    219,
    92,
    173,
    154,
    228
  ],
  "AMI_EVENT_LOGS_DYNAMIC_GUID": [
    3713117048,
    58717,
    17427,
    175,
    174,
    229,
    146,
    246,
    181,
    50,
    27
  ],
  "AMI_IPMI_PKG_TOKEN_SPACE_GUID": [
    505529126,
    3392,
    16626,
    159,
    2,
    58,
    155,
    120,
    56,
    170,
    107
  ],
  "EFI_SERVER_MGMT_SETUP_VARIABLE_GUID": [
    19110297,
    64526,
    19310,
    158,
    121,
    213,
    77,
    93,
    182,
    205,
    32
  ],
  "EFI_IPMI_CMOS_CLEAR_VARIABLE_GUID": [
    1734051686,
    32515,
    16769,
    155,
    225,
    115,
    188,
    69,
    223,
    247,
    153
  ],
  "EFI_IPMI_BOOT_GUID": [
    2217115890,
    6812,
    18662,
    164,
    51,
    190,
    154,
    203,
    13,
    212,
    56
  ],
  "EFI_PEI_IPMI_TRANSPORT_PPI_GUID": [
    2166542013,
    62717,
    20136,
    151,
    108,
    240,
    3,
    173,
    220,
    76,
    180
  ],
  "EFI_PEI_IPMI_USB_TRANSPORT_PPI_GUID": [
    3420267415,
    53957,
    16731,
    189,
    119,
    150,
    48,
    161,
    183,
    133,
    61
  ],
  "EFI_PEI_SEL_PPI_GUID": [
    3842731613,
    13723,
    19424,
    160,
    176,
    7,
    21,
    163,
    1,
    166,
    6
  ],
  "EFI_DXE_IPMI_TRANSPORT_PROTOCOL_GUID": [
    1243418214,
    21105,
    20002,
    131,
    254,
    144,
    146,
    27,
    116,
    130,
    19
  ],
  "EFI_SMM_IPMI_TRANSPORT_PROTOCOL_GUID": [
    498930947,
    2656,
    16944,
    170,
    163,
    128,
    22,
    216,
    195,
    222,
    47
  ],
  "EFI_BMC_SELF_TEST_LOG_PROTOCOL_GUID": [
    2682692402,
    6687,
    17379,
    189,
    37,
    247,
    137,
    28,
    111,
    199,
    74
  ],
  "EFI_SEL_STATUS_CODE_PROTOCOL_GUID": [
    3160376860,
    34541,
    16766,
    187,
    123,
    108,
    2,
    107,
    220,
    101,
    35
  ],
  "EFI_REDIR_FRU_PROTOCOL_GUID": [
    677612794,
    60040,
    17772,
    146,
    165,
    242,
    73,
    202,
    72,
    133,
    53
  ],
  "EFI_REDIR_ELOG_PROTOCOL_GUID": [
    382799920,
    29114,
    20062,
    169,
    249,
    180,
    117,
    165,
    73,
    4,
    138
  ],
  "EFI_DXE_IPMI_USB_TRANSPORT_PROTOCOL_GUID": [
    1121145776,
    35870,
    19146,
    190,
    172,
    40,
    251,
    36,
    242,
    12,
    66
  ],
  "AMI_ATA_PASS_THRU_INIT_PROTOCOL_GUID": [
    3329442833,
    11738,
    17970,
    165,
    146,
    146,
    15,
    36,
    214,
    237,
    33
  ],
  "AMI_AHCI_BUS_PROTOCOL_GUID": [
    3002746724,
    15214,
    17363,
    145,
    223,
    135,
    209,
    90,
    62,
    86,
    104
  ],
  "AMI_AHCI_PLATFORM_POLICY_PROTOCOL_GUID": [
    393243943,
    33790,
    18288,
    135,
    95,
    76,
    239,
    76,
    184,
    246,
    61
  ],
  "AMI_AHCI_SMM_PROTOCOL_GUID": [
    3002750820,
    15214,
    17363,
    145,
    223,
    135,
    209,
    90,
    62,
    86,
    104
  ],
  "AMI_BLOCK_IO_WRITE_PROTECTION_PROTOCOL_GUID": [
    2140494398,
    44981,
    16674,
    185,
    37,
    75,
    17,
    113,
    246,
    147,
    245
  ],
  "AMI_BOARD_INFO2_PROTOCOL_GUID": [
    1338012479,
    28626,
    18715,
    168,
    144,
    83,
    116,
    82,
    27,
    244,
    143
  ],
  "AMI_BOARD_SIO_INIT_PROTOCOL_GUID": [
    2637625327,
    24696,
    17433,
    140,
    70,
    43,
    189,
    176,
    224,
    199,
    179
  ],
  "AMI_BOARD_PCI_INIT_PROTOCOL_GUID": [
    3965928077,
    26314,
    19449,
    130,
    174,
    132,
    15,
    109,
    92,
    35,
    5
  ],
  "AMI_CSM_OPROM_POLICY_PROTOCOL_GUID": [
    3692357271,
    30554,
    19515,
    161,
    26,
    237,
    195,
    142,
    27,
    227,
    230
  ],
  "AMI_CSM_VIDEO_POLICY_PROTOCOL_GUID": [
    978207606,
    18545,
    19214,
    160,
    47,
    237,
    54,
    242,
    174,
    205,
    0
  ],
  "AMI_FLASH_PROTOCOL_GUID": [
    1968924054,
    26774,
    19363,
    179,
    221,
    28,
    98,
    159,
    209,
    234,
    136
  ],
  "AMI_SMM_FLASH_PROTOCOL_GUID": [
    3971508139,
    36340,
    18733,
    129,
    80,
    167,
    253,
    27,
    155,
    90,
    117
  ],
  "AMI_HDD_HPA_PROTOCOL_GUID": [
    1370121724,
    33462,
    18918,
    149,
    226,
    230,
    130,
    122,
    141,
    125,
    180
  ],
  "AMI_HDD_OPAL_SEC_INIT_PROTOCOL_GUID": [
    1504646832,
    26141,
    18533,
    163,
    129,
    56,
    222,
    104,
    56,
    93,
    141
  ],
  "AMI_HDD_POWER_MGMT_PROTOCOL_GUID": [
    1740388483,
    32377,
    19393,
    163,
    62,
    58,
    247,
    209,
    117,
    137,
    186
  ],
  "AMI_HDD_SECURITY_INIT_PROTOCOL_GUID": [
    3463415483,
    47104,
    19569,
    178,
    209,
    56,
    151,
    163,
    188,
    29,
    174
  ],
  "AMI_TCG_STORAGE_SECURITY_INIT_PROTOCOL_GUID": [
    1934270493,
    38380,
    17847,
    162,
    58,
    45,
    134,
    216,
    253,
    235,
    182
  ],
  "AMI_HDD_SECURITY_PROTOCOL_GUID": [
    4109776169,
    10270,
    16448,
    163,
    19,
    193,
    214,
    118,
    99,
    132,
    190
  ],
  "AMI_HDD_SECURITY_END_PROTOCOL_GUID": [
    2910301737,
    19488,
    20445,
    133,
    4,
    129,
    118,
    97,
    155,
    103,
    106
  ],
  "AMI_ONBOARD_RAID_CONTROLLER_GUID": [
    1562406355,
    20842,
    18396,
    161,
    188,
    109,
    162,
    4,
    170,
    190,
    8
  ],
  "AMI_HDD_PASSWORD_VERIFIED_GUID": [
    533896166,
    28880,
    17060,
    166,
    231,
    229,
    209,
    14,
    106,
    195,
    118
  ],
  "AMI_TCG_STORAGE_SECURITY_PROTOCOL_GUID": [
    3013007930,
    21170,
    19670,
    168,
    154,
    19,
    231,
    196,
    174,
    151,
    144
  ],
  "AMI_HDD_SMART_INIT_PROTOCOL_GUID": [
    2483141967,
    6656,
    18832,
    171,
    86,
    218,
    240,
    228,
    227,
    72,
    222
  ],
  "AMI_HDD_SMART_PROTOCOL_GUID": [
    4290616018,
    61915,
    20370,
    166,
    73,
    235,
    158,
    237,
    234,
    134,
    181
  ],
  "AMI_HDD_TEMPERATURE_PROTOCOL_GUID": [
    2845029996,
    8938,
    18106,
    162,
    122,
    10,
    35,
    53,
    109,
    144,
    28
  ],
  "AMI_PLATFORM_IDE_PROTOCOL_GUID": [
    1731720859,
    47308,
    17852,
    147,
    39,
    204,
    245,
    238,
    247,
    12,
    222
  ],
  "AMI_IDE_BUS_INIT_PROTOCOL_GUID": [
    3780749654,
    12953,
    20201,
    145,
    118,
    101,
    24,
    26,
    78,
    94,
    159
  ],
  "AMI_SCSI_PASS_THRU_INIT_PROTOCOL_GUID": [
    264571000,
    5683,
    17194,
    189,
    228,
    132,
    19,
    87,
    252,
    21,
    233
  ],
  "AMI_ERROR_DISPLAY_FRAMEWORK_PROTOCOL_GUID": [
    3966346748,
    33726,
    17339,
    135,
    247,
    75,
    7,
    227,
    20,
    231,
    192
  ],
  "AMI_SERIAL_PROTOCOL_GUID": [
    1356618896,
    7475,
    20438,
    135,
    229,
    6,
    59,
    29,
    250,
    33,
    112
  ],
  "AMI_OEM_CSM16_BINARY_GUID": [
    3919103704,
    22315,
    19992,
    150,
    204,
    3,
    30,
    163,
    221,
    85,
    140
  ],
  "AMI_PCI_IRQ_PROGRAM_GUID": [
    2483082651,
    3740,
    20332,
    181,
    154,
    252,
    32,
    0,
    157,
    185,
    236
  ],
  "AMI_CSM_STARTED_PROTOCOL_GUID": [
    1051206865,
    33251,
    20469,
    189,
    67,
    187,
    156,
    101,
    223,
    124,
    70
  ],
  "AMI_PCI_OPROM_DATA_PROTOCOL_GUID": [
    815157570,
    64602,
    20078,
    148,
    219,
    187,
    164,
    65,
    179,
    104,
    81
  ],
  "EFI_SMI_FLASH_PROTOCOL_GUID": [
    1865156264,
    54452,
    19091,
    159,
    120,
    43,
    72,
    11,
    232,
    14,
    15
  ],
  "SDIO_BUS_INIT_PROTOCOL_GUID": [
    2496043079,
    41167,
    17973,
    170,
    35,
    210,
    102,
    123,
    215,
    247,
    145
  ],
  "EFI_SDIO_PROTOCOL_GUID": [
    2533928370,
    10417,
    18167,
    154,
    108,
    231,
    68,
    151,
    250,
    102,
    121
  ],
  "AMI_TCG_PLATFORM_PROTOCOLGUID": [
    2358482436,
    1792,
    17429,
    157,
    98,
    17,
    97,
    219,
    129,
    100,
    166
  ],
  "AMI_TPM_SUPPORT_TYPE_PROTOCOLGUID": [
    839638073,
    16288,
    19369,
    191,
    45,
    179,
    63,
    114,
    186,
    156,
    161
  ],
  "EFI_GENERIC_ELOG_PROTOCOL_GUID": [
    1506815949,
    37427,
    19764,
    188,
    254,
    135,
    202,
    129,
    211,
    221,
    167
  ],
  "EFI_GENERIC_ELOG_SMM_PROTOCOL_INSTALLLED": [
    2753707249,
    27431,
    18836,
    143,
    203,
    163,
    162,
    121,
    192,
    78,
    129
  ],
  "EFI_KEY_MON_PLATFORM_PROTOCOL_GUID": [
    334761838,
    20673,
    19315,
    177,
    226,
    110,
    114,
    210,
    28,
    176,
    74
  ],
  "EFI_MONITOR_KEY_FILTER_PROTOCOL_GUID": [
    2655248680,
    51021,
    17140,
    140,
    12,
    72,
    17,
    103,
    74,
    23,
    181
  ],
  "AMI_REFLASH_PROTOCOL_GUID": [
    2414167525,
    56489,
    19794,
    191,
    205,
    143,
    19,
    231,
    23,
    1,
    95
  ],
  "AMI_PLATFORM_TO_DRIVER_AGENT_PROTOCOL_GUID": [
    500153034,
    27354,
    19469,
    134,
    237,
    175,
    101,
    139,
    223,
    236,
    12
  ],
  "AMI_NVME_CONTROLLER_PROTOCOL_GUID": [
    2946813759,
    44913,
    19504,
    164,
    251,
    41,
    16,
    231,
    113,
    249,
    176
  ],
  "AMI_SMM_NVME_CONTROLLER_PROTOCOL_GUID": [
    2849838487,
    62149,
    19638,
    170,
    123,
    238,
    1,
    174,
    128,
    97,
    133
  ],
  "AMI_NVME_PASS_THRU_PROTOCOL_GUID": [
    1260474769,
    39461,
    17405,
    134,
    181,
    116,
    231,
    175,
    114,
    51,
    21
  ],
  "AMI_SMM_NVME_PASS_THRU_PROTOCOL_GUID": [
    3105179637,
    19748,
    20207,
    133,
    7,
    116,
    221,
    171,
    235,
    113,
    173
  ],
  "AMI_NVME_LEGACY_PROTOCOL_GUID": [
    3571948974,
    43772,
    17282,
    149,
    64,
    62,
    63,
    164,
    45,
    66,
    85
  ],
  "AMI_TEXT_OUT_PROTOCOL_GUID": [
    3789858903,
    51568,
    16501,
    164,
    218,
    233,
    196,
    27,
    105,
    173,
    252
  ],
  "AMI_DEBUG_SERVICE_PROTOCOL_GUID": [
    908273974,
    3702,
    12744,
    161,
    58,
    58,
    242,
    252,
    28,
    57,
    50
  ],
  "AMI_SMM_DEBUG_SERVICE_PROTOCOL_GUID": [
    1142946328,
    34580,
    16926,
    140,
    149,
    88,
    112,
    128,
    121,
    111,
    238
  ],
  "AMI_USB_IAD_PROTOCOL_GUID": [
    169383791,
    27814,
    16475,
    175,
    75,
    39,
    184,
    247,
    246,
    219,
    152
  ],
  "AMI_USB_VIDEO_PROTOCOL_GUID": [
    2189561759,
    16791,
    18128,
    169,
    108,
    177,
    209,
    91,
    173,
    152,
    142
  ],
  "AMI_MULTI_PLATFORM_PROTOCOL_GUID": [
    853086570,
    44821,
    18806,
    144,
    140,
    44,
    110,
    5,
    203,
    120,
    154
  ],
  "AMI_SMM_MULTI_PLATFORM_PROTOCOL_GUID": [
    433663021,
    61577,
    19324,
    171,
    230,
    51,
    58,
    18,
    5,
    237,
    137
  ],
  "AMI_NVRAM_UPDATE_PROTOCOL_GUID": [
    3722646900,
    13705,
    20393,
    188,
    105,
    23,
    41,
    175,
    111,
    218,
    78
  ],
  "AMI_SMM_NVRAM_UPDATE_PROTOCOL_GUID": [
    4079110750,
    6051,
    18370,
    163,
    139,
    72,
    20,
    86,
    134,
    60,
    116
  ],
  "AMI_SIO_SMM_HANDOFF_PROTOCOL_GUID": [
    1970719881,
    36771,
    19629,
    186,
    2,
    97,
    25,
    180,
    110,
    212,
    74
  ],
  "AMI_PCI_SMM_HANDOFF_PROTOCOL_GUID": [
    1875786681,
    38722,
    19709,
    142,
    158,
    57,
    249,
    141,
    202,
    50,
    113
  ],
  "AMI_BDS_CONNECT_POLICY_PROTOCOL_GUID": [
    953573059,
    36665,
    18016,
    184,
    166,
    243,
    106,
    163,
    146,
    84,
    117
  ],
  "AMI_OPTION_ROM_POLICY_PROTOCOL_GUID": [
    2471291098,
    24106,
    16772,
    138,
    21,
    142,
    8,
    71,
    152,
    132,
    49
  ],
  "AMI_FRI_PROTOCOL_GUID": [
    3203715761,
    50491,
    18739,
    163,
    186,
    42,
    66,
    44,
    137,
    164,
    57
  ],
  "AMI_SMM_BUFFER_VALIDATION_PROTOCOL_GUID": [
    3662101887,
    19249,
    19811,
    146,
    183,
    61,
    144,
    94,
    248,
    75,
    132
  ],
  "AMI_BDS_CONNECT_DRIVERS_PROTOCOL_GUID": [
    984102725,
    37972,
    20346,
    167,
    192,
    144,
    219,
    208,
    47,
    171,
    142
  ],
  "AMI_READY_TO_LOAD_DXE_CORE_PPI_GUID": [
    302143110,
    14724,
    18028,
    152,
    11,
    139,
    94,
    137,
    218,
    3,
    25
  ],
  "SERIAL_RECOVERY_DEVICE_PPI_GUID": [
    1584423891,
    3090,
    18267,
    152,
    53,
    20,
    171,
    177,
    203,
    14,
    233
  ],
  "AMI_PLATFORM_SECURITY_CHIP_GUID": [
    90734410,
    15527,
    19737,
    155,
    197,
    225,
    128,
    206,
    163,
    86,
    159
  ],
  "AMI_TREE_PPI_GUID": [
    2264229898,
    5468,
    19400,
    172,
    119,
    87,
    56,
    72,
    226,
    173,
    61
  ],
  "AMI_MULTI_PLATFORM_PPI_GUID": [
    4031549949,
    23275,
    17853,
    190,
    113,
    101,
    67,
    89,
    4,
    197,
    104
  ],
  "AMI_PEI_PCI_ENUMERATION_PPI_GUID": [
    3887445781,
    4483,
    17715,
    190,
    118,
    86,
    166,
    215,
    206,
    176,
    46
  ],
  "AMI_MODULE_PKG_TOKEN_SPACE_GUID": [
    3545051700,
    14522,
    17035,
    154,
    205,
    132,
    232,
    48,
    168,
    7,
    133
  ],
  "WIN_CE_GUID": [
    3246675500,
    26724,
    16547,
    160,
    129,
    200,
    211,
    94,
    130,
    185,
    32
  ],
  "AMI_UDF_MEDIA_GUID": [
    1952823925,
    34983,
    19297,
    154,
    126,
    109,
    78,
    223,
    104,
    4,
    220
  ],
  "AMI_GLOBAL_VARIABLE_GUID": [
    20351105,
    50349,
    19229,
    182,
    49,
    213,
    122,
    142,
    200,
    219,
    107
  ],
  "AMI_ROM_LAYOUT_FFS_FILE_GUID": [
    3374070807,
    64628,
    18149,
    189,
    190,
    111,
    72,
    106,
    90,
    159,
    60
  ],
  "AMI_ROM_LAYOUT_GUID": [
    7871649,
    24035,
    16479,
    171,
    184,
    55,
    156,
    60,
    7,
    105,
    132
  ],
  "AMI_SMI_VARIABLE_DXE_DRIVER_STARTED_GUID": [
    3277821216,
    22417,
    18023,
    173,
    228,
    28,
    253,
    168,
    55,
    114,
    45
  ],
  "AMI_PERFORMANCE_PROFILING_GUID": [
    685038985,
    5790,
    18909,
    132,
    134,
    162,
    0,
    162,
    253,
    60,
    33
  ],
  "AMI_NVRAM_MAIN_ROM_AREA_GUID": [
    4199118076,
    44829,
    20061,
    189,
    197,
    218,
    205,
    109,
    39,
    186,
    236
  ],
  "AMI_NVRAM_BACKUP_ROM_AREA_GUID": [
    2817387480,
    43223,
    18680,
    129,
    251,
    131,
    118,
    86,
    184,
    32,
    119
  ],
  "AMI_NVRAM_SMM_COMMUNICATION_GUID": [
    1168935011,
    58362,
    19000,
    162,
    60,
    0,
    188,
    209,
    12,
    189,
    80
  ],
  "AMI_BOARD_INFO_FILE_GUID": [
    2073692690,
    17144,
    19788,
    130,
    182,
    50,
    240,
    202,
    25,
    83,
    244
  ],
  "AMI_ASL_DSDT_FILE_GUID": [
    3239638285,
    14621,
    17908,
    179,
    211,
    17,
    188,
    147,
    26,
    165,
    109
  ],
  "AMI_SMM_NVME_COMMUNICATION_GUID": [
    3962294781,
    58288,
    17051,
    173,
    223,
    150,
    87,
    147,
    90,
    54,
    132
  ],
  "AMI_PLATFORM_INFO_HOB_GUID": [
    2270075220,
    9428,
    17382,
    144,
    161,
    197,
    119,
    83,
    64,
    207,
    69
  ],
  "AMI_PLATFORM_INFO_UNCOMPRESSED_FFS_SECTION_GUID": [
    250393765,
    31647,
    18183,
    129,
    215,
    156,
    4,
    94,
    152,
    202,
    149
  ],
  "AMI_PLATFORM_INFO_COMPRESSED_FFS_SECTION_GUID": [
    3995434895,
    59152,
    16769,
    155,
    1,
    192,
    102,
    152,
    69,
    74,
    22
  ],
  "AMI_PLATFORM_INFO_FFS_FILE_GUID": [
    264473686,
    20490,
    18004,
    137,
    167,
    244,
    60,
    26,
    56,
    67,
    245
  ],
  "AMI_RESET_SYSTEM_EVENT_GUID": [
    1658481238,
    5115,
    18522,
    168,
    218,
    163,
    221,
    121,
    18,
    203,
    107
  ],
  "AMI_FRI_VARIABLE_GUID": [
    671861781,
    11479,
    18044,
    150,
    71,
    27,
    48,
    48,
    125,
    126,
    213
  ],
  "EFI_NETWORK_STACK_SETUP_GUID": [
    3510656278,
    31484,
    18069,
    187,
    18,
    65,
    69,
    157,
    54,
    149,
    162
  ],
  "READY_TO_PXE_BOOT_GUID": [
    3844039743,
    24380,
    19709,
    145,
    38,
    70,
    135,
    48,
    95,
    24,
    218
  ],
  "AMI_DXE_HASH_INTERFACE_GUID": [
    2627256330,
    11931,
    18582,
    149,
    200,
    172,
    100,
    53,
    130,
    132,
    229
  ],
  "AMI_NVRAM_CONTROL_PROTOCOL_GUID": [
    4157240680,
    23049,
    19756,
    138,
    155,
    117,
    132,
    104,
    89,
    42,
    226
  ],
  "AMI_TCG2_INFO_PROTOCOL_GUID": [
    52798804,
    1470,
    18027,
    188,
    140,
    112,
    190,
    60,
    157,
    175,
    177
  ],
  "AMI_HASH_LOG_EXTEND_EX_GUID": [
    3748010348,
    38287,
    18223,
    147,
    147,
    113,
    125,
    130,
    17,
    10,
    246
  ],
  "SKIP_TPM_STARTUP_GUID": [
    1860285571,
    43448,
    20143,
    154,
    225,
    59,
    40,
    197,
    207,
    243,
    107
  ],
  "PASSWORD_AUTHENTICATION_GUID": [
    2962472406,
    11746,
    18545,
    135,
    104,
    238,
    29,
    165,
    114,
    73,
    180
  ],
  "AMI_TCM_SIGNALGUID": [
    2445758032,
    13853,
    19674,
    161,
    107,
    201,
    43,
    228,
    191,
    22,
    238
  ],
  "AMI_LEGACY_TPMGUID": [
    2714259589,
    12371,
    19531,
    169,
    246,
    114,
    77,
    34,
    167,
    110,
    249
  ],
  "EFI_TCG_MP_DRIVER_HOB_GUID": [
    3132009737,
    672,
    16689,
    158,
    13,
    188,
    82,
    158,
    240,
    255,
    42
  ],
  "EFI_PEI_TCG_LOG_HOB_GUID": [
    1602047502,
    15725,
    17084,
    169,
    66,
    14,
    145,
    232,
    62,
    60,
    49
  ],
  "PEI_EFI_TCG_WAKE_EVENT_DATA_HOB_GUID": [
    3149402299,
    24304,
    20111,
    178,
    152,
    173,
    116,
    170,
    80,
    239,
    10
  ],
  "VARIABLES_GUID": [
    1329920612,
    43222,
    19481,
    182,
    29,
    99,
    16,
    157,
    119,
    211,
    210
  ],
  "TPM20_HOB_GUID": [
    2095730558,
    8274,
    18157,
    190,
    253,
    226,
    42,
    68,
    220,
    101,
    231
  ],
  "INTERFACE_VAR_GUID": [
    1852750893,
    30635,
    18127,
    178,
    167,
    204,
    150,
    139,
    14,
    138,
    243
  ],
  "RESET_VAR_HOB_GUID": [
    3215987010,
    12385,
    18596,
    146,
    47,
    157,
    36,
    110,
    32,
    17,
    32
  ],
  "EFI_TCG_TREE_LOG_HOB_GUID": [
    1897823588,
    4401,
    18763,
    162,
    209,
    132,
    128,
    108,
    215,
    45,
    83
  ],
  "TC_EFI_GLOBAL_VARIABLE_GUID": [
    324600551,
    38665,
    19265,
    143,
    210,
    64,
    105,
    218,
    240,
    84,
    106
  ],
  "CERT_TBL_GUID": [
    1719914764,
    53102,
    18708,
    181,
    180,
    171,
    142,
    215,
    55,
    14,
    215
  ],
  "AMI_MEASURE_CPU_MICROCODE_GUID": [
    1559431349,
    64035,
    16640,
    138,
    118,
    243,
    38,
    194,
    129,
    72,
    128
  ],
  "INFO_FUNC_GUID": [
    1839624424,
    15731,
    20146,
    167,
    33,
    162,
    221,
    246,
    130,
    253,
    216
  ],
  "READYTOBOOT_GUID": [
    2756856476,
    2910,
    18733,
    174,
    201,
    48,
    134,
    49,
    177,
    137,
    180
  ],
  "PPI_REQUEST_GUID": [
    816655235,
    44496,
    16715,
    177,
    28,
    249,
    60,
    193,
    208,
    183,
    155
  ],
  "AMI_TPM20_MEASURE_CONFIGURATION_INFO_GUID": [
    1192513378,
    46115,
    17700,
    172,
    106,
    144,
    16,
    107,
    170,
    137,
    251
  ],
  "PTT_SSDT_ACPI_TABLE_GUID": [
    3073622337,
    59535,
    18310,
    148,
    175,
    139,
    135,
    188,
    72,
    103,
    254
  ],
  "AMI_PPI_GUID": [
    464599399,
    35620,
    16667,
    152,
    40,
    24,
    210,
    133,
    169,
    204,
    77
  ],
  "AMI_TPM_ROLLBACK_SMM_PROTOCOL_GUID": [
    2046536985,
    63969,
    19720,
    183,
    188,
    53,
    132,
    83,
    25,
    94,
    65
  ],
  "TCG_NVRAM_HOB_GUID": [
    3236692221,
    49912,
    20039,
    144,
    239,
    156,
    129,
    85,
    40,
    91,
    236
  ],
  "EFI_TCG_MA_DRIVER_HOB_GUID": [
    3045747198,
    5694,
    19648,
    164,
    135,
    48,
    77,
    52,
    213,
    72,
    159
  ],
  "EFI_TCG_MA_DRIVER_GUID": [
    2461700693,
    10265,
    17529,
    134,
    122,
    28,
    88,
    240,
    114,
    197,
    178
  ],
  "TCG_LEG_X16_FILE_GUID": [
    337773794,
    51121,
    19193,
    167,
    41,
    146,
    55,
    88,
    217,
    109,
    3
  ],
  "TPM32_FILE_GUID": [
    178461638,
    13177,
    16872,
    130,
    90,
    83,
    248,
    44,
    192,
    242,
    84
  ],
  "MP_TPM_FILE_GUID": [
    2098281129,
    25216,
    18630,
    186,
    206,
    223,
    231,
    102,
    142,
    131,
    7
  ],
  "TCM_LEG_X16_FILE_GUID": [
    511000086,
    56559,
    18384,
    154,
    56,
    122,
    222,
    205,
    185,
    131,
    237
  ],
  "TCM32_FILE_GUID": [
    3075368814,
    15150,
    18495,
    148,
    88,
    195,
    120,
    254,
    10,
    198,
    159
  ],
  "MP_TCM_FILE_GUID": [
    1052373203,
    16592,
    17243,
    182,
    146,
    128,
    145,
    81,
    128,
    127,
    244
  ],
  "AMI_TCG_PKG_TOKEN_SPACE_GUID": [
    3952650506,
    17134,
    18998,
    141,
    204,
    175,
    167,
    34,
    201,
    202,
    179
  ],
  "HOB_GUID": [
    3751544454,
    11054,
    18905,
    148,
    244,
    164,
    28,
    71,
    171,
    150,
    51
  ],
  "PEI_POLICY_HOB_GUID": [
    239960157,
    29804,
    20156,
    135,
    149,
    49,
    162,
    134,
    204,
    166,
    32
  ],
  "TSE_INVALIDATE_BGRT_STATUS_PROTOCOL_GUID": [
    1938838353,
    60237,
    17975,
    168,
    59,
    209,
    191,
    108,
    28,
    72,
    235
  ],
  "ESA_INTERFACES_FOR_TSE_PROTOCOL_GUID": [
    289395482,
    48779,
    16779,
    176,
    52,
    126,
    175,
    229,
    198,
    12,
    153
  ],
  "TSE_SCREEN_MGMT_PROTOCOL_GUID": [
    3605752171,
    32451,
    19739,
    170,
    40,
    103,
    117,
    116,
    76,
    158,
    181
  ],
  "AMI_TSE_AFTER_FIRST_BOOT_OPTION_GUID": [
    3297600796,
    40206,
    19687,
    173,
    57,
    237,
    209,
    171,
    131,
    107,
    48
  ],
  "AMI_TSE_EVENT_BEFORE_BOOT_GUID": [
    913798927,
    61362,
    17330,
    184,
    174,
    179,
    2,
    233,
    96,
    72,
    130
  ],
  "AMI_TSE_BOOT_ORDER_CHANGE_GUID": [
    460048393,
    51590,
    18743,
    147,
    79,
    30,
    165,
    134,
    34,
    254,
    80
  ],
  "AMI_TSE_PASSWORD_PROMPT_ENTER_GUID": [
    121536001,
    9745,
    20101,
    184,
    150,
    163,
    182,
    118,
    124,
    186,
    0
  ],
  "AMI_TSE_PASSWORD_PROMPT_EXIT_GUID": [
    3115333808,
    58038,
    19115,
    148,
    53,
    65,
    101,
    236,
    254,
    208,
    50
  ],
  "AMI_TSE_USER_PASSWORD_VALID_GUID": [
    2870215882,
    18433,
    16904,
    152,
    191,
    48,
    213,
    33,
    218,
    212,
    211
  ],
  "AMI_TSE_ADMIN_PASSWORD_VALID_GUID": [
    1411209845,
    38382,
    17351,
    158,
    93,
    35,
    148,
    220,
    72,
    98,
    73
  ],
  "AMI_TSE_INVALID_PASSWORD_GUID": [
    3599909056,
    56640,
    20269,
    152,
    99,
    72,
    72,
    218,
    110,
    97,
    95
  ],
  "AMI_TSE_BEFORE_TIME_OUT_GUID": [
    482331062,
    32542,
    20126,
    128,
    31,
    251,
    206,
    77,
    146,
    167,
    109
  ],
  "AMI_TSE_AFTER_TIME_OUT_GUID": [
    3402894702,
    51313,
    17304,
    145,
    13,
    45,
    116,
    238,
    148,
    113,
    26
  ],
  "AMI_TSE_OEM_TSE_VAR_GUID": [
    4105355271,
    38049,
    19669,
    167,
    16,
    244,
    20,
    31,
    206,
    188,
    160
  ],
  "AMI_TSE_OEM_PORTING_VAR1_GUID": [
    3986862340,
    31248,
    17689,
    176,
    161,
    235,
    165,
    197,
    42,
    207,
    206
  ],
  "AMI_TSE_OEM_PORTING_VAR2_GUID": [
    4013959507,
    47129,
    19650,
    164,
    76,
    76,
    155,
    76,
    251,
    200,
    137
  ],
  "AMI_TSE_OEM_PORTING_VAR3_GUID": [
    493847870,
    6,
    16600,
    155,
    75,
    121,
    97,
    138,
    87,
    51,
    176
  ],
  "AMI_TSE_OEM_PORTING_VAR4_GUID": [
    1206419047,
    64448,
    19457,
    144,
    2,
    74,
    10,
    110,
    203,
    146,
    255
  ],
  "AMI_TSE_OEM_PORTING_VAR5_GUID": [
    664380499,
    64528,
    17204,
    158,
    102,
    211,
    214,
    239,
    9,
    208,
    238
  ],
  "AMI_TSE_OEM_PORTING_VAR6_GUID": [
    3615113185,
    20990,
    17939,
    168,
    29,
    130,
    174,
    36,
    70,
    76,
    253
  ],
  "AMI_TSE_OEM_PORTING_VAR7_GUID": [
    3050225687,
    29899,
    19984,
    186,
    195,
    146,
    74,
    76,
    198,
    41,
    200
  ],
  "AMI_TSE_OEM_PORTING_VAR8_GUID": [
    2024209207,
    36647,
    16548,
    156,
    78,
    159,
    201,
    228,
    56,
    213,
    226
  ],
  "AMI_TSE_OEM_PORTING_VAR9_GUID": [
    2376880533,
    16341,
    20018,
    156,
    42,
    26,
    101,
    189,
    105,
    153,
    50
  ],
  "AMI_TSE_OEM_PORTING_VAR10_GUID": [
    2799383416,
    53207,
    19453,
    161,
    196,
    39,
    9,
    254,
    197,
    47,
    139
  ],
  "AMI_TSE_OEM_PORTING_VAR11_GUID": [
    3932329074,
    55238,
    19470,
    136,
    32,
    43,
    129,
    28,
    126,
    227,
    175
  ],
  "AMI_TSE_OEM_PORTING_VAR12_GUID": [
    1289321319,
    4795,
    20421,
    139,
    42,
    88,
    10,
    219,
    106,
    99,
    104
  ],
  "AMI_TSE_OEM_PORTING_VAR13_GUID": [
    3225279815,
    56330,
    17177,
    159,
    236,
    68,
    176,
    120,
    194,
    66,
    230
  ],
  "AMI_TSE_OEM_PORTING_VAR14_GUID": [
    716096280,
    59467,
    19979,
    191,
    65,
    172,
    101,
    241,
    126,
    158,
    47
  ],
  "AMI_TSE_OEM_PORTING_VAR15_GUID": [
    426186363,
    41277,
    20037,
    128,
    27,
    166,
    5,
    209,
    25,
    70,
    213
  ],
  "AMI_TSE_OEM_PORTING_VAR16_GUID": [
    1181381265,
    20703,
    19264,
    162,
    235,
    206,
    230,
    125,
    84,
    40,
    201
  ],
  "AMI_TSE_OEM_PORTING_VAR17_GUID": [
    1178183425,
    29945,
    17973,
    177,
    38,
    159,
    240,
    72,
    214,
    176,
    208
  ],
  "AMI_TSE_OEM_PORTING_VAR18_GUID": [
    4009906844,
    41603,
    18637,
    141,
    8,
    106,
    30,
    156,
    60,
    3,
    211
  ],
  "AMI_TSE_OEM_PORTING_VAR19_GUID": [
    1288867678,
    19387,
    17922,
    172,
    184,
    116,
    27,
    170,
    126,
    179,
    19
  ],
  "AMI_TSE_OEM_PORTING_VAR20_GUID": [
    2210542571,
    53274,
    17880,
    159,
    161,
    175,
    64,
    32,
    111,
    204,
    155
  ],
  "AMI_TSE_OEM_PORTING_VAR21_GUID": [
    1634325750,
    1625,
    20405,
    176,
    60,
    54,
    69,
    216,
    200,
    13,
    200
  ],
  "AMI_TSE_OEM_PORTING_VAR22_GUID": [
    471772033,
    37417,
    17068,
    185,
    64,
    117,
    124,
    73,
    138,
    9,
    237
  ],
  "AMI_TSE_OEM_PORTING_VAR23_GUID": [
    248438064,
    26604,
    17776,
    158,
    251,
    48,
    141,
    229,
    62,
    233,
    61
  ],
  "AMI_TSE_OEM_PORTING_VAR24_GUID": [
    2436866616,
    31510,
    19314,
    165,
    240,
    129,
    94,
    125,
    44,
    140,
    31
  ],
  "AMI_TSE_OEM_PORTING_VAR25_GUID": [
    4261895492,
    55793,
    19873,
    174,
    106,
    130,
    80,
    85,
    60,
    222,
    102
  ],
  "AMI_TSE_OEM_PORTING_VAR26_GUID": [
    1193234756,
    24631,
    18770,
    139,
    1,
    207,
    245,
    134,
    253,
    230,
    179
  ],
  "AMI_TSE_OEM_PORTING_VAR27_GUID": [
    320405200,
    10085,
    17077,
    128,
    62,
    50,
    21,
    163,
    192,
    147,
    197
  ],
  "AMI_TSE_OEM_PORTING_VAR28_GUID": [
    4284091843,
    57260,
    17226,
    179,
    223,
    255,
    212,
    193,
    234,
    126,
    65
  ],
  "AMI_TSE_OEM_PORTING_VAR29_GUID": [
    1066255155,
    52437,
    20056,
    184,
    207,
    123,
    154,
    143,
    49,
    234,
    150
  ],
  "AMI_TSE_OEM_PORTING_GUID1": [
    3976022990,
    17017,
    16632,
    186,
    242,
    220,
    183,
    150,
    56,
    212,
    30
  ],
  "AMI_TSE_OEM_PORTING_GUID2": [
    603364560,
    65350,
    19894,
    185,
    130,
    99,
    237,
    241,
    169,
    1,
    255
  ],
  "TSE_SWITCHING_TO_POST_SCREEN_GUID": [
    3033731558,
    29213,
    16465,
    149,
    109,
    36,
    16,
    193,
    215,
    137,
    170
  ],
  "TSE_AFTER_POST_INV_PWD_PROMPT_GUID": [
    4261134251,
    48225,
    18785,
    185,
    23,
    119,
    68,
    86,
    65,
    80,
    123
  ],
  "SETUP_COMPLETE_REDRAW_GUID": [
    315284784,
    24583,
    19587,
    137,
    215,
    255,
    35,
    127,
    123,
    148,
    122
  ],
  "AMI_TSE_PKG_TOKEN_SPACE_GUID": [
    2370095298,
    32997,
    18919,
    188,
    18,
    174,
    8,
    158,
    72,
    250,
    66
  ],
  "EVALUATE_DEFAULTS4_FIRST_BOOT_GUID": [
    1263350206,
    35014,
    17514,
    164,
    169,
    74,
    208,
    246,
    18,
    179,
    46
  ],
  "PLATFORM_RECOVERY_ORDER_GUID": [
    1939429980,
    49835,
    18636,
    164,
    4,
    227,
    155,
    56,
    80,
    92,
    86
  ],
  "PC_PASSWORD_GUID": [
    1047593057,
    25722,
    19459,
    190,
    133,
    250,
    214,
    204,
    250,
    90,
    24
  ],
  "EFI_SEC_REV_GUID": [
    4110878640,
    32160,
    18477,
    180,
    88,
    210,
    58,
    114,
    147,
    153,
    89
  ],
  "EFI_CP_PC_PLAT_TOKEN_SPACE_GUID": [
    2187058794,
    59876,
    19656,
    156,
    45,
    9,
    178,
    156,
    59,
    212,
    38
  ],
  "OA2_MAGIC_NUMBER_GUID": [
    1093152498,
    39770,
    20151,
    149,
    216,
    217,
    205,
    123,
    220,
    227,
    103
  ],
  "OA2_OEM_PUBLIC_KEY_VARIABLE_GUID": [
    172843565,
    500,
    18804,
    179,
    245,
    43,
    254,
    152,
    136,
    239,
    146
  ],
  "OA2_MARKER_VARIABLE_GUID": [
    3962203176,
    8838,
    17645,
    145,
    107,
    36,
    58,
    181,
    37,
    53,
    70
  ],
  "OA2_ENCRYPTED_OEM_PUBLIC_KEY_VARIBLE_GUID": [
    1838937873,
    43277,
    17145,
    163,
    251,
    221,
    8,
    182,
    232,
    144,
    55
  ],
  "EFI_DRIVER_HEALTH_MANAGER_FORM_SET_GUID": [
    1117182452,
    63228,
    19934,
    134,
    133,
    140,
    226,
    215,
    157,
    144,
    240
  ],
  "CP_PC_HOTKEY_DATA_GUID": [
    1411947568,
    19796,
    19364,
    141,
    6,
    28,
    107,
    155,
    45,
    194,
    61
  ],
  "BOOT_ORDER_DATA_GUID": [
    3534770044,
    27035,
    20378,
    145,
    243,
    4,
    7,
    139,
    149,
    99,
    203
  ],
  "BACKUP_BIOS_UPDATE_GUID": [
    4225520393,
    49045,
    17589,
    168,
    174,
    224,
    89,
    62,
    5,
    34,
    191
  ],
  "BIOS_IDENTIFIED_INFO_GUID": [
    1325259081,
    59505,
    18977,
    150,
    182,
    177,
    97,
    178,
    113,
    185,
    191
  ],
  "CP_PC_BIOS_ID_FILE_GUID": [
    925862993,
    50235,
    18218,
    130,
    175,
    84,
    181,
    195,
    35,
    77,
    127
  ],
  "BIOS_CAPSULE_GUID": [
    3662359929,
    65249,
    17094,
    155,
    86,
    146,
    54,
    51,
    57,
    138,
    235
  ],
  "ME_CAPSULE_GUID": [
    2582599988,
    30754,
    18884,
    131,
    164,
    80,
    193,
    175,
    188,
    190,
    0
  ],
  "FD_CAPSULE_GUID": [
    520459069,
    65326,
    16950,
    190,
    146,
    86,
    104,
    45,
    62,
    143,
    180
  ],
  "PDR_CAPSULE_GUID": [
    1770701362,
    10406,
    16620,
    148,
    170,
    125,
    48,
    45,
    191,
    86,
    103
  ],
  "PLATFORM_VARIABLE_HOB_GUID": [
    1910953148,
    18487,
    17905,
    162,
    215,
    63,
    147,
    8,
    177,
    126,
    215
  ],
  "DEFAULT_DATA_FILE_GUID": [
    451160182,
    143,
    16737,
    178,
    183,
    28,
    13,
    21,
    197,
    239,
    67
  ],
  "SMM_SPI_INITILIZED_GUID": [
    901988146,
    35937,
    17709,
    141,
    20,
    155,
    95,
    83,
    162,
    223,
    192
  ],
  "EFI_TPM_CALL_BACK_PROTOCOL_GUID": [
    416742526,
    55394,
    18654,
    181,
    109,
    250,
    49,
    20,
    33,
    191,
    41
  ],
  "PEI_IPMI_TRANSPORT_PPI_GUID": [
    2079719116,
    50613,
    19237,
    129,
    27,
    180,
    181,
    11,
    40,
    121,
    247
  ],
  "UBA_CONFIG_DATABASE_PPI_GUID": [
    3239536435,
    5535,
    17109,
    188,
    185,
    50,
    6,
    96,
    177,
    115,
    16
  ],
  "EFI_BMC_ACPI_SW_CHILD_POLICY_PROTOCOL_GUID": [
    2307144715,
    22273,
    20470,
    164,
    115,
    101,
    117,
    153,
    4,
    247,
    53
  ],
  "SMM_GENERIC_ELOG_PROTOCOL_GUID": [
    1716449782,
    6591,
    17560,
    171,
    106,
    252,
    5,
    114,
    251,
    152,
    81
  ],
  "SMM_REDIR_ELOG_PROTOCOL_GUID": [
    2041327004,
    37398,
    17349,
    160,
    116,
    11,
    69,
    199,
    100,
    34,
    193
  ],
  "EFI_IPMI_SOL_STATUS_PROTOCOL_GUID": [
    3885008014,
    46763,
    17579,
    132,
    145,
    220,
    165,
    12,
    57,
    7,
    198
  ],
  "EFI_BMC_LAN_PROTOCOL_GUID": [
    2560447816,
    44096,
    17907,
    173,
    245,
    208,
    95,
    148,
    168,
    145,
    174
  ],
  "EFI_GENERIC_FRU_PROTOCOL_GUID": [
    3371089678,
    3600,
    18423,
    129,
    189,
    57,
    219,
    117,
    202,
    147,
    159
  ],
  "EFI_SM_BMC_VARIABLE_GUID": [
    1532124969,
    33405,
    19619,
    190,
    181,
    137,
    84,
    181,
    108,
    5,
    115
  ],
  "EFI_IPMI_TRANSPORT_PROTOCOL_GUID": [
    1807304168,
    14147,
    17214,
    185,
    14,
    41,
    179,
    13,
    93,
    198,
    48
  ],
  "SMM_IPMI_TRANSPORT_PROTOCOL_GUID": [
    2343596273,
    43251,
    18205,
    134,
    22,
    119,
    75,
    163,
    244,
    48,
    160
  ],
  "EFI_OS_WDT_POLICY_PROTOCOL_GUID": [
    175628425,
    5520,
    17474,
    187,
    234,
    17,
    94,
    25,
    230,
    53,
    138
  ],
  "EFI_FRB_CODE_PROTOCOL_GUID": [
    3160376860,
    34541,
    16766,
    187,
    123,
    108,
    2,
    107,
    205,
    117,
    91
  ],
  "UBA_CONFIG_DATABASE_PROTOCOL_GUID": [
    3762163014,
    21091,
    18501,
    176,
    164,
    88,
    213,
    123,
    49,
    119,
    226
  ],
  "LEGACY_BRIDGE_PROTOCOL_GUID": [
    1448372597,
    50256,
    17586,
    157,
    37,
    206,
    131,
    197,
    130,
    1,
    97
  ],
  "UEFI_BOOT_MARKER_PROTOCOL_GUID": [
    3194703718,
    23433,
    19906,
    145,
    2,
    161,
    120,
    200,
    98,
    28,
    242
  ],
  "UEFI_LEGACY_BOOT_MARKER_GUID": [
    245697579,
    19469,
    19619,
    151,
    193,
    0,
    20,
    219,
    117,
    68,
    115
  ],
  "UEFI_WINDOWS_INT10_WORKAROUND": [
    580198238,
    20347,
    16475,
    138,
    218,
    236,
    220,
    67,
    28,
    97,
    111
  ],
  "FVB_INITILIZED_GUID": [
    4195306319,
    55023,
    16615,
    188,
    27,
    41,
    36,
    92,
    160,
    59,
    194
  ],
  "EFI_WHEA_SUPPORT_PROTOCOL_GUID": [
    4007687172,
    9966,
    17353,
    144,
    113,
    78,
    72,
    0,
    140,
    70,
    145
  ],
  "EFI_WHEA_PLATFORM_SUPPORT_PROTOCOL_GUID": [
    1812579769,
    48959,
    18130,
    145,
    152,
    74,
    6,
    72,
    38,
    244,
    20
  ],
  "EFI_IS_PLATFORM_SUPPORT_WHEA_PROTOCOL_GUID": [
    1908719957,
    54603,
    19801,
    162,
    193,
    249,
    165,
    114,
    60,
    101,
    168
  ],
  "EFI_WHEA_BOOT_PROTOCOL_GUID": [
    1241671422,
    65111,
    18232,
    128,
    171,
    20,
    110,
    70,
    240,
    58,
    101
  ],
  "CP_PLAT_IPMI_TOKEN_SPACE_GUID": [
    3507564223,
    3458,
    16497,
    150,
    124,
    225,
    105,
    35,
    39,
    64,
    186
  ],
  "EFI_WHEA_PROCESSOR_GENERIC_ERROR_SECTION_GUID": [
    2557922477,
    18356,
    19419,
    182,
    94,
    22,
    241,
    147,
    196,
    243,
    219
  ],
  "EFI_WHEA_PROCESSOR_SPECIFIC_ERROR_SECTION_GUID": [
    3695091888,
    41284,
    18327,
    181,
    91,
    83,
    250,
    36,
    43,
    110,
    29
  ],
  "EFI_WHEA_PLATFORM_MEMORY_ERROR_SECTION_GUID": [
    2780565780,
    28516,
    20190,
    184,
    99,
    62,
    131,
    237,
    124,
    131,
    177
  ],
  "EFI_WHEA_PCIE_ERROR_SECTION_GUID": [
    3650480468,
    48065,
    17167,
    173,
    145,
    180,
    77,
    203,
    60,
    111,
    53
  ],
  "EFI_WHEA_PCI_DEV_ERROR_SECTION_GUID": [
    3948824197,
    51814,
    18281,
    182,
    162,
    38,
    6,
    139,
    0,
    19,
    38
  ],
  "EFI_WHEA_PLATFORM_NON_STANDARD_ERROR_SECTION_GUID": [
    463263844,
    55932,
    18494,
    141,
    105,
    211,
    92,
    180,
    173,
    39,
    201
  ],
  "EFI_WHEA_ELOG_FV_GUID": [
    3600928112,
    19251,
    18836,
    166,
    234,
    55,
    95,
    44,
    204,
    84,
    55
  ],
  "OUT_OF_BAND_GUID": [
    3133629830,
    13589,
    16907,
    161,
    183,
    35,
    90,
    113,
    110,
    202,
    173
  ],
  "EFI_CP_RC_PKG_TOKEN_SPACE_GUID": [
    4242353916,
    27816,
    19723,
    157,
    0,
    111,
    156,
    250,
    87,
    143,
    152
  ],
  "USRA_PROTOCOL_GUID": [
    4249356918,
    45364,
    20215,
    173,
    254,
    176,
    224,
    84,
    99,
    152,
    7
  ],
  "USRA_PPI_GUID": [
    2423679641,
    40101,
    17630,
    148,
    218,
    220,
    193,
    210,
    214,
    218,
    31
  ],
  "MRC_OEM_HOOKS_PPI_GUID": [
    1507850050,
    30808,
    17072,
    141,
    91,
    18,
    194,
    173,
    0,
    61,
    108
  ],
  "MRC_HOOKS_SERVICES_PPI_GUID": [
    4274283328,
    51865,
    18942,
    188,
    202,
    208,
    159,
    166,
    6,
    74,
    74
  ],
  "MRC_HOOKS_CHIP_SERVICES_PPI_GUID": [
    447703707,
    51995,
    18078,
    148,
    32,
    13,
    57,
    18,
    184,
    227,
    118
  ],
  "EFI_CPU_TOKEN_SPACE_GUID": [
    718963565,
    2621,
    17366,
    162,
    90,
    56,
    69,
    202,
    210,
    212,
    0
  ],
  "SMM_CPU_SYNC_PROTOCOL_GUID": [
    3583314309,
    35811,
    19228,
    182,
    63,
    149,
    209,
    90,
    179,
    182,
    95
  ],
  "SMM_CPU_SYNC2_PROTOCOL_GUID": [
    2646027810,
    37474,
    18968,
    143,
    224,
    133,
    224,
    61,
    250,
    150,
    115
  ],
  "INTEL_CPU_PCDS_SET_DONE_PROTOCOL_GUID": [
    2914499046,
    28855,
    18644,
    182,
    165,
    24,
    250,
    21,
    235,
    205,
    120
  ],
  "INTEL_10G_LAN_POLICY_PROTOCOL_GUID": [
    735542551,
    14193,
    18804,
    134,
    68,
    249,
    156,
    245,
    178,
    102,
    168
  ],
  "INTEL_GIGABIT_LAN_POLICY_PROTOCOL_GUID": [
    735542551,
    14193,
    18804,
    134,
    68,
    249,
    156,
    245,
    178,
    102,
    167
  ],
  "EFI_SETUP_VARIABLE_DEFAULT_GUID": [
    2367975729,
    14430,
    18719,
    186,
    104,
    141,
    233,
    85,
    48,
    179,
    166
  ],
  "EFI_MFG_UUID_HOB_GUID": [
    580855439,
    9136,
    17462,
    131,
    227,
    139,
    122,
    224,
    138,
    107,
    216
  ],
  "EFI_GLOBAL_VARIABLE_CONTROL_GUID": [
    2578016274,
    18224,
    17040,
    139,
    254,
    123,
    78,
    81,
    79,
    249,
    59
  ],
  "EFI_ADMIN_PASSWORD_HOB_GUID": [
    1310143239,
    37595,
    19023,
    154,
    142,
    134,
    168,
    86,
    73,
    180,
    5
  ],
  "MAIN_PKG_LIST_GUID": [
    1644544932,
    4425,
    18714,
    166,
    214,
    30,
    114,
    59,
    135,
    131,
    177
  ],
  "ADVANCED_PKG_LIST_GUID": [
    3231482315,
    12777,
    19942,
    169,
    249,
    23,
    161,
    68,
    53,
    66,
    69
  ],
  "TPM_PKG_LIST_GUID": [
    2107923113,
    28095,
    20251,
    164,
    62,
    50,
    135,
    203,
    229,
    19,
    81
  ],
  "SECURITY_PKG_LIST_GUID": [
    982014638,
    15920,
    17081,
    169,
    118,
    47,
    31,
    19,
    189,
    112,
    21
  ],
  "BOOT_OPTIONS_PKG_LIST_GUID": [
    1645838064,
    31614,
    4578,
    185,
    42,
    8,
    0,
    32,
    12,
    154,
    102
  ],
  "BIOS_GUARD_MODULE_GUID": [
    2033456493,
    53198,
    17934,
    146,
    245,
    160,
    121,
    9,
    165,
    158,
    202
  ],
  "BIOS_GUARD_HOB_GUID": [
    1727054893,
    3342,
    19491,
    147,
    192,
    45,
    82,
    149,
    220,
    94,
    33
  ],
  "EFI_OC_DATA_GUID": [
    1257842073,
    36470,
    19380,
    191,
    210,
    245,
    166,
    110,
    48,
    65,
    212
  ],
  "SMM_TXT_CONFIG_LOCK_GUID": [
    3263359235,
    9445,
    17432,
    169,
    120,
    167,
    65,
    146,
    73,
    201,
    176
  ],
  "SMBUS2_HOST_CONTROLLER": [
    4231900652,
    7740,
    18860,
    156,
    200,
    60,
    53,
    151,
    168,
    200,
    95
  ],
  "EFI_SERVER_CAPSULE_GUID": [
    3556823524,
    41748,
    17451,
    137,
    237,
    169,
    46,
    76,
    129,
    151,
    203
  ],
  "IIO_VVAR_GUID": [
    3435995222,
    54273,
    19951,
    133,
    176,
    31,
    161,
    31,
    243,
    181,
    227
  ],
  "EFI_DPR_REGS_PROGRAMMED_GUID": [
    1266958849,
    28649,
    16849,
    180,
    111,
    223,
    252,
    52,
    228,
    146,
    162
  ],
  "PCH_EVA_INT15_HANDLER_FILE_GUID": [
    2729467013,
    36187,
    20467,
    183,
    209,
    143,
    190,
    146,
    180,
    170,
    50
  ],
  "EFI_ACPI_PARAMETER_GUID": [
    3486762139,
    22236,
    18012,
    179,
    160,
    65,
    154,
    139,
    66,
    203,
    96
  ],
  "PLATFORM_INFO_HOB_GUID": [
    1422269588,
    10365,
    19909,
    153,
    213,
    211,
    141,
    26,
    83,
    174,
    107
  ],
  "ATTEMPT_USB_FIRST_HOTKEY_INFO_HOB_GUID": [
    951640596,
    5224,
    19383,
    149,
    177,
    116,
    89,
    30,
    76,
    110,
    29
  ],
  "TCO_WDT_HOB_GUID": [
    1044403224,
    3468,
    20250,
    176,
    85,
    190,
    249,
    8,
    65,
    70,
    141
  ],
  "EFI_SIMPLE_BOOT_FLAG_VARIABLE_GUID": [
    2347032417,
    37834,
    4562,
    170,
    13,
    0,
    224,
    152,
    3,
    43,
    140
  ],
  "FAST_BOOT_EXCEPTION_INFO_HOB_GUID": [
    1322812022,
    54495,
    19715,
    134,
    97,
    41,
    88,
    1,
    178,
    218,
    88
  ],
  "FAST_BOOT_FUNCTION_ENABLED_HOB_GUID": [
    27242954,
    54289,
    18760,
    183,
    60,
    76,
    5,
    74,
    186,
    158,
    142
  ],
  "DRAM_SHARED_MAIL_BOX_GUID": [
    2644091796,
    6264,
    19756,
    152,
    233,
    193,
    107,
    142,
    196,
    121,
    51
  ],
  "BIOS_KNOBS_DATA_BIN_GUID": [
    1633574945,
    24637,
    16676,
    183,
    234,
    196,
    138,
    55,
    55,
    186,
    205
  ],
  "EFI_TRACE_HUB_DEBUG_LIB_IA32_GUID": [
    597944250,
    30161,
    19641,
    156,
    143,
    86,
    250,
    78,
    72,
    217,
    158
  ],
  "EFI_TRACE_HUB_DEBUG_LIB_X64_GUID": [
    2407406138,
    38487,
    17648,
    185,
    230,
    78,
    247,
    75,
    34,
    213,
    67
  ],
  "CP_PLAT_FLASH_TOKEN_SPACE_GUID": [
    3385038436,
    38621,
    19548,
    175,
    215,
    205,
    101,
    118,
    41,
    207,
    176
  ],
  "EFI_PCH_RC_VARIABLE_GUID": [
    3516540579,
    6129,
    18627,
    138,
    30,
    17,
    235,
    10,
    127,
    110,
    78
  ],
  "IFWI_ID_GUID": [
    2415560955,
    17301,
    63156,
    5,
    37,
    147,
    255,
    39,
    122,
    98,
    21
  ],
  "FPGA_CAPSULE_GUID": [
    1960704001,
    42972,
    17424,
    157,
    248,
    192,
    142,
    109,
    159,
    214,
    187
  ],
  "OEM_SKU_TOKEN_SPACE_GUID": [
    2654458451,
    44024,
    18821,
    142,
    35,
    186,
    202,
    16,
    57,
    86,
    19
  ],
  "PLATFORM_KTI_EPARAM_UPDATE_DATA_GUID": [
    2076206543,
    45032,
    17302,
    174,
    159,
    186,
    39,
    223,
    190,
    207,
    61
  ],
  "RESERVE_MEM_FLAG_VARIABLE_GUID": [
    3095045951,
    56499,
    17715,
    131,
    152,
    108,
    18,
    132,
    39,
    40,
    64
  ],
  "EFI_AFTER_PLATFORM_LOCKS_EVENT_GUID": [
    476044018,
    40883,
    17179,
    142,
    205,
    183,
    211,
    92,
    190,
    250,
    233
  ],
  "OPA_PLAT_CFG_NV_VAR_GUID": [
    1456618803,
    2007,
    18681,
    129,
    214,
    126,
    213,
    153,
    30,
    206,
    136
  ],
  "EFI_OPA_SOCKET_MAP_HOB_GUID": [
    2191344082,
    27813,
    18523,
    161,
    162,
    209,
    183,
    150,
    39,
    171,
    205
  ],
  "EFI_RSA_TPM_CLEAR_OWNERSHIP_GUID": [
    2149276747,
    27362,
    16485,
    159,
    114,
    130,
    202,
    118,
    12,
    46,
    202
  ],
  "PLATFORM_CONFIG_CHANGE_GUID": [
    3821719394,
    12386,
    19997,
    151,
    142,
    70,
    128,
    122,
    185,
    116,
    125
  ],
  "PEI_LEGACY_REGION_PPI_GUID": [
    531525804,
    33283,
    18672,
    185,
    239,
    232,
    115,
    255,
    236,
    193,
    242
  ],
  "EFI_PEI_BOOT_IN_NON_S3_MODE_PPI_GUID": [
    1719595140,
    29935,
    18183,
    144,
    179,
    117,
    20,
    89,
    32,
    179,
    156
  ],
  "EFI_PEI_SYSTEM_BOARD_PPI_GUID": [
    3369623180,
    56348,
    20364,
    173,
    167,
    88,
    193,
    209,
    7,
    163,
    4
  ],
  "SI_PLATFORM_POLICY_PPI_GUID": [
    2931816961,
    32476,
    18943,
    141,
    136,
    203,
    132,
    140,
    94,
    134,
    112
  ],
  "EFI_NORTH_PEAK_STATUS_CODE_HANDLE_PPI": [
    2284608852,
    7597,
    20298,
    131,
    22,
    75,
    223,
    132,
    30,
    9,
    208
  ],
  "EFI_SILICON_RC_HOBS_READY_PPI": [
    3975236021,
    48974,
    19144,
    138,
    140,
    206,
    135,
    203,
    172,
    147,
    211
  ],
  "EFI_PLATFORM_POLICY_PROTOCOL_GUID": [
    695666255,
    43926,
    20393,
    133,
    69,
    249,
    196,
    2,
    81,
    224,
    127
  ],
  "EFI_PLATFORM_TYPE_PROTOCOL_GUID": [
    387879832,
    9884,
    16513,
    144,
    153,
    56,
    68,
    226,
    96,
    70,
    108
  ],
  "EFI_DMA_REMAP_PROTOCOL_GUID": [
    1317484403,
    33681,
    20039,
    183,
    244,
    202,
    251,
    220,
    196,
    178,
    4
  ],
  "EFI_PCI_IOV_PLATFORM_PROTOCOL_GUID": [
    4087657604,
    39718,
    20202,
    144,
    229,
    162,
    6,
    84,
    12,
    165,
    37
  ],
  "EFI_MPST_SUPPORT_PROTOCOL_GUID": [
    1463020456,
    18733,
    18170,
    170,
    106,
    55,
    151,
    121,
    225,
    11,
    119
  ],
  "EFI_RASF_SUPPORT_PROTOCOL_GUID": [
    1520870813,
    22404,
    16907,
    166,
    229,
    216,
    246,
    65,
    189,
    151,
    50
  ],
  "EFI_WINDOWS_INT10_WORKAROUND": [
    59241813,
    8360,
    20418,
    187,
    148,
    205,
    48,
    218,
    27,
    64,
    8
  ],
  "EFI_LEGACY_BOOT_MARKER_GUID": [
    1927314856,
    25513,
    17108,
    131,
    213,
    11,
    181,
    24,
    56,
    68,
    117
  ],
  "AMI_TSE_SETUP_ENTER_PROTOCOL_GUID": [
    1897934574,
    24403,
    16601,
    171,
    61,
    158,
    12,
    38,
    217,
    102,
    87
  ],
  "XML_CLI_PROTOCOL_GUID": [
    3823410061,
    6535,
    18640,
    154,
    1,
    237,
    161,
    121,
    202,
    11,
    214
  ],
  "EFI_PLATFORM_ERROR_HANDLING_PROTOCOL_GUID": [
    1746971604,
    41618,
    18455,
    145,
    71,
    217,
    29,
    200,
    197,
    53,
    66
  ],
  "SMM_BIOS_GUARD_PROTOCOL_GUID": [
    391533329,
    19313,
    17216,
    136,
    170,
    220,
    159,
    68,
    34,
    229,
    58
  ],
  "EFI_DXE_SYSTEM_BOARD_PROTOCOL_GUID": [
    2776371480,
    27388,
    18130,
    186,
    230,
    146,
    146,
    98,
    211,
    235,
    30
  ],
  "EFI_SV_SMM_PROTOCOL_GUID": [
    4047093111,
    32759,
    18902,
    144,
    134,
    213,
    10,
    178,
    111,
    109,
    215
  ],
  "EFI_VMD_DRIVER_PROTOCOL_GUID": [
    1516727017,
    56099,
    19048,
    162,
    77,
    170,
    95,
    236,
    213,
    116,
    134
  ],
  "EFI_HFI_PCIE_GEN3_PROTOCOL_GUID": [
    2069442926,
    59871,
    17247,
    152,
    205,
    87,
    38,
    100,
    91,
    232,
    99
  ],
  "EFI_USB_LEGACY_STACK": [
    718806553,
    11931,
    17578,
    180,
    172,
    158,
    33,
    101,
    50,
    46,
    28
  ],
  "RAS_CLV_PCIE_ERR_HAND_PROTOCOL": [
    2998882784,
    25923,
    19147,
    176,
    158,
    253,
    130,
    110,
    26,
    244,
    192
  ],
  "TXT_DXE_PROTOCOL_GUID": [
    2723949964,
    12178,
    17958,
    141,
    99,
    132,
    59,
    169,
    67,
    150,
    48
  ],
  "EFI_BMC_SMBIOS_PROTOCOL_GUID": [
    3825598102,
    23126,
    16570,
    188,
    36,
    97,
    156,
    137,
    226,
    210,
    238
  ],
  "EFI_RSA_BMC_COMMANDS_PROTOCOL_GUID": [
    50445896,
    32037,
    17468,
    170,
    119,
    213,
    231,
    83,
    219,
    65,
    106
  ],
  "PLATFORM_CONFIG_CHANGE_PROTOCOL_GUID": [
    4096376842,
    38464,
    18099,
    149,
    68,
    248,
    248,
    106,
    40,
    243,
    15
  ],
  "HSTI_PROTOCOL_GUID": [
    453369409,
    51515,
    19380,
    173,
    71,
    42,
    120,
    172,
    15,
    201,
    228
  ],
  "HSTI_PUBLISH_COMPLETE_PROTOCOL_GUID": [
    256904166,
    60644,
    20184,
    144,
    129,
    154,
    169,
    165,
    35,
    251,
    123
  ],
  "DXE_SI_POLICY_PROTOCOL_GUID": [
    3970069782,
    12396,
    20008,
    140,
    148,
    78,
    82,
    16,
    150,
    105,
    94
  ],
  "CLV_BOOT_TIME_TEST_EXECUTION": [
    1073205586,
    61318,
    18371,
    151,
    176,
    206,
    217,
    187,
    128,
    154,
    103
  ],
  "EFI_PEI_PLATFORM_TYPE_WOLF_PASS_PPI_GUID": [
    3534299137,
    8877,
    17337,
    190,
    188,
    27,
    21,
    33,
    0,
    216,
    204
  ],
  "EFI_PEI_PLATFORM_TYPE_NEON_CITY_EPRP_PPI_GUID": [
    2732941470,
    35885,
    17126,
    162,
    252,
    18,
    188,
    116,
    189,
    67,
    127
  ],
  "EFI_PEI_PLATFORM_TYPE_BUCHANAN_PASS_PPI_GUID": [
    4156062329,
    42560,
    19109,
    140,
    30,
    69,
    63,
    178,
    110,
    243,
    118
  ],
  "EFI_PEI_PLATFORM_TYPE_NEON_CITY_EPECB_PPI_GUID": [
    562527791,
    63598,
    20106,
    156,
    155,
    215,
    177,
    82,
    221,
    64,
    216
  ],
  "EFI_PEI_PLATFORM_TYPE_OPAL_CITY_STHI_PPI_GUID": [
    2692430815,
    46986,
    16878,
    162,
    118,
    85,
    194,
    37,
    160,
    123,
    11
  ],
  "EFI_PEI_PLATFORM_TYPE_PURLEY_LBGEPDVP_PPI_GUID": [
    1008944240,
    27091,
    17121,
    179,
    35,
    200,
    9,
    48,
    15,
    57,
    37
  ],
  "EFI_PEI_PLATFORM_TYPE_CRESCENT_CITY_PPI_GUID": [
    1255743727,
    19823,
    18709,
    152,
    42,
    220,
    22,
    103,
    113,
    49,
    213
  ],
  "EFI_PEI_PLATFORM_TYPE_HEDT_EV_PPI_GUID": [
    1098391375,
    41933,
    18256,
    138,
    44,
    33,
    146,
    180,
    223,
    229,
    43
  ],
  "EFI_PEI_PLATFORM_TYPE_HEDT_CRB_PPI_GUID": [
    2612454042,
    8818,
    17002,
    171,
    119,
    155,
    127,
    229,
    239,
    234,
    132
  ],
  "EFI_PEI_PLATFORM_TYPE_LIGHTNING_RIDGE_EXRP_PPI_GUID": [
    2938378228,
    31614,
    19502,
    148,
    187,
    122,
    51,
    137,
    161,
    87,
    202
  ],
  "EFI_PEI_PLATFORM_TYPE_LIGHTNING_RIDGE_EXEC_B1_PPI_GUID": [
    4144644374,
    65014,
    17915,
    147,
    205,
    132,
    205,
    221,
    115,
    223,
    212
  ],
  "EFI_PEI_PLATFORM_TYPE_LIGHTNING_RIDGE_EXEC_B2_PPI_GUID": [
    201634047,
    8829,
    18330,
    147,
    90,
    246,
    229,
    168,
    181,
    25,
    140
  ],
  "EFI_PEI_PLATFORM_TYPE_LIGHTNING_RIDGE_EXEC_B3_PPI_GUID": [
    2495619131,
    21705,
    16750,
    166,
    224,
    71,
    232,
    212,
    120,
    105,
    1
  ],
  "EFI_PEI_PLATFORM_TYPE_LIGHTNING_RIDGE_EXEC_B4_PPI_GUID": [
    1115988252,
    6337,
    19472,
    178,
    217,
    88,
    106,
    1,
    96,
    165,
    35
  ],
  "EFI_PEI_PLATFORM_TYPE_LIGHTNING_RIDGE_E_X8_S1_N_PPI_GUID": [
    1330758211,
    31982,
    16708,
    142,
    237,
    35,
    74,
    194,
    218,
    189,
    83
  ],
  "EFI_PEI_PLATFORM_TYPE_LIGHTNING_RIDGE_E_X8_S2_N_PPI_GUID": [
    1570051795,
    48201,
    17207,
    159,
    199,
    41,
    223,
    53,
    38,
    236,
    135
  ],
  "EFI_PEI_PLATFORM_TYPE_KYANITE_PPI_GUID": [
    2990334657,
    5792,
    20329,
    152,
    10,
    149,
    199,
    114,
    22,
    249,
    162
  ],
  "EFI_PEI_PLATFORM_TYPE_NEON_CITY_FPGA_PPI_GUID": [
    1223136957,
    20179,
    18261,
    168,
    202,
    76,
    244,
    55,
    37,
    130,
    65
  ],
  "EFI_PEI_PLATFORM_TYPE_OPAL_CITY_FPGA_PPI_GUID": [
    3846392614,
    44767,
    17374,
    137,
    53,
    209,
    196,
    133,
    169,
    18,
    185
  ],
  "EFI_PLATFORM_TYPE_WOLF_PASS_PROTOCOL_GUID": [
    1292500386,
    44572,
    19783,
    156,
    209,
    107,
    84,
    138,
    21,
    202,
    202
  ],
  "EFI_PLATFORM_TYPE_NEON_CITY_EPRP_PROTOCOL_GUID": [
    3234671926,
    43035,
    17677,
    165,
    2,
    55,
    103,
    223,
    162,
    152,
    38
  ],
  "EFI_PLATFORM_TYPE_BUCHANAN_PASS_PROTOCOL_GUID": [
    857465511,
    48528,
    19073,
    161,
    40,
    54,
    176,
    178,
    5,
    121,
    151
  ],
  "EFI_PLATFORM_TYPE_NEON_CITY_EPECB_PROTOCOL_GUID": [
    3192137121,
    6363,
    18415,
    146,
    115,
    39,
    62,
    149,
    0,
    112,
    20
  ],
  "EFI_PLATFORM_TYPE_PURLEY_LBGEPDVP_PROTOCOL_GUID": [
    1531018096,
    32607,
    18799,
    168,
    3,
    138,
    10,
    44,
    172,
    52,
    227
  ],
  "EFI_PLATFORM_TYPE_OPAL_CITY_STHI_PROTOCOL_GUID": [
    2964499330,
    11931,
    20361,
    163,
    216,
    245,
    169,
    153,
    104,
    149,
    12
  ],
  "EFI_PLATFORM_TYPE_CRESCENT_CITY_PROTOCOL_GUID": [
    1531156805,
    17203,
    16799,
    141,
    136,
    132,
    198,
    149,
    98,
    226,
    246
  ],
  "EFI_PLATFORM_TYPE_HEDT_EV_PROTOCOL_GUID": [
    2892296388,
    9665,
    18376,
    172,
    116,
    177,
    82,
    116,
    86,
    53,
    29
  ],
  "EFI_PLATFORM_TYPE_HEDT_CRB_PROTOCOL_GUID": [
    746737543,
    3884,
    17879,
    129,
    166,
    79,
    57,
    224,
    66,
    189,
    223
  ],
  "EFI_PLATFORM_TYPE_LIGHTNING_RIDGE_EXRP_PROTOCOL_GUID": [
    457892088,
    60703,
    20433,
    155,
    24,
    176,
    130,
    41,
    15,
    134,
    245
  ],
  "EFI_PLATFORM_TYPE_LIGHTNING_RIDGE_EXEC_B1_PROTOCOL_GUID": [
    2194928232,
    30074,
    17613,
    168,
    125,
    19,
    253,
    169,
    114,
    185,
    153
  ],
  "EFI_PLATFORM_TYPE_LIGHTNING_RIDGE_EXEC_B2_PROTOCOL_GUID": [
    4026681439,
    45238,
    19514,
    158,
    123,
    84,
    250,
    189,
    131,
    7,
    77
  ],
  "EFI_PLATFORM_TYPE_LIGHTNING_RIDGE_EXEC_B3_PROTOCOL_GUID": [
    1156018559,
    1886,
    17677,
    152,
    213,
    84,
    235,
    187,
    64,
    112,
    30
  ],
  "EFI_PLATFORM_TYPE_LIGHTNING_RIDGE_EXEC_B4_PROTOCOL_GUID": [
    2107979861,
    63024,
    18992,
    157,
    133,
    14,
    153,
    223,
    217,
    42,
    6
  ],
  "EFI_PLATFORM_TYPE_LIGHTNING_RIDGE_E_X8_S1_N_PROTOCOL_GUID": [
    1169528917,
    20492,
    17467,
    181,
    4,
    154,
    180,
    202,
    41,
    188,
    104
  ],
  "EFI_PLATFORM_TYPE_LIGHTNING_RIDGE_EX_8S2N_PROTOCOL_GUID": [
    3190812100,
    12113,
    16656,
    147,
    39,
    54,
    250,
    183,
    66,
    154,
    171
  ],
  "EFI_PLATFORM_TYPE_KYANITE_PROTOCOL_GUID": [
    3049131006,
    22658,
    16777,
    128,
    243,
    154,
    35,
    131,
    245,
    116,
    194
  ],
  "EFI_PLATFORM_TYPE_NEON_CITY_FPGA_PROTOCOL_GUID": [
    4068145620,
    14765,
    19720,
    133,
    109,
    193,
    21,
    238,
    74,
    173,
    64
  ],
  "EFI_PLATFORM_TYPE_OPAL_CITY_FPGA_PROTOCOL_GUID": [
    3349743222,
    20940,
    20474,
    181,
    202,
    105,
    234,
    136,
    210,
    247,
    141
  ],
  "CPU_UNCORE_TOKEN_SPACE_GUID": [
    2420392780,
    16616,
    18337,
    163,
    186,
    133,
    7,
    243,
    192,
    226,
    86
  ],
  "EFI_CPU_HT_CAPABLE_GUID": [
    219913358,
    63355,
    17970,
    131,
    67,
    145,
    244,
    61,
    154,
    133,
    96
  ],
  "EFI_MEMORY_CONFIG_DATA_HOB_GUID": [
    501373049,
    28202,
    19826,
    167,
    104,
    40,
    140,
    203,
    159,
    167,
    25
  ],
  "EFI_MEMORY_SETUP_GUID": [
    1055912799,
    5244,
    19665,
    162,
    52,
    146,
    160,
    105,
    112,
    13,
    182
  ],
  "EFI_MEMORY_MAP_GUID": [
    4169596949,
    27028,
    19352,
    149,
    162,
    189,
    86,
    218,
    145,
    192,
    127
  ],
  "EFI_MEMORY_MAP_DATA_HOB_BDAT_GUID": [
    873968165,
    37226,
    18933,
    154,
    245,
    201,
    199,
    191,
    147,
    126,
    162
  ],
  "EFI_MPST_NODE_DATA_GUID": [
    1099679236,
    61790,
    18499,
    133,
    208,
    45,
    36,
    128,
    183,
    228,
    136
  ],
  "READY_FOR_LOCK_PROTOCOL_GUID": [
    2372868829,
    17829,
    17832,
    139,
    184,
    12,
    58,
    149,
    49,
    72,
    250
  ],
  "PLATFORM_TOKEN_SPACE_GUID": [
    132096210,
    10949,
    19627,
    172,
    20,
    48,
    92,
    98,
    72,
    135,
    228
  ],
  "EFI_SOCKET_IIO_VARIABLE_GUID": [
    3716415870,
    32594,
    18681,
    177,
    110,
    80,
    237,
    158,
    13,
    190,
    39
  ],
  "EFI_SOCKET_COMMON_RC_VARIABLE_GUID": [
    1141033528,
    32911,
    17017,
    188,
    236,
    91,
    175,
    141,
    89,
    9,
    47
  ],
  "EFI_SOCKET_MP_LINK_VARIABLE_GUID": [
    731587294,
    10964,
    19132,
    149,
    125,
    95,
    24,
    197,
    4,
    160,
    92
  ],
  "EFI_SOCKET_PCI_RESOURCE_DATA_GUID": [
    3393190199,
    54854,
    18742,
    144,
    232,
    27,
    149,
    6,
    73,
    179,
    137
  ],
  "EFI_SOCKET_MEMORY_VARIABLE_GUID": [
    2563709421,
    16649,
    18049,
    183,
    157,
    145,
    150,
    117,
    124,
    120,
    36
  ],
  "EFI_SOCKET_POWERMANAGEMENT_VAR_GUID": [
    2701423426,
    48570,
    19886,
    166,
    122,
    64,
    151,
    155,
    101,
    199,
    248
  ],
  "EFI_SOCKET_PROCESSOR_CORE_VAR_GUID": [
    117519752,
    51081,
    19986,
    167,
    195,
    136,
    250,
    250,
    231,
    159,
    124
  ],
  "PREV_BOOT_ERR_SRC_HOB_GUID": [
    1362671045,
    37737,
    18668,
    91,
    151,
    56,
    162,
    247,
    9,
    102,
    117
  ],
  "SOCKET_PKG_LIST_GUID": [
    1543537627,
    16253,
    19232,
    172,
    155,
    115,
    252,
    101,
    27,
    37,
    3
  ],
  "EFI_NGN_CFG_CUR_GUID": [
    2699353631,
    60673,
    16794,
    149,
    125,
    35,
    121,
    3,
    16,
    139,
    168
  ],
  "EFI_NGN_CFG_OUT_GUID": [
    1096362157,
    12761,
    19647,
    158,
    146,
    109,
    31,
    103,
    236,
    87,
    17
  ],
  "EFI_VOLATILE_MEM_MODE_VARIABLE_GUID": [
    104046833,
    30974,
    16697,
    184,
    120,
    0,
    69,
    232,
    28,
    184,
    171
  ],
  "EFI_PREV_BOOT_NGN_DIMM_CFG_VARIABLE_GUID": [
    1399948985,
    7858,
    16660,
    177,
    252,
    138,
    168,
    148,
    9,
    53,
    68
  ],
  "SIGNAL_BEFORE_ENTER_SETUP_GUID": [
    3656476314,
    62725,
    18621,
    168,
    146,
    148,
    183,
    202,
    144,
    48,
    49
  ],
  "EFI_QPI_RC_PARM_GUID": [
    2169109432,
    41679,
    16948,
    181,
    6,
    183,
    98,
    85,
    247,
    163,
    109
  ],
  "ADDRESS_BASED_MIRROR_GUID": [
    2073813728,
    57994,
    16791,
    173,
    62,
    50,
    240,
    98,
    249,
    70,
    44
  ],
  "EFI_PPR_VARIABLE_GUID": [
    1779801423,
    28267,
    17699,
    174,
    181,
    247,
    175,
    28,
    68,
    75,
    15
  ],
  "EFI_VIRTUAL_LOCKSTEP_GUID": [
    2441696287,
    44044,
    17256,
    144,
    98,
    112,
    225,
    149,
    124,
    52,
    69
  ],
  "EFI_RAS_CLV_TESTER_GUID": [
    2614325071,
    2268,
    20139,
    134,
    55,
    43,
    193,
    189,
    94,
    13,
    149
  ],
  "SOCKET_PKG_FPGA_GUID": [
    1649120399,
    28346,
    19965,
    157,
    218,
    16,
    176,
    7,
    58,
    55,
    53
  ],
  "FPGA_SOCKET_VARIABLE_GUID": [
    1971559179,
    2713,
    16947,
    138,
    164,
    56,
    102,
    246,
    206,
    244,
    179
  ],
  "FPGA_SOCKET_PKG_LIST_GUID": [
    2744265498,
    13796,
    16690,
    156,
    237,
    145,
    211,
    141,
    113,
    113,
    216
  ],
  "FPGA_FORM_SET_GUID": [
    578916624,
    32623,
    18514,
    180,
    187,
    19,
    167,
    112,
    20,
    155,
    12
  ],
  "FPGA_SOCKET_HOB_GUID": [
    3612985104,
    18922,
    19750,
    159,
    124,
    222,
    16,
    100,
    135,
    110,
    47
  ],
  "FPGA_SOCKET_BBS_GBE_GUID": [
    682763759,
    59057,
    19904,
    141,
    77,
    73,
    239,
    200,
    87,
    204,
    223
  ],
  "FPGA_SOCKET_BBS_PCIE_GUID": [
    3839255245,
    31947,
    19637,
    174,
    206,
    78,
    234,
    57,
    143,
    248,
    228
  ],
  "FPGA_SOCKET_N4_PE_GUID": [
    2027454362,
    12830,
    18951,
    135,
    95,
    141,
    131,
    163,
    208,
    110,
    89
  ],
  "FPGA_ERROR_RECORD_GUID": [
    167627550,
    57483,
    19300,
    137,
    12,
    112,
    227,
    23,
    75,
    224,
    122
  ],
  "IIO_POLICY_HOB_GUID": [
    212579111,
    4606,
    16747,
    174,
    128,
    45,
    229,
    223,
    96,
    247,
    125
  ],
  "PEI_BASE_MEMORY_TEST_PPI_GUID": [
    3068936764,
    8658,
    18701,
    133,
    198,
    221,
    88,
    100,
    234,
    166,
    116
  ],
  "SSA_BIOS_SERVICES_PPI_GUID": [
    3135413627,
    35259,
    16931,
    175,
    118,
    150,
    208,
    179,
    36,
    155,
    54
  ],
  "FPGA_INIT_PPI_GUID": [
    845026370,
    39905,
    18827,
    176,
    7,
    191,
    76,
    56,
    189,
    176,
    236
  ],
  "EFI_IIO_UDS_PROTOCOL_GUID": [
    2815350624,
    50972,
    19994,
    172,
    177,
    137,
    96,
    77,
    82,
    22,
    203
  ],
  "EFI_IIO_SYSTEM_PROTOCOL_GUID": [
    3720546314,
    10048,
    20162,
    154,
    165,
    160,
    173,
    239,
    214,
    255,
    156
  ],
  "EFI_CPU_CSR_ACCESS_GUID": [
    6783839,
    39504,
    17210,
    140,
    187,
    133,
    32,
    120,
    25,
    120,
    20
  ],
  "EFI_CRYSTAL_RIDGE_GUID": [
    1651075015,
    1819,
    19866,
    157,
    12,
    241,
    18,
    207,
    8,
    54,
    233
  ],
  "EFI_CRYSTAL_RIDGE_SMM_GUID": [
    4035953429,
    52303,
    19852,
    179,
    76,
    176,
    48,
    196,
    231,
    185,
    25
  ],
  "EFI_JEDEC_NV_DIMM_GUID": [
    1890901644,
    15105,
    20234,
    162,
    243,
    147,
    206,
    233,
    119,
    49,
    62
  ],
  "EFI_JEDEC_NV_DIMM_SMM_GUID": [
    3121088633,
    15092,
    17977,
    150,
    19,
    209,
    252,
    142,
    216,
    166,
    105
  ],
  "EFI_CPU_PPM_PROTOCOL_GUID": [
    2120903925,
    51356,
    18735,
    172,
    55,
    35,
    7,
    132,
    156,
    58,
    213
  ],
  "NGN_RAS_PROTOCOL_GUID": [
    438703264,
    35303,
    4579,
    41,
    144,
    49,
    210,
    129,
    254,
    177,
    220
  ],
  "EFI_RAS_MP_LINK_PROTOCOL_GUID": [
    2413594765,
    8546,
    18801,
    129,
    194,
    53,
    211,
    161,
    170,
    80,
    71
  ],
  "EFI_MEM_RAS_PROTOCOL_GUID": [
    1836993074,
    39539,
    18106,
    148,
    161,
    95,
    47,
    37,
    239,
    62,
    41
  ],
  "EFI_NGN_ACPI_SMM_INTERFACE_PROTOCOL_GUID": [
    2216548979,
    2701,
    19785,
    175,
    96,
    42,
    20,
    93,
    33,
    118,
    206
  ],
  "ACPI_PCAT_PROTOCOL_GUID": [
    2972567200,
    4130,
    18102,
    185,
    149,
    134,
    70,
    173,
    94,
    94,
    235
  ],
  "NFIT_BINDING_PROTOCOL_GUID": [
    2545220108,
    19838,
    49872,
    103,
    142,
    251,
    146,
    233,
    109,
    44,
    194
  ],
  "EFI_QUIESCE_PROTOCOL_GUID": [
    550954841,
    19530,
    16576,
    149,
    51,
    43,
    240,
    6,
    104,
    80,
    253
  ],
  "EFI_PLATFORM_RAS_POLICY_PROTOCOL_GUID": [
    2259718637,
    5219,
    17333,
    130,
    161,
    44,
    139,
    131,
    203,
    137,
    23
  ],
  "EFI_ERROR_HANDLING_PROTOCOL_GUID": [
    1000857931,
    5997,
    19242,
    148,
    138,
    200,
    111,
    176,
    1,
    148,
    60
  ],
  "EFI_HP_IOX_ACCESS_GUID": [
    1650797395,
    31193,
    19698,
    181,
    170,
    173,
    153,
    129,
    10,
    127,
    23
  ],
  "EFI_CPU_HOT_ADD_DATA_PROTOCOL_GUID": [
    856418133,
    64493,
    20248,
    185,
    168,
    73,
    88,
    86,
    211,
    215,
    161
  ],
  "EFI_CPU_RAS_PROTOCOL_GUID": [
    4035247941,
    63994,
    20126,
    141,
    255,
    226,
    215,
    128,
    210,
    44,
    194
  ],
  "EFI_IIO_RAS_PROTOCOL_GUID": [
    1283343804,
    35363,
    9933,
    148,
    173,
    93,
    44,
    38,
    63,
    37,
    254
  ],
  "RAS_CLV_ADDDC_PROTOCOL": [
    542597704,
    49178,
    17309,
    140,
    214,
    65,
    142,
    170,
    190,
    10,
    41
  ],
  "RAS_CLV_SDDC_PROTOCOL": [
    1572504268,
    59405,
    17528,
    160,
    125,
    57,
    79,
    54,
    45,
    53,
    36
  ],
  "RAS_CLV_RANK_SPARING_PROTOCOL": [
    3827683127,
    58715,
    17367,
    178,
    198,
    205,
    185,
    238,
    141,
    37,
    165
  ],
  "RAS_CLV_PATROL_SCRUB_PROTOCOL": [
    398422695,
    47717,
    18487,
    134,
    109,
    151,
    155,
    47,
    44,
    7,
    94
  ],
  "RAS_CLV_MIRROR_FAILOVER_PROTOCOL": [
    1723597020,
    34135,
    20417,
    155,
    236,
    19,
    119,
    96,
    226,
    126,
    150
  ],
  "EFI_FPGA_HSSI_CONFIG_DATA_PROTOCOL": [
    858469766,
    61620,
    18158,
    163,
    156,
    120,
    99,
    48,
    226,
    211,
    40
  ],
  "COMPLETE_POWER_MANAGEMENT_PROTOCOL_GUID": [
    2724147149,
    49512,
    20087,
    173,
    62,
    164,
    136,
    172,
    183,
    37,
    171
  ],
  "SERVER_COMMON_TOKEN_SPACE_GUID": [
    895775153,
    46211,
    17070,
    182,
    231,
    59,
    46,
    186,
    177,
    78,
    21
  ],
  "USB_DBG_GUID": [
    4169181920,
    58540,
    19556,
    163,
    38,
    130,
    112,
    156,
    194,
    65,
    234
  ],
  "EFI_PLATFORM_TXT_DEVICE_MEMORY_GUID": [
    1943131254,
    42953,
    20221,
    143,
    139,
    213,
    50,
    239,
    56,
    23,
    8
  ],
  "EFI_PLATFORM_TXT_POLICY_DATA_GUID": [
    2740136203,
    34429,
    19667,
    168,
    27,
    75,
    126,
    94,
    16,
    14,
    22
  ],
  "PREPARE_FOR_SCHECK_EVENT_GUID": [
    3401135228,
    36073,
    19937,
    156,
    111,
    100,
    87,
    172,
    105,
    51,
    43
  ],
  "EFI_HII_EXPORT_DATABASE_GUID": [
    461603216,
    17957,
    20141,
    171,
    201,
    205,
    94,
    106,
    241,
    143,
    224
  ],
  "EFI_TRACE_HUB_TOKEN_SPACE_GUID": [
    2795198633,
    27653,
    19905,
    133,
    191,
    175,
    128,
    220,
    230,
    217,
    125
  ],
  "EFI_TRACE_HUB_STATUS_CODE_HANDLE_PEI_GUID": [
    263437561,
    2589,
    17816,
    165,
    33,
    229,
    200,
    78,
    149,
    217,
    122
  ],
  "EFI_TRACE_HUB_STATUS_CODE_HANDLE_RUNTIME_DXE_GUID": [
    4243922539,
    21119,
    17293,
    190,
    109,
    166,
    209,
    95,
    12,
    217,
    139
  ],
  "EFI_TRACE_HUB_STATUS_CODE_HANDLE_SMM_GUID": [
    2919979888,
    53316,
    17494,
    186,
    81,
    151,
    14,
    76,
    104,
    112,
    191
  ],
  "PEI_SPI_SOFT_STRAPS_PPI_GUID": [
    2132403990,
    16796,
    20089,
    142,
    55,
    194,
    189,
    132,
    235,
    101,
    40
  ],
  "PEI_TXT_SCLEAN_PPI_GUID": [
    1297498341,
    9986,
    19960,
    136,
    244,
    86,
    72,
    134,
    252,
    67,
    220
  ],
  "EFI_TRACE_HUB_STATUS_CODE_HANDLE_HEADER_PPI": [
    2021526602,
    18983,
    18577,
    148,
    137,
    175,
    80,
    116,
    195,
    110,
    137
  ],
  "EFI_PCI_CALLBACK_PROTOCOL_GUID": [
    480305666,
    65182,
    18294,
    159,
    170,
    87,
    12,
    25,
    97,
    122,
    6
  ],
  "EFI_LPC_POLICY_PROTOCOL_GUID": [
    1677860350,
    42540,
    17063,
    191,
    70,
    21,
    7,
    140,
    223,
    159,
    137
  ],
  "EFI_TXT_LOCK_CONFIG_GUID": [
    4059546657,
    38623,
    19594,
    175,
    145,
    98,
    163,
    201,
    174,
    211,
    16
  ],
  "PROJECT_OWN_PROTOCOL_GUID": [
    1800965500,
    50990,
    19064,
    136,
    88,
    119,
    225,
    218,
    143,
    199,
    247
  ],
  "PROJECT_OWN_PEI_PROTOCOL_GUID": [
    2699404383,
    21364,
    18099,
    181,
    30,
    211,
    16,
    178,
    196,
    138,
    174
  ],
  "SUPER_M_DRIVER_PROTOCOL_GUID": [
    577930843,
    60406,
    16455,
    176,
    8,
    120,
    137,
    73,
    127,
    83,
    189
  ],
  "SUPER_M_PEI_PROCOCOL_GUID": [
    2147235584,
    31838,
    16959,
    160,
    75,
    50,
    233,
    241,
    106,
    103,
    39
  ],
  "SMC_OOB_MD5_GUID": [
    3056196086,
    54160,
    20403,
    170,
    10,
    210,
    72,
    199,
    62,
    168,
    246
  ],
  "SMC_FEATURE_SUPPORT_FLAGS_GUID": [
    3542920707,
    65534,
    20327,
    187,
    249,
    124,
    184,
    81,
    196,
    88,
    14
  ],
  "SMC_BOARD_INFO_VARIABLE_GUID": [
    640364095,
    55853,
    19329,
    141,
    29,
    249,
    56,
    232,
    81,
    253,
    237
  ],
  "SMC_MEM_MAP_OUT_GUID": [
    1976104482,
    32912,
    16407,
    133,
    12,
    63,
    164,
    11,
    2,
    121,
    132
  ],
  "EFI_SMC_IN_BAND_LOAD_DEFAULT_GUID": [
    504397795,
    22109,
    19168,
    148,
    181,
    86,
    61,
    159,
    150,
    191,
    200
  ],
  "SMC_SW_SMI_FLASH_PROTOCOL_GUID": [
    4257945601,
    41731,
    17456,
    148,
    129,
    40,
    242,
    152,
    192,
    30,
    201
  ],
  "SMC_OOB_PLATFORM_POLICY_GUID": [
    661798795,
    9640,
    19873,
    163,
    252,
    123,
    48,
    233,
    135,
    29,
    199
  ],
  "SMC_OOB_PLATFORM_POLICY_CALLBACK_GUID": [
    1344035719,
    33153,
    19173,
    166,
    178,
    208,
    90,
    206,
    13,
    131,
    222
  ],
  "SMC_OOB_DATA_READY_PROTOCOL_GUID": [
    3567629053,
    44356,
    16458,
    152,
    168,
    41,
    120,
    87,
    231,
    42,
    83
  ],
  "SETUP_MODIFY_PROTOCOL_GUID": [
    1105910784,
    36274,
    19454,
    176,
    234,
    203,
    170,
    231,
    244,
    211,
    27
  ],
  "SMC_NVDIMM_SMM_PROTOCOL_GUID": [
    2727938833,
    61532,
    16770,
    151,
    3,
    187,
    2,
    39,
    93,
    184,
    249
  ],
  "SMC_IPMI_OEM_COMMAND_SET_PROTOCOL_GUID": [
    2180591769,
    2687,
    20250,
    148,
    212,
    179,
    190,
    63,
    172,
    234,
    106
  ],
  "SMC_ROM_HOLE_PROTOCOL_GUID": [
    691585993,
    20379,
    17330,
    164,
    41,
    126,
    99,
    21,
    173,
    106,
    157
  ],
  "SMC_PKG_TOKEN_SPACE_GUID": [
    1335395271,
    45833,
    16722,
    172,
    243,
    34,
    56,
    80,
    71,
    141,
    136
  ],
  "EFI_EV_PPI_GUID": [
    2684442945,
    417,
    16710,
    177,
    1,
    177,
    187,
    5,
    216,
    99,
    28
  ],
  "PLATFORM_FLASH_SMM_PROTOCOL_GUID": [
    564612963,
    51728,
    19910,
    164,
    235,
    54,
    201,
    59,
    154,
    6,
    58
  ],
  "SYSTEM_FIRMWARE_DEVICE_SMM_PROTOCOL_GUID": [
    28922374,
    52582,
    19469,
    168,
    103,
    237,
    66,
    150,
    14,
    7,
    220
  ],
  "LENOVO_SECURITY_SMI_DISPATCH_PROTOCOL_GUID": [
    2673773662,
    883,
    18952,
    141,
    181,
    31,
    145,
    51,
    22,
    197,
    228
  ],
  "THINKPAD_ACPI_NVS_DATA_PROTOCOL_GUID": [
    3874493611,
    51982,
    17774,
    138,
    247,
    114,
    33,
    237,
    183,
    2,
    247
  ],
  "EC_IO_SMM_PROTOCOL_GUID": [
    2866707607,
    39143,
    19706,
    180,
    239,
    187,
    226,
    5,
    6,
    163,
    29
  ],
  "NVME_SMM_PROTOCOL_GUID": [
    1172953002,
    28037,
    19948,
    139,
    136,
    140,
    75,
    229,
    161,
    160,
    141
  ],
  "PCH_TCO_SMI_DISPATCH_PROTOCOL_GUID": [
    2658260489,
    27940,
    18429,
    181,
    114,
    97,
    64,
    248,
    217,
    194,
    164
  ],
  "SYSTEM_VARIABLE_STORE_PROTOCOL_GUID": [
    2815950891,
    37435,
    16832,
    136,
    76,
    63,
    195,
    121,
    82,
    3,
    250
  ],
  "EMULATED_EEPROM_SMM_PROTOCOL_GUID": [
    233355983,
    57354,
    17720,
    190,
    13,
    129,
    175,
    147,
    116,
    252,
    201
  ],
  "LENOVO_SUPERVISOR_PASSWORD_MANAGER_SMM_PROTOCOL_GUID": [
    1710970205,
    23754,
    16579,
    153,
    103,
    34,
    121,
    136,
    40,
    141,
    216
  ],
  "SYSTEM_VARIABLE_HOOK_PROTOCOL_GUID": [
    1010040483,
    60114,
    18417,
    152,
    179,
    79,
    16,
    37,
    73,
    102,
    245
  ],
  "LENOVO_MAILBOX_SMM_PROTOCOL_GUID": [
    2452201135,
    26258,
    18525,
    174,
    44,
    205,
    7,
    120,
    151,
    64,
    139
  ],
  "FLASH_UTILITY_SMM_PROTOCOL_GUID": [
    3831037044,
    40723,
    19982,
    168,
    30,
    227,
    38,
    5,
    250,
    114,
    71
  ],
  "PCH_SMM_SPI_PROTOCOL_GUID": [
    1448222470,
    2658,
    18466,
    153,
    99,
    223,
    1,
    157,
    114,
    199,
    225
  ],
  "PCH_FLASH_CONTROLLER_SMM_PROTOCOL_GUID": [
    1173519784,
    56221,
    18657,
    191,
    94,
    69,
    141,
    238,
    217,
    222,
    132
  ],
  "EFI_EC_ACCESS_PROTOCOL_GUID": [
    1894706366,
    29306,
    16964,
    144,
    76,
    219,
    107,
    240,
    5,
    83,
    146
  ],
  "PCH_PCIE_SMI_DISPATCH_PROTOCOL_GUID": [
    1048390486,
    16199,
    17066,
    143,
    107,
    34,
    245,
    25,
    129,
    141,
    171
  ],
  "SA_POLICY_PROTOCOL_GUID": [
    3333037863,
    21911,
    18434,
    159,
    99,
    214,
    40,
    54,
    89,
    134,
    53
  ],
  "SCT_MILESTONE_TASK_PROTOCOL_GUID": [
    1486834498,
    43269,
    4576,
    130,
    100,
    8,
    0,
    32,
    12,
    154,
    102
  ],
  "SCT_MILESTONE_TASK_ENTRY_GUID": [
    4003565808,
    38447,
    4576,
    170,
    128,
    8,
    0,
    32,
    12,
    154,
    102
  ],
  "BOARD_INFO_SMM_PROTOCOL_GUID": [
    4135579194,
    56290,
    16936,
    151,
    50,
    180,
    221,
    30,
    95,
    246,
    175
  ],
  "SMM_ASL_SMI_PROTOCOL_GUID": [
    3088480265,
    59194,
    17287,
    131,
    35,
    10,
    254,
    131,
    211,
    7,
    79
  ],
  "FDISK_OEM_SMM_PROTOCOL_GUID": [
    2978821267,
    32354,
    18651,
    164,
    218,
    129,
    32,
    191,
    177,
    67,
    148
  ],
  "LENOVO_SMM_KEYBOARD_CONFIG_PROTOCOL_GUID": [
    2509393432,
    30492,
    17065,
    184,
    133,
    190,
    221,
    182,
    13,
    45,
    56
  ],
  "LENOVO_CONFIG_VARIABLE_GUID": [
    709740215,
    16885,
    17885,
    180,
    111,
    45,
    211,
    52,
    193,
    207,
    101
  ],
  "SYSTEM_FLASH_COMMUNICATION_DATA_PROTOCOL_GUID": [
    4124909425,
    50146,
    18237,
    132,
    213,
    52,
    26,
    55,
    64,
    84,
    175
  ],
  "PCH_ESPI_SMI_DISPATCH_PROTOCOL_GUID": [
    3015790579,
    47848,
    17772,
    134,
    49,
    39,
    254,
    12,
    235,
    52,
    12
  ],
  "LENOVO_SECURE_KEY_SMM_PROTOCOL_GUID": [
    4104059872,
    18050,
    17521,
    174,
    101,
    0,
    239,
    251,
    71,
    112,
    186
  ],
  "LENOVO_VARIABLE_DXE_PROTOCOL_GUID": [
    3568717770,
    31820,
    18625,
    151,
    111,
    82,
    135,
    66,
    55,
    83,
    228
  ],
  "LENOVO_SECURITY_CONFIG_VARIABLE_GUID": [
    2730590351,
    3407,
    19657,
    166,
    25,
    209,
    230,
    65,
    211,
    157,
    73
  ],
  "LENOVO_VARIABLE_SMM_PROTOCOL_GUID": [
    1057399341,
    52482,
    20202,
    178,
    148,
    214,
    135,
    29,
    241,
    37,
    93
  ],
  "PCH_NVS_AREA_PROTOCOL_GUID": [
    772115243,
    60865,
    17457,
    135,
    217,
    198,
    196,
    234,
    16,
    43,
    227
  ],
  "PCH_SMI_DISPATCH_PROTOCOL_GUID": [
    3869776831,
    34621,
    18429,
    182,
    190,
    97,
    179,
    229,
    114,
    9,
    147
  ],
  "PCH_SMM_PERIODIC_TIMER_CONTROL_GUID": [
    1762060603,
    24635,
    18959,
    134,
    146,
    131,
    32,
    4,
    170,
    242,
    219
  ],
  "PCH_ACPI_SMI_DISPATCH_PROTOCOL_GUID": [
    3576410722,
    61474,
    18924,
    134,
    210,
    122,
    41,
    58,
    122,
    5,
    75
  ],
  "PCH_SMM_IO_TRAP_CONTROL_GUID": [
    1364011773,
    8342,
    17027,
    157,
    166,
    112,
    12,
    210,
    125,
    199,
    165
  ],
  "ME_GLOBAL_NVS_AREA_PROTOCOL_GUID": [
    1006628093,
    55135,
    18805,
    184,
    136,
    57,
    2,
    189,
    105,
    0,
    43
  ],
  "ME_SSDT_ACPI_TABLE_STORAGE_GUID": [
    2593096405,
    14769,
    18650,
    146,
    220,
    162,
    45,
    168,
    131,
    77,
    246
  ],
  "TPM2_ACPI_TABLE_STORAGE_GUID": [
    2099745651,
    61132,
    19791,
    174,
    47,
    206,
    196,
    183,
    6,
    176,
    106
  ],
  "LENOVO_CAPSULE_UPDATE_VARIABLE_GUID": [
    1215322664,
    65358,
    17779,
    129,
    100,
    160,
    38,
    150,
    61,
    128,
    31
  ],
  "LENOVO_LOGGING_VARIABLE_GUID": [
    936634592,
    34904,
    19332,
    161,
    6,
    36,
    75,
    184,
    203,
    253,
    195
  ],
  "DELL_FLASH_IO_SMM_PROTOCOL_GUID": [
    1106796650,
    63308,
    16541,
    148,
    101,
    82,
    25,
    85,
    124,
    188,
    125
  ],
  "DELL_SMM_VARIABLE_PROTOCOL_GUID": [
    240204090,
    59493,
    19518,
    140,
    95,
    68,
    47,
    224,
    145,
    70,
    165
  ],
  "DELL_PROPERTY_SMM_PROTOCOL_GUID": [
    3081205713,
    28342,
    18078,
    173,
    31,
    17,
    101,
    235,
    146,
    179,
    255
  ],
  "DELL_PROPERTY_ACCESSOR_PROTOCOL_GUID": [
    3784303313,
    61234,
    19598,
    137,
    90,
    240,
    44,
    60,
    56,
    251,
    25
  ],
  "DELL_STORAGE_AGENT_SMM_PROTOCOL_GUID": [
    1365421601,
    6125,
    17847,
    170,
    157,
    230,
    105,
    163,
    163,
    53,
    37
  ],
  "DELL_SMM_EVENT_PROTOCOL_GUID": [
    3834818659,
    59462,
    18448,
    169,
    104,
    1,
    188,
    36,
    51,
    151,
    116
  ],
  "DELL_VARIABLE_PROTOCOL_GUID": [
    598193751,
    1919,
    19132,
    171,
    126,
    183,
    13,
    138,
    56,
    157,
    190
  ],
  "DELL_STORAGE_AGENT_SMM_REGISTER_GUID": [
    2202109274,
    62066,
    20478,
    187,
    238,
    218,
    234,
    197,
    206,
    221,
    199
  ],
  "SMM_BBS_MANAGER_PROTOCOL_GUID": [
    4112354150,
    59242,
    17359,
    152,
    128,
    63,
    174,
    77,
    48,
    246,
    135
  ],
  "DELL_ENHANCED_VERSION_PROTOCOL_GUID": [
    298970145,
    58728,
    20144,
    142,
    29,
    160,
    128,
    151,
    114,
    182,
    6
  ],
  "DELL_SMM_SERVICES_PROTOCOL_GUID": [
    203384192,
    40023,
    18994,
    132,
    153,
    34,
    124,
    46,
    162,
    126,
    125
  ],
  "DELL_VIRT_RTC_SMM_PROTOCOL_GUID": [
    1578874102,
    3399,
    18163,
    161,
    138,
    65,
    235,
    64,
    11,
    208,
    249
  ],
  "DELL_BIOS_ATTRIBUTES_SMM_GUID": [
    3284288209,
    259,
    19572,
    154,
    25,
    60,
    92,
    59,
    71,
    235,
    206
  ],
  "DELL_SMM_TAGS_PROTOCOL_GUID": [
    3697861383,
    27788,
    18839,
    179,
    47,
    63,
    115,
    195,
    129,
    183,
    105
  ],
  "DELL_SMM_MFG_MODE_PROTOCOL_GUID": [
    858574829,
    58855,
    18859,
    130,
    13,
    227,
    74,
    84,
    237,
    63,
    87
  ],
  "EFI_SMB_SMM_DA_CI_PROTOCOL_VER2_GUID": [
    1734764392,
    40036,
    19626,
    186,
    244,
    202,
    62,
    76,
    183,
    105,
    122
  ],
  "DELL_PASSWORD_POLICY_EXT_SMM_PROTOCOL_GUID": [
    2665749132,
    49426,
    20047,
    178,
    240,
    101,
    208,
    249,
    177,
    51,
    219
  ],
  "DELL_DEV_PASSWORD_PROTOCOL": [
    179738574,
    47392,
    18604,
    162,
    101,
    236,
    86,
    36,
    237,
    205,
    215
  ],
  "DELL_SMB_DA_TOKEN_CFG_POLICY_GUID_VER2": [
    1786132583,
    16518,
    16620,
    165,
    172,
    109,
    99,
    2,
    30,
    254,
    220
  ],
  "DELL_TAGS_POLICY_GUID": [
    492366333,
    47744,
    19015,
    129,
    144,
    8,
    174,
    155,
    184,
    160,
    237
  ],
  "DELL_EC_POLICY_GUID": [
    2000124362,
    10984,
    16499,
    139,
    197,
    67,
    55,
    106,
    97,
    191,
    213
  ],
  "DELL_GENERATION_ID_POLICY_GUID": [
    4014538728,
    40484,
    20152,
    130,
    141,
    46,
    193,
    26,
    157,
    248,
    221
  ],
  "DELL_SMI_CPU_DECODE_PROTOCOL_GUID": [
    577250467,
    6537,
    19820,
    189,
    23,
    200,
    99,
    132,
    95,
    126,
    153
  ],
  "DELL_SB_SMM_PROTOCOL_GUID": [
    3184524733,
    43713,
    18180,
    143,
    73,
    236,
    37,
    6,
    67,
    36,
    192
  ],
  "DELL_PASSWORD_POLICY_SMM_PROTOCOL_GUID": [
    799436599,
    36243,
    16419,
    182,
    162,
    188,
    80,
    73,
    172,
    207,
    11
  ],
  "DELL_PASSWORD_POLICY_DXE_PROTOCOL_GUID": [
    559962128,
    21683,
    16649,
    138,
    255,
    59,
    63,
    191,
    74,
    240,
    64
  ],
  "DELL_BFA_SMM_PROTOCOL_GUID": [
    783381159,
    26853,
    19072,
    159,
    249,
    25,
    223,
    55,
    166,
    147,
    202
  ],
  "DELL_SMM_EC_IO_PROTOCOL_GUID": [
    1930486414,
    38634,
    17248,
    148,
    110,
    90,
    220,
    107,
    232,
    245,
    49
  ],
  "DELL_OS_PROTOCOL_ACCESS_GUID": [
    3554477446,
    38765,
    17567,
    152,
    55,
    3,
    146,
    233,
    59,
    125,
    82
  ],
  "DELL_TOKEN_HANDLER_PROTOCOL_GUID": [
    708691735,
    27702,
    20309,
    157,
    46,
    202,
    90,
    115,
    214,
    47,
    23
  ],
  "DELL_SYSTEM_POLICY_GUID": [
    2343933041,
    33340,
    18961,
    182,
    16,
    206,
    57,
    133,
    121,
    62,
    177
  ],
  "DELL_SMM_GPIO_CONTROL_PROTOCOL_GUID": [
    1370456604,
    44463,
    19132,
    159,
    191,
    38,
    205,
    82,
    69,
    186,
    34
  ],
  "DELL_SMM_LEGACY_REGION_PROTOCOL_GUID": [
    807422031,
    17794,
    16494,
    178,
    15,
    137,
    234,
    204,
    147,
    220,
    106
  ],
  "DELL_HOT_KEYS_POLICY_GUID": [
    2537162355,
    15018,
    18332,
    151,
    70,
    219,
    215,
    222,
    170,
    160,
    180
  ],
  "DELL_EC_POLICY2_GUID": [
    1934142791,
    11840,
    18502,
    182,
    88,
    185,
    33,
    52,
    105,
    193,
    48
  ],
  "DELL_EC_POLICY3_GUID": [
    4254642530,
    16826,
    19614,
    152,
    46,
    2,
    54,
    153,
    222,
    2,
    240
  ],
  "DELL_BATT_POLICY_GUID": [
    3866445575,
    36634,
    17734,
    185,
    198,
    177,
    54,
    211,
    70,
    219,
    247
  ],
  "DELL_STEALTH_MODE_POLICY_GUID": [
    228494774,
    23130,
    19035,
    134,
    33,
    133,
    255,
    201,
    174,
    69,
    131
  ],
  "DELL_STEALTH_MODE2_POLICY_GUID": [
    2600766611,
    16305,
    20333,
    133,
    146,
    19,
    62,
    38,
    249,
    79,
    253
  ],
  "DELL_SYSTEM_ID_POLICY_GUID": [
    1721407303,
    42590,
    20281,
    143,
    214,
    149,
    87,
    87,
    59,
    201,
    218
  ],
  "DELL_DOCK_POLICY_GUID": [
    3342078921,
    16476,
    20304,
    186,
    23,
    13,
    255,
    185,
    19,
    237,
    22
  ],
  "DELL_SMM_EC_PROTOCOL_GUID": [
    3076643361,
    30444,
    19120,
    153,
    232,
    77,
    194,
    81,
    183,
    44,
    181
  ],
  "DELL_SYSTEM_POLICY3_GUID": [
    1896876567,
    30442,
    18621,
    130,
    99,
    26,
    49,
    178,
    149,
    36,
    56
  ],
  "DELL_PM_POLICY_PROTOCOL_GUID": [
    10780878,
    55121,
    19217,
    137,
    251,
    125,
    206,
    187,
    178,
    47,
    77
  ],
  "DELL_SMB_QUICK_SET_SUPPORT_PROT_GUID": [
    3858837331,
    30101,
    16538,
    159,
    172,
    48,
    224,
    57,
    10,
    42,
    105
  ],
  "DELL_HOT_KEY_SMM_PROTOCOL_GUID": [
    1840697154,
    2620,
    19401,
    151,
    219,
    156,
    237,
    3,
    183,
    241,
    141
  ],
  "DELL_SMM_KEYBOARD_BACKLIGHT_PROTOCOL_GUID": [
    138477446,
    63120,
    20440,
    168,
    145,
    139,
    249,
    68,
    176,
    243,
    36
  ],
  "DELL_ATA_ATAPI_IO_PROTOCOL_GUID": [
    599024080,
    15508,
    18701,
    154,
    75,
    74,
    225,
    145,
    107,
    212,
    37
  ],
  "DELL_PROPERTY_READY_GUID": [
    4261473010,
    47671,
    19407,
    147,
    156,
    76,
    120,
    234,
    99,
    236,
    218
  ],
  "DELL_STORAGE_AGENT_CONFIG_POLICY_GUID": [
    3649582474,
    5503,
    17335,
    154,
    122,
    39,
    87,
    214,
    99,
    220,
    235
  ],
  "DELL_SMM_ACPI_PROTOCOL_GUID": [
    4000400574,
    25684,
    18243,
    157,
    35,
    93,
    216,
    223,
    234,
    91,
    91
  ],
  "ERROR_LOG_POLICY_DXE_GUID": [
    2375132141,
    36928,
    18144,
    130,
    72,
    251,
    190,
    63,
    43,
    232,
    8
  ],
  "DELL_DIAGS_SMM_PROTOCOL_GUID": [
    837417748,
    20962,
    18153,
    159,
    129,
    242,
    202,
    82,
    252,
    178,
    180
  ],
  "DEH_SMM_PROTOCOL_VER3_GUID": [
    57235770,
    47771,
    17789,
    180,
    111,
    49,
    216,
    58,
    150,
    214,
    254
  ],
  "DELL_ERROR_HANDLER_SMM_PROTOCOL_GUID_VER2": [
    1356740489,
    48435,
    19183,
    177,
    130,
    127,
    233,
    24,
    62,
    136,
    218
  ],
  "DELL_PERMANENT_DEVICE_POLICY_SMM_GUID": [
    3632136001,
    8677,
    17574,
    151,
    139,
    128,
    120,
    106,
    185,
    114,
    41
  ],
  "DELL_ACPI_POLICY_GUID": [
    3857099594,
    3453,
    18950,
    161,
    100,
    97,
    228,
    124,
    206,
    155,
    59
  ],
  "DELL_DASH_POLICY_PROTOCOL_GUID": [
    3826098180,
    52907,
    17357,
    180,
    168,
    152,
    73,
    123,
    243,
    57,
    135
  ],
  "DELL_DASH_POLICY_VER3_PROTOCOL_GUID": [
    1173020965,
    10781,
    17632,
    153,
    83,
    122,
    183,
    241,
    152,
    136,
    175
  ],
  "DELL_SMM_PAID_SUP_DEV_POLICY_PROTOCOL_GUID": [
    3852237463,
    32745,
    20018,
    149,
    176,
    112,
    142,
    181,
    138,
    245,
    7
  ],
  "DELL_SMM_SYS_BOOT_DEVICES_POLICY_PROTOCOL_GUID": [
    1230837556,
    1491,
    16399,
    175,
    53,
    200,
    188,
    211,
    184,
    92,
    195
  ],
  "DELL_SMM_MFG_BOOT_LIST_POLICY_PROTOCOL_GUID": [
    2044818199,
    7355,
    18981,
    152,
    132,
    145,
    224,
    65,
    192,
    92,
    46
  ],
  "DELL_SMM_MFG_POLICY_PROTOCOL_GUID": [
    3426923731,
    29216,
    17034,
    155,
    110,
    228,
    73,
    113,
    208,
    40,
    9
  ],
  "CPU_GLOBAL_NVS_AREA_PROTOCOL_GUID": [
    2874822132,
    61655,
    18856,
    191,
    92,
    242,
    93,
    160,
    76,
    37,
    51
  ],
  "DELL_RADIO_USB_LOCATIONS_POLICY_GUID": [
    841669988,
    64289,
    17764,
    177,
    127,
    30,
    66,
    145,
    68,
    100,
    21
  ],
  "DELL_SMM_RADIO_DEVICE_PROTOCOL_GUID": [
    1360486578,
    58493,
    17588,
    131,
    102,
    15,
    44,
    211,
    188,
    29,
    56
  ],
  "DELL_ACPI_RESET_PROTOCOL_GUID": [
    444328680,
    1415,
    20149,
    179,
    93,
    208,
    210,
    98,
    32,
    24,
    0
  ],
  "ODM_GET_PCH_CF9_TRAP_HANDLE_PROTOCOL_GUID": [
    679629394,
    12817,
    13615,
    73,
    206,
    49,
    37,
    52,
    196,
    20,
    25
  ],
  "DELL_W_BOOT_CAPSULE_PROTOCOL_GUID": [
    1919026612,
    11853,
    17926,
    153,
    139,
    107,
    42,
    62,
    136,
    88,
    228
  ],
  "DELL_FN_USB_EMULATION_SMM_PROTOCOL_GUID": [
    1854934256,
    54678,
    17377,
    185,
    249,
    217,
    224,
    88,
    76,
    178,
    7
  ],
  "DELL_SMM_SYSTEM_SIO_PROTOCOL_GUID": [
    3402186753,
    22033,
    17472,
    155,
    33,
    245,
    75,
    112,
    10,
    29,
    52
  ],
  "SA_GLOBAL_NVS_AREA_PROTOCOL_GUID": [
    1036131701,
    56846,
    17152,
    160,
    170,
    25,
    196,
    28,
    12,
    243,
    223
  ],
  "DELL_SMM_GPIO_LOOKUP_POLICY_GUID": [
    2784557192,
    29073,
    17051,
    129,
    174,
    38,
    136,
    244,
    21,
    189,
    43
  ],
  "DELL_SMM_RADIO_EXEC_PROTOCOL_GUID": [
    2983971164,
    3815,
    16993,
    178,
    144,
    91,
    240,
    164,
    219,
    149,
    39
  ],
  "DELL_P_STATE_CONTROL_PROTOCOL_GUID": [
    4092836633,
    25632,
    17865,
    136,
    25,
    182,
    6,
    167,
    242,
    14,
    80
  ],
  "DELL_NUMBER_OF_P_STATE_PROTOCOL_GUID": [
    3978133630,
    39519,
    17258,
    184,
    170,
    215,
    142,
    217,
    231,
    217,
    44
  ],
  "DELL_POWER_OFF_POLICY_GUID": [
    4205920067,
    48962,
    17678,
    182,
    149,
    163,
    84,
    121,
    169,
    214,
    66
  ],
  "DELL_SMM_POWER_OFF_PROTOCOL_GUID": [
    2396166854,
    54954,
    20456,
    173,
    197,
    183,
    229,
    135,
    145,
    160,
    19
  ],
  "EFI_ODMEM_GNVS_AREA_PROTOCOL_GUID": [
    2508899018,
    39172,
    17322,
    185,
    222,
    53,
    229,
    212,
    196,
    18,
    23
  ],
  "ODM_DEBUG_SMM_PROTOCOL_GUID": [
    4118673553,
    7633,
    19559,
    153,
    161,
    74,
    178,
    218,
    217,
    255,
    188
  ],
  "DELL_PROPERTY_DXE_PROTOCOL_GUID": [
    1910209406,
    16741,
    18682,
    172,
    157,
    249,
    175,
    76,
    239,
    197,
    52
  ],
  "DELL_LEG_USB_BUS_PROTOCOL_GUID": [
    3661547425,
    63187,
    16681,
    152,
    176,
    148,
    148,
    248,
    88,
    80,
    6
  ],
  "DEVICE_ADDRESS_POLICY_PROTOCOL_GUID": [
    2914899691,
    10162,
    19010,
    179,
    146,
    242,
    156,
    0,
    200,
    216,
    97
  ],
  "DELL_LOM_POLICY_GUID": [
    3525154484,
    8390,
    20272,
    142,
    130,
    103,
    1,
    72,
    91,
    16,
    73
  ],
  "DELL_SMM_LOM_PROTOCOL_GUID": [
    349264290,
    21229,
    18013,
    147,
    83,
    242,
    57,
    197,
    70,
    75,
    245
  ],
  "SMM_BBS_MANAGER_INIT_NOTIFY_PROTOCOL_GUID": [
    4004415307,
    25811,
    17187,
    181,
    130,
    84,
    95,
    179,
    194,
    235,
    90
  ],
  "DELL_VIDEO_DEVICE2_PROTOCOL_GUID": [
    2849207006,
    54903,
    19265,
    143,
    173,
    158,
    193,
    120,
    222,
    25,
    206
  ],
  "DELL_SMM_NB_DOCK_PROTOCOL_GUID": [
    1418970396,
    31176,
    19502,
    151,
    88,
    29,
    181,
    181,
    43,
    19,
    183
  ],
  "DELL_RUNTIME_SMBIOS_PROTOCOL_GUID": [
    3755840049,
    62935,
    19597,
    139,
    232,
    110,
    173,
    135,
    50,
    64,
    243
  ],
  "DELL_VIDEO_PROTOCOL_GUID": [
    83360183,
    4680,
    18812,
    176,
    235,
    143,
    116,
    138,
    191,
    202,
    240
  ],
  "DELL_SMM_DPST_PROTOCOL_GUID": [
    1889096964,
    55210,
    19386,
    128,
    58,
    163,
    169,
    199,
    41,
    163,
    126
  ],
  "DELL_SMM_NB_PROTOCOL_GUID": [
    3522967299,
    26001,
    19177,
    167,
    149,
    197,
    98,
    140,
    207,
    82,
    54
  ],
  "DELL_THROTTLING_CONTROL_PROTOCOL_GUID": [
    719214768,
    53949,
    19175,
    185,
    24,
    233,
    170,
    161,
    164,
    89,
    133
  ],
  "DELL_NB_THERMAL_PROTOCOL_GUID": [
    941799526,
    57634,
    17342,
    135,
    125,
    74,
    199,
    114,
    157,
    110,
    120
  ],
  "DELL_MEMORY_THROTTLE_PROTOCOL_GUID": [
    2307134881,
    1777,
    19489,
    184,
    58,
    197,
    85,
    207,
    47,
    35,
    100
  ],
  "DELL_SMM_THERMAL_DEBUG_PROTOCOL_GUID": [
    3210975301,
    53318,
    17401,
    173,
    188,
    208,
    8,
    106,
    226,
    88,
    113
  ],
  "DELL_SATA_PORT_NUM_MAP_POLICY_GUID": [
    4035492656,
    55954,
    19455,
    171,
    188,
    115,
    228,
    33,
    119,
    164,
    61
  ]
}
```

`pics/hexrays_logo.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="184.559" height="50" viewBox="0 0 184.559 50"><defs><pattern id="a" preserveAspectRatio="none" width="100%" height="100%" viewBox="0 0 1094 294"><image width="1094" height="294" xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABEYAAAEmCAYAAABvdJXoAAAACXBIWXMAAAsTAAALEwEAmpwYAAAFFmlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNi4wLWMwMDUgNzkuMTY0NTkwLCAyMDIwLzEyLzA5LTExOjU3OjQ0ICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgMjIuMSAoV2luZG93cykiIHhtcDpDcmVhdGVEYXRlPSIyMDIxLTAyLTA1VDA4OjMxOjExKzAxOjAwIiB4bXA6TW9kaWZ5RGF0ZT0iMjAyMS0wMi0wOFQxMzo1MDoyOCswMTowMCIgeG1wOk1ldGFkYXRhRGF0ZT0iMjAyMS0wMi0wOFQxMzo1MDoyOCswMTowMCIgZGM6Zm9ybWF0PSJpbWFnZS9wbmciIHBob3Rvc2hvcDpDb2xvck1vZGU9IjMiIHBob3Rvc2hvcDpJQ0NQcm9maWxlPSJzUkdCIElFQzYxOTY2LTIuMSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpmZDE3NzQyZS01NDAzLTJjNDUtYjkwYi00OTU4Njg3NmI3NzYiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6ZmQxNzc0MmUtNTQwMy0yYzQ1LWI5MGItNDk1ODY4NzZiNzc2IiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InhtcC5kaWQ6ZmQxNzc0MmUtNTQwMy0yYzQ1LWI5MGItNDk1ODY4NzZiNzc2Ij4gPHhtcE1NOkhpc3Rvcnk+IDxyZGY6U2VxPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0iY3JlYXRlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDpmZDE3NzQyZS01NDAzLTJjNDUtYjkwYi00OTU4Njg3NmI3NzYiIHN0RXZ0OndoZW49IjIwMjEtMDItMDVUMDg6MzE6MTErMDE6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCAyMi4xIChXaW5kb3dzKSIvPiA8L3JkZjpTZXE+IDwveG1wTU06SGlzdG9yeT4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz66EO5FAABJcUlEQVR4nO3dT3IiSbb3/V+XtRnDl2cDXDRg3GjADLMKraDRCgqtINEKJK0AtAJRKxC1AkWZMWMgesxAcdlAxzNk9LwDdzJJpST+uEe4R/D9mJXdvlXSiZMpAeEnjh//h4Az1ZunbUltSVr0kzRkLgAAAACAMP4ROgGgbL152pU0lpTs/Otc0u2in0zLzwgAAAAAEAqFEZyN3jxtyhREhl982Q3FEQAAAAA4H7+FTgAoQ2+e3kt609dFEckUTgAAAAAAZ4KOEdRab54mkp5kZ4kc6IqZIwAAAABwHv4ZOgGgCHaw6pN+niMCAAAAAMBPKIygVuwckTtJo7CZAAAAAACqgMIIaqM3T0cyRZFm2EwAAAAAAFVBYQSVZ+eIjCV1w2YCAAAAAKgaCiOoLDtHZCxpEDYTAAAAAEBVURhB5dg5IiOZbTMAAAAAAJyMwggqpTdPhzJdIs2wmQAAAAAA6oDCCCrBzhG5E8fvAgAAAAA8ojCCqNk5IneShh7CzSS1xZBWAAAAAID1W+gEgM/05um9pFe5F0WWkq4W/eRaUu4YCwAAAABQI3SMIDq9eTqQmSPSdgyVS7pd9JOpYxwAAAAAQE1RGEE0evO0K1MQSTyEm0h6WPST3EMsAAAAAEBNURhBcPb43bH8zBFJJd0s+knmIRYAAAAAoOYojCCo3jwdyQxXbTqGymQKIqljHAAAAADAGaEwgiDs8btP8jNH5HHRT+4d4wAAAAAAzhCFEZTKHr/7JD9zRKYyw1VzD7EAAAAAAGeIwghKYeeI3EkaeQiXyhRElh5iAQAAAADOGIURFK43T4cyw1WbjqEymYLIzDEOAAAAAACSKIygQHaOyFhS1zFULulR0oRtMwAAAAAAnyiMwDs7R2QsaeAh3FTSA8fvAgAAAACKQGEE3tg5IiOZWSKuUpmCSOohFgAAAAAAH6IwAi/sHJE7+Tl+93bRT6aOcQAAAAAA2IvCCJzYOSJ38nP87oOYIwIAAAAAKBGFEZzEbpsZSxp6CDeT6RLJPMQCAAAAAOBgFEZwtN48vZf0Te7H7y5lCiKpYxwAAAAAAE5CYQQH683TgUyXSNsxVC4zWHXiGAcAAAAAACcURrBXb552ZQoiiYdwE5miSO4hFgAAAAAATiiM4FN2jsidzBG8rlJJN8wRAQAAAADEhMIIPtSbpyOZokjTMVQmM0dk5hgHAAAAAADvKIzgJ/b43Sf5mSPyuOgn945xAAAAAAAoDIURSJJ687QtUxBJPISbynSJ5B5iAQAAAABQGAojZ87OERnJbJtxlcoURJYeYgEAAAAAUDgKI2esN0+HMqfNNB1DZTInzUwd4wAAAAAAUCoKI2fIzhEZS+o6hsolPUqasG0GAAAAAFBFFEbOiJ0jMpY08BBuKtMlknmIBQAAAABAEBRGzsDOHJFvct82s5SZI5I6xgEAAAAAIDgKIzVn54jcyc/xu7fMEQEAAAAA1AmFkZrqzdOuzLaZxEO4BzFHBAAAAABQQxRGasZumxlLGnoIl0q6YY4IAAAAAKCuKIzUSG+e3svPHJFMpiCSOsYBAAAAACBqFEZqoDdPBzJdIm3HULnMSTMTxzgAAAAAAFQChZEKs8fvPsnPHJGJTFEk9xALAAAAAIBKoDBSQXaOyJ3MEbyuUpnTZpYeYgEAAAAAUCkURiqmN09HMkWRpmOoTKYgMnOMAwAAAABAZVEYqYjePE1kts20HUPlkh4X/eTeMQ4AAAAAAJVHYSRydo7IWNLAQ7ipTJdI7iEWAAAAAACVR2EkUnaOyEhm24yrVGawauohFgAAAAAAtUFhJEK9eTqU6RJpOobKZAoiU8c4ACLVaHW6cn+vkKRss15lHuIAAAAAlUJhJCJ2jsid3I/fzSU9SpqwbQaovbH8HNmtRqtzzJc/bNarex/XBQAAAEKiMBIBO0fkTtLQQ7iZzByRzEMsAAAAAABqjcJIQDtzRL7JvRV+KVMQSR3jAAAAAABwNiiMBNKbpwOZFvi2Y6hcpiAydYwDAAAAAMDZoTBSst487crfTICJzHDV3EMsAAAAAADODoWRkthtM2P5mSOSSrphjggAAAAAAG4ojJSgN0/v5WeOSCZTEEkd4wAAAAAAAFEYKZQ9fvdJfuaIPCz6ycQxDgAAAAAA2EFhpAD2+N0n+ZkjMpUZrpp7iAUAAAAAAHZQGPHIzhG5kzmC11UqUxBZeogFAAAAAAA+QGHEk948HckURZqOoTKZgsjMMQ4AAAAAANiDwogjO0dkLKnrGCqX9LjoJ/eOcQAAAAAAwIEojJzIzhEZSxp4CDeVGa6aeYgFAAAAAAAORGHkSHaOyEhm24yrVKYgknqIBQAAAAAAjkRh5Ai9eTqUKYi0HUNlMgWRqWMcAAAAAADggMLIAewckTv5OX73QdKE43cBAAAAAAiPwsgX7ByRO0lDD+FmMqfNZB5iAQAAAAAADyiMfKI3T+8lfZP78btLmYJI6hgHAAAAAAB4RmHknd48HcicNtN2DJXLzBGZOMYBAAAAAAAFoTBi9eZpV6YgkngIN5EpiuQeYgEAAAAAgIKcfWHEHr87lp85IqmkG+aIAAAAAABQDWddGOnN05HMcNWmY6hMpiCSOsYBAAAAAAAlOsvCiD1+90l+5og8LvrJvWMcAAAAAAAQwFkVRuzxu0/yM0dkKnPaTO4hFgAAAAAACOAsCiN2jsidpJGHcKlMQWTpIRbiNO7NU45YBgAAAIAzUPvCSG+eDmWGqzYdQ2UyBZGZYxzEryvppTdPpzKnC2VBswEAAAAAFKa2hRE7R2Qss8h1kUt6lDRh28zZGUoa9OYpP38AAAAAqKnaFUbsHJGxpIGHcFPRMXDumjLbsP7ozdOHRT+Zhk0HAAAAAOBTbQojdo7ISNI3uW+bSWUKIqljHNRHW9JTb57+IWbMAAAAAEBt1KIwYueI3MnP8bu3dAXgC4mkVzt/hFOJAAAAAKDifgudgIvePE168/RF5gjetmO4B0kXFEVwoKGkt948vQ+cBwAAAADAQSU7Ruy2mbHM4tTVTObJf+YhFs5LU9LdzvaaWdh0AAAAAADHqlxhxD6h9zFHJJN0wxwReNCW9Nybp6nM71QWNBsAAAAAwMEqUxjpzdOBTJdI2zFULjNYdeIYB3gvkdleM5H5HcuDZgMAAAAA2Cv6GSO9edq1c0Se5V4UmcjMEZk4xkG95Y7fP5IpkIycMwEAAAAAFCrajhE7R+ROZpHpKhVbHHC4a5nuD5ctW01J4535I6mPxAAAAAAAfkXZMWKftL/JvSiSSbpe9JMriiI4xqKf3Eu6kDR1DNWV9NKbp8+9edp2jAUAAAAA8CyqjpHePE3k5+jdXNKjXdwCJ7EzQm568/RPme6lxCHcQNKgN08fJE2YPwIAAAAAcYiiY6Q3T9t2jsiL3IsiU5k5IveOcQBJ0qKfpIt+ciXpRqYLycWdzPyRoWteAAAAAAB3QQsjvXnatMfvvsntabxk5ohcLvrJDU/jUYRFP5lKupT04BiqKempN09fbJcUAAAAACCQYIUR+8T8TeYJuotMZrDq1aKfLB1jAV9a9JN8Z/7IzDFcIjN/5In5IwAAAAAQRumFkd48TXrz9FVmlkjTIVQu8+T+0j7JB0qz6CfZop9cS7qStHQMN5T02pun9/Y0JgAAAABASUorjNg5Ik8yc0S6juFmMgWRe7bNICQ7f+RSZv5I7hCqKdM99dqbpwP3zAAAAAAAhyi8MLIzR+RV5sm4i6Wkq0U/ueb4XcTEdi1dSJo4hmpLerbzR7qOsQAAAAAAexRaGLFzRF5lnoQ3HULlMnNELhf9JHVODCiAnT9yK1MgSR3DJTLdI09srwEAAACA4hRSGOnN0649fvdJ7sfvPsgcvzt1zQsog50/ciUzfyRzDDeUOd733jEOAAAAAOAD//QZzD7ZHst9y4xknrjfsGUGVWW7my5683Qkt66ppqS73jz9Q+Y1kXpIDwAAAAAgjx0j9on2m9yLIpnMHJEriiKog0U/mchsr5k6hmrLHO/7wvG+AAAAAOCHc8eIPUFjLPctM7mkB7uIBGrFnp5005unjzKvl8QhXCKzvWYi85rJHdMDAAAAgLN1cseIPX73RdKz3IsiE5k5IhPHOEDUFv1kaeePXMt9/shIpkAydIwDAAAAAGfr6MKIPX53LLNtJnG8firpctFPbnnqjXOy6CczSZcyw4Vzh1BNSU+9efram6eJc2IAAAAAcGaOKozYIZJvMk+qXWSSru0ckaVjLKCS7PG+9zIFkqljuK7M/JFn5o8AAAAAwOEOmjFin0SPZRZfLnJJj3YxCEDmeF+Z+SN/ypxekziEG0ga9Obpg6QJnVgAAAAA8LUvO0bsHJFnSS9yL4pMZeaI3DvGAWpp0U9SO3/kRm7bayRTYHll/ggAAAAAfO3DwoidI3Ivs21m4HiNVOb43RueXgP7LfrJVOZ43wfHUG2Z+SMvzB8BAAAAgI/9UhixT5jfZJ44u8gk3dg5IqljLOCs7MwfuZA0cwyXyMwfeWL+CAAAAAD87HthpDdPu/b43SeZky5cPMicNjN1jAOctUU/yRb95FrSlaSlY7ihzPaae8c4AAAAAFAbv0mmKCIzRyRxjDeTnSPCthnAHzt/5FLSrdyP973rzdO33jwdeEgNAAAAACpt2zHyLLcukaXMHJFre8IGgAIs+slEZnvNxDFUW9KznT/SdYwFAAAAAJX1m10UtU/8/lxmjsglc0SActj5I7cyBZLUMVwis73mqTdPm46xAAAAAKByftPpnSKZmCMCBGPnj1zJzB/JHMMNJb315unIMQ4AAAAAVMpvOn1eQVvmSfPIVzIAjmfnj2yP980dQjUlje38kcRDagAAAAAQvd8W/WSp0582N2UWUq8spICwdo73nTqGassc7/vC8b4AAAAA6m47fPVabk+auzILqWcWUkA4dv7IjaRL+Zk/8tabp/fMHwEAAABQV79Jku0auZL7QmogFlJAcIt+srTzR27kPn/kTuZ1PXTNCwAAAABis+0YYSEF1JAdjnwpP/NHntg2BwAAAKBufnv/L94tpFw0ZRZSLyykgHDs9pp7mdf11DFcV2ybi003dAIAAABAlf1SGJF+WkhdSJo5XiORWUg9sZACwrHH+97IbJtbOoYbyJxKxba58JqhEwAAAACq7B+HfJHt+BjL/clkLunRFl2A0vXm6YtMse4rV4t+khafTVh2q9tY7gvrTNKD7TZDyRqtzv8LdOmHzXp17yNQo9Vpy3y+dCX9j8zJSE0d9pmT2X9ySf+RKfplm/Vq6SM3HKbR6nT142fWtP/69y++5W/7f3P9+JllBaQG4ACNVqepz99zK/H6tJ8lu/9s/X8yf7Zc5nNi19L+++VmvcoLTA84Gzv3BIeK4vV3UGFkqzdPRzLzQ5qO180k3S76ycwxDnAUCiM/s90eI5nXtatUpkCSeoiFA1WxMGI/MBOZhXOiYrpecpkb3r8lzSiU+GMXH4mkf8ksNhKP4VOZn9t/JKVVWIwBVdFodRL9KEB3dXgBetdSP95f/1dmQZN6SO8oO58j2/ehrqfQqXgPAg5iC6qJzOvvd/1alDxWrh/vMf+RqRksy7qHO6owIn1fSN3JLKZcpTIFkqWHWMBeFEY+Zre5jWW2yLiayryucw+xsEdVCiP2JvYPmd+xdiEZfS2X2Rr612a9mgW4fqU1Wp2BzE3PQOX+/DL9+LmlJV4XqLSdBcu2AN0t+JJLmfv6v4t4j7V/noGkf6u4gvpHMpk/F58dgH66n0tU7py7VPaBV1GvxaMLI1t2IfUkP0+KpmIhhRJQGPma3Tb3JPeFTy62zZUi5sKI7SwYynyAtgvP6HCZzGL7kaeBn7M3P99kFiPNkLlYucz9wp++nh7Zgs+zj1gOMkmXMbQRf8QuSF90/A1w6jmVh9DFsUar42Nb+SFuT/kdf1c8GHjN6Di5bDFBpmMvPyVIRH+erVyOBfZGqzOU+Ux0zeP9lqCtbLNeTT+5dlfh/x6X51hgarQ6I4X9HJ263O/Y1+JQ5p6g7SUjdzM5vse8d3JhZMvzQuph0U8mjnGAT1EYOQzb5qojxsLIzoJ6WGI+p5rJFEjSwHlEw964f1PcJx4tZX5uU9dAdrE7co3jaLZZr64D5/ChSP5+0s16dRU4BzVanUPuIXy4OuY9yRah7xRPEXNXLvN5MTn0GyL/82xlkv6UNDlmUdZode7lZ/vyZz59rdjF7ZvC/51enNNDCbuF7SVgCplOLL7b1+L2fq7pMSffZjIFy6lLkA9PpTnGop+ki35yIXO8b+4Qqilp3JunbxzvC4RlC5QXkiaOodqSnu2x3V3HWIhco9VJ7MLhVdUoikjmxvul0eq82JuXs9RodZqNVmfUaHXeZB52dAOntE9X0lOj1XmzhRwXD3I/qcvVwMOfwzvbUTMKnEYuKcqiUWiNVqfbaHWeZBa7Q8W5cHk8tCiy8xkS859nqy1T4HhrtDpPdgEZNbswfgidh8xnzDkpshB2iIdjiyL2nuBe5n5upLhfi5K5l3tqtDr/bbQ696e+Hp0LI1s7x/tOHUO1ZY73feF4XyAce2z3rczrOnUMl8gc7zvmeN/6abQ6bXtzXtbT1CIk+lEgaQfOpVR2Qf4mM2eoHTSZ47XlWCCxN4w3HnM61Tim3z37dDmGBcxNrNuMQtl5z425CJ3LdL7c7/tCW+B5UTU/Q5oyP4M3uyBrBs1mD1ukygKnkdiia+3Zz6UkYAqfbq36jP3ZvMlP53jZmnIoWHorjEjfF1I3ki7lZyH1xkIKCGvRT7JFP7mSeWKXOYYbybyuR45xEAn7RGH7dK8OElXkBteVfTq77RBpBk7HVVumQPJ6SuePnedw6zmnYzUVft7JrmeF/72YRDaPIAmdgJ1VEHNBRDIdWJf7tgPZp9LbAk9SfFqF2y7IRqET2SOGrpFx6ARKErxb5NAvtK/HZ8Xx3u/DUEcWSLwWRrYW/WRZwEJq6BgHgINFP5mxbQ47/mUX1aE/9ItyJ+mkRXbsdhYjL6peh8g+XZnOn/GxhS37JDX1n9JRurbYGJRd2CWB01gqjgVcFOzr9kVmQdkMnM5XZjKdItlXX7TTqTYsPKNyNWW6v17tvK3o2A6CLHAa7Rje64pk30fbAVM4uFvE/q6+Kvxw3iIMdWCBpJDCyJYduHgpPwupp948fWUhBYRVwLa5Z7bNVdJA9VtUv9eWXWSHTsSXnRbZYdhMCjfSaYWta7ndr/hwF3JBZa8dw+88W2gs+zN5U/hi1T7TzXp1/dXPbafAU4dOta90Zd6D7t/9+/8pP5UPxVB0/BbT9kGfbGE+9IOjg37G9r6gjg9K3hvKviY/e3BSaGFE+r695l6mQDJ1DNcVCykguJ1tc1dyf8I6kOkKu2fbHCI1sk//2qETcWELPHVpkT1EW0cWtiKaN/IcYitXRHNFTjquto5sZ8Wr4n/dTjfr1ZevnZ3CbFJGQpG4e/f50f7ia0sTSddIU3EUYYswUtjXbHpIt4h9fzmn+4KmfnQED9//x8ILI1t2ToHPhdQrCykgLHsq1ZXMQiJzDHcnts0hXl1VdGuNfUK7nSx/jraFreYhX2xnWkyKTOgAbYVZMIwV/kSi9JijXWuqK31ftMRQqNrnkKLIuRVmd3VlPj8GgfN4L4aukUEVP1e/snPcdEh7f7YVen8pQltmLtnLbodmaYWRrXcLqdwhVFO24sNCCghr0U+mYtsc6q8p04EwDJzHwXZa8LthMwmuK7PHuHvg18dwhO+wzIWUvdawrOt9IhdH80pSs0KLli+LIjsDHUflpRSlpkxhqBs2jR9sR0EaOA2pGr/nxwhdFEkPGHzcVX27dY6RyBQtm1KAwsiWXUhtBzm6aMsspF5YSAHhvNs2N3MM15XZNvfEtjlE6KkKc0fswupF5/mE9iNNmcJWsu8LI9pS81TGlhr7hDOGxcmX8ynOyL9UjUXL3qKIzHvQoKyEKqAZOoF3Yugaqc0gVvv5Mgycxpc/053XZbOMZCrgYfu5E6wwIv20kLqQ+0Iq0Y+FVNMxFoAT2W1z1zLb5paO4YZi2xziNLInu0Rp52lzM2wm0WnqwK6fMzvCN4bflcm+p5xnZKDwP499lnuKIl2Z2SjdshLC8exrLg2chmQGsTZDJ+FB9N0iOt8tbR/JtLN1NmhhZOvdQipzDDeUHeToGAeAA7tt7lJsm0N9DWMsjlSoBT+kpwOLIxOFXzQk9tjHQtgntUlR8Q+03KxXoYtQOFwmc8/+IVsUOYdTLuoihq6RpqrRJfUpux0xCZzGvm6RkcLnGJOfTj+LojCyZRdSFzJPaHKHUE1Jd715+tabpwMPqQE4UUHb5rqOsQBfhjFtq6EocpSDiiOK4wjfcRFH+NqYoZ9w5opj2xIOk+uLLU92WxZt+hUSUdfIsOKDWEPfC0y/6haJ5AjhmPzy9xVVYWRr0U8mMgupiWOotqRnFlJAWO+2zaWO4RKZ7hG2zSEWoxgGstqnVRRFjvO0r+AQ07wRn8HsTXIZ23T2eeBo3kr59Cjlnd+pZon5wI8Yukak8MWFk9hOjHbgNPb9DMfitbmV64OtslEWRqTvC6lb+V1IjVlIAeHYbXNXYtsc6ucp5FGMdnFPUeQ0LwcUR2YKf4Rv13N30ljhb+RnHM1bKVN7kskvdgY6dkvMB55E1DXSLXLrYBEi6cSYbtar7LP/aDu5hmUlUwE3H3W9RVsY2dpZSF3LfSE1kllIjRzjAHBQ0La5xENqgIu93QdFYMK8s6ak5wMG/8VwhO/IR6t5REfzxtCJg8Nk+noY8VgURaoultfjXcUGsY4U/vN3X7fIt1KyqIbUPuz4RfSFka1FP5nZhdSD3BdSYxZSQHiet8292G1zbcdYwKmaKul41XdoXXfX1p5tJRFtqTmkiPMpjubFiT58wip930YwLDMZ+Gc7DqaB05AqNIjVvp9G3S1iDUvIowpyffE5XpnCyNbOnIKpY6i2WEgBwe1sm7uUn21zb2ybQ0BdlXiTFMmJInWR2L/PT0V0hK9LYSOGQhpH81bLp0MdbZdcJRaxOEgss0aGITowTxC6KJJr/0k0A4V/z4/Fw1dFpMoVRqTvC6kb+V1I3bOQAsJZ9JMl2+ZQE6My5o3YLRWhb8oOsZT5rN7+swyWyX53B8wbmSj8XvzBKfvwbeGn6zuZI3E0b7Xk+qQYGNEAX3gSUdeIFHnBzX4GDwOn8XhAt8i/y0ikAtJ9M63+UVIiherN06HMzWHbMVQu6dYeL4oa6s3TF+1/unq16Cdp8dngK3ao6je5V7mXMq/r1DFOlBqtzv8LnQM+lEu6KGqrgF2QvCr88Mz3Ukl/2/+7/OrPb/8MXZn35N8VT+dLJunygNzfFPYpXC6TZ3bIF9ub+JcC8zlELumqqqfQnOn77e1niwk7DHhUajbYJ92sV1cuAez2kDc/6Ti7+Wzgb2iNVueQNUWRch1wn9Fodd4U7l4hlzST9JekbPe9334mNWXuA8q4B7jc99lTi8KIJNluj5FYSOELFEaqxW5zu5OfivxM5nWdeYgVjTO9Ua+KSVFPxiNbkGSSHmXa7fNTg9hiw1Dmc7ztnpaTh816df/VF9iuoNBPy5eb9epy3xdFVEj7dJFdBWf4fptt1quLj/5DJIU2/Mq5MCJJjVbnSeG7IaSCHzKcKpLf/0M+p9oKV+R6kLkPyg/5Yvs5NZDpcBn4zmXf35VUo8LIll1IjeXnL3Qq6aFuC6lzRmGkmuyg5Dv5qSY/SJos+knuIVZwNbxRT2VuhP7z7t//bv9vUmIuPlz5nqVgt3q8+ox5okzmZmPqO3Cj1RnKTyeoi4t93RiRFKgOuTl+lv8bzWPNNuvVdeAcnNTw/XafT5/WN1qdV4XflnWopX4+uKGt8EXCovgqjLRlPmearrE8KOwhw6kCd2FIh3eLDBSmgO/U6eP5QcmnBd73alcY2bILKR9Hh+UyT8Jqs5A6ZxRGqo1tc7+qwY36TKbFMj1iS0BX5nX8b8VfKPFyk7orgvZd6cCnL67sTIxQc1T2/uwi6sT4tABni0yhT6HJFeFT32PV4P1W+lEkWEr6v+/+224B+qtukZHinf+wlP1M0f7tfG39aOMfKPzr2AdvnzmB33/f27sNoiyRvKce9Bkc6GfotTPQw4OSgx9Q1bYwsmUXUmO5Vzwzme6RqWMcBERhpPp2ts35eKNPZV7XqYdYQVT0Rj2T6dyZuS6U7I3tUH62URblerNezXwEimD7Ribz51mWdUFbCHtWmEXL3huqSDp4Mn0wFyWip77eO6dCqPD77UzSX8f8DBqtTvOj9+dI5uu8l8k8xJwdWmD/iH0t/yHzmdJ0TysIb90Vkf2svT9kOEUkfyeZ9szB2gpQGCns53RigeSo10MlT6U5hi1kXMj9+Km2pCd7vG/XMRaAE9lTqe5lXtczx3CJzLHdTxzbXYpMpr3yYrNeOc2j2NqsV5l9arJ9n3eOWQCfT1ZDPqVdKsBTO3u9S4U5zWbvDaXNL/QRl219/LsRw9G8D3UoilTQVOb1erFZr26P/Rl88f48Uvjfqa1MPz5TJi5FEcm8lu0iKubPk33edwGdzP4OPPqK5ygp47S3A4wU/vf/4Yj7p9/3f4lXfxYV2N43Xki60WGvzVxHfjbXvmNkl134PMlPC/JUphU/9xALJaFjpH7OfdtchZ5glrX1oinzPj8o+lpHcp6sH7h9dynz1D8PdP3tz/ZF5c81OKjjJ5ItTt9zjWT+yUHDYauiIu+3U5n328x34Eielkt2wVP0IF/75x0rjiGkh/L6WRvRz1w6olOiCJF04B08L0Mq/3Nps16VUluwv5d3+voz7uhu3dp3jOxa9JNs0U+uJF3JvLhcDCW92SNFAQSy6Cfpop9c6vAK8meaMm+yr715OnDPDNZS5kbmvoyLbdar3A54dP198O0PDzFC7fVeKnBRRPr+9PJK5XeOfDvw62L4nXtqtDpte2LCKHAuuaRKD1utmKXMe+1NEUURa6TwC+SlzJ9zUvSF7OfJjczvcV709WIUWddIW2Hf1+4U/vc/dHfiV9KyLmRfm7f6/J5gdsoW5rMqjGzZhdSFpFt5WEj15ukbCykgrJ1tcxPHUG1Jz2yb82Ims6Beln1h251xpXhuZhO7WD2J/d62r2SOkMs8dckDXPsXNo+yCxAH/ezsYvSm8Gy+1pTpKgp9jLBkBvBloZM4Ew+b9aqMbW4+CrwupvbPmZV5UbvACrWdLwYTxfNZemc7N0pl588My77uO1kRp8BV2Wa9Sm1X4m7BKNeJn8VnWRjZWvSTifwvpNqOsQCcyM4f2e4PTh3DJTLdI0924CuOM92sV0EX1HaREFNxxGVRcWjXgm9FPn0+if25ll2AOOhnZxdQ00Iz2S9R+KeaM27gS5HLFC7vi76Q3crXLvo6X7ix3RtB2PfBEB1rwdnP8Zg6FUJsKY3hFKaYfgZRse+Bl7LD/U+99zzrwoj000LqUn4WUm+9eTpmIQWEU9C2uZFjnHMyDXkDuyuy4sjQ7os9in06NvCdzAFOakUtg81rVuIlj/nZ3cr9fafKMoXvnDkHuUxH3qyk6/27pOt8xHlGkw8Bt/MFZ7cuZYHT2Cp1EKvtGEzKut4n0hNfA0vPeXylXeK1fmGHJ1+4bLM7+8LI1qKfLO1C6lruL/yRWEgBwXneNje22+YSD6nV2VLm7zsaO8WRGAxK+h4fovo5fqDs/IaHfJFdPJ3zbI2bWLZe1ViuErcpBizOSmZL1jTQtX9xzsURxdWxUGYHR6ih57tO/bv3dkrRAdq2s6yyKIy8s+gnM7uQcj2mqykWUkAUdrbNTR1DtWWO92Xb3MdyRTSPYpddQMSw0D/lqWuIff3T2LbQvGfzm5Z4yYN/DpEc4RsCR/OWo+zZTYMSr7VrWsaQ1WPtFD/zsJmUyxaossBpbLUbrc590ReJYAuZZLpF0hO/N/OYxyHGdh5LJVEY+cSin9zL70LqmYUUEI7dNncjv9vm7h3j1E108yh22RvsWeA0Bsdsp7FPartFJfOFqizqy8yze8zQP7vnOS0qmQgtyzp96szdBhhoHaI4mymOYvaH7GfdOXaGxfTZ8K3IQaw7xzWH5vJ3nvlK4kBNSS9lbnXyicLIF3YWUldyv7kZyC6kmD8ChON529wdxZHvop1H8U4MR6oOCvpaX6LvFtkK0DWSHPn1Mfy+lSHXeS4SyzYru4PCLg67ZV7Tin5Lln2KPwmcRqki6xppqtjCxUjhB1m7dIsoUAdfU9Jzo9V5CXGCkAsKIwewcwquZG5wMsdwdzIFkqFrXgBOt+gnM5nuEddtc98odipXxE/2dkUyXf/3gr7Wl78CXNNFmfketRUqkiN8y8DRvMXLFeZ3KQlwzWmFtmS53kNUUejP0F2DQ45TP5Zd0Ic6DW6Xj7/rpYcYp0gkvdkCySBQDkehMHKERT+Z6sdCykVT0pOdU5A4xgJwItsVdi/zup6eGKapME/TYvJYpUVRBNP1kyO+dlBQDp/JK9L5813J+SbHfkMkR/gWiaN5y/EYqIOi7OJsrrgW3l+yP5NKPBjwxb7e08Bp7CpiOOqdwneL+CoQhn7Ykch0kLw1Wp2oZ5BQGDnSzkLqQu571ROZ+SNPzB8Bwln0k0zSnzq/pz4+5KpmK3HIG+/2Ie2lRTwFO8AywDV9SEu6TvPEm7q6HuGb6Tw6YkLLAs5vSUq+3qxKhXYpuu0lZYmpeOV1EKv9fB76iufA19/x1FMcV22Z7UmvO0WSQdCM3qEwcqJFP8kW/eRafo7sGkp6Zf4IUL7ePG335umzpBed/nQg85ZQ9cxi3wf+EXsjmwdMoevpa3z7O8A1fSgz7+TYb6jxEb7Rz4GoiceA1+6WfL2YFtzH+DN0AmWynQxp4DR2fTtmsPkeMRzP623Wl42z9BHLo7ZMkeS50er8t9HqPDdanaHHn+FJKIw4svNHLuU+YK0p07b12punA/fMAHylN0+bdnDqm9y2K6S24+RchbxhdzUNeO3uAV/zr6KT+MAywDV9yEq81v+c8k01PMKXo3nLkSvQe1WArrXKdYvsmIZOIICY3s+a8jCI1f7OJ65xPPD9dxvzvVpT5j78SdJ/7UySUYjBrRRGPLHzRy7k3lLelvRs5490HWMB+IAdfvwmU4x0sVQ9nwIfKgtwbKRPIZ/wHbJvv1t0Eh/IA1zTh6zEa3VP/cYaHeGbcjRvaUJ25XVLvl7oWQgnswWdWeA0ShVh18jQQzEvhuN5vZ8MV7HtXonMz+Gt0eq8llkk+WcZFzkXi36SS7rtzdNHmapX4hAukekemUq6tbEBOLDDjsdyv9nLZarvkzN/bc5CJ+Bis14tG61OJlOQLlvzgK/pFpzDh9dstDoBLuusW+K1Esfvv5H0qvCD/U6Vi7kiZQpZLGiWfL1Zydfz7W+FOWI9pAfF0WGxNZYZqH+0RqszVPhh+rmK68S5kdk2XiVd+8+40eosZR5oTYsqFlMYKYBtq7+yi7Anud10DyUNevP00Q59BXAkO9z4Tn6Gac1kipWZh1hVV9mneztShRmy1v3qP4ZoIbVieFpWa5v1Kmu0OjeSnkPncqKbCm93qKI04LXLPJEmrcG8mjR0AmXbrFdpo9VJFU9xpNtodUb29LmD2dkWrl3EPhR2yp/9WU0Vx2DZU3T1o0gylfm7Wvq8AIWRAi36SSrpojdPR3I79qkp6a43T/+QdGPjAtjDDjMeyZxF33QMt5QpiKSOcWqjJvMF/lacNwnt0Angc41WJ3H5/d+sV7OK3qBOfR2P3JunPrr3TrVc9JMqHLG6rEGx4FBVHfz8ne1CzFXdbrBT3cp0wcXirtHqHNtVMFL4z91cxZ/yd6sfBYYqG8psnUrlcd4VhZESLPrJxG6JGcvtJqgtc7xvKlMgyVxzA+rKzhG5k/sHXS5TEJk6xqmbZegEPMlCXdh1cY3Ku5V5ytoOm8bBMpmcfekqnqfMscoDXz8p8VrLEq9VpKXO7PfaFoSmiqfQ25RZcx205c92i3wrMJ9DPRZdCN2sV7ntWHQ5iTEmiaTEFkicuxkZvlqSRT/JF/3kRmbfW+oYLpH01punY473BX7Wm6fd3jx9kfs2Nsns87ygKPKhPHQCPkRcmEhCJ4AvtV0DVPAI3+sz6l5A+bLQCXiyDJ1AIDGdUCOZboLugV87VvgiQa7iu0UkfT8h7Uo1uY+zEplhrWOXI38pjJRs0U+Wi35yJXMzlDmGG8kUSIaOcYDKs8fvPsm0cyaO4VKZgsj9mQ9X/Url254BB20fQSp0hO9DxU+gQuRq9Pv1f0MnEIJ9Uj8NnMZ7e2dm2Xlew8Iz2a/wbpFdNS2OSGZt/Hrq6UQURgJZ9JPZop9cyNwQ5Q6hmpKeevP01Q57Bc5Ob57eyxy/O3QMlUm6WvSTK7aqnZVl6ARwvipwhC9H8wI4RGxF3sSeNPOVpzIS2SNTSd0iu3aKI8uyr12wtqSXRqtzf+w3UhgJzJ40cyn3KmtXZv7Isz2BA6i93jxNevP0TW7DjaUfc0QuGK56lvLQCeDs3SjO38NcHM0LHGMZOoFQYu0a+Wxrhe0qSMpM5hMPobYp7hRHZiGuX7C7RqvzcszWGgojEVj0k8zOH7mS+1Ojgcz2mnvmj6CuevO0beeIvMi9pX0qs21m4hgHAE5iFxQxFiA4mhc4Th46gcBi6xpp6vNjeGM4nj7brFfTkAls1qt8s15dy4x5yEPmUoBEpnukecgXUxiJyKKfpHb+iI8nR3eSXpk/gjqxc0TGMttmEsdwqaTLRT+5YY4IgAikiuumNFfcW3yAGCWhEwjJFlJjK46M3g9itVtsuh99ccmi+buyR7FfKL6uH1ddmcGs3X1fSGEkQvYEjO38ERdtmfkjL8wfQdX15ulIpiAycgyVSbq2c0SWjrEAwJcnhT8ZYVdTnz9pBYDPTBRXkVfa6Q6x3QMxvLcF7xZ5z3aP3MisQ9PA6fjUlPS8r3OEwkik7PG+9zK/mDPHcInM/JEn5o+gauwckVe5H6eWS3qwc0RmHlIDAC/s08tB4DQ+Mmq0OoPQSaD+7OkgqAE7L+MxdB7vJDvvZSN5OlnMUTTdIu9t1qtss15dyYx5mAZOx5e29myroTASOTt/5Fp+pgYPZbbX3DvGAQpn54g8y8wR6TqGm8psm7l3jAOUJQudAL609BXILghj2Ov+madjhtcBJ2qHTsCT30MnEImJIuwase+330InInPa1zR0Evts1qt0p4Nkqvh+psfq6ovPWwojFWHnj1xKupX78b53vXn61punAw+pAV7ZOSL3MttmBo7hUpnjd284fhcVk4VOAF/KPcZ6VlxbaN5ryuSI87Ms8VpJidcqUjt0AjGItGukLfOwrRk2DUkRd4t8xHaQbAskN6r26UvDRqsz+ug/UBipGHtyxoXcz7tuS3q280e6jrEAL+yw4O3xuy4ySTd2jkjqGAsA3st8BGm0OveKYwDgPslnN5KotbzEa/2rxGsVwnYjtAOnEZOJ4uswaIdOQKZbJA2dxCnsDJLpZr261I/1aBY0qdPcfbR9j8JIBdn5I7fyMxgnkdle88TxvgjFzhF5kZ/hgw8y22amrnkBoVT1pulc+DjCttHqJIpjAOCh7g6Z6o9ayUq8VlLitYqShE4gJpF2jcSgUt0in7FdJLeb9epC0qWqVSRp6oMtNRRGKszOH9kOxskcww0lvdmTP4BS2DkiTzKtjYljuJmki0U/uef4XdREHjoBfGjpGsDO7HhyzqRcTVUvZ7j53xKv1azBoF/mi7yzWa/uVZ3Fchkq2y3ylc16taxgkWRgH1B8989AicAju1Xgws5l+KbTn7g3JY178/SbzDaE1EN6wC9sd9JIbr+vW0tJt/y+ooaWKv8JZK5q7x0uw98eYjwpjpbuY3Ubrc54s17deoh1q3B7/fNA162aVOV2Nf1b7icxBmGLnYPAacTqQRRVt2rRLfKVzXq1lL03t12GiaQ/FOe20Tvt7L6gMFIji35y35unE5nWoKFDqLbM8b6pTIEkc80N2LJDf8dyXxTkMgWRqWMcIFZ/q/zCSFPStW2BRgEiPpr3UKNGq/OX61PPRT9Z+kkHBVqWfL1Bo9W5rej7z0BxDPWMzma9mjZanTtVsxjs07SO3SJf2SmSTOxMj6FMkaQdKqd3kkar095uj2UrTc3Y+SM3Mm1MqWO4RGZ7zT3zR+CqN0+7do7Is9zfECcy22amjnGAmC0DXXcU6Lq1V4GjeQ/FEb5nwBYoshIv2VR133+qNC8ohNp3ShzgrP8O7EySe7vd5krxdId9P76ZwkhNLfrJ0s4fuZb7h9qdTIFk6JoXzo89fvdJ0qvcn36nMgWRW+aI4AwsA133j0DXPQexH817qLZojT8Xy5Kv961qRTc7p6AdOI2obdarqeKfOVGkqY+h3XWxWa/SzXp1LT8HibgabP8HhZGaW/STmUz3yIPc9tQ2JT315ulrb54mzonhLNhhvm9y29olmQ/TK3v8buYYC6gEexOVBbh02x4jC48qdDTvoQZ2WxDq7a+Sr9dU9bpGKBIe5pw7Js75z/4p20WyfZCfB0qjvT1xjcLIGbDba+5lCiRTx3Bdmfkjz7152naMhZqyx+++ybSMNx1C5ZIeFv3kguGqOFOzQNet3FPbmNmbrjq22o/t9iDUVxrgmt+q8nvVaHVGolvkILZrZBk4jRDoFtljs17NZLbX5IFSSCQKI2fFHu97I/OLt3QMN5D0yvwR7LLH777IHL/bdgw3lT1+1zEOUGU+TkA5RVP1mIURnC0wPYfOoyBN1ffPBn3vXFuWfNmmKtCFYYs3dSx4FsnHiVZVkotukYPYQa2hiiO/SxRGztKin6SLfnIp6Ubu22vuZAokQ/fMUFV2jshYZttM4hgulXS56Cc3zBHBubNPUfJAlx82Wp1BoGvXiY9TuGLWZetV7aUBrpnYboyY1WVmUGnsqSxp4DTK9Bh7t0ij1Wk2Wp3XGLZG2uJIiEJSV6IwctbsiR4Xcv8FbMvMH3lh/sj5sUWxN7nvCc4kXds5IkvHWECdzAJe+6kqLe0xsoWlYeA0ynC33aONWvoz0HXHsf5eNVqdJ9VrZlCZzqWDIpc5RTFatqPxReZ3+SmS4shE5T8QaksURs7ezvyRC7nffCcy80ee2F5Tf3aOyKtMu2vTIVQu8yF5aYcFA/hZ2cMPdzUlPTNv5Hi2oBT9dgCP+D2pKfsUdxno8i+xFUcarc5Y51HwLMQZdY082iOvo/SuKLIVRXFEAR4INVqdNoURSPo+f+RaZm9X5hhuKHO8771jHETIzhF51q9vpqeYyhRE7tk2A3zMbqfJAqbQlVmcNAPmIOn7ENOqcC0aV01bzKWps8dA120qouKI3d4zCpxGHdS9ayRXxN0inxRFtmIojvwnwDUpjOBndv7IhcxwpNwhVFPSXW+evvXm6cBDagjMzhG5l9k2M3AMl8ocv3vD8bvAQUK1sm91Fbg4YlvXXxutTvSdCXbmRhI4jRCYS+NXqOHLH5kp3Lyjpsz7TxLo+pK+vwdR/PPgDLpGou0W2VMU2Xqyv++hLENclMIIPrToJxOZ7TUTx1BtSc92/kjXMRYCsXNEXuU+fT2XdGPniKSOsYBzMlG4RclWV2Zx0i7zonYw3It+tK4PJL3FugCv8dG8h2IuTQ3ZRd40YApNmfefUdkX/uA9CH7U9YSaTJF2ixxYFNkaNlqdUA9EQlyTwgg+Z+eP3MoUSFLHcInM6TVj5o9Uh50j8iLTEt52DPcgc/zu1DUv4NzYRckscBqSuZl6LasoYZ8Qv+rX7oumzEyLqLpHan4076GaOq/ZKuck1HaaXWO7WGuXcTH7XufjxD28Y2fXTAOnUYSHGLtFjiyKbCUyn/mJ/4y+1C35epIojOAAdv7IlaRrue9zH8nMHxk5xkGB7LaZJ5k30MQx3EymIMIcEcBNLHuymyq4KGGf0G7fg9pffOlAcXWPxHA070ThBmVuVeGoVRzJHjs6DZyGZO5L3hqtzn2B70Ft2yXCkbzFiuVzzZdss15NQyfx3olFka22TLfWuMQHEf8u6To/oTCCgy36yczOH5k4hmpKGtv5I4lrXvBrZ47I0DHUUmaOyDVzRAB3dlEyCZzGroE8L05sQeRex70HNWUKNWXetP0ikqN50816dSvpJnAeUsRHrcJJTAvZO5n3oLGvDpJGq5PYoixdIiWIqNjmS0yvD0nORZFdI5XQMWo/N7pFXuMjm/UqpTCCU/g6OrItc7zvc2+etj3FxIl683TQm6dvMjcaTYdQuaTbRT+5ZI4I4N2Dws8a2dWUec/4b6PVeTr1hqnR6gzsYuS/Ov09aKQwLb/bG8/Q20cymc7ObYt6DDfoTzFtdYI7u5CN4XdrqynbjdxodV4brc7o2IKcLYaMG63Om8wCcug7SXwppt8nF9F1i3gsimy1ZR5EFDkMOcRnaS5J/wxwYeC9gaRBb54+SJqw3aJcdijuWH6ejEwkPfAzBIqxWa/yRqvzqDiHew5lhrXlMnOp/iPTOZZLyjfr1dI+1W3LLGa6kv4l897T9JRDW6bld6Jy93mHbrfPJV3v/nk369V9o9X5XWGfendlflfrOmTxXE0kfVN8W0y69h81Wh3JvA9lkv73g6/9l8z7Rbf4tPCVzXqVNVqdqapfkIqqwFNAUWRXIrNlMpU5gWfmGtDmO1aY1+RSojCCuNxJ+tabp7cM6CyeHYJ7J/OkxVUqc9pM5iEWgC/YBe+/Fe8NfVO24L37L+1CpSwjSYNGq3Njj4UsjJ2lkRR5jQPc2i6R925khtc2S83mZ6NGq/NX0T8HlMcWaG8VvktqnyR0AjjYg6pdGElj6hYpuCiyK5EpkGQyMwX//OSz6Eu2+8THQQ+n+ltixgji05T01Junr8wfKY4dfvsm96JIJunaHr+bOcYCcDiewO/XVsED42zL/riI2EeYfHZDbrc9xDBvJKrTg+DO/s6lgdNATUS4RetY0eReYlFkV1s/trO+2a21o6+229gtbKNGq/Oq/YPWizaT6BhBvLoy80emMlszsqDZ1IQtNvmoyOaSHhf95N4xDoATbNar1G4XGQVOpQpGKqB7JJK5Itthq5/arFezCNrUmzJ/V9cBc4B/MXQkoT4minOL1j5pLB1xgYoi77W183lTcrfoKbJtlwsdIyjSldyPDBxKeu3N03u79QMn6M3Tdm+evshPRXYqe/yuYxwAbh4U/ljWqmjLf/fIncLefGY6vNBwa78+pAFH+NZLRB1JqAE7I+kxdB4niKJbJJKiSBXNtv+DwggKs+gn6aKfXMp8aOYOoZoyN6CvvXk6dM/sfPTmaXPn+N3EMVwq6XLRT24YrgqEZ28iXd9fz81IHk6usafvjNzTcXJ96HBZ+3UxdGvccYRvvdihi9PAaaA+JqrWZ1oU3SIURZx8L8ZRGEHh7CDVC7lXVNsy80de7Ekq+IItIm2P33WRyQxWvVr0k6VjLAAe2fZP5o0cpy2H7pFIttDcHDvgLpIjfJsK/3cH/25F9xo8qGDXSOj3VIoibqa2800ShRGUZNFPcrv14kLuw7oSme6RJ7bX/Ko3T5PePH2VuflsOoTKZd7wLzklCIiXHYI4CZxGFY10WvdI6KN5p6eefrBZr+4VfmBmt9Hq3AfOAR7ZxeyVqvWkH/GaqBq/S9PQ3SIURZz9VISjMIJSLfpJtugnVzIfoJljuKGkN7tV5OzZOSLP8vMGOZUpiNyzbQaInx3AOQ2dRwW1Jf370C+O4Gje5Wa9cp3pEMP2qzvX7UyIC8UR+FKhrpHg3SIyn0fdwDlU1fR95yWFEQRh549cyLRf5g6hmpLuevP0rTdPBx5Sq5ydOSKvkgaO4ZaSruwckcwxFoBy0c5+vOm+U122IjiaN5dZeDqJaGDmE0f41otdZDj/jgK2uy0LnMZXftqCEYqd8RPD+3nV5PpgGzKFEQS16CcTme01E8dQbUnPdv5I2zFWZdg5Iq8yc0SaDqFymTkil4t+kjonBqB0O09sl2EzqYzpkd0XoWdjXB06bHUfezM98xHLQVvh/07hmS2OsFCDDzF0ZHwmmtzs1kpec8e5+ejzlMIIgrPzR24lXcrP/JG33jwd13n+SG+edu3xu09yP373Qeb43alrXgDCojhysNkxRZFGqzNW2Hblo4etHhJT4Z/IDhqtzjBwDvBsZ6GWh80EVWZ/j7LAaXwkim6RXfbv6lq85g4xtQ8HfkFhBNFY9JOlnT9yLfc3wpFMgWTkGCcqdtvMk0yXSOIYLpUpiDBHBKgRiiN7TTfr1cFH19pZGKPCstnv5GGrX9k57jm0caPVaYdOAn7Z31lmjsBVNJ0ZVq74cpL0vROQz/6vLfXFSX4URhCdRT+Z2fkjD3KfPzLuzdPX3jxNPKQWlJ0j8iYzdNZFJjNH5Io5IkA9bdarfLNeXYqBrO8dtX3GzsB4Li6dvZYq8Dhme6JC6Jv8pthSU0s7M0eysJmgqiLsGnmMrVtk185rbhY2kyjlkq6/2pJKYQTRssf7+rix70p6sSe2NB1jla43Twe9efomP3NEbhf95II5IsB5sEWA0AvfWNyecKKL67HnLnLtuYnzwQ45XBZ5jQMkHOFbT3ahdqnwv2MxmCr8cdlVFMtnWC73mYiFsw9GruV+wEWd5DJzurKvvojCCKJmj/e9kal+po7hBqrQkVb2+N0XmaeVbcdwE5ltMxPHOAAqxi58z3nvcS5zQzQ55pvs0bwD/+kc7LrEJ5Mx/H7c2ZN/UDM7HWyT0LkEksvMCYph61rl2K6RZeA0JNMtkodO4lD2M8/H+qnqcpl7gOW+L6Qwgkqwx/teKY5hcYWyc0TGMttmEsdwqaTLRT+5ZY4IcL7s3uNzfGqbSrq0W0YOZhfodwXkc6jbY3N2YQswhW3ZOcIzR/jWlz0a+9zmjixlFmXTwHlUXej3p1wVLOxt1qvlZr260vl2j+Q6sCgiURhBxdiTUy4VT1udV3ZY7JvcB/1lkq7tHJGlYywANbBZrzL71LaW758feNisV3tbZz8RcgvN9NjuFh/swm1W9nXfaUsaB84BBbIFvwuF/10rw8Nmvbos4ESpc5QHvn6lukXes58pFzqvuWNLSRfHvP4ojKBy7PG+96rRB2tvniZ2jshY7nNEHuwckZmH1ADUjN1a4+N49FilMjdD96d8c+CjeZcK+2Q0hq7MYaPVGQTOAQXamYFQ18GsqUyn2n3gPOokZME0UwW7Rd6zr7sb1fvzf2tii5L5Md9EYQSVZeePbD9Yl4HTOYmdI/Is6UXuc0SmssfvOsYBUHM77bUxLIR9yWT28Z/aJRL6aN5cJQxb/UpER/g+saWm/jbrVbpZr3ycQhiLTOY1fHDrPvaz78tJwBQeqtwt8t7O538d54/kMq/Bkx4wUBhB5dn5I5cyN3N54HQOYueI3Mtsmxk4hktljt+9YY4IgGPY7RPb7TV50GROl8vcuF647OOP4GjemxiOgYzoCN+QPwuUyHZWVLlAksm8fi/sPCf4FXLeU1bX+TC2MHml+myxmch0i85ODUBhBLVh549cKPJ2t948HcoURFzf6DNJN3aOSOoYC8CZsu219zLvn7eqTgdJJpPvydtm3gk5V+QhpgVVREf4jgLngJJU9H1oqR8FkWngXGophm6RgNcuhZ0/diPp/8i89pZhMzpaKrN17da1s+efXtIBImE7Jm578/RR5iY3CZrQjt48TWT2SHYdQ+WSHiVN6BCBwrVBZoGuW4RloOvmga77IXtDMZE0abQ6Q0l/KKL30B0zSX/6LCTYP+/AV7wjzSKdRXAjs82zGTCHcaPVmcXQSYNyvHsfGkj6t6RhuIx+kcu8Bz2yXaYUQWeLnFPB691rrytzDzCQ+1b/oqQyDxVSXwH/4SsQzodd4L/s+7pFPwn++3Voru947cDozdO2THfI0EO4maTbRT/JPMQCgC81Wp22zI3RHwo3kFQyxas/ZYoIWcA8AGf2ddU+4Eszft+/b3MbyBRJEpVfrMtl7r/+ci3I2gVn0zWhL9Tmd8YWrJ8CpnBzToWRz+zcB2xffyHlMtt+Hov4PQ++cEX1VKww8qTjChL5op/8H0/XbsoM8fsm9w/BpUxBJHWMAwAn2bk5+l3FL05ymadBf0lK63KjD8DdzvaK32UKtk3Pl8hl3n/+lnn/WXqOjwM0Wp03hetW2M7fwDs7r79/ybz+2gVfMpMpTP5d9JZTttKgtuxw0+GR3+blmMTePB3ItP+1HUPlMgWRqWMcAHBiixMT+8+2UJLIvM/9LrM46Z4QeinzXve3/d9LCiEAPmNb59Pt/7/TgZPYf/X7zpcn+li687//lnkPWsq8/+SuOcKN7RZpB0yh9rNFTvX+9Sd9L5a07T//krkf2P7/x8jsP0HuB4I/0Uf1VKFjxA44Pbb97sa1ANGbp12ZgkjiEseaSHpgjgiAqrE3SV/JeQoLAHjPbp16Fd0itfLVNjKfc0Jc0DGC2jmxKDJxKYrYbTNj+ZkjksoUaTIPsQCgdLHc5AAAKmckukVqpwoPQyiMoFZOLIpMF/3k5C00dsuOjzkimUxBJHWMAwAAAFSK7Rb5FjCFlML++aIwgtpwKIrcnHi9xF6vfcr378hltsxMHOMAAAAAVTVS2CPC6RY5YxRGUAtlFkXs8btP8jNHZCozXDX3EAsAAAConAi6RaZ0i5w3CiOovLKKInaOyJ1MNdtVKlMQWXqIBQAAAFTZnegWQUAURlBpJRZFRvLzhp3JFERmjnEAAACAyrNHLo8CpjDlmHhQGEFllVEUsXNExpK6R17nvVzS46Kf3DvGAQAAAOrkLvD16RYBhRFUU2+eDlRgUcTOERlLGhx5jQ+vKzNcNfMQCwAAAKgF2y0yDJgC3SKQRGEEFdSbp10VVBSxc0RG8lO5TmUKIqmHWAAAAEDdjANfn24RSKIwgoqxRZEXHTfrY3lgUWQoUxBpn5DarkymIDJ1jAMAAADUUqPVSeSnO/tUD3SLYIvCCCrj1KKIpKs9cROZgkhyUmI/e5A04fhdAAAA4EshZ4vkkiYBr4/IUBhBJbgURT4rUtg5Infys69xJnPaTOYhFgAAAFBbtlskCZjC42a9ygNeH5GhMILoFVQUuZf07ciYn13nljkiAAAAwMHoFkFUKIwgar6LIvY0m7Hc54jkMnNEJo5xAAAAgLPRaHUGolsEkaEwgmj5LIrYWGP5eROeyBRF8j1fBwAAAOBnIU+iyUW3CD5AYQRR8lUUscfvjuVnjkgq6YY5IgAAAMDxGq3OUO6d2y5u6RbBRyiMIDp2KKqPoshIZv/iMXE+kskURFLHOAAAAMA5CzlbJNusV9OA10fEKIwgKrbD41kORRF7/O6T/MwReVz0k3vHOAAAAMBZa7Q6I4XtFnkIeG1EjsIIomGLIi+Sukd8Wy5bFLGdJk/yM0dkKnPaTO4hFgAAAHC2Gq1OU3SLIGIURhAFl6KI/f6xpJGHVFKZgsjSQywAAAAA5j69GfD6dIvgSxRGEJxjUaSr4+eRfCSTKYjMHOMAAAAAsGy3yLeAKSzpFsE+FEYQlENR5EFm28wx3/dZrEdJE7bNAAAAAN6NFLZb5DbgtVERFEYQzIlFEckUM3ycfz6V9MDxuwAAAIB/jVanrbCzRdLNepUGvD4qgsIIgnAoikju06xTmYJI6hgHAAAAwOdCFkUkZovgQBRGUDrHooiLXGaOyLTk6wIAAABnxXaLDAOmQLcIDkZhBKUKWBR5EHNEAAAAgLLQLYLKoDCCso1VblFkJtMlkpV4TQAAAOBsNVqdrsJ2i8zoFsExKIygNL15+qTy3iAzSTfMEQEAAABK5+OgBBecRIOjUBhBKUosiuQyg1UnJVwLAAAAwI5Gq5NISgKmMN2sV1nA66OCKIygcCUWRSYyRZG8hGsBAAAA+BWzRVA5FEZQqJKKIqnMtpms4OsAAAAA+ATdIqgqCiMoTAlFkUxmsOqswGsAAAAAOMxT4OvTLYKTUBhBkYYFxc0lPS76yX1B8QEAAAAcodHqDCW1A6bwQLcITkVhBFUzlekSyQPnAQAAAOCHkLNFcpl5g8BJKIygKlKZgsgycB4AAAAAdkTQLfK4Wa/ygNdHxVEYQewymZNmpoHzAAAAAPBOo9Vpim4RVByFEcQql/QoacK2GQAAACBaI9EtgoqjMIIYzWS2zWSB8wAAAADwCdst8i1gCrnoFoEHFEYQk6VMQSQNnAcAAACA/UaSmgGvf0u3CHygMIIY5DIFkWngPAAAAAAcIIJukWyzXk0DXh81QmEEoT2IOSIAAABA1YwVtlvkIeC1UTMURhBKKumGOSIAAABAtTRanbakYcAU6BaBVxRGULZMpiCSBs4DAAAAwGlCHs8r0S0CzyiMoCy5pIdFP5kEzgMAAADAiSLoFlnSLQLfKIzgFNmRXz+RKYrk3jMBAAAAUKZx4OvfBr4+augfoRNANfXm6YukZM+XpTKnzSyLzgcAAABAsRqtTiLpJWAK6Wa9ugp4fdQUHSM41a3Mm2Lzg/+WyRREZiXmAwAAAKBYzBZBLdExgpP15mlb5s0xkdSWtJT0J3NEAAAAgHqhWwR1RmEEAAAAAPClRqtzyFb6Il1t1qs04PVRY7+FTgAAAAAAEK9GqzNU2KLIjKIIikRhBAAAAADwldCzRTiJBoWiMAIAAAAA+JDtFmkHTGG6Wa+ygNfHGaAwAgAAAAD4TOhuEU6iQeEojAAAAAAAftFodUaiWwRngFNpAAAAAAA/abQ6TUlvkpoB07igMIIy0DECAAAAAHhvpLBFkQeKIigLHSMAAAAAgO8i6BbJZbpF8kDXx5mhYwQAAAAAsGuksN0ijxRFUCY6RgAAAAAAkqRGq9OW6RYJJRfdIigZHSMAAAAAgK3Qx/PSLYLS0TECAAAAAKBbBGeLjhEAAAAAgBS+W+SWoghCoGMEAAAAAM5co9VJJL0ETCHbrFcXAa+PM0bHCAAAAAAgdLfIQ+Dr44zRMQIAAAAAZ4xuEZw7OkYAAAAA4LzRLYKzRscIAAAAAJypCLpFlpv16jLg9QH9M3QCAAAAAIBgMklXga8PBPX/A49hc683yB6kAAAAAElFTkSuQmCC"/></pattern></defs><g transform="translate(-60 -95)"><g transform="translate(60 95)"><rect width="183.016" height="48.853" fill="url(#a)"/></g></g></svg>
```