Project Path: arc_gmh5225_BetterHI3Launcher_mokw2gi_

Source Tree:

```txt
arc_gmh5225_BetterHI3Launcher_mokw2gi_
├── App.config
├── App.xaml
├── App.xaml.cs
├── Assets
│   ├── Fonts
│   │   └── FZLanTingHei-B-GBK.ttf
│   ├── Images
│   │   ├── BackgroundShadow.png
│   │   ├── Button.png
│   │   ├── Button_Box_Close.png
│   │   ├── Button_Box_Close_Highlighted.png
│   │   ├── Button_Box_Close_Pressed.png
│   │   ├── Button_Close.png
│   │   ├── Button_Close_Highlighted.png
│   │   ├── Button_Close_Pressed.png
│   │   ├── Button_Disabled.png
│   │   ├── Button_Minimize.png
│   │   ├── Button_Minimize_Highlighted.png
│   │   ├── Button_Minimize_Pressed.png
│   │   ├── Button_Pause.png
│   │   ├── Button_Pause_Highlighted.png
│   │   ├── Button_Pause_Pressed.png
│   │   ├── Button_Preload.png
│   │   ├── Button_Preload_Checkmark.png
│   │   ├── Button_Preload_Circle.png
│   │   ├── Button_Preload_Highlighted.png
│   │   ├── Button_Preload_Pause.png
│   │   ├── Button_Preload_Pressed.png
│   │   ├── Button_Preload_Resume.png
│   │   ├── Button_Pressed.png
│   │   ├── Button_Resume.png
│   │   ├── Button_Resume_Highlighted.png
│   │   ├── Button_Resume_Pressed.png
│   │   ├── Checkbox_Disabled.png
│   │   ├── Checkbox_Off.png
│   │   ├── Checkbox_On.png
│   │   ├── HoV_Dance.gif
│   │   ├── Icon.ico
│   │   └── Window_Dialog.png
│   └── Sounds
│       ├── Click.wav
│       ├── Window_Close.wav
│       └── Window_Open.wav
├── BetterHI3Launcher.csproj
├── BetterHI3Launcher.sln
├── DialogWindow.xaml
├── DialogWindow.xaml.cs
├── FodyWeavers.xml
├── FodyWeavers.xsd
├── LICENSE.md
├── MainWindow.xaml
├── MainWindow.xaml.cs
├── Properties
│   ├── AssemblyInfo.cs
│   ├── Resources.Designer.cs
│   ├── Resources.resx
│   ├── Settings.Designer.cs
│   └── Settings.settings
├── README.md
├── TextStrings_en.cs
├── Utility
│   ├── BpUtility.cs
│   ├── DownloadProgressEvents.cs
│   ├── Hi3HelperCore.Http
│   ├── PartialZip
│   │   ├── Exceptions
│   │   │   ├── PartialZipFileNotFoundException.cs
│   │   │   ├── PartialZipNotSupportedException.cs
│   │   │   ├── PartialZipParsingException.cs
│   │   │   └── PartialZipUnsupportedCompressionException.cs
│   │   ├── Models
│   │   │   ├── CentralDirectoryHeader.cs
│   │   │   ├── EndOfCentralDirectory.cs
│   │   │   ├── EndOfCentralDirectory64.cs
│   │   │   ├── EndOfCentralDirectoryLocator64.cs
│   │   │   ├── ExtendedInformationExtraField64.cs
│   │   │   ├── LocalFileHeader.cs
│   │   │   └── PartialZipInfo.cs
│   │   ├── PartialZipDownloader.cs
│   │   └── Services
│   │       ├── DeflateService.cs
│   │       └── HttpService.cs
│   └── miHoYoCRCUtility.cs
├── Utility.cs
└── app.manifest

```

`App.config`:

```config
<?xml version="1.0" encoding="utf-8"?>
<configuration>
  <startup>
    <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.6" />
  </startup>
  <runtime>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="System.Runtime.CompilerServices.Unsafe" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-6.0.0.0" newVersion="6.0.0.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Buffers" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-4.0.3.0" newVersion="4.0.3.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Net.Http" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-4.1.1.3" newVersion="4.1.1.3" />
      </dependentAssembly>
    </assemblyBinding>
  </runtime>
</configuration>
```

`App.xaml`:

```xaml
<Application x:Class="BetterHI3Launcher.App"
		xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
		xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
		StartupUri="MainWindow.xaml">
	<Application.Resources>
	</Application.Resources>
</Application>
```

`App.xaml.cs`:

```cs
using Microsoft.Win32;
using Newtonsoft.Json.Linq;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;

namespace BetterHI3Launcher
{
	public partial class App : Application
	{
		public static readonly LauncherVersion LocalLauncherVersion = new LauncherVersion("1.3.20220707.0");
		public static readonly string LauncherRootPath = AppDomain.CurrentDomain.BaseDirectory;
		public static readonly string LocalLowPath = $"{Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData)}Low";
		public static readonly string LauncherDataPath = Path.Combine(LocalLowPath, @"Bp\Better HI3 Launcher");
		public static readonly string LauncherBackgroundsPath = Path.Combine(LauncherDataPath, "Backgrounds");
		public static readonly string LauncherLogFile = Path.Combine(LauncherDataPath, "BetterHI3Launcher-latest.log");
		public static readonly string LauncherTranslationsFile = Path.Combine(LauncherDataPath, "BetterHI3Launcher-translations.json");
		public static string UserAgent = $"BetterHI3Launcher v{LocalLauncherVersion}";
		public static string LauncherExeName, LauncherPath, LauncherArchivePath, LauncherLanguage;
		public static readonly string OSVersion = BpUtility.GetWindowsVersion();
		public static readonly string OSLanguage = CultureInfo.CurrentUICulture.ToString();
		public static string[] CommandLineArgs = Environment.GetCommandLineArgs();
		public static List<string> SeenAnnouncements = new List<string>();
		public static JArray Announcements = new JArray();
		public static RegistryKey LauncherRegKey = Registry.CurrentUser.CreateSubKey(@"SOFTWARE\Bp\Better HI3 Launcher");
		public static bool DisableAutoUpdate, DisableLogging, DisableTranslations, DisableSounds, AdvancedFeatures, NeedsUpdate, UseLegacyDownload;
		public static bool FirstLaunch = LauncherRegKey.GetValue("LauncherVersion") == null ? true : false;
		public static bool Starting = true;
		public static readonly int ParallelDownloadSessions = 4;
		public static Dictionary<string, string> TextStrings = new Dictionary<string, string>();
		public static Mutex Mutex = null;

		public App() : base()
		{
			SetupUnhandledExceptionHandling();
		}

		protected override void OnStartup(StartupEventArgs e)
		{
			var culture = CultureInfo.InvariantCulture;
			try
			{
				Mutex = new Mutex(true, "BetterHI3Launcher", out bool new_mutex);
				if(!new_mutex)
				{
					Shutdown();
				}
			}
			catch
			{
				throw;
			}
			Thread.CurrentThread.CurrentCulture = culture;
			Thread.CurrentThread.CurrentUICulture = culture;
			CultureInfo.DefaultThreadCurrentCulture = culture;
			CultureInfo.DefaultThreadCurrentUICulture = culture;
			#if DEBUG
			WinConsole.Initialize();
			UserAgent += " [DEBUG]";
			#endif
			TextStrings_English();
			switch(OSLanguage)
			{
				case "cs-CZ":
					LauncherLanguage = "cs";
					break;
				case "de-AT":
				case "de-CH":
				case "de-DE":
				case "de-LI":
				case "de-LU":
					LauncherLanguage = "de";
					break;
				case "es-AR":
				case "es-BO":
				case "es-CL":
				case "es-CO":
				case "es-CR":
				case "es-DO":
				case "es-EC":
				case "es-ES":
				case "es-GT":
				case "es-HN":
				case "es-MX":
				case "es-NI":
				case "es-PA":
				case "es-PE":
				case "es-PR":
				case "es-PY":
				case "es-SV":
				case "es-US":
				case "es-UY":
					LauncherLanguage = "es";
					break;
				case "fr-BE":
				case "fr-CA":
				case "fr-CH":
				case "fr-FR":
				case "fr-LU":
				case "fr-MC":
					LauncherLanguage = "fr";
					break;
				case "id-ID":
					LauncherLanguage = "id";
					break;
				case "it-CH":
				case "it-IT":
					LauncherLanguage = "it";
					break;
				case "pt-BR":
					LauncherLanguage = "pt-BR";
					break;
				case "pt-PT":
					LauncherLanguage = "pt-PT";
					break;
				case "ru-RU":
				case "uk-UA":
				case "be-BY":
					LauncherLanguage = "ru";
					break;
				case "sr-Cyrl-BA":
				case "sr-Cyrl-CS":
				case "sr-Cyrl-ME":
				case "sr-Cyrl-RS":
				case "sr-Latn-BA":
				case "sr-Latn-CS":
				case "sr-Latn-ME":
				case "sr-Latn-RS":
					LauncherLanguage = "sr";
					break;
				case "th-TH":
					LauncherLanguage = "th";
					break;
				case "vi-VN":
					LauncherLanguage = "vi";
					break;
				case "zh-CHS":
				case "zh-CN":
					LauncherLanguage = "zh-CN";
					break;
				default:
					LauncherLanguage = "en";
					break;
			}
			base.OnStartup(e);
		}

		protected override void OnExit(ExitEventArgs e)
		{
			if(Mutex != null)
			{
				Mutex.Dispose();
			}
			base.OnExit(e);
		}

		private void SetupUnhandledExceptionHandling()
		{
			// Catch exceptions from all threads in the AppDomain.
			AppDomain.CurrentDomain.UnhandledException += (sender, args) => ShowUnhandledException(args.ExceptionObject as Exception, "AppDomain.CurrentDomain.UnhandledException");

			// Catch exceptions from each AppDomain that uses a task scheduler for async operations.
			TaskScheduler.UnobservedTaskException += (sender, args) => ShowUnhandledException(args.Exception, "TaskScheduler.UnobservedTaskException");

			// Catch exceptions from a single specific UI dispatcher thread.
			Dispatcher.UnhandledException += (sender, args) =>
			{
				// If we are debugging, let Visual Studio handle the exception and take us to the code that threw it.
				if(!Debugger.IsAttached)
				{
					args.Handled = true;
					ShowUnhandledException(args.Exception, "Dispatcher.UnhandledException");
				}
			};
		}

		private void ShowUnhandledException(Exception e, string unhandledExceptionType)
		{
			if(unhandledExceptionType == "TaskScheduler.UnobservedTaskException")
			{
				return;
			}

			string msg = $"CRITICAL ERROR: Unhandled exception occurred. Stack trace:\n{e}";
			Console.ForegroundColor = ConsoleColor.Red;
			Console.WriteLine('\n' + msg);
			Directory.CreateDirectory(LauncherDataPath);
			if(File.Exists(LauncherLogFile))
			{
				File.SetAttributes(LauncherLogFile, File.GetAttributes(LauncherLogFile) & ~FileAttributes.ReadOnly);
			}
			File.AppendAllText(LauncherLogFile, '\n' + msg);
			if(MessageBox.Show(TextStrings["msgbox_unhandled_exception_msg"], TextStrings["msgbox_generic_error_title"], MessageBoxButton.YesNo, MessageBoxImage.Error) == MessageBoxResult.Yes)
			{
				BpUtility.StartProcess(LauncherLogFile, null, null, true);
			}
			Current.Shutdown();
		}
		
		public struct LauncherVersion
		{
			private int major, minor, date, hotfix;

			internal LauncherVersion(int _major, int _minor, int _date, int _hotfix)
			{
				major = _major;
				minor = _minor;
				date = _date;
				hotfix = _hotfix;
			}

			internal LauncherVersion(string _version)
			{
				string[] _version_strings = _version.Split('.');
				if(_version_strings.Length != 4)
				{
					major = 0;
					minor = 0;
					date = 0;
					hotfix = 0;
					return;
				}

				major = int.Parse(_version_strings[0]);
				minor = int.Parse(_version_strings[1]);
				date = int.Parse(_version_strings[2]);
				hotfix = int.Parse(_version_strings[3]);
			}

			internal bool IsNewerThan(LauncherVersion _other_version)
			{
				if(major >= _other_version.major && minor >= _other_version.minor && date >= _other_version.date)
				{
					if(major > _other_version.major)
					{
						return true;
					}
					else if(minor > _other_version.minor)
					{
						return true;
					}
					else if(date > _other_version.date)
					{
						return true;
					}
					else if(hotfix > _other_version.hotfix)
					{
						return true;
					}
				}
				return false;
			}

			public override string ToString()
			{
				return $"{major}.{minor}.{date}.{hotfix}";
			}
		}
	}
}
```

`BetterHI3Launcher.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{FEB42181-FC9E-4FCD-B931-8F972EAA7110}</ProjectGuid>
    <OutputType>WinExe</OutputType>
    <RootNamespace>BetterHI3Launcher</RootNamespace>
    <AssemblyName>BetterHI3Launcher</AssemblyName>
    <TargetFrameworkVersion>v4.6.1</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <ProjectTypeGuids>{60dc8134-eba5-43b8-bcc9-bb4bc16c2548};{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}</ProjectTypeGuids>
    <WarningLevel>4</WarningLevel>
    <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
    <Deterministic>true</Deterministic>
    <IsWebBootstrapper>false</IsWebBootstrapper>
    <NuGetPackageImportStamp>
    </NuGetPackageImportStamp>
    <TargetFrameworkProfile />
    <PublishUrl>publish\</PublishUrl>
    <Install>true</Install>
    <InstallFrom>Disk</InstallFrom>
    <UpdateEnabled>false</UpdateEnabled>
    <UpdateMode>Foreground</UpdateMode>
    <UpdateInterval>7</UpdateInterval>
    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
    <UpdatePeriodically>false</UpdatePeriodically>
    <UpdateRequired>false</UpdateRequired>
    <MapFileExtensions>true</MapFileExtensions>
    <ApplicationRevision>0</ApplicationRevision>
    <ApplicationVersion>1.0.0.0</ApplicationVersion>
    <UseApplicationTrust>false</UseApplicationTrust>
    <BootstrapperEnabled>true</BootstrapperEnabled>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>x64</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>x64</PlatformTarget>
    <DebugType>none</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>
    </DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <DebugSymbols>false</DebugSymbols>
  </PropertyGroup>
  <PropertyGroup>
    <ApplicationIcon>Assets\Images\Icon.ico</ApplicationIcon>
  </PropertyGroup>
  <PropertyGroup>
    <ApplicationManifest>app.manifest</ApplicationManifest>
  </PropertyGroup>
  <PropertyGroup>
    <SignManifests>false</SignManifests>
  </PropertyGroup>
  <PropertyGroup>
    <SignAssembly>false</SignAssembly>
  </PropertyGroup>
  <PropertyGroup>
    <ManifestCertificateThumbprint>ED52B84CCFE6E7402C6C9080D4EFDA99FB93825C</ManifestCertificateThumbprint>
  </PropertyGroup>
  <PropertyGroup>
    <ManifestKeyFile>BetterHI3Launcher_TemporaryKey.pfx</ManifestKeyFile>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.ComponentModel.Composition" />
    <Reference Include="System.Data" />
    <Reference Include="System.Drawing" />
    <Reference Include="System.IO.Compression.FileSystem" />
    <Reference Include="System.Numerics" />
    <Reference Include="System.Web" />
    <Reference Include="System.Xml" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="System.Xaml">
      <RequiredTargetFramework>4.0</RequiredTargetFramework>
    </Reference>
    <Reference Include="UIAutomationProvider" />
    <Reference Include="WindowsBase" />
    <Reference Include="PresentationCore" />
    <Reference Include="PresentationFramework" />
    <Reference Include="XamlAnimatedGif, Version=2.0.0.0, Culture=neutral, PublicKeyToken=20a987d8023d9690, processorArchitecture=MSIL">
      <HintPath>packages\XamlAnimatedGif.2.0.0\lib\net45\XamlAnimatedGif.dll</HintPath>
    </Reference>
  </ItemGroup>
  <ItemGroup>
    <ApplicationDefinition Include="App.xaml">
      <Generator>MSBuild:Compile</Generator>
      <SubType>Designer</SubType>
    </ApplicationDefinition>
    <Page Include="MainWindow.xaml">
      <Generator>MSBuild:Compile</Generator>
      <SubType>Designer</SubType>
    </Page>
    <Page Include="DialogWindow.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Compile Include="App.xaml.cs">
      <DependentUpon>App.xaml</DependentUpon>
      <SubType>Code</SubType>
    </Compile>
    <Compile Include="MainWindow.xaml.cs">
      <DependentUpon>MainWindow.xaml</DependentUpon>
      <SubType>Code</SubType>
    </Compile>
    <Compile Include="DialogWindow.xaml.cs">
      <DependentUpon>DialogWindow.xaml</DependentUpon>
    </Compile>
    <Compile Include="TextStrings_en.cs" />
    <Compile Include="Utility\DownloadProgressEvents.cs" />
    <Compile Include="Utility\Hi3HelperCore.Http\Class\Attribute.cs" />
    <Compile Include="Utility\Hi3HelperCore.Http\Class\Event.cs" />
    <Compile Include="Utility\Hi3HelperCore.Http\Class\Exception.cs" />
    <Compile Include="Utility\Hi3HelperCore.Http\Class\IO.cs" />
    <Compile Include="Utility\Hi3HelperCore.Http\Class\Merge.cs" />
    <Compile Include="Utility\Hi3HelperCore.Http\Class\Session.cs" />
    <Compile Include="Utility\Hi3HelperCore.Http\Class\Thread.cs" />
    <Compile Include="Utility\Hi3HelperCore.Http\Http.cs" />
    <Compile Include="Utility\Hi3HelperCore.Http\HttpMultisession.cs" />
    <Compile Include="Utility\miHoYoCRCUtility.cs" />
    <Compile Include="Utility\PartialZip\Exceptions\PartialZipFileNotFoundException.cs" />
    <Compile Include="Utility\PartialZip\Exceptions\PartialZipNotSupportedException.cs" />
    <Compile Include="Utility\PartialZip\Exceptions\PartialZipParsingException.cs" />
    <Compile Include="Utility\PartialZip\Exceptions\PartialZipUnsupportedCompressionException.cs" />
    <Compile Include="Utility\PartialZip\Models\CentralDirectoryHeader.cs" />
    <Compile Include="Utility\PartialZip\Models\EndOfCentralDirectory.cs" />
    <Compile Include="Utility\PartialZip\Models\EndOfCentralDirectory64.cs" />
    <Compile Include="Utility\PartialZip\Models\EndOfCentralDirectoryLocator64.cs" />
    <Compile Include="Utility\PartialZip\Models\ExtendedInformationExtraField64.cs" />
    <Compile Include="Utility\PartialZip\Models\LocalFileHeader.cs" />
    <Compile Include="Utility\PartialZip\Models\PartialZipInfo.cs" />
    <Compile Include="Utility\PartialZip\PartialZipDownloader.cs" />
    <Compile Include="Utility\PartialZip\Services\DeflateService.cs" />
    <Compile Include="Utility\PartialZip\Services\HttpService.cs" />
    <Compile Include="Utility\BpUtility.cs" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Properties\AssemblyInfo.cs">
      <SubType>Code</SubType>
    </Compile>
    <Compile Include="Properties\Resources.Designer.cs">
      <AutoGen>True</AutoGen>
      <DesignTime>True</DesignTime>
      <DependentUpon>Resources.resx</DependentUpon>
    </Compile>
    <Compile Include="Properties\Settings.Designer.cs">
      <AutoGen>True</AutoGen>
      <DependentUpon>Settings.settings</DependentUpon>
      <DesignTimeSharedInput>True</DesignTimeSharedInput>
    </Compile>
    <EmbeddedResource Include="Properties\Resources.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
      <SubType>Designer</SubType>
    </EmbeddedResource>
    <None Include="Utility\Hi3HelperCore.Http\Hi3HelperCore.Http.csproj" />
    <None Include="Utility\Hi3HelperCore.Http\LICENSE" />
    <None Include="Utility\Hi3HelperCore.Http\README.md" />
    <Resource Include="Assets\Fonts\FZLanTingHei-B-GBK.ttf" />
    <None Include="app.manifest" />
    <None Include="Properties\Settings.settings">
      <Generator>SettingsSingleFileGenerator</Generator>
      <LastGenOutput>Settings.Designer.cs</LastGenOutput>
    </None>
  </ItemGroup>
  <ItemGroup>
    <None Include="App.config" />
  </ItemGroup>
  <ItemGroup>
    <BootstrapperPackage Include=".NETFramework,Version=v4.6.1">
      <Visible>False</Visible>
      <ProductName>Microsoft .NET Framework 4.6.1 %28x86 and x64%29</ProductName>
      <Install>true</Install>
    </BootstrapperPackage>
    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
      <Visible>False</Visible>
      <ProductName>.NET Framework 3.5 SP1</ProductName>
      <Install>false</Install>
    </BootstrapperPackage>
  </ItemGroup>
  <ItemGroup>
    <Content Include="Utility\Hi3HelperCore.Http\.gitattributes" />
    <Content Include="Utility\Hi3HelperCore.Http\.gitignore" />
    <Resource Include="Assets\Images\Icon.ico" />
    <Resource Include="Assets\Images\Button.png" />
    <Resource Include="Assets\Images\Button_Disabled.png" />
    <Resource Include="Assets\Images\Button_Pressed.png" />
    <Resource Include="Assets\Images\Button_Close.png" />
    <Resource Include="Assets\Images\Button_Close_Pressed.png" />
    <Resource Include="Assets\Images\Button_Close_Highlighted.png" />
    <Resource Include="Assets\Images\Button_Box_Close.png" />
    <Resource Include="Assets\Images\Button_Box_Close_Highlighted.png" />
    <Resource Include="Assets\Images\Button_Box_Close_Pressed.png" />
    <Resource Include="Assets\Images\Button_Minimize.png" />
    <Resource Include="Assets\Images\Button_Minimize_Highlighted.png" />
    <Resource Include="Assets\Images\Button_Minimize_Pressed.png" />
    <Resource Include="Assets\Images\Button_Preload.png" />
    <Resource Include="Assets\Images\Button_Preload_Checkmark.png" />
    <Resource Include="Assets\Images\Button_Preload_Circle.png" />
    <Resource Include="Assets\Images\Button_Preload_Highlighted.png" />
    <Resource Include="Assets\Images\Button_Preload_Pressed.png" />
    <Resource Include="Assets\Images\Button_Preload_Pause.png" />
    <Resource Include="Assets\Images\Button_Preload_Resume.png" />
    <Resource Include="Assets\Images\Button_Pause.png" />
    <Resource Include="Assets\Images\Button_Pause_Highlighted.png" />
    <Resource Include="Assets\Images\Button_Pause_Pressed.png" />
    <Resource Include="Assets\Images\Button_Resume.png" />
    <Resource Include="Assets\Images\Button_Resume_Highlighted.png" />
    <Resource Include="Assets\Images\Button_Resume_Pressed.png" />
    <Resource Include="Assets\Images\BackgroundShadow.png" />
    <Resource Include="Assets\Images\HoV_Dance.gif" />
    <Resource Include="Assets\Images\Window_Dialog.png" />
    <Resource Include="Assets\Images\Checkbox_On.png" />
    <Resource Include="Assets\Images\Checkbox_Off.png" />
    <Resource Include="Assets\Images\Checkbox_Disabled.png" />
    <Content Include="Assets\Sounds\Click.wav" />
    <Content Include="Assets\Sounds\Window_Close.wav" />
    <Content Include="Assets\Sounds\Window_Open.wav" />
  </ItemGroup>
  <ItemGroup>
    <PackageReference Include="AssetsTools.NET">
      <Version>2.0.12</Version>
    </PackageReference>
    <PackageReference Include="Costura.Fody">
      <Version>5.7.0</Version>
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
    <PackageReference Include="Fody">
      <Version>6.6.3</Version>
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
    <PackageReference Include="ini-parser">
      <Version>2.5.2</Version>
    </PackageReference>
    <PackageReference Include="Microsoft.NETCore.Platforms">
      <Version>6.0.4</Version>
    </PackageReference>
    <PackageReference Include="NETStandard.Library">
      <Version>2.0.3</Version>
    </PackageReference>
    <PackageReference Include="Newtonsoft.Json">
      <Version>13.0.1</Version>
    </PackageReference>
    <PackageReference Include="SharpCompress">
      <Version>0.32.1</Version>
    </PackageReference>
    <PackageReference Include="System.Diagnostics.DiagnosticSource">
      <Version>6.0.0</Version>
    </PackageReference>
    <PackageReference Include="System.Globalization.Calendars">
      <Version>4.3.0</Version>
    </PackageReference>
    <PackageReference Include="System.IO.Compression">
      <Version>4.3.0</Version>
    </PackageReference>
    <PackageReference Include="System.IO.Compression.ZipFile">
      <Version>4.3.0</Version>
    </PackageReference>
    <PackageReference Include="System.IO.FileSystem">
      <Version>4.3.0</Version>
    </PackageReference>
    <PackageReference Include="System.Net.Http">
      <Version>4.3.4</Version>
    </PackageReference>
    <PackageReference Include="System.Net.Sockets">
      <Version>4.3.0</Version>
    </PackageReference>
    <PackageReference Include="System.Runtime.InteropServices.RuntimeInformation">
      <Version>4.3.0</Version>
    </PackageReference>
    <PackageReference Include="System.Security.Cryptography.Algorithms">
      <Version>4.3.1</Version>
    </PackageReference>
    <PackageReference Include="System.Security.Cryptography.X509Certificates">
      <Version>4.3.2</Version>
    </PackageReference>
    <PackageReference Include="System.Text.Encoding.CodePages">
      <Version>6.0.0</Version>
    </PackageReference>
    <PackageReference Include="System.Xml.ReaderWriter">
      <Version>4.3.1</Version>
    </PackageReference>
    <PackageReference Include="WindowsAPICodePack-Core">
      <Version>1.1.2</Version>
    </PackageReference>
    <PackageReference Include="WindowsAPICodePack-Shell">
      <Version>1.1.1</Version>
    </PackageReference>
    <PackageReference Include="XamlAnimatedGif">
      <Version>2.0.2</Version>
    </PackageReference>
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
</Project>
```

`BetterHI3Launcher.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30621.155
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "BetterHI3Launcher", "BetterHI3Launcher.csproj", "{FEB42181-FC9E-4FCD-B931-8F972EAA7110}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{FEB42181-FC9E-4FCD-B931-8F972EAA7110}.Debug|x64.ActiveCfg = Debug|Any CPU
		{FEB42181-FC9E-4FCD-B931-8F972EAA7110}.Debug|x64.Build.0 = Debug|Any CPU
		{FEB42181-FC9E-4FCD-B931-8F972EAA7110}.Release|x64.ActiveCfg = Release|Any CPU
		{FEB42181-FC9E-4FCD-B931-8F972EAA7110}.Release|x64.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {86D48662-3623-4111-9F78-2A71A144A0E8}
	EndGlobalSection
EndGlobal

```

`DialogWindow.xaml`:

```xaml
<Window x:Class="BetterHI3Launcher.DialogWindow"
		xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
		xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
		xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
		xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
		mc:Ignorable="d"
		WindowStyle="None"
		ResizeMode="NoResize"
		AllowsTransparency="True"
		Background="#80000000"
		Closing="DialogWindow_Closing"
		UseLayoutRounding="True"
		TextOptions.TextFormattingMode="Display"
		TextOptions.TextRenderingMode="ClearType"
		ShowInTaskbar="False"
		Title="DialogWindow" Width="1280" Height="730">
	<Window.Resources>
		<FontFamily x:Key="Font">/BetterHI3Launcher;component/Assets/Fonts/#FZLanTingHei-B-GBK</FontFamily>
		<ImageBrush x:Key="Button" ImageSource="/Assets/Images/Button.png"/>
		<ImageBrush x:Key="ButtonPressed" ImageSource="/Assets/Images/Button_Pressed.png"/>
		<ImageBrush x:Key="ButtonDisabled" ImageSource="/Assets/Images/Button_Disabled.png"/>
		<Style x:Key="FocusVisual">
			<Setter Property="Control.Template">
				<Setter.Value>
					<ControlTemplate>
						<Rectangle UseLayoutRounding="true" StrokeThickness="2" Stroke="{DynamicResource {x:Static SystemColors.MenuHighlightBrushKey}}"/>
					</ControlTemplate>
				</Setter.Value>
			</Setter>
		</Style>
		<Style x:Key="ButtonStyle" TargetType="{x:Type Button}">
			<Setter Property="FocusVisualStyle" Value="{StaticResource FocusVisual}"/>
			<Setter Property="Background" Value="{StaticResource Button}"/>
			<Setter Property="BorderBrush" Value="{x:Null}"/>
			<Setter Property="Foreground" Value="#313131"/>
			<Setter Property="BorderThickness" Value="0"/>
			<Setter Property="HorizontalAlignment" Value="Center"/>
			<Setter Property="VerticalAlignment" Value="Bottom"/>
			<Setter Property="Margin" Value="15,0"/>
			<Setter Property="FontFamily" Value="{DynamicResource Font}"/>
			<Setter Property="FontSize" Value="20"/>
			<Setter Property="Template">
				<Setter.Value>
					<ControlTemplate TargetType="{x:Type Button}">
						<Border x:Name="border" Background="{TemplateBinding Background}" BorderThickness="{TemplateBinding BorderThickness}" BorderBrush="{TemplateBinding BorderBrush}" SnapsToDevicePixels="true">
							<ContentPresenter x:Name="contentPresenter" Focusable="False" HorizontalAlignment="{TemplateBinding HorizontalContentAlignment}" Margin="{TemplateBinding Padding}" RecognizesAccessKey="True" SnapsToDevicePixels="{TemplateBinding SnapsToDevicePixels}" VerticalAlignment="{TemplateBinding VerticalContentAlignment}"/>
						</Border>
						<ControlTemplate.Triggers>
							<Trigger Property="IsDefaulted" Value="true">
								<Setter Property="BorderBrush" TargetName="border" Value="{DynamicResource {x:Static SystemColors.HighlightBrushKey}}"/>
							</Trigger>
							<Trigger Property="IsPressed" Value="true">
								<Setter Property="Background" TargetName="border" Value="{StaticResource ButtonPressed}"/>
							</Trigger>
							<Trigger Property="IsEnabled" Value="false">
								<Setter Property="Background" TargetName="border" Value="{StaticResource ButtonDisabled}"/>
								<Setter Property="TextElement.Foreground" TargetName="contentPresenter" Value="#333333"/>
							</Trigger>
						</ControlTemplate.Triggers>
					</ControlTemplate>
				</Setter.Value>
			</Setter>
		</Style>
		<Style x:Key="CloseButtonStyle" TargetType="{x:Type Button}">
			<Setter Property="FocusVisualStyle" Value="{StaticResource FocusVisual}"/>
			<Setter Property="Background" Value="Transparent"/>
			<Setter Property="BorderBrush" Value="{x:Null}"/>
			<Setter Property="BorderThickness" Value="0"/>
			<Setter Property="HorizontalAlignment" Value="Right"/>
			<Setter Property="VerticalAlignment" Value="Top"/>
			<Setter Property="Width" Value="52"/>
			<Setter Property="Height" Value="38"/>
			<Setter Property="FontFamily" Value="{DynamicResource Font}"/>
			<Setter Property="FontWeight" Value="Bold"/>
			<Setter Property="FontSize" Value="16"/>
			<Setter Property="Template">
				<Setter.Value>
					<ControlTemplate TargetType="{x:Type Button}">
						<Border x:Name="border" Background="{TemplateBinding Background}" BorderThickness="{TemplateBinding BorderThickness}" BorderBrush="{TemplateBinding BorderBrush}" SnapsToDevicePixels="true">
							<ContentPresenter x:Name="contentPresenter" Focusable="False" HorizontalAlignment="{TemplateBinding HorizontalContentAlignment}" Margin="{TemplateBinding Padding}" RecognizesAccessKey="True" SnapsToDevicePixels="{TemplateBinding SnapsToDevicePixels}" VerticalAlignment="{TemplateBinding VerticalContentAlignment}"/>
						</Border>
					</ControlTemplate>
				</Setter.Value>
			</Setter>
		</Style>
		<Style TargetType="{x:Type CheckBox}">
			<Setter Property="FocusVisualStyle" Value="{StaticResource FocusVisual}"/>
			<Setter Property="Width" Value="24"/>
			<Setter Property="Height" Value="16"/>
			<Setter Property="Margin" Value="5"/>
			<Setter Property="UseLayoutRounding" Value="True"/>
			<Setter Property="Template">
				<Setter.Value>
					<ControlTemplate TargetType="{x:Type CheckBox}">
						<StackPanel Orientation="Horizontal">
							<Image x:Name="Image" Source="/Assets/Images/Checkbox_On.png"/>
							<ContentPresenter/>
						</StackPanel>
						<ControlTemplate.Triggers>
							<Trigger Property="IsChecked" Value="True">
								<Setter TargetName="Image" Property="Source" Value="/Assets/Images/Checkbox_On.png"/>
							</Trigger>
							<Trigger Property="IsChecked" Value="False">
								<Setter TargetName="Image" Property="Source" Value="/Assets/Images/Checkbox_Off.png"/>
							</Trigger>
							<Trigger Property="IsEnabled" Value="False">
								<Setter TargetName="Image" Property="Source" Value="/Assets/Images/Checkbox_Disabled.png"/>
							</Trigger>
						</ControlTemplate.Triggers>
					</ControlTemplate>
				</Setter.Value>
			</Setter>
		</Style>
		<Style TargetType="{x:Type RadioButton}">
			<Setter Property="FocusVisualStyle" Value="{StaticResource FocusVisual}"/>
			<Setter Property="Width" Value="21"/>
			<Setter Property="Height" Value="16"/>
			<Setter Property="Margin" Value="5"/>
			<Setter Property="UseLayoutRounding" Value="True"/>
			<Setter Property="Template">
				<Setter.Value>
					<ControlTemplate TargetType="{x:Type RadioButton}">
						<StackPanel Orientation="Horizontal">
							<Image x:Name="Image" Source="/Assets/Images/Checkbox_On.png"/>
							<ContentPresenter/>
						</StackPanel>
						<ControlTemplate.Triggers>
							<Trigger Property="IsChecked" Value="True">
								<Setter TargetName="Image" Property="Source" Value="/Assets/Images/Checkbox_On.png"/>
							</Trigger>
							<Trigger Property="IsChecked" Value="False">
								<Setter TargetName="Image" Property="Source" Value="/Assets/Images/Checkbox_Off.png"/>
							</Trigger>
							<Trigger Property="IsEnabled" Value="False">
								<Setter TargetName="Image" Property="Source" Value="/Assets/Images/Checkbox_Disabled.png"/>
							</Trigger>
						</ControlTemplate.Triggers>
					</ControlTemplate>
				</Setter.Value>
			</Setter>
		</Style>
		<Style TargetType="{x:Type TextBox}">
			<Setter Property="FocusVisualStyle" Value="{StaticResource FocusVisual}"/>
			<Setter Property="VerticalContentAlignment" Value="Center"/>
			<Setter Property="FontFamily" Value="{DynamicResource Font}"/>
			<Setter Property="FontSize" Value="14"/>
			<Setter Property="Template">
				<Setter.Value>
					<ControlTemplate TargetType="{x:Type TextBoxBase}">
						<Border Name="Border" CornerRadius="3" Padding="1">
							<Border.Background>
								<SolidColorBrush Color="White" />
							</Border.Background>
							<ScrollViewer Margin="0" x:Name="PART_ContentHost"/>
						</Border>
					</ControlTemplate>
				</Setter.Value>
			</Setter>
		</Style>
	</Window.Resources>
	<Grid Width="576" Height="307">
		<Image Source="Assets/Images/Window_Dialog.png"/>
		<TextBlock Name="DialogTitle" VerticalAlignment="Top" Margin="85,29,85,0" Foreground="White" FontFamily="{DynamicResource Font}" FontSize="18" TextAlignment="Center"/>
		<ScrollViewer Name="DialogMessageScrollViewer" VerticalAlignment="Center" HorizontalAlignment="Center" Margin="0,0,0,25" Width="500" Height="135" Focusable="False" ScrollViewer.VerticalScrollBarVisibility="Hidden">
			<TextBlock Name="DialogMessage" VerticalAlignment="Center" HorizontalAlignment="Center" MaxWidth="500" MaxHeight="147" Foreground="White" FontFamily="{DynamicResource Font}" FontSize="16" TextAlignment="Center" TextWrapping="Wrap"/>
		</ScrollViewer>
		<StackPanel Name="InstallStackPanel" HorizontalAlignment="Center" VerticalAlignment="Center" Margin="0,50,0,0" Visibility="Collapsed">
			<StackPanel Orientation="Horizontal">
				<TextBox Name="InstallPathTextBox" Width="380" Height="20" TextChanged="InstallPathTextBox_TextChanged"/>
				<Button Style="{DynamicResource ButtonStyle}" Height="20" Margin="5,0,0,0" FontSize="16" Content="..." Click="BrowseButton_Click"/>
			</StackPanel>
		</StackPanel>
		<StackPanel Name="UninstallStackPanel" HorizontalAlignment="Center" VerticalAlignment="Center" Margin="0,25,0,0" Visibility="Collapsed">
			<StackPanel Orientation="Horizontal">
				<CheckBox Name="UninstallGameFilesCheckBox" IsChecked="True" Click="UninstallCheckBox_Click" x:FieldModifier="public"/>
				<TextBlock Name="UninstallGameFilesLabel" VerticalAlignment="Center" Foreground="White" FontFamily="{DynamicResource Font}" FontSize="16"/>
			</StackPanel>
			<StackPanel Orientation="Horizontal">
				<CheckBox Name="UninstallGameCacheCheckBox" IsChecked="True" Click="UninstallCheckBox_Click" x:FieldModifier="public"/>
				<TextBlock Name="UninstallGameCacheLabel" VerticalAlignment="Center" Foreground="White" FontFamily="{DynamicResource Font}" FontSize="16"/>
			</StackPanel>
			<StackPanel Orientation="Horizontal">
				<CheckBox Name="UninstallGameSettingsCheckBox" IsChecked="True" Click="UninstallCheckBox_Click" x:FieldModifier="public"/>
				<TextBlock Name="UninstallGameSettingsLabel" VerticalAlignment="Center" Foreground="White" FontFamily="{DynamicResource Font}" FontSize="16"/>
			</StackPanel>
		</StackPanel>
		<StackPanel Name="CustomLaunchOptionsStackPanel" HorizontalAlignment="Center" VerticalAlignment="Center" Margin="0,50,0,0" Visibility="Collapsed">
			<StackPanel Orientation="Horizontal">
				<TextBox Name="CustomLaunchOptionsTextBox" Width="400" Height="20" MaxLength="256"/>
			</StackPanel>
		</StackPanel>
		<StackPanel Name="CustomBackgroundStackPanel" HorizontalAlignment="Center" VerticalAlignment="Center" Margin="0,35,0,0" Visibility="Collapsed">
			<StackPanel Orientation="Horizontal">
				<RadioButton Name="CustomBackgroundEditRadioButton" GroupName="CustomBackgroundActionChoice" IsChecked="True" Click="CustomBackgroundRadioButton_Click" x:FieldModifier="public"/>
				<TextBlock Name="CustomBackgroundEditLabel" Foreground="White" VerticalAlignment="Center" FontFamily="{DynamicResource Font}" FontSize="16"/>
			</StackPanel>
			<StackPanel Orientation="Horizontal">
				<RadioButton Name="CustomBackgroundDeleteRadioButton" GroupName="CustomBackgroundActionChoice" Click="CustomBackgroundRadioButton_Click" x:FieldModifier="public"/>
				<TextBlock Name="CustomBackgroundDeleteLabel" Foreground="White" VerticalAlignment="Center" FontFamily="{DynamicResource Font}" FontSize="16"/>
			</StackPanel>
		</StackPanel>
		<Button Name="CloseButton" Style="{DynamicResource CloseButtonStyle}" Margin="0,23,33,0" Click="CloseButton_Click"/>
		<StackPanel Orientation="Horizontal" HorizontalAlignment="Center" VerticalAlignment="Bottom" Margin="36">
			<Button Name="ConfirmButton" Style="{DynamicResource ButtonStyle}" Width="189" Height="44" Click="ConfirmButton_Click"/>
			<Button Name="CancelButton" Style="{DynamicResource ButtonStyle}" Width="189" Height="44" Click="CloseButton_Click"/>
		</StackPanel>
	</Grid>
</Window>
```

`DialogWindow.xaml.cs`:

```cs
using Microsoft.Win32;
using Microsoft.WindowsAPICodePack.Dialogs;
using System.ComponentModel;
using System.IO;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;
using System.Windows.Media;

namespace BetterHI3Launcher
{
	public partial class DialogWindow : Window
	{
		public enum DialogType
		{
			Confirmation, Question, Install, Uninstall, CustomLaunchOptions, CustomBackground
		}

		public DialogWindow(string title, string message, DialogType type = DialogType.Confirmation)
		{
			Owner = Application.Current.MainWindow;
			Left = Application.Current.MainWindow.Left + 10;
			Top = Application.Current.MainWindow.Top + 10;
			InitializeComponent();
			DialogTitle.Text = title;
			DialogMessage.Text = message;
			ConfirmButton.Content = App.TextStrings["button_confirm"];
			CancelButton.Content = App.TextStrings["button_cancel"];
			switch(type)
			{
				case DialogType.Confirmation:
					ConfirmButton.Content = App.TextStrings["button_ok"];
					CancelButton.Visibility = Visibility.Collapsed;
					break;
				case DialogType.Question:
					ConfirmButton.Content = App.TextStrings["button_yes"];
					CancelButton.Content = App.TextStrings["button_no"];
					break;
				case DialogType.Install:
					DialogMessageScrollViewer.Margin = new Thickness(0, 0, 0, 75);
					DialogMessageScrollViewer.Height = 100;
					InstallStackPanel.Visibility = Visibility.Visible;
					break;
				case DialogType.Uninstall:
					DialogMessageScrollViewer.Margin = new Thickness(0, 0, 0, 100);
					DialogMessageScrollViewer.Height = 50;
					UninstallStackPanel.Visibility = Visibility.Visible;
					UninstallGameFilesLabel.Text = App.TextStrings["msgbox_uninstall_game_files"];
					UninstallGameCacheLabel.Text = App.TextStrings["msgbox_uninstall_game_cache"];
					UninstallGameSettingsLabel.Text = App.TextStrings["msgbox_uninstall_game_settings"];
					if(!Directory.Exists(MainWindow.GameCachePath))
					{
						UninstallGameCacheCheckBox.IsChecked = false;
						UninstallGameCacheCheckBox.IsEnabled = false;
					}
					if(Registry.CurrentUser.OpenSubKey(MainWindow.GameRegistryPath) == null)
					{
						UninstallGameSettingsCheckBox.IsChecked = false;
						UninstallGameSettingsCheckBox.IsEnabled = false;
					}
					break;
				case DialogType.CustomLaunchOptions:
					DialogMessageScrollViewer.Margin = new Thickness(0, 0, 0, 75);
					DialogMessageScrollViewer.Height = 100;
					CustomLaunchOptionsStackPanel.Visibility = Visibility.Visible;
					break;
				case DialogType.CustomBackground:
					DialogMessageScrollViewer.Margin = new Thickness(0, 0, 0, 75);
					DialogMessageScrollViewer.Height = 80;
					CustomBackgroundStackPanel.Visibility = Visibility.Visible;
					CustomBackgroundEditLabel.Text = App.TextStrings["msgbox_custom_background_edit"];
					CustomBackgroundDeleteLabel.Text = App.TextStrings["msgbox_custom_background_delete"];
					break;
			}
			if(App.LauncherLanguage != "en" && App.LauncherLanguage != "zh-CN")
			{
				Resources["Font"] = new FontFamily("Segoe UI Bold");
			}
			Application.Current.MainWindow.WindowState = WindowState.Normal;
			BpUtility.PlaySound(Properties.Resources.Window_Open);
		}

		private void ConfirmButton_Click(object sender, RoutedEventArgs e)
		{
			BpUtility.PlaySound(Properties.Resources.Click);
			DialogResult = true;
			Close();
		}

		private void CloseButton_Click(object sender, RoutedEventArgs e)
		{
			BpUtility.PlaySound(Properties.Resources.Click);
			Close();
		}

		private void BrowseButton_Click(object sender, RoutedEventArgs e)
		{
			BpUtility.PlaySound(Properties.Resources.Click);
			var dialog = new CommonOpenFileDialog
			{
				IsFolderPicker = true,
				Multiselect = false,
				DefaultDirectory = InstallPathTextBox.Text,
				AddToMostRecentlyUsedList = false,
				AllowNonFileSystemItems = false,
				EnsurePathExists = true,
				EnsureReadOnly = false,
				EnsureValidNames = true
			};
			if(dialog.ShowDialog(this) == CommonFileDialogResult.Ok)
			{
				InstallPathTextBox.Text = Path.Combine(dialog.FileName, MainWindow.GameFullName);
				string[] game_full_names = {"Honkai Impact 3rd", "Honkai Impact 3", "崩坏3", "崩壞3", "붕괴3rd", "Honkai Impact 3rd glb", "Honkai Impact 3 sea", "Honkai Impact 3rd tw", "Honkai Impact 3rd kr"};
				foreach(string game_full_name in game_full_names)
				{
					if(dialog.FileName.Contains(game_full_name))
					{
						InstallPathTextBox.Text = dialog.FileName;
						break;
					}
				}
			}
		}

		private void InstallPathTextBox_TextChanged(object sender, TextChangedEventArgs e)
		{
			if(string.IsNullOrEmpty(InstallPathTextBox.Text))
			{
				ConfirmButton.IsEnabled = false;
			}
			else
			{
				ConfirmButton.IsEnabled = true;
			}
		}

		private void UninstallCheckBox_Click(object sender, RoutedEventArgs e)
		{
			BpUtility.PlaySound(Properties.Resources.Click);
			if(!(bool)UninstallGameFilesCheckBox.IsChecked && !(bool)UninstallGameCacheCheckBox.IsChecked && !(bool)UninstallGameSettingsCheckBox.IsChecked)
			{
				ConfirmButton.IsEnabled = false;
			}
			else
			{
				ConfirmButton.IsEnabled = true;
			}
		}

		private void CustomBackgroundRadioButton_Click(object sender, RoutedEventArgs e)
		{
			BpUtility.PlaySound(Properties.Resources.Click);
		}

		protected override void OnKeyDown(KeyEventArgs e)
		{
			if(Keyboard.Modifiers == ModifierKeys.Alt && e.SystemKey == Key.Space)
			{
				e.Handled = true;
			}
			else
			{
				base.OnKeyDown(e);
			}
		}

		private void DialogWindow_Closing(object sender, CancelEventArgs e)
		{
			BpUtility.PlaySound(Properties.Resources.Window_Close);   
		}
	}
}
```

`FodyWeavers.xml`:

```xml
<Weavers xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="FodyWeavers.xsd">
  <Costura />
</Weavers>
```

`FodyWeavers.xsd`:

```xsd
<?xml version="1.0" encoding="utf-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
  <!-- This file was generated by Fody. Manual changes to this file will be lost when your project is rebuilt. -->
  <xs:element name="Weavers">
    <xs:complexType>
      <xs:all>
        <xs:element name="Costura" minOccurs="0" maxOccurs="1">
          <xs:complexType>
            <xs:all>
              <xs:element minOccurs="0" maxOccurs="1" name="ExcludeAssemblies" type="xs:string">
                <xs:annotation>
                  <xs:documentation>A list of assembly names to exclude from the default action of "embed all Copy Local references", delimited with line breaks</xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element minOccurs="0" maxOccurs="1" name="IncludeAssemblies" type="xs:string">
                <xs:annotation>
                  <xs:documentation>A list of assembly names to include from the default action of "embed all Copy Local references", delimited with line breaks.</xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element minOccurs="0" maxOccurs="1" name="ExcludeRuntimeAssemblies" type="xs:string">
                <xs:annotation>
                  <xs:documentation>A list of runtime assembly names to exclude from the default action of "embed all Copy Local references", delimited with line breaks</xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element minOccurs="0" maxOccurs="1" name="IncludeRuntimeAssemblies" type="xs:string">
                <xs:annotation>
                  <xs:documentation>A list of runtime assembly names to include from the default action of "embed all Copy Local references", delimited with line breaks.</xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element minOccurs="0" maxOccurs="1" name="Unmanaged32Assemblies" type="xs:string">
                <xs:annotation>
                  <xs:documentation>A list of unmanaged 32 bit assembly names to include, delimited with line breaks.</xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element minOccurs="0" maxOccurs="1" name="Unmanaged64Assemblies" type="xs:string">
                <xs:annotation>
                  <xs:documentation>A list of unmanaged 64 bit assembly names to include, delimited with line breaks.</xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element minOccurs="0" maxOccurs="1" name="PreloadOrder" type="xs:string">
                <xs:annotation>
                  <xs:documentation>The order of preloaded assemblies, delimited with line breaks.</xs:documentation>
                </xs:annotation>
              </xs:element>
            </xs:all>
            <xs:attribute name="CreateTemporaryAssemblies" type="xs:boolean">
              <xs:annotation>
                <xs:documentation>This will copy embedded files to disk before loading them into memory. This is helpful for some scenarios that expected an assembly to be loaded from a physical file.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="IncludeDebugSymbols" type="xs:boolean">
              <xs:annotation>
                <xs:documentation>Controls if .pdbs for reference assemblies are also embedded.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="IncludeRuntimeReferences" type="xs:boolean">
              <xs:annotation>
                <xs:documentation>Controls if runtime assemblies are also embedded.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="UseRuntimeReferencePaths" type="xs:boolean">
              <xs:annotation>
                <xs:documentation>Controls whether the runtime assemblies are embedded with their full path or only with their assembly name.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="DisableCompression" type="xs:boolean">
              <xs:annotation>
                <xs:documentation>Embedded assemblies are compressed by default, and uncompressed when they are loaded. You can turn compression off with this option.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="DisableCleanup" type="xs:boolean">
              <xs:annotation>
                <xs:documentation>As part of Costura, embedded assemblies are no longer included as part of the build. This cleanup can be turned off.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="LoadAtModuleInit" type="xs:boolean">
              <xs:annotation>
                <xs:documentation>Costura by default will load as part of the module initialization. This flag disables that behavior. Make sure you call CosturaUtility.Initialize() somewhere in your code.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="IgnoreSatelliteAssemblies" type="xs:boolean">
              <xs:annotation>
                <xs:documentation>Costura will by default use assemblies with a name like 'resources.dll' as a satellite resource and prepend the output path. This flag disables that behavior.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="ExcludeAssemblies" type="xs:string">
              <xs:annotation>
                <xs:documentation>A list of assembly names to exclude from the default action of "embed all Copy Local references", delimited with |</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="IncludeAssemblies" type="xs:string">
              <xs:annotation>
                <xs:documentation>A list of assembly names to include from the default action of "embed all Copy Local references", delimited with |.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="ExcludeRuntimeAssemblies" type="xs:string">
              <xs:annotation>
                <xs:documentation>A list of runtime assembly names to exclude from the default action of "embed all Copy Local references", delimited with |</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="IncludeRuntimeAssemblies" type="xs:string">
              <xs:annotation>
                <xs:documentation>A list of runtime assembly names to include from the default action of "embed all Copy Local references", delimited with |.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="Unmanaged32Assemblies" type="xs:string">
              <xs:annotation>
                <xs:documentation>A list of unmanaged 32 bit assembly names to include, delimited with |.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="Unmanaged64Assemblies" type="xs:string">
              <xs:annotation>
                <xs:documentation>A list of unmanaged 64 bit assembly names to include, delimited with |.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="PreloadOrder" type="xs:string">
              <xs:annotation>
                <xs:documentation>The order of preloaded assemblies, delimited with |.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
          </xs:complexType>
        </xs:element>
      </xs:all>
      <xs:attribute name="VerifyAssembly" type="xs:boolean">
        <xs:annotation>
          <xs:documentation>'true' to run assembly verification (PEVerify) on the target assembly after all weavers have been executed.</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="VerifyIgnoreCodes" type="xs:string">
        <xs:annotation>
          <xs:documentation>A comma-separated list of error codes that can be safely ignored in assembly verification.</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="GenerateXsd" type="xs:boolean">
        <xs:annotation>
          <xs:documentation>'false' to turn off automatic generation of the XML Schema file.</xs:documentation>
        </xs:annotation>
      </xs:attribute>
    </xs:complexType>
  </xs:element>
</xs:schema>
```

`LICENSE.md`:

```md
This is free and unencumbered software released into the public domain.

Anyone is free to copy, modify, publish, use, compile, sell, or distribute this software, either in source code form or as a compiled binary, for any purpose, commercial or non-commercial, and by any means.

In jurisdictions that recognize copyright laws, the author or authors of this software dedicate any and all copyright interest in the software to the public domain. We make this dedication for the benefit of the public at large and to the detriment of our heirs and successors. We intend this dedication to be an overt act of relinquishment in perpetuity of all present and future rights to this software under copyright law.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
```

`MainWindow.xaml`:

```xaml
<Window x:Class="BetterHI3Launcher.MainWindow"
		xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
		xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
		xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
		xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
		xmlns:gif="https://github.com/XamlAnimatedGif/XamlAnimatedGif"
		xmlns:local="clr-namespace:BetterHI3Launcher"
		mc:Ignorable="d"
		WindowStyle="None"
		ResizeMode="CanMinimize"
		AllowsTransparency="True"
		Background="{DynamicResource BackgroundShadow}"
		WindowStartupLocation="CenterScreen"
		ContentRendered="Window_ContentRendered"
		Closing="MainWindow_Closing"
		UseLayoutRounding="True"
		TextOptions.TextFormattingMode="Display"
		TextOptions.TextRenderingMode="ClearType"
		Title="Better HI3 Launcher" Width="1300" Height="750">
	<Window.TaskbarItemInfo>
		<TaskbarItemInfo/>
	</Window.TaskbarItemInfo>
	<Window.CommandBindings>
		<CommandBinding Command="{x:Static local:MainWindow.DownloadCacheCommand}" Executed="DownloadCacheCommand_Executed"/>
		<CommandBinding Command="{x:Static local:MainWindow.RepairGameCommand}" Executed="RepairGameCommand_Executed"/>
		<CommandBinding Command="{x:Static local:MainWindow.MoveGameCommand}" Executed="MoveGameCommand_Executed"/>
		<CommandBinding Command="{x:Static local:MainWindow.UninstallGameCommand}" Executed="UninstallGameCommand_Executed"/>
		<CommandBinding Command="{x:Static local:MainWindow.WebProfileCommand}" Executed="WebProfileCommand_Executed"/>
		<CommandBinding Command="{x:Static local:MainWindow.FeedbackCommand}" Executed="FeedbackCommand_Executed"/>
		<CommandBinding Command="{x:Static local:MainWindow.ChangelogCommand}" Executed="ChangelogCommand_Executed"/>
		<CommandBinding Command="{x:Static local:MainWindow.CustomBackgroundCommand}" Executed="CustomBackgroundCommand_Executed"/>
		<CommandBinding Command="{x:Static local:MainWindow.ToggleLogCommand}" Executed="ToggleLogCommand_Executed"/>
		<CommandBinding Command="{x:Static local:MainWindow.ToggleSoundsCommand}" Executed="ToggleSoundsCommand_Executed"/>
		<CommandBinding Command="{x:Static local:MainWindow.AboutCommand}" Executed="AboutCommand_Executed"/>
	</Window.CommandBindings>
	<Window.Resources>
		<local:ProgressToAngleConverter x:Key="ProgressConverter"/>
		<FontFamily x:Key="Font">/BetterHI3Launcher;component/Assets/Fonts/#FZLanTingHei-B-GBK</FontFamily>
		<FontFamily x:Key="FontStatic">/BetterHI3Launcher;component/Assets/Fonts/#FZLanTingHei-B-GBK</FontFamily>
		<BitmapImage x:Key="BackgroundImage" UriSource=""/>
		<BitmapImage x:Key="PreloadCircle" UriSource="/Assets/Images/Button_Preload_Circle.png"/>
		<BitmapImage x:Key="PreloadCheckmark" UriSource="/Assets/Images/Button_Preload_Checkmark.png"/>
		<ImageBrush x:Key="BackgroundShadow" ImageSource="/Assets/Images/BackgroundShadow.png"/>
		<ImageBrush x:Key="Button" ImageSource="/Assets/Images/Button.png"/>
		<ImageBrush x:Key="ButtonPressed" ImageSource="/Assets/Images/Button_Pressed.png"/>
		<ImageBrush x:Key="ButtonDisabled" ImageSource="/Assets/Images/Button_Disabled.png"/>
		<ImageBrush x:Key="CloseButton" ImageSource="/Assets/Images/Button_Close.png"/>
		<ImageBrush x:Key="CloseButtonPressed" ImageSource="/Assets/Images/Button_Close_Pressed.png"/>
		<ImageBrush x:Key="CloseButtonHighlighted" ImageSource="/Assets/Images/Button_Close_Highlighted.png"/>
		<ImageBrush x:Key="MinimizeButton" ImageSource="/Assets/Images/Button_Minimize.png"/>
		<ImageBrush x:Key="MinimizeButtonPressed" ImageSource="/Assets/Images/Button_Minimize_Pressed.png"/>
		<ImageBrush x:Key="MinimizeButtonHighlighted" ImageSource="/Assets/Images/Button_Minimize_Highlighted.png"/>
		<ImageBrush x:Key="BoxCloseButton" ImageSource="/Assets/Images/Button_Box_Close.png"/>
		<ImageBrush x:Key="BoxCloseButtonPressed" ImageSource="/Assets/Images/Button_Box_Close_Pressed.png"/>
		<ImageBrush x:Key="BoxCloseButtonHighlighted" ImageSource="/Assets/Images/Button_Box_Close_Highlighted.png"/>
		<ImageBrush x:Key="PreloadButton" ImageSource="/Assets/Images/Button_Preload.png"/>
		<ImageBrush x:Key="PreloadButtonHighlighted" ImageSource="/Assets/Images/Button_Preload_Highlighted.png"/>
		<ImageBrush x:Key="PreloadButtonPressed" ImageSource="/Assets/Images/Button_Preload_Pressed.png"/>
		<ImageBrush x:Key="PreloadPauseButton" ImageSource="/Assets/Images/Button_Preload_Pause.png"/>
		<ImageBrush x:Key="PreloadResumeButton" ImageSource="/Assets/Images/Button_Preload_Resume.png"/>
		<ImageBrush x:Key="DownloadPauseButton" ImageSource="/Assets/Images/Button_Pause.png"/>
		<ImageBrush x:Key="DownloadPauseButtonHighlighted" ImageSource="/Assets/Images/Button_Pause_Highlighted.png"/>
		<ImageBrush x:Key="DownloadPauseButtonPressed" ImageSource="/Assets/Images/Button_Pause_Pressed.png"/>
		<ImageBrush x:Key="DownloadResumeButton" ImageSource="/Assets/Images/Button_Resume.png"/>
		<ImageBrush x:Key="DownloadResumeButtonHighlighted" ImageSource="/Assets/Images/Button_Resume_Highlighted.png"/>
		<ImageBrush x:Key="DownloadResumeButtonPressed" ImageSource="/Assets/Images/Button_Resume_Pressed.png"/>
		<Style x:Key="FocusVisual">
			<Setter Property="Control.Template">
				<Setter.Value>
					<ControlTemplate>
						<Rectangle UseLayoutRounding="True" StrokeThickness="2" Stroke="{DynamicResource {x:Static SystemColors.MenuHighlightBrushKey}}"/>
					</ControlTemplate>
				</Setter.Value>
			</Setter>
		</Style>
		<Style TargetType="{x:Type ComboBox}">
			<Setter Property="FocusVisualStyle" Value="{StaticResource FocusVisual}"/>
			<Setter Property="FontFamily" Value="{StaticResource FontStatic}"/>
			<Setter Property="SelectedIndex" Value="0"/>
			<Setter Property="Template">
				<Setter.Value>
					<ControlTemplate TargetType="{x:Type ComboBox}">
						<Grid>
							<ToggleButton x:Name="ToggleButton" Grid.Column="2" Focusable="False" ClickMode="Release" IsChecked="{Binding IsDropDownOpen, Mode=TwoWay, RelativeSource={RelativeSource TemplatedParent}}">
								<ToggleButton.Template>
									<ControlTemplate TargetType="{x:Type ToggleButton}">
										<Grid>
											<Grid.ColumnDefinitions>
												<ColumnDefinition/>
												<ColumnDefinition Width="20"/>
											</Grid.ColumnDefinitions>
											<Border x:Name="Border" Grid.ColumnSpan="2" Background="#E0E0E0" BorderBrush="White" BorderThickness="1"/>
											<Path x:Name="Arrow" Grid.Column="1" Fill="Black" HorizontalAlignment="Center" VerticalAlignment="Center" Data="M0,0 L0,2 L4,6 L8,2 L8,0 L4,4 z"/>
										</Grid>
										<ControlTemplate.Triggers>
											<Trigger Property="ToggleButton.IsMouseOver" Value="True">
												<Setter TargetName="Border" Property="Background" Value="#A9A9A9"/>
											</Trigger>
											<Trigger Property="ToggleButton.IsChecked" Value="True">
												<Setter TargetName="Border" Property="Background" Value="Gray"/>
											</Trigger>
											<Trigger Property="IsEnabled" Value="False">
												<Setter TargetName="Border" Property="Background" Value="DimGray"/>
												<Setter TargetName="Border" Property="BorderBrush" Value="DarkGray"/>
											</Trigger>
										</ControlTemplate.Triggers>
									</ControlTemplate>
								</ToggleButton.Template>
							</ToggleButton>
							<ContentPresenter x:Name="ContentSite" IsHitTestVisible="False" Content="{TemplateBinding SelectionBoxItem}" ContentTemplate="{TemplateBinding SelectionBoxItemTemplate}" ContentTemplateSelector="{TemplateBinding ItemTemplateSelector}" Margin="3,3,23,3" VerticalAlignment="Stretch" HorizontalAlignment="Left"/>
							<Popup x:Name="Popup" Placement="Bottom" IsOpen="{TemplateBinding IsDropDownOpen}" Focusable="False">
								<Grid x:Name="DropDown" MinWidth="{TemplateBinding ActualWidth}" MaxHeight="{TemplateBinding MaxDropDownHeight}">
									<Border x:Name="DropDownBorder" BorderThickness="1">
										<Border.BorderBrush>
											<SolidColorBrush Color="White"/>
										</Border.BorderBrush>
										<Border.Background>
											<SolidColorBrush Color="#E0E0E0"/>
										</Border.Background>
									</Border>
									<ScrollViewer>
										<StackPanel IsItemsHost="True" KeyboardNavigation.DirectionalNavigation="Contained"/>
									</ScrollViewer>
								</Grid>
							</Popup>
						</Grid>
						<ControlTemplate.Triggers>
							<Trigger Property="HasItems" Value="False">
								<Setter TargetName="DropDownBorder" Property="MinHeight" Value="95"/>
							</Trigger>
							<Trigger Property="IsGrouping" Value="True">
								<Setter Property="ScrollViewer.CanContentScroll" Value="False"/>
							</Trigger>
						</ControlTemplate.Triggers>
					</ControlTemplate>
				</Setter.Value>
			</Setter>
		</Style>
		<Style x:Key="LaunchButtonStyle" TargetType="{x:Type Button}">
			<Setter Property="FocusVisualStyle" Value="{StaticResource FocusVisual}"/>
			<Setter Property="Background" Value="{StaticResource Button}"/>
			<Setter Property="Foreground" Value="#313131"/>
			<Setter Property="BorderThickness" Value="0"/>
			<Setter Property="HorizontalAlignment" Value="Right"/>
			<Setter Property="VerticalAlignment" Value="Bottom"/>
			<Setter Property="Width" Value="218"/>
			<Setter Property="Height" Value="46"/>
			<Setter Property="FontFamily" Value="{DynamicResource Font}"/>
			<Setter Property="FontSize" Value="24"/>
			<Setter Property="UseLayoutRounding" Value="True"/>
			<Setter Property="Template">
				<Setter.Value>
					<ControlTemplate TargetType="{x:Type Button}">
						<Border x:Name="border" Background="{TemplateBinding Background}" BorderThickness="{TemplateBinding BorderThickness}" BorderBrush="{TemplateBinding BorderBrush}">
							<ContentPresenter x:Name="contentPresenter" Focusable="False" HorizontalAlignment="{TemplateBinding HorizontalContentAlignment}" Margin="{TemplateBinding Padding}" RecognizesAccessKey="True" VerticalAlignment="{TemplateBinding VerticalContentAlignment}"/>
						</Border>
						<ControlTemplate.Triggers>
							<Trigger Property="IsPressed" Value="True">
								<Setter Property="Background" TargetName="border" Value="{StaticResource ButtonPressed}"/>
							</Trigger>
							<Trigger Property="IsEnabled" Value="False">
								<Setter Property="Background" TargetName="border" Value="{StaticResource ButtonDisabled}"/>
								<Setter Property="TextElement.Foreground" TargetName="contentPresenter" Value="#333333"/>
							</Trigger>
						</ControlTemplate.Triggers>
					</ControlTemplate>
				</Setter.Value>
			</Setter>
		</Style>
		<Style x:Key="DownloadPauseButtonStyle" TargetType="{x:Type Button}">
			<Setter Property="FocusVisualStyle" Value="{StaticResource FocusVisual}"/>
			<Setter Property="Background" Value="{StaticResource DownloadPauseButton}"/>
			<Setter Property="BorderThickness" Value="0"/>
			<Setter Property="Width" Value="30"/>
			<Setter Property="Height" Value="30"/>
			<Setter Property="UseLayoutRounding" Value="True"/>
			<Setter Property="Template">
				<Setter.Value>
					<ControlTemplate TargetType="{x:Type Button}">
						<Border x:Name="border" Background="{TemplateBinding Background}" BorderThickness="{TemplateBinding BorderThickness}" BorderBrush="{TemplateBinding BorderBrush}">
							<ContentPresenter x:Name="contentPresenter" Focusable="False" HorizontalAlignment="{TemplateBinding HorizontalContentAlignment}" Margin="{TemplateBinding Padding}" RecognizesAccessKey="True" VerticalAlignment="{TemplateBinding VerticalContentAlignment}"/>
						</Border>
						<ControlTemplate.Triggers>
							<Trigger Property="IsDefaulted" Value="True">
								<Setter Property="BorderBrush" TargetName="border" Value="{DynamicResource {x:Static SystemColors.HighlightBrushKey}}"/>
							</Trigger>
							<Trigger Property="IsMouseOver" Value="True">
								<Setter Property="Background" TargetName="border" Value="{StaticResource DownloadPauseButtonHighlighted}"/>
							</Trigger>
							<Trigger Property="IsPressed" Value="True">
								<Setter Property="Background" TargetName="border" Value="{StaticResource DownloadPauseButtonPressed}"/>
							</Trigger>
						</ControlTemplate.Triggers>
					</ControlTemplate>
				</Setter.Value>
			</Setter>
		</Style>
		<Style x:Key="DownloadResumeButtonStyle" TargetType="{x:Type Button}">
			<Setter Property="FocusVisualStyle" Value="{StaticResource FocusVisual}"/>
			<Setter Property="Background" Value="{StaticResource DownloadResumeButton}"/>
			<Setter Property="BorderThickness" Value="0"/>
			<Setter Property="Width" Value="30"/>
			<Setter Property="Height" Value="30"/>
			<Setter Property="UseLayoutRounding" Value="True"/>
			<Setter Property="Template">
				<Setter.Value>
					<ControlTemplate TargetType="{x:Type Button}">
						<Border x:Name="border" Background="{TemplateBinding Background}" BorderThickness="{TemplateBinding BorderThickness}" BorderBrush="{TemplateBinding BorderBrush}">
							<ContentPresenter x:Name="contentPresenter" Focusable="False" HorizontalAlignment="{TemplateBinding HorizontalContentAlignment}" Margin="{TemplateBinding Padding}" RecognizesAccessKey="True" VerticalAlignment="{TemplateBinding VerticalContentAlignment}"/>
						</Border>
						<ControlTemplate.Triggers>
							<Trigger Property="IsDefaulted" Value="True">
								<Setter Property="BorderBrush" TargetName="border" Value="{DynamicResource {x:Static SystemColors.HighlightBrushKey}}"/>
							</Trigger>
							<Trigger Property="IsMouseOver" Value="True">
								<Setter Property="Background" TargetName="border" Value="{StaticResource DownloadResumeButtonHighlighted}"/>
							</Trigger>
							<Trigger Property="IsPressed" Value="True">
								<Setter Property="Background" TargetName="border" Value="{StaticResource DownloadResumeButtonPressed}"/>
							</Trigger>
						</ControlTemplate.Triggers>
					</ControlTemplate>
				</Setter.Value>
			</Setter>
		</Style>
		<Style x:Key="PreloadButtonStyle" TargetType="{x:Type Button}">
			<Setter Property="FocusVisualStyle" Value="{StaticResource FocusVisual}"/>
			<Setter Property="Background" Value="{StaticResource PreloadButton}"/>
			<Setter Property="BorderThickness" Value="0"/>
			<Setter Property="Width" Value="50"/>
			<Setter Property="Height" Value="50"/>
			<Setter Property="Template">
				<Setter.Value>
					<ControlTemplate TargetType="{x:Type Button}">
						<Border x:Name="border" Background="{TemplateBinding Background}" BorderThickness="{TemplateBinding BorderThickness}" BorderBrush="{TemplateBinding BorderBrush}">
							<ContentPresenter x:Name="contentPresenter" Focusable="False" HorizontalAlignment="{TemplateBinding HorizontalContentAlignment}" Margin="{TemplateBinding Padding}" RecognizesAccessKey="True" VerticalAlignment="{TemplateBinding VerticalContentAlignment}"/>
						</Border>
						<ControlTemplate.Triggers>
							<Trigger Property="IsDefaulted" Value="True">
								<Setter Property="BorderBrush" TargetName="border" Value="{DynamicResource {x:Static SystemColors.HighlightBrushKey}}"/>
							</Trigger>
							<Trigger Property="IsMouseOver" Value="True">
								<Setter Property="Background" TargetName="border" Value="{StaticResource PreloadButtonHighlighted}"/>
							</Trigger>
							<Trigger Property="IsPressed" Value="True">
								<Setter Property="Background" TargetName="border" Value="{StaticResource PreloadButtonPressed}"/>
							</Trigger>
						</ControlTemplate.Triggers>
					</ControlTemplate>
				</Setter.Value>
			</Setter>
		</Style>
		<Style x:Key="PreloadPauseButtonStyle" TargetType="{x:Type Button}">
			<Setter Property="FocusVisualStyle" Value="{StaticResource FocusVisual}"/>
			<Setter Property="Background" Value="{StaticResource PreloadPauseButton}"/>
			<Setter Property="BorderThickness" Value="0"/>
			<Setter Property="Width" Value="50"/>
			<Setter Property="Height" Value="50"/>
			<Setter Property="Template">
				<Setter.Value>
					<ControlTemplate TargetType="{x:Type Button}">
						<Border x:Name="border" Background="{TemplateBinding Background}" BorderThickness="{TemplateBinding BorderThickness}" BorderBrush="{TemplateBinding BorderBrush}">
							<ContentPresenter x:Name="contentPresenter" Focusable="False" HorizontalAlignment="{TemplateBinding HorizontalContentAlignment}" Margin="{TemplateBinding Padding}" RecognizesAccessKey="True" VerticalAlignment="{TemplateBinding VerticalContentAlignment}"/>
						</Border>
						<ControlTemplate.Triggers>
							<Trigger Property="IsDefaulted" Value="True">
								<Setter Property="BorderBrush" TargetName="border" Value="{DynamicResource {x:Static SystemColors.HighlightBrushKey}}"/>
							</Trigger>
						</ControlTemplate.Triggers>
					</ControlTemplate>
				</Setter.Value>
			</Setter>
		</Style>
		<Style x:Key="CloseButtonStyle" TargetType="{x:Type Button}">
			<Setter Property="FocusVisualStyle" Value="{StaticResource FocusVisual}"/>
			<Setter Property="Background" Value="{StaticResource CloseButton}"/>
			<Setter Property="Foreground" Value="#7FA9A9A9"/>
			<Setter Property="BorderThickness" Value="0"/>
			<Setter Property="HorizontalAlignment" Value="Right"/>
			<Setter Property="VerticalAlignment" Value="Top"/>
			<Setter Property="Width" Value="32"/>
			<Setter Property="Height" Value="32"/>
			<Setter Property="FontFamily" Value="{DynamicResource Font}"/>
			<Setter Property="FontWeight" Value="Bold"/>
			<Setter Property="FontSize" Value="16"/>
			<Setter Property="Template">
				<Setter.Value>
					<ControlTemplate TargetType="{x:Type Button}">
						<Border x:Name="border" Background="{TemplateBinding Background}" BorderThickness="{TemplateBinding BorderThickness}" BorderBrush="{TemplateBinding BorderBrush}">
							<ContentPresenter x:Name="contentPresenter" Focusable="False" HorizontalAlignment="{TemplateBinding HorizontalContentAlignment}" Margin="{TemplateBinding Padding}" RecognizesAccessKey="True" VerticalAlignment="{TemplateBinding VerticalContentAlignment}"/>
						</Border>
						<ControlTemplate.Triggers>
							<Trigger Property="IsDefaulted" Value="True">
								<Setter Property="BorderBrush" TargetName="border" Value="{DynamicResource {x:Static SystemColors.HighlightBrushKey}}"/>
							</Trigger>
							<Trigger Property="IsMouseOver" Value="True">
								<Setter Property="Background" TargetName="border" Value="{StaticResource CloseButtonHighlighted}"/>
							</Trigger>
							<Trigger Property="IsPressed" Value="True">
								<Setter Property="Background" TargetName="border" Value="{StaticResource CloseButtonPressed}"/>
							</Trigger>
						</ControlTemplate.Triggers>
					</ControlTemplate>
				</Setter.Value>
			</Setter>
		</Style>
		<Style x:Key="MinimizeButtonStyle" TargetType="{x:Type Button}">
			<Setter Property="FocusVisualStyle" Value="{StaticResource FocusVisual}"/>
			<Setter Property="Background" Value="{StaticResource MinimizeButton}"/>
			<Setter Property="Foreground" Value="#7FA9A9A9"/>
			<Setter Property="BorderThickness" Value="0"/>
			<Setter Property="HorizontalAlignment" Value="Right"/>
			<Setter Property="VerticalAlignment" Value="Top"/>
			<Setter Property="Width" Value="32"/>
			<Setter Property="Height" Value="32"/>
			<Setter Property="FontFamily" Value="{DynamicResource Font}"/>
			<Setter Property="FontWeight" Value="Bold"/>
			<Setter Property="FontSize" Value="16"/>
			<Setter Property="Template">
				<Setter.Value>
					<ControlTemplate TargetType="{x:Type Button}">
						<Border x:Name="border" Background="{TemplateBinding Background}" BorderThickness="{TemplateBinding BorderThickness}" BorderBrush="{TemplateBinding BorderBrush}">
							<ContentPresenter x:Name="contentPresenter" Focusable="False" HorizontalAlignment="{TemplateBinding HorizontalContentAlignment}" Margin="{TemplateBinding Padding}" RecognizesAccessKey="True" VerticalAlignment="{TemplateBinding VerticalContentAlignment}"/>
						</Border>
						<ControlTemplate.Triggers>
							<Trigger Property="IsDefaulted" Value="True">
								<Setter Property="BorderBrush" TargetName="border" Value="{DynamicResource {x:Static SystemColors.HighlightBrushKey}}"/>
							</Trigger>
							<Trigger Property="IsMouseOver" Value="True">
								<Setter Property="Background" TargetName="border" Value="{StaticResource MinimizeButtonHighlighted}"/>
							</Trigger>
							<Trigger Property="IsPressed" Value="True">
								<Setter Property="Background" TargetName="border" Value="{StaticResource MinimizeButtonPressed}"/>
							</Trigger>
						</ControlTemplate.Triggers>
					</ControlTemplate>
				</Setter.Value>
			</Setter>
		</Style>
		<Style x:Key="BoxCloseButtonStyle" TargetType="{x:Type Button}">
			<Setter Property="FocusVisualStyle" Value="{StaticResource FocusVisual}"/>
			<Setter Property="Background" Value="{StaticResource BoxCloseButton}"/>
			<Setter Property="Foreground" Value="#7FA9A9A9"/>
			<Setter Property="BorderThickness" Value="0"/>
			<Setter Property="HorizontalAlignment" Value="Right"/>
			<Setter Property="VerticalAlignment" Value="Top"/>
			<Setter Property="Width" Value="24"/>
			<Setter Property="Height" Value="24"/>
			<Setter Property="Template">
				<Setter.Value>
					<ControlTemplate TargetType="{x:Type Button}">
						<Border x:Name="border" Background="{TemplateBinding Background}" BorderThickness="{TemplateBinding BorderThickness}" BorderBrush="{TemplateBinding BorderBrush}">
							<ContentPresenter x:Name="contentPresenter" Focusable="False" HorizontalAlignment="{TemplateBinding HorizontalContentAlignment}" Margin="{TemplateBinding Padding}" RecognizesAccessKey="True" VerticalAlignment="{TemplateBinding VerticalContentAlignment}"/>
						</Border>
						<ControlTemplate.Triggers>
							<Trigger Property="IsDefaulted" Value="True">
								<Setter Property="BorderBrush" TargetName="border" Value="{DynamicResource {x:Static SystemColors.HighlightBrushKey}}"/>
							</Trigger>
							<Trigger Property="IsMouseOver" Value="True">
								<Setter Property="Background" TargetName="border" Value="{StaticResource BoxCloseButtonHighlighted}"/>
							</Trigger>
							<Trigger Property="IsPressed" Value="True">
								<Setter Property="Background" TargetName="border" Value="{StaticResource BoxCloseButtonPressed}"/>
							</Trigger>
						</ControlTemplate.Triggers>
					</ControlTemplate>
				</Setter.Value>
			</Setter>
		</Style>
		<Style x:Key="WhiteButtonStyle" TargetType="{x:Type Button}">
			<Setter Property="FocusVisualStyle" Value="{StaticResource FocusVisual}"/>
			<Setter Property="BorderBrush" Value="White"/>
			<Setter Property="Margin" Value="10"/>
			<Setter Property="Padding" Value="3,1,3,1"/>
			<Setter Property="FontFamily" Value="{DynamicResource Font}"/>
			<Setter Property="FontSize" Value="18"/>
			<Setter Property="UseLayoutRounding" Value="True"/>
			<Setter Property="Template">
				<Setter.Value>
					<ControlTemplate TargetType="{x:Type Button}">
						<Border x:Name="border" Background="#E0E0E0" BorderThickness="{TemplateBinding BorderThickness}" BorderBrush="{TemplateBinding BorderBrush}">
							<ContentPresenter x:Name="contentPresenter" Focusable="False" HorizontalAlignment="{TemplateBinding HorizontalContentAlignment}" Margin="{TemplateBinding Padding}" RecognizesAccessKey="True" VerticalAlignment="{TemplateBinding VerticalContentAlignment}"/>
						</Border>
						<ControlTemplate.Triggers>
							<Trigger Property="IsMouseOver" Value="True">
								<Setter Property="Background" TargetName="border" Value="#A9A9A9"/>
							</Trigger>
							<Trigger Property="IsPressed" Value="True">
								<Setter Property="Background" TargetName="border" Value="Gray"/>
							</Trigger>
							<Trigger Property="IsEnabled" Value="False">
								<Setter Property="Background" TargetName="border" Value="DimGray"/>
								<Setter Property="BorderBrush" TargetName="border" Value="DarkGray"/>
								<Setter Property="TextElement.Foreground" TargetName="contentPresenter" Value="#333333"/>
							</Trigger>
						</ControlTemplate.Triggers>
					</ControlTemplate>
				</Setter.Value>
			</Setter>
		</Style>
		<Style x:Key="CheckBoxStyle" TargetType="{x:Type CheckBox}">
			<Setter Property="FocusVisualStyle" Value="{StaticResource FocusVisual}"/>
			<Setter Property="Width" Value="48"/>
			<Setter Property="Height" Value="36"/>
			<Setter Property="UseLayoutRounding" Value="True"/>
			<Setter Property="Template">
				<Setter.Value>
					<ControlTemplate TargetType="{x:Type CheckBox}">
						<StackPanel Orientation="Horizontal">
							<Image x:Name="Image" Source="/Assets/Images/Checkbox_On.png"/>
							<ContentPresenter/>
						</StackPanel>
						<ControlTemplate.Triggers>
							<Trigger Property="IsChecked" Value="True">
								<Setter TargetName="Image" Property="Source" Value="/Assets/Images/Checkbox_On.png"/>
							</Trigger>
							<Trigger Property="IsChecked" Value="False">
								<Setter TargetName="Image" Property="Source" Value="/Assets/Images/Checkbox_Off.png"/>
							</Trigger>
							<Trigger Property="IsEnabled" Value="False">
								<Setter TargetName="Image" Property="Source" Value="/Assets/Images/Checkbox_Disabled.png"/>
							</Trigger>
						</ControlTemplate.Triggers>
					</ControlTemplate>
				</Setter.Value>
			</Setter>
		</Style>
		<Style x:Key="ProgressBarStyle" TargetType="{x:Type ProgressBar}" >
			<Setter Property="Maximum" Value="1"/>
			<Setter Property="Template">
				<Setter.Value>
					<ControlTemplate TargetType="{x:Type ProgressBar}">
						<Grid>
							<VisualStateManager.VisualStateGroups>
								<VisualStateGroup x:Name="CommonStates">
									<VisualState x:Name="Determinate" />
									<VisualState x:Name="Indeterminate">
										<Storyboard>
											<ObjectAnimationUsingKeyFrames Duration="00:00:00"
                                                 Storyboard.TargetName="PART_Indicator"
                                                 Storyboard.TargetProperty="Background">
												<DiscreteObjectKeyFrame KeyTime="00:00:00">
													<DiscreteObjectKeyFrame.Value>
														<SolidColorBrush>Transparent</SolidColorBrush>
													</DiscreteObjectKeyFrame.Value>
												</DiscreteObjectKeyFrame>
											</ObjectAnimationUsingKeyFrames>
										</Storyboard>
									</VisualState>
								</VisualStateGroup>
							</VisualStateManager.VisualStateGroups>
							<Border Name="PART_Track" Background="#7FFFFFFF" BorderBrush="White" BorderThickness="1"/>
							<Border Name="PART_Indicator" Background="Green" BorderThickness="1" HorizontalAlignment="Left">
								<Border.BorderBrush>
									<LinearGradientBrush StartPoint="0,0" EndPoint="0,1">
										<GradientBrush.GradientStops>
											<GradientStopCollection>
												<GradientStop Color="{DynamicResource BorderLightColor}" Offset="0.0" />
												<GradientStop Color="{DynamicResource BorderMediumColor}" Offset="1.0" />
											</GradientStopCollection>
										</GradientBrush.GradientStops>
									</LinearGradientBrush>
								</Border.BorderBrush>
								<Grid ClipToBounds="True" x:Name="Animation">
									<Rectangle x:Name="PART_GlowRect" Width="50" HorizontalAlignment="Left" Fill="Green" Margin="-50,0,0,0"/>
								</Grid>
							</Border>
						</Grid>
					</ControlTemplate>
				</Setter.Value>
			</Setter>
		</Style>
		<Style x:Key="DownloadProgressBarStyle" TargetType="{x:Type ProgressBar}">
			<Setter Property="Maximum" Value="1"/>
			<Setter Property="Template">
				<Setter.Value>
					<ControlTemplate TargetType="{x:Type ProgressBar}">
						<Grid>
							<Border BorderBrush="#7FFFFFFF" BorderThickness="2"/>
							<Border Name="PART_Track" Background="#32FFFFFF" Margin="4"/>
							<Border Name="PART_Indicator" Background="White" HorizontalAlignment="Left" Margin="4"/>
						</Grid>
					</ControlTemplate>
				</Setter.Value>
			</Setter>
		</Style>
		<Style x:Key="RadialProgressBarStyle" TargetType="{x:Type ProgressBar}">
			<Setter Property="Maximum" Value="1"/>
			<Setter Property="BorderBrush" Value="#FFCD0C"/>
			<Setter Property="Template">
				<Setter.Value>
					<ControlTemplate TargetType="{x:Type ProgressBar}">
						<Grid>
							<local:Arc StrokeThickness="30" Stroke="{TemplateBinding BorderBrush}">
								<local:Arc.StartAngle>
									<MultiBinding Converter="{StaticResource ProgressConverter}">
										<Binding Path="Minimum" RelativeSource="{RelativeSource TemplatedParent}"/>
										<Binding Path="." RelativeSource="{RelativeSource TemplatedParent}"/>
									</MultiBinding>
								</local:Arc.StartAngle>
								<local:Arc.EndAngle>
									<MultiBinding Converter="{StaticResource ProgressConverter}">
										<Binding Path="Value" RelativeSource="{RelativeSource TemplatedParent}"/>
										<Binding Path="." RelativeSource="{RelativeSource TemplatedParent}"/>
									</MultiBinding>
								</local:Arc.EndAngle>
							</local:Arc>
						</Grid>
					</ControlTemplate>
				</Setter.Value>
			</Setter>
		</Style>
	</Window.Resources>
	<Grid>
		<Grid Name="Grid" Width="1280" Height="730">
			<Image Name="BackgroundImage" Stretch="Fill" Source="{DynamicResource BackgroundImage}"/>
			<MediaElement Name="BackgroundMedia" IsMuted="True" Stretch="Fill" Focusable="False" ScrubbingEnabled="True" Visibility="Collapsed"/>
			<Rectangle VerticalAlignment="Top" HorizontalAlignment="Right" Width="64" Height="32" Fill="#C8141414"/>
			<Button Name="CloseButton" Style="{DynamicResource CloseButtonStyle}" Click="CloseButton_Click"/>
			<Button Name="MinimizeButton" Style="{DynamicResource MinimizeButtonStyle}" Margin="0,0,32,0" Click="MinimizeButton_Click"/>
			<StackPanel VerticalAlignment="Bottom" HorizontalAlignment="Right" Margin="0,0,57,0" MaxWidth="218">
				<TextBlock Name="ProgressText" HorizontalAlignment="Center" Margin="0,0,0,5" Foreground="White" FontFamily="{DynamicResource Font}" FontSize="12" TextAlignment="Center" TextWrapping="Wrap">
					<TextBlock.Effect>
						<DropShadowEffect ShadowDepth="0"/>
					</TextBlock.Effect>
				</TextBlock>
				<StackPanel HorizontalAlignment="Center">
					<ProgressBar Name="ProgressBar" Style="{StaticResource ProgressBarStyle}" Margin="0,0,0,5" Height="5" Visibility="Collapsed"/>
					<StackPanel Orientation="Horizontal" HorizontalAlignment="Right" Margin="0,0,0,5">
						<TextBlock Name="ServerLabel" Margin="0,0,5,0" Foreground="White" FontFamily="{DynamicResource Font}" FontSize="16">
							<TextBlock.Effect>
								<DropShadowEffect BlurRadius="1" ShadowDepth="2"/>
							</TextBlock.Effect>
						</TextBlock>
						<ComboBox Name="ServerDropdown" Width="120" Height="20" DropDownOpened="ServerDropdown_Opened" SelectionChanged="ServerDropdown_Changed">
							<ComboBoxItem Content="Global"/>
							<ComboBoxItem Content="SEA"/>
							<ComboBoxItem Content="CN"/>
							<ComboBoxItem Content="TW/HK/MO"/>
							<ComboBoxItem Content="KR"/>
						</ComboBox>
					</StackPanel>
					<StackPanel Orientation="Horizontal" HorizontalAlignment="Right" Margin="0,0,0,10">
						<TextBlock Name="MirrorLabel" Margin="0,0,5,0" Foreground="White" FontFamily="{DynamicResource Font}" FontSize="16">
							<TextBlock.Effect>
								<DropShadowEffect BlurRadius="1" ShadowDepth="2"/>
							</TextBlock.Effect>
						</TextBlock>
						<ComboBox Name="MirrorDropdown" Width="120" Height="20" DropDownOpened="MirrorDropdown_Opened" SelectionChanged="MirrorDropdown_Changed">
							<ComboBoxItem Content="HoYoverse"/>
							<ComboBoxItem Content="Hi3Mirror"/>
						</ComboBox>
					</StackPanel>
				</StackPanel>
				<Button Name="OptionsButton" Style="{DynamicResource LaunchButtonStyle}" Margin="0,0,0,13" Click="OptionsButton_Click" IsEnabled="False">
					<Button.ContextMenu>
						<ContextMenu Name="OptionsContextMenu"/>
					</Button.ContextMenu>
				</Button>
				<Button Name="LaunchButton" Style="{DynamicResource LaunchButtonStyle}" Margin="0,0,0,8" Click="LaunchButton_Click" IsEnabled="False"/>
				<TextBlock Name="GameVersionText" HorizontalAlignment="Center" Margin="0,0,0,25" Foreground="#A7FFFFFF" FontFamily="{DynamicResource Font}" FontSize="12">
					<TextBlock.Effect>
						<DropShadowEffect ShadowDepth="0"/>
					</TextBlock.Effect>
				</TextBlock>
			</StackPanel>
			<Grid Name="PreloadGrid" Visibility="Collapsed">
				<Grid HorizontalAlignment="Right" VerticalAlignment="Bottom" Margin="0,0,364,50" Width="240" Height="50">
					<StackPanel Orientation="Horizontal">
						<Grid HorizontalAlignment="Left">
							<Grid.RowDefinitions>
								<RowDefinition Height="*"/>
								<RowDefinition Height="auto"/>
							</Grid.RowDefinitions>
							<Button Name="PreloadButton" Style="{DynamicResource PreloadButtonStyle}" Click="PreloadButton_Click"/>
							<Image Name="PreloadCircle" Source="{StaticResource PreloadCircle}" Visibility="Collapsed"/>
							<Viewbox>
								<ProgressBar Name="PreloadCircleProgressBar" Style="{StaticResource RadialProgressBarStyle}" Margin="20" Width="400" Height="400" Visibility="Collapsed"/>
							</Viewbox>
							<Button Name="PreloadPauseButton" Style="{DynamicResource PreloadPauseButtonStyle}" Click="PreloadPauseButton_Click" Visibility="Collapsed"/>
							<Image Name="PreloadCheckmark" Source="{StaticResource PreloadCheckmark}" Visibility="Collapsed"/>
						</Grid>
						<Grid Margin="12,0">
							<StackPanel VerticalAlignment="Center">
								<StackPanel.Resources>
									<Style TargetType="{x:Type TextBlock}">
										<Setter Property="Margin" Value="0,2"/>
										<Setter Property="FontFamily" Value="{DynamicResource Font}"/>
									</Style>
								</StackPanel.Resources>
								<Viewbox HorizontalAlignment="Left" StretchDirection="DownOnly" Stretch="Fill" Width="178">
									<TextBlock Name="PreloadTopText" Foreground="White" FontSize="16">
										<TextBlock.Effect>
											<DropShadowEffect BlurRadius="1" ShadowDepth="2"/>
										</TextBlock.Effect>
									</TextBlock>
								</Viewbox>
								<Viewbox HorizontalAlignment="Left" StretchDirection="DownOnly" Stretch="Fill" Width="178">
									<TextBlock Name="PreloadBottomText" Foreground="#FFCB0B" FontSize="14">
										<TextBlock.Effect>
											<DropShadowEffect BlurRadius="1" ShadowDepth="2"/>
										</TextBlock.Effect>
									</TextBlock>
								</Viewbox>
							</StackPanel>
						</Grid>
					</StackPanel>
				</Grid>
				<Grid Name="PreloadStatusGrid" HorizontalAlignment="Right" VerticalAlignment="Bottom" Margin="0,0,617,30" Width="315" Height="90" Background="#80000000">
					<Grid.Style>
						<Style TargetType="{x:Type Grid}">
							<Setter Property="Visibility" Value="Hidden"/>
							<Style.Triggers>
								<DataTrigger Binding="{Binding IsMouseOver, ElementName=PreloadPauseButton}" Value="True">
									<Setter Property="Visibility" Value="Visible"/>
								</DataTrigger>
							</Style.Triggers>
						</Style>
					</Grid.Style>
					<StackPanel HorizontalAlignment="Left">
						<StackPanel.Resources>
							<Style TargetType="{x:Type TextBlock}">
								<Setter Property="Margin" Value="12,12,0,0"/>
								<Setter Property="Foreground" Value="White"/>
								<Setter Property="FontFamily" Value="{DynamicResource Font}"/>
								<Setter Property="FontSize" Value="12"/>
							</Style>
						</StackPanel.Resources>
						<TextBlock Name="PreloadStatusTopLeftText"/>
						<TextBlock Name="PreloadStatusMiddleLeftText"/>
						<TextBlock Name="PreloadStatusBottomLeftText"/>
					</StackPanel>
					<StackPanel HorizontalAlignment="Right">
						<StackPanel.Resources>
							<Style TargetType="{x:Type TextBlock}">
								<Setter Property="Margin" Value="0,12,12,0"/>
								<Setter Property="Foreground" Value="White"/>
								<Setter Property="FontFamily" Value="{DynamicResource Font}"/>
								<Setter Property="FontSize" Value="12"/>
								<Setter Property="TextAlignment" Value="Right"/>
							</Style>
						</StackPanel.Resources>
						<TextBlock Name="PreloadStatusTopRightText"/>
						<TextBlock Name="PreloadStatusMiddleRightText"/>
						<TextBlock Name="PreloadStatusBottomRightText"/>
					</StackPanel>
				</Grid>
			</Grid>
			<StackPanel Name="DownloadProgressBarStackPanel" Orientation="Vertical" HorizontalAlignment="Left" VerticalAlignment="Bottom" Margin="50,36">
				<TextBlock Name="DownloadProgressText" VerticalAlignment="Center" HorizontalAlignment="Left" FontFamily="{DynamicResource Font}" FontSize="14" Foreground="White">
					<TextBlock.Effect>
						<DropShadowEffect BlurRadius="1" ShadowDepth="2"/>
					</TextBlock.Effect>
				</TextBlock>
				<TextBlock Name="DownloadETAText" VerticalAlignment="Center" HorizontalAlignment="Right" Margin="0,-15,3,0" FontFamily="{DynamicResource Font}" FontSize="14" Foreground="#FFD847">
					<TextBlock.Effect>
						<DropShadowEffect BlurRadius="1" ShadowDepth="2"/>
					</TextBlock.Effect>
				</TextBlock>
				<StackPanel Orientation="Horizontal">
					<ProgressBar Name="DownloadProgressBar" Style="{StaticResource DownloadProgressBarStyle}" VerticalAlignment="Bottom" HorizontalAlignment="Left" Margin="0,4,0,8" Width="776" Height="24"/>
					<Button Name="DownloadPauseButton" Style="{DynamicResource DownloadPauseButtonStyle}" Margin="10,0,0,4" Click="DownloadPauseButton_Click"/>
					<Button Name="DownloadResumeButton" Style="{DynamicResource DownloadResumeButtonStyle}" Margin="10,0,0,4" Click="DownloadPauseButton_Click" Visibility="Collapsed"/>
				</StackPanel>
				<TextBlock Name="DownloadSpeedText" VerticalAlignment="Center" HorizontalAlignment="Left" FontFamily="{DynamicResource Font}" FontSize="14" Foreground="#C8FFFFFF">
					<TextBlock.Effect>
						<DropShadowEffect BlurRadius="1" ShadowDepth="2"/>
					</TextBlock.Effect>
				</TextBlock>
			</StackPanel>
			<Grid Name="LogBox" Margin="10,128" HorizontalAlignment="Left" VerticalAlignment="Bottom" Width="900" Height="470" UseLayoutRounding="True" Visibility="Collapsed">
				<StackPanel>
					<ScrollViewer Name="LogBoxScrollViewer" Width="{Binding Path=ActualWidth, ElementName=LogBox, Mode=OneWay}" Height="{Binding Path=ActualHeight, ElementName=LogBox, Mode=OneWay}" ScrollViewer.HorizontalScrollBarVisibility="Auto" ScrollViewer.VerticalScrollBarVisibility="Auto">
						<RichTextBox Name="LogBoxRichTextBox" HorizontalAlignment="Stretch" VerticalAlignment="Stretch" Background="#C8000000" Foreground="White" FontFamily="Consolas" FocusVisualStyle="{StaticResource FocusVisual}" IsReadOnly="True">
							<RichTextBox.Resources>
								<Style TargetType="{x:Type Paragraph}">
									<Setter Property="Margin" Value="0"/>
								</Style>
							</RichTextBox.Resources>
						</RichTextBox>
					</ScrollViewer>
				</StackPanel>
			</Grid>
			<Grid Name="IntroBox" Background="#80000000" Visibility="Collapsed">
				<Grid HorizontalAlignment="Center" VerticalAlignment="Center" Width="644" Background="#C8FFFFFF">
					<StackPanel>
						<TextBlock Name="IntroBoxTitleTextBlock" Margin="25,5,25,5" FontFamily="{DynamicResource Font}" FontWeight="Bold" FontSize="15" TextAlignment="Center"/>
						<TextBlock Name="IntroBoxMessageTextBlock" Margin="150,0,22,0" FontFamily="Segoe UI" TextWrapping="Wrap"/>
					</StackPanel>
					<StackPanel Orientation="Horizontal" HorizontalAlignment="Center" VerticalAlignment="Bottom">
						<Button Name="IntroBoxOKButton" Style="{DynamicResource WhiteButtonStyle}" Click="IntroBoxCloseButton_Click"/>
					</StackPanel>
					<Image gif:AnimationBehavior.SourceUri="Assets/Images/HoV_Dance.gif" HorizontalAlignment="Left" VerticalAlignment="Top" Margin="16,25,0,18" Width="128"/>
					<Button Name="IntroBoxCloseButton" Style="{DynamicResource BoxCloseButtonStyle}" Click="IntroBoxCloseButton_Click"/>
				</Grid>
			</Grid>
			<Grid Name="RepairBox" Background="#80000000" Visibility="Collapsed">
				<Grid HorizontalAlignment="Center" VerticalAlignment="Center" Width="644" Background="#C8FFFFFF">
					<StackPanel>
						<StackPanel>
							<TextBlock Name="RepairBoxTitleTextBlock" Margin="25,5,25,5" FontFamily="{DynamicResource Font}" FontWeight="Bold" FontSize="15" TextAlignment="Center"/>
							<TextBlock Name="RepairBoxMessageTextBlock" Margin="22,0,22,5" FontFamily="Segoe UI" TextWrapping="Wrap"/>
						</StackPanel>
						<StackPanel Orientation="Horizontal" HorizontalAlignment="Center">
							<Button Name="RepairBoxYesButton" Style="{DynamicResource WhiteButtonStyle}" Click="RepairBoxYesButton_Click"/>
							<Button Name="RepairBoxNoButton" Style="{DynamicResource WhiteButtonStyle}" Click="RepairBoxCloseButton_Click"/>
							<Button Name="RepairBoxGenerateButton" Style="{DynamicResource WhiteButtonStyle}" Click="RepairBoxGenerateButton_Click"/>
						</StackPanel>
					</StackPanel>
					<Button Name="RepairBoxCloseButton" Style="{DynamicResource BoxCloseButtonStyle}" Click="RepairBoxCloseButton_Click"/>
				</Grid>
			</Grid>
			<Grid Name="FPSInputBox" Background="#80000000" Visibility="Collapsed">
				<Grid HorizontalAlignment="Center" VerticalAlignment="Center" Background="#C8FFFFFF">
					<StackPanel>
						<TextBlock Name="FPSInputBoxTitleTextBlock" Margin="25,5,25,5" FontFamily="{DynamicResource Font}" FontWeight="Bold" FontSize="15" TextAlignment="Center"/>
						<DockPanel Height="26" Margin="100,5">
							<TextBlock Name="CombatFPSInputBoxTextBlock" Margin="25,5,25,0" FontFamily="{DynamicResource Font}" FontWeight="Bold" FontSize="15" TextAlignment="Center"/>
							<TextBox Name="CombatFPSInputBoxTextBox" HorizontalAlignment="Right" VerticalAlignment="Center" Width="50" Height="25" MaxLength="3" FontFamily="Segoe UI" FontWeight="Bold" FontSize="16" TextAlignment="Center" PreviewTextInput="FPSInputBoxTextBox_PreviewTextInput" DataObject.Pasting="FPSInputBoxTextBox_Pasting"/>
						</DockPanel>
						<DockPanel Height="26" Margin="100,5">
							<TextBlock Name="MenuFPSInputBoxTextBlock" Margin="25,5,25,0" FontFamily="{DynamicResource Font}" FontWeight="Bold" FontSize="15" TextAlignment="Center"/>
							<TextBox Name="MenuFPSInputBoxTextBox" HorizontalAlignment="Right" VerticalAlignment="Center" Width="50" Height="25" MaxLength="3" FontFamily="Segoe UI" FontWeight="Bold" FontSize="16" TextAlignment="Center" PreviewTextInput="FPSInputBoxTextBox_PreviewTextInput" DataObject.Pasting="FPSInputBoxTextBox_Pasting"/>
						</DockPanel>
						<StackPanel Orientation="Horizontal" HorizontalAlignment="Center">
							<Button Name="FPSInputBoxOKButton" Style="{DynamicResource WhiteButtonStyle}" Click="FPSInputBoxOKButton_Click"/>
							<Button Name="FPSInputBoxCancelButton" Style="{DynamicResource WhiteButtonStyle}" Click="FPSInputBoxCancelButton_Click"/>
						</StackPanel>
					</StackPanel>
					<Button Name="FPSInputBoxCloseButton" Style="{DynamicResource BoxCloseButtonStyle}" Click="FPSInputBoxCancelButton_Click"/>
				</Grid>
			</Grid>
			<Grid Name="ResolutionInputBox" Background="#80000000" Visibility="Collapsed">
				<Grid HorizontalAlignment="Center" VerticalAlignment="Center" Background="#C8FFFFFF">
					<StackPanel>
						<TextBlock Name="ResolutionInputBoxTitleTextBlock" Margin="25,5,25,5" FontFamily="{DynamicResource Font}" FontWeight="Bold" FontSize="15" TextAlignment="Center"/>
						<DockPanel Height="26" Margin="100,5">
							<TextBlock Name="ResolutionInputBoxWidthTextBlock" Margin="25,5,25,0" FontFamily="{DynamicResource Font}" FontWeight="Bold" FontSize="15" TextAlignment="Center"/>
							<TextBox Name="ResolutionInputBoxWidthTextBox" HorizontalAlignment="Right" VerticalAlignment="Center" Width="50" Height="25" MaxLength="4" FontFamily="Segoe UI" FontWeight="Bold" FontSize="16" TextAlignment="Center" PreviewTextInput="FPSInputBoxTextBox_PreviewTextInput" DataObject.Pasting="FPSInputBoxTextBox_Pasting"/>
						</DockPanel>
						<DockPanel Height="26" Margin="100,5">
							<TextBlock Name="ResolutionInputBoxHeightTextBlock" Margin="25,5,25,0" FontFamily="{DynamicResource Font}" FontWeight="Bold" FontSize="15" TextAlignment="Center"/>
							<TextBox Name="ResolutionInputBoxHeightTextBox" HorizontalAlignment="Right" VerticalAlignment="Center" Width="50" Height="25" MaxLength="4" FontFamily="Segoe UI" FontWeight="Bold" FontSize="16" TextAlignment="Center" PreviewTextInput="FPSInputBoxTextBox_PreviewTextInput" DataObject.Pasting="FPSInputBoxTextBox_Pasting"/>
						</DockPanel>
						<DockPanel Height="26" Margin="100,5">
							<TextBlock Name="ResolutionInputBoxFullscreenTextBlock" Margin="25,5,25,0" FontFamily="{DynamicResource Font}" FontWeight="Bold" FontSize="15" TextAlignment="Center"/>
							<CheckBox Name="ResolutionInputBoxFullscreenCheckbox" Margin="25,5,25,0" HorizontalAlignment="Right"/>
						</DockPanel>
						<StackPanel Orientation="Horizontal" HorizontalAlignment="Center">
							<Button Name="ResolutionInputBoxOKButton" Style="{DynamicResource WhiteButtonStyle}" Click="ResolutionInputBoxOKButton_Click"/>
							<Button Name="ResolutionInputBoxCancelButton" Style="{DynamicResource WhiteButtonStyle}" Click="ResolutionInputBoxCancelButton_Click"/>
						</StackPanel>
					</StackPanel>
					<Button Name="ResolutionInputBoxCloseButton" Style="{DynamicResource BoxCloseButtonStyle}" Click="ResolutionInputBoxCancelButton_Click"/>
				</Grid>
			</Grid>
			<Grid Name="ChangelogBox" Background="#80000000" Visibility="Collapsed">
				<Grid HorizontalAlignment="Center" VerticalAlignment="Center" Width="844" Background="#C8FFFFFF">
					<StackPanel>
						<TextBlock Name="ChangelogBoxTitleTextBlock" Margin="25,5,25,5" FontFamily="{DynamicResource Font}" FontWeight="Bold" FontSize="15" TextAlignment="Center"/>
						<TextBlock Name="ChangelogBoxMessageTextBlock" Margin="22,0,22,5" FontFamily="Segoe UI" Visibility="Collapsed"/>
						<ScrollViewer Name="ChangelogBoxScrollViewer" Margin="14,0,14,0" Width="800" Height="325" ScrollViewer.VerticalScrollBarVisibility="Auto">
							<TextBox Name="ChangelogBoxTextBox" HorizontalAlignment="Stretch" VerticalAlignment="Stretch" Background="#19000000" FontFamily="Consolas" IsReadOnly="True" TextWrapping="Wrap"/>
						</ScrollViewer>
						<StackPanel Orientation="Horizontal" HorizontalAlignment="Center">
							<Button Name="ChangelogBoxOKButton" Style="{DynamicResource WhiteButtonStyle}" Click="ChangelogBoxCloseButton_Click"/>
						</StackPanel>
					</StackPanel>
					<Button Name="ChangelogBoxCloseButton" Style="{DynamicResource BoxCloseButtonStyle}" Click="ChangelogBoxCloseButton_Click"/>
				</Grid>
			</Grid>
			<Grid Name="AboutBox" Background="#80000000" Visibility="Collapsed">
				<Grid HorizontalAlignment="Center" VerticalAlignment="Center" Width="644" Background="#C8FFFFFF">
					<StackPanel>
						<StackPanel>
							<TextBlock Name="AboutBoxTitleTextBlock" Margin="25,5,25,5" FontFamily="{DynamicResource Font}" FontWeight="Bold" FontSize="15" TextAlignment="Center"/>
							<TextBlock Name="AboutBoxAppNameTextBlock" Margin="150,0,25,0" Text="Better HI3 Launcher" FontFamily="Segoe UI" FontWeight="Bold" FontSize="15"/>
							<TextBlock Name="AboutBoxMessageTextBlock" Margin="150,0,22,0" FontFamily="Segoe UI" TextWrapping="Wrap"/>
						</StackPanel>
						<StackPanel Orientation="Horizontal" HorizontalAlignment="Center">
							<Button Name="AboutBoxGitHubButton" Style="{DynamicResource WhiteButtonStyle}" Click="AboutBoxGitHubButton_Click"/>
							<Button Name="AboutBoxOKButton" Style="{DynamicResource WhiteButtonStyle}" Click="AboutBoxCloseButton_Click"/>
						</StackPanel>
					</StackPanel>
					<Image gif:AnimationBehavior.SourceUri="Assets/Images/HoV_Dance.gif" HorizontalAlignment="Left" VerticalAlignment="Top" Margin="16,25,0,18" Width="128"/>
					<Button Name="AboutBoxCloseButton" Style="{DynamicResource BoxCloseButtonStyle}" Click="AboutBoxCloseButton_Click"/>
				</Grid>
			</Grid>
			<Grid Name="AnnouncementBox" Background="#80000000" Visibility="Collapsed">
				<Grid HorizontalAlignment="Center" VerticalAlignment="Center" MaxWidth="844" Background="#C8FFFFFF">
					<StackPanel>
						<TextBlock Name="AnnouncementBoxTitleTextBlock" Margin="25,5,25,5" FontFamily="{DynamicResource Font}" FontWeight="Bold" FontSize="15" TextAlignment="Center"/>
						<ScrollViewer Name="AnnouncementBoxScrollViewer" Margin="14,0,14,0" MaxHeight="325" ScrollViewer.VerticalScrollBarVisibility="Auto">
							<TextBlock Name="AnnouncementBoxMessageTextBlock" FontFamily="Segoe UI" TextWrapping="Wrap" FontSize="14"/>
						</ScrollViewer>
						<CheckBox Name="AnnouncementBoxDoNotShowCheckbox" Margin="14,5,25,0" HorizontalAlignment="Center"/>
						<StackPanel Orientation="Horizontal" HorizontalAlignment="Center">
							<Button Name="AnnouncementBoxOKButton" Style="{DynamicResource WhiteButtonStyle}" Click="AnnouncementBoxCloseButton_Click"/>
						</StackPanel>
					</StackPanel>
					<Button Name="AnnouncementBoxCloseButton" Style="{DynamicResource BoxCloseButtonStyle}" Click="AnnouncementBoxCloseButton_Click"/>
				</Grid>
			</Grid>
		</Grid>
	</Grid>
</Window>
```

`MainWindow.xaml.cs`:

```cs
using IniParser;
using IniParser.Model;
using Microsoft.Win32;
using Newtonsoft.Json;
using PartialZip;
using SharpCompress.Archives;
using SharpCompress.Common;
using SharpCompress.Readers;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Dynamic;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Net;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using System.Web;
using System.Windows;
using System.Windows.Automation.Peers;
using System.Windows.Automation.Provider;
using System.Windows.Controls;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Shell;
using Hi3Helper.Http;

namespace BetterHI3Launcher
{
	enum LauncherStatus
	{
		Ready, Error, CheckingUpdates, Downloading, Updating, Verifying, Unpacking, UpdateAvailable, Uninstalling, Working, DownloadPaused, Running, Preloading, PreloadVerifying
	}
	enum HI3Server
	{
		GLB, SEA, CN, TW, KR
	}
	enum HI3Mirror
	{
		miHoYo, Hi3Mirror
	}

	class HttpProp
	{
		public HttpProp(string URL, string Out)
		{
			this.URL = URL;
			this.Out = Out;
		}
		public string URL{get;private set;}
		public string Out{get;private set;}
		public byte Thread => (byte)App.ParallelDownloadSessions;
	}

	public partial class MainWindow : Window
	{
		public static readonly string miHoYoPath = Path.Combine(App.LocalLowPath, "miHoYo");
		public static string GameInstallPath, GameCachePath, GameRegistryPath, GameArchivePath, GameArchiveTempPath, GameExePath;
		public static string RegistryVersionInfo;
		public static string GameWebProfileURL, GameFullName, GameArchiveName, GameExeName, GameInstallRegistryName;
		public static bool DownloadPaused, PatchDownload, PreloadDownload, BackgroundImageDownloading, LegacyBoxActive;
		public static int PatchDownloadInt;
		public static RoutedCommand DownloadCacheCommand = new RoutedCommand();
		public static RoutedCommand RepairGameCommand = new RoutedCommand();
		public static RoutedCommand MoveGameCommand = new RoutedCommand();
		public static RoutedCommand UninstallGameCommand = new RoutedCommand();
		public static RoutedCommand WebProfileCommand = new RoutedCommand();
		public static RoutedCommand FeedbackCommand = new RoutedCommand();
		public static RoutedCommand ChangelogCommand = new RoutedCommand();
		public static RoutedCommand CustomBackgroundCommand = new RoutedCommand();
		public static RoutedCommand ToggleLogCommand = new RoutedCommand();
		public static RoutedCommand ToggleSoundsCommand = new RoutedCommand();
		public static RoutedCommand AboutCommand = new RoutedCommand();
		public dynamic LocalVersionInfo, OnlineVersionInfo, OnlineRepairInfo, miHoYoVersionInfo;
		public dynamic GameGraphicSettings, GameScreenSettings;
		LauncherStatus _status;
		HI3Server _gameserver;
		HI3Mirror _downloadmirror;
		Http httpclient;
		HttpProp httpprop;
		CancellationTokenSource token;
		DownloadPauseable download;
		DownloadProgressTracker tracker = new DownloadProgressTracker(50, TimeSpan.FromMilliseconds(500));

		internal LauncherStatus Status
		{
			get => _status;
			set => Dispatcher.Invoke(() =>
			{
				void ToggleUI(bool val)
				{
					LaunchButton.IsEnabled = val;
					OptionsButton.IsEnabled = val;
					ServerDropdown.IsEnabled = val;
					if(Server != HI3Server.GLB && Server != HI3Server.SEA && Server != HI3Server.CN)
					{
						MirrorDropdown.IsEnabled = false;
					}
					else
					{
						MirrorDropdown.IsEnabled = val;
					}
					ToggleContextMenuItems(val);
					DownloadProgressBarStackPanel.Visibility = Visibility.Collapsed;
					DownloadETAText.Visibility = Visibility.Visible;
					DownloadSpeedText.Visibility = Visibility.Visible;
					DownloadPauseButton.Visibility = Visibility.Visible;
					DownloadResumeButton.Visibility = Visibility.Collapsed;
				}
				void ToggleProgressBar(bool val)
				{
					ProgressBar.Visibility = val ? Visibility.Visible : Visibility.Collapsed;
					ProgressBar.IsIndeterminate = true;
					TaskbarItemInfo.ProgressState = val ? TaskbarItemProgressState.Indeterminate : TaskbarItemInfo.ProgressState = TaskbarItemProgressState.None;
				}

				_status = value;
				switch(_status)
				{
					case LauncherStatus.Ready:
						ProgressText.Text = string.Empty;
						ToggleUI(true);
						ToggleProgressBar(false);
						ProgressBar.IsIndeterminate = false;
						break;
					case LauncherStatus.Error:
						ProgressText.Text = App.TextStrings["progresstext_error"];
						ToggleUI(false);
						ToggleProgressBar(false);
						ProgressBar.IsIndeterminate = false;
						ToggleLog(true);
						TaskbarItemInfo.ProgressState = TaskbarItemProgressState.Error;
						break;
					case LauncherStatus.CheckingUpdates:
						ProgressText.Text = App.TextStrings["progresstext_checking_update"];
						ToggleUI(false);
						ToggleProgressBar(true);
						break;
					case LauncherStatus.Downloading:
						DownloadPaused = false;
						ProgressText.Text = App.TextStrings["progresstext_initiating_download"];
						LaunchButton.Content = App.TextStrings["button_downloading"];
						ToggleUI(false);
						OptionsButton.IsEnabled = true;
						ToggleProgressBar(true);
						ProgressBar.IsIndeterminate = false;
						TaskbarItemInfo.ProgressState = TaskbarItemProgressState.Normal;
						break;
					case LauncherStatus.DownloadPaused:
						DownloadPaused = true;
						ProgressText.Text = string.Empty;
						ToggleUI(true);
						ToggleProgressBar(false);
						ToggleContextMenuItems(false);
						ProgressBar.IsIndeterminate = false;
						break;
					case LauncherStatus.Preloading:
						PreloadBottomText.Text = App.TextStrings["button_downloading"];
						PreloadButton.Visibility = Visibility.Collapsed;
						PreloadPauseButton.IsEnabled = false;
						PreloadPauseButton.Visibility = Visibility.Visible;
						PreloadPauseButton.Background = (ImageBrush)Resources["PreloadPauseButton"];
						PreloadCircle.Visibility = Visibility.Visible;
						PreloadCircleProgressBar.Visibility = Visibility.Visible;
						TaskbarItemInfo.ProgressState = TaskbarItemProgressState.Normal;
						ToggleContextMenuItems(false);
						break;
					case LauncherStatus.PreloadVerifying:
						PreloadPauseButton.IsEnabled = false;
						PreloadCircleProgressBar.Value = 0;
						PreloadBottomText.Text = App.TextStrings["label_verifying"];
						PreloadStatusMiddleRightText.Text = string.Empty;
						PreloadStatusBottomRightText.Text = string.Empty;
						TaskbarItemInfo.ProgressState = TaskbarItemProgressState.Indeterminate;
						break;
					case LauncherStatus.Working:
						ToggleUI(false);
						ToggleProgressBar(true);
						break;
					case LauncherStatus.Running:
						ProgressText.Text = string.Empty;
						LaunchButton.Content = App.TextStrings["button_running"];
						ToggleUI(false);
						OptionsButton.IsEnabled = true;
						ToggleProgressBar(false);
						ToggleContextMenuItems(false);
						ProgressBar.IsIndeterminate = false;
						break;
					case LauncherStatus.Verifying:
						ProgressText.Text = App.TextStrings["progresstext_verifying_files"];
						ToggleUI(false);
						OptionsButton.IsEnabled = true;
						ToggleProgressBar(true);
						break;
					case LauncherStatus.Unpacking:
						ProgressText.Text = string.Empty;
						ToggleProgressBar(false);
						DownloadProgressBarStackPanel.Visibility = Visibility.Visible;
						DownloadProgressText.Text = App.TextStrings["progresstext_unpacking_1"];
						DownloadPauseButton.Visibility = Visibility.Collapsed;
						DownloadETAText.Visibility = Visibility.Collapsed;
						DownloadSpeedText.Visibility = Visibility.Collapsed;
						TaskbarItemInfo.ProgressState = TaskbarItemProgressState.Normal;
						break;
					case LauncherStatus.UpdateAvailable:
						ProgressText.Text = string.Empty;
						ToggleUI(true);
						ToggleProgressBar(false);
						ToggleContextMenuItems(false, true);
						ProgressBar.IsIndeterminate = false;
						break;
					case LauncherStatus.Uninstalling:
						ProgressText.Text = App.TextStrings["progresstext_uninstalling"];
						ToggleUI(false);
						OptionsButton.IsEnabled = true;
						ToggleProgressBar(true);
						break;
				}
			});
		}
		internal HI3Server Server
		{
			get => _gameserver;
			set
			{
				_gameserver = value;
				switch(_gameserver)
				{
					case HI3Server.GLB:
						RegistryVersionInfo = "VersionInfoGlobal";
						GameFullName = "Honkai Impact 3rd";
						GameInstallRegistryName = GameFullName;
						GameWebProfileURL = "https://account.hoyoverse.com";
						break;
					case HI3Server.SEA:
						RegistryVersionInfo = "VersionInfoSEA";
						GameFullName = "Honkai Impact 3";
						GameInstallRegistryName = GameFullName;
						GameWebProfileURL = "https://account.hoyoverse.com";
						break;
					case HI3Server.CN:
						RegistryVersionInfo = "VersionInfoCN";
						GameFullName = "崩坏3";
						GameInstallRegistryName = GameFullName;
						GameWebProfileURL = "https://user.mihoyo.com";
						break;
					case HI3Server.TW:
						RegistryVersionInfo = "VersionInfoTW";
						GameFullName = "崩壊3rd";
						GameInstallRegistryName = "崩壞3rd";
						GameWebProfileURL = "https://account.hoyoverse.com";
						break;
					case HI3Server.KR:
						RegistryVersionInfo = "VersionInfoKR";
						GameFullName = "붕괴3rd";
						GameInstallRegistryName = GameFullName;
						GameWebProfileURL = "https://account.hoyoverse.com";
						break;

				}
				GameRegistryPath = $@"SOFTWARE\miHoYo\{GameFullName}";
				GameCachePath = Path.Combine(miHoYoPath, GameFullName);
			}
		}
		internal HI3Mirror Mirror
		{
			get => _downloadmirror;
			set
			{
				_downloadmirror = value;
			}
		}

		public MainWindow()
		{
			InitializeComponent();
			var args = new List<string>();
			for(int i = 1; i < App.CommandLineArgs.Length; i++)
			{
				args.Add(App.CommandLineArgs[i].ToUpper());
			}
			if(args.Contains("NOLOG"))
			{
				App.DisableLogging = true;
			}
			if(!App.DisableLogging)
			{
				try
				{
					if(File.Exists(App.LauncherLogFile))
					{
						string old_log_path_1 = Path.Combine(App.LauncherDataPath, "BetterHI3Launcher-old1.log");
						for(int i = 9; i > 0; i--)
						{
							string old_log_path_2 = Path.Combine(App.LauncherDataPath, $"BetterHI3Launcher-old{i}.log");
							if(File.Exists(old_log_path_2))
							{
								string old_log_path_3 = Path.Combine(App.LauncherDataPath, $"BetterHI3Launcher-old{i + 1}.log");
								string old_log_path_4 = Path.Combine(App.LauncherDataPath, "BetterHI3Launcher-old10.log");
								if(File.Exists(old_log_path_4))
								{
									File.Delete(old_log_path_4);
								}
								File.Move(old_log_path_2, old_log_path_3);
							}
						}
						File.Move(App.LauncherLogFile, old_log_path_1);
					}
				}
				catch
				{
					Log("Unable to rename log files", true, 2);
				}
			}
			DeleteFile(App.LauncherLogFile, true);
			Log(App.UserAgent, false);
			Log($"Working directory: {App.LauncherRootPath}");
			Log($"OS version: {App.OSVersion}");
			Log($"OS language: {App.OSLanguage}");
			#if !DEBUG
			if(args.Contains("NOUPDATE"))
			{
				App.DisableAutoUpdate = true;
				App.UserAgent += " [NOUPDATE]";
				Log("Auto-update disabled");
			}
			#endif
			if(args.Contains("NOLOG"))
			{
				App.UserAgent += " [NOLOG]";
				Log("Logging to file disabled");
			}
			if(args.Contains("NOTRANSLATIONS"))
			{
				App.DisableTranslations = true;
				App.LauncherLanguage = "en";
				App.UserAgent += " [NOTRANSLATIONS]";
				Log("Translations disabled, only English will be available");
			}
			if(args.Contains("LEGACYDOWNLOAD"))
			{
				App.UseLegacyDownload = true;
				App.UserAgent += " [LEGACYDOWNLOAD]";
				Log("Using legacy download method");
			}
			if(args.Contains("ADVANCED"))
			{
				App.AdvancedFeatures = true;
				App.UserAgent += " [ADVANCED]";
				Log("Advanced features enabled");
			}
			else
			{
				RepairBoxGenerateButton.Visibility = Visibility.Collapsed;
			}
			string language_log_msg = "Launcher language: {0}";
			var language_reg = App.LauncherRegKey.GetValue("Language");
			if(!App.DisableTranslations)
			{
				if(language_reg != null)
				{
					if(App.LauncherRegKey.GetValueKind("Language") == RegistryValueKind.String)
					{
						SetLanguage(language_reg.ToString());
					}
				}
				else
				{
					SetLanguage(App.LauncherLanguage);
					language_log_msg += " (autodetect)";
				}
			}
			language_log_msg = string.Format(language_log_msg, App.LauncherLanguage);
			Log(language_log_msg);
			App.UserAgent += $" [{App.LauncherLanguage}] [{App.OSVersion}]";

			LaunchButton.Content = App.TextStrings["button_download"];
			OptionsButton.Content = App.TextStrings["button_options"];
			ServerLabel.Text = $"{App.TextStrings["label_server"]}:";
			MirrorLabel.Text = $"{App.TextStrings["label_mirror"]}:";
			IntroBoxTitleTextBlock.Text = App.TextStrings["introbox_title"];
			IntroBoxMessageTextBlock.Text = App.TextStrings["introbox_msg"];
			IntroBoxOKButton.Content = App.TextStrings["button_ok"];
			RepairBoxTitleTextBlock.Text = App.TextStrings["contextmenu_repair"];
			RepairBoxYesButton.Content = App.TextStrings["button_yes"];
			RepairBoxNoButton.Content = App.TextStrings["button_no"];
			RepairBoxGenerateButton.Content = App.TextStrings["button_generate"];
			FPSInputBoxTitleTextBlock.Text = App.TextStrings["fpsinputbox_title"];
			CombatFPSInputBoxTextBlock.Text = App.TextStrings["fpsinputbox_label_combatfps"];
			MenuFPSInputBoxTextBlock.Text = App.TextStrings["fpsinputbox_label_menufps"];
			FPSInputBoxOKButton.Content = App.TextStrings["button_confirm"];
			FPSInputBoxCancelButton.Content = App.TextStrings["button_cancel"];
			ResolutionInputBoxTitleTextBlock.Text = App.TextStrings["resolutioninputbox_title"];
			ResolutionInputBoxWidthTextBlock.Text = $"{App.TextStrings["resolutioninputbox_label_width"]}:";
			ResolutionInputBoxHeightTextBlock.Text = $"{App.TextStrings["resolutioninputbox_label_height"]}:";
			ResolutionInputBoxFullscreenTextBlock.Text = $"{App.TextStrings["resolutioninputbox_label_fullscreen"]}:";
			ResolutionInputBoxOKButton.Content = App.TextStrings["button_confirm"];
			ResolutionInputBoxCancelButton.Content = App.TextStrings["button_cancel"];
			ChangelogBoxTitleTextBlock.Text = App.TextStrings["changelogbox_title"];
			ChangelogBoxMessageTextBlock.Text = App.TextStrings["changelogbox_1_msg"];
			ChangelogBoxOKButton.Content = App.TextStrings["button_ok"];
			AboutBoxTitleTextBlock.Text = App.TextStrings["contextmenu_about"];
			AboutBoxAppNameTextBlock.Text += $" v{App.LocalLauncherVersion}";
			AboutBoxMessageTextBlock.Text = $"{App.TextStrings["aboutbox_msg"]}\n\nMade by Bp (BuIlDaLiBlE production).";
			AboutBoxGitHubButton.Content = App.TextStrings["button_github"];
			AboutBoxOKButton.Content = App.TextStrings["button_ok"];
			AnnouncementBoxOKButton.Content = App.TextStrings["button_ok"];
			AnnouncementBoxDoNotShowCheckbox.Content = App.TextStrings["announcementbox_do_not_show"];
			PreloadTopText.Text = App.TextStrings["label_pre_install"];
			PreloadStatusMiddleLeftText.Text = App.TextStrings["label_eta"];

			Grid.MouseLeftButtonDown += delegate{DragMove();};
			PreloadGrid.Visibility = Visibility.Collapsed;
			DownloadProgressBarStackPanel.Visibility = Visibility.Collapsed;
			LogBox.Visibility = Visibility.Collapsed;
			LogBoxRichTextBox.Document.PageWidth = LogBox.Width;
			IntroBox.Visibility = Visibility.Collapsed;
			RepairBox.Visibility = Visibility.Collapsed;
			FPSInputBox.Visibility = Visibility.Collapsed;
			ResolutionInputBox.Visibility = Visibility.Collapsed;
			ChangelogBox.Visibility = Visibility.Collapsed;
			AboutBox.Visibility = Visibility.Collapsed;
			AnnouncementBox.Visibility = Visibility.Collapsed;

			OptionsContextMenu.Items.Clear();
			var CM_Download_Cache = new MenuItem{Header = App.TextStrings["contextmenu_download_cache"], InputGestureText = "Ctrl+D"};
			CM_Download_Cache.Click += (sender, e) => CM_DownloadCache_Click(sender, e);
			OptionsContextMenu.Items.Add(CM_Download_Cache);
			var CM_Repair = new MenuItem{Header = App.TextStrings["contextmenu_repair"], InputGestureText = "Ctrl+R"};
			CM_Repair.Click += async (sender, e) => await CM_Repair_Click(sender, e);
			OptionsContextMenu.Items.Add(CM_Repair);
			var CM_Move = new MenuItem{Header = App.TextStrings["contextmenu_move"], InputGestureText = "Ctrl+M"};
			CM_Move.Click += async (sender, e) => await CM_Move_Click(sender, e);
			OptionsContextMenu.Items.Add(CM_Move);
			var CM_Uninstall = new MenuItem{Header = App.TextStrings["contextmenu_uninstall"], InputGestureText = "Ctrl+U"};
			CM_Uninstall.Click += async (sender, e) => await CM_Uninstall_Click(sender, e);
			OptionsContextMenu.Items.Add(CM_Uninstall);
			var CM_Game_Settings = new MenuItem{Header = App.TextStrings["contextmenu_game_settings"]};
			var CM_Custom_FPS = new MenuItem{Header = App.TextStrings["contextmenu_custom_fps"]};
			CM_Custom_FPS.Click += (sender, e) => CM_CustomFPS_Click(sender, e);
			CM_Game_Settings.Items.Add(CM_Custom_FPS);
			var CM_Custom_Resolution = new MenuItem{Header = App.TextStrings["contextmenu_custom_resolution"]};
			CM_Custom_Resolution.Click += (sender, e) => CM_CustomResolution_Click(sender, e);
			CM_Game_Settings.Items.Add(CM_Custom_Resolution);
			var CM_Custom_Launch_Options = new MenuItem{Header = App.TextStrings["contextmenu_custom_launch_options"]};
			CM_Custom_Launch_Options.Click += (sender, e) => CM_CustomLaunchOptions_Click(sender, e);
			CM_Game_Settings.Items.Add(CM_Custom_Launch_Options);
			var CM_Download_Type = new MenuItem{Header = App.TextStrings["contextmenu_reset_download_type"]};
			CM_Download_Type.Click += (sender, e) => CM_ResetDownloadType_Click(sender, e);
			CM_Game_Settings.Items.Add(CM_Download_Type);
			OptionsContextMenu.Items.Add(CM_Game_Settings);
			OptionsContextMenu.Items.Add(new Separator());
			var CM_Web_Profile = new MenuItem{Header = App.TextStrings["contextmenu_web_profile"], InputGestureText = "Ctrl+P"};
			CM_Web_Profile.Click += (sender, e) => BpUtility.StartProcess(GameWebProfileURL, null, App.LauncherRootPath, true);
			OptionsContextMenu.Items.Add(CM_Web_Profile);
			var CM_Feedback = new MenuItem{Header = App.TextStrings["contextmenu_feedback"], InputGestureText = "Ctrl+F"};
			CM_Feedback.Click += (sender, e) => BpUtility.StartProcess("https://github.com/BuIlDaLiBlE/BetterHI3Launcher/issues/new/choose", null, App.LauncherRootPath, true);
			OptionsContextMenu.Items.Add(CM_Feedback);
			var CM_Changelog = new MenuItem{Header = App.TextStrings["contextmenu_changelog"], InputGestureText = "Ctrl+C"};
			CM_Changelog.Click += (sender, e) => CM_Changelog_Click(sender, e);
			OptionsContextMenu.Items.Add(CM_Changelog);
			var CM_Custom_Background = new MenuItem{Header = App.TextStrings["contextmenu_custom_background"], InputGestureText = "Ctrl+B"};
			CM_Custom_Background.Click += (sender, e) => CM_CustomBackground_Click(sender, e);
			OptionsContextMenu.Items.Add(CM_Custom_Background);
			var CM_ShowLog = new MenuItem{Header = App.TextStrings["contextmenu_show_log"], InputGestureText = "Ctrl+L"};
			CM_ShowLog.Click += (sender, e) => CM_ShowLog_Click(sender, e);
			OptionsContextMenu.Items.Add(CM_ShowLog);
			var CM_Sounds = new MenuItem{Header = App.TextStrings["contextmenu_sounds"], InputGestureText = "Ctrl+S", IsChecked = true};
			CM_Sounds.Click += (sender, e) => CM_Sounds_Click(sender, e);
			OptionsContextMenu.Items.Add(CM_Sounds);
			var CM_Language = new MenuItem{Header = App.TextStrings["contextmenu_language"]};
			var CM_Language_System = new MenuItem{Header = App.TextStrings["contextmenu_language_system"]};
			CM_Language_System.Click += (sender, e) => CM_Language_Click(sender, e);
			CM_Language.Items.Add(CM_Language_System);
			var CM_Language_Chinese_Simplified = new MenuItem {Header = App.TextStrings["contextmenu_language_chinese_simplified"]};
			CM_Language_Chinese_Simplified.Click += (sender, e) => CM_Language_Click(sender, e);
			CM_Language.Items.Add(CM_Language_Chinese_Simplified);
			var CM_Language_Czech = new MenuItem {Header = App.TextStrings["contextmenu_language_czech"]};
			CM_Language_Czech.Click += (sender, e) => CM_Language_Click(sender, e);
			CM_Language.Items.Add(CM_Language_Czech);
			var CM_Language_English = new MenuItem{Header = App.TextStrings["contextmenu_language_english"]};
			CM_Language_English.Click += (sender, e) => CM_Language_Click(sender, e);
			CM_Language.Items.Add(CM_Language_English);
			var CM_Language_French = new MenuItem{Header = App.TextStrings["contextmenu_language_french"]};
			CM_Language_French.Click += (sender, e) => CM_Language_Click(sender, e);
			CM_Language.Items.Add(CM_Language_French);
			var CM_Language_German = new MenuItem{Header = App.TextStrings["contextmenu_language_german"]};
			CM_Language_German.Click += (sender, e) => CM_Language_Click(sender, e);
			CM_Language.Items.Add(CM_Language_German);
			var CM_Language_Indonesian = new MenuItem{Header = App.TextStrings["contextmenu_language_indonesian"]};
			CM_Language_Indonesian.Click += (sender, e) => CM_Language_Click(sender, e);
			CM_Language.Items.Add(CM_Language_Indonesian);
			var CM_Language_Italian = new MenuItem {Header = App.TextStrings["contextmenu_language_italian"]};
			CM_Language_Italian.Click += (sender, e) => CM_Language_Click(sender, e);
			CM_Language.Items.Add(CM_Language_Italian);
			var CM_Language_Portuguese_Brazil = new MenuItem{Header = App.TextStrings["contextmenu_language_portuguese_brazil"]};
			CM_Language_Portuguese_Brazil.Click += (sender, e) => CM_Language_Click(sender, e);
			CM_Language.Items.Add(CM_Language_Portuguese_Brazil);
			var CM_Language_Portuguese_Portugal = new MenuItem{Header = App.TextStrings["contextmenu_language_portuguese_portugal"]};
			CM_Language_Portuguese_Portugal.Click += (sender, e) => CM_Language_Click(sender, e);
			CM_Language.Items.Add(CM_Language_Portuguese_Portugal);
			var CM_Language_Russian = new MenuItem{Header = App.TextStrings["contextmenu_language_russian"]};
			CM_Language_Russian.Click += (sender, e) => CM_Language_Click(sender, e);
			CM_Language.Items.Add(CM_Language_Russian);
			var CM_Language_Serbian = new MenuItem{Header = App.TextStrings["contextmenu_language_serbian"]};
			CM_Language_Serbian.Click += (sender, e) => CM_Language_Click(sender, e);
			CM_Language.Items.Add(CM_Language_Serbian);
			var CM_Language_Spanish = new MenuItem{Header = App.TextStrings["contextmenu_language_spanish"]};
			CM_Language_Spanish.Click += (sender, e) => CM_Language_Click(sender, e);
			CM_Language.Items.Add(CM_Language_Spanish);
			var CM_Language_Thai = new MenuItem{Header = App.TextStrings["contextmenu_language_thai"]};
			CM_Language_Thai.Click += (sender, e) => CM_Language_Click(sender, e);
			CM_Language.Items.Add(CM_Language_Thai);
			var CM_Language_Vietnamese = new MenuItem{Header = App.TextStrings["contextmenu_language_vietnamese"]};
			CM_Language_Vietnamese.Click += (sender, e) => CM_Language_Click(sender, e);
			CM_Language.Items.Add(CM_Language_Vietnamese);
			CM_Language.Items.Add(new Separator());
			var CM_Language_Contribute = new MenuItem{Header = App.TextStrings["contextmenu_language_contribute"]};
			CM_Language_Contribute.Click += (sender, e) => BpUtility.StartProcess("https://github.com/BuIlDaLiBlE/BetterHI3Launcher#how-can-i-contribute", null, App.LauncherRootPath, true);
			CM_Language.Items.Add(CM_Language_Contribute);
			OptionsContextMenu.Items.Add(CM_Language);
			var CM_About = new MenuItem{Header = App.TextStrings["contextmenu_about"], InputGestureText = "Ctrl+A"};
			CM_About.Click += (sender, e) => CM_About_Click(sender, e);
			OptionsContextMenu.Items.Add(CM_About);

			if(!App.DisableTranslations)
			{
				if(language_reg == null)
				{
					CM_Language_System.IsChecked = true;
				}
				else
				{
					switch(language_reg.ToString())
					{
						case "cs":
							CM_Language_Czech.IsChecked = true;
							break;
						case "fr":
							CM_Language_French.IsChecked = true;
							break;
						case "de":
							CM_Language_German.IsChecked = true;
							break;
						case "id":
							CM_Language_Indonesian.IsChecked = true;
							break;
						case "it":
							CM_Language_Italian.IsChecked = true;
							break;
						case "pt-BR":
							CM_Language_Portuguese_Brazil.IsChecked = true;
							break;
						case "pt-PT":
							CM_Language_Portuguese_Portugal.IsChecked = true;
							break;
						case "ru":
							CM_Language_Russian.IsChecked = true;
							break;
						case "sr":
							CM_Language_Serbian.IsChecked = true;
							break;
						case "es":
							CM_Language_Spanish.IsChecked = true;
							break;
						case "th":
							CM_Language_Thai.IsChecked = true;
							break;
						case "vi":
							CM_Language_Vietnamese.IsChecked = true;
							break;
						case "zh-CN":
							CM_Language_Chinese_Simplified.IsChecked = true;
							break;
						default:
							CM_Language_English.IsChecked = true;
							break;
					}
				}
			}
			else
			{
				CM_Language_English.IsChecked = true;
				foreach(dynamic item in CM_Language.Items)
				{
					if(item.GetType() == typeof(MenuItem))
					{
						if(item.Header.ToString() == App.TextStrings["contextmenu_language_contribute"])
						{
							continue;
						}
					}
					item.IsEnabled = false;
				}
			}

			var key = Registry.LocalMachine.OpenSubKey(@"SOFTWARE\Microsoft\NET Framework Setup\NDP\v4\Full");
			if(key == null || (int)key.GetValue("Release") < 394254)
			{
				MessageBox.Show(App.TextStrings["msgbox_net_version_old_msg"], App.TextStrings["msgbox_start_error_title"], MessageBoxButton.OK, MessageBoxImage.Error);
				Application.Current.Shutdown();
				return;
			}

			Server = HI3Server.GLB;
			try
			{
				var last_selected_server_reg = App.LauncherRegKey.GetValue("LastSelectedServer");
				if(last_selected_server_reg != null)
				{
					if(App.LauncherRegKey.GetValueKind("LastSelectedServer") == RegistryValueKind.DWord)
					{
						switch((int)last_selected_server_reg)
						{
							case 0:
								Server = HI3Server.GLB;
								break;
							case 1:
								Server = HI3Server.SEA;
								break;
							case 2:
								Server = HI3Server.CN;
								break;
							case 3:
								Server = HI3Server.TW;
								break;
							case 4:
								Server = HI3Server.KR;
								break;
						}
					}
				}
				ServerDropdown.SelectedIndex = (int)Server;

				try
				{
					FetchOnlineVersionInfo();
				}
				catch(Exception ex)
				{
					if(Status == LauncherStatus.Error)
					{
						return;
					}
					Status = LauncherStatus.Error;
					MessageBox.Show($"{App.TextStrings["msgbox_conn_bp_error_msg"]}\n{ex.Message}", App.TextStrings["msgbox_net_error_title"], MessageBoxButton.OK, MessageBoxImage.Error);
					Application.Current.Shutdown();
					return;
				}
				try
				{
					FetchmiHoYoVersionInfo();
				}
				catch(Exception ex)
				{
					if(Status == LauncherStatus.Error)
					{
						return;
					}
					Status = LauncherStatus.Error;
					MessageBox.Show($"{App.TextStrings["msgbox_conn_mihoyo_error_msg"]}\n{ex.Message}", App.TextStrings["msgbox_net_error_title"], MessageBoxButton.OK, MessageBoxImage.Error);
					Application.Current.Shutdown();
					return;
				}

				Mirror = HI3Mirror.miHoYo;
				var last_selected_mirror_reg = App.LauncherRegKey.GetValue("LastSelectedMirror");
				if(last_selected_mirror_reg != null)
				{
					if(App.LauncherRegKey.GetValueKind("LastSelectedMirror") == RegistryValueKind.DWord)
					{
						if((int)last_selected_mirror_reg == 0)
						{
							Mirror = HI3Mirror.miHoYo;
						}
						else if((int)last_selected_mirror_reg == 1)
						{
							Mirror = HI3Mirror.Hi3Mirror;
						}
					}
				}
				if(Server != HI3Server.GLB && Server != HI3Server.SEA)
				{
					Mirror = HI3Mirror.miHoYo;
				}
				MirrorDropdown.SelectedIndex = (int)Mirror;

				var seen_announcements_reg = App.LauncherRegKey.GetValue("SeenAnnouncements");
				if(seen_announcements_reg != null)
				{
					if(App.LauncherRegKey.GetValueKind("SeenAnnouncements") == RegistryValueKind.String)
					{
						App.SeenAnnouncements = seen_announcements_reg.ToString().Split(',').ToList();
					}
				}

				var show_log_reg = App.LauncherRegKey.GetValue("ShowLog");
				if(show_log_reg != null)
				{
					if(App.LauncherRegKey.GetValueKind("ShowLog") == RegistryValueKind.DWord)
					{
						if((int)show_log_reg == 1)
						{
							ToggleLog(true);
							CM_ShowLog.IsChecked = true;
						}
					}
				}

				var sounds_reg = App.LauncherRegKey.GetValue("Sounds");
				if(sounds_reg != null)
				{
					if(App.LauncherRegKey.GetValueKind("Sounds") == RegistryValueKind.DWord)
					{
						if((int)sounds_reg == 0)
						{
							App.DisableSounds = true;
							CM_Sounds.IsChecked = false;
						}
					}
				}

				DownloadCacheCommand.InputGestures.Add(new KeyGesture(Key.D, ModifierKeys.Control));
				RepairGameCommand.InputGestures.Add(new KeyGesture(Key.R, ModifierKeys.Control));
				MoveGameCommand.InputGestures.Add(new KeyGesture(Key.M, ModifierKeys.Control));
				UninstallGameCommand.InputGestures.Add(new KeyGesture(Key.U, ModifierKeys.Control));
				WebProfileCommand.InputGestures.Add(new KeyGesture(Key.P, ModifierKeys.Control));
				FeedbackCommand.InputGestures.Add(new KeyGesture(Key.F, ModifierKeys.Control));
				ChangelogCommand.InputGestures.Add(new KeyGesture(Key.C, ModifierKeys.Control));
				CustomBackgroundCommand.InputGestures.Add(new KeyGesture(Key.B, ModifierKeys.Control));
				ToggleLogCommand.InputGestures.Add(new KeyGesture(Key.L, ModifierKeys.Control));
				ToggleSoundsCommand.InputGestures.Add(new KeyGesture(Key.S, ModifierKeys.Control));
				AboutCommand.InputGestures.Add(new KeyGesture(Key.A, ModifierKeys.Control));

				App.NeedsUpdate = LauncherUpdateCheck();
				if(!App.DisableTranslations)
				{
					if(!App.DisableAutoUpdate && !App.NeedsUpdate)
					{
						DownloadLauncherTranslations();
					}
				}

				Log($"Using server: {((ComboBoxItem)ServerDropdown.SelectedItem).Content as string}");
				Log($"Using mirror: {((ComboBoxItem)MirrorDropdown.SelectedItem).Content as string}");

				DownloadBackgroundImage();
			}
			catch(Exception ex)
			{
				Status = LauncherStatus.Error;
				MessageBox.Show(string.Format(App.TextStrings["msgbox_start_error_msg"], ex), App.TextStrings["msgbox_start_error_title"], MessageBoxButton.OK, MessageBoxImage.Error);
				Application.Current.Shutdown();
				return;
			}
		}

		private void FetchOnlineVersionInfo()
		{
			#if DEBUG
			var version_info_url = "https://bpnet.work/bh3?launcher_status=debug";
			#else
			var version_info_url = "https://bpnet.work/bh3?launcher_status=prod";
			#endif
			string version_info = null;
			void Get(int timeout)
			{
				var web_client = new BpWebClient{Timeout = timeout};
				version_info = web_client.DownloadString(version_info_url);
			}
			int attempts = 6;
			int timeout_add = 2500;
			for(int i = 0; i < attempts; i++)
			{
				if(i == attempts - 1)
				{
					Get(timeout_add);
				}
				else
				{
					try
					{
						Get(timeout_add);
						break;
					}
					catch
					{
						Log($"Bp Network connection error, attempt №{i + 2}...", true, 2);
						timeout_add += 2500;
						#if !DEBUG
						if(i == 3)
						{
							// fallback server with basic information needed to start the launcher
							version_info_url = "https://serioussam.ucoz.ru/bbh3l_prod.json";
						}
						#endif
					}
				}
			}
			OnlineVersionInfo = JsonConvert.DeserializeObject<dynamic>(version_info);
			if(OnlineVersionInfo.status == "success")
			{
				OnlineVersionInfo = OnlineVersionInfo.launcher_status;
				App.LauncherExeName = OnlineVersionInfo.launcher_info.name;
				App.LauncherPath = Path.Combine(App.LauncherRootPath, App.LauncherExeName);
				App.LauncherArchivePath = Path.Combine(App.LauncherRootPath, OnlineVersionInfo.launcher_info.url.ToString().Substring(OnlineVersionInfo.launcher_info.url.ToString().LastIndexOf('/') + 1));
			}
			else
			{
				Status = LauncherStatus.Error;
				Dispatcher.Invoke(() =>
				{
					MessageBox.Show(string.Format(App.TextStrings["msgbox_net_error_msg"], OnlineVersionInfo.status_message), App.TextStrings["msgbox_net_error_title"], MessageBoxButton.OK, MessageBoxImage.Error);
					Application.Current.Shutdown();
				});
			}
		}
		
		private async void FetchAnnouncements()
		{
			Status = LauncherStatus.Working;
			ProgressBar.Visibility = Visibility.Collapsed;
			try
			{
				await Task.Run(() =>
				{
					var web_client = new BpWebClient();
					dynamic announcements;
					announcements = JsonConvert.DeserializeObject<dynamic>(web_client.DownloadString($"{OnlineVersionInfo.launcher_info.announcements_url.ToString()}&lang={App.LauncherLanguage}"));
					if(announcements.status == "success")
					{
						announcements = announcements.announcements;
						foreach(dynamic announcement in announcements)
						{
							string min_launcher_version = announcement.min_version.ToString();
							if(!new App.LauncherVersion(min_launcher_version).IsNewerThan(App.LocalLauncherVersion) && DateTime.Compare(DateTime.UtcNow, new DateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc).AddSeconds((double)announcement.relevant_until)) < 0 && !App.SeenAnnouncements.Contains(announcement.id.ToString()))
							{
								App.Announcements.Add(announcement);
							}
						}
					}
					else
					{
						Log($"Failed to fetch announcements: {announcements.status_message}", true, 2);
					}
				});
			}
			catch(Exception ex)
			{
				Log($"Failed to fetch announcements:\n{ex}", true, 2);
			}
			if(App.Announcements.Count > 0)
			{
				Dispatcher.Invoke(() => {ShowAnnouncement(App.Announcements.First);});
			}
			else
			{
				LauncherLocalVersionCheck();
			}
		}

		private void ShowAnnouncement(dynamic announcement)
		{
			LegacyBoxActive = true;
			AnnouncementBoxTitleTextBlock.Text = announcement.content.title;
			AnnouncementBoxMessageTextBlock.Text = announcement.content.text;
			AnnouncementBox.Visibility = Visibility.Visible;
		}

		private async void FetchChangelog()
		{
			if(ChangelogBoxTextBox.Text != string.Empty)
			{
				return;
			}

			string changelog = null;
			Dispatcher.Invoke(() => {ChangelogBoxTextBox.Text = App.TextStrings["changelogbox_2_msg"];});
			await Task.Run(() =>
			{
				void Get(int timeout)
				{
					var web_client = new BpWebClient{Timeout = timeout};
					if(App.LauncherLanguage == "ru")
					{
						changelog = web_client.DownloadString(OnlineVersionInfo.launcher_info.changelog_url.ru.ToString());
					}
					else
					{
						changelog = web_client.DownloadString(OnlineVersionInfo.launcher_info.changelog_url.en.ToString());
					}
				}
				try
				{
					int attempts = 6;
					int timeout_add = 2500;
					for(int i = 0; i < attempts; i++)
					{
						if(i == attempts - 1)
						{
							Get(timeout_add);
						}
						else
						{
							try
							{
								Get(timeout_add);
								break;
							}
							catch
							{
								Log($"Bp Network connection error, attempt №{i + 2}...", true, 2);
								timeout_add += 2500;
							}
						}
					}
				}
				catch
				{
					Log($"Bp Network connection error, giving up...", true, 2);
					changelog = App.TextStrings["changelogbox_3_msg"];
				}
				Dispatcher.Invoke(() => {ChangelogBoxTextBox.Text = changelog;});
			});
		}

		private void FetchmiHoYoVersionInfo()
		{
			string url = null;
			switch(Server)
			{
				case HI3Server.GLB:
					url = OnlineVersionInfo.game_info.mirror.mihoyo.resource_info.global.ToString();
					break;
				case HI3Server.SEA:
					url = OnlineVersionInfo.game_info.mirror.mihoyo.resource_info.os.ToString();
					break;
				case HI3Server.CN:
					url = OnlineVersionInfo.game_info.mirror.mihoyo.resource_info.cn.ToString();
					break;
				case HI3Server.TW:
					url = OnlineVersionInfo.game_info.mirror.mihoyo.resource_info.tw.ToString();
					break;
				case HI3Server.KR:
					url = OnlineVersionInfo.game_info.mirror.mihoyo.resource_info.kr.ToString();
					break;
			}
			void Get(int timeout)
			{
				var web_request = BpUtility.CreateWebRequest(url, "GET", timeout);
				using(var web_response = (HttpWebResponse)web_request.GetResponse())
				{
					using(var data = new MemoryStream())
					{
						web_response.GetResponseStream().CopyTo(data);
						miHoYoVersionInfo = JsonConvert.DeserializeObject<dynamic>(Encoding.UTF8.GetString(data.ToArray()));
						if(miHoYoVersionInfo.retcode == 0)
						{
							if(miHoYoVersionInfo.data != null)
							{
								miHoYoVersionInfo = miHoYoVersionInfo.data;
							}
							else
							{
								throw new WebException();
							}
						}
						else
						{
							throw new WebException(miHoYoVersionInfo.message.ToString());
						}
					}
				}
				GameExeName = miHoYoVersionInfo.game.latest.entry.ToString();
				GameArchiveName = Path.GetFileName(HttpUtility.UrlDecode(miHoYoVersionInfo.game.latest.path.ToString()));
				web_request = BpUtility.CreateWebRequest(miHoYoVersionInfo.game.latest.path.ToString(), "HEAD", timeout);
				using(var web_response = (HttpWebResponse)web_request.GetResponse())
				{
					miHoYoVersionInfo.size = web_response.ContentLength;
					miHoYoVersionInfo.last_modified = web_response.LastModified.ToUniversalTime().ToString();
				}
			}
			int attempts = 6;
			int timeout_add = 2500;
			for(int i = 0; i < attempts; i++)
			{
				if(i == attempts - 1)
				{
					Get(timeout_add);
				}
				else
				{
					try
					{
						Get(timeout_add);
						break;
					}
					catch
					{
						Log($"HoYoverse connection error, attempt №{i + 2}...", true, 2);
						timeout_add += 2500;
					}
				}
			}
			Dispatcher.Invoke(() =>
			{
				GameVersionText.Text = $"{App.TextStrings["version"]}: {miHoYoVersionInfo.game.latest.version.ToString()}";
			});
		}

		private DateTime FetchmiHoYoResourceVersionDateModified()
		{
			var url = new string[3];
			var time = new DateTime[3];
			switch(Server)
			{
				case HI3Server.GLB:
					url[0] = OnlineVersionInfo.game_info.mirror.mihoyo.resource_version.global[0].ToString();
					url[1] = OnlineVersionInfo.game_info.mirror.mihoyo.resource_version.global[1].ToString();
					url[2] = OnlineVersionInfo.game_info.mirror.mihoyo.resource_version.global[2].ToString();
					break;
				case HI3Server.SEA:
					url[0] = OnlineVersionInfo.game_info.mirror.mihoyo.resource_version.os[0].ToString();
					url[1] = OnlineVersionInfo.game_info.mirror.mihoyo.resource_version.os[1].ToString();
					url[2] = OnlineVersionInfo.game_info.mirror.mihoyo.resource_version.os[2].ToString();
					break;
			}
			try
			{
				for(int i = 0; i < url.Length; i++)
				{
					var web_request = BpUtility.CreateWebRequest(url[i], "HEAD");
					using(var web_response = (HttpWebResponse)web_request.GetResponse())
					{
						time[i] = web_response.LastModified.ToUniversalTime();
					}
				}
				Array.Sort(time);
				return time[time.Length - 1];
			}
			catch
			{
				return new DateTime();
			}
		}

		private dynamic FetchMediaFireFileMetadata(string id)
		{
			if(string.IsNullOrEmpty(id))
			{
				throw new ArgumentNullException();
			}

			string url = $"https://www.mediafire.com/file/{id}";
			try
			{
				var web_request = BpUtility.CreateWebRequest(url, "HEAD");
				using(var web_response = (HttpWebResponse)web_request.GetResponse())
				{
					dynamic metadata = new ExpandoObject();
					metadata.title = web_response.Headers["Content-Disposition"].Replace("attachment; filename=", string.Empty).Replace("\"", string.Empty);
					metadata.downloadUrl = url;
					metadata.fileSize = web_response.ContentLength;
					return metadata;
				}
			}
			catch(WebException ex)
			{
				Status = LauncherStatus.Error;
				Log($"Failed to fetch MediaFire file metadata:\n{ex}", true, 1);
				Dispatcher.Invoke(() => {new DialogWindow(App.TextStrings["msgbox_net_error_title"], string.Format(App.TextStrings["msgbox_mirror_error_msg"], ex.Message)).ShowDialog();});
			}
			return null;
		}

		private bool LauncherUpdateCheck()
		{
			var OnlineLauncherVersion = new App.LauncherVersion(OnlineVersionInfo.launcher_info.version.ToString());
			if(OnlineLauncherVersion.IsNewerThan(App.LocalLauncherVersion))
			{
				return true;
			}
			else
			{
				return false;
			}
		}

		private void LauncherLocalVersionCheck()
		{
			#if !DEBUG
			if(App.LauncherRegKey != null && App.LauncherRegKey.GetValue("LauncherVersion") != null)
			{
				if(new App.LauncherVersion(App.LocalLauncherVersion.ToString()).IsNewerThan(new App.LauncherVersion(App.LauncherRegKey.GetValue("LauncherVersion").ToString())))
				{
					LegacyBoxActive = true;
					ChangelogBox.Visibility = Visibility.Visible;
					ChangelogBoxMessageTextBlock.Visibility = Visibility.Visible;
					FetchChangelog();
				}
			}
			#endif
			try
			{
				if(App.LauncherRegKey.GetValue("LauncherVersion") == null || App.LauncherRegKey.GetValue("LauncherVersion") != null && App.LauncherRegKey.GetValue("LauncherVersion").ToString() != App.LocalLauncherVersion.ToString())
				{
					BpUtility.WriteToRegistry("LauncherVersion", App.LocalLauncherVersion.ToString());
				}
				// legacy values
				BpUtility.DeleteFromRegistry("RanOnce");
				BpUtility.DeleteFromRegistry("BackgroundImageName");
			}
			catch(Exception ex)
			{
				Status = LauncherStatus.Error;
				Log($"Failed to write critical registry info:\n{ex}", true, 1);
				new DialogWindow(App.TextStrings["msgbox_registry_error_title"], App.TextStrings["msgbox_registry_error_msg"]).ShowDialog();
				return;
			}
			GameUpdateCheck();
		}

		private async void GameUpdateCheck(bool server_changed = false)
		{
			if(Status == LauncherStatus.Error)
			{
				return;
			}
			Log("Checking for game update...");
			Status = LauncherStatus.CheckingUpdates;
			LocalVersionInfo = null;
			await Task.Run(() =>
			{
				try
				{
					int game_needs_update;

					Dispatcher.Invoke(() => {PreloadGrid.Visibility = Visibility.Collapsed;});
					if(!App.Starting)
					{
						FetchOnlineVersionInfo();
					}
					App.Starting = false;

					if(App.LauncherRegKey.GetValue(RegistryVersionInfo) != null)
					{
						LocalVersionInfo = JsonConvert.DeserializeObject<dynamic>(Encoding.UTF8.GetString((byte[])App.LauncherRegKey.GetValue(RegistryVersionInfo)));
						GameInstallPath = LocalVersionInfo.game_info.install_path.ToString();
						var game_config_ini_file = Path.Combine(GameInstallPath, "config.ini");
						if(File.Exists(game_config_ini_file))
						{
							var data = new FileIniDataParser().ReadFile(game_config_ini_file);
							if(data["General"]["game_version"] != null)
							{
								if(data["General"]["game_version"] == miHoYoVersionInfo.game.latest.version.ToString())
								{
									LocalVersionInfo.game_info.installed = true;
								}
								LocalVersionInfo.game_info.version = data["General"]["game_version"];
							}
						}
						var local_game_version = new GameVersion(LocalVersionInfo.game_info.version.ToString());
						game_needs_update = GameVersionUpdateCheck(local_game_version);
						GameArchivePath = Path.Combine(GameInstallPath, GameArchiveName);
						GameExePath = Path.Combine(GameInstallPath, GameExeName);

						Log($"Game version: {local_game_version}");
						Log($"Game directory: {GameInstallPath}");
						if(new DirectoryInfo(GameInstallPath).Parent == null)
						{
							Log("Game directory is unsafe, resetting version info...", true, 2);
							ResetVersionInfo();
							GameUpdateCheck();
							return;
						}
						else if(game_needs_update != 0)
						{
							PatchDownload = false;
							if(game_needs_update == 2 && Mirror == HI3Mirror.miHoYo)
							{
								var url = miHoYoVersionInfo.game.diffs[PatchDownloadInt].path.ToString();
								GameArchiveName = Path.GetFileName(HttpUtility.UrlDecode(url));
								GameArchivePath = Path.Combine(GameInstallPath, GameArchiveName);
								PatchDownload = true;
							}
							Log("The game requires an update!");
							Status = LauncherStatus.UpdateAvailable;
						}
						else if(LocalVersionInfo.game_info.installed == false)
						{
							DownloadPaused = true;
							Status = LauncherStatus.UpdateAvailable;
						}
						else
						{
							var process = Process.GetProcessesByName("BH3");
							if(process.Length > 0)
							{
								process[0].EnableRaisingEvents = true;
								process[0].Exited += new EventHandler((object s, EventArgs ea) => {OnGameExit();});
								if(PreloadDownload)
								{
									Dispatcher.Invoke(() =>
									{
										LaunchButton.Content = App.TextStrings["button_running"];
										LaunchButton.IsEnabled = false;
									});
								}
								else
								{
									Status = LauncherStatus.Running;
								}
							}
							else
							{
								Status = LauncherStatus.Ready;
								Dispatcher.Invoke(() => {LaunchButton.Content = App.TextStrings["button_launch"];});
							}
						}
						if(Status == LauncherStatus.UpdateAvailable)
						{
							if(File.Exists(GameArchiveTempPath))
							{
								DownloadPaused = true;
								Dispatcher.Invoke(() =>
								{
									LaunchButton.Content = App.TextStrings["button_resume"];
								});
							}
							else
							{
								Dispatcher.Invoke(() =>
								{
									LaunchButton.Content = App.TextStrings["button_update"];
								});
							}
						}
						else
						{
							Dispatcher.Invoke(() =>
							{
								if(miHoYoVersionInfo.pre_download_game != null)
								{
									var path = Path.Combine(GameInstallPath, Path.GetFileName(HttpUtility.UrlDecode(miHoYoVersionInfo.pre_download_game.latest.path.ToString())));
									if(File.Exists(path))
									{
										PreloadButton.Visibility = Visibility.Collapsed;
										PreloadCheckmark.Visibility = Visibility.Visible;
										PreloadCircle.Visibility = Visibility.Visible;
										PreloadCircleProgressBar.Visibility = Visibility.Visible;
										PreloadCircleProgressBar.Value = 100;
										PreloadBottomText.Text = App.TextStrings["label_done"];
									}
									else
									{
										PreloadButton.Visibility = Visibility.Visible;
										PreloadCheckmark.Visibility = Visibility.Collapsed;
										PreloadCircle.Visibility = Visibility.Collapsed;
										PreloadCircleProgressBar.Visibility = Visibility.Collapsed;
										PreloadCircleProgressBar.Value = 0;
										PreloadBottomText.Text = App.TextStrings["label_get_now"];
									}
									PreloadPauseButton.Visibility = Visibility.Collapsed;
									PreloadGrid.Visibility = Visibility.Visible;
								}
								else
								{
									PreloadGrid.Visibility = Visibility.Collapsed;
								}
							});
						}	
					}
					else
					{
						Log("Ready to install the game");
						if(server_changed)
						{
							FetchmiHoYoVersionInfo();
						}
						DownloadPaused = false;
						Status = LauncherStatus.Ready;
						Dispatcher.Invoke(() =>
						{
							LaunchButton.Content = App.TextStrings["button_download"];
							ToggleContextMenuItems(false);
						});
					}
					if(server_changed)
					{
						DownloadBackgroundImage();
					}
				}
				catch(Exception ex)
				{
					Status = LauncherStatus.Error;
					Log($"Checking for game update failed:\n{ex}", true, 1);
					Dispatcher.Invoke(() =>
					{
						if(new DialogWindow(App.TextStrings["msgbox_update_check_error_title"], App.TextStrings["msgbox_update_check_error_msg"], DialogWindow.DialogType.Question).ShowDialog() == false)
						{
							Status = LauncherStatus.CheckingUpdates;
							ProgressText.Visibility = Visibility.Collapsed;
							ProgressBar.Visibility = Visibility.Collapsed;
							ServerDropdown.IsEnabled = true;
						}
						else
						{
							Status = LauncherStatus.Ready;
							GameUpdateCheck();
						}
					});
				}
			});
		}

		private int GameVersionUpdateCheck(GameVersion local_game_version)
		{
			if(LocalVersionInfo != null)
			{
				FetchmiHoYoVersionInfo();
				var online_game_version = new GameVersion(miHoYoVersionInfo.game.latest.version.ToString());
				if(online_game_version.IsNewerThan(local_game_version))
				{
					for(var i = 0; i < miHoYoVersionInfo.game.diffs.Count; i++)
					{
						if(miHoYoVersionInfo.game.diffs[i].version == local_game_version.ToString())
						{
							PatchDownloadInt = i;
							return 2;
						}
					}
					return 1;
				}
				else
				{
					return 0;
				}
			}
			else
			{
				return 0;
			}
		}

		private void DownloadLauncherUpdate()
		{
			Log("Downloading update...");
			Dispatcher.Invoke(() =>
			{
				ProgressText.Text = string.Empty;
				ProgressBar.Visibility = Visibility.Collapsed;
				DownloadProgressBarStackPanel.Visibility = Visibility.Visible;
				DownloadPauseButton.Visibility = Visibility.Collapsed;
				TaskbarItemInfo.ProgressState = TaskbarItemProgressState.Normal;
			});
			try
			{
				tracker.NewFile();
				var eta_calc = new ETACalculator();
				var download = new DownloadPauseable(OnlineVersionInfo.launcher_info.url.ToString(), App.LauncherArchivePath);
				download.Start();
				while(!download.Done)
				{
					tracker.SetProgress(download.BytesWritten, download.ContentLength);
					eta_calc.Update((float)download.BytesWritten / (float)download.ContentLength);
					Dispatcher.Invoke(() =>
					{
						var progress = tracker.GetProgress();
						DownloadProgressBar.Value = progress;
						TaskbarItemInfo.ProgressValue = progress;
						DownloadProgressText.Text = $"{App.TextStrings["progresstext_updating_launcher"].TrimEnd('.')} {Math.Round(progress * 100)}% ({BpUtility.ToBytesCount(download.BytesWritten)}/{BpUtility.ToBytesCount(download.ContentLength)})";
						DownloadETAText.Text = string.Format(App.TextStrings["progresstext_eta"], eta_calc.ETR.ToString("hh\\:mm\\:ss"));
						DownloadSpeedText.Text = $"{App.TextStrings["label_download_speed"]} {tracker.GetBytesPerSecondString()}";
					});
					Thread.Sleep(500);
				}
				Log("success!", false);
				Dispatcher.Invoke(() =>
				{
					ProgressText.Text = App.TextStrings["progresstext_updating_launcher"];
					ProgressBar.Visibility = Visibility.Visible;
					ProgressBar.IsIndeterminate = true;
					DownloadProgressBarStackPanel.Visibility = Visibility.Collapsed;
					TaskbarItemInfo.ProgressState = TaskbarItemProgressState.Indeterminate;
				});
				while(BpUtility.IsFileLocked(new FileInfo(App.LauncherArchivePath)))
				{
					Thread.Sleep(10);
				}
			}
			catch(Exception ex)
			{
				Status = LauncherStatus.Error;
				Log($"Failed to download launcher update:\n{ex}", true, 1);
				Dispatcher.Invoke(() =>
				{
					new DialogWindow(App.TextStrings["msgbox_net_error_title"], App.TextStrings["msgbox_launcher_download_error_msg"]).ShowDialog();
					MessageBox.Show(string.Format(App.TextStrings["msgbox_launcher_download_error_msg"], ex), App.TextStrings["msgbox_net_error_title"], MessageBoxButton.OK, MessageBoxImage.Error);
					Application.Current.Shutdown();
					return;
				});
			}
		}

		private void DownloadLauncherTranslations()
		{
			try
			{
				string translations_url = OnlineVersionInfo.launcher_info.translations.url.ToString();
				string translations_md5 = OnlineVersionInfo.launcher_info.translations.md5.ToString().ToUpper();
				string translations_version = OnlineVersionInfo.launcher_info.translations.version;
				bool Validate()
				{
					if(File.Exists(App.LauncherTranslationsFile))
					{
						var translations_version_reg = App.LauncherRegKey.GetValue("TranslationsVersion");
						if(translations_version_reg != null)
						{
							if(App.LauncherRegKey.GetValueKind("TranslationsVersion") == RegistryValueKind.String)
							{
								if(translations_version == App.LauncherRegKey.GetValue("TranslationsVersion").ToString())
								{
									#if DEBUG
									return true;
									#else
									string actual_md5 = BpUtility.CalculateMD5(App.LauncherTranslationsFile);
									if(actual_md5 != translations_md5)
									{
										Log($"Translations validation failed. Expected MD5: {translations_md5}, got MD5: {actual_md5}", true, 2);
									}
									else
									{
										return true;
									}
									#endif
								}
							}
						}
					}
					return false;
				}
				if(!Validate())
				{
					DeleteFile(App.LauncherTranslationsFile, true);
					int attempts = 3;
					for(int i = 0; i < attempts; i++)
					{
						if(!File.Exists(App.LauncherTranslationsFile))
						{
							Log("Downloading translations...");
							Directory.CreateDirectory(App.LauncherDataPath);
							var web_client = new BpWebClient();
							web_client.DownloadFile(translations_url, App.LauncherTranslationsFile);
							try
							{
								BpUtility.WriteToRegistry("TranslationsVersion", translations_version);
							}
							catch(Exception ex)
							{
								Status = LauncherStatus.Error;
								Log($"Failed to write critical registry info:\n{ex}", true, 1);
								MessageBox.Show(App.TextStrings["msgbox_registry_error_msg"], App.TextStrings["msgbox_registry_error_title"], MessageBoxButton.OK, MessageBoxImage.Error);
								break;
							}
							Log("success!", false);
						}
						if(Validate())
						{
							BpUtility.RestartApp();
							break;
						}
						else
						{
							if(i == attempts - 1)
							{
								Log("Giving up...");
								throw new CryptographicException("Failed to verify translations");
							}
							else
							{
								DeleteFile(App.LauncherTranslationsFile, true);
								Log("Attempting to download again...");
							}
						}
					}
				}
			}
			catch(Exception ex)
			{
				Log($"Failed to download translations:\n{ex}", true, 1);
				MessageBox.Show(App.TextStrings["msgbox_translations_download_error_msg"], App.TextStrings["msgbox_generic_error_title"], MessageBoxButton.OK, MessageBoxImage.Error);
				DeleteFile(App.LauncherTranslationsFile, true);
				Array.Resize(ref App.CommandLineArgs, App.CommandLineArgs.Length + 1);
				App.CommandLineArgs[App.CommandLineArgs.Length - 1] = "NOTRANSLATIONS";
				BpUtility.RestartApp();
			}
		}

		private void DownloadBackgroundImage()
		{
			BackgroundImageDownloading = true;
			try
			{
				string url = null;
				switch(Server)
				{
					case HI3Server.GLB:
						url = OnlineVersionInfo.game_info.mirror.mihoyo.launcher_content.global.ToString();
						break;
					case HI3Server.SEA:
						url = OnlineVersionInfo.game_info.mirror.mihoyo.launcher_content.os.ToString();
						break;
					case HI3Server.CN:
						url = OnlineVersionInfo.game_info.mirror.mihoyo.launcher_content.cn.ToString();
						break;
					case HI3Server.TW:
						url = OnlineVersionInfo.game_info.mirror.mihoyo.launcher_content.tw.ToString();
						break;
					case HI3Server.KR:
						url = OnlineVersionInfo.game_info.mirror.mihoyo.launcher_content.kr.ToString();
						break;
				}
				Directory.CreateDirectory(App.LauncherBackgroundsPath);
				string background_image_url;
				string background_image_md5;
				var web_request = BpUtility.CreateWebRequest(url);
				using(var web_response = (HttpWebResponse)web_request.GetResponse())
				{
					using(var data = new MemoryStream())
					{
						web_response.GetResponseStream().CopyTo(data);
						var json = JsonConvert.DeserializeObject<dynamic>(Encoding.UTF8.GetString(data.ToArray()));
						if(json.retcode == 0)
						{
							if(json.data != null && json.data.adv != null && json.data.adv.background != null)
							{
								background_image_url = json.data.adv.background.ToString();
							}
							else
							{
								BackgroundImageDownloading = false;
								return;
							}
						}
						else
						{
							Log($"Failed to fetch background image info: {json.message.ToString()}", true, 2);
							BackgroundImageDownloading = false;
							return;
						}
					}
				}
				string background_image_name = Path.GetFileName(HttpUtility.UrlDecode(background_image_url));
				string background_image_path = Path.Combine(App.LauncherBackgroundsPath, background_image_name);
				background_image_md5 = background_image_name.Split('_')[0].ToUpper();
				bool Validate()
				{
					if(File.Exists(background_image_path))
					{
						string actual_md5 = BpUtility.CalculateMD5(background_image_path);
						if(actual_md5 != background_image_md5)
						{
							Log($"Background image validation failed. Expected MD5: {background_image_md5}, got MD5: {actual_md5}", true, 2);
						}
						else
						{
							Dispatcher.Invoke(() => {Resources["BackgroundImage"] = new BitmapImage(new Uri(background_image_path));});
							return true;
						}
					}
					return false;
				}
				try
				{
					foreach(var file in Directory.GetFiles(App.LauncherDataPath, "*.png"))
					{
						File.Move(file, Path.Combine(App.LauncherBackgroundsPath, Path.GetFileName(file)));
					}
				}catch{}
				if(!Validate())
				{
					DeleteFile(background_image_path, true);
					int attempts = 3;
					for(int i = 0; i < attempts; i++)
					{
						if(!File.Exists(background_image_path))
						{
							Log("Downloading background image...");
							Directory.CreateDirectory(App.LauncherDataPath);
							var web_client = new BpWebClient();
							web_client.DownloadFile(background_image_url, background_image_path);
							Log("success!", false);
						}
						if(Validate())
						{
							break;
						}
						else
						{
							if(i == attempts - 1)
							{
								Log("Giving up...");
								throw new CryptographicException("Verification failed");
							}
							else
							{
								DeleteFile(background_image_path, true);
								Log("Attempting to download again...");
							}
						}
					}
				}
			}
			catch(Exception ex)
			{
				Log($"Failed to download background image: {ex.Message}", true, 2);
			}
			BackgroundImageDownloading = false;
		}

		private async Task DownloadGameFile()
		{
			try
			{
				string title;
				long size = 0;
				string url;
				string md5;
				bool abort = false;
				if(Mirror == HI3Mirror.miHoYo)
				{
					title = GameArchiveName;
					url = miHoYoVersionInfo.game.latest.path.ToString();
					if(PatchDownload)
					{
						md5 = miHoYoVersionInfo.game.diffs[PatchDownloadInt].md5.ToString();
					}
					else
					{
						md5 = miHoYoVersionInfo.game.latest.md5.ToString();
					}
				}
				else
				{
					title = GameArchiveName;
					url = OnlineVersionInfo.game_info.mirror.hi3mirror.game_archive.ToString() + title;
					md5 = miHoYoVersionInfo.game.latest.md5.ToString();
				}
				md5 = md5.ToUpper();
				GameArchiveTempPath = $"{GameArchivePath}_tmp";
				Status = LauncherStatus.Downloading;
				ProgressBar.IsIndeterminate = true;
				if(File.Exists(GameArchivePath))
				{
					File.Move(GameArchivePath, GameArchiveTempPath);
				}
				if(!File.Exists(GameArchiveTempPath))
				{
					Log($"Starting to download game archive: {title} ({url})");
					if(!App.UseLegacyDownload)
					{
						try
						{
							httpclient = new Http();
							httpprop = new HttpProp(url, GameArchiveTempPath);
							token = new CancellationTokenSource();
							httpclient.DownloadProgress += DownloadStatusChanged;
							Dispatcher.Invoke(() =>
							{
								ProgressText.Text = string.Empty;
								ProgressBar.Visibility = Visibility.Collapsed;
								DownloadProgressBarStackPanel.Visibility = Visibility.Visible;
								LaunchButton.IsEnabled = true;
								LaunchButton.Content = App.TextStrings["button_cancel"];
							});
							await httpclient.DownloadMultisession(httpprop.URL, httpprop.Out, false, httpprop.Thread, token.Token);
							await httpclient.MergeMultisession(httpprop.Out, httpprop.Thread, token.Token);
							httpclient.DownloadProgress -= DownloadStatusChanged;
							Log("Successfully downloaded game archive");
							Dispatcher.Invoke(() =>
							{
								ProgressText.Text = string.Empty;
								DownloadProgressBarStackPanel.Visibility = Visibility.Collapsed;
								LaunchButton.Content = App.TextStrings["button_launch"];
							});
						}
						catch(OperationCanceledException)
						{
							httpclient.DownloadProgress -= DownloadStatusChanged;
							return;
						}
					}
					else
					{
						await Task.Run(() =>
						{
							tracker.NewFile();
							var eta_calc = new ETACalculator();
							download = new DownloadPauseable(url, GameArchiveTempPath);
							download.Start();
							Dispatcher.Invoke(() =>
							{
								ProgressText.Text = string.Empty;
								ProgressBar.Visibility = Visibility.Collapsed;
								DownloadProgressBarStackPanel.Visibility = Visibility.Visible;
								LaunchButton.IsEnabled = true;
								LaunchButton.Content = App.TextStrings["button_cancel"];
							});
							while(download != null && !download.Done)
							{
								if(DownloadPaused)
								{
									continue;
								}
								size = download.ContentLength;
								tracker.SetProgress(download.BytesWritten, download.ContentLength);
								eta_calc.Update((float)download.BytesWritten / (float)download.ContentLength);
								Dispatcher.Invoke(() =>
								{
									var progress = tracker.GetProgress();
									DownloadProgressBar.Value = progress;
									TaskbarItemInfo.ProgressValue = progress;
									DownloadProgressText.Text = $"{string.Format(App.TextStrings["label_downloaded_1"], Math.Round(progress * 100))} ({BpUtility.ToBytesCount(download.BytesWritten)}/{BpUtility.ToBytesCount(download.ContentLength)})";
									DownloadETAText.Text = string.Format(App.TextStrings["progresstext_eta"], eta_calc.ETR.ToString("hh\\:mm\\:ss"));
									DownloadSpeedText.Text = $"{App.TextStrings["label_download_speed"]} {tracker.GetBytesPerSecondString()}";
								});
								Thread.Sleep(500);
							}
							if(download == null)
							{
								abort = true;
							}
							if(abort)
							{
								return;
							}
							download = null;
							Log("Successfully downloaded game archive");
							while(BpUtility.IsFileLocked(new FileInfo(GameArchiveTempPath)))
							{
								Thread.Sleep(10);
							}
							Dispatcher.Invoke(() =>
							{
								ProgressText.Text = string.Empty;
								DownloadProgressBarStackPanel.Visibility = Visibility.Collapsed;
								LaunchButton.Content = App.TextStrings["button_launch"];
							});
						});
					}
				}

				try
				{
					if(abort)
					{
						return;
					}
					await Task.Run(() =>
					{
						Log("Validating game archive...");
						Status = LauncherStatus.Verifying;
						string actual_md5 = BpUtility.CalculateMD5(GameArchiveTempPath);
						if(actual_md5 == md5)
						{
							if(!File.Exists(GameArchivePath))
							{
								File.Move(GameArchiveTempPath, GameArchivePath);
							}
							else if(File.Exists(GameArchivePath) && size != 0 && new FileInfo(GameArchivePath).Length != size)
							{
								DeleteFile(GameArchivePath);
								File.Move(GameArchiveTempPath, GameArchivePath);
							}
							Log("success!", false);
						}
						else
						{
							Status = LauncherStatus.Error;
							Log($"Validation failed. Expected MD5: {md5}, got MD5: {actual_md5}", true, 1);
							DeleteFile(GameArchiveTempPath);
							abort = true;
							Dispatcher.Invoke(() => {new DialogWindow(App.TextStrings["msgbox_verify_error_title"], App.TextStrings["msgbox_verify_error_1_msg"]).ShowDialog();});
							Status = LauncherStatus.Ready;
							GameUpdateCheck();
						}
						if(abort)
						{
							return;
						}
						if(!PatchDownload)
						{
							try
							{
								foreach(var file in Directory.GetFiles(Path.Combine(GameInstallPath, @"BH3_Data\StreamingAssets\Asb\pc"), "*.wmv"))
								{
									DeleteFile(file);
								}
							}catch{}
						}
						var skipped_files = new List<string>();
						using(var archive = ArchiveFactory.Open(GameArchivePath))
						{
							int unpacked_files = 0;
							int file_count = 0;

							Log("Unpacking game archive...");
							Status = LauncherStatus.Unpacking;
							foreach(var entry in archive.Entries)
							{
								if(!entry.IsDirectory)
								{
									file_count++;
								}
							}
							var reader = archive.ExtractAllEntries();
							while(reader.MoveToNextEntry())
							{
								try
								{
									Dispatcher.Invoke(() =>
									{
										var progress = (unpacked_files + 1f) / file_count;
										DownloadProgressText.Text = string.Format(App.TextStrings["progresstext_unpacking_2"], unpacked_files + 1, file_count, Math.Round(progress * 100, 2));
										DownloadProgressBar.Value = progress;
										TaskbarItemInfo.ProgressValue = progress;
									});
									reader.WriteEntryToDirectory(GameInstallPath, new ExtractionOptions(){ExtractFullPath = true, Overwrite = true, PreserveFileTime = true});
									if(!reader.Entry.IsDirectory)
									{
										unpacked_files++;
									}
								}
								catch
								{
									if(!reader.Entry.IsDirectory)
									{
										skipped_files.Add(reader.Entry.ToString());
										file_count--;
										Log($"Unpack {reader.Entry}");
									}
								}
							}
						}
						if(skipped_files.Count > 0)
						{
							DeleteFile(GameArchivePath);
							throw new ArchiveException("Game archive is corrupt");
						}
						Log("success!", false);
						DeleteFile(GameArchivePath);
						Dispatcher.Invoke(() => 
						{
							PatchDownload = false;
							WriteVersionInfo(false, true);
							Log("Successfully installed the game");
							GameUpdateCheck();
						});
					});
				}
				catch(Exception ex)
				{
					Status = LauncherStatus.Error;
					Log($"Failed to install the game:\n{ex}", true, 1);
					Dispatcher.Invoke(() =>
					{
						new DialogWindow(App.TextStrings["msgbox_install_error_title"], App.TextStrings["msgbox_install_error_msg"]).ShowDialog();
						Status = LauncherStatus.Ready;
						GameUpdateCheck();
					});
				}
			}
			catch(Exception ex)
			{
				Status = LauncherStatus.Error;
				Log($"Failed to download the game:\n{ex}", true, 1);
				new DialogWindow(App.TextStrings["msgbox_game_download_error_title"], App.TextStrings["msgbox_game_download_error_msg"]).ShowDialog();
				Status = LauncherStatus.Ready;
				GameUpdateCheck();
			}
		}

		private void WriteVersionInfo(bool check_for_local_version = false, bool is_installed = false)
		{
			try
			{
				string game_config_ini_file = Path.Combine(GameInstallPath, "config.ini");
				string launcher_config_ini_file = null;
				try
				{
					launcher_config_ini_file = Path.Combine(Registry.LocalMachine.OpenSubKey($@"SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\{GameInstallRegistryName}").GetValue("InstallPath").ToString(), "config.ini");
				}catch{}
				IniData game_config_ini_data = null;
				IniData launcher_config_ini_data = null;
				var ini_parser = new FileIniDataParser();
				if(File.Exists(game_config_ini_file))
				{
					game_config_ini_data = ini_parser.ReadFile(game_config_ini_file);
				}
				if(File.Exists(launcher_config_ini_file))
				{
					launcher_config_ini_data = ini_parser.ReadFile(launcher_config_ini_file);
				}
				var version_info = LocalVersionInfo;
				if(version_info == null)
				{
					version_info = new ExpandoObject();
					version_info.game_info = new ExpandoObject();
				}
				if(!PatchDownload)
				{
					version_info.game_info.version = miHoYoVersionInfo.game.latest.version.ToString();
				}
				else
				{
					version_info.game_info.version = LocalVersionInfo.game_info.version.ToString();
				}
				version_info.game_info.install_path = GameInstallPath;
				version_info.game_info.installed = is_installed;

				if(new DirectoryInfo(GameInstallPath).Parent == null)
				{
					throw new Exception("Installation directory cannot be drive root");
				}
				if(check_for_local_version)
				{
					var key = Registry.CurrentUser.OpenSubKey(GameRegistryPath);
					try
					{
						if(game_config_ini_data["General"]["game_version"] != null)
						{
							version_info.game_info.version = game_config_ini_data["General"]["game_version"];
						}
						else
						{
							throw new NullReferenceException();
						}
					}
					catch
					{
						if(new DialogWindow(App.TextStrings["msgbox_install_title"], App.TextStrings["msgbox_install_existing_no_local_version_msg"], DialogWindow.DialogType.Question).ShowDialog() == false)
						{
							version_info.game_info.version = new GameVersion().ToString();
						}
					}
					if(key != null)
					{
						key.Close();
					}
				}
				Log("Writing game version info...");
				BpUtility.WriteToRegistry(RegistryVersionInfo, Encoding.UTF8.GetBytes(JsonConvert.SerializeObject(version_info)), RegistryValueKind.Binary);
				if(is_installed)
				{
					try
					{
						if(game_config_ini_data == null)
						{
							game_config_ini_data = new IniData();
						}
						game_config_ini_data.Configuration.AssigmentSpacer = string.Empty;
						game_config_ini_data["General"]["game_version"] = version_info.game_info.version;
						ini_parser.WriteFile(game_config_ini_file, game_config_ini_data);
					}
					catch(Exception ex)
					{
						Log($"Failed to write version info to game config.ini: {ex.Message}", true, 2);
					}
					try
					{
						if(launcher_config_ini_data != null)
						{
							string path = BpUtility.GetCNotatedStringPath(GameInstallPath.Replace("\\", "/"));
							launcher_config_ini_data.Configuration.AssigmentSpacer = string.Empty;
							if(launcher_config_ini_data["launcher"]["game_install_path"] != path)
							{
								launcher_config_ini_data["launcher"]["game_install_path"] = path;
								ini_parser.WriteFile(launcher_config_ini_file, launcher_config_ini_data);
							}
						}
					}
					catch(Exception ex)
					{
						Log($"Failed to write path to launcher config.ini: {ex.Message}", true, 2);
					}
				}
				Log("success!", false);
			}
			catch(Exception ex)
			{
				Status = LauncherStatus.Error;
				Log($"Failed to write version info:\n{ex}", true, 1);
				new DialogWindow(App.TextStrings["msgbox_generic_error_title"], App.TextStrings["msgbox_generic_error_msg"]).ShowDialog();
			}
		}

		private void ResetVersionInfo(bool DeleteGame = false)
		{
			if(DeleteGame)
			{
				if(Directory.Exists(GameInstallPath))
				{
					Directory.Delete(GameInstallPath, true);
				}
			}
			try{App.LauncherRegKey.DeleteValue(RegistryVersionInfo);}catch{}
			Dispatcher.Invoke(() => {LaunchButton.Content = App.TextStrings["button_download"];});
		}

		private readonly string[] CacheRegionalCheckName = new string[]{"sprite"};
		private enum CacheType {Data, Event, Ai, Unknown}
		private string ReturnCacheTypeEnum(CacheType enumName)
		{
			switch(enumName)
			{
				case CacheType.Ai:
					return "ai";
				case CacheType.Data:
					return "data";
				case CacheType.Event:
					return "event";
				default:
					throw new Exception("Unknown cache file data type");
			}
		}

		/*
		 * N			-> Name of the necessary file
		 * CRC			-> Expected MD5 hash of the file
		 * CS			-> Size of the file
		 * IsNecessary	-> The file is necessary on "Updating settings" screen
		 */
		private class CacheDataProperties
		{
			public string N {get; set;}
			public string CRC {get; set;}
			public long CS {get; set;}
			public bool IsNecessary {get; set;}
			public CacheType Type {get; set;}
		}

		/* Filter Region Type of Cache File
		 * 0 -> the file is a regional file but outside user region.
		 * 1 -> the file is a regional file but inside user region and downloadable.
		 * 2 -> the file is not a regional file and downloadable.
		 */
		private byte FilterRegion(string input, string regionName)
		{
			foreach(string word in CacheRegionalCheckName)
			{
				if(input.Contains(word))
				{
					if(input.Contains($"{word}_{regionName}"))
					{
						return 1;
					}
					else
					{
						return 0;
					}
				}
			}
			return 2;
		}

		// Normalize Unix path (/) to Windows path (\)
		private string NormalizePath(string i) => i.Replace('/', '\\');

		private async void DownloadGameCache(string game_language)
		{
			string data;
			string path;
			string data_url = OnlineVersionInfo.game_info.mirror.hi3mirror.game_cache.ToString();
			string hi3mirror_api_url = OnlineVersionInfo.game_info.mirror.hi3mirror.api.ToString();

			List<CacheDataProperties> cache_files, bad_files;
			CacheType cache_type;
			var web_client = new BpWebClient();

			try
			{
				int server;
				switch((int)Server)
				{
					case 0:
						server = 1;
						break;
					case 1:
						server = 0;
						break;
					case 2:
						server = 2;
						break;
					default:
						throw new NotSupportedException("This server is not supported.");
				}

				cache_files = new List<CacheDataProperties>();
				bad_files = new List<CacheDataProperties>();

				await Task.Run(() =>
				{
					for(int i = 0; i < 3; i++)
					{
						// Classify data type as per i
						// 0 or _	: Data and AI/Btree cache
						// 1		: Resources/Event cache
						// 2		: Btree/Ai cache
						switch(i)
						{
							case 0:
								cache_type = CacheType.Data;
								break;
							case 1:
								cache_type = CacheType.Event;
								break;
							case 2:
								cache_type = CacheType.Ai;
								break;
							default:
								cache_type = CacheType.Unknown;
								break;
						}

						// Get URL and API data
						var url = string.Format(hi3mirror_api_url, i, server);
						data = web_client.DownloadString(url);

						// Do Elimination Process
						// Deserialize string and make it to Object as List<CacheDataProperties>
						foreach(CacheDataProperties file in JsonConvert.DeserializeObject<List<CacheDataProperties>>(data))
						{
							// Do check whenever the file is included regional language as game_language defined
							// Then add it to cache_files list
							if(FilterRegion(file.N, game_language) > 0)
							{
								// Do add if the Filter passed.
								cache_files.Add(new CacheDataProperties
								{
									N = file.N,
									CRC = file.CRC,
									CS = file.CS,
									IsNecessary = file.IsNecessary,
									Type = cache_type
								});
							}
						}
					}
				});
				Log("success!", false);
			}
			catch(WebException ex)
			{
				Status = LauncherStatus.Error;
				Log($"Failed to connect to Hi3Mirror:\n{ex}", true, 1);
				new DialogWindow(App.TextStrings["msgbox_net_error_title"], string.Format(App.TextStrings["msgbox_net_error_msg"], ex.Message)).ShowDialog();
				Status = LauncherStatus.Ready;
				return;
			}

			try
			{
				Directory.CreateDirectory(GameCachePath);
				var existing_files = new DirectoryInfo(GameCachePath).GetFiles("*", SearchOption.AllDirectories).Where(x => x.DirectoryName.Contains(@"Data\data") || x.DirectoryName.Contains("Resources")).ToList();
				var useless_files = existing_files;
				long bad_files_size = 0;
				long empty_directories_count = 0;

				Status = LauncherStatus.Working;
				OptionsButton.IsEnabled = true;
				ProgressBar.IsIndeterminate = false;
				TaskbarItemInfo.ProgressState = TaskbarItemProgressState.Normal;
				Log("Verifying game cache...");
				await Task.Run(() =>
				{
					for(int i = 0; i < cache_files.Count; i++)
					{
						var name = $"{NormalizePath(cache_files[i].N)}.unity3d";

						// Combine Path and assign their own path
						// If none of them assigned as Unknown type, throw an exception.
						switch(cache_files[i].Type)
						{
							case CacheType.Data:
								path = Path.Combine(GameCachePath, "Data", name);
								break;
							case CacheType.Ai:
							case CacheType.Event:
								path = Path.Combine(GameCachePath, "Resources", name);
								break;
							default:
								throw new Exception("Unknown cache file data type");
						}
						var file = new FileInfo(path);

						Dispatcher.Invoke(() =>
						{
							ProgressText.Text = string.Format(App.TextStrings["progresstext_verifying_file"], i + 1, cache_files.Count);
							var progress = (i + 1f) / cache_files.Count;
							ProgressBar.Value = progress;
							TaskbarItemInfo.ProgressValue = progress;
						});

						if(file.Exists)
						{
							if(BpUtility.CalculateMD5(file.FullName) == cache_files[i].CRC)
							{
								if(App.AdvancedFeatures) Log($"File OK: {path}");
							}
							else
							{
								bad_files.Add(cache_files[i]);
								Log($"File corrupted: {path}");
							}
							useless_files.RemoveAll(x => x.FullName == path);
						}
						else
						{
							if(cache_files[i].IsNecessary)
							{
								bad_files.Add(cache_files[i]);
								Log($"File missing: {path}");
							}
						}
					}

					foreach(var useless_file in useless_files)
					{
						Log($"Useless file: {useless_file.FullName}");
					}

					bad_files_size = bad_files.Sum(x => x.CS);
				});

				ProgressText.Text = string.Empty;
				ProgressBar.Visibility = Visibility.Collapsed;
				ProgressBar.Value = 0;
				TaskbarItemInfo.ProgressState = TaskbarItemProgressState.None;
				TaskbarItemInfo.ProgressValue = 0;
				WindowState = WindowState.Normal;

				if(useless_files.Count > 0)
				{
					foreach(var file in useless_files)
					{
						DeleteFile(file.FullName, true);
					}
					Log($"Deleted {useless_files.Count} useless files");
				}

				foreach(var dir in Directory.GetDirectories(GameCachePath, "*", SearchOption.AllDirectories).Reverse())
				{
					if(dir.Contains("Crashes"))
					{
						continue;
					}
					try
					{
						if(Directory.GetFiles(dir, "*", SearchOption.AllDirectories).Length == 0)
						{
							Log($"Empty directory: {dir}");
							Directory.Delete(dir);
							empty_directories_count++;
						}
					}catch{}
				}
				if(empty_directories_count > 0)
				{
					Log($"Deleted {empty_directories_count} empty directories");
				}

				if(bad_files.Count > 0)
				{
					Log($"Finished verifying files, found corrupted/missing files: {bad_files.Count}");
					if(new DialogWindow(App.TextStrings["contextmenu_download_cache"], string.Format(App.TextStrings["msgbox_repair_3_msg"], bad_files.Count, BpUtility.ToBytesCount(bad_files_size)), DialogWindow.DialogType.Question).ShowDialog() == true)
					{
						string server;
						switch((int)Server)
						{
							case 0:
								server = "global";
								if(Mirror == HI3Mirror.miHoYo) data_url = OnlineVersionInfo.game_info.mirror.mihoyo.game_cache.global.ToString();
								break;
							case 1:
								server = "sea";
								if(Mirror == HI3Mirror.miHoYo) data_url = OnlineVersionInfo.game_info.mirror.mihoyo.game_cache.os.ToString();
								break;
							case 2:
								server = "cn";
								if(Mirror == HI3Mirror.miHoYo) data_url = OnlineVersionInfo.game_info.mirror.mihoyo.game_cache.cn.ToString();
								break;
							default:
								throw new NotSupportedException("This server is not supported.");
						}

						int downloaded_files = 0;
						Status = LauncherStatus.Downloading;

						await Task.Run(async () =>
						{
							for(int i = 0; i < bad_files.Count; i++)
							{
								path = $"{NormalizePath(bad_files[i].N)}.unity3d";
								switch(bad_files[i].Type)
								{
									case CacheType.Data:
										path = Path.Combine(GameCachePath, "Data", path);
										break;
									case CacheType.Ai:
									case CacheType.Event:
										path = Path.Combine(GameCachePath, "Resources", path);
										break;
								}

								var url = string.Format(data_url, server, ReturnCacheTypeEnum(bad_files[i].Type), bad_files[i].N);
								if(Mirror == HI3Mirror.miHoYo) url = string.Format(data_url, ReturnCacheTypeEnum(bad_files[i].Type), bad_files[i].N);
								Log($"Downloading from {url}...");
								Dispatcher.Invoke(() =>
								{
									ProgressText.Text = string.Format(App.TextStrings["progresstext_downloading_file"], i + 1, bad_files.Count);
									var progress = (i + 1f) / bad_files.Count;
									ProgressBar.Value = progress;
									TaskbarItemInfo.ProgressValue = progress;
								});

								try
								{
									Directory.CreateDirectory(Path.GetDirectoryName(path));
									await web_client.DownloadFileTaskAsync(new Uri(url), path);
									var md5 = BpUtility.CalculateMD5(path);
									if(File.Exists(path) && md5 != bad_files[i].CRC)
									{
										throw new CryptographicException("Verification failed");
									}
									else
									{
										Log("success!", false);
										downloaded_files++;
									}
								}
								catch(Exception ex)
								{
									Log($"Failed to download file [{bad_files[i].N}] ({url}): {ex.Message}", true, 1);
								}
							}
						});

						Dispatcher.Invoke(() =>
						{
							LaunchButton.Content = App.TextStrings["button_launch"];
							ProgressText.Text = string.Empty;
							ProgressBar.Visibility = Visibility.Collapsed;
							TaskbarItemInfo.ProgressState = TaskbarItemProgressState.None;
						});

						if(downloaded_files == bad_files.Count)
						{
							Log($"Successfully downloaded {downloaded_files} file(s)");
							Dispatcher.Invoke(() =>
							{
								new DialogWindow(App.TextStrings["contextmenu_download_cache"], string.Format(App.TextStrings["msgbox_repair_4_msg"], downloaded_files)).ShowDialog();
							});
						}
						else
						{
							int skipped_files = bad_files.Count - downloaded_files;
							if(downloaded_files > 0)
							{
								Log($"Successfully downloaded {downloaded_files} files, failed to download {skipped_files} files");
							}
							
							Dispatcher.Invoke(() =>
							{
								new DialogWindow(App.TextStrings["contextmenu_download_cache"], string.Format(App.TextStrings["msgbox_repair_5_msg"], skipped_files)).ShowDialog();
							});
						}
					}
				}
				else
				{
					Log("Finished verifying files, the cache is up-to-date");
					Dispatcher.Invoke(() =>
					{
						ProgressText.Text = string.Empty;
						ProgressBar.Visibility = Visibility.Collapsed;
						TaskbarItemInfo.ProgressState = TaskbarItemProgressState.None;
					});
					new DialogWindow(App.TextStrings["contextmenu_download_cache"], App.TextStrings["msgbox_repair_2_msg"]).ShowDialog();
				}
				Status = LauncherStatus.Ready;

			}
			catch(Exception ex)
			{
				Status = LauncherStatus.Error;
				Log($"{ex}", true, 1);
				new DialogWindow(App.TextStrings["msgbox_generic_error_title"], App.TextStrings["msgbox_generic_error_msg"]).ShowDialog();
				Status = LauncherStatus.Ready;
			}
		}

		private async void Window_ContentRendered(object sender, EventArgs e)
		{
			#if DEBUG
			App.DisableAutoUpdate = true;
			#endif
			try
			{
				string exe_name = Process.GetCurrentProcess().MainModule.ModuleName;
				string old_exe_name = $"{Path.GetFileNameWithoutExtension(App.LauncherPath)}_old.exe";

				if(Process.GetCurrentProcess().MainModule.ModuleName != App.LauncherExeName)
				{
					Status = LauncherStatus.Error;
					DeleteFile(App.LauncherPath, true);
					File.Move(Path.Combine(App.LauncherRootPath, exe_name), App.LauncherPath);
					BpUtility.RestartApp();
					return;
				}
				DeleteFile(Path.Combine(App.LauncherRootPath, old_exe_name), true);
				DeleteFile(Path.Combine(App.LauncherRootPath, "BetterHI3Launcher.exe.bak"), true); // legacy name
				await Task.Run(() =>
				{
					if(App.DisableAutoUpdate)
					{
						return;
					}

					if(!App.NeedsUpdate)
					{
						if(BpUtility.CalculateMD5(App.LauncherPath) != OnlineVersionInfo.launcher_info.exe_md5.ToString().ToUpper())
						{
							Log($"Launcher integrity error, attempting self-repair...", true, 1);
							App.NeedsUpdate = true;
						}
					}
					if(App.NeedsUpdate)
					{
						Log("A newer version of the launcher is available!");
						Status = LauncherStatus.Working;
						DownloadLauncherUpdate();
						Log("Validating update...");
						string md5 = OnlineVersionInfo.launcher_info.md5.ToString().ToUpper();
						string actual_md5 = BpUtility.CalculateMD5(App.LauncherArchivePath);
						if(actual_md5 != md5)
						{
							Status = LauncherStatus.Error;
							Log($"Validation failed. Expected MD5: {md5}, got MD5: {actual_md5}", true, 1);
							DeleteFile(App.LauncherArchivePath, true);
							Dispatcher.Invoke(() => {new DialogWindow(App.TextStrings["msgbox_verify_error_title"], App.TextStrings["msgbox_verify_error_1_msg"]).ShowDialog();});
							return;
						}
						Log("success!", false);
						Log("Performing update...");
						File.Move(Path.Combine(App.LauncherRootPath, exe_name), Path.Combine(App.LauncherRootPath, old_exe_name));
						using(var archive = ArchiveFactory.Open(App.LauncherArchivePath))
						{
							var reader = archive.ExtractAllEntries();
							while(reader.MoveToNextEntry())
							{
								reader.WriteEntryToDirectory(App.LauncherRootPath, new ExtractionOptions(){ExtractFullPath = true, Overwrite = true, PreserveFileTime = true});
							}
						}
						Log("success!", false);
						Dispatcher.Invoke(() => {BpUtility.RestartApp();});
						return;
					}
					else
					{
						DeleteFile(App.LauncherArchivePath, true);
						DeleteFile(Path.Combine(App.LauncherRootPath, "BetterHI3Launcher.7z"), true); // legacy name
						if(!File.Exists(App.LauncherPath))
						{
							File.Copy(Path.Combine(App.LauncherRootPath, exe_name), App.LauncherPath, true);
						}
					}
				});
			}
			catch(Exception ex)
			{
				Status = LauncherStatus.Error;
				Log($"Failed to start the launcher:\n{ex}", true, 1);
				new DialogWindow(App.TextStrings["msgbox_start_error_title"], string.Format(App.TextStrings["msgbox_start_error_msg"], ex.Message)).ShowDialog();
				return;
			}


			if(App.FirstLaunch)
			{
				LegacyBoxActive = true;
				IntroBox.Visibility = Visibility.Visible;
				ProgressBar.Visibility = Visibility.Collapsed;
			}
			else
			{
				FetchAnnouncements();
			}
			var custom_background_name_reg = App.LauncherRegKey.GetValue("CustomBackgroundName");
			if(custom_background_name_reg != null)
			{
				if(App.LauncherRegKey.GetValueKind("CustomBackgroundName") == RegistryValueKind.String)
				{
					string path = Path.Combine(App.LauncherBackgroundsPath, custom_background_name_reg.ToString());
					if(File.Exists(path))
					{
						SetCustomBackgroundFile(path);
					}
					else
					{
						Log("Custom background file cannot be found, resetting to official...", true, 2);
						BpUtility.DeleteFromRegistry("CustomBackgroundName");
					}
				}
			}
		}

		private void CloseButton_Click(object sender, RoutedEventArgs e)
		{
			if(LegacyBoxActive)
			{
				return;
			}

			Close();
		}

		private void MinimizeButton_Click(object sender, RoutedEventArgs e)
		{
			if(LegacyBoxActive)
			{
				return;
			}

			WindowState = WindowState.Minimized;
		}

		private async void LaunchButton_Click(object sender, RoutedEventArgs e)
		{
			if(LegacyBoxActive)
			{
				return;
			}

			BpUtility.PlaySound(Properties.Resources.Click);
			if(Status == LauncherStatus.Ready || Status == LauncherStatus.Preloading || Status == LauncherStatus.PreloadVerifying)
			{
				if(DownloadPaused)
				{
					DownloadPaused = false;
					await DownloadGameFile();
					return;
				}

				if(LocalVersionInfo != null)
				{
					if(!File.Exists(GameExePath))
					{
						if(new DialogWindow(App.TextStrings["msgbox_no_game_exe_title"], App.TextStrings["msgbox_no_game_exe_msg"], DialogWindow.DialogType.Question).ShowDialog() == true)
						{
							ResetVersionInfo();
							GameUpdateCheck();
						}
						return;
					}
					try
					{
						var processes = Process.GetProcessesByName("BH3");
						if(processes.Length > 0)
						{
							processes[0].EnableRaisingEvents = true;
							processes[0].Exited += new EventHandler((object s, EventArgs ea) => {OnGameExit();});
							if(PreloadDownload)
							{
								Dispatcher.Invoke(() =>
								{
									LaunchButton.Content = App.TextStrings["button_running"];
									LaunchButton.IsEnabled = false;
								});
							}
							else
							{
								Status = LauncherStatus.Running;
							}
							return;
						}
						var start_info = new ProcessStartInfo(GameExePath);
						start_info.WorkingDirectory = GameInstallPath;
						start_info.UseShellExecute = true;
						try
						{
							start_info.Arguments = LocalVersionInfo.launch_options.ToString();
						}catch{}
						var process = Process.Start(start_info);
						process.EnableRaisingEvents = true;
						process.Exited += new EventHandler((object s1, EventArgs ea1) =>
						{
							processes = Process.GetProcessesByName("BH3");
							if(processes.Length > 0)
							{
								processes[0].EnableRaisingEvents = true;
								processes[0].Exited += new EventHandler((object s2, EventArgs ea2) => {OnGameExit();});
							}
							else
							{
								OnGameExit();
							}
						});
						if(PreloadDownload)
						{
							Dispatcher.Invoke(() =>
							{
								LaunchButton.Content = App.TextStrings["button_running"];
								LaunchButton.IsEnabled = false;
							});
						}
						else
						{
							Status = LauncherStatus.Running;
						}
						WindowState = WindowState.Minimized;
					}
					catch(Exception ex)
					{
						Status = LauncherStatus.Error;
						Log($"Failed to start the game:\n{ex}", true, 1);
						new DialogWindow(App.TextStrings["msgbox_start_error_title"], App.TextStrings["msgbox_process_start_error_msg"]).ShowDialog();
						Status = LauncherStatus.Ready;
					}
				}
				else
				{
					try
					{
						var possible_paths = new List<string>();
						possible_paths.Add(App.LauncherRootPath);
						possible_paths.Add(Environment.ExpandEnvironmentVariables("%ProgramW6432%"));
						string[] game_reg_names = {"Honkai Impact 3rd", "Honkai Impact 3", "崩坏3", "崩壞3rd", "붕괴3rd"};
						foreach(string game_reg_name in game_reg_names)
						{
							try
							{
								var path = CheckForExistingGameDirectory(Registry.LocalMachine.OpenSubKey($@"SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\{game_reg_name}").GetValue("InstallPath").ToString());
								if(!string.IsNullOrEmpty(path))
								{
									possible_paths.Add(path);
								}
							}catch{}
						}
						foreach(string path in possible_paths)
						{
							if(!string.IsNullOrEmpty(CheckForExistingGameDirectory(path)))
							{
								var server = CheckForExistingGameClientServer(path);
								if(server >= 0)
								{
									if(new DialogWindow(App.TextStrings["msgbox_install_title"], string.Format(App.TextStrings["msgbox_install_existing_dir_msg"], path), DialogWindow.DialogType.Question).ShowDialog() == true)
									{
										Log($"Existing installation directory selected: {path}");
										GameInstallPath = path;
										if((int)Server != server)
										{
											ServerDropdown.SelectedIndex = server;
										}
										WriteVersionInfo(true, true);
										GameUpdateCheck();
										return;
									}
								}
							}
						}
					}catch{}

					while(true)
					{
						try
						{
							var dialog = new DialogWindow(App.TextStrings["msgbox_install_title"], $"{App.TextStrings["msgbox_install_1_msg"]}\n{string.Format(App.TextStrings["msgbox_install_2_msg"], BpUtility.ToBytesCount((long)miHoYoVersionInfo.size))}\n{string.Format(App.TextStrings["msgbox_install_3_msg"], BpUtility.ToBytesCount((long)miHoYoVersionInfo.game.latest.size))}", DialogWindow.DialogType.Install);
							dialog.InstallPathTextBox.Text = Path.Combine(Environment.ExpandEnvironmentVariables("%ProgramW6432%"), GameFullName);
							if(dialog.ShowDialog() == false)
							{
								return;
							}
							GameInstallPath = dialog.InstallPathTextBox.Text;
							string path = CheckForExistingGameDirectory(GameInstallPath);
							if(!string.IsNullOrEmpty(path))
							{
								var server = CheckForExistingGameClientServer(path);
								if(server >= 0)
								{
									if(new DialogWindow(App.TextStrings["msgbox_install_title"], string.Format(App.TextStrings["msgbox_install_existing_dir_msg"], path), DialogWindow.DialogType.Question).ShowDialog() == true)
									{
										Log($"Existing installation directory selected: {path}");
										GameInstallPath = path;
										if((int)Server != server)
										{
											ServerDropdown.SelectedIndex = server;
										}
										WriteVersionInfo(true, true);
										GameUpdateCheck();
										return;
									}
									else
									{
										continue;
									}
								}
							}

							try
							{
								if(!App.UseLegacyDownload)
								{
									path = GameInstallPath;
									if(!Directory.Exists(GameInstallPath))
									{
										Directory.CreateDirectory(GameInstallPath);
									}
								}
								else
								{
									path = Directory.CreateDirectory(GameInstallPath).FullName;
									Directory.Delete(GameInstallPath);
								}
							}
							catch(Exception ex)
							{
								new DialogWindow(App.TextStrings["msgbox_install_dir_error_title"], ex.Message).ShowDialog();
								continue;
							}

							if(new DialogWindow(App.TextStrings["msgbox_install_title"], string.Format(App.TextStrings["msgbox_install_4_msg"], GameInstallPath), DialogWindow.DialogType.Question).ShowDialog() == false)
							{
								continue;
							}
							var game_install_drive = DriveInfo.GetDrives().Where(x => x.Name == Path.GetPathRoot(GameInstallPath) && x.IsReady).FirstOrDefault();
							if(game_install_drive == null || game_install_drive.DriveType == DriveType.CDRom)
							{
								new DialogWindow(App.TextStrings["msgbox_install_error_title"], App.TextStrings["msgbox_install_wrong_drive_type_msg"]).ShowDialog();
								continue;
							}
							if(game_install_drive.TotalFreeSpace < (long)miHoYoVersionInfo.game.latest.size)
							{
								if(new DialogWindow(App.TextStrings["msgbox_install_title"], App.TextStrings["msgbox_install_little_space_msg"], DialogWindow.DialogType.Question).ShowDialog() == false)
								{
									continue;
								}
							}
							Directory.CreateDirectory(GameInstallPath);
							GameArchivePath = Path.Combine(GameInstallPath, GameArchiveName);
							GameExePath = Path.Combine(GameInstallPath, GameExeName);
							Log($"Installation directory selected: {GameInstallPath}");
							await DownloadGameFile();
							return;
						}
						catch(Exception ex)
						{
							Status = LauncherStatus.Error;
							Log($"Failed to select game installation directory:\n{ex}", true, 1);
							new DialogWindow(App.TextStrings["msgbox_install_dir_error_title"], App.TextStrings["msgbox_install_dir_error_msg"]).ShowDialog();
							Status = LauncherStatus.Ready;
							return;
						}
					}
				}
			}
			else if(Status == LauncherStatus.UpdateAvailable)
			{
				var game_install_drive = DriveInfo.GetDrives().Where(x => x.Name == Path.GetPathRoot(GameInstallPath) && x.IsReady).FirstOrDefault();
				if(game_install_drive.TotalFreeSpace < (long)miHoYoVersionInfo.game.latest.size)
				{
					if(new DialogWindow(App.TextStrings["msgbox_install_title"], App.TextStrings["msgbox_install_little_space_msg"], DialogWindow.DialogType.Question).ShowDialog() == false)
					{
						return;
					}
				}
				if(!PatchDownload)
				{
					Directory.CreateDirectory(GameInstallPath);
				}
				await DownloadGameFile();
			}
			else if(Status == LauncherStatus.Downloading || Status == LauncherStatus.DownloadPaused)
			{
				if(!App.UseLegacyDownload)
				{
					if(httpclient.SessionState == MultisessionState.Merging)
					{
						LaunchButton.IsEnabled = false;
						return;
					}
				}
				if(new DialogWindow(App.TextStrings["msgbox_abort_title"], $"{App.TextStrings["msgbox_abort_2_msg"]}\n{App.TextStrings["msgbox_abort_3_msg"]}", DialogWindow.DialogType.Question).ShowDialog() == true)
				{
					if(!App.UseLegacyDownload)
					{
						token.Cancel();
						await httpclient.DeleteMultisessionChunks(httpprop.Out);
					}
					else
					{
						download.Pause();
						download = null;
						if(!string.IsNullOrEmpty(GameArchiveTempPath))
						{
							while(BpUtility.IsFileLocked(new FileInfo(GameArchiveTempPath)))
							{
								Thread.Sleep(10);
							}
							DeleteFile(GameArchiveTempPath, true);
						}
					}

					try{Directory.Delete(Path.GetDirectoryName(GameArchiveTempPath));}catch{}
					DownloadPaused = false;
					Log("Download cancelled");
					Status = LauncherStatus.Ready;
					GameUpdateCheck();
				}
			}
		}

		private void OptionsButton_Click(object sender, RoutedEventArgs e)
		{
			if(LegacyBoxActive)
			{
				return;
			}

			var button = sender as Button;
			OptionsContextMenu.Placement = System.Windows.Controls.Primitives.PlacementMode.Relative;
			OptionsContextMenu.PlacementTarget = button;
			OptionsContextMenu.VerticalOffset = button.Height;
			OptionsContextMenu.IsOpen = true;
			BpUtility.PlaySound(Properties.Resources.Click);
		}

		private async void DownloadPauseButton_Click(object sender, RoutedEventArgs e)
		{
			if(LegacyBoxActive)
			{
				return;
			}

			if(!DownloadPaused)
			{
				Status = LauncherStatus.DownloadPaused;
				DownloadProgressBarStackPanel.Visibility = Visibility.Visible;
				DownloadETAText.Visibility = Visibility.Hidden;
				DownloadSpeedText.Visibility = Visibility.Hidden;
				DownloadPauseButton.Visibility = Visibility.Collapsed;
				TaskbarItemInfo.ProgressState = TaskbarItemProgressState.Paused;
				if(!App.UseLegacyDownload)
				{
					token.Cancel();
				}
				else
				{
					download.Pause();
				}
				DownloadResumeButton.Visibility = Visibility.Visible;
				Log("Download paused");
			}
			else
			{
				Status = LauncherStatus.Downloading;
				ProgressBar.IsIndeterminate = true;
				DownloadPauseButton.Visibility = Visibility.Collapsed;
				DownloadProgressBarStackPanel.Visibility = Visibility.Collapsed;
				try
				{
					ProgressText.Text = string.Empty;
					ProgressBar.Visibility = Visibility.Collapsed;
					DownloadPauseButton.Visibility = Visibility.Visible;
					DownloadProgressBarStackPanel.Visibility = Visibility.Visible;
					LaunchButton.IsEnabled = true;
					LaunchButton.Content = App.TextStrings["button_cancel"];
					Log("Download resumed");

					if(!App.UseLegacyDownload)
					{
						TaskbarItemInfo.ProgressState = TaskbarItemProgressState.Normal;
						httpclient = new Http();
						token = new CancellationTokenSource();
						httpclient.DownloadProgress += DownloadStatusChanged;
						await httpclient.DownloadMultisession(httpprop.URL, httpprop.Out, false, httpprop.Thread, token.Token);
						await httpclient.MergeMultisession(httpprop.Out, httpprop.Thread, token.Token);
						httpclient.DownloadProgress -= DownloadStatusChanged;
						await DownloadGameFile();
					}
					else
					{
						await download.Start();
					}
				}
				catch(TaskCanceledException){}
				catch(OperationCanceledException){}
				catch(Exception ex)
				{
					Status = LauncherStatus.Error;
					Log($"Failed to download the game:\n{ex}", true, 1);
					new DialogWindow(App.TextStrings["msgbox_game_download_error_title"], App.TextStrings["msgbox_game_download_error_msg"]).ShowDialog();
					Status = LauncherStatus.Ready;
					GameUpdateCheck();
				}
			}
		}

		private async void PreloadButton_Click(object sender, RoutedEventArgs e)
		{
			if(Status != LauncherStatus.Ready && Status != LauncherStatus.Preloading && Status != LauncherStatus.Running)
			{
				return;
			}
			if(LegacyBoxActive)
			{
				return;
			}

			try
			{
				string url = miHoYoVersionInfo.pre_download_game.latest.path.ToString();
				string title = Path.GetFileName(HttpUtility.UrlDecode(url));
				long size;
				string md5 = miHoYoVersionInfo.pre_download_game.latest.md5.ToString();
				string path = Path.Combine(GameInstallPath, title);
				string tmp_path = $"{path}_tmp";
				bool abort = false;

				var web_request = BpUtility.CreateWebRequest(url, "HEAD");
				using(var web_response = (HttpWebResponse) web_request.GetResponse())
				{
					size = web_response.ContentLength;
				}
				if(App.UseLegacyDownload && !File.Exists(tmp_path) || !App.UseLegacyDownload && !File.Exists($"{tmp_path}.001"))
				{
					if(new DialogWindow(App.TextStrings["label_pre_install"], $"{App.TextStrings["msgbox_pre_install_msg"]}\n{string.Format(App.TextStrings["msgbox_install_2_msg"], BpUtility.ToBytesCount(size))}", DialogWindow.DialogType.Question).ShowDialog() == false)
					{
						return;
					}
					var game_install_drive = DriveInfo.GetDrives().Where(x => x.Name == Path.GetPathRoot(GameInstallPath) && x.IsReady).FirstOrDefault();
					if(game_install_drive.TotalFreeSpace < (long)miHoYoVersionInfo.pre_download_game.latest.size)
					{
						if(new DialogWindow(App.TextStrings["msgbox_install_title"], App.TextStrings["msgbox_install_little_space_msg"], DialogWindow.DialogType.Question).ShowDialog() == false)
						{
							return;
						}
					}
					Log($"Starting to pre-download game: {title} ({url})");
				}
				else
				{
					Log("Pre-download resumed");
				}
				PreloadDownload = true;
				Status = LauncherStatus.Preloading;
				if(File.Exists(path))
				{
					File.Move(path, tmp_path);
				}
				if(!App.UseLegacyDownload)
				{
					if(!File.Exists(tmp_path))
					{
						try
						{
							httpclient = new Http();
							token = new CancellationTokenSource();
							httpprop = new HttpProp(url, tmp_path);
							httpclient.DownloadProgress += PreloadDownloadStatusChanged;
							PreloadPauseButton.IsEnabled = true;
							await httpclient.DownloadMultisession(httpprop.URL, httpprop.Out, false, httpprop.Thread, token.Token);
							await httpclient.MergeMultisession(httpprop.Out, httpprop.Thread, token.Token);
							httpclient.DownloadProgress -= PreloadDownloadStatusChanged;
							Log("Downloaded pre-download archive");
						}
						catch(OperationCanceledException)
						{
							httpclient.DownloadProgress -= PreloadDownloadStatusChanged;
							return;
						}
					}
				}
				else
				{
					await Task.Run(() =>
					{
						tracker.NewFile();
						var eta_calc = new ETACalculator();
						download = new DownloadPauseable(url, tmp_path);
						download.Start();
						while(download != null && !download.Done)
						{
							tracker.SetProgress(download.BytesWritten, download.ContentLength);
							eta_calc.Update((float)download.BytesWritten / (float)download.ContentLength);
							Dispatcher.Invoke(() =>
							{
								var progress = tracker.GetProgress();
								PreloadCircleProgressBar.Value = progress;
								TaskbarItemInfo.ProgressValue = progress;
								PreloadBottomText.Text = string.Format(App.TextStrings["label_downloaded_1"], Math.Round(progress * 100));
								PreloadStatusTopLeftText.Text = App.TextStrings["label_downloaded_2"];
								PreloadStatusTopRightText.Text = $"{BpUtility.ToBytesCount(download.BytesWritten)}/{BpUtility.ToBytesCount(download.ContentLength)}";
								PreloadStatusMiddleRightText.Text = eta_calc.ETR.ToString("hh\\:mm\\:ss");
								PreloadStatusBottomLeftText.Text = App.TextStrings["label_download_speed"];
								PreloadStatusBottomRightText.Text = tracker.GetBytesPerSecondString();
							});
							Thread.Sleep(500);
						}
						if(download == null)
						{
							abort = true;
							Status = LauncherStatus.Ready;
							return;
						}
						Log("Downloaded pre-download archive");
						while(BpUtility.IsFileLocked(new FileInfo(tmp_path)))
						{
							Thread.Sleep(10);
						}
					});
					if(abort)
					{
						return;
					}
				}
				Status = LauncherStatus.PreloadVerifying;
				try
				{
					await Task.Run(() =>
					{
						Log("Validating pre-download archive...");
						string actual_md5 = BpUtility.CalculateMD5(tmp_path);
						if(actual_md5 == md5.ToUpper())
						{
							Log("success!", false);
							if(!File.Exists(path))
							{
								File.Move(tmp_path, path);
							}
							else if(File.Exists(path) && new FileInfo(path).Length != size)
							{
								DeleteFile(path, true);
								File.Move(tmp_path, path);
							}
							Log("Successfully pre-downloaded the game");
							PreloadDownload = false;
							GameUpdateCheck();
						}
						else
						{
							Status = LauncherStatus.Error;
							Log($"Validation failed. Expected MD5: {md5}, got MD5: {actual_md5}", true, 1);
							DeleteFile(tmp_path);
							Dispatcher.Invoke(() =>
							{
								PreloadButton.Visibility = Visibility.Visible;
								PreloadPauseButton.Visibility = Visibility.Collapsed;
								PreloadCircle.Visibility = Visibility.Collapsed;
								PreloadCircleProgressBar.Visibility = Visibility.Collapsed;
								PreloadCircleProgressBar.Value = 0;
								PreloadBottomText.Text = App.TextStrings["label_retry"];
							});
							Status = LauncherStatus.Ready;
						}
					});
				}
				catch(Exception ex)
				{
					Status = LauncherStatus.Error;
					Log($"Failed to pre-download the game:\n{ex}", true, 1);
					new DialogWindow(App.TextStrings["msgbox_install_error_title"], App.TextStrings["msgbox_install_error_msg"]).ShowDialog();
					Status = LauncherStatus.Ready;
					GameUpdateCheck();
				}
			}
			catch(Exception ex)
			{
				Status = LauncherStatus.Error;
				Log($"Failed to download game pre-download archive:\n{ex}", true, 1);
				new DialogWindow(App.TextStrings["msgbox_game_download_error_title"], App.TextStrings["msgbox_game_download_error_msg"]).ShowDialog();
				Status = LauncherStatus.Ready;
				GameUpdateCheck();
			}
			TaskbarItemInfo.ProgressState = TaskbarItemProgressState.None;
			WindowState = WindowState.Normal;
		}

		private void PreloadPauseButton_Click(object sender, RoutedEventArgs e)
		{
			if(LegacyBoxActive)
			{
				return;
			}

			if(download != null || httpclient.SessionState == MultisessionState.Downloading)
			{
				PreloadPauseButton.IsEnabled = false;
				if(download != null)
				{
					download.Pause();
					download = null;
				}
				else
				{
					token.Cancel();
				}
				Log("Pre-download paused");
				PreloadDownload = false;
				PreloadPauseButton.IsEnabled = true;
				PreloadPauseButton.Background = (ImageBrush)Resources["PreloadResumeButton"];
				PreloadBottomText.Text = PreloadBottomText.Text.Replace(App.TextStrings["label_downloaded_1"], App.TextStrings["label_paused"]);
				PreloadStatusMiddleRightText.Text = string.Empty;
				PreloadStatusBottomRightText.Text = string.Empty;
				TaskbarItemInfo.ProgressState = TaskbarItemProgressState.None;
			}
			else
			{
				try
				{
					var peer = new ButtonAutomationPeer(PreloadButton);
					var inv_prov = peer.GetPattern(PatternInterface.Invoke) as IInvokeProvider;
					inv_prov.Invoke();
				}
				catch(Exception ex)
				{
					Log($"Failed to resume pre-download:\n{ex}", true, 1);
				}
			}
		}

		private void CM_DownloadCache_Click(object sender, RoutedEventArgs e)
		{
			if(Status != LauncherStatus.Ready)
			{
				return;
			}
			if(LegacyBoxActive)
			{
				return;
			}
			if(Server != HI3Server.GLB && Server != HI3Server.SEA && (Server != HI3Server.CN && Mirror == HI3Mirror.Hi3Mirror))
			{
				new DialogWindow(App.TextStrings["contextmenu_download_cache"], App.TextStrings["msgbox_feature_not_available_msg"]).ShowDialog();
				return;
			}
			int game_language_int;
			string game_language;
			var key = Registry.CurrentUser.OpenSubKey(GameRegistryPath);
			string value = "multi_language_h2498394913";
			if(key == null || key.GetValue(value) == null || key.GetValueKind(value) != RegistryValueKind.DWord)
			{
				game_language_int = 0;
			}
			else
			{
				game_language_int = (int)key.GetValue(value);
			}
			switch(game_language_int)
			{
				case 0:
					game_language = "cn";
					break;
				case 1:
					game_language = "en";
					break;
				case 2:
					if(Server == HI3Server.SEA)
					{
						game_language = "vn";
						break;
					}
					goto case 0;
				case 3:
					if(Server == HI3Server.SEA)
					{
						game_language = "th";
						break;
					}
					goto case 0;
				case 4:
					if(Server == HI3Server.GLB)
					{
						game_language = "fr";
						break;
					}
					goto case 0;
				case 5:
					if(Server == HI3Server.GLB)
					{
						game_language = "de";
						break;
					}
					goto case 0;
				case 6:
					if(Server == HI3Server.SEA)
					{
						game_language = "id";
						break;
					}
					goto case 0;
				default:
					goto case 0;
			}

			if(Mirror == HI3Mirror.miHoYo || Mirror == HI3Mirror.Hi3Mirror)
			{
				if(new DialogWindow(App.TextStrings["contextmenu_download_cache"], string.Format(App.TextStrings["msgbox_download_cache_hi3mirror_msg"], OnlineVersionInfo.game_info.mirror.hi3mirror.maintainer.ToString()), DialogWindow.DialogType.Question).ShowDialog() == false)
				{
					return;
				}
				Status = LauncherStatus.CheckingUpdates;
				Dispatcher.Invoke(() => {ProgressText.Text = App.TextStrings["progresstext_mirror_connect"];});
				Log("Connecting to Hi3Mirror...");
				DownloadGameCache(game_language);
			}
		}

		private async Task CM_Repair_Click(object sender, RoutedEventArgs e)
		{
			if(Status != LauncherStatus.Ready)
			{
				return;
			}
			if(LegacyBoxActive)
			{
				return;
			}
			if(Server != HI3Server.GLB && Server != HI3Server.SEA)
			{
				new DialogWindow(App.TextStrings["contextmenu_repair"], App.TextStrings["msgbox_feature_not_available_msg"]).ShowDialog();
				return;
			}

			Status = LauncherStatus.CheckingUpdates;
			Dispatcher.Invoke(() => {ProgressText.Text = App.TextStrings["progresstext_fetching_hashes"];});
			Log("Fetching repair data...");
			try
			{
				string server = (int)Server == 0 ? "global" : "os";
				var web_client = new BpWebClient();
				await Task.Run(() =>
				{
					OnlineRepairInfo = JsonConvert.DeserializeObject<dynamic>(web_client.DownloadString($"{OnlineVersionInfo.launcher_info.repair_url.ToString()}={server}"));
				});
				if(OnlineRepairInfo.status == "success")
				{
					Log("success!", false);
					OnlineRepairInfo = OnlineRepairInfo.repair_info;
					if(OnlineRepairInfo.game_version != LocalVersionInfo.game_info.version && !App.AdvancedFeatures)
					{
						ProgressText.Text = string.Empty;
						ProgressBar.Visibility = Visibility.Collapsed;
						new DialogWindow(App.TextStrings["contextmenu_repair"], App.TextStrings["msgbox_repair_1_msg"]).ShowDialog();
					}
					else
					{
						Dispatcher.Invoke(() =>
						{
							RepairBox.Visibility = Visibility.Visible;
							RepairBoxMessageTextBlock.Text = string.Format(App.TextStrings["repairbox_msg"], OnlineRepairInfo.mirrors, OnlineVersionInfo.game_info.mirror.maintainer.ToString());
						});
						LegacyBoxActive = true;
					}
				}
				else
				{
					Status = LauncherStatus.Error;
					Log($"Failed to fetch repair data: {OnlineRepairInfo.status_message}", true, 1);
					new DialogWindow(App.TextStrings["msgbox_net_error_title"], string.Format(App.TextStrings["msgbox_net_error_msg"], OnlineRepairInfo.status_message)).ShowDialog();
				}
			}
			catch(Exception ex)
			{
				Status = LauncherStatus.Error;
				Log($"Failed to fetch repair data:\n{ex}", true, 1);
				Dispatcher.Invoke(() => {new DialogWindow(App.TextStrings["msgbox_net_error_title"], string.Format(App.TextStrings["msgbox_net_error_msg"], ex.Message)).ShowDialog();});
			}
			Status = LauncherStatus.Ready;
		}

		private async Task CM_Move_Click(object sender, RoutedEventArgs e)
		{
			if(Status != LauncherStatus.Ready)
			{
				return;
			}
			if(LegacyBoxActive)
			{
				return;
			}
			if(!Directory.Exists(GameInstallPath))
			{
				new DialogWindow(App.TextStrings["msgbox_no_game_dir_title"], App.TextStrings["msgbox_no_game_dir_msg"]).ShowDialog();
				return;
			}
			if(App.LauncherRootPath.Contains($@"{GameInstallPath}\"))
			{
				new DialogWindow(App.TextStrings["msgbox_move_error_title"], App.TextStrings["msgbox_move_4_msg"]).ShowDialog();
				return;
			}

			while(true)
			{
				var dialog = new DialogWindow(App.TextStrings["msgbox_move_title"], App.TextStrings["msgbox_move_1_msg"], DialogWindow.DialogType.Install);
				dialog.InstallPathTextBox.Text = GameInstallPath;
				if(dialog.ShowDialog() == false)
				{
					return;
				}
				string path = dialog.InstallPathTextBox.Text;
				bool is_destination_drive_the_same = Directory.GetDirectoryRoot(GameInstallPath) == Directory.GetDirectoryRoot(path);
				if($@"{path}\".Contains($@"{GameInstallPath}\"))
				{
					new DialogWindow(App.TextStrings["msgbox_move_error_title"], App.TextStrings["msgbox_move_3_msg"]).ShowDialog();
					continue;
				}
				var game_move_to_drive = DriveInfo.GetDrives().Where(x => x.Name == Path.GetPathRoot(path) && x.IsReady).FirstOrDefault();
				if(game_move_to_drive == null)
				{
					new DialogWindow(App.TextStrings["msgbox_move_error_title"], App.TextStrings["msgbox_move_wrong_drive_type_msg"]).ShowDialog();
					continue;
				}
				if(!is_destination_drive_the_same && game_move_to_drive.TotalFreeSpace < new DirectoryInfo(GameInstallPath).EnumerateFiles("*", SearchOption.AllDirectories).Sum(x => x.Length))
				{
					if(new DialogWindow(App.TextStrings["msgbox_move_title"], App.TextStrings["msgbox_move_little_space_msg"], DialogWindow.DialogType.Question).ShowDialog() == false)
					{
						continue;
					}
				}
				try
				{
					path = Directory.CreateDirectory(path).FullName;
					Directory.Delete(path);
				}
				catch(Exception ex)
				{
					new DialogWindow(App.TextStrings["msgbox_install_dir_error_title"], ex.Message).ShowDialog();
					continue;
				}
				if(new DialogWindow(App.TextStrings["msgbox_move_title"], string.Format(App.TextStrings["msgbox_move_2_msg"], path), DialogWindow.DialogType.Question).ShowDialog() == false)
				{
					continue;
				}
				Status = LauncherStatus.Working;
				ProgressText.Text = App.TextStrings["progresstext_moving_files"];
				Log($"Moving game files to: {path}");
				await Task.Run(() =>
				{
					try
					{
						if(is_destination_drive_the_same)
						{
							Directory.Move(GameInstallPath, path);
						}
						else
						{
							Directory.CreateDirectory(path);
							Directory.SetCreationTime(path, Directory.GetCreationTime(GameInstallPath));
							Directory.SetLastWriteTime(path, Directory.GetLastWriteTime(GameInstallPath));
							string[] files = Directory.GetFiles(GameInstallPath);
							foreach(string file in files)
							{
								string name = Path.GetFileName(file);
								string dest = Path.Combine(path, name);
								new FileInfo(file).Attributes &= ~FileAttributes.ReadOnly;
								File.Copy(file, dest, true);
								File.SetCreationTime(dest, File.GetCreationTime(file));
							}
							string[] dirs = Directory.GetDirectories(GameInstallPath, "*", SearchOption.AllDirectories);
							foreach(string dir in dirs)
							{
								string name = dir.Replace(GameInstallPath, string.Empty);
								string dest = $"{path}{name}";
								new DirectoryInfo(dir).Attributes &= ~FileAttributes.ReadOnly;
								Directory.CreateDirectory(dest);
								Directory.SetCreationTime(dest, Directory.GetCreationTime(dir));
								Directory.SetLastWriteTime(dest, Directory.GetLastWriteTime(dir));
								string[] nested_files = Directory.GetFiles(dir);
								foreach(string nested_file in nested_files)
								{
									string nested_name = Path.GetFileName(nested_file);
									string nested_dest = Path.Combine(dest, nested_name);
									new FileInfo(nested_file).Attributes &= ~FileAttributes.ReadOnly;
									File.Copy(nested_file, nested_dest, true);
									File.SetCreationTime(nested_dest, File.GetCreationTime(nested_file));
								}
							}
							try
							{
								new DirectoryInfo(GameInstallPath).Attributes &= ~FileAttributes.ReadOnly;
								Directory.Delete(GameInstallPath, true);
							}
							catch
							{
								Log($"Failed to delete old game directory, you may want to do it manually: {GameInstallPath}", true, 2);
							}
						}
						GameInstallPath = path;
						WriteVersionInfo(false, true);
						Log("Successfully moved game files");
						GameUpdateCheck();
					}
					catch(Exception ex)
					{
						Status = LauncherStatus.Error;
						Log($"Failed to move the game:\n{ex}", true, 1);
						Dispatcher.Invoke(() => {new DialogWindow(App.TextStrings["msgbox_move_error_title"], App.TextStrings["msgbox_generic_error_msg"]).ShowDialog();});
						Status = LauncherStatus.Ready;
					}
				});
				return;
			}
		}

		private async Task CM_Uninstall_Click(object sender, RoutedEventArgs e)
		{
			if((Status != LauncherStatus.Ready || Status != LauncherStatus.UpdateAvailable || Status != LauncherStatus.DownloadPaused) && string.IsNullOrEmpty(GameInstallPath))
			{
				return;
			}
			if(LegacyBoxActive)
			{
				return;
			}

			try
			{
				if(App.LauncherRootPath.Contains(GameInstallPath))
				{
					new DialogWindow(App.TextStrings["msgbox_uninstall_title"], App.TextStrings["msgbox_uninstall_5_msg"]).ShowDialog();
					return;
				}
				var dialog = new DialogWindow(App.TextStrings["msgbox_uninstall_title"], App.TextStrings["msgbox_uninstall_1_msg"], DialogWindow.DialogType.Uninstall);
				if(dialog.ShowDialog() == false)
				{
					return;
				}
				bool delete_game_files = (bool)dialog.UninstallGameFilesCheckBox.IsChecked;
				bool delete_game_cache = (bool)dialog.UninstallGameCacheCheckBox.IsChecked;
				bool delete_game_settings = (bool)dialog.UninstallGameSettingsCheckBox.IsChecked;
				if(!delete_game_files && !delete_game_cache && !delete_game_settings)
				{
					return;
				}
				string delete_list = "\n";
				if(delete_game_files)
				{
					delete_list += $"\n{App.TextStrings["msgbox_uninstall_game_files"]}";
				}
				if(delete_game_cache)
				{
					delete_list += $"\n{App.TextStrings["msgbox_uninstall_game_cache"]}";
				}
				if(delete_game_settings)
				{
					delete_list += $"\n{App.TextStrings["msgbox_uninstall_game_settings"]}";
				}
				if(new DialogWindow(App.TextStrings["msgbox_uninstall_title"], App.TextStrings["msgbox_uninstall_2_msg"] + delete_list, DialogWindow.DialogType.Question).ShowDialog() == false)
				{
					return;
				}
				string msg;
				if(delete_game_files)
				{
					msg = App.TextStrings["msgbox_uninstall_3_msg"] + delete_list;
				}
				else
				{
					msg = App.TextStrings["msgbox_uninstall_4_msg"];
				}
				if(new DialogWindow(App.TextStrings["msgbox_uninstall_title"], msg, DialogWindow.DialogType.Question).ShowDialog() == false)
				{
					return;
				}
				Status = LauncherStatus.Uninstalling;
				await Task.Run(() =>
				{
					if(delete_game_files)
					{
						Log("Deleting game files...");
						ResetVersionInfo(true);
						Log("Sucessfully deleted game files");
					}
					if(delete_game_cache)
					{
						Log("Deleting game cache...");
						if(Directory.Exists(GameCachePath))
						{
							Directory.Delete(GameCachePath, true);
							Log("Successfully deleted game cache");
						}
					}
					if(delete_game_settings)
					{
						Log("Deleting game settings...");
						var key = Registry.CurrentUser.OpenSubKey(GameRegistryPath);
						if(key != null)
						{
							Registry.CurrentUser.DeleteSubKeyTree(GameRegistryPath, true);
							key.Close();
							Log("Successfully deleted game settings");
						}
					}
					Dispatcher.Invoke(() =>
					{
						ProgressText.Text = string.Empty;
						ProgressBar.Visibility = Visibility.Collapsed;
						TaskbarItemInfo.ProgressState = TaskbarItemProgressState.None;
						WindowState = WindowState.Normal;
						new DialogWindow(App.TextStrings["msgbox_uninstall_title"], App.TextStrings["msgbox_uninstall_6_msg"] + delete_list).ShowDialog();
					});
					GameUpdateCheck();
				});
			}
			catch(Exception ex)
			{
				Status = LauncherStatus.Error;
				Log($"Failed to uninstall the game:\n{ex}", true, 1);
				new DialogWindow(App.TextStrings["msgbox_uninstall_error_title"], App.TextStrings["msgbox_uninstall_error_msg"]).ShowDialog();
				Status = LauncherStatus.Ready;
				return;
			}
		}

		private void CM_CustomFPS_Click(object sender, RoutedEventArgs e)
		{
			if(Status != LauncherStatus.Ready)
			{
				return;
			}

			try
			{
				var key = Registry.CurrentUser.OpenSubKey(GameRegistryPath);
				string value = "GENERAL_DATA_V2_PersonalGraphicsSettingV2_h3480068519";
				if(key == null || key.GetValue(value) == null || key.GetValueKind(value) != RegistryValueKind.Binary)
				{
					try
					{
						if(key.GetValue(value) != null)
						{
							key.DeleteValue(value);
						}
					}catch{}
					new DialogWindow(App.TextStrings["msgbox_registry_error_title"], $"{App.TextStrings["msgbox_registry_empty_1_msg"]}\n{App.TextStrings["msgbox_registry_empty_3_msg"]}").ShowDialog();
					return;
				}
				var value_before = key.GetValue(value);
				var json = JsonConvert.DeserializeObject<dynamic>(Encoding.UTF8.GetString((byte[])value_before));
				if(json == null)
				{
					new DialogWindow(App.TextStrings["msgbox_registry_error_title"], $"{App.TextStrings["msgbox_registry_empty_1_msg"]}\n{App.TextStrings["msgbox_registry_empty_3_msg"]}").ShowDialog();
					return;
				}
				key.Close();
				FPSInputBox.Visibility = Visibility.Visible;
				if(json.TargetFrameRateForInLevel != null)
				{
					CombatFPSInputBoxTextBox.Text = json.TargetFrameRateForInLevel;
				}
				else
				{
					CombatFPSInputBoxTextBox.Text = "60";
				}
				if(json.TargetFrameRateForOthers != null)
				{
					MenuFPSInputBoxTextBox.Text = json.TargetFrameRateForOthers;
				}
				else
				{
					MenuFPSInputBoxTextBox.Text = "60";
				}
				GameGraphicSettings = json;
				LegacyBoxActive = true;
			}
			catch(Exception ex)
			{
				Status = LauncherStatus.Error;
				Log($"Failed to access registry:\n{ex}", true, 1);
				new DialogWindow(App.TextStrings["msgbox_registry_error_title"], App.TextStrings["msgbox_registry_error_msg"]).ShowDialog();
				Status = LauncherStatus.Ready;
				return;
			}
		}

		private void CM_CustomResolution_Click(object sender, RoutedEventArgs e)
		{
			if(Status != LauncherStatus.Ready)
			{
				return;
			}

			try
			{
				var key = Registry.CurrentUser.OpenSubKey(GameRegistryPath, true);
				string value = "GENERAL_DATA_V2_ScreenSettingData_h1916288658";
				if(key == null || key.GetValue(value) == null || key.GetValueKind(value) != RegistryValueKind.Binary)
				{
					try
					{
						if(key.GetValue(value) != null)
						{
							key.DeleteValue(value);
						}
					}catch{}
					new DialogWindow(App.TextStrings["msgbox_registry_error_title"], $"{App.TextStrings["msgbox_registry_empty_1_msg"]}\n{App.TextStrings["msgbox_registry_empty_3_msg"]}").ShowDialog();
					return;
				}
				var value_before = key.GetValue(value);
				var json = JsonConvert.DeserializeObject<dynamic>(Encoding.UTF8.GetString((byte[])value_before));
				if(json == null)
				{
					new DialogWindow(App.TextStrings["msgbox_registry_error_title"], $"{App.TextStrings["msgbox_registry_empty_1_msg"]}\n{App.TextStrings["msgbox_registry_empty_3_msg"]}").ShowDialog();
					return;
				}
				key.Close();
				ResolutionInputBox.Visibility = Visibility.Visible;

				if(json.width != null)
				{
					ResolutionInputBoxWidthTextBox.Text = json.width;
				}
				else
				{
					ResolutionInputBoxWidthTextBox.Text = "720";
				}
				if(json.height != null)
				{
					ResolutionInputBoxHeightTextBox.Text = json.height;
				}
				else
				{
					ResolutionInputBoxHeightTextBox.Text = "480";
				}
				if(json.isfullScreen != null)
				{
					ResolutionInputBoxFullscreenCheckbox.IsChecked = json.isfullScreen;
				}
				else
				{
					ResolutionInputBoxFullscreenCheckbox.IsChecked = false;
				}
				GameScreenSettings = json;
				LegacyBoxActive = true;
			}

			catch(Exception ex)
			{
				Status = LauncherStatus.Error;
				Log($"Failed to access registry:\n{ex}", true, 1);
				new DialogWindow(App.TextStrings["msgbox_registry_error_title"], App.TextStrings["msgbox_registry_error_msg"]).ShowDialog();
				Status = LauncherStatus.Ready;
				return;
			}

		}

		private void CM_CustomLaunchOptions_Click(object sender, RoutedEventArgs e)
		{
			if(Status != LauncherStatus.Ready)
			{
				return;
			}

			try
			{
				var dialog = new DialogWindow(App.TextStrings["contextmenu_custom_launch_options"], App.TextStrings["msgbox_custom_launch_options_msg"], DialogWindow.DialogType.CustomLaunchOptions);
				try
				{
					dialog.CustomLaunchOptionsTextBox.Text = LocalVersionInfo.launch_options.ToString().Trim();
				}catch{}
				if(dialog.ShowDialog() == false)
				{
					return;
				}
				string launch_options = dialog.CustomLaunchOptionsTextBox.Text.Trim();
				if(string.IsNullOrEmpty(launch_options))
				{
					LocalVersionInfo.Remove("launch_options");
				}
				else
				{
					LocalVersionInfo.launch_options = launch_options;
				}
				Log("Saving launch options...");
				BpUtility.WriteToRegistry(RegistryVersionInfo, Encoding.UTF8.GetBytes(JsonConvert.SerializeObject(LocalVersionInfo)), RegistryValueKind.Binary);
				Log("success!", false);
			}
			catch(Exception ex)
			{
				Status = LauncherStatus.Error;
				Log($"Failed to access registry:\n{ex}", true, 1);
				new DialogWindow(App.TextStrings["msgbox_registry_error_title"], App.TextStrings["msgbox_registry_error_msg"]).ShowDialog();
				Status = LauncherStatus.Ready;
				return;
			}
		}

		private void CM_ResetDownloadType_Click(object sender, RoutedEventArgs e)
		{
			if(Status != LauncherStatus.Ready)
			{
				return;
			}
			if(new DialogWindow(App.TextStrings["contextmenu_reset_download_type"], App.TextStrings["msgbox_download_type_1_msg"], DialogWindow.DialogType.Question).ShowDialog() == false)
			{
				return;
			}

			try
			{
				var key = Registry.CurrentUser.OpenSubKey(GameRegistryPath, true);
				string[] values = {"GENERAL_DATA_V2_ResourceDownloadType_h2238376574", "GENERAL_DATA_V2_ResourceDownloadVersion_h1528433916"};
				foreach(string value in values)
				{
					if(key == null || key.GetValue(value) == null || key.GetValueKind(value) != RegistryValueKind.DWord)
					{
						try
						{
							if(key.GetValue(value) != null)
							{
								key.DeleteValue(value);
							}
						}catch{}
					}
				}
				var value_before = key.GetValue(values[0]);
				int value_after;
				if((int)value_before != 0)
				{
					value_after = 0;
				}
				else
				{
					new DialogWindow(App.TextStrings["contextmenu_reset_download_type"], App.TextStrings["msgbox_download_type_3_msg"]).ShowDialog();
					return;
				}
				key.SetValue(values[0], value_after, RegistryValueKind.DWord);
				key.Close();
				Log("Download type has been reset");
				new DialogWindow(App.TextStrings["contextmenu_reset_download_type"], App.TextStrings["msgbox_download_type_2_msg"]).ShowDialog();
			}
			catch(Exception ex)
			{
				Status = LauncherStatus.Error;
				Log($"Failed to access registry:\n{ex}", true, 1);
				new DialogWindow(App.TextStrings["msgbox_registry_error_title"], App.TextStrings["msgbox_registry_error_msg"]).ShowDialog();
				Status = LauncherStatus.Ready;
				return;
			}
		}

		private void CM_Changelog_Click(object sender, RoutedEventArgs e)
		{
			if(LegacyBoxActive)
			{
				return;
			}

			LegacyBoxActive = true;
			ChangelogBox.Visibility = Visibility.Visible;
			ChangelogBoxScrollViewer.ScrollToHome();
			FetchChangelog();
		}

		private void CM_CustomBackground_Click(object sender, RoutedEventArgs e)
		{
			if(LegacyBoxActive)
			{
				return;
			}

			bool first_time = App.LauncherRegKey.GetValue("CustomBackgroundName") == null ? true : false;
			if(first_time)
			{
				if(new DialogWindow(App.TextStrings["contextmenu_custom_background"], string.Format(App.TextStrings["msgbox_custom_background_1_msg"], Grid.Width, Grid.Height), DialogWindow.DialogType.Question).ShowDialog() == false)
				{
					return;
				}
			}
			else
			{
				var dialog = new DialogWindow(App.TextStrings["contextmenu_custom_background"], App.TextStrings["msgbox_custom_background_2_msg"], DialogWindow.DialogType.CustomBackground);
				if(dialog.ShowDialog() == false)
				{
					return;
				}
				if((bool)dialog.CustomBackgroundDeleteRadioButton.IsChecked)
				{
					Log("Deleting custom background...");
					BackgroundImage.Source = (BitmapImage)Resources["BackgroundImage"];
					BackgroundImage.Visibility = Visibility.Visible;
					BackgroundMedia.Visibility = Visibility.Collapsed;
					BackgroundMedia.Source = null;
					string custom_background_path = Path.Combine(App.LauncherBackgroundsPath, App.LauncherRegKey.GetValue("CustomBackgroundName").ToString());
					BpUtility.DeleteFromRegistry("CustomBackgroundName");
					if(DeleteFile(custom_background_path))
					{
						Log("success!", false);
					}
					return;
				}
			}

			try
			{
				while(true)
				{
					var dialog = new OpenFileDialog
					{
						InitialDirectory = "::{20D04FE0-3AEA-1069-A2D8-08002B30309D}",
						Filter = "Bitmap Files|*.bmp;*.dib|JPEG|*.jpg;*.jpeg;*.jpe;*.jfif|GIF|*.gif|TIFF|*.tif;*.tiff|PNG|*.png|MPEG|*.mp4;*.m4v;*.mpeg;*.mpg;*.mpv|AVI|*.avi|WMV|*.wmv|FLV|*.flv|All Supported Files|*.bmp;*.dib;*.jpg;*.jpeg;*.jpe;*.jfif;*.gif;*.tif;*.tiff;*.png;*.mp4;*.m4v;*.mpeg;*.mpg;*.mpv;*.avi;*.wmv;*.flv|All Files|*.*",
						FilterIndex = 10
					};
					if(dialog.ShowDialog() == true)
					{
						long file_size = new FileInfo(dialog.FileName).Length;
						int file_size_limit = 52428800;
						var launcher_data_drive = DriveInfo.GetDrives().Where(x => x.Name == Path.GetPathRoot(App.LauncherDataPath) && x.IsReady).FirstOrDefault();
						if(launcher_data_drive == null)
						{
							throw new DriveNotFoundException("Launcher data drive is unavailable");
						}
						if(dialog.FileName.Contains(App.LauncherBackgroundsPath))
						{
							new DialogWindow(App.TextStrings["contextmenu_custom_background"], string.Format(App.TextStrings["msgbox_custom_background_4_msg"], BpUtility.ToBytesCount(file_size_limit))).ShowDialog();
							continue;
						}
						if(file_size > file_size_limit)
						{
							new DialogWindow(App.TextStrings["contextmenu_custom_background"], string.Format(App.TextStrings["msgbox_custom_background_5_msg"], BpUtility.ToBytesCount(file_size_limit))).ShowDialog();
							continue;
						}
						if(launcher_data_drive.TotalFreeSpace < file_size)
						{
							new DialogWindow(App.TextStrings["contextmenu_custom_background"], App.TextStrings["msgbox_custom_background_6_msg"]).ShowDialog();
							continue;
						}
						SetCustomBackgroundFile(dialog.FileName, true);
					}
					break;
				}
			}
			catch(Exception ex)
			{
				Status = LauncherStatus.Error;
				Log($"Failed to set custom background:\n{ex}", true, 1);
				new DialogWindow(App.TextStrings["msgbox_generic_error_title"], App.TextStrings["msgbox_generic_error_msg"]).ShowDialog();
				Status = LauncherStatus.Ready;
			}
		}

		private void CM_ShowLog_Click(object sender, RoutedEventArgs e)
		{
			var item = sender as MenuItem;
			item.IsChecked = !item.IsChecked;
			ToggleLog(item.IsChecked);
		}

		private void CM_Sounds_Click(object sender, RoutedEventArgs e)
		{
			var item = sender as MenuItem;
			if(item.IsChecked)
			{
				Log("Disabled sounds");
			}
			else
			{
				Log("Enabled sounds");
			}
			App.DisableSounds = item.IsChecked;
			item.IsChecked = !item.IsChecked;
			try
			{
				BpUtility.WriteToRegistry("Sounds", item.IsChecked, RegistryValueKind.DWord);
			}
			catch(Exception ex)
			{
				Log($"Failed to write value with key Sounds to registry:\n{ex}", true, 1);
			}
		}

		private void CM_Language_Click(object sender, RoutedEventArgs e)
		{
			var item = sender as MenuItem;
			if(item.IsChecked)
			{
				return;
			}
			if(Status == LauncherStatus.Downloading || Status == LauncherStatus.Verifying || Status == LauncherStatus.Unpacking || Status == LauncherStatus.Uninstalling || Status == LauncherStatus.Working || Status == LauncherStatus.Preloading || Status == LauncherStatus.PreloadVerifying)
			{
				return;
			}

			string lang = item.Header.ToString();
			string msg;
			if(App.LauncherLanguage != "en" && App.LauncherLanguage != "de" && App.LauncherLanguage != "id" && App.LauncherLanguage != "vi")
			{
				if(lang != App.TextStrings["contextmenu_language_portuguese_brazil"] && lang != App.TextStrings["contextmenu_language_portuguese_portugal"])
				{
					lang = lang.ToLower();
				}
				else
				{
					lang = char.ToLower(lang[0]) + lang.Substring(1);
				}
			}
			if(App.LauncherLanguage == "id" || App.LauncherLanguage == "vi")
			{
				lang = char.ToLower(lang[0]) + lang.Substring(1);
			}
			msg = string.Format(App.TextStrings["msgbox_language_msg"], lang);
			lang = item.Header.ToString();
			if(new DialogWindow(App.TextStrings["contextmenu_language"], msg, DialogWindow.DialogType.Question).ShowDialog() == false)
			{
				return;
			}
			if(Status == LauncherStatus.DownloadPaused)
			{
				if(new DialogWindow(App.TextStrings["msgbox_abort_title"], $"{App.TextStrings["msgbox_abort_1_msg"]}\n{App.TextStrings["msgbox_abort_3_msg"]}", DialogWindow.DialogType.Question).ShowDialog() == false)
				{
					return;
				}
				DeleteFile(GameArchiveTempPath);
			}

			try
			{
				if(lang == App.TextStrings["contextmenu_language_system"])
				{
					try{BpUtility.DeleteFromRegistry("Language");}catch{}
				}
				else
				{
					if(lang == App.TextStrings["contextmenu_language_english"])
					{
						App.LauncherLanguage = "en";
					}
					else if(lang == App.TextStrings["contextmenu_language_russian"])
					{
						App.LauncherLanguage = "ru";
					}
					else if(lang == App.TextStrings["contextmenu_language_spanish"])
					{
						App.LauncherLanguage = "es";
					}
					else if(lang == App.TextStrings["contextmenu_language_portuguese_brazil"])
					{
						App.LauncherLanguage = "pt-BR";
					}
					else if(lang == App.TextStrings["contextmenu_language_portuguese_portugal"])
					{
						App.LauncherLanguage = "pt-PT";
					}
					else if(lang == App.TextStrings["contextmenu_language_german"])
					{
						App.LauncherLanguage = "de";
					}
					else if(lang == App.TextStrings["contextmenu_language_vietnamese"])
					{
						App.LauncherLanguage = "vi";
					}
					else if(lang == App.TextStrings["contextmenu_language_serbian"])
					{
						App.LauncherLanguage = "sr";
					}
					else if(lang == App.TextStrings["contextmenu_language_thai"])
					{
						App.LauncherLanguage = "th";
					}
					else if(lang == App.TextStrings["contextmenu_language_french"])
					{
						App.LauncherLanguage = "fr";
					}
					else if(lang == App.TextStrings["contextmenu_language_indonesian"])
					{
						App.LauncherLanguage = "id";
					}
					else if(lang == App.TextStrings["contextmenu_language_italian"])
					{
						App.LauncherLanguage = "it";
					}
					else if(lang == App.TextStrings["contextmenu_language_czech"])
					{
						App.LauncherLanguage = "cs";
					}
					else if(lang == App.TextStrings["contextmenu_language_chinese_simplified"])
					{
						App.LauncherLanguage = "zh-CN";
					}
					else
					{
						Log($"Translation for {lang} does not exist", true, 1);
						return;
					}
					BpUtility.WriteToRegistry("Language", App.LauncherLanguage);
				}
				Log($"Set language to {App.LauncherLanguage}");
				BpUtility.RestartApp();
			}
			catch(Exception ex)
			{
				Status = LauncherStatus.Error;
				Log($"Failed to set language:\n{ex}", true, 1);
				Status = LauncherStatus.Ready;
			}
		}

		private void CM_About_Click(object sender, RoutedEventArgs e)
		{
			if(LegacyBoxActive)
			{
				return;
			}

			LegacyBoxActive = true;
			AboutBox.Visibility = Visibility.Visible;
		}

		private void ServerDropdown_Opened(object sender, EventArgs e)
		{
			BpUtility.PlaySound(Properties.Resources.Click);
		}

		private void ServerDropdown_Changed(object sender, SelectionChangedEventArgs e)
		{
			var index = ServerDropdown.SelectedIndex;
			if((int)Server == index)
			{
				return;
			}
			if(BackgroundImageDownloading || LegacyBoxActive || PreloadDownload)
			{
				ServerDropdown.SelectedIndex = (int)Server;
				return;
			}

			if(DownloadPaused)
			{
				if(new DialogWindow(App.TextStrings["msgbox_notice_title"], App.TextStrings["msgbox_game_download_paused_msg"], DialogWindow.DialogType.Question).ShowDialog() == false)
				{
					ServerDropdown.SelectedIndex = (int)Server;
					return;
				}
				download = null;
				DownloadPaused = false;
				DeleteFile(GameArchiveTempPath);
				if(!PatchDownload)
				{
					ResetVersionInfo();
				}
			}
			switch(index)
			{
				case 0:
					Server = HI3Server.GLB;
					break;
				case 1:
					Server = HI3Server.SEA;
					break;
				case 2:
					Server = HI3Server.CN;
					break;
				case 3:
					Server = HI3Server.TW;
					break;
				case 4:
					Server = HI3Server.KR;
					break;
			}
			if(Server != HI3Server.GLB && Server != HI3Server.SEA && Server != HI3Server.CN)
			{
				MirrorDropdown.SelectedIndex = 0;
				Mirror = HI3Mirror.miHoYo;
			}
			try
			{
				BpUtility.WriteToRegistry("LastSelectedServer", index, RegistryValueKind.DWord);
			}
			catch(Exception ex)
			{
				Log($"Failed to write value with key LastSelectedServer to registry:\n{ex}", true, 1);
			}
			Log($"Switched server to {((ComboBoxItem)ServerDropdown.SelectedItem).Content as string}");
			GameUpdateCheck(true);
		}

		private void MirrorDropdown_Opened(object sender, EventArgs e)
		{
			BpUtility.PlaySound(Properties.Resources.Click);
			if(Server != HI3Server.GLB && Server != HI3Server.SEA && Server != HI3Server.CN)
			{
				new DialogWindow(App.TextStrings["label_mirror"], App.TextStrings["msgbox_feature_not_available_msg"]).ShowDialog();
				return;
			}
		}

		private void MirrorDropdown_Changed(object sender, SelectionChangedEventArgs e)
		{
			var index = MirrorDropdown.SelectedIndex;
			if((int)Mirror == index)
			{
				return;
			}
			if(LegacyBoxActive || PreloadDownload)
			{
				MirrorDropdown.SelectedIndex = (int)Mirror;
				return;
			}
			if(Server != HI3Server.GLB && Server != HI3Server.SEA && (Server == HI3Server.CN && index > 1))
			{
				MirrorDropdown.SelectedIndex = 0;
				new DialogWindow(App.TextStrings["label_mirror"], App.TextStrings["msgbox_feature_not_available_msg"]).ShowDialog();
				return;
			}

			if(DownloadPaused)
			{
				if(new DialogWindow(App.TextStrings["msgbox_notice_title"], App.TextStrings["msgbox_game_download_paused_msg"], DialogWindow.DialogType.Question).ShowDialog() == false)
				{
					MirrorDropdown.SelectedIndex = (int)Mirror;
					return;
				}
				download = null;
				DownloadPaused = false;
				DeleteFile(GameArchiveTempPath);
				if(!PatchDownload)
				{
					ResetVersionInfo();
				}
			}
			else if(Mirror == HI3Mirror.miHoYo && index != 0)
			{
				string msg = App.TextStrings["msgbox_mirror_info_msg"];
				if(index == 1)
				{
					int newline_1 = msg.IndexOf('\n');
					int newline_2 = msg.IndexOf('\n', newline_1 + 1);
					msg = msg.Remove(newline_1 + 1, newline_2 - newline_1);
				}
				if(new DialogWindow(App.TextStrings["msgbox_notice_title"], msg, DialogWindow.DialogType.Question).ShowDialog() == false)
				{
					MirrorDropdown.SelectedIndex = 0;
					return;
				}
			}
			switch(index)
			{
				case 0:
					Mirror = HI3Mirror.miHoYo;
					break;
				case 1:
					Mirror = HI3Mirror.Hi3Mirror;
					break;
			}
			try
			{
				BpUtility.WriteToRegistry("LastSelectedMirror", index, RegistryValueKind.DWord);
			}
			catch(Exception ex)
			{
				Log($"Failed to write value with key LastSelectedMirror to registry:\n{ex}", true, 1);
			}
			GameUpdateCheck();
			Log($"Selected mirror: {((ComboBoxItem)MirrorDropdown.SelectedItem).Content as string}");
		}
		
		private void FPSInputBoxTextBox_PreviewTextInput(object sender, TextCompositionEventArgs e)
		{
			e.Handled = !e.Text.Any(x => char.IsDigit(x));
		}

		// https://stackoverflow.com/q/1268552/7570821
		private void FPSInputBoxTextBox_Pasting(object sender, DataObjectPastingEventArgs e)
		{
			bool IsTextAllowed(string text)
			{
				return Array.TrueForAll(text.ToCharArray(), delegate (char c){return char.IsDigit(c) || char.IsControl(c);});
			}

			if(e.DataObject.GetDataPresent(typeof(string)))
			{
				string text = (string)e.DataObject.GetData(typeof(string));
				if(!IsTextAllowed(text))
				{
					e.CancelCommand();
				}
			}
			else
			{
				e.CancelCommand();
			}
		}

		private void IntroBoxCloseButton_Click(object sender, RoutedEventArgs e)
		{
			LegacyBoxActive = false;
			IntroBox.Visibility = Visibility.Collapsed;
			FetchAnnouncements();
		}

		private async void RepairBoxYesButton_Click(object sender, RoutedEventArgs e)
		{
			try
			{
				async Task Verify()
				{
					var corrupted_files = new List<string>();
					var corrupted_file_hashes = new List<string>();
					long corrupted_files_size = 0;

					Log("Verifying game files...");
					if(App.AdvancedFeatures) Log($"Repair data game version: {OnlineRepairInfo.game_version}");
					await Task.Run(() =>
					{
						for(int i = 0; i < OnlineRepairInfo.files.names.Count; i++)
						{
							string name = OnlineRepairInfo.files.names[i].ToString().Replace("/", "\\");
							string md5 = OnlineRepairInfo.files.hashes[i].ToString().ToUpper();
							long size = OnlineRepairInfo.files.sizes[i];
							string path = Path.Combine(GameInstallPath, name);

							Dispatcher.Invoke(() =>
							{
								ProgressText.Text = string.Format(App.TextStrings["progresstext_verifying_file"], i + 1, OnlineRepairInfo.files.names.Count);
								var progress = (i + 1f) / OnlineRepairInfo.files.names.Count;
								ProgressBar.Value = progress;
								TaskbarItemInfo.ProgressValue = progress;
							});
							if(!File.Exists(path) || BpUtility.CalculateMD5(path) != md5)
							{
								if(File.Exists(path))
								{
									Log($"File corrupted: {name}");
								}
								else
								{
									Log($"File missing: {name}");
								}
								corrupted_files.Add(name);
								corrupted_file_hashes.Add(md5);
								corrupted_files_size += size;
							}
							else
							{
								if(App.AdvancedFeatures) Log($"File OK: {name}");
							}
						}
					});
					ProgressText.Text = string.Empty;
					ProgressBar.Visibility = Visibility.Collapsed;
					ProgressBar.Value = 0;
					TaskbarItemInfo.ProgressState = TaskbarItemProgressState.None;
					TaskbarItemInfo.ProgressValue = 0;
					WindowState = WindowState.Normal;
					if(corrupted_files.Count > 0)
					{
						Log($"Finished verifying files, found corrupted/missing files: {corrupted_files.Count}");
						if(new DialogWindow(App.TextStrings["contextmenu_repair"], string.Format(App.TextStrings["msgbox_repair_3_msg"], corrupted_files.Count, BpUtility.ToBytesCount(corrupted_files_size)), DialogWindow.DialogType.Question).ShowDialog() == true)
						{
							string[] urls = OnlineRepairInfo.zip_urls.ToObject<string[]>();
							int repaired_files = 0;
							bool abort = false;

							Status = LauncherStatus.Downloading;
							await Task.Run(async () =>
							{
								if(urls.Length == 0)
								{
									throw new InvalidOperationException("No download URLs are present in repair data.");
								}
								for(int i = 0; i < corrupted_files.Count; i++)
								{
									string path = Path.Combine(GameInstallPath, corrupted_files[i]);

									Dispatcher.Invoke(() =>
									{
										ProgressText.Text = string.Format(App.TextStrings["progresstext_downloading_file"], i + 1, corrupted_files.Count);
										var progress = (i + 1f) / corrupted_files.Count;
										ProgressBar.Value = progress;
										TaskbarItemInfo.ProgressValue = progress;
									});
									for(int j = 0; j < urls.Length; j++)
									{
										string url = null;

										try
										{
											if(string.IsNullOrEmpty(urls[j]))
											{
												throw new NullReferenceException($"Download URL with index {j} is empty.");
											}
											else if(urls[j].Contains("www.mediafire.com"))
											{
												var metadata = FetchMediaFireFileMetadata(urls[j].Substring(31, 15));
												url = metadata.downloadUrl.ToString();
											}
											else
											{
												url = urls[j];
											}

											Directory.CreateDirectory(Path.GetDirectoryName(path));
											await PartialZipDownloader.DownloadFile(url, corrupted_files[i], path);
											Dispatcher.Invoke(() => {ProgressText.Text = string.Format(App.TextStrings["progresstext_verifying_file"], i + 1, corrupted_files.Count);});
											if(!File.Exists(path) || BpUtility.CalculateMD5(path) != corrupted_file_hashes[i])
											{
												Log($"Failed to repair file {corrupted_files[i]}", true, 1);
											}
											else
											{
												Log($"Repaired file {corrupted_files[i]}");
												repaired_files++;
											}
										}
										catch(Exception ex)
										{
											if(j == urls.Length - 1)
											{
												Status = LauncherStatus.Error;
												Log($"Failed to download file [{corrupted_files[i]}] ({url}): {ex.Message}\nNo more mirrors available!", true, 1);
												Dispatcher.Invoke(() =>
												{
													new DialogWindow(App.TextStrings["msgbox_generic_error_title"], App.TextStrings["msgbox_generic_error_msg"]).ShowDialog();
													LaunchButton.Content = App.TextStrings["button_launch"];
												});
												Status = LauncherStatus.Ready;
												abort = true;
												return;
											}
											else
											{
												Log($"Failed to download file [{corrupted_files[i]}] ({url}): {ex.Message}\nAttempting to download from another mirror...", true, 2);
											}
										}
									}
								}
							});
							Dispatcher.Invoke(() =>
							{
								LaunchButton.Content = App.TextStrings["button_launch"];
								ProgressText.Text = string.Empty;
								ProgressBar.Visibility = Visibility.Collapsed;
								TaskbarItemInfo.ProgressState = TaskbarItemProgressState.None;
							});
							if(!abort)
							{
								if(repaired_files == corrupted_files.Count)
								{
									Log($"Successfully repaired {repaired_files} file(s)");
									Dispatcher.Invoke(() =>
									{
										new DialogWindow(App.TextStrings["contextmenu_repair"], string.Format(App.TextStrings["msgbox_repair_4_msg"], repaired_files)).ShowDialog();
									});
								}
								else
								{
									int skipped_files = corrupted_files.Count - repaired_files;
									if(repaired_files > 0)
									{
										Log($"Successfully repaired {repaired_files} files, failed to repair {skipped_files} files");
									}
									Dispatcher.Invoke(() =>
									{
										new DialogWindow(App.TextStrings["contextmenu_repair"], string.Format(App.TextStrings["msgbox_repair_5_msg"], skipped_files)).ShowDialog();
									});
								}
							}
						}
					}
					else
					{
						Log("Finished verifying files, no files need repair");
						Dispatcher.Invoke(() =>
						{
							ProgressText.Text = string.Empty;
							ProgressBar.Visibility = Visibility.Collapsed;
							TaskbarItemInfo.ProgressState = TaskbarItemProgressState.None;
						});
						new DialogWindow(App.TextStrings["contextmenu_repair"], App.TextStrings["msgbox_repair_2_msg"]).ShowDialog();
					}
					Status = LauncherStatus.Ready;
				}

				if(OnlineRepairInfo.game_version != LocalVersionInfo.game_info.version)
				{
					if(App.AdvancedFeatures)
					{
						if(new DialogWindow(App.TextStrings["contextmenu_repair"], App.TextStrings["msgbox_repair_8_msg"], DialogWindow.DialogType.Question).ShowDialog() == false)
						{
							return;
						}
					}
				}
				LegacyBoxActive = false;
				RepairBox.Visibility = Visibility.Collapsed;
				Status = LauncherStatus.Working;
				OptionsButton.IsEnabled = true;
				ProgressText.Text = App.TextStrings["progresstext_fetching_hashes"];
				ProgressBar.IsIndeterminate = false;
				TaskbarItemInfo.ProgressState = TaskbarItemProgressState.Normal;
				await Verify();
			}
			catch(Exception ex)
			{
				LaunchButton.Content = App.TextStrings["button_launch"];
				Status = LauncherStatus.Error;
				Log($"{ex}", true, 1);
				new DialogWindow(App.TextStrings["msgbox_generic_error_title"], App.TextStrings["msgbox_generic_error_msg"]).ShowDialog();
				Status = LauncherStatus.Ready;
			}
		}

		private async void RepairBoxGenerateButton_Click(object sender, RoutedEventArgs e)
		{
			async Task Generate()
			{
				string server = null;
				if(Server == HI3Server.GLB)
				{
					server = "global";
				}
				else if(Server == HI3Server.SEA)
				{
					server = "os";
				}
				var dialog = new SaveFileDialog
				{
					InitialDirectory = App.LauncherRootPath,
					Filter = "JSON|*.json",
					FileName = $"bh3_files_{server}_{LocalVersionInfo.game_info.version}.json"
				};
				if(dialog.ShowDialog() == true)
				{
					try
					{
						Status = LauncherStatus.Working;
						OptionsButton.Visibility = Visibility.Visible;
						ProgressBar.IsIndeterminate = false;
						TaskbarItemInfo.ProgressState = TaskbarItemProgressState.Normal;
						Log("Generating game file hashes...");
						var files = new DirectoryInfo(GameInstallPath).GetFiles("*", SearchOption.AllDirectories).Where(x =>
						!x.Attributes.HasFlag(FileAttributes.Hidden) &&
						x.Extension != ".log" &&
						x.Extension != ".bat" &&
						x.Extension != ".zip" &&
						x.Name != "blockVerifiedVersion.txt" &&
						x.Name != "config.ini" &&
						x.Name != "manifest.m" &&
						x.Name != "pkg_version" &&
						x.Name != "ThirdPartyNotices.txt" &&
						x.Name != "UniFairy.sys" &&
						x.Name != "Version.txt" &&
						!x.Name.Contains("Blocks_") &&
						!x.Name.Contains("AUDIO_Avatar") &&
						!x.Name.Contains("AUDIO_BGM") &&
						!x.Name.Contains("AUDIO_Dialog") &&
						!x.Name.Contains("AUDIO_DLC") &&
						!x.Name.Contains("AUDIO_EVENT") &&
						!x.Name.Contains("AUDIO_Ex") &&
						!x.Name.Contains("AUDIO_HOT_FIX") &&
						!x.Name.Contains("AUDIO_Main") &&
						!x.Name.Contains("AUDIO_Story") &&
						!x.Name.Contains("AUDIO_Vanilla") &&
						!x.DirectoryName.Contains("ThirdPartyNotice") &&
						!x.DirectoryName.Contains("Video") &&
						!x.DirectoryName.Contains("webCaches")
						).ToList();
						dynamic json = new ExpandoObject();
						json.repair_info = new ExpandoObject();
						json.repair_info.game_version = miHoYoVersionInfo.game.latest.version;
						json.repair_info.mirrors = string.Empty;
						json.repair_info.zip_urls = Array.Empty<string>();
						json.repair_info.files = new ExpandoObject();
						json.repair_info.files.names = new dynamic[files.Count];
						json.repair_info.files.hashes = new dynamic[files.Count];
						json.repair_info.files.sizes = new dynamic[files.Count];
						await Task.Run(() =>
						{
							for(int i = 0; i < files.Count; i++)
							{
								json.repair_info.files.names[i] = files[i].FullName.Replace($"{GameInstallPath}\\", string.Empty).Replace("\\", "/");
								json.repair_info.files.hashes[i] = BpUtility.CalculateMD5(files[i].FullName);
								json.repair_info.files.sizes[i] = files[i].Length;
								Dispatcher.Invoke(() =>
								{
									ProgressText.Text = string.Format(App.TextStrings["progresstext_generating_hash"], i + 1, files.Count);
									var progress = (i + 1f) / files.Count;
									ProgressBar.Value = progress;
									TaskbarItemInfo.ProgressValue = progress;
								});
							}
							File.WriteAllText(dialog.FileName, JsonConvert.SerializeObject(json));
							Log("success!", false);
							Log($"Saved JSON: {dialog.FileName}");
						});
						ProgressText.Text = string.Empty;
						ProgressBar.Visibility = Visibility.Collapsed;
						TaskbarItemInfo.ProgressState = TaskbarItemProgressState.None;
						if(new DialogWindow(App.TextStrings["contextmenu_repair"], App.TextStrings["msgbox_repair_7_msg"], DialogWindow.DialogType.Question).ShowDialog() == true)
						{
							ProgressBar.Visibility = Visibility.Visible;
							await Task.Run(() =>
							{
								Log("Creating ZIP file...");
								var zip_name = dialog.FileName.Replace(".json", ".zip");
								DeleteFile(zip_name);
								using(var archive = ZipFile.Open(zip_name, ZipArchiveMode.Create))
								{
									for(int i = 0; i < files.Count; i++)
									{
										archive.CreateEntryFromFile(files[i].FullName, files[i].FullName.Replace($"{GameInstallPath}\\", string.Empty));
										Dispatcher.Invoke(() =>
										{
											ProgressText.Text = string.Format(App.TextStrings["progresstext_zipping"], i + 1, files.Count);
											var progress = (i + 1f) / files.Count;
											ProgressBar.Value = progress;
											TaskbarItemInfo.ProgressValue = progress;
										});
									}
								}
								Log("success!", false);
								Log($"Saved ZIP: {zip_name}");
							});
						}
						Status = LauncherStatus.Ready;
					}
					catch(Exception ex)
					{
						Status = LauncherStatus.Error;
						Log($"{ex}", true, 1);
						Status = LauncherStatus.Ready;
					}
				}
			}

			if(new DialogWindow(App.TextStrings["contextmenu_repair"], App.TextStrings["msgbox_repair_6_msg"], DialogWindow.DialogType.Question).ShowDialog() == false)
			{
				return;
			}
			LegacyBoxActive = false;
			RepairBox.Visibility = Visibility.Collapsed;
			await Generate();
		}

		private void RepairBoxCloseButton_Click(object sender, RoutedEventArgs e)
		{
			LegacyBoxActive = false;
			RepairBox.Visibility = Visibility.Collapsed;
		}

		private void FPSInputBoxOKButton_Click(object sender, RoutedEventArgs e)
		{
			try
			{
				CombatFPSInputBoxTextBox.Text = string.Concat(CombatFPSInputBoxTextBox.Text.Where(c => !char.IsWhiteSpace(c)));
				MenuFPSInputBoxTextBox.Text = string.Concat(MenuFPSInputBoxTextBox.Text.Where(c => !char.IsWhiteSpace(c)));
				if(string.IsNullOrEmpty(CombatFPSInputBoxTextBox.Text) || string.IsNullOrEmpty(MenuFPSInputBoxTextBox.Text))
				{
					new DialogWindow(App.TextStrings["contextmenu_custom_fps"], App.TextStrings["msgbox_custom_fps_1_msg"]).ShowDialog();
					return;
				}
				int fps_combat = int.Parse(CombatFPSInputBoxTextBox.Text);
				int fps_menu = int.Parse(MenuFPSInputBoxTextBox.Text);
				if(fps_combat < 1 || fps_menu < 1)
				{
					new DialogWindow(App.TextStrings["contextmenu_custom_fps"], App.TextStrings["msgbox_custom_fps_2_msg"]).ShowDialog();
					return;
				}
				if(fps_combat < 30 || fps_menu < 30)
				{
					if(new DialogWindow(App.TextStrings["contextmenu_custom_fps"], App.TextStrings["msgbox_custom_fps_3_msg"], DialogWindow.DialogType.Question).ShowDialog() == false)
					{
						return;
					}
				}
				Log($"Setting in-game FPS to {fps_combat}, menu FPS to {fps_menu}...");
				GameGraphicSettings.TargetFrameRateForInLevel = fps_combat;
				GameGraphicSettings.TargetFrameRateForOthers = fps_menu;
				var value_after = Encoding.UTF8.GetBytes($"{JsonConvert.SerializeObject(GameGraphicSettings)}\0");
				var key = Registry.CurrentUser.OpenSubKey(GameRegistryPath, true);
				key.SetValue("GENERAL_DATA_V2_PersonalGraphicsSettingV2_h3480068519", value_after, RegistryValueKind.Binary);
				key.Close();
				FPSInputBox.Visibility = Visibility.Collapsed;
				LegacyBoxActive = false;
				Log("success!", false);
				new DialogWindow(App.TextStrings["contextmenu_custom_fps"], string.Format(App.TextStrings["msgbox_custom_fps_4_msg"], fps_combat, fps_menu)).ShowDialog();
			}
			catch(Exception ex)
			{
				Status = LauncherStatus.Error;
				Log($"{ex}", true, 1);
				new DialogWindow(App.TextStrings["msgbox_generic_error_title"], App.TextStrings["msgbox_generic_error_msg"]).ShowDialog();
				Status = LauncherStatus.Ready;
				return;
			}
		}

		private void FPSInputBoxCancelButton_Click(object sender, RoutedEventArgs e)
		{
			FPSInputBox.Visibility = Visibility.Collapsed;
			LegacyBoxActive = false;
		}

		private void ResolutionInputBoxOKButton_Click(object sender, RoutedEventArgs e)
		{
			try
			{
				ResolutionInputBoxHeightTextBox.Text = string.Concat(ResolutionInputBoxHeightTextBox.Text.Where(c => !char.IsWhiteSpace(c)));
				ResolutionInputBoxWidthTextBox.Text = string.Concat(ResolutionInputBoxWidthTextBox.Text.Where(c => !char.IsWhiteSpace(c)));
				if(string.IsNullOrEmpty(ResolutionInputBoxHeightTextBox.Text) || string.IsNullOrEmpty(ResolutionInputBoxWidthTextBox.Text))
				{
					new DialogWindow(App.TextStrings["contextmenu_custom_resolution"], App.TextStrings["msgbox_custom_fps_1_msg"]).ShowDialog();
					return;
				}
				bool fullscreen = (bool)ResolutionInputBoxFullscreenCheckbox.IsChecked;
				int height = int.Parse(ResolutionInputBoxHeightTextBox.Text);
				int width = int.Parse(ResolutionInputBoxWidthTextBox.Text);
				if(height < 1 || width < 1)
				{
					new DialogWindow(App.TextStrings["contextmenu_custom_resolution"], App.TextStrings["msgbox_custom_fps_2_msg"]).ShowDialog();
					return;
				}
				if(height > width)
				{
					if(new DialogWindow(App.TextStrings["contextmenu_custom_resolution"], App.TextStrings["msgbox_custom_resolution_1_msg"], DialogWindow.DialogType.Question).ShowDialog() == false)
					{
						return;
					}
				}
				string is_fullscreen = fullscreen ? "enabled" : "disabled";
				is_fullscreen = fullscreen ? App.TextStrings["enabled"].ToLower() : App.TextStrings["disabled"].ToLower();
				Log($"Setting game resolution to {width}x{height}, fullscreen {is_fullscreen}...");
				GameScreenSettings.height = height;
				GameScreenSettings.width = width;
				GameScreenSettings.isfullScreen = fullscreen;
				var value_after = Encoding.UTF8.GetBytes($"{JsonConvert.SerializeObject(GameScreenSettings)}\0");
				var key = Registry.CurrentUser.OpenSubKey(GameRegistryPath, true);
				key.SetValue("GENERAL_DATA_V2_ScreenSettingData_h1916288658", value_after, RegistryValueKind.Binary);
				string sm_fullscreen = "Screenmanager Is Fullscreen mode_h3981298716";
				string sm_res_width = "Screenmanager Resolution Width_h182942802";
				string sm_res_height = "Screenmanager Resolution Height_h2627697771";
				if(key.GetValue(sm_fullscreen) != null)
				{
					key.SetValue(sm_fullscreen, fullscreen, RegistryValueKind.DWord);
				}
				if(key.GetValue(sm_res_width) != null)
				{
					key.SetValue(sm_res_width, width, RegistryValueKind.DWord);
				}
				if(key.GetValue(sm_res_height) != null)
				{
					key.SetValue(sm_res_height, height, RegistryValueKind.DWord);
				}
				key.Close();
				ResolutionInputBox.Visibility = Visibility.Collapsed;
				LegacyBoxActive = false;
				Log("success!", false);
				new DialogWindow(App.TextStrings["contextmenu_custom_resolution"], string.Format(App.TextStrings["msgbox_custom_resolution_2_msg"], width, height, is_fullscreen)).ShowDialog();
			}
			catch(Exception ex)
			{
				Status = LauncherStatus.Error;
				Log($"{ex}", true, 1);
				new DialogWindow(App.TextStrings["msgbox_generic_error_title"], App.TextStrings["msgbox_generic_error_msg"]).ShowDialog();
				Status = LauncherStatus.Ready;
				return;
			}
		}

		private void ResolutionInputBoxCancelButton_Click(object sender, RoutedEventArgs e)
		{
			ResolutionInputBox.Visibility = Visibility.Collapsed;
			LegacyBoxActive = false;
		}

		private void ChangelogBoxCloseButton_Click(object sender, RoutedEventArgs e)
		{
			LegacyBoxActive = false;
			ChangelogBox.Visibility = Visibility.Collapsed;
			ChangelogBoxMessageTextBlock.Visibility = Visibility.Collapsed;
		}

		private void AboutBoxGitHubButton_Click(object sender, RoutedEventArgs e)
		{
			AboutBox.Visibility = Visibility.Collapsed;
			BpUtility.StartProcess("https://github.com/BuIlDaLiBlE/BetterHI3Launcher", null, App.LauncherRootPath, true);
		}

		private void AboutBoxCloseButton_Click(object sender, RoutedEventArgs e)
		{
			LegacyBoxActive = false;
			AboutBox.Visibility = Visibility.Collapsed;
		}

		private void AnnouncementBoxCloseButton_Click(object sender, RoutedEventArgs e)
		{
			LegacyBoxActive = false;
			AnnouncementBox.Visibility = Visibility.Collapsed;
			bool do_not_show_next_time = (bool)AnnouncementBoxDoNotShowCheckbox.IsChecked;
			if(do_not_show_next_time)
			{
				try
				{
					App.SeenAnnouncements.Add(App.Announcements.First["id"].ToString());
					BpUtility.WriteToRegistry("SeenAnnouncements", string.Join(",", App.SeenAnnouncements), RegistryValueKind.String);
				}
				catch(Exception ex)
				{
					Log($"Failed to write value with key SeenAnnouncements to registry:\n{ex}", true, 1);
				}
			}
			AnnouncementBoxDoNotShowCheckbox.IsChecked = false;
			App.Announcements.Remove(App.Announcements.First);
			if(App.Announcements.Count > 0)
			{
				ShowAnnouncement(App.Announcements.First);
			}
			else
			{
				LauncherLocalVersionCheck();
			}
		}

		private void DownloadCacheCommand_Executed(object sender, ExecutedRoutedEventArgs e)
		{
			var item = BpUtility.GetMenuItem(OptionsContextMenu.Items, App.TextStrings["contextmenu_download_cache"]);
			if(item.IsEnabled && !LegacyBoxActive)
			{
				var peer = new MenuItemAutomationPeer(item);
				var inv_prov = peer.GetPattern(PatternInterface.Invoke) as IInvokeProvider;
				inv_prov.Invoke();
			}
		}


		private void RepairGameCommand_Executed(object sender, ExecutedRoutedEventArgs e)
		{
			var item = BpUtility.GetMenuItem(OptionsContextMenu.Items, App.TextStrings["contextmenu_repair"]);
			if(item.IsEnabled && !LegacyBoxActive)
			{
				var peer = new MenuItemAutomationPeer(item);
				var inv_prov = peer.GetPattern(PatternInterface.Invoke) as IInvokeProvider;
				inv_prov.Invoke();
			}
		}

		private void MoveGameCommand_Executed(object sender, ExecutedRoutedEventArgs e)
		{
			var item = BpUtility.GetMenuItem(OptionsContextMenu.Items, App.TextStrings["contextmenu_move"]);
			if(item.IsEnabled)
			{
				var peer = new MenuItemAutomationPeer(item);
				var inv_prov = peer.GetPattern(PatternInterface.Invoke) as IInvokeProvider;
				inv_prov.Invoke();
			}
		}

		private void UninstallGameCommand_Executed(object sender, ExecutedRoutedEventArgs e)
		{
			var item = BpUtility.GetMenuItem(OptionsContextMenu.Items, App.TextStrings["contextmenu_uninstall"]);
			if(item.IsEnabled)
			{
				var peer = new MenuItemAutomationPeer(item);
				var inv_prov = peer.GetPattern(PatternInterface.Invoke) as IInvokeProvider;
				inv_prov.Invoke();
			}
		}

		private void WebProfileCommand_Executed(object sender, ExecutedRoutedEventArgs e)
		{
			var item = BpUtility.GetMenuItem(OptionsContextMenu.Items, App.TextStrings["contextmenu_web_profile"]);
			if(item.IsEnabled)
			{
				var peer = new MenuItemAutomationPeer(item);
				var inv_prov = peer.GetPattern(PatternInterface.Invoke) as IInvokeProvider;
				inv_prov.Invoke();
			}
		}

		private void FeedbackCommand_Executed(object sender, ExecutedRoutedEventArgs e)
		{
			var item = BpUtility.GetMenuItem(OptionsContextMenu.Items, App.TextStrings["contextmenu_feedback"]);
			if(item.IsEnabled)
			{
				var peer = new MenuItemAutomationPeer(item);
				var inv_prov = peer.GetPattern(PatternInterface.Invoke) as IInvokeProvider;
				inv_prov.Invoke();
			}
		}

		private void ChangelogCommand_Executed(object sender, ExecutedRoutedEventArgs e)
		{
			var item = BpUtility.GetMenuItem(OptionsContextMenu.Items, App.TextStrings["contextmenu_changelog"]);
			if(item.IsEnabled && !LegacyBoxActive)
			{
				var peer = new MenuItemAutomationPeer(item);
				var inv_prov = peer.GetPattern(PatternInterface.Invoke) as IInvokeProvider;
				inv_prov.Invoke();
			}
		}

		private void CustomBackgroundCommand_Executed(object sender, ExecutedRoutedEventArgs e)
		{
			var item = BpUtility.GetMenuItem(OptionsContextMenu.Items, App.TextStrings["contextmenu_custom_background"]);
			if(item.IsEnabled)
			{
				var peer = new MenuItemAutomationPeer(item);
				var inv_prov = peer.GetPattern(PatternInterface.Invoke) as IInvokeProvider;
				inv_prov.Invoke();
			}
		}

		private void ToggleLogCommand_Executed(object sender, ExecutedRoutedEventArgs e)
		{
			var item = BpUtility.GetMenuItem(OptionsContextMenu.Items, App.TextStrings["contextmenu_show_log"]);
			if(item.IsEnabled)
			{
				var peer = new MenuItemAutomationPeer(item);
				var inv_prov = peer.GetPattern(PatternInterface.Invoke) as IInvokeProvider;
				inv_prov.Invoke();
			}
		}

		private void ToggleSoundsCommand_Executed(object sender, ExecutedRoutedEventArgs e)
		{
			var item = BpUtility.GetMenuItem(OptionsContextMenu.Items, App.TextStrings["contextmenu_sounds"]);
			if(item.IsEnabled)
			{
				var peer = new MenuItemAutomationPeer(item);
				var inv_prov = peer.GetPattern(PatternInterface.Invoke) as IInvokeProvider;
				inv_prov.Invoke();
			}
		}

		private void AboutCommand_Executed(object sender, ExecutedRoutedEventArgs e)
		{
			var item = BpUtility.GetMenuItem(OptionsContextMenu.Items, App.TextStrings["contextmenu_about"]);
			if(item.IsEnabled && !LegacyBoxActive)
			{
				var peer = new MenuItemAutomationPeer(item);
				var inv_prov = peer.GetPattern(PatternInterface.Invoke) as IInvokeProvider;
				inv_prov.Invoke();
			}
		}

		private void MainWindow_Closing(object sender, CancelEventArgs e)
		{
			if(Status == LauncherStatus.Downloading || Status == LauncherStatus.DownloadPaused || Status == LauncherStatus.Preloading)
			{
				if(download == null && httpclient == null || httpclient.SessionState == MultisessionState.Idle)
				{
					if(new DialogWindow(App.TextStrings["msgbox_abort_title"], $"{App.TextStrings["msgbox_abort_1_msg"]}\n{App.TextStrings["msgbox_abort_3_msg"]}", DialogWindow.DialogType.Question).ShowDialog() == false)
					{
						e.Cancel = true;
					}
				}
				else
				{
					if(httpclient != null && httpclient.SessionState == MultisessionState.Merging)
					{
						e.Cancel = true;
						return;
					}
					if(new DialogWindow(App.TextStrings["msgbox_abort_title"], $"{App.TextStrings["msgbox_abort_1_msg"]}\n{App.TextStrings["msgbox_abort_4_msg"]}", DialogWindow.DialogType.Question).ShowDialog() == true)
					{
						if(download != null)
						{	
							download.Pause();
						}
						else if(httpclient != null && httpclient.SessionState == MultisessionState.Downloading || httpclient.SessionState == MultisessionState.CancelledDownloading)
						{
							try
							{
								token.Cancel();
							}catch(OperationCanceledException){}
						}
						else
						{
							e.Cancel = true;
						}
						if(Status != LauncherStatus.Preloading)
						{
							WriteVersionInfo();
						}
					}
					else
					{
						e.Cancel = true;
					}
				}
			}
			else if(Status == LauncherStatus.Verifying || Status == LauncherStatus.Unpacking || Status == LauncherStatus.Uninstalling || Status == LauncherStatus.Working || Status == LauncherStatus.PreloadVerifying)
			{
				e.Cancel = true;
			}
		}

		private void OnGameExit()
		{
			Dispatcher.Invoke(() =>
			{
				LaunchButton.Content = App.TextStrings["button_launch"];
				if(!PreloadDownload)
				{
					Status = LauncherStatus.Ready;
				}
			});
		}

		private string CheckForExistingGameDirectory(string path)
		{
			if(string.IsNullOrEmpty(path))
			{
				return string.Empty;
			}

			var path_variants = new List<string>(new string[]
			{
				path.Replace(@"\BH3_Data", string.Empty),
				Path.Combine(path, "Games"),
				Path.Combine(path, "Honkai Impact 3rd"),
				Path.Combine(path, "Honkai Impact 3"),
				Path.Combine(path, "崩坏3"),
				Path.Combine(path, "崩壊3rd"),
				Path.Combine(path, "붕괴3rd"),
				Path.Combine(path, "Honkai Impact 3rd", "Games"),
				Path.Combine(path, "Honkai Impact 3", "Games"),
				Path.Combine(path, "Honkai Impact 3rd glb", "Games"),
				Path.Combine(path, "Honkai Impact 3 sea", "Games"),
				Path.Combine(path, "Honkai Impact 3rd tw", "Games"),
				Path.Combine(path, "Honkai Impact 3rd kr", "Games")
			});

			foreach(var variant in path_variants)
			{
				if(string.IsNullOrEmpty(variant))
				{
					continue;
				}

				if(File.Exists(Path.Combine(variant, GameExeName)))
				{
					return variant;
				}
			}
			return string.Empty;
		}

		private int CheckForExistingGameClientServer(string path)
		{
			path = Path.Combine(path, @"BH3_Data\app.info");
			if(File.Exists(path))
			{
				var game_title_line = File.ReadLines(path).Skip(1).Take(1).First();
				if(!string.IsNullOrEmpty(game_title_line))
				{
					switch(game_title_line)
					{
						case "Honkai Impact 3rd":
							if(App.LauncherRegKey.GetValue("VersionInfoGlobal") == null)
							{
								return 0;
							}
							break;
						case "Honkai Impact 3":
							if(App.LauncherRegKey.GetValue("VersionInfoSEA") == null)
							{
								return 1;
							}
							break;
						case "崩坏3":
							if(App.LauncherRegKey.GetValue("VersionInfoCN") == null)
							{
								return 2;
							}
							break;
						case "崩壊3rd":
							if(App.LauncherRegKey.GetValue("VersionInfoTW") == null)
							{
								return 3;
							}
							break;
						case "붕괴3rd":
							if(App.LauncherRegKey.GetValue("VersionInfoKR") == null)
							{
								return 4;
							}
							break;
					}
				}
			}
			return -1;
		}

		private void ToggleContextMenuItems(bool val, bool leave_uninstall_enabled = false)
		{
			foreach(dynamic item in OptionsContextMenu.Items)
			{
				if(item.GetType() == typeof(MenuItem))
				{
					if(item.Header.ToString() == App.TextStrings["contextmenu_web_profile"] ||
					   item.Header.ToString() == App.TextStrings["contextmenu_feedback"] ||
					   item.Header.ToString() == App.TextStrings["contextmenu_changelog"] ||
					   item.Header.ToString() == App.TextStrings["contextmenu_language"] ||
					   item.Header.ToString() == App.TextStrings["contextmenu_custom_background"] ||
					   item.Header.ToString() == App.TextStrings["contextmenu_show_log"] ||
					   item.Header.ToString() == App.TextStrings["contextmenu_sounds"] ||
					   item.Header.ToString() == App.TextStrings["contextmenu_about"])
					{
						continue;
					}
				}
				if(!val && leave_uninstall_enabled)
				{
					if(item.GetType() == typeof(MenuItem) && item.Header.ToString() == App.TextStrings["contextmenu_uninstall"])
					{
						continue;
					}
				}
					
				item.IsEnabled = val;
			}
		}

		private void ToggleLog(bool val)
		{
			LogBox.Visibility = val ? Visibility.Visible : Visibility.Collapsed;
			BpUtility.GetMenuItem(OptionsContextMenu.Items, App.TextStrings["contextmenu_show_log"]).IsChecked = val;
			try
			{
				BpUtility.WriteToRegistry("ShowLog", val ? 1 : 0, RegistryValueKind.DWord);
			}
			catch(Exception ex)
			{
				Log($"Failed to write value with key ShowLog to registry:\n{ex}", true, 1);
			}
		}

		private Tuple<string, int, bool> GetCustomBackgroundFileInfo(string path)
		{
			string name = Path.GetFileName(path);
			int format = 0;
			bool is_recommended_resolution = false;
			bool check_media = false;
			if(!string.IsNullOrEmpty(path) && Path.HasExtension(path))
			{
				try
				{
					var image = new BitmapImage();
					using(FileStream fs = new FileStream(path, FileMode.Open))
					{
						image.BeginInit();
						image.StreamSource = fs;
						image.CacheOption = BitmapCacheOption.OnLoad;
						image.EndInit();
					}
					if(Path.GetExtension(path) != ".gif")
					{
						format = 1;
					}
					else
					{
						format = 2;
					}
					if(image.Width == Grid.Width && image.Height == Grid.Height)
					{
						is_recommended_resolution = true;
					}
				}
				catch
				{
					check_media = true;
				}
				if(check_media)
				{
					try
					{
						int timeout = 3000;
						var old_source = BackgroundMedia.Source;
						BackgroundMedia.Source = new Uri(path);
						while(timeout > 0)
						{
							if(BackgroundMedia.NaturalDuration.HasTimeSpan && BackgroundMedia.NaturalDuration.TimeSpan.TotalMilliseconds > 0)
							{
								if(BackgroundMedia.HasVideo)
								{
									format = 3;
									if(BackgroundMedia.NaturalVideoWidth == Grid.Width && BackgroundMedia.NaturalVideoHeight == Grid.Height)
									{
										is_recommended_resolution = true;
									}
								}
								break;
							}
							timeout -= 100;
							Thread.Sleep(100);
						}
						BackgroundMedia.Source = old_source;
					}catch{}
				}
			}
			else
			{
				format = -1;
			}
			return Tuple.Create(name, format, is_recommended_resolution);
		}

		private void SetCustomBackgroundFile(string path, bool new_file = false)
		{
			try
			{
				var file_info = GetCustomBackgroundFileInfo(path);
				string name = file_info.Item1;
				int format = file_info.Item2;
				bool is_recommended_resolution = file_info.Item3;
				if(format > 0)
				{
					if(new_file)
					{
						if(!is_recommended_resolution)
						{
							if(new DialogWindow(App.TextStrings["contextmenu_custom_background"], App.TextStrings["msgbox_custom_background_3_msg"], DialogWindow.DialogType.Question).ShowDialog() == false)
							{
								return;
							}
						}
						if(App.LauncherRegKey.GetValue("CustomBackgroundName") != null)
						{
							DeleteFile(Path.Combine(App.LauncherBackgroundsPath, App.LauncherRegKey.GetValue("CustomBackgroundName").ToString()));
						}
						Log($"Setting custom background: {path}");
						string new_path = Path.Combine(App.LauncherBackgroundsPath, name);
						File.Copy(path, new_path, true);
						path = new_path;
						BpUtility.WriteToRegistry("CustomBackgroundName", name);
					}
					BackgroundImage.Visibility = Visibility.Collapsed;
					BackgroundImage.Source = (BitmapImage)Resources["BackgroundImage"];
					BackgroundMedia.Visibility = Visibility.Collapsed;
					BackgroundMedia.Source = null;
				}
				switch(format)
				{
					case 0:
						if(new_file)
						{
							new DialogWindow(App.TextStrings["contextmenu_custom_background"], App.TextStrings["msgbox_custom_background_7_msg"]).ShowDialog();
						}
						else
						{
							throw new FileFormatException("File is in unsupported format");
						}
						break;
					case 1:
						BackgroundImage.Visibility = Visibility.Visible;
						using(FileStream fs = new FileStream(path, FileMode.Open))
						{
							var image = new BitmapImage();
							image.BeginInit();
							image.StreamSource = fs;
							image.CacheOption = BitmapCacheOption.OnLoad;
							image.EndInit();
							BackgroundImage.Source = image;
						}
						break;
					case 2:
						BackgroundImage.Visibility = Visibility.Visible;
						XamlAnimatedGif.AnimationBehavior.SetSourceUri(BackgroundImage, new Uri(path));
						break;
					case 3:
						BackgroundMedia.Visibility = Visibility.Visible;
						BackgroundMedia.Source = new Uri(path);
						BackgroundMedia.MediaEnded += (object sender, RoutedEventArgs e) =>
						{
							BackgroundMedia.Position = TimeSpan.FromMilliseconds(1);
						};
						break;
					default:
						if(new_file)
						{
							new DialogWindow(App.TextStrings["contextmenu_custom_background"], App.TextStrings["msgbox_custom_background_8_msg"]).ShowDialog();
						}
						else
						{
							throw new FileLoadException("Could not load the file");
						}
						break;
				}
			}
			catch(Exception ex)
			{
				Log($"Failed to set custom background:\n{ex}", true, 1);
			}
		}

		public void SetLanguage(string lang)
		{
			App.LauncherLanguage = "en";
			if(File.Exists(App.LauncherTranslationsFile))
			{
				try
				{
					var json = JsonConvert.DeserializeObject<dynamic>(File.ReadAllText(App.LauncherTranslationsFile));
					foreach(var kvp in json[lang])
					{
						App.TextStrings[kvp.Name] = kvp.Value.ToString();
					}
					App.LauncherLanguage = lang;
				}
				catch(Exception ex)
				{
					Log($"Failed to load translations:\n{ex}", true, 1);
					MessageBox.Show(App.TextStrings["msgbox_translations_download_error_msg"], App.TextStrings["msgbox_generic_error_title"], MessageBoxButton.OK, MessageBoxImage.Error);
					DeleteFile(App.LauncherTranslationsFile, true);
					BpUtility.DeleteFromRegistry("Language");
					Array.Resize(ref App.CommandLineArgs, App.CommandLineArgs.Length + 1);
					App.CommandLineArgs[App.CommandLineArgs.Length - 1] = "NOTRANSLATIONS";
					BpUtility.RestartApp();
				}
			}
			if(App.LauncherLanguage != "en" && App.LauncherLanguage != "zh-CN")
			{
				Resources["Font"] = new FontFamily("Segoe UI Bold");
			}
		}

		public void Log(string msg, bool newline = true, int type = 0)
		{
			if(string.IsNullOrEmpty(msg))
			{
				return;
			}

			Color color;
			#if DEBUG
			ConsoleColor ccolor;
			#endif
			switch(type)
			{
				case 1:
					msg = "ERROR: " + msg;
					color = Colors.Red;
					#if DEBUG
					ccolor = ConsoleColor.Red;
					#endif
					break;
				case 2:
					msg = "WARNING: " + msg;
					color = Colors.Yellow;
					#if DEBUG
					ccolor = ConsoleColor.Yellow;
					#endif
					break;
				default:
					color = Colors.White;
					#if DEBUG
					ccolor = ConsoleColor.Gray;
					#endif
					break;
			}
			#if DEBUG
			Console.ForegroundColor = ccolor;
			if(newline)
			{
				Console.Write('\n' + msg);
			}
			else
			{
				Console.Write(msg);
			}
			#endif
			Dispatcher.Invoke(() =>
			{
				if(newline)
				{
					var brush = new SolidColorBrush(color);
					var run = new Run()
					{
						Text = msg,
						Foreground = brush
					};
					var para = new Paragraph(run)
					{
						Margin = new Thickness(0)
					};
					LogBoxRichTextBox.Document.Blocks.Add(para);
				}
				else
				{
					LogBoxRichTextBox.AppendText(msg);
				}
				if(!LogBoxScrollViewer.AreAnyTouchesCaptured)
				{
					LogBoxScrollViewer.ScrollToEnd();
				}
			});
			if(!App.DisableLogging)
			{
				try
				{
					Directory.CreateDirectory(App.LauncherDataPath);
					if(File.Exists(App.LauncherLogFile))
					{
						File.SetAttributes(App.LauncherLogFile, File.GetAttributes(App.LauncherLogFile) & ~FileAttributes.ReadOnly);
					}
					if(newline)
					{
						File.AppendAllText(App.LauncherLogFile, '\n' + msg);
					}
					else
					{
						File.AppendAllText(App.LauncherLogFile, msg);
					}
				}
				catch
				{
					App.DisableLogging = true;
					Log("Unable to write to log file, disabling logging to file...", true, 2);
				}
			}
		}

		public bool DeleteFile(string path, bool ignore_read_only = false)
		{
			try
			{
				if(File.Exists(path))
				{
					if(ignore_read_only)
					{
						File.SetAttributes(path, File.GetAttributes(path) & ~FileAttributes.ReadOnly);
					}
					File.Delete(path);
				}
				return true;
			}
			catch
			{
				Log($"Failed to delete {path}", true, 2);
				return false;
			}
		}

		public struct GameVersion
		{
			private int major, minor, patch;
			
			internal GameVersion(int _major, int _minor, int _patch)
			{
				major = _major;
				minor = _minor;
				patch = _patch;
			}

			internal GameVersion(string _version)
			{
				string[] _version_strings = _version.Split('.', '_');
				if(_version_strings.Length < 3 || _version_strings.Length > 4)
				{
					major = 0;
					minor = 0;
					patch = 0;
					return;
				}

				major = int.Parse(_version_strings[0]);
				minor = int.Parse(_version_strings[1]);
				patch = int.Parse(_version_strings[2]);
			}

			internal bool IsNewerThan(GameVersion _other_version)
			{
				int old_version = int.Parse(string.Format("{0}{1}{2}", _other_version.major, _other_version.minor, _other_version.patch));
				int new_version = int.Parse(string.Format("{0}{1}{2}", major, minor, patch));

				if(new_version > old_version)
				{
					return true;
				}
				else
				{
					return false;
				}
			}

			public override string ToString()
			{
				return $"{major}.{minor}.{patch}";
			}
		}
	}
}
```

`Properties/AssemblyInfo.cs`:

```cs
using System.Reflection;
using System.Resources;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Windows;

// General Information about an assembly is controlled through the following
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Better HI3 Launcher")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Bp")]
[assembly: AssemblyProduct("Better HI3 Launcher")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible
// to COM components.  If you need to access a type in this assembly from
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

//In order to begin building localizable applications, set
//<UICulture>CultureYouAreCodingWith</UICulture> in your .csproj file
//inside a <PropertyGroup>.  For example, if you are using US english
//in your source files, set the <UICulture> to en-US.  Then uncomment
//the NeutralResourceLanguage attribute below.  Update the "en-US" in
//the line below to match the UICulture setting in the project file.

//[assembly: NeutralResourcesLanguage("en-US", UltimateResourceFallbackLocation.Satellite)]


[assembly: ThemeInfo(
    ResourceDictionaryLocation.None, //where theme specific resource dictionaries are located
                                     //(used if a resource is not found in the page,
                                     // or application resource dictionaries)
    ResourceDictionaryLocation.SourceAssembly //where the generic resource dictionary is located
                                              //(used if a resource is not found in the page,
                                              // app, or any theme specific resource dictionaries)
)]


// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.3.0.0")]

```

`Properties/Resources.Designer.cs`:

```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace BetterHI3Launcher.Properties {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "16.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("BetterHI3Launcher.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.IO.UnmanagedMemoryStream similar to System.IO.MemoryStream.
        /// </summary>
        internal static System.IO.UnmanagedMemoryStream Click {
            get {
                return ResourceManager.GetStream("Click", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.IO.UnmanagedMemoryStream similar to System.IO.MemoryStream.
        /// </summary>
        internal static System.IO.UnmanagedMemoryStream Window_Close {
            get {
                return ResourceManager.GetStream("Window_Close", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.IO.UnmanagedMemoryStream similar to System.IO.MemoryStream.
        /// </summary>
        internal static System.IO.UnmanagedMemoryStream Window_Open {
            get {
                return ResourceManager.GetStream("Window_Open", resourceCulture);
            }
        }
    }
}

```

`Properties/Resources.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <assembly alias="System.Windows.Forms" name="System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />
  <data name="Click" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Assets\Sounds\Click.wav;System.IO.MemoryStream, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="Window_Close" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Assets\Sounds\Window_Close.wav;System.IO.MemoryStream, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="Window_Open" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Assets\Sounds\Window_Open.wav;System.IO.MemoryStream, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
</root>
```

`Properties/Settings.Designer.cs`:

```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace BetterHI3Launcher.Properties {
    
    
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "16.8.1.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase {
        
        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));
        
        public static Settings Default {
            get {
                return defaultInstance;
            }
        }
    }
}

```

`Properties/Settings.settings`:

```settings
<?xml version='1.0' encoding='utf-8'?>
<SettingsFile xmlns="uri:settings" CurrentProfile="(Default)">
  <Profiles>
    <Profile Name="(Default)" />
  </Profiles>
  <Settings />
</SettingsFile>
```

`README.md`:

```md
# Better HI3 Launcher
A much better Honkai Impact 3rd launcher. Here are the key points:
* No need to install, it is just one file
* Supports all game clients (Global, SEA, CN, TW/HK/MO and KR), can switch between them freely
  * **Please note that Steam version is not supported**
* Uses parallel downloading mechanism: Instead of downloading the game as one continuous stream of data it is now divided to several chunks, which dramatically speeds up the download process
* Has mirror support so you have more download sources to choose from
* Automatically updates itself, so you are always getting the latest and greatest!
* Has lots of useful features, such as:
  * Downloading game cache (fixes the problems that occur during "Updating settings")
  * Repairing game files (only the files that are needed will be downloaded)
  * Moving game files (properly, so that the original launcher still works)
  * Setting custom resolution, custom FPS, resetting download type (to reselect assets download option)
  * Customizable background (supports still images, GIFs, and even videos!)

## Getting the launcher
Go to the [releases page](https://github.com/BuIlDaLiBlE/BetterHI3Launcher/releases/latest) and click on `BetterHI3Launcher.exe`.

You can save and use it wherever you want, it's that simple!

## Compatibility
First of all, a 64-bit version of Windows is required, since the game also requires it.

Confirmed to work on Windows 10 and Windows 11, but the machine I develop on runs Windows 10.

Windows 8.1 should work if .NET Framework 4.6.1 or newer is installed.

Windows 7 should technically work too if the above condition is met, however it's not supported by Microsoft since January of 2020 so I may not provide much support.

## Is this safe?
I started this project with hope to help fellow Captains have a better experience with the game. Since the release in January of 2021 there have been no cases of bans.
After all, this is just an app that downloads the game and has some helpful utilities. However, it is wise to remember that this project is not affiliated with HoYoverse and thus they have the final say about it.

Ultimately, it is for you to decide whether to trust me or not. The launcher's code is open source though, so you're always welcome to look at it. On that note...

## How can I contribute? 
Great question! This project is actively supported, you are always welcome to [open an issue](https://github.com/BuIlDaLiBlE/BetterHI3Launcher/issues/new/choose) (report a bug or suggest something) or directly contribute to the project via [pull requests](https://github.com/BuIlDaLiBlE/BetterHI3Launcher/pulls).

You can also contribute by translating the launcher into a language you speak. **Please only contribute languages the launcher doesn't yet have!**

Here's how to do it:
1. [Download English source text](https://bpnet.work/bh3?launcher_translations=get_contents_en)
2. You will see a bunch of lines with text, on each line there are two pieces of text: you don't need to touch the one on the left, only translate the one on the right (after the space). Please try your best not to touch special characters such as `{0}`, `\n`, or `\"`, don't add any unnecessary spaces, newlines or other characters.
3. After you're done, [create an issue](https://github.com/BuIlDaLiBlE/BetterHI3Launcher/issues/new?assignees=BuIlDaLiBlE&labels=language+contribution&template=language_contribution.md&title=Language+contribution+%5BNAME+OF+THE+LANGUAGE+HERE%5D) with the name of the language and attach the file with translated strings to it.

That's it, you're done! Please be ready to answer if there happens to be something that I need to clarify about your translation.

After I verify your submission and implement it you can be sure I will list your name in the "About" section of the launcher.

Translations may need updating in the future as I keep adding and changing things so I'd be eternally grateful if you keep being subscribed to the issue so that you receive notifications whenever I need more help.
```

`TextStrings_en.cs`:

```cs
using System.Windows;

namespace BetterHI3Launcher
{
	public partial class App : Application
	{
		public static void TextStrings_English()
		{
			TextStrings.Add("version", "Version");
			TextStrings.Add("binary_prefixes", "KMGTPEZY");
			TextStrings.Add("byte_short", "b");
			TextStrings.Add("bytes_per_second", "B/s");
			TextStrings.Add("outdated", "Outdated");
			TextStrings.Add("enabled", "Enabled");
			TextStrings.Add("disabled", "Disabled");
			TextStrings.Add("button_yes", "Yes");
			TextStrings.Add("button_no", "No");
			TextStrings.Add("button_download", "Download");
			TextStrings.Add("button_downloading", "Downloading");
			TextStrings.Add("button_running", "Running");
			TextStrings.Add("button_update", "Update");
			TextStrings.Add("button_pause", "Pause");
			TextStrings.Add("button_launch", "Launch");
			TextStrings.Add("button_options", "Options");
			TextStrings.Add("button_resume", "Resume");
			TextStrings.Add("button_ok", "OK");
			TextStrings.Add("button_confirm", "Confirm");
			TextStrings.Add("button_cancel", "Cancel");
			TextStrings.Add("button_github", "Go to GitHub repository");
			TextStrings.Add("button_generate", "Generate");
			TextStrings.Add("label_server", "Server");
			TextStrings.Add("label_mirror", "Mirror");
			TextStrings.Add("label_pre_install", "Game Pre-Installation");
			TextStrings.Add("label_get_now", "Get Now");
			TextStrings.Add("label_verifying", "Verifying");
			TextStrings.Add("label_paused", "Paused");
			TextStrings.Add("label_done", "Done");
			TextStrings.Add("label_retry", "Retry");
			TextStrings.Add("label_downloaded_1", "Downloaded {0}%");
			TextStrings.Add("label_downloaded_2", "Download resources:");
			TextStrings.Add("label_merged", "Merged {0}%");
			TextStrings.Add("label_eta", "Time remaining:");
			TextStrings.Add("label_download_speed", "Download speed:");
			TextStrings.Add("label_merge_speed", "Merge speed:");
			TextStrings.Add("introbox_title", "Welcome to Better HI3 Launcher!");
			TextStrings.Add("introbox_msg", "Seems like this is your first time using the launcher. I'm glad you've decided to give it a try so in case you'd like to give feedback don't hesitate to do so by clicking \"Options\" button and selecting \"Send feedback\".\nIf you already have the game installed just press the \"Download\" button and point to where your game is. The launcher will detect your game version automatically and you won't have to download the game again.");
			TextStrings.Add("repairbox_msg", "This will check every game file and attempt to repair if any is broken. It can take a while.\nContinue?\nAvailable mirrors: {0}.\nCurrent mirror maintainer is {1}.");
			TextStrings.Add("fpsinputbox_title", "Enter max FPS cap");
			TextStrings.Add("fpsinputbox_label_combatfps", "FPS in-game");
			TextStrings.Add("fpsinputbox_label_menufps", "FPS in menu");
			TextStrings.Add("resolutioninputbox_title", "Enter custom resolution");
			TextStrings.Add("resolutioninputbox_label_width", "Width");
			TextStrings.Add("resolutioninputbox_label_height", "Height");
			TextStrings.Add("resolutioninputbox_label_fullscreen", "Fullscreen");
			TextStrings.Add("changelogbox_title", "Changelog");
			TextStrings.Add("changelogbox_1_msg", "Better HI3 Launcher has just become even better. Here's what happened:");
			TextStrings.Add("changelogbox_2_msg", "Loading changelog...");
			TextStrings.Add("changelogbox_3_msg", "Failed to load the changelog.");
			TextStrings.Add("aboutbox_msg", "Well it is much more advanced, isn't it? :^)\nThis project was made with hope for many captains to have a better experience with the game.\nIt is not affiliated with miHoYo and is completely open source.\nAny feedback is greatly appreciated.\nSpecial thanks to these GitHub contributors:\nSinsOfSeven - Custom resolution contribution\nProxy-E23 - Spanish language translation\nSpookyKisuy - Portuguese (Brazil) language translation\nbulawin1, Vrontis - German language translation\nKorewaLidesu - Vietnamese language translation\nSm1leAway - Serbian language translation\nVoRTeXStarz - Thai language translation\nTrilip - French language translation\nfabio-silva-pt - Portuguese (Portugal) language translation\nneon-nyan - Indonesian language translation, parallel download feature\nRinnosuke93 - Italian language translation\nMartinial - Czech language translation\nKLXLjun - Chinese (Simplified) translation");
			TextStrings.Add("announcementbox_do_not_show", "Do not show me this next time");
			TextStrings.Add("contextmenu_download_cache", "Download cache");
			TextStrings.Add("contextmenu_repair", "Repair game files");
			TextStrings.Add("contextmenu_move", "Move game files");
			TextStrings.Add("contextmenu_uninstall", "Uninstall game");
			TextStrings.Add("contextmenu_game_settings", "Manage game settings");
			TextStrings.Add("contextmenu_custom_fps", "Set custom FPS cap");
			TextStrings.Add("contextmenu_custom_resolution", "Set custom resolution");
			TextStrings.Add("contextmenu_custom_launch_options", "Set custom launch options");
			TextStrings.Add("contextmenu_reset_download_type", "Reset download type");
			TextStrings.Add("contextmenu_web_profile", "Go to web profile");
			TextStrings.Add("contextmenu_feedback", "Send feedback");
			TextStrings.Add("contextmenu_changelog", "Show changelog");
			TextStrings.Add("contextmenu_custom_background", "Set custom background");
			TextStrings.Add("contextmenu_show_log", "Show log");
			TextStrings.Add("contextmenu_sounds", "Sounds");
			TextStrings.Add("contextmenu_language", "Language");
			TextStrings.Add("contextmenu_language_system", "System Default");
			TextStrings.Add("contextmenu_language_chinese_simplified", "Chinese (Simplified)");
			TextStrings.Add("contextmenu_language_czech", "Czech");
			TextStrings.Add("contextmenu_language_english", "English");
			TextStrings.Add("contextmenu_language_french", "French");
			TextStrings.Add("contextmenu_language_german", "German");
			TextStrings.Add("contextmenu_language_indonesian", "Indonesian");
			TextStrings.Add("contextmenu_language_italian", "Italian");
			TextStrings.Add("contextmenu_language_portuguese_brazil", "Portuguese (Brazil)");
			TextStrings.Add("contextmenu_language_portuguese_portugal", "Portuguese (Portugal)");
			TextStrings.Add("contextmenu_language_russian", "Russian");
			TextStrings.Add("contextmenu_language_serbian", "Serbian");
			TextStrings.Add("contextmenu_language_spanish", "Spanish");
			TextStrings.Add("contextmenu_language_thai", "Thai");
			TextStrings.Add("contextmenu_language_vietnamese", "Vietnamese");
			TextStrings.Add("contextmenu_language_contribute", "Want to help?");
			TextStrings.Add("contextmenu_about", "About");
			TextStrings.Add("progresstext_checking_update", "Checking for update...");
			TextStrings.Add("progresstext_downloaded", "Downloaded {0}/{1} ({2})");
			TextStrings.Add("progresstext_downloading_file", "Downloading file {0}/{1}...");
			TextStrings.Add("progresstext_error", "Mistakes were made :^(");
			TextStrings.Add("progresstext_eta", "Estimated time: {0}");
			TextStrings.Add("progresstext_fetching_hashes", "Fetching file hashes...");
			TextStrings.Add("progresstext_generating_hash", "Generating hash for file {0}/{1}...");
			TextStrings.Add("progresstext_initiating_download", "Initiating download...");
			TextStrings.Add("progresstext_mirror_connect", "Connecting to mirror...");
			TextStrings.Add("progresstext_moving_files", "Moving game files...");
			TextStrings.Add("progresstext_uninstalling", "Uninstalling the game...");
			TextStrings.Add("progresstext_unpacking_1", "Unpacking game files...");
			TextStrings.Add("progresstext_unpacking_2", "Unpacking game file {0}/{1} ({2}%)...");
			TextStrings.Add("progresstext_updating_launcher", "Updating launcher...");
			TextStrings.Add("progresstext_verifying_file", "Verifying game file {0}/{1}...");
			TextStrings.Add("progresstext_verifying_files", "Verifying game files...");
			TextStrings.Add("progresstext_zipping", "Adding file {0}/{1} to ZIP archive...");
			TextStrings.Add("msgbox_abort_1_msg", "Are you sure you want to cancel the download and close the launcher?");
			TextStrings.Add("msgbox_abort_2_msg", "Are you sure you want to cancel the download?");
			TextStrings.Add("msgbox_abort_3_msg", "Progress will not be saved.");
			TextStrings.Add("msgbox_abort_4_msg", "Progress will be saved.");
			TextStrings.Add("msgbox_abort_title", "Abort");
			TextStrings.Add("msgbox_conn_bp_error_msg", "Cannot connect to Bp Network:");
			TextStrings.Add("msgbox_conn_mihoyo_error_msg", "Cannot connect to HoYoverse servers:");
			TextStrings.Add("msgbox_custom_background_1_msg", "You can select a file to be used as a background.\nIt can be an image or a video.\nRecommended resolution is {0} by {1} pixels.\nContinue?");
			TextStrings.Add("msgbox_custom_background_2_msg", "Select what would you like to do with the background.");
			TextStrings.Add("msgbox_custom_background_3_msg", "Selected file does not have the recommended resolution. You may still use it, but it will be stretched to the window size.\nContinue?");
			TextStrings.Add("msgbox_custom_background_4_msg", "Please select another file.");
			TextStrings.Add("msgbox_custom_background_5_msg", "Selected file is too large.\nYou can use files up to {0} in size.");
			TextStrings.Add("msgbox_custom_background_6_msg", "There is not enough free space on your system drive to use the file.");
			TextStrings.Add("msgbox_custom_background_7_msg", "Selected file is not in a supported format.");
			TextStrings.Add("msgbox_custom_background_8_msg", "Failed to load selected file.");
			TextStrings.Add("msgbox_custom_background_edit", "Change it");
			TextStrings.Add("msgbox_custom_background_delete", "Reset to official");
			TextStrings.Add("msgbox_custom_fps_1_msg", "Values must not be empty.");
			TextStrings.Add("msgbox_custom_fps_2_msg", "Values must not be zero or negative.");
			TextStrings.Add("msgbox_custom_fps_3_msg", "Values lower than 30 are not recommended. Continue?");
			TextStrings.Add("msgbox_custom_fps_4_msg", "In-game and menu FPS cap successfully set to {0} and {1} respectively.");
			TextStrings.Add("msgbox_custom_resolution_1_msg", "Height being greater than width is not recommended.\nContinue?");
			TextStrings.Add("msgbox_custom_resolution_2_msg", "Resolution successfully set to {0}x{1} with fullscreen {2}.");
			TextStrings.Add("msgbox_custom_launch_options_msg", "Advanced users may enter custom launch options here.\nNote: they are applied independently per server.");
			TextStrings.Add("msgbox_download_cache_hi3mirror_msg", "The entire game cache will be checked and can be downloaded if needed. It can take a while.\nHi3Mirror is a project courtesy of {0}.\nContinue?");
			TextStrings.Add("msgbox_download_type_1_msg", "This will reset game's resource download type and allow you to reselect which assets to download.\nContinue?");
			TextStrings.Add("msgbox_download_type_2_msg", "Download type has been reset.");
			TextStrings.Add("msgbox_download_type_3_msg", "Download type has already been reset.");
			TextStrings.Add("msgbox_feature_not_available_msg", "This feature is not available for selected server.");
			TextStrings.Add("msgbox_game_download_error_msg", "An error occurred while downloading game files.\nFor more information take a look at the log.");
			TextStrings.Add("msgbox_game_download_error_title", "Error downloading game files");
			TextStrings.Add("msgbox_game_download_mirror_error_msg", "An error occurred while downloading from the mirror.\nFor more information take a look at the log.");
			TextStrings.Add("msgbox_game_download_mirror_old_msg", "It seems like the game version on miHoYo servers is newer than the one on the mirror.\nThere is no reason to download an outdated version, ask the mirror maintainer to upload a new version.");
			TextStrings.Add("msgbox_game_download_paused_msg", "The game is not downloaded entirely yet. Changing server or mirror will reset the download progress.\nContinue?");
			TextStrings.Add("msgbox_generic_error_msg", "An error occurred.\nFor more information take a look at the log.");
			TextStrings.Add("msgbox_generic_error_title", "Error");
			TextStrings.Add("msgbox_install_dir_error_msg", "An error occurred while selecting game installation directory.\nFor more information take a look at the log.");
			TextStrings.Add("msgbox_install_dir_error_title", "Invalid directory");
			TextStrings.Add("msgbox_install_error_msg", "An error occurred while installing game files.\nFor more information take a look at the log.");
			TextStrings.Add("msgbox_install_error_title", "Installation error");
			TextStrings.Add("msgbox_install_existing_dir_msg", "The game appears to have already been installed to:\n{0}\nUse this directory?");
			TextStrings.Add("msgbox_install_existing_no_local_version_msg", "Local version could not be determined.\nIs your game updated already? Please choose wisely!\nSelecting \"Yes\" will make you be able to launch the game.\nSelecting \"No\" will make you have to download the game.");
			TextStrings.Add("msgbox_install_little_space_msg", "There is potentially not enough free space on selected device, it is recommended to free up some space or installation may result in failure.\nContinue?");
			TextStrings.Add("msgbox_install_1_msg", "Select where would you like to install the game.");
			TextStrings.Add("msgbox_install_2_msg", "Download size: {0}.");
			TextStrings.Add("msgbox_install_3_msg", "Installation size: {0}.");
			TextStrings.Add("msgbox_install_4_msg", "The game is going to be installed to:\n{0}\nContinue?");
			TextStrings.Add("msgbox_install_title", "Install");
			TextStrings.Add("msgbox_install_wrong_drive_type_msg", "Cannot install on selected device.");
			TextStrings.Add("msgbox_language_msg", "Language is going to be changed to {0} and launcher will be restarted.\nContinue?");
			TextStrings.Add("msgbox_launcher_download_error_msg", "An error occurred while downloading the launcher.\nFor more information take a look at the log.");
			TextStrings.Add("msgbox_mirror_error_msg", "There is an error with the mirror. Ask the mirror maintainer to get to the bottom of this.\nMessage: {0}");
			TextStrings.Add("msgbox_mirror_info_msg", "Use this mirror only if you cannot download the game via official miHoYo servers.\nPlease note that it is updated manually.\nContinue?");
			TextStrings.Add("msgbox_move_1_msg", "Select where would you like to move the game.");
			TextStrings.Add("msgbox_move_2_msg", "The game is going to be moved to:\n{0}\nContinue?");
			TextStrings.Add("msgbox_move_3_msg", "Cannot move the game inside the current game directory.");
			TextStrings.Add("msgbox_move_4_msg", "Cannot move the game while the launcher is inside game directory. Move launcher outside the directory and try again.");
			TextStrings.Add("msgbox_move_error_title", "Move error");
			TextStrings.Add("msgbox_move_little_space_msg", "There is potentially not enough free space on selected device, it is recommended to free up some space or move operation may result in failure.\nContinue?");
			TextStrings.Add("msgbox_move_title", "Move");
			TextStrings.Add("msgbox_move_wrong_drive_type_msg", "Cannot move to selected device.");
			TextStrings.Add("msgbox_net_error_msg", "An error occurred while connecting to server:\n{0}");
			TextStrings.Add("msgbox_net_error_title", "Network error");
			TextStrings.Add("msgbox_net_version_old_msg", "This launcher requires .NET Framework 4.6.1 or newer to be installed.");
			TextStrings.Add("msgbox_no_game_dir_msg", "Game directory cannot be found.\nTry reinstalling the game.");
			TextStrings.Add("msgbox_no_game_dir_title", "No game directory");
			TextStrings.Add("msgbox_no_game_exe_msg", "Game executable cannot be found.\nWould you like to reset the installation information?");
			TextStrings.Add("msgbox_no_game_exe_title", "No game executable");
			TextStrings.Add("msgbox_notice_title", "Notice");
			TextStrings.Add("msgbox_pre_install_msg", "You can still enter the game when pre-installing. Are you sure you want to download?\nYou can only download from the miHoYo servers.");
			TextStrings.Add("msgbox_process_start_error_msg", "An error occurred while starting the process.\nFor more information take a look at the log.");
			TextStrings.Add("msgbox_registry_empty_1_msg", "No value to be tweaked in registry exists.");
			TextStrings.Add("msgbox_registry_empty_2_msg", "Have you run the game yet?");
			TextStrings.Add("msgbox_registry_empty_3_msg", "Try changing video settings in-game first (disabling fullscreen, changing video preset, etc).");
			TextStrings.Add("msgbox_registry_error_msg", "An error occurred while accessing registry.\nFor more information take a look at the log.");
			TextStrings.Add("msgbox_registry_error_title", "Registry error");
			TextStrings.Add("msgbox_repair_1_msg", "The version of the game installed differs from repair information on the server. Due to us having to update this information manually, it may not be available for some time.\nPlease try again later.");
			TextStrings.Add("msgbox_repair_2_msg", "No files need any repairs.");
			TextStrings.Add("msgbox_repair_3_msg", "Found {0} corrupted/missing file(s). They need to be repaired by downloading them again.\nBecause technology is awesome, only the required files will be downloaded.\nDownload size: {1}.\nContinue?");
			TextStrings.Add("msgbox_repair_4_msg", "{0} file(s) successfully repaired.");
			TextStrings.Add("msgbox_repair_5_msg", "{0} file(s) failed to be repaired.\nFor more information take a look at the log.");
			TextStrings.Add("msgbox_repair_6_msg", "Going to generate a JSON file containing the list of game files and their hashes, then create a ZIP archive with those files.\nContinue?");
			TextStrings.Add("msgbox_repair_7_msg", "Continue to create ZIP file? It definitely takes a while.");
			TextStrings.Add("msgbox_repair_8_msg", "Repair data from the server has a different game version.\nAre you sure you want to run the check?");
			TextStrings.Add("msgbox_start_error_msg", "An error occurred while starting the launcher:\n{0}");
			TextStrings.Add("msgbox_start_error_title", "Startup error");
			TextStrings.Add("msgbox_translations_download_error_msg", "An error occurred while downloading translations.\nOnly English language will be available.");
			TextStrings.Add("msgbox_unhandled_exception_msg", "Oops, something very bad has happened and the launcher must close. But you can help!\nThere is a log file you can send to help diagnose the error.\nDo you want to open the log file now?");
			TextStrings.Add("msgbox_uninstall_1_msg", "Select what would you like to uninstall.");
			TextStrings.Add("msgbox_uninstall_2_msg", "Are you sure you want to uninstall the following?");
			TextStrings.Add("msgbox_uninstall_3_msg", "Are you really sure you want to uninstall the following? :^(");
			TextStrings.Add("msgbox_uninstall_4_msg", "This action is irreversible.\nOnly do this if you are having problems with the game!\nAre you sure you want to continue?");
			TextStrings.Add("msgbox_uninstall_5_msg", "Cannot uninstall the game while the launcher is inside game directory. Move launcher outside the directory and try again.");
			TextStrings.Add("msgbox_uninstall_6_msg", "Sucessfully uninstalled the following:");
			TextStrings.Add("msgbox_uninstall_error_msg", "An error occurred while uninstalling the game.\nFor more information take a look at the log.");
			TextStrings.Add("msgbox_uninstall_error_title", "Uninstallation error");
			TextStrings.Add("msgbox_uninstall_game_files", "Game Files");
			TextStrings.Add("msgbox_uninstall_game_cache", "Game Cache");
			TextStrings.Add("msgbox_uninstall_game_settings", "Game Settings");
			TextStrings.Add("msgbox_uninstall_title", "Uninstall");
			TextStrings.Add("msgbox_update_check_error_msg", "An error occurred while checking for update.\nFor more information take a look at the log.\nRetry?");
			TextStrings.Add("msgbox_update_check_error_title", "Update check error");
			TextStrings.Add("msgbox_update_title", "Update notice");
			TextStrings.Add("msgbox_verify_error_1_msg", "An error occurred while downloading. Please try again.");
			TextStrings.Add("msgbox_verify_error_2_msg", "An error occurred while downloading. File may be corrupt.\nContinue regardless?");
			TextStrings.Add("msgbox_verify_error_title", "File validation error");
		}
	}
}
```

`Utility.cs`:

```cs
using Microsoft.Win32;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Media;
using System.Net;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Media;
using System.Windows.Shapes;
using ProgressItem = System.Collections.Generic.KeyValuePair<long, float>;

namespace BetterHI3Launcher
{
	public class BpUtility
	{
		public static void StartProcess(string proccess, string arguments, string workingDir, bool useShellExec)
		{
			var startInfo = new ProcessStartInfo(proccess, arguments);
			startInfo.WorkingDirectory = workingDir;
			startInfo.UseShellExecute = useShellExec;
			Process.Start(startInfo);
		}

		public static void RestartApp()
		{
			try
			{
				if(App.Mutex != null)
				{
					App.Mutex.Dispose();
				}
				Application.Current.Shutdown();
				StartProcess(App.LauncherExeName, string.Join(" ", App.CommandLineArgs), App.LauncherRootPath, true);
			}catch{}
		}

		public static void PlaySound(Stream sound)
		{
			if(!App.DisableSounds)
			{
				try
				{
					new SoundPlayer(sound).Play();
				}catch{}
			}
		}

		// https://stackoverflow.com/a/10520086/7570821
		public static string CalculateMD5(string filename)
		{
			using(var md5 = MD5.Create())
			{
				using(var stream = File.OpenRead(filename))
				{
					return BitConverter.ToString(md5.ComputeHash(stream)).Replace("-", string.Empty);
				}
			}
		}

		// https://stackoverflow.com/a/49535675/7570821
		public static string ToBytesCount(long bytes)
		{
			int unit = 1024;
			string unitStr = App.TextStrings["byte_short"];
			if(bytes < unit) return string.Format("{0} {1}", bytes, unitStr);
			else unitStr = unitStr.ToUpper();
			int exp = (int)(Math.Log(bytes) / Math.Log(unit));
			return string.Format("{0:##.##} {1}{2}", bytes / Math.Pow(unit, exp), App.TextStrings["binary_prefixes"][exp - 1], unitStr);
		}

		public static string GetWindowsVersion()
		{
			var key = Registry.LocalMachine.OpenSubKey(@"SOFTWARE\Microsoft\Windows NT\CurrentVersion");
			string name = "Windows";
			string build = "0";
			string version = string.Empty;
			string revision = "0";
			try
			{
				var value = key.GetValue("ProductName").ToString();
				if(!string.IsNullOrEmpty(value))
				{
					name = value;
				}
			}catch{}
			try
			{
				var value = key.GetValue("CurrentBuild").ToString();
				if(!string.IsNullOrEmpty(value))
				{
					build = value;
				}
			}catch{}
			try
			{
				var value = key.GetValue("DisplayVersion").ToString();
				if(!string.IsNullOrEmpty(value))
				{
					version = value;
				}
			}catch{}
			try
			{
				var value = key.GetValue("UBR").ToString();
				if(!string.IsNullOrEmpty(value))
				{
					revision = value;
				}
			}catch{}
			if(Environment.OSVersion.Version.Major == 10)
			{
				if(!string.IsNullOrEmpty(version))
					return $"{name} (Version {version}, Build {build}.{revision})";
				else
					return $"{name} (Build {build}.{revision})";
			}
			else
			{
				return $"{name} (Build {build})";
			}
		}

		public static bool IsFileLocked(FileInfo file)
		{
			try
			{
				using(FileStream stream = file.Open(FileMode.Open, FileAccess.Read, FileShare.None))
				{
					stream.Close();
				}
			}
			catch(IOException)
			{
				return true;
			}
			return false;
		}

		public static MenuItem GetMenuItem(dynamic menu, string name)
		{
			foreach(dynamic item in menu)
			{
				if(item.GetType() == typeof(MenuItem) && item.Header.ToString() == name)
				{
					return item;
				}
			}
			return null;
		}

		public static HttpWebRequest CreateWebRequest(string url, string method = "GET", int timeout = 10000)
		{
			var webRequest = (HttpWebRequest)WebRequest.Create(url);
			webRequest.Method = method;
			webRequest.UserAgent = App.UserAgent;
			webRequest.Headers.Add("Accept-Language", App.LauncherLanguage);
			webRequest.Timeout = timeout;
			return webRequest;
		}

		public static void WriteToRegistry(string name, dynamic value, RegistryValueKind valueKind = RegistryValueKind.Unknown)
		{
			App.LauncherRegKey.SetValue(name, value, valueKind);
			App.LauncherRegKey.Close();
			App.LauncherRegKey = Registry.CurrentUser.OpenSubKey(@"SOFTWARE\Bp\Better HI3 Launcher", true);
		}

		public static void DeleteFromRegistry(string name)
		{
			if(App.LauncherRegKey.GetValue(name) != null)
			{
				App.LauncherRegKey.DeleteValue(name);
				App.LauncherRegKey.Close();
				App.LauncherRegKey = Registry.CurrentUser.OpenSubKey(@"SOFTWARE\Bp\Better HI3 Launcher", true);
			}
		}
	}

	// https://stackoverflow.com/a/42725580/7570821
	public class DownloadProgressTracker
	{
		private long _totalFileSize;
		private readonly int _sampleSize;
		private readonly TimeSpan _valueDelay;

		private DateTime _lastUpdateCalculated;
		private long _previousProgress;

		private double _cachedSpeed;

		private Queue<Tuple<DateTime, long>> _changes = new Queue<Tuple<DateTime, long>>();

		public DownloadProgressTracker(int sampleSize, TimeSpan valueDelay)
		{
			_lastUpdateCalculated = DateTime.Now;
			_sampleSize = sampleSize;
			_valueDelay = valueDelay;
		}

		public void NewFile()
		{
			_previousProgress = 0;
		}

		public void SetProgress(long bytesReceived, long totalBytesToReceive)
		{
			_totalFileSize = totalBytesToReceive;

			long diff = bytesReceived - _previousProgress;
			if(diff <= 0)
			{
				return;
			}

			_previousProgress = bytesReceived;

			_changes.Enqueue(new Tuple<DateTime, long>(DateTime.Now, diff));
			while(_changes.Count > _sampleSize)
			{
				_changes.Dequeue();
			}
		}

		public double GetProgress()
		{
			return _previousProgress / (double)_totalFileSize;
		}

		public string GetProgressString()
		{
			return string.Format("{0:P0}", GetProgress());
		}

		public string GetBytesPerSecondString()
		{
			double speed = GetBytesPerSecond();
			string[] prefix;
			switch(App.OSLanguage)
			{
				case "ru-RU":
				case "uk-UA":
				case "be-BY":
					prefix = new[]{"", "К", "М", "Г"};
					break;
				default:
					prefix = new[]{"", "K", "M", "G"};
					break;
			}

			int index = 0;
			while(speed > 1024 && index < prefix.Length - 1)
			{
				speed /= 1024;
				index++;
			}

			int intLen = ((int)speed).ToString().Length;
			int decimals = 3 - intLen;
			if(decimals < 0)
			{
				decimals = 0;
			}

			string format = string.Format("{{0:F{0}}}", decimals) + " {1}" + App.TextStrings["bytes_per_second"];

			return string.Format(format, speed, prefix[index]);
		}

		public double GetBytesPerSecond()
		{
			if(DateTime.Now >= _lastUpdateCalculated + _valueDelay)
			{
				_lastUpdateCalculated = DateTime.Now;
				_cachedSpeed = GetRateInternal();
			}

			return _cachedSpeed;
		}

		private double GetRateInternal()
		{
			if(_changes.Count == 0)
			{
				return 0;
			}

			TimeSpan timespan = _changes.Last().Item1 - _changes.First().Item1;
			long bytes = _changes.Sum(t => t.Item2);

			double rate = bytes / timespan.TotalSeconds;

			if(double.IsInfinity(rate) || double.IsNaN(rate))
			{
				return 0;
			}

			return rate;
		}
	}

	// https://stackoverflow.com/a/62039306/7570821
	public class DownloadPauseable
	{
		private volatile bool _allowedToRun;
		private readonly string _sourceUrl;
		private readonly string _destination;
		private readonly int _chunkSize;
		private readonly IProgress<double> _progress;
		private readonly Lazy<long> _contentLength;

		public long BytesWritten {get; private set;}
		public long ContentLength => _contentLength.Value;

		public bool Done => ContentLength == BytesWritten;

		public DownloadPauseable(string source, string destination, int chunkSizeInBytes = 8192, IProgress<double> progress = null)
		{
			if(string.IsNullOrEmpty(source) || string.IsNullOrEmpty(destination))
				throw new ArgumentNullException();

			_allowedToRun = true;
			_sourceUrl = source;
			_destination = destination;
			_chunkSize = chunkSizeInBytes;
			_contentLength = new Lazy<long>(GetContentLength);
			_progress = progress;

			if(!File.Exists(destination))
				BytesWritten = 0;
			else
			{
				try
				{
					BytesWritten = new FileInfo(destination).Length;
				}
				catch
				{
					BytesWritten = 0;
				}
			}
		}

		private long GetContentLength()
		{
			var request = (HttpWebRequest)WebRequest.Create(_sourceUrl);
			request.Method = "HEAD";
			request.UserAgent = App.UserAgent;
			request.Headers.Add("Accept-Language", App.LauncherLanguage);

			using(var response = request.GetResponse())
				return response.ContentLength;
		}

		private async Task Start(long range)
		{
			if(!_allowedToRun)
				throw new InvalidOperationException();

			if(Done)
				//file has been found in folder destination and is already fully downloaded 
				return;

			var request = (HttpWebRequest)WebRequest.Create(_sourceUrl);
			request.UserAgent = App.UserAgent;
			request.Headers.Add("Accept-Language", App.LauncherLanguage);
			request.AddRange(range);

			using(var response = await request.GetResponseAsync())
			{
				using(var responseStream = response.GetResponseStream())
				{
					using(var fs = new FileStream(_destination, FileMode.Append, FileAccess.Write, FileShare.ReadWrite))
					{
						while(_allowedToRun)
						{
							var buffer = new byte[_chunkSize];
							var bytesRead = await responseStream.ReadAsync(buffer, 0, buffer.Length).ConfigureAwait(false);

							if(bytesRead == 0) break;

							await fs.WriteAsync(buffer, 0, bytesRead);
							BytesWritten += bytesRead;
							_progress?.Report((double)BytesWritten / ContentLength);
						}

						await fs.FlushAsync();
					}
				}
			}
		}

		public Task Start()
		{
			_allowedToRun = true;
			return Start(BytesWritten);
		}

		public void Pause()
		{
			_allowedToRun = false;
		}
	}

	public class BpWebClient : WebClient
	{
		public int Timeout {get; set;}

		public BpWebClient()
		{
			Encoding = Encoding.UTF8;
			Timeout = 10000;
			Headers.Set(HttpRequestHeader.UserAgent, App.UserAgent);
			Headers.Set(HttpRequestHeader.AcceptLanguage, App.LauncherLanguage);
		}

		protected override WebRequest GetWebRequest(Uri address)
		{
			var webRequest = base.GetWebRequest(address);
			webRequest.Timeout = Timeout;
			return webRequest;
		}
	}

	// https://stackoverflow.com/a/23047288/7570821
	public class Arc : Shape
	{
		public double StartAngle
		{
			get { return (double)GetValue(StartAngleProperty); }
			set { SetValue(StartAngleProperty, value); }
		}

		// Using a DependencyProperty as the backing store for StartAngle.  This enables animation, styling, binding, etc...
		public static readonly DependencyProperty StartAngleProperty =
			DependencyProperty.Register("StartAngle", typeof(double), typeof(Arc), new UIPropertyMetadata(0.0, new PropertyChangedCallback(UpdateArc)));

		public double EndAngle
		{
			get { return (double)GetValue(EndAngleProperty); }
			set { SetValue(EndAngleProperty, value); }
		}

		// Using a DependencyProperty as the backing store for EndAngle.  This enables animation, styling, binding, etc...
		public static readonly DependencyProperty EndAngleProperty =
			DependencyProperty.Register("EndAngle", typeof(double), typeof(Arc), new UIPropertyMetadata(90.0, new PropertyChangedCallback(UpdateArc)));

		//This controls whether or not the progress bar goes clockwise or counterclockwise
		public SweepDirection Direction
		{
			get { return (SweepDirection)GetValue(DirectionProperty); }
			set { SetValue(DirectionProperty, value); }
		}

		public static readonly DependencyProperty DirectionProperty =
			DependencyProperty.Register("Direction", typeof(SweepDirection), typeof(Arc),
				new UIPropertyMetadata(SweepDirection.Clockwise));

		//rotate the start/endpoint of the arc a certain number of degree in the direction
		//ie. if you wanted it to be at 12:00 that would be 270 Clockwise or 90 counterclockwise
		public double OriginRotationDegrees
		{
			get { return (double)GetValue(OriginRotationDegreesProperty); }
			set { SetValue(OriginRotationDegreesProperty, value); }
		}

		public static readonly DependencyProperty OriginRotationDegreesProperty =
			DependencyProperty.Register("OriginRotationDegrees", typeof(double), typeof(Arc),
				new UIPropertyMetadata(270.0, new PropertyChangedCallback(UpdateArc)));

		protected static void UpdateArc(DependencyObject d, DependencyPropertyChangedEventArgs e)
		{
			Arc arc = d as Arc;
			arc.InvalidateVisual();
		}

		protected override Geometry DefiningGeometry
		{
			get { return GetArcGeometry(); }
		}

		protected override void OnRender(System.Windows.Media.DrawingContext drawingContext)
		{
			drawingContext.DrawGeometry(null, new Pen(Stroke, StrokeThickness), GetArcGeometry());
		}

		private Geometry GetArcGeometry()
		{
			Point startPoint = PointAtAngle(Math.Min(StartAngle, EndAngle), Direction);
			Point endPoint = PointAtAngle(Math.Max(StartAngle, EndAngle), Direction);

			Size arcSize = new Size(Math.Max(0, (RenderSize.Width - StrokeThickness) / 2),
				Math.Max(0, (RenderSize.Height - StrokeThickness) / 2));
			bool isLargeArc = Math.Abs(EndAngle - StartAngle) > 180;

			StreamGeometry geom = new StreamGeometry();
			using(StreamGeometryContext context = geom.Open())
			{
				context.BeginFigure(startPoint, false, false);
				context.ArcTo(endPoint, arcSize, 0, isLargeArc, Direction, true, false);
			}
			geom.Transform = new TranslateTransform(StrokeThickness / 2, StrokeThickness / 2);
			return geom;
		}

		private Point PointAtAngle(double angle, SweepDirection sweep)
		{
			double translatedAngle = angle + OriginRotationDegrees;
			double radAngle = translatedAngle * (Math.PI / 180);
			double xr = (RenderSize.Width - StrokeThickness) / 2;
			double yr = (RenderSize.Height - StrokeThickness) / 2;

			double x = xr + xr * Math.Cos(radAngle);
			double y = yr * Math.Sin(radAngle);

			if(sweep == SweepDirection.Counterclockwise)
			{
				y = yr - y;
			}
			else
			{
				y = yr + y;
			}

			return new Point(x, y);
		}
	}

	// https://github.com/scottrippey/Progression/blob/master/Progression/Extras/ETACalculator.cs
	public interface IETACalculator
	{
		/// <summary> Clears all collected data.
		/// </summary>
		void Reset();

		/// <summary> Updates the current progress.
		/// </summary>
		/// <param name="progress">The current level of completion.
		/// Must be between 0.0 and 1.0 (inclusively).</param>
		void Update(float progress);

		/// <summary> Returns True when there is enough data to calculate the ETA.
		/// Returns False if the ETA is still calculating.
		/// </summary>
		bool ETAIsAvailable {get;}

		/// <summary> Calculates the Estimated Time of Arrival (Completion)
		/// </summary>
		DateTime ETA {get;}

		/// <summary> Calculates the Estimated Time Remaining.
		/// </summary>
		TimeSpan ETR {get;}
	}

	/// <summary> Calculates the "Estimated Time of Arrival"
	/// (or more accurately, "Estimated Time of Completion"),
	/// based on a "rolling average" of progress over time.
	/// </summary>
	public class ETACalculator : IETACalculator
	{
		/// <summary>
		/// </summary>
		/// <param name="minimumData">
		/// The minimum number of data points required before ETA can be calculated.
		/// </param>
		/// <param name="maximumDuration">
		/// Determines how many seconds of data will be used to calculate the ETA.
		/// </param>
		public ETACalculator(int minimumData = 1, double maximumDuration = 1)
		{
			this.minimumData = minimumData;
			this.maximumTicks = (long)(maximumDuration * Stopwatch.Frequency);
			this.queue = new Queue<ProgressItem>(minimumData * 2);
			this.timer = Stopwatch.StartNew();
		}

		private int minimumData;
		private long maximumTicks;
		private readonly Stopwatch timer;
		private readonly Queue<ProgressItem> queue;

		private ProgressItem current;
		private ProgressItem oldest;

		public void Reset()
		{
			queue.Clear();

			timer.Reset();
			timer.Start();
		}

		private void ClearExpired()
		{
			var expired = timer.ElapsedTicks - this.maximumTicks;
			while(queue.Count > this.minimumData && queue.Peek().Key < expired)
			{
				this.oldest = queue.Dequeue();
			}
		}

		/// <summary> Adds the current progress to the calculation of ETA.
		/// </summary>
		/// <param name="progress">The current level of completion.
		/// Must be between 0.0 and 1.0 (inclusively).</param>
		public void Update(float progress)
		{
			// If progress hasn't changed, ignore:
			if(this.current.Value == progress)
			{
				return;
			}

			// Clear space for this item:
			ClearExpired();

			// Queue this item:
			long currentTicks = timer.ElapsedTicks;
			this.current = new ProgressItem(currentTicks, progress);
			this.queue.Enqueue(this.current);

			// See if its the first item:
			if(this.queue.Count == 1)
			{
				this.oldest = this.current;
			}
		}

		/// <summary> Calculates the Estimated Time Remaining
		/// </summary>
		public TimeSpan ETR
		{
			get
			{
				// Create local copies of the oldest & current,
				// so that another thread can update them without locking:
				var oldest = this.oldest;
				var current = this.current;

				// Make sure we have enough items:
				if(queue.Count < this.minimumData || oldest.Value == current.Value)
				{
					return TimeSpan.MaxValue;
				}

				// Calculate the estimated finished time:
				double finishedInTicks = (1.0d - current.Value) * (current.Key - oldest.Key) / (current.Value - oldest.Value);

				return TimeSpan.FromSeconds(finishedInTicks / Stopwatch.Frequency);
			}
		}

		/// <summary> Calculates the Estimated Time of Arrival (Completion)
		/// </summary>
		public DateTime ETA
		{
			get
			{
				return DateTime.Now.Add(ETR);
			}
		}

		/// <summary> Returns True when there is enough data to calculate the ETA.
		/// Returns False if the ETA is still calculating.
		/// </summary>
		public bool ETAIsAvailable
		{
			get
			{
				// Make sure we have enough items:
				return (queue.Count >= this.minimumData && oldest.Value != current.Value);
			}
		}
	}

	public class ProgressToAngleConverter : System.Windows.Data.IMultiValueConverter
	{
		public object Convert(object[] values, Type targetType, object parameter, System.Globalization.CultureInfo culture)
		{
			double progress = (double)values[0];
			System.Windows.Controls.ProgressBar bar = values[1] as System.Windows.Controls.ProgressBar;
			return 359.999 * (progress / (bar.Maximum - bar.Minimum));
		}

		public object[] ConvertBack(object value, Type[] targetTypes, object parameter, System.Globalization.CultureInfo culture)
		{
			throw new NotImplementedException();
		}
	}

	#if DEBUG
	// https://stackoverflow.com/a/48864902/7570821
	static class WinConsole
	{
		static public void Initialize(bool alwaysCreateNewConsole = true)
		{
			bool consoleAttached = true;
			if (alwaysCreateNewConsole
				|| (AttachConsole(ATTACH_PARRENT) == 0
				&& Marshal.GetLastWin32Error() != ERROR_ACCESS_DENIED))
			{
				consoleAttached = AllocConsole() != 0;
			}

			if (consoleAttached)
			{
				InitializeOutStream();
				InitializeInStream();
			}
		}

		private static void InitializeOutStream()
		{
			var fs = CreateFileStream("CONOUT$", GENERIC_WRITE, FILE_SHARE_WRITE, FileAccess.Write);
			if (fs != null)
			{
				var writer = new StreamWriter(fs) {AutoFlush = true};
				Console.SetOut(writer);
				Console.SetError(writer);
			}
		}

		private static void InitializeInStream()
		{
			var fs = CreateFileStream("CONIN$", GENERIC_READ, FILE_SHARE_READ, FileAccess.Read);
			if (fs != null)
			{
				Console.SetIn(new StreamReader(fs));
			}
		}

		private static FileStream CreateFileStream(string name, uint win32DesiredAccess, uint win32ShareMode, FileAccess dotNetFileAccess)
		{
			var file = new Microsoft.Win32.SafeHandles.SafeFileHandle(CreateFileW(name, win32DesiredAccess, win32ShareMode, IntPtr.Zero, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, IntPtr.Zero), true);
			if (!file.IsInvalid)
			{
				var fs = new FileStream(file, dotNetFileAccess);
				return fs;
			}
			return null;
		}

		#region Win API Functions and Constants
		[DllImport("kernel32.dll",
			EntryPoint = "AllocConsole",
			SetLastError = true,
			CharSet = CharSet.Auto,
			CallingConvention = CallingConvention.StdCall)]
		private static extern int AllocConsole();

		[DllImport("kernel32.dll",
			EntryPoint = "AttachConsole",
			SetLastError = true,
			CharSet = CharSet.Auto,
			CallingConvention = CallingConvention.StdCall)]
		private static extern UInt32 AttachConsole(UInt32 dwProcessId);

		[DllImport("kernel32.dll",
			EntryPoint = "CreateFileW",
			SetLastError = true,
			CharSet = CharSet.Auto,
			CallingConvention = CallingConvention.StdCall)]
		private static extern IntPtr CreateFileW
		(
				string lpFileName,
				UInt32 dwDesiredAccess,
				UInt32 dwShareMode,
				IntPtr lpSecurityAttributes,
				UInt32 dwCreationDisposition,
				UInt32 dwFlagsAndAttributes,
				IntPtr hTemplateFile
		);

		private const UInt32 GENERIC_WRITE = 0x40000000;
		private const UInt32 GENERIC_READ = 0x80000000;
		private const UInt32 FILE_SHARE_READ = 0x00000001;
		private const UInt32 FILE_SHARE_WRITE = 0x00000002;
		private const UInt32 OPEN_EXISTING = 0x00000003;
		private const UInt32 FILE_ATTRIBUTE_NORMAL = 0x80;
		private const UInt32 ERROR_ACCESS_DENIED = 5;

		private const UInt32 ATTACH_PARRENT = 0xFFFFFFFF;

		#endregion
	}
	#endif
}
```

`Utility/BpUtility.cs`:

```cs
using Microsoft.Win32;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Media;
using System.Net;
using System.Security.Cryptography;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Media;
using System.Windows.Shapes;
using ProgressItem = System.Collections.Generic.KeyValuePair<long, float>;

namespace BetterHI3Launcher
{
	public class BpUtility
	{
		public static void StartProcess(string proccess, string arguments, string workingDir, bool useShellExec)
		{
			var startInfo = new ProcessStartInfo(proccess, arguments);
			startInfo.WorkingDirectory = workingDir;
			startInfo.UseShellExecute = useShellExec;
			Process.Start(startInfo);
		}

		public static void RestartApp()
		{
			try
			{
				if(App.Mutex != null)
				{
					App.Mutex.Dispose();
				}
				Application.Current.Shutdown();
				StartProcess(App.LauncherExeName, string.Join(" ", App.CommandLineArgs), App.LauncherRootPath, true);
			}catch{}
		}

		public static void PlaySound(Stream sound)
		{
			if(!App.DisableSounds)
			{
				try
				{
					new SoundPlayer(sound).Play();
				}catch{}
			}
		}

		// https://stackoverflow.com/a/10520086/7570821
		public static string CalculateMD5(string filename)
		{
			using(var md5 = MD5.Create())
			{
				using(var stream = File.OpenRead(filename))
				{
					return BitConverter.ToString(md5.ComputeHash(stream)).Replace("-", string.Empty);
				}
			}
		}

		// https://stackoverflow.com/a/49535675/7570821
		public static string ToBytesCount(long bytes)
		{
			int unit = 1024;
			string unitStr = App.TextStrings["byte_short"];
			if(bytes < unit) return string.Format("{0} {1}", bytes, unitStr);
			else unitStr = unitStr.ToUpper();
			int exp = (int)(Math.Log(bytes) / Math.Log(unit));
			return string.Format("{0:##.##} {1}{2}", bytes / Math.Pow(unit, exp), App.TextStrings["binary_prefixes"][exp - 1], unitStr);
		}

		public static string GetWindowsVersion()
		{
			var key = Registry.LocalMachine.OpenSubKey(@"SOFTWARE\Microsoft\Windows NT\CurrentVersion");
			string name = "Windows Unknown";
			string version = string.Empty;
			int build = 0;
			int revision = 0;
			try
			{
				var value = key.GetValue("ProductName").ToString();
				if(!string.IsNullOrEmpty(value))
				{
					name = value;
				}
			}catch{}
			try
			{
				var value = key.GetValue("DisplayVersion").ToString();
				if(!string.IsNullOrEmpty(value))
				{
					version = value;
				}
			}catch{}
			try
			{
				var value = key.GetValue("CurrentBuild").ToString();
				if(!string.IsNullOrEmpty(value))
				{
					build = int.Parse(value);
				}
			}catch{}
			try
			{
				var value = key.GetValue("UBR").ToString();
				if(!string.IsNullOrEmpty(value))
				{
					revision = int.Parse(value);
				}
			}catch{}
			if(build >= 22000)
			{
				int index = name.IndexOf("10");
				if(index > 0)
				{
					name = name.Remove(index, 2).Insert(index, "11");
				}
			}
			if(Environment.OSVersion.Version.Major == 10)
			{
				if(!string.IsNullOrEmpty(version))
				{
					return $"{name} (Version {version}, Build {build}.{revision})";
				}
				else
				{
					return $"{name} (Build {build}.{revision})";
				}
			}
			else
			{
				return $"{name} (Build {build})";
			}
		}

		public static string GetCNotatedStringPath(string path)
		{
			var path_array = path.Split('/');
			for(int i = 0; i < path_array.Length; i++)
			{
				bool skip = true;
				foreach(char chr in path_array[i])
				{
					if(chr > sbyte.MaxValue)
					{
						skip = false;
						break;
					}
				}
				if(!skip)
				{
					string dir = string.Empty;
					foreach(char chr in path_array[i])
					{
						if(chr == '\0')
						{
							continue;
						}
						dir = dir.Insert(dir.Length, "\\x").Insert(dir.Length + 2, BitConverter.ToString(Encoding.BigEndianUnicode.GetBytes(chr.ToString())).Replace("-", string.Empty).TrimStart('0').ToLower());
					}
					path_array[i] = dir;
				}
			}
			return string.Join("/", path_array);
		}

		public static MenuItem GetMenuItem(dynamic menu, string name)
		{
			foreach(dynamic item in menu)
			{
				if(item.GetType() == typeof(MenuItem) && item.Header.ToString() == name)
				{
					return item;
				}
			}
			return null;
		}

		public static bool IsFileLocked(FileInfo file)
		{
			try
			{
				using(FileStream stream = file.Open(FileMode.Open, FileAccess.Read, FileShare.None))
				{
					stream.Close();
				}
			}
			catch(FileNotFoundException)
			{
				return false;
			}
			catch(IOException)
			{
				return true;
			}
			return false;
		}
		public static HttpWebRequest CreateWebRequest(string url, string method = "GET", int timeout = 10000)
		{
			var webRequest = (HttpWebRequest)WebRequest.Create(url);
			webRequest.Method = method;
			webRequest.UserAgent = App.UserAgent;
			webRequest.Headers.Add("Accept-Language", App.LauncherLanguage);
			webRequest.Timeout = timeout;
			return webRequest;
		}

		public static void WriteToRegistry(string name, dynamic value, RegistryValueKind valueKind = RegistryValueKind.Unknown)
		{
			App.LauncherRegKey.SetValue(name, value, valueKind);
			App.LauncherRegKey.Close();
			App.LauncherRegKey = Registry.CurrentUser.OpenSubKey(@"SOFTWARE\Bp\Better HI3 Launcher", true);
		}

		public static void DeleteFromRegistry(string name)
		{
			if(App.LauncherRegKey.GetValue(name) != null)
			{
				App.LauncherRegKey.DeleteValue(name);
				App.LauncherRegKey.Close();
				App.LauncherRegKey = Registry.CurrentUser.OpenSubKey(@"SOFTWARE\Bp\Better HI3 Launcher", true);
			}
		}
	}

	// https://stackoverflow.com/a/42725580/7570821
	public class DownloadProgressTracker
	{
		private long _totalFileSize;
		private readonly int _sampleSize;
		private readonly TimeSpan _valueDelay;

		private DateTime _lastUpdateCalculated;
		private long _previousProgress;

		private double _cachedSpeed;

		private Queue<Tuple<DateTime, long>> _changes = new Queue<Tuple<DateTime, long>>();

		public DownloadProgressTracker(int sampleSize, TimeSpan valueDelay)
		{
			_lastUpdateCalculated = DateTime.Now;
			_sampleSize = sampleSize;
			_valueDelay = valueDelay;
		}

		public void NewFile()
		{
			_previousProgress = 0;
		}

		public void SetProgress(long bytesReceived, long totalBytesToReceive)
		{
			_totalFileSize = totalBytesToReceive;

			long diff = bytesReceived - _previousProgress;
			if(diff <= 0)
			{
				return;
			}

			_previousProgress = bytesReceived;

			_changes.Enqueue(new Tuple<DateTime, long>(DateTime.Now, diff));
			while(_changes.Count > _sampleSize)
			{
				_changes.Dequeue();
			}
		}

		public double GetProgress()
		{
			return _previousProgress / (double)_totalFileSize;
		}

		public string GetProgressString()
		{
			return string.Format("{0:P0}", GetProgress());
		}

		public string GetBytesPerSecondString()
		{
			double speed = GetBytesPerSecond();
			string[] prefix;
			switch(App.OSLanguage)
			{
				case "ru-RU":
				case "uk-UA":
				case "be-BY":
					prefix = new[]{"", "К", "М", "Г"};
					break;
				default:
					prefix = new[]{"", "K", "M", "G"};
					break;
			}

			int index = 0;
			while(speed > 1024 && index < prefix.Length - 1)
			{
				speed /= 1024;
				index++;
			}

			int intLen = ((int)speed).ToString().Length;
			int decimals = 3 - intLen;
			if(decimals < 0)
			{
				decimals = 0;
			}

			string format = string.Format("{{0:F{0}}}", decimals) + " {1}" + App.TextStrings["bytes_per_second"];

			return string.Format(format, speed, prefix[index]);
		}

		public double GetBytesPerSecond()
		{
			if(DateTime.Now >= _lastUpdateCalculated + _valueDelay)
			{
				_lastUpdateCalculated = DateTime.Now;
				_cachedSpeed = GetRateInternal();
			}

			return _cachedSpeed;
		}

		private double GetRateInternal()
		{
			if(_changes.Count == 0)
			{
				return 0;
			}

			TimeSpan timespan = _changes.Last().Item1 - _changes.First().Item1;
			long bytes = _changes.Sum(t => t.Item2);

			double rate = bytes / timespan.TotalSeconds;

			if(double.IsInfinity(rate) || double.IsNaN(rate))
			{
				return 0;
			}

			return rate;
		}
	}

	// https://stackoverflow.com/a/62039306/7570821
	public class DownloadPauseable
	{
		private volatile bool _allowedToRun;
		private readonly string _sourceUrl;
		private readonly string _destination;
		private readonly int _chunkSize;
		private readonly IProgress<double> _progress;
		private readonly Lazy<long> _contentLength;

		public long BytesWritten {get; private set;}
		public long ContentLength => _contentLength.Value;

		public bool Done => ContentLength == BytesWritten;

		public DownloadPauseable(string source, string destination, int chunkSizeInBytes = 8192, IProgress<double> progress = null)
		{
			if(string.IsNullOrEmpty(source) || string.IsNullOrEmpty(destination))
				throw new ArgumentNullException();

			_allowedToRun = true;
			_sourceUrl = source;
			_destination = destination;
			_chunkSize = chunkSizeInBytes;
			_contentLength = new Lazy<long>(GetContentLength);
			_progress = progress;

			if(!File.Exists(destination))
				BytesWritten = 0;
			else
			{
				try
				{
					BytesWritten = new FileInfo(destination).Length;
				}
				catch
				{
					BytesWritten = 0;
				}
			}
		}

		private long GetContentLength()
		{
			var request = (HttpWebRequest)WebRequest.Create(_sourceUrl);
			request.Method = "HEAD";
			request.UserAgent = App.UserAgent;
			request.Headers.Add("Accept-Language", App.LauncherLanguage);

			using(var response = request.GetResponse())
				return response.ContentLength;
		}

		private async Task Start(long range)
		{
			if(!_allowedToRun)
				throw new InvalidOperationException();

			if(Done)
				//file has been found in folder destination and is already fully downloaded 
				return;

			var request = (HttpWebRequest)WebRequest.Create(_sourceUrl);
			request.UserAgent = App.UserAgent;
			request.Headers.Add("Accept-Language", App.LauncherLanguage);
			request.AddRange(range);

			using(var response = await request.GetResponseAsync())
			{
				using(var responseStream = response.GetResponseStream())
				{
					using(var fs = new FileStream(_destination, FileMode.Append, FileAccess.Write, FileShare.ReadWrite))
					{
						while(_allowedToRun)
						{
							var buffer = new byte[_chunkSize];
							var bytesRead = await responseStream.ReadAsync(buffer, 0, buffer.Length).ConfigureAwait(false);

							if(bytesRead == 0) break;

							await fs.WriteAsync(buffer, 0, bytesRead);
							BytesWritten += bytesRead;
							_progress?.Report((double)BytesWritten / ContentLength);
						}

						await fs.FlushAsync();
					}
				}
			}
		}

		public Task Start()
		{
			_allowedToRun = true;
			return Start(BytesWritten);
		}

		public void Pause()
		{
			_allowedToRun = false;
		}
	}

	public class BpWebClient : WebClient
	{
		public int Timeout {get; set;}

		public BpWebClient()
		{
			Encoding = Encoding.UTF8;
			Timeout = 10000;
			Headers.Set(HttpRequestHeader.UserAgent, App.UserAgent);
			Headers.Set(HttpRequestHeader.AcceptLanguage, App.LauncherLanguage);
		}

		protected override WebRequest GetWebRequest(Uri address)
		{
			var webRequest = base.GetWebRequest(address);
			webRequest.Timeout = Timeout;
			return webRequest;
		}
	}

	// https://stackoverflow.com/a/23047288/7570821
	public class Arc : Shape
	{
		public double StartAngle
		{
			get { return (double)GetValue(StartAngleProperty); }
			set { SetValue(StartAngleProperty, value); }
		}

		// Using a DependencyProperty as the backing store for StartAngle.  This enables animation, styling, binding, etc...
		public static readonly DependencyProperty StartAngleProperty =
			DependencyProperty.Register("StartAngle", typeof(double), typeof(Arc), new UIPropertyMetadata(0.0, new PropertyChangedCallback(UpdateArc)));

		public double EndAngle
		{
			get { return (double)GetValue(EndAngleProperty); }
			set { SetValue(EndAngleProperty, value); }
		}

		// Using a DependencyProperty as the backing store for EndAngle.  This enables animation, styling, binding, etc...
		public static readonly DependencyProperty EndAngleProperty =
			DependencyProperty.Register("EndAngle", typeof(double), typeof(Arc), new UIPropertyMetadata(90.0, new PropertyChangedCallback(UpdateArc)));

		//This controls whether or not the progress bar goes clockwise or counterclockwise
		public SweepDirection Direction
		{
			get { return (SweepDirection)GetValue(DirectionProperty); }
			set { SetValue(DirectionProperty, value); }
		}

		public static readonly DependencyProperty DirectionProperty =
			DependencyProperty.Register("Direction", typeof(SweepDirection), typeof(Arc),
				new UIPropertyMetadata(SweepDirection.Clockwise));

		//rotate the start/endpoint of the arc a certain number of degree in the direction
		//ie. if you wanted it to be at 12:00 that would be 270 Clockwise or 90 counterclockwise
		public double OriginRotationDegrees
		{
			get { return (double)GetValue(OriginRotationDegreesProperty); }
			set { SetValue(OriginRotationDegreesProperty, value); }
		}

		public static readonly DependencyProperty OriginRotationDegreesProperty =
			DependencyProperty.Register("OriginRotationDegrees", typeof(double), typeof(Arc),
				new UIPropertyMetadata(270.0, new PropertyChangedCallback(UpdateArc)));

		protected static void UpdateArc(DependencyObject d, DependencyPropertyChangedEventArgs e)
		{
			Arc arc = d as Arc;
			arc.InvalidateVisual();
		}

		protected override Geometry DefiningGeometry
		{
			get { return GetArcGeometry(); }
		}

		protected override void OnRender(System.Windows.Media.DrawingContext drawingContext)
		{
			drawingContext.DrawGeometry(null, new Pen(Stroke, StrokeThickness), GetArcGeometry());
		}

		private Geometry GetArcGeometry()
		{
			Point startPoint = PointAtAngle(Math.Min(StartAngle, EndAngle), Direction);
			Point endPoint = PointAtAngle(Math.Max(StartAngle, EndAngle), Direction);

			Size arcSize = new Size(Math.Max(0, (RenderSize.Width - StrokeThickness) / 2),
				Math.Max(0, (RenderSize.Height - StrokeThickness) / 2));
			bool isLargeArc = Math.Abs(EndAngle - StartAngle) > 180;

			StreamGeometry geom = new StreamGeometry();
			using(StreamGeometryContext context = geom.Open())
			{
				context.BeginFigure(startPoint, false, false);
				context.ArcTo(endPoint, arcSize, 0, isLargeArc, Direction, true, false);
			}
			geom.Transform = new TranslateTransform(StrokeThickness / 2, StrokeThickness / 2);
			return geom;
		}

		private Point PointAtAngle(double angle, SweepDirection sweep)
		{
			double translatedAngle = angle + OriginRotationDegrees;
			double radAngle = translatedAngle * (Math.PI / 180);
			double xr = (RenderSize.Width - StrokeThickness) / 2;
			double yr = (RenderSize.Height - StrokeThickness) / 2;

			double x = xr + xr * Math.Cos(radAngle);
			double y = yr * Math.Sin(radAngle);

			if(sweep == SweepDirection.Counterclockwise)
			{
				y = yr - y;
			}
			else
			{
				y = yr + y;
			}

			return new Point(x, y);
		}
	}

	// https://github.com/scottrippey/Progression/blob/master/Progression/Extras/ETACalculator.cs
	public interface IETACalculator
	{
		/// <summary> Clears all collected data.
		/// </summary>
		void Reset();

		/// <summary> Updates the current progress.
		/// </summary>
		/// <param name="progress">The current level of completion.
		/// Must be between 0.0 and 1.0 (inclusively).</param>
		void Update(float progress);

		/// <summary> Returns True when there is enough data to calculate the ETA.
		/// Returns False if the ETA is still calculating.
		/// </summary>
		bool ETAIsAvailable {get;}

		/// <summary> Calculates the Estimated Time of Arrival (Completion)
		/// </summary>
		DateTime ETA {get;}

		/// <summary> Calculates the Estimated Time Remaining.
		/// </summary>
		TimeSpan ETR {get;}
	}

	/// <summary> Calculates the "Estimated Time of Arrival"
	/// (or more accurately, "Estimated Time of Completion"),
	/// based on a "rolling average" of progress over time.
	/// </summary>
	public class ETACalculator : IETACalculator
	{
		/// <summary>
		/// </summary>
		/// <param name="minimumData">
		/// The minimum number of data points required before ETA can be calculated.
		/// </param>
		/// <param name="maximumDuration">
		/// Determines how many seconds of data will be used to calculate the ETA.
		/// </param>
		public ETACalculator(int minimumData = 1, double maximumDuration = 1)
		{
			this.minimumData = minimumData;
			this.maximumTicks = (long)(maximumDuration * Stopwatch.Frequency);
			this.queue = new Queue<ProgressItem>(minimumData * 2);
			this.timer = Stopwatch.StartNew();
		}

		private int minimumData;
		private long maximumTicks;
		private readonly Stopwatch timer;
		private readonly Queue<ProgressItem> queue;

		private ProgressItem current;
		private ProgressItem oldest;

		public void Reset()
		{
			queue.Clear();

			timer.Reset();
			timer.Start();
		}

		private void ClearExpired()
		{
			var expired = timer.ElapsedTicks - this.maximumTicks;
			while(queue.Count > this.minimumData && queue.Peek().Key < expired)
			{
				this.oldest = queue.Dequeue();
			}
		}

		/// <summary> Adds the current progress to the calculation of ETA.
		/// </summary>
		/// <param name="progress">The current level of completion.
		/// Must be between 0.0 and 1.0 (inclusively).</param>
		public void Update(float progress)
		{
			// If progress hasn't changed, ignore:
			if(this.current.Value == progress)
			{
				return;
			}

			// Clear space for this item:
			ClearExpired();

			// Queue this item:
			long currentTicks = timer.ElapsedTicks;
			this.current = new ProgressItem(currentTicks, progress);
			this.queue.Enqueue(this.current);

			// See if its the first item:
			if(this.queue.Count == 1)
			{
				this.oldest = this.current;
			}
		}

		/// <summary> Calculates the Estimated Time Remaining
		/// </summary>
		public TimeSpan ETR
		{
			get
			{
				// Create local copies of the oldest & current,
				// so that another thread can update them without locking:
				var oldest = this.oldest;
				var current = this.current;

				// Make sure we have enough items:
				if(queue.Count < this.minimumData || oldest.Value == current.Value)
				{
					return TimeSpan.MaxValue;
				}

				// Calculate the estimated finished time:
				double finishedInTicks = (1.0d - current.Value) * (current.Key - oldest.Key) / (current.Value - oldest.Value);

				return TimeSpan.FromSeconds(finishedInTicks / Stopwatch.Frequency);
			}
		}

		/// <summary> Calculates the Estimated Time of Arrival (Completion)
		/// </summary>
		public DateTime ETA
		{
			get
			{
				return DateTime.Now.Add(ETR);
			}
		}

		/// <summary> Returns True when there is enough data to calculate the ETA.
		/// Returns False if the ETA is still calculating.
		/// </summary>
		public bool ETAIsAvailable
		{
			get
			{
				// Make sure we have enough items:
				return (queue.Count >= this.minimumData && oldest.Value != current.Value);
			}
		}
	}

	public class ProgressToAngleConverter : System.Windows.Data.IMultiValueConverter
	{
		public object Convert(object[] values, Type targetType, object parameter, System.Globalization.CultureInfo culture)
		{
			double progress = (double)values[0];
			System.Windows.Controls.ProgressBar bar = values[1] as System.Windows.Controls.ProgressBar;
			return 359.999 * (progress / (bar.Maximum - bar.Minimum));
		}

		public object[] ConvertBack(object value, Type[] targetTypes, object parameter, System.Globalization.CultureInfo culture)
		{
			throw new NotImplementedException();
		}
	}

	#if DEBUG
	// https://stackoverflow.com/a/48864902/7570821
	static class WinConsole
	{
		static public void Initialize(bool alwaysCreateNewConsole = true)
		{
			bool consoleAttached = true;
			if (alwaysCreateNewConsole
				|| (AttachConsole(ATTACH_PARRENT) == 0
				&& Marshal.GetLastWin32Error() != ERROR_ACCESS_DENIED))
			{
				consoleAttached = AllocConsole() != 0;
			}

			if (consoleAttached)
			{
				InitializeOutStream();
				InitializeInStream();
			}
		}

		private static void InitializeOutStream()
		{
			var fs = CreateFileStream("CONOUT$", GENERIC_WRITE, FILE_SHARE_WRITE, FileAccess.Write);
			if (fs != null)
			{
				var writer = new StreamWriter(fs) {AutoFlush = true};
				Console.SetOut(writer);
				Console.SetError(writer);
			}
		}

		private static void InitializeInStream()
		{
			var fs = CreateFileStream("CONIN$", GENERIC_READ, FILE_SHARE_READ, FileAccess.Read);
			if (fs != null)
			{
				Console.SetIn(new StreamReader(fs));
			}
		}

		private static FileStream CreateFileStream(string name, uint win32DesiredAccess, uint win32ShareMode, FileAccess dotNetFileAccess)
		{
			var file = new Microsoft.Win32.SafeHandles.SafeFileHandle(CreateFileW(name, win32DesiredAccess, win32ShareMode, IntPtr.Zero, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, IntPtr.Zero), true);
			if (!file.IsInvalid)
			{
				var fs = new FileStream(file, dotNetFileAccess);
				return fs;
			}
			return null;
		}

		#region Win API Functions and Constants
		[DllImport("kernel32.dll",
			EntryPoint = "AllocConsole",
			SetLastError = true,
			CharSet = CharSet.Auto,
			CallingConvention = CallingConvention.StdCall)]
		private static extern int AllocConsole();

		[DllImport("kernel32.dll",
			EntryPoint = "AttachConsole",
			SetLastError = true,
			CharSet = CharSet.Auto,
			CallingConvention = CallingConvention.StdCall)]
		private static extern UInt32 AttachConsole(UInt32 dwProcessId);

		[DllImport("kernel32.dll",
			EntryPoint = "CreateFileW",
			SetLastError = true,
			CharSet = CharSet.Auto,
			CallingConvention = CallingConvention.StdCall)]
		private static extern IntPtr CreateFileW
		(
				string lpFileName,
				UInt32 dwDesiredAccess,
				UInt32 dwShareMode,
				IntPtr lpSecurityAttributes,
				UInt32 dwCreationDisposition,
				UInt32 dwFlagsAndAttributes,
				IntPtr hTemplateFile
		);

		private const UInt32 GENERIC_WRITE = 0x40000000;
		private const UInt32 GENERIC_READ = 0x80000000;
		private const UInt32 FILE_SHARE_READ = 0x00000001;
		private const UInt32 FILE_SHARE_WRITE = 0x00000002;
		private const UInt32 OPEN_EXISTING = 0x00000003;
		private const UInt32 FILE_ATTRIBUTE_NORMAL = 0x80;
		private const UInt32 ERROR_ACCESS_DENIED = 5;

		private const UInt32 ATTACH_PARRENT = 0xFFFFFFFF;

		#endregion
	}
	#endif
}
```

`Utility/DownloadProgressEvents.cs`:

```cs
using System;
using System.Diagnostics;
using System.Windows;
using System.Windows.Shell;
using Hi3Helper.Http;

namespace BetterHI3Launcher
{
	public partial class MainWindow : Window
	{
		float RefreshRate = 250f;
		Stopwatch LastTimeSpan = Stopwatch.StartNew();
		private void DownloadStatusChanged(object sender, DownloadEvent e)
		{
			if (LastTimeSpan.Elapsed.TotalMilliseconds >= RefreshRate)
			{
				Dispatcher.Invoke(() =>
				{
					double DownloadPercentage = Math.Round(double.IsInfinity(e.ProgressPercentage) ? 0 : e.ProgressPercentage, 2);
					DownloadProgressBar.Value = DownloadPercentage / 100;
					TaskbarItemInfo.ProgressValue = DownloadPercentage / 100;
					DownloadETAText.Text = string.Format(App.TextStrings["progresstext_eta"], string.Format("{0:hh\\:mm\\:ss}", e.TimeLeft));
					if (e.State == MultisessionState.Merging)
					{
						DownloadProgressText.Text = $"{string.Format(App.TextStrings["label_merged"], DownloadPercentage)} ({BpUtility.ToBytesCount(e.SizeDownloaded)}/{BpUtility.ToBytesCount(e.SizeToBeDownloaded)})";
						DownloadSpeedText.Text = $"{App.TextStrings["label_merge_speed"]} {BpUtility.ToBytesCount(e.Speed)}{App.TextStrings["bytes_per_second"].Substring(1)}";
						DownloadPauseButton.Visibility = Visibility.Collapsed;
					}
					else
					{
						DownloadProgressText.Text = $"{string.Format(App.TextStrings["label_downloaded_1"], DownloadPercentage)} ({BpUtility.ToBytesCount(e.SizeDownloaded)}/{BpUtility.ToBytesCount(e.SizeToBeDownloaded)})";
						DownloadSpeedText.Text = $"{App.TextStrings["label_download_speed"]} {BpUtility.ToBytesCount(e.Speed)}{App.TextStrings["bytes_per_second"].Substring(1)}";
					}
				});
				LastTimeSpan = Stopwatch.StartNew();
			}
		}
		private void PreloadDownloadStatusChanged(object sender, DownloadEvent e)
		{
			if (LastTimeSpan.Elapsed.TotalMilliseconds >= RefreshRate)
			{
				Dispatcher.Invoke(() =>
				{
					double DownloadPercentage = Math.Round(double.IsInfinity(e.ProgressPercentage) ? 0 : e.ProgressPercentage, 2);
					PreloadCircleProgressBar.Value = DownloadPercentage / 100;
					TaskbarItemInfo.ProgressValue = DownloadPercentage / 100;
					PreloadStatusTopRightText.Text = $"{BpUtility.ToBytesCount(e.SizeDownloaded)}/{BpUtility.ToBytesCount(e.SizeToBeDownloaded)}";
					PreloadStatusMiddleRightText.Text = string.Format("{0:hh\\:mm\\:ss}", e.TimeLeft);
					PreloadStatusBottomRightText.Text = $"{BpUtility.ToBytesCount(e.Speed)}{App.TextStrings["bytes_per_second"].Substring(1)}";
                    if (e.State == MultisessionState.Merging)
                    {
						PreloadPauseButton.IsEnabled = false;
						PreloadBottomText.Text = string.Format(App.TextStrings["label_merged"], DownloadPercentage);
						PreloadStatusTopLeftText.Text = $"{App.TextStrings["label_merged"].Split(' ')[0]}:";
						PreloadStatusBottomLeftText.Text = App.TextStrings["label_merge_speed"];
					}
					else
					{
						PreloadBottomText.Text = string.Format(App.TextStrings["label_downloaded_1"], DownloadPercentage);
						PreloadStatusTopLeftText.Text = App.TextStrings["label_downloaded_2"];
						PreloadStatusBottomLeftText.Text = App.TextStrings["label_download_speed"];
					}
				});
				LastTimeSpan = Stopwatch.StartNew();
			}
		}
	}
}

```

`Utility/PartialZip/Exceptions/PartialZipFileNotFoundException.cs`:

```cs
using System;

namespace PartialZip.Exceptions
{
	public class PartialZipFileNotFoundException : Exception
	{
		public PartialZipFileNotFoundException(string msg) : base(msg) {}
	}
}
```

`Utility/PartialZip/Exceptions/PartialZipNotSupportedException.cs`:

```cs
using System;

namespace PartialZip.Exceptions
{
	public class PartialZipNotSupportedException : Exception
	{
		public PartialZipNotSupportedException(string msg) : base(msg) {}
	}
}
```

`Utility/PartialZip/Exceptions/PartialZipParsingException.cs`:

```cs
using System;

namespace PartialZip.Exceptions
{
	public class PartialZipParsingException : Exception
	{
		public PartialZipParsingException(string msg) : base(msg) {}
	}
}
```

`Utility/PartialZip/Exceptions/PartialZipUnsupportedCompressionException.cs`:

```cs
using System;

namespace PartialZip.Exceptions
{
	public class PartialZipUnsupportedCompressionException : Exception
	{
		public PartialZipUnsupportedCompressionException(string msg) : base(msg) {}
	}
}
```

`Utility/PartialZip/Models/CentralDirectoryHeader.cs`:

```cs
using PartialZip.Exceptions;
using System.Collections.Generic;
using System.IO;

namespace PartialZip.Models
{
	public struct DataProp
	{
		public ushort modifiedTime, modifiedDate;
		public ulong uncompressedSize, compressedSize, headerOffset;
		public uint diskNum;
	}

	internal class CentralDirectoryHeader
	{
		internal static uint Size => 6 * sizeof(uint) + 11 * sizeof(ushort);

		internal CentralDirectoryHeader(BinaryReader reader)
		{
			Signature = reader.ReadUInt32();
			VersionMade = reader.ReadUInt16();
			VersionNeeded = reader.ReadUInt16();
			Flags = reader.ReadUInt16();
			Compression = reader.ReadUInt16();
			ModifiedTime = reader.ReadUInt16();
			ModifiedDate = reader.ReadUInt16();
			CRC32 = reader.ReadUInt32();
			CompressedSize = reader.ReadUInt32();
			UncompressedSize = reader.ReadUInt32();
			FileNameLength = reader.ReadUInt16();
			ExtraFieldLength = reader.ReadUInt16();
			FileCommentLength = reader.ReadUInt16();
			DiskNumberStart = reader.ReadUInt16();
			InternalFileAttributes = reader.ReadUInt16();
			ExternalFileAttributes = reader.ReadUInt32();
			LocalHeaderOffset = reader.ReadUInt32();

			FileName = new string(reader.ReadChars(FileNameLength));

			if(ExtraFieldLength >= ExtendedInformationExtraField64.Size)
				ExtraField = new ExtendedInformationExtraField64(reader.ReadBytes(ExtraFieldLength));

			FileComment = new string(reader.ReadChars(FileCommentLength));
		}

		internal static IEnumerable<CentralDirectoryHeader> GetFromBuffer(byte[] buffer, ulong cdEntries)
		{
			if(buffer.Length >= EndOfCentralDirectory.Size)
			{
				using(BinaryReader reader = new BinaryReader(new MemoryStream(buffer)))
				{
					ulong entriesRead = 0;
					while(reader.BaseStream.Position + Size <= reader.BaseStream.Length && entriesRead < cdEntries)
					{
						yield return new CentralDirectoryHeader(reader);
						entriesRead++;
					}
				}
			}
			else
			{
				throw new PartialZipParsingException("Failed to parse central directory headers. The supplied buffer is too small");
			}
		}

		internal DataProp GetFileInfoStruct()
        {
			int extraIndex = 0;

			return new DataProp()
			{
				modifiedTime = (ModifiedTime == ushort.MaxValue) ? (ushort)ExtraField.ExtraField[extraIndex++] : ModifiedTime,
				modifiedDate = (ModifiedDate == ushort.MaxValue) ? (ushort)ExtraField.ExtraField[extraIndex++] : ModifiedDate,
				uncompressedSize = (UncompressedSize == uint.MaxValue) ? ExtraField.ExtraField[extraIndex++] : UncompressedSize,
				compressedSize = (CompressedSize == uint.MaxValue) ? ExtraField.ExtraField[extraIndex++] : CompressedSize,
				headerOffset = (LocalHeaderOffset == uint.MaxValue) ? ExtraField.ExtraField[extraIndex++] : LocalHeaderOffset,
				diskNum = (DiskNumberStart == ushort.MaxValue) ? (uint)ExtraField.ExtraField[extraIndex++] : DiskNumberStart
			};
        }

		internal uint Signature {get; set;}

		internal ushort VersionMade {get; set;}

		internal ushort VersionNeeded {get; set;}

		internal ushort Flags {get; set;}

		internal ushort Compression {get; set;}

		internal ushort ModifiedTime {get; set;}

		internal ushort ModifiedDate {get; set;}

		internal uint CRC32 {get; set;}

		internal uint CompressedSize {get; set;}

		internal uint UncompressedSize {get; set;}

		internal ushort FileNameLength {get; set;}

		internal ushort ExtraFieldLength {get; set;}

		internal ushort FileCommentLength {get; set;}

		internal ushort DiskNumberStart {get; set;}

		internal ushort InternalFileAttributes {get; set;}

		internal uint ExternalFileAttributes {get; set;}

		internal uint LocalHeaderOffset {get; set;}

		internal string FileName {get; set;}

		internal ExtendedInformationExtraField64 ExtraField {get; set;}

		internal string FileComment {get; set;}
	}
}
```

`Utility/PartialZip/Models/EndOfCentralDirectory.cs`:

```cs
using PartialZip.Exceptions;
using System.IO;

namespace PartialZip.Models
{
	internal class EndOfCentralDirectory
	{
		internal static uint Size => 3 * sizeof(uint) + 5 * sizeof(ushort);

		internal EndOfCentralDirectory(byte[] buffer)
		{
			if(buffer.Length >= Size)
			{
				using(BinaryReader reader = new BinaryReader(new MemoryStream(buffer)))
				{
					Signature = reader.ReadUInt32();
					DiskNumber = reader.ReadUInt16();
					StartCentralDirectoryDiskNumber = reader.ReadUInt16();
					DiskCentralDirectoryRecordCount = reader.ReadUInt16();
					CentralDirectoryRecordCount = reader.ReadUInt16();
					CentralDirectorySize = reader.ReadUInt32();
					CentralDirectoryStartOffset = reader.ReadUInt32();
					CommentLength = reader.ReadUInt16();
				}
			}
			else
			{
				throw new PartialZipParsingException("Failed to parse end of central directory. The supplied buffer is too small");
			}
		}

		internal uint Signature {get; set;}

		internal ushort DiskNumber {get; set;}

		internal ushort StartCentralDirectoryDiskNumber {get; set;}

		internal ushort DiskCentralDirectoryRecordCount {get; set;}

		internal ushort CentralDirectoryRecordCount {get; set;}

		internal uint CentralDirectorySize {get; set;}

		internal uint CentralDirectoryStartOffset {get; set;}

		internal ushort CommentLength {get; set;}

		internal bool IsZip64 => DiskNumber == ushort.MaxValue || 
			StartCentralDirectoryDiskNumber == ushort.MaxValue ||
			DiskCentralDirectoryRecordCount == ushort.MaxValue || 
			CentralDirectorySize == uint.MaxValue ||
			CentralDirectoryStartOffset == uint.MaxValue || 
			CommentLength == ushort.MaxValue;
	}
}
```

`Utility/PartialZip/Models/EndOfCentralDirectory64.cs`:

```cs
using PartialZip.Exceptions;
using System.IO;

namespace PartialZip.Models
{
	internal class EndOfCentralDirectory64
	{
		internal static uint Size => 5 * sizeof(ulong) + 3 * sizeof(uint) + 2 * sizeof(ushort);

		internal EndOfCentralDirectory64(byte[] buffer)
		{
			if(buffer.Length >= Size)
			{
				using(BinaryReader reader = new BinaryReader(new MemoryStream(buffer)))
				{
					Signature = reader.ReadUInt32();
					EndOfCentralDirectoryRecordSize = reader.ReadUInt64();
					VersionMadeBy = reader.ReadUInt16();
					VersionNeeded = reader.ReadUInt16();
					DiskNumber = reader.ReadUInt32();
					StartCentralDirectoryDiskNumber = reader.ReadUInt32();
					DiskCentralDirectoryRecordCount = reader.ReadUInt64();
					CentralDirectoryRecordCount = reader.ReadUInt64();
					CentralDirectorySize = reader.ReadUInt64();
					CentralDirectoryStartOffset = reader.ReadUInt64();
				}
			}
			else
			{
				throw new PartialZipParsingException("Failed to parse end of ZIP64 central directory. The supplied buffer is too small");
			}
		}

		internal uint Signature {get; set;}

		internal ulong EndOfCentralDirectoryRecordSize {get; set;}

		internal ushort VersionMadeBy {get; set;}

		internal ushort VersionNeeded {get; set;}

		internal uint DiskNumber {get; set;}

		internal uint StartCentralDirectoryDiskNumber {get; set;}

		internal ulong DiskCentralDirectoryRecordCount {get; set;}

		internal ulong CentralDirectoryRecordCount {get; set;}

		internal ulong CentralDirectorySize {get; set;}

		internal ulong CentralDirectoryStartOffset {get; set;}
	}
}
```

`Utility/PartialZip/Models/EndOfCentralDirectoryLocator64.cs`:

```cs
using PartialZip.Exceptions;
using System.IO;

namespace PartialZip.Models
{
	internal class EndOfCentralDirectoryLocator64
	{
		internal static uint Size => 3 * sizeof(uint) + 1 * sizeof(ulong);

		internal EndOfCentralDirectoryLocator64(byte[] buffer)
		{
			if(buffer.Length >= Size)
			{
				using(BinaryReader reader = new BinaryReader(new MemoryStream(buffer)))
				{
					Signature = reader.ReadUInt32();
					StartCentralDirectory64DiskNumber = reader.ReadUInt32();
					EndOfCentralDirectory64StartOffset = reader.ReadUInt64();
					DiskCount = reader.ReadUInt32();
				}
			}
			else
			{
				throw new PartialZipParsingException("Failed to parse end of ZIP64 central directory locator. The supplied buffer is too small");
			}
		}

		internal uint Signature {get; set;}

		internal uint StartCentralDirectory64DiskNumber {get; set;}

		internal ulong EndOfCentralDirectory64StartOffset {get; set;}

		internal uint DiskCount {get; set;}
	}
}
```

`Utility/PartialZip/Models/ExtendedInformationExtraField64.cs`:

```cs
using PartialZip.Exceptions;
using System.IO;

namespace PartialZip.Models
{
	internal class ExtendedInformationExtraField64
	{
		internal static uint Size => 2 * sizeof(ushort);

		internal ExtendedInformationExtraField64(byte[] buffer)
		{
			if(buffer.Length >= Size)
			{
				using(BinaryReader reader = new BinaryReader(new MemoryStream(buffer)))
				{
					FieldTag = reader.ReadUInt16();
					FieldSize = reader.ReadUInt16();

					ExtraField = new ulong[(reader.BaseStream.Length - reader.BaseStream.Position) / sizeof(ulong)];

					for(int i = 0; i < ExtraField.Length; i++)
						ExtraField[i] = reader.ReadUInt64();
				}
			}
			else
			{
				throw new PartialZipParsingException("Failed to parse ZIP64 extended information field. The supplied buffer is too small");
			}
		}

		internal ushort FieldTag {get; set;}

		internal ushort FieldSize {get; set;}

		internal ulong[] ExtraField {get; set;}
	}
}
```

`Utility/PartialZip/Models/LocalFileHeader.cs`:

```cs
using PartialZip.Exceptions;
using System.IO;

namespace PartialZip.Models
{
	internal class LocalFileHeader
	{
		internal static uint Size => 4 * sizeof(uint) + 7 * sizeof(ushort);

		internal LocalFileHeader(byte[] buffer)
		{
			if(buffer.Length >= Size)
			{
				using (BinaryReader reader = new BinaryReader(new MemoryStream(buffer)))
				{
					Signature = reader.ReadUInt32();
					VersionNeeded = reader.ReadUInt16();
					Flags = reader.ReadUInt16();
					Compression = reader.ReadUInt16();
					ModifiedTime = reader.ReadUInt16();
					ModifiedDate = reader.ReadUInt16();
					CRC32 = reader.ReadUInt32();
					CompressedSize = reader.ReadUInt32();
					UncompressedSize = reader.ReadUInt32();
					FileNameLength = reader.ReadUInt16();
					ExtraFieldLength = reader.ReadUInt16();
				}
			}
			else
			{
				throw new PartialZipParsingException("Failed to parse local file header. The supplied buffer is too small");
			}
		}

		internal uint Signature {get; set;}

		internal ushort VersionNeeded {get; set;}

		internal ushort Flags {get; set;}

		internal ushort Compression {get; set;}

		internal ushort ModifiedTime {get; set;}

		internal ushort ModifiedDate {get; set;}

		internal uint CRC32 {get; set;}

		internal uint CompressedSize {get; set;}

		internal uint UncompressedSize {get; set;}

		internal ushort FileNameLength {get; set;}

		internal ushort ExtraFieldLength {get; set;}
	}
}
```

`Utility/PartialZip/Models/PartialZipInfo.cs`:

```cs
using System.Collections.Generic;

namespace PartialZip.Models
{
	public class PartialZipInfo
	{
		internal ulong Length {get; set;}

		internal ulong CentralDirectoryEntries {get; set;}

		internal EndOfCentralDirectory EndOfCentralDirectory {get; set;}

		internal EndOfCentralDirectory64 EndOfCentralDirectory64 {get; set;}

		internal EndOfCentralDirectoryLocator64 EndOfCentralDirectoryLocator64 {get; set;}

		internal IEnumerable<CentralDirectoryHeader> CentralDirectory {get; set;}
	}
}
```

`Utility/PartialZip/PartialZipDownloader.cs`:

```cs
using PartialZip.Exceptions;
using PartialZip.Models;
using PartialZip.Services;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Threading.Tasks;

namespace PartialZip
{
	public class PartialZipDownloader
	{
		private string _archiveUrl;

		private HttpService _httpService;
		private DeflateService _deflateService;

		private PartialZipDownloader(string archiveUrl)
		{
			_archiveUrl = archiveUrl;

			_httpService = new HttpService(_archiveUrl);
			_deflateService = new DeflateService();
		}

		/// <summary>
		/// Returns a list of all filenames in the remote .zip archive
		/// </summary>
		/// <param name="archiveUrl">URL of the .zip archive</param>
		/// <returns>List of filenames</returns>
		public static async Task<IEnumerable<string>> GetFileList(string archiveUrl)
		{
			PartialZipDownloader downloader = new PartialZipDownloader(archiveUrl);
			PartialZipInfo info = await downloader.Open();

			return info.CentralDirectory.Select(cd => cd.FileName).OrderBy(f => f);
		}

		/// <summary>
		/// Downloads a specific file from a remote .zip archive
		/// </summary>
		/// <param name="archiveUrl">URL of the .zip archive</param>
		/// <param name="filePath">Path of the file in archive</param>
		/// <param name="writePath">Path where the file will be written</param>
		/// <param name="preserveTime">Preserve modification date</param>
		/// <returns>File content</returns>
		public static async Task DownloadFile(string archiveUrl, string filePath, string writePath)
		{
			PartialZipDownloader downloader = new PartialZipDownloader(archiveUrl);
			PartialZipInfo info = await downloader.Open();
			var content = await downloader.Download(info, filePath);
			File.WriteAllBytes(writePath, content.Item1);
			File.SetLastWriteTimeUtc(writePath, content.Item2);
		}

		private async Task<PartialZipInfo> Open()
		{
			bool supportsPartialZip = await _httpService.SupportsPartialZip();

			if(!supportsPartialZip)
				throw new PartialZipNotSupportedException("The web server does not support PartialZip as byte ranges are not accepted.");

			PartialZipInfo info = new PartialZipInfo();

			info.Length = await _httpService.GetContentLength();

			byte[] eocdBuffer = await _httpService.GetRange(info.Length - EndOfCentralDirectory.Size, info.Length - 1);
			info.EndOfCentralDirectory = new EndOfCentralDirectory(eocdBuffer);

			ulong startCD, endCD;

			if(info.EndOfCentralDirectory.IsZip64)
			{
				byte[] eocdLocator64Buffer = await _httpService.GetRange(info.Length - EndOfCentralDirectory.Size - EndOfCentralDirectoryLocator64.Size, info.Length - EndOfCentralDirectory.Size);
				info.EndOfCentralDirectoryLocator64 = new EndOfCentralDirectoryLocator64(eocdLocator64Buffer);

				byte[] eocd64Buffer = await _httpService.GetRange(info.EndOfCentralDirectoryLocator64.EndOfCentralDirectory64StartOffset, info.EndOfCentralDirectoryLocator64.EndOfCentralDirectory64StartOffset + EndOfCentralDirectory64.Size - 1);
				info.EndOfCentralDirectory64 = new EndOfCentralDirectory64(eocd64Buffer);

				startCD = info.EndOfCentralDirectory64.CentralDirectoryStartOffset;
				endCD = info.EndOfCentralDirectory64.CentralDirectoryStartOffset + info.EndOfCentralDirectory64.CentralDirectorySize + EndOfCentralDirectory64.Size - 1;
				info.CentralDirectoryEntries = info.EndOfCentralDirectory64.CentralDirectoryRecordCount;
			}
			else
			{
				startCD = info.EndOfCentralDirectory.CentralDirectoryStartOffset;
				endCD = info.EndOfCentralDirectory.CentralDirectoryStartOffset + info.EndOfCentralDirectory.CentralDirectorySize + EndOfCentralDirectory.Size - 1;
				info.CentralDirectoryEntries = info.EndOfCentralDirectory.CentralDirectoryRecordCount;
			}

			byte[] cdBuffer = await _httpService.GetRange(startCD, endCD);
			info.CentralDirectory = CentralDirectoryHeader.GetFromBuffer(cdBuffer, info.CentralDirectoryEntries);

			return info;
		}

		private async Task<Tuple<byte[], DateTime>> Download(PartialZipInfo info, string filePath)
		{
			CentralDirectoryHeader cd = info.CentralDirectory.FirstOrDefault(c => c.FileName == filePath);
			DataProp dataProp;

			if(cd != null)
			{
				dataProp = cd.GetFileInfoStruct();

				byte[] localFileBuffer = await _httpService.GetRange(dataProp.headerOffset, dataProp.headerOffset + LocalFileHeader.Size - 1);
				LocalFileHeader localFileHeader = new LocalFileHeader(localFileBuffer);

				ulong start = dataProp.headerOffset + LocalFileHeader.Size + localFileHeader.FileNameLength + localFileHeader.ExtraFieldLength;
				byte[] compressedContent = await _httpService.GetRange(start, start + dataProp.compressedSize - 1);

				var dateTimeModified = ConvertDOSDateTime(dataProp.modifiedDate, dataProp.modifiedTime);

				switch(localFileHeader.Compression)
				{
					case 0:
						return Tuple.Create(compressedContent, dateTimeModified);
					case 8:
						return Tuple.Create(_deflateService.Inflate(compressedContent), dateTimeModified);
					default:
						throw new PartialZipUnsupportedCompressionException("Unknown compression.");
				}
			}

			throw new PartialZipFileNotFoundException($"Could not find file in archive.");
		}

		internal struct Systime
		{
			internal ushort Year;
			internal ushort Month;
			internal ushort DayOfWeek;
			internal ushort Day;
			internal ushort Hour;
			internal ushort Minute;
			internal ushort Second;
			internal ushort Milliseconds;
		}

		internal struct FileTime
		{
			internal uint dwLowDateTime;
			internal uint dwHighDateTime;
		}

		[DllImport("Kernel32.dll", CharSet = CharSet.Ansi)]
		private static extern bool DosDateTimeToFileTime(ushort wFatDate, ushort wFatTime, ref FileTime lpFileTime);
		[DllImport("Kernel32.dll", CharSet = CharSet.Ansi)]
		private static extern bool FileTimeToSystemTime(ref FileTime lpFileTime, ref Systime lpSystemTime);

		private static DateTime ConvertDOSDateTime(ushort date, ushort time)
		{
			FileTime fileTime = new FileTime();
			Systime systemTime = new Systime();

			DosDateTimeToFileTime(date, time, ref fileTime);
			FileTimeToSystemTime(ref fileTime, ref systemTime);

			return new DateTime(systemTime.Year, systemTime.Month, systemTime.Day, systemTime.Hour, systemTime.Minute, systemTime.Second + 1, DateTimeKind.Utc).AddHours(-3);
		}
	}
}
```

`Utility/PartialZip/Services/DeflateService.cs`:

```cs
using System.IO;
using System.IO.Compression;

namespace PartialZip.Services
{
	internal class DeflateService
	{
		internal byte[] Inflate(byte[] buffer)
		{
			using(MemoryStream input = new MemoryStream(buffer))
			{
				using(MemoryStream output = new MemoryStream())
				{
					using(DeflateStream deflate = new DeflateStream(input, CompressionMode.Decompress))
					{
						deflate.CopyTo(output);
						deflate.Close();
						output.Position = 0;
						return output.ToArray();
					}
				}
			}
		}
	}
}
```

`Utility/PartialZip/Services/HttpService.cs`:

```cs
using BetterHI3Launcher;
using System;
using System.IO;
using System.Net;
using System.Threading.Tasks;

namespace PartialZip.Services
{
	internal class HttpService
	{
		private string _url;

		private Task<WebHeaderCollection> _contentHeaders;

		internal HttpService(string url)
		{
			_url = url;
			_contentHeaders = GetContentInfo();
		}

		internal async Task<ulong> GetContentLength()
		{
			WebHeaderCollection headers = await _contentHeaders;
			return ulong.Parse(headers.Get("Content-Length"));
		}

		internal async Task<bool> SupportsPartialZip()
		{
			WebHeaderCollection headers = await _contentHeaders;
			return headers.Get("Accept-Ranges") == "bytes";
		}

		private async Task<WebHeaderCollection> GetContentInfo()
		{
			HttpWebRequest request = WebRequest.CreateHttp(_url);
			request.AllowAutoRedirect = true;
			request.KeepAlive = true;
			request.Method = "HEAD";
			request.UserAgent = App.UserAgent;

			using(WebResponse response = await request.GetResponseAsync())
			{
				return response.Headers;
			}
		}

		internal async Task<byte[]> GetRange(ulong startBytes, ulong endBytes)
		{
			if(startBytes < endBytes)
			{
				HttpWebRequest request = WebRequest.CreateHttp(_url);
				request.AllowAutoRedirect = true;
				request.KeepAlive = true;
				request.AddRange((long)startBytes, (long)endBytes);
				request.Method = "GET";
				request.UserAgent = App.UserAgent;

				using(WebResponse response = await request.GetResponseAsync())
				{
					using(Stream responseStream = response.GetResponseStream())
					{
						using(MemoryStream output = new MemoryStream())
						{
							await responseStream.CopyToAsync(output);
							return output.ToArray();
						}
					}
				}
			}
			else
			{
				throw new Exception("Invalid byte range.");
			}
		}
	}
}
```

`Utility/miHoYoCRCUtility.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Security.Cryptography;
using System.Text;
using System.Xml;

namespace BetterHI3Launcher
{
	// source: https://github.com/neon-nyan/CollapseLauncher/blob/main/Hi3HelperCore/Classes/Data/Tools/mhySHASaltTool.cs
	public class miHoYoCRCUtility
	{
		protected string _778;
		protected HMACSHA1 sha;
		protected RSA _ooh;
		protected const string _ = @"D4F8D4A6F6CF9AD4E78FF4E1D696CA88D9DF8FF7F5DDF3DC87E1D08A8598A9D1DED7D4DD81C2EC938FECB0E8F493B2F4B2DBD39FC99CA2FBCCD3DBE190E2F494EEDEBAE7F5A0C7F1BDE5EAA3FFD888B2E89BD1D0B198F5D0D2E8D7D8C5DAF5C080E2FD8AFC9CD5CFE3D6B7F383EEB3D0E79985C1C3A1E7C8AED2EAA2EBCEB6C1F0AEB0D6A1ECE3B6C5FBA0C0B1A0CCE5AEFDDFAFD2FC85C0EEADE2C0DE9AC893E5EED4B3F0A5F4F7AAE6EE88DC9CABC6CE81CAEFD0E6E380EACEB5B3B6ACD6E5AD97BBC8F0C587F7EA96F2BAD4EFFF97D2C486ECF2DDC4D5D597BBC8F8D293EDE886EFF0D696D7D98C9CA4EBF191E6C7AFDCE4BEDFCDB0D8C9A1CBD6909EC0DED6C38CC5E186F9C8BBD3D0D18FC3A8B6C396D5B4B0DFBE9FC4CC8FC0C282C2B091C5E8A1D6D291E4EA92C4C5A1C3C281E9DBADC5EABAE4CE83D9ACD2CCDDDEBFBACCD1BAD4FBB99DDBFBBAB6E2B4E8ABACC6E8D485D3D5FAF0BBB5F4BDEFC68D8CC281E7C08CAED581D3B0AF8D9AB3B2BEDAD6B4A3E9B1AAD9C3C8C5DFD7D4F1BAEDCD93DAF2D4D7DC85C6D58CE2D58D85C7A1E8EF89C7FD80FFEBD3CA97DEBEA9B2BFB8ACFAB984D4C28FCDE389F8C083CBD283D3D88DF6C3BBF7C0D8F9F1978ADC8FD7BF87FBCED0C3F2A9C781ACEDCC87D4C983E1CF8EECDEDBFBF092B9C89E99C0938DDAD1DAF5D1B1FC9BF3BE90F9C2B0EBB4BBE7E5D1CEEEB4CA97DEBEA9A7D1BAD4EED6D9FAEE91D4F1A7E5C5BFCFEE8E8AF980EEC5A5EAF7BC9CB6ABE5E98AC6C9D2D9F4BDD2D5B4ED8191FBFCB9AEF7AFE3F38FF0DD93F5F2D4DBE791C4F6AECFEBA0B2CCD4E4C59EE2CAADD0E2AAD2D686E0F0DA9EE8A2D9FBDEBFBACCC5D5D696CE89CBCF91F1E3B2BFD4DC85F180CC9BBBC4B1D4CFBCA385C89FE9C880E8D1A5C2C7D9CEAC918EFDD6FAD1B2CBE685FFB4ACDBFCA5B0F1ACD2F0B2CFCEABE998BBB3B490B6C5A0EEAC92E8CCADBBC9CCF9E0ADE8CE82CCC9B0CED09BD6EE9F97BADB92E38DF4E391F2E1B994BBA383C5D3D5F0B9C2FC9EE7E0B0D8CB97F0FF81C3F2A1DCEBB0EC9ABBB4C5AFC7DDB1CFB5928998A4DAF6AACDEF8ADAB4B7FBDF99CAF08DEAF19FC3F7C8C4EDD0B7D48FEDD7DACFE1A0D7CCABC7B68BE6C5DBC9E69DCFE484CFB084C3C08BECE6D0D4D08DF4EFAAE8D5BCD3D49FFBDF99FBB58ED9F482F9D6A1DCED84E6F08EF4D1B9E6E08088DB82EAE587C6E3BC9EB2D2FBD08CB7C1B0F4AFA1D3D397F98187CCE9A8F8B3D1E4CBB3DFDC89C7BBDFAEC0D696A8B5EEEBA8E7FFB5E0E89DCFB9";

		protected readonly Dictionary<char, byte> __951 = new Dictionary<char, byte>()
		{
			{'a', 0xA},{'b', 0xB},{'c', 0xC},{'d', 0xD},
			{'e', 0xE},{'f', 0xF},{'A', 0xA},{'B', 0xB},
			{'C', 0xC},{'D', 0xD},{'E', 0xE},{'F', 0xF},
			{'0', 0x0},{'1', 0x1},{'2', 0x2},{'3', 0x3},
			{'4', 0x4},{'5', 0x5},{'6', 0x6},{'7', 0x7},
			{'8', 0x8},{'9', 0x9}
		};

		protected readonly byte[] sKey = new byte[12]
		{
			232, 170, 135, 231,
			189, 170, 227, 130,
			134, 227, 129, 132
		};

		public miHoYoCRCUtility(string _i)
		{
			this._778 = _i;
			this._ooh = RSA.Create();
		}

		public byte[] GetSalt()
		{
			byte[] cy_a = default(byte[]);
			byte[] hR = default(byte[]);
			byte[] _0041 = default(byte[]);
			byte[] at = default(byte[]);
			while(true)
			{
				int num = -379967069;
				while(true)
				{
					uint num2;
					switch((num2 = (uint)num ^ 0xD91CA180u) % 8u)
					{
						case 0u:
							break;
						case 3u:
							cy_a = new byte[8];
							num = (int)((num2 * 265579718) ^ 0x2AB6A14D);
							continue;
						case 2u:
							num = (int)((num2 * 1194515468) ^ 0x6BE031F1);
							continue;
						case 5u:
							hR = cy_a;
							num = ((int)num2 * -1066675674) ^ 0xD7A97C;
							continue;
						case 6u:
							FromXmlStringA(in _ooh, Encoding.UTF8.GetString(_0041));
							num = (int)(num2 * 1342003605) ^ -355963254;
							continue;
						case 4u:
							Array.Copy(_ooh.Decrypt(at, RSAEncryptionPadding.Pkcs1), 48, cy_a, 0, 8);
							num = ((int)num2 * -1711149688) ^ -181350819;
							continue;
						case 7u:
							_0041 = _f8j51(_);
							at = HTb(_778);
							num = ((int)num2 * -1995578406) ^ 0x57CB1D8;
							continue;
						default:
							return hR;
					}
					break;
				}
			}
		}

		private void FromXmlStringA(in RSA rsa, string xml_string)
		{
			RSAParameters parameters = new RSAParameters();
			XmlDocument xml_doc = new XmlDocument();
			xml_doc.LoadXml(xml_string);
			if(xml_doc.DocumentElement.Name.Equals("RSAKeyValue"))
			{
				foreach(XmlNode node in xml_doc.DocumentElement.ChildNodes)
				{
					switch(node.Name)
					{
						case "Modulus": parameters.Modulus = Convert.FromBase64String(node.InnerText); break;
						case "Exponent": parameters.Exponent = Convert.FromBase64String(node.InnerText); break;
						case "P": parameters.P = Convert.FromBase64String(node.InnerText); break;
						case "Q": parameters.Q = Convert.FromBase64String(node.InnerText); break;
						case "DP": parameters.DP = Convert.FromBase64String(node.InnerText); break;
						case "DQ": parameters.DQ = Convert.FromBase64String(node.InnerText); break;
						case "InverseQ": parameters.InverseQ = Convert.FromBase64String(node.InnerText); break;
						case "D": parameters.D = Convert.FromBase64String(node.InnerText); break;
					}
				}
			}
			else
			{
				throw new CryptographicException("Invalid XML RSA key.");
			}

			rsa.ImportParameters(parameters);
		}

		private byte[] HTb(string _a)
		{
			byte[] _p49 = new byte[_a.Length / 2];
			bool f = default(bool);
			int n_94 = default(int);
			int _001 = default(int);
			while(true)
			{
				int kk1 = -1675277297;
				while(true)
				{
					uint lo_051;
					switch((lo_051 = (uint)kk1 ^ 0x8D7A7B5Fu) % 9u)
					{
						case 2u:
							break;
						case 5u:
						{
							int _0051;
							if(!f)
							{
								_0051 = -1380326733;
							}
							else
							{
								_0051 = -189009401;
							}
							kk1 = _0051 ^ (int)(lo_051 * 2073484105);
							continue;
						}
						case 3u:
							n_94 = 0;
							kk1 = (int)((lo_051 * 2059650746) ^ 0x70BDC4E2);
							continue;
						case 8u:
							char c = _a[n_94];
							char c2 = _a[n_94 + 1];
							_p49[_001] = (byte)((__951[c] << 4) | __951[c2]);
							kk1 = (int)((lo_051 * 1839013216) ^ 0x5C090E6D);
							continue;
						case 1u:
							_001 = 0;
							kk1 = (int)((lo_051 * 316152874) ^ 0x4220ABE6);
							continue;
						case 6u:
							f = n_94 < _a.Length;
							kk1 = -7386813;
							continue;
						case 0u:
							n_94 += 2;
							_001++;
							kk1 = (int)((lo_051 * 196220108) ^ 0x5B6DC890);
							continue;
						case 7u:
							kk1 = -742839246;
							continue;
						default:
							return _p49;
					}
					break;
				}
			}
		}

		private byte[] _f8j51(string c)
		{
			byte[] ar_84 = new byte[c.Length / 2];
			int _445 = default(int);
			int nud_e = default(int);
			byte[] r = default(byte[]);
			while(true)
			{
				int _Kj9a = -415293042;
				while(true)
				{
					uint _99Jm1;
					switch((_99Jm1 = (uint)_Kj9a ^ 0xD88AD053u) % 8u)
					{
						case 3u:
							break;
						case 5u:
							_445 = 0;
							nud_e = 0;
							_Kj9a = ((int)_99Jm1 * -1420181188) ^ 0x2336EBD;
							continue;
						case 2u:
							_Kj9a = ((int)_99Jm1 * -336838899) ^ -1483897312;
							continue;
						case 0u:
							nud_e++;
							_Kj9a = (int)(_99Jm1 * 1698348363) ^ -1786813222;
							continue;
						case 4u:
							r = ar_84;
							_Kj9a = (int)(_99Jm1 * 1245963323) ^ -23762559;
							continue;
						case 1u:
							if(_445 >= c.Length)
							{
								_Kj9a = -481382921;
							}
							else
							{
								_Kj9a = -1714879556;
							}
							continue;
						case 7u:
							byte b = (byte)((__951[c[_445]] << 4) | __951[c[_445 + 1]]);
							ar_84[nud_e] = (byte)(b ^ sKey[nud_e % sKey.Length]);
							_445 += 2;
							_Kj9a = -1908881005;
							continue;
						default:
							return r;
					}
					break;
				}
			}
		}
	}
}
```

`app.manifest`:

```manifest
<?xml version="1.0" encoding="utf-8"?>
<assembly manifestVersion="1.0" xmlns="urn:schemas-microsoft-com:asm.v1">
  <assemblyIdentity version="1.0.0.0" name="BetterHI3Launcher"/>
  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v2">
    <security>
      <requestedPrivileges xmlns="urn:schemas-microsoft-com:asm.v3">
        <!-- UAC Manifest Options
             If you want to change the Windows User Account Control level replace the 
             requestedExecutionLevel node with one of the following.

        <requestedExecutionLevel  level="asInvoker" uiAccess="false" />
        <requestedExecutionLevel  level="requireAdministrator" uiAccess="false" />
        <requestedExecutionLevel  level="highestAvailable" uiAccess="false" />

            Specifying requestedExecutionLevel element will disable file and registry virtualization. 
            Remove this element if your application requires this virtualization for backwards
            compatibility.
        -->
        <requestedExecutionLevel  level="requireAdministrator" uiAccess="false" />
      </requestedPrivileges>
    </security>
  </trustInfo>

  <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
    <application>
      <!-- A list of the Windows versions that this application has been tested on
           and is designed to work with. Uncomment the appropriate elements
           and Windows will automatically select the most compatible environment. -->

      <!-- Windows 10 -->
      <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}" />

      <!-- Windows 8.1 -->
      <supportedOS Id="{1f676c76-80e1-4239-95bb-83d0f6d0da78}" />

    </application>
  </compatibility>

  <!-- Enable themes for Windows common controls and dialogs (Windows XP and later) -->
  <dependency>
    <dependentAssembly>
      <assemblyIdentity
          type="win32"
          name="Microsoft.Windows.Common-Controls"
          version="6.0.0.0"
          processorArchitecture="*"
          publicKeyToken="6595b64144ccf1df"
          language="*"
        />
    </dependentAssembly>
  </dependency>

</assembly>

```