Project Path: arc_gmh5225_qsynthesis_e31qm2tk

Source Tree:

```txt
arc_gmh5225_qsynthesis_e31qm2tk
├── LICENSE
├── README.md
├── bin
│   ├── qsynthesis-table-manager
│   └── qsynthesis-table-server
├── doc
│   ├── Makefile
│   ├── api
│   │   ├── sym_exec.rst
│   │   ├── synthesis.rst
│   │   ├── table.rst
│   │   ├── tritonast.rst
│   │   └── types.rst
│   ├── api_usage.rst
│   ├── conf.py
│   ├── dev_doc
│   │   └── table.rst
│   ├── figs
│   │   ├── asts.png
│   │   ├── deps.png
│   │   ├── logo_quarkslab_Securing_Q.png
│   │   ├── main-ui-example.png
│   │   ├── popup-actions.png
│   │   ├── reass1.png
│   │   ├── reass2.png
│   │   ├── reass3.png
│   │   ├── reassembly-opts.png
│   │   ├── reassembly.drawio
│   │   └── reassembly.png
│   ├── index.rst
│   ├── installation.rst
│   ├── latexstyling.sty
│   ├── mock
│   │   ├── qtracedb
│   │   │   ├── __init__.py
│   │   │   ├── archs
│   │   │   │   ├── __init__.py
│   │   │   │   ├── arch.py
│   │   │   │   ├── arm.py
│   │   │   │   ├── arm64.py
│   │   │   │   ├── manager.py
│   │   │   │   └── x86.py
│   │   │   └── trace.py
│   │   └── triton.py
│   ├── plugin
│   │   └── plugin_usage.rst
│   └── requirements.txt
├── ida_plugin
│   └── qsynthesis_plugin.py
├── qsynthesis
│   ├── __init__.py
│   ├── algorithms
│   │   ├── __init__.py
│   │   ├── synthesizer_base.py
│   │   ├── synthesizer_plhld.py
│   │   ├── synthesizer_td.py
│   │   └── synthesizer_tdbu.py
│   ├── grammar
│   │   ├── __init__.py
│   │   ├── grammar.py
│   │   ├── jitting.py
│   │   └── ops.py
│   ├── plugin
│   │   ├── __init__.py
│   │   ├── actions.py
│   │   ├── arch.py
│   │   ├── ast_viewer.py
│   │   ├── dependencies.py
│   │   ├── popup_actions.py
│   │   ├── processor.py
│   │   ├── slicer.py
│   │   ├── ui
│   │   │   ├── Makefile
│   │   │   ├── __init__.py
│   │   │   ├── synthesis_ui.py
│   │   │   └── synthesis_view.ui
│   │   └── view.py
│   ├── tables
│   │   ├── __init__.py
│   │   ├── base.py
│   │   ├── lookuptablelvldb.py
│   │   └── lookuptablerest.py
│   ├── tritonast.py
│   ├── types.py
│   └── utils
│       ├── __init__.py
│       └── symexec.py
├── setup.py
└── tests
    └── test_fullsym.py

```

`LICENSE`:

```
                    GNU AFFERO GENERAL PUBLIC LICENSE
                       Version 3, 19 November 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU Affero General Public License is a free, copyleft license for
software and other kinds of works, specifically designed to ensure
cooperation with the community in the case of network server software.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
our General Public Licenses are intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  Developers that use our General Public Licenses protect your rights
with two steps: (1) assert copyright on the software, and (2) offer
you this License which gives you legal permission to copy, distribute
and/or modify the software.

  A secondary benefit of defending all users' freedom is that
improvements made in alternate versions of the program, if they
receive widespread use, become available for other developers to
incorporate.  Many developers of free software are heartened and
encouraged by the resulting cooperation.  However, in the case of
software used on network servers, this result may fail to come about.
The GNU General Public License permits making a modified version and
letting the public access it on a server without ever releasing its
source code to the public.

  The GNU Affero General Public License is designed specifically to
ensure that, in such cases, the modified source code becomes available
to the community.  It requires the operator of a network server to
provide the source code of the modified version running there to the
users of that server.  Therefore, public use of a modified version, on
a publicly accessible server, gives the public access to the source
code of the modified version.

  An older license, called the Affero General Public License and
published by Affero, was designed to accomplish similar goals.  This is
a different license, not a version of the Affero GPL, but Affero has
released a new version of the Affero GPL which permits relicensing under
this license.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU Affero General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Remote Network Interaction; Use with the GNU General Public License.

  Notwithstanding any other provision of this License, if you modify the
Program, your modified version must prominently offer all users
interacting with it remotely through a computer network (if your version
supports such interaction) an opportunity to receive the Corresponding
Source of your version by providing access to the Corresponding Source
from a network server at no charge, through some standard or customary
means of facilitating copying of software.  This Corresponding Source
shall include the Corresponding Source for any work covered by version 3
of the GNU General Public License that is incorporated pursuant to the
following paragraph.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the work with which it is combined will remain governed by version
3 of the GNU General Public License.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU Affero General Public License from time to time.  Such new versions
will be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU Affero General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU Affero General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU Affero General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>

    Copyright (C) {{ year }}  {{ organization }}

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If your software can interact with users remotely through a computer
network, you should also make sure that it provides a way for users to
get its source.  For example, if your program is a web application, its
interface could display a "Source" link that leads users to an archive
of the code.  There are many ways you could offer source, and different
solutions will be better for different programs; see section 13 for the
specific requirements.

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU AGPL, see
<http://www.gnu.org/licenses/>.

```

`README.md`:

```md
# Qsynthesis

QSynthesis is a Python3 API to perform I/O based program synthesis
of bitvector expressions. It aims at facilitating code deobfuscation.
The algorithm is greybox approach combining both a blackbox I/O based
synthesis and a whitebox AST search to synthesize sub-expressions *(if
the root node cannot be synthesized)*. 

This algorithm as originaly been described at the BAR academic workshop:

* [QSynth: A Program Synthesis based Approach for Binary Code Deobfuscation](https://archive.bar/pdfs/bar2020-preprint9.pdf)
  (benchmark used are available: [here](https://github.com/werew/qsynth-artifacts))

The code has been release as part of the following Black Hat talk:

* [Greybox Program Synthesis: A New Approach to Attack Dataflow Obfuscation](https://www.blackhat.com/us-21/briefings/schedule/index.html#greybox-program-synthesis-a-new-approach-to-attack-dataflow-obfuscation-22930)

**Disclaimer: This framework is experimental, and shall only be used for experimentation purposes.
It mainly aims at stimulating research in this area.**


## Documentation

The installation, examples, and API documentation is available on the dedicated documentation: [Documentation](https://quarkslab.github.io/qsynthesis)


## Functionalities

The core synthesis is based on [Triton](https://triton.quarkslab.com) symbolic engine on which is built
the whole framework. It provides the following functionalities:

* synthesis of bitvector expressions
* ability to check through SMT the semantic equivalence of synthesized expressions
* ability to synthesize constants *(if the expression encode a constant)*
* ability to improve oracles (pre-computed tables) overtime through a learning mechanism
* ability to reassemble synthesized expression back to assembly
* ability to serve oracles through a REST API to facilitate the synthesis usage  
* an IDA plugin providing an integration of the synthesis


## Quick start

### Installation

In order to work Triton first has to be installed: [install documentation](https://triton.quarkslab.com/documentation/doxygen/index.html#install_sec).
Triton does not automatically install itself in a virtualenv, copy it in your venv or use --system-site-packages when configuring your venv.

Then:

    $ git clone https://github.com/quarkslab/qsynthesis.git
    $ cd qsynthesis
    $ pip3 install '.[all]'

The ``[all]`` will installed all dependencies *(see the documentation for a light install)*.

### Table generation

The synthesis algorithm requires generating oracle tables derived from a grammar *(a
set of variables and operators)*. Qsynthesis installation provides the utility ``qsynthesis-table-manager``
enabling manipulating tables. The following command generate a table with 3 variables of 64 bits,
5 operators using a vector of 16 inputs. We limit the generation to 5 million entries.

    $ qsynthesis-table-manager generate -bs 64 --var-num 3 --input-num 16 --random-level 5 --ops AND,NEG,MUL,XOR,NOT --watchdog 80 --limit 5000000 my_oracle_table
    Generate Table
    Watchdog value: 80.0
    Depth 2 (size:3) (Time:0m0.23120s)
    Depth 3 (size:21) (Time:0m0.23198s)
    Depth 4 (size:574) (Time:0m0.26068s)
    Depth 5 (size:400858) (Time:0m21.23231s)
    Threshold reached, generation interrupted
    Stop required
    Depth 5 (size:5000002) (Time:4m52.56009s) [RAM:9.52Gb]



Note: The generation process is RAM consuming the ``--watchdog`` enables setting a
percentage of the RAM above which the generation is interrupted.

### Synthesizing a bitvector expression

We then can try simplifying a seemingly obfuscated expression with:

```python
from qsynthesis import SimpleSymExec, TopDownSynthesizer, InputOutputOracleLevelDB

blob = b'UH\x89\xe5H\x89}\xf8H\x89u\xf0H\x89U\xe8H\x89M\xe0L\x89E\xd8H\x8bE' \
       b'\xe0H\xf7\xd0H\x0bE\xf8H\x89\xc2H\x8bE\xe0H\x01\xd0H\x8dH\x01H\x8b' \
       b'E\xf8H+E\xe8H\x8bU\xe8H\xf7\xd2H\x0bU\xf8H\x01\xd2H)\xd0H\x83\xe8' \
       b'\x02H!\xc1H\x8bE\xe0H\xf7\xd0H\x0bE\xf8H\x89\xc2H\x8bE\xe0H\x01\xd0' \
       b'H\x8dp\x01H\x8bE\xf8H+E\xe8H\x8bU\xe8H\xf7\xd2H\x0bU\xf8H\x01\xd2' \
       b'H)\xd0H\x83\xe8\x02H\t\xf0H)\xc1H\x89\xc8H\x83\xe8\x01]\xc3'

# Perform symbolic execution of the instructions
symexec = SimpleSymExec("x86_64")
symexec.initialize_register('rip', 0x40B160)  # arbitrary address
symexec.initialize_register('rsp', 0x800000)  # arbitrary stack
symexec.execute_blob(blob, 0x40B160)
rax = symexec.get_register_ast("rax")  # retrieve rax register expressions

# Load lookup tables
ltm = InputOutputOracleLevelDB.load("my_oracle_table")

# Perform Synthesis of the expression
synthesizer = TopDownSynthesizer(ltm)
synt_rax, simp = synthesizer.synthesize(rax)

print(f"expression: {rax.pp_str}")
print(f"synthesized expression: {synt_rax.pp_str} [{simp}]")
```

## Limitations

* synthesis accuracy limited by pre-computed tables exhaustivness
* table generation limited by RAM consumption
* reassembly cannot involve memory variable, destination is necessarily a register and
  architecture depends on llvmlite *(thus mostly x86_64)*
* the code references trace-based synthesis which is disabled *(as the underlying
  framework is not yet open-source)*  

## Authors

* Robin David (@RobinDavid), Quarkslab

## Contributors

Huge thanks to contributors to this research:

* Luigi Coniglio
* Jonathan Salwan

```

`bin/qsynthesis-table-manager`:

```
#!/usr/bin/env python3

from itertools import permutations, combinations
import random
from pathlib import Path
import logging
import click
import time
import sys

import qsynthesis
from qsynthesis import TritonGrammar, BvOp, HashType, InputOutputOracleLevelDB


def biased_input_generator(bitsize: int, var_num: int, input_number: int, bs: int, random_level: int = 2):
    n = max(var_num-3, random_level)
    minus_one = pow(2, bitsize)-1
    vals = [1, 0, minus_one] + [None] * n
    all_perms = list(permutations(vals, var_num))
    return list(map(lambda l: [random.getrandbits(bs) if x is None else x for x in l], random.sample(all_perms, k=input_number)))


def operator_generator(nb_operator: int):
    """ Generate infinite operators set (making sure all combinations  """
    ops = [BvOp.NOT, BvOp.AND, BvOp.OR, BvOp.XOR, BvOp.NEG, BvOp.ADD, BvOp.MUL, BvOp.SUB]
    while 1:
        l = list(combinations(ops, nb_operator))
        random.shuffle(l)
        yield from l


@click.group(context_settings={'help_option_names': ['-h', '--help']})
@click.version_option(version=qsynthesis.__version__, message='%(version)s')
def main():
    pass


@main.command(name="generate")
@click.argument('output_file', type=str)
@click.option('-l', '--limit', default=0, type=int, help="Limit number of expressions to generate (-1 no limit)")
@click.option('-bs', '--bitsize', metavar="bitsize", default=64, type=int, help="Bit size of expressions")
@click.option('--var-num', default=3, type=int, help="Number of variables")
@click.option('--input-num', default=5, type=int, help="Number of inputs")
@click.option('--random-level', type=int, default=2, help="Randomness level of inputs 0 means higlhly biased to use corner-case values (0,1,-1)")
@click.option('--op-num', default=5, type=int, help="Operator number")
@click.option("-v", "--verbosity", default=0, count=True, help="increase output verbosity")
@click.option('--ops', type=str, default='', help='specifying operators to uses')
@click.option('--inputs', type=str, default='', help='specifying input vector to use')
@click.option('--hash-mode', default=HashType.MD5.name, type=click.Choice([x.name for x in HashType]), help="Hash function for keys in table")
@click.option('--watchdog', type=float, help="Activate RAM watchdog (percentage of load when to stop)")
@click.option('-c', '--cst', type=str, help="Constant to add in the generation process", multiple=True)
@click.option('--linearization', is_flag=True, type=bool, default=False, help="If set activate linearization of expressions")
def generate_command(output_file, limit, bitsize, var_num, input_num, random_level, op_num, verbosity, ops, inputs, hash_mode, watchdog, cst, linearization):
    """ Table generation utility """
    logging.basicConfig(level=logging.DEBUG if verbosity else logging.INFO, format='%(message)s')

    constants = [int(x, 16 if x.startswith("0x") else 10) for x in cst]

    try:
        import pydffi
    except ImportError:
        raise click.Abort("Cannot import dragonffi (pip3 install pydffi")
    try:
        import sympy
    except ImportError:
        raise click.Abort("Cannot import sympy (pip3 install sympy")

    if bitsize not in [8, 16, 32, 64]:
        print(f"Invalid bitsize {bitsize} valid ones [8, 16, 32, 64]")
        sys.exit(1)

    out_dir = Path(output_file)
    if out_dir.exists() and out_dir.is_file():
        out_dir.unlink()

    ops = [BvOp[x] for x in ops.split(",")] if ops else None
    inputs = [int(x) for x in inputs.split(",") if x]

    t1 = time.time()

    logging.info(f"Generate Table")

    operators = next(operator_generator(op_num)) if ops is None else ops
    vrs = [chr(ord('a') + x) for x in range(var_num)]
    if inputs:
        inputs = [{n: v for n, v in zip(vrs, inputs[i:i + len(vrs)])} for i in
                  range(0, len(inputs), len(vrs))]
    else:
        inputs = biased_input_generator(bitsize, var_num, input_num, bitsize, random_level)
        inputs = [{n: v for n, v in zip(vrs, i)} for i in inputs]

    grammar = TritonGrammar([(x, bitsize) for x in vrs], operators)

    logging.info(f"Watchdog value: {watchdog}")
    ltm = InputOutputOracleLevelDB.create(out_dir.absolute(), grammar, inputs, HashType[hash_mode], constants)
    try:
        if watchdog:
            ltm.generate(bitsize, constants=constants, do_watch=True, watchdog_threshold=watchdog, linearize=linearization, limit=limit)
        else:
            ltm.generate(bitsize, constants=constants, linearize=linearization, limit=limit)
    except KeyboardInterrupt:
        logging.warning("Stop required")

    elapsed = time.time() - t1
    hours, rem = divmod(elapsed, 3600)
    minutes, seconds = divmod(rem, 60)
    logging.info(f"\n{int(hours)}h{int(minutes)}m{seconds:.2f}s")


@main.command(name="info")
@click.argument('table_file', type=click.Path(exists=True))
def infos_command(table_file):
    """Getting information of a given database"""
    logging.basicConfig(level=logging.INFO, format='%(message)s')
    table_file = Path(table_file)

    table = InputOutputOracleLevelDB.load(table_file)

    logging.info(f"Bitsize: {table.bitsize}")
    logging.info(f"Hash mode: {table.hash_mode.name}")
    logging.info(f"Size: {table.size}")
    logging.info(f"Variables: {table.grammar.vars}")
    logging.info(f"Operators: {[x.name for x in table.grammar.ops]}")
    logging.info(f"Nb inputs: {len(table.inputs)}")
    l = []
    for i in table.inputs:
        for v in i.values():
            l.append(v)
    logging.info(",".join(str(x) for x in l))


@main.command(name="check")
@click.argument('table_file', type=click.Path(exists=True))
def check_command(table_file):
    """Checking the equivalence of hashes against evaluation of expressions on inputs"""
    logging.basicConfig(level=logging.INFO, format='%(message)s')
    table_file = Path(table_file)

    table = InputOutputOracleLevelDB.load(table_file)
    count = table.size
    good, bad = 0, 0

    for i, (h, expr) in enumerate(table):
        if i % 100 == 0:
            print(f"process {i}/{count} [KO:{bad}]\r", end="")
        triton_exp = table.get_expr(expr)
        outs = table.eval_expr_inputs(triton_exp)
        if table.hash(outs) != h:
            logging.warning(f"Bad expression: {expr}  with [{outs}]")
        else:
            good += 1
    logging.info(f"[OK:{good}/{count}]{'': <15}")


@main.command(name="compare")
@click.argument('table1', type=click.Path(exists=True))
@click.argument('table2', type=click.Path(exists=True))
def compare_command(table1, table2):
    """Compare two tables"""
    table1 = InputOutputOracleLevelDB.load(table1)
    table2 = InputOutputOracleLevelDB.load(table2)

    only1 = 0
    only2 = 0
    common = 0
    sz1 = table1.size
    sz2 = table2.size
    for h, k in table1:
        if table2.db.get(h):
            common += 1
        else:
            only1 += 1
    for h, k in table2:
        if not table1.db.get(h):
            only2 += 1

    print(f"Table 1 size:{sz1}\tTable 2 size:{sz2}\t[Inputs:{'OK' if table1.inputs == table2.inputs else 'DIFFERENT'}]")
    print(f"Only table 1:{only1}\tOnly table2:{only2}\tCommons:{common}")
    # FUTURE: Implementing semantic comparison of common keys


@main.command(name="merge")
@click.argument('in_table', type=click.Path(exists=True))
@click.argument('out_table', type=click.Path(exists=False))
def merge_command(in_table, out_table):
    """Merge entries of the first database in the second"""
    lkp_in = InputOutputOracleLevelDB.load(in_table)
    lkp_out = InputOutputOracleLevelDB.load(out_table)

    if lkp_in.inputs != lkp_out.inputs:
        print("Tables should use the same set of inputs")
        sys.exit(1)

    i = 0
    c = 0
    sz = lkp_in.size
    for hash, s in lkp_in:
        if lkp_out.db.get(hash) is None:
            lkp_out.add_entry(hash, s)
            i += 1
        c += 1
        if c % 100 == 0:
            print(f"count:{c}/{sz} (imported:{i})\r", end="")

    print(f"Imported: {i}")


@main.command(name="dump")
@click.option('-l', '--limit', type=int, default=0, help='maximum number of entries to dump')
@click.argument('in_table', type=click.Path(exists=True))
def dump_command(limit, in_table):
    """Dump the content of the table on stdout"""
    lkp_in = InputOutputOracleLevelDB.load(in_table)

    counter = 0
    for hash, s in lkp_in:
        if counter > limit > 0:
            break
        print(f"{hash} -> {s}")
        counter += 1


if __name__ == "__main__":
    main()

```

`bin/qsynthesis-table-server`:

```
#!/usr/bin/env python3

import click
import logging
import json
from binascii import unhexlify

import plyvel

META_KEY = b"metadatas"
VARS_KEY = b"variables"
INPUTS_KEY = b"inputs"
SIZE_KEY = b"size"


@click.command()
@click.argument('table_file', type=click.Path(exists=True))
@click.option('-p', '--port', type=int, default=8080, help="Service port to listen on")
def runserver(table_file, port):
    """Run the REST API to serve a given table database"""
    logging.basicConfig(level=logging.INFO, format='%(message)s')

    try:
        table = plyvel.DB(str(table_file))
        metas = json.loads(table.get(META_KEY))
        vrs = list(json.loads(table.get(VARS_KEY)).items())
        inps = json.loads(table.get(INPUTS_KEY))
    except IOError:
        logging.error("Lookup table database is invalid (or already opened)")
        return

    try:
        from fastapi import FastAPI, Query
        import uvicorn
    except ImportError:
        logging.critical("Cannot import fastapi or uvicorn (pip3 install fastapi uvicorn)")
        raise click.Abort("")

    app = FastAPI()


    @app.get("/")
    def read_root():
        return {'size': table.get(SIZE_KEY),
                'hash_mode': metas['hash_mode'],
                'inputs': inps,
                'grammar': {'vars': vrs, 'operators': metas['operators']}}

    @app.get("/entry/{hash}")
    def read_item(hash: str = Query(None, min_length=32, max_length=32, regex="^[0-9a-z]+$")):
        decoded = unhexlify(hash)
        entry = table.get(decoded)
        print(entry)
        if entry:
            return {"hash": hash, "expression": entry}
        else:
            return {}

    uvicorn.run(app, host="0.0.0.0", port=port)


if __name__ == "__main__":
    runserver()

```

`doc/Makefile`:

```
# Minimal makefile for Sphinx documentation
#

# You can set these variables from the command line, and also
# from the environment for the first two.
SPHINXOPTS    ?=
SPHINXBUILD   ?= sphinx-build
SOURCEDIR     = .
BUILDDIR      = _build

# Put it first so that "make" without argument is like "make help".
help:
	@$(SPHINXBUILD) -M help "$(SOURCEDIR)" "$(BUILDDIR)" $(SPHINXOPTS) $(O)

.PHONY: help Makefile

# Catch-all target: route all unknown targets to Sphinx using the new
# "make mode" option.  $(O) is meant as a shortcut for $(SPHINXOPTS).
%: Makefile
	@$(SPHINXBUILD) -M $@ "$(SOURCEDIR)" "$(BUILDDIR)" $(SPHINXOPTS) $(O)

```

`doc/api/sym_exec.rst`:

```rst
.. _label_simplesymexec:

SimpleSymExec
=============


.. autoclass:: qsynthesis.utils.symexec.SimpleSymExec
    :members:
    :show-inheritance:
    :inherited-members:
    :undoc-members:
    :exclude-members:


```

`doc/api/synthesis.rst`:

```rst


Top-Down Synthesizer
====================

.. _label_topdown:

.. autoclass:: qsynthesis.algorithms.synthesizer_td.TopDownSynthesizer
    :members:
    :show-inheritance:
    :inherited-members:
    :undoc-members:
    :exclude-members:



Placeholder-based Synthesizer
=============================

.. _label_plhdr:

.. autoclass:: qsynthesis.algorithms.synthesizer_plhld.PlaceHolderSynthesizer
    :members:
    :show-inheritance:
    :inherited-members:
    :undoc-members:
    :exclude-members:


```

`doc/api/table.rst`:

```rst
Grammar
=======

Oracles contain pre-computed expression on a given grammar. A grammar is composed
of variables, and operators (unary/binary) that can be applied on these
variables. An oracle object is instanciated with such grammar class and an input vector.

.. autoclass:: qsynthesis.grammar.grammar.TritonGrammar
   :members:


Oracles
=======

QSynthesis support any types of oracles as long as they implement :py:class:`InputOutputOracle` base class
which interface is given below. At the moment two children classes implement this interface:

* :py:class:`InputOutputOracleLevelDB`: Main table object where entries are stored in a key-value database
  made by called `Level-DB <https://github.com/google/leveldb>`_ made by Google, that guarantee logarithmic
  read in database.
* :py:class:`InputOutputOracleREST`: Class interfacing a ``InputOutputOracleLevelDB`` being served on a REST API
  (cf. :ref:`label_rest_api`). This table avoids having a whole table locally.


.. autoclass:: qsynthesis.tables.base.InputOutputOracle
   :members:

```

`doc/api/tritonast.rst`:

```rst

.. _label_tritonast:

TritonAst
=========

TritonAst is a class wrapper around Triton AstNode objects on top of which it provides
many utility functions.

.. autoclass:: qsynthesis.tritonast.TritonAst
   :members:

```

`doc/api/types.rst`:

```rst
Types
=====

.. automodule:: qsynthesis.types
   :members:

```

`doc/api_usage.rst`:

```rst
.. _qsynthesis_api_usage:

API Usage
=========

Use-case: Synthesis in pure symbolic with Triton
---------------------------------------------------

While working on an execution trace is very powerful thanks to concretization that can be made
we often can't executed the program or the execution does not reach the intended location. As such,
this use-case shows a very similar one where instruction are provided by the use directly.

First lets consider the following bytes representing the x86_64 computation of an obfuscated
expression.

.. code-block:: python

    INSTRUCTIONS = [b'U', b'H\x89\xe5', b'H\x89}\xf8', b'H\x89u\xf0', b'H\x89U\xe8', b'H\x89M\xe0', b'L\x89E\xd8',
                    b'H\x8bE\xf0', b'H#E\xe0', b'H\x89\xc2', b'H\x8bE\xf0', b'H\x0bE\xe0', b'H\x0f\xaf\xd0', b'H\x8bE\xe0',
                    b'H\xf7\xd0', b'H#E\xf0', b'H\x89\xc1', b'H\x8bE\xf0', b'H\xf7\xd0', b'H#E\xe0', b'H\x0f\xaf\xc1',
                    b'H\x01\xc2', b'H\x8bE\xe0', b'H\x0f\xaf\xc0', b'H\x89\xd6', b'H!\xc6', b'H\x8bE\xf0', b'H#E\xe0',
                    b'H\x89\xc2', b'H\x8bE\xf0', b'H\x0bE\xe0', b'H\x0f\xaf\xd0', b'H\x8bE\xe0', b'H\xf7\xd0', b'H#E\xf0',
                    b'H\x89\xc1', b'H\x8bE\xf0', b'H\xf7\xd0', b'H#E\xe0', b'H\x0f\xaf\xc1', b'H\x01\xc2', b'H\x8bE\xe0',
                    b'H\x0f\xaf\xc0', b'H\t\xd0', b'H)\xc6', b'H\x89\xf0', b'H\x83\xe8\x01', b'H3E\xf0', b'H\x89\xc2',
                    b'H\x8bE\xf0', b'H#E\xe0', b'H\x89\xc1', b'H\x8bE\xf0', b'H\x0bE\xe0', b'H\x0f\xaf\xc8', b'H\x8bE\xe0',
                    b'H\xf7\xd0', b'H#E\xf0', b'H\x89\xc6', b'H\x8bE\xf0', b'H\xf7\xd0', b'H#E\xe0', b'H\x0f\xaf\xc6',
                    b'H\x01\xc1', b'H\x8bE\xe0', b'H\x0f\xaf\xc0', b'H1\xc8', b'H#E\xf0', b'H\x01\xc0', b'H)\xc2',
                    b'H\x89\xd0', b']', b'\xc3']

The first thing to do is to executed these instruction with triton. For that Qsynthesis
provides an utility class :py:class:`SimpleSymExec` (cf: :ref:`label_simplesymexec`) facilitating
various tasks. It takes the architecture in parameter. We arbritrarily initialize ``rip`` and
``rsp`` to arbitrary addresses and feed all instructions to that wrapper.

.. code-block:: python

    from qsynthesis.utils.symexec import SimpleSymExec

    symexec = SimpleSymExec("x86_64")              # Initialize it with the intended architecture
    symexec.initialize_register('rip', 0x40B160)   # arbitrary address
    symexec.initialize_register('rsp', 0x800000)   # arbitrary address
    for opcode in INSTRUCTIONS:
        symexec.execute(opcode)                    # Execute the given opcode
    rax = symexec.get_register_ast("rax")          # Retrieve rax AST after executing instructions


As of now the ``rax`` expression can be synthesized by instanciating the synthesizer with
an oracle table.

.. code-block:: python

    from qsynthesis import TopDownSynthesizer, InputOutputOracleLevelDB

    table = InputOutputOracleLevelDB.load("my_leveldb_table/")  # Load the lookup table database

    synthesizer = TopDownSynthesizer(table)       # Instanciate the synthesize of the table
    synt_rax, simp_bool = synthesizer.synthesize(rax)  # Trigger synthesize of the rax expression

    # Print synthesis results
    print(f"simplified: {simp_bool}")
    print(f"synthesized expression: {synt_rax.pp_str}")
    print(f"size: {rax.node_count} -> {synt_rax.node_count}")

```

`doc/conf.py`:

```py
# Configuration file for the Sphinx documentation builder.
#
# This file only contains a selection of the most common options. For a full
# list see the documentation:
# http://www.sphinx-doc.org/en/master/config

# -- Path setup --------------------------------------------------------------

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.

import os
import sys
import datetime
sys.path.insert(0, os.path.abspath('..'))
sys.path.insert(0, os.path.abspath('./mock'))

# -- Project information -----------------------------------------------------

project = 'QSynthesis'
copyright = '2021, Quarkslab'
author = 'Robin David'

# The full version, including alpha/beta/rc tags
release = '0.1'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
language = 'en'

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'friendly'  # also monokai, friendly, colorful

# -- General configuration ---------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
# ones.
extensions = [
    'sphinx.ext.autodoc',
    'sphinx.ext.todo',
    'sphinx.ext.viewcode',
    'sphinx.ext.githubpages',
    'breathe',
    'sphinx.ext.intersphinx',
    'sphinx_fontawesome'
]

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
# This pattern also affects html_static_path and html_extra_path.
exclude_patterns = ['_build', 'Thumbs.db', '.DS_Store']


# -- Options for HTML output -------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
#
html_theme = "sphinx_rtd_theme"

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['figs']

autodoc_default_flags = ['members', 'inherited-members']


autoclass_content = "both"  # Comment class with both class docstring and __init__ docstring

autodoc_typehints = "signature"

autodoc_type_aliases = {
    'Addr': 'qsynthesis.types.Addr',
    'BitSize': 'qsynthesis.types.BitSize',
    'ByteSize': 'qsynthesis.types.ByteSize',
    'Hash': 'qsynthesis.types.Hash',
    'Char': 'qsynthesis.types.Char',
    'Input': 'qsynthesis.types.Input',
    'Output': 'qsynthesis.types.Output',
    'IOPair': 'qsynthesis.types.IOPair',
    'IOVector': 'qsynthesis.types.IOVector'
}


intersphinx_mapping = {'python': ('https://docs.python.org/3', None)}



# ==============================================================
#                     LATEX CONFIGURATION
# ==============================================================

report_title = "QSynthesis: Documentation"
report_reference = u'21-01-781-REP'
report_version = release
report_filename = 'qsynthesis.tex'
report_date = datetime.date.today().strftime("%d %B %Y")

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
    ('index', report_filename, report_title,
     u'QB', 'manual'),
]

# Additional stuff for the LaTeX preamble.
custom_latex_preamble = r'''
    \newcommand{\myref}{%s}
    \newcommand{\myversion}{%s}
    \newcommand{\mydate}{%s}
    \usepackage{float}
    \usepackage{xcolor}
    \setlength{\parskip}{5pt}
    \usepackage{multicol}
    \usepackage{tikz}
    \usepackage{fontawesome}
    \definecolor{LightCyan}{rgb}{0.88, 1.0, 1.0}
''' % (report_reference, report_version, report_date)

latex_additional_files = ['latexstyling.sty']
latex_elements = {
    'papersize': 'a4paper',
    'pointsize': '11pt',
    'fontpkg': '\\usepackage{lmodern}',
    'babel': '\\usepackage[english]{babel}',  # choix du langage : le langage utilise doit etre le dernier de la liste
    'fncychap': '',  # don't redefine chapter commands
    'preamble': '\\usepackage{latexstyling}' + custom_latex_preamble,
    # remove blank pages and same margin on odd and even pages
    'classoptions': ',oneside',
    'figure_align': 'H',
    'maketitle': '\\maketitle',
    'passoptionstopackages': r'\PassOptionsToPackage{svgnames}{xcolor}',
    'sphinxsetup': 'warningborder=1pt, '  # also: cautious, attention, danger, error
                   'warningBorderColor={rgb}{1.0, 0.51, 0.26}, '  # (http://latexcolor.com)
                   'warningBgColor={rgb}{1.0, 0.8, 0.64}, '  # 

                   'noteborder=2pt, '  # also: hint, important, tip
                   'noteBorderColor={rgb}{0.57, 0.63, 0.81}, '
}

```

`doc/dev_doc/table.rst`:

```rst
Oracle Management
=================

qsynthesis-table-manager utility
--------------------------------

The tedious task about using QSynthesis is having good tables (aka oracles)
for efficient synthesis. QSynthesis provides `qsynthesis-table-manager`
which provide high-level function to manage tables. Its help file is:

.. highlight:: none

::

    Usage: qsynthesis-table-manager [OPTIONS] COMMAND [ARGS]...

    Options:
      --version   Show the version and exit.
      -h, --help  Show this message and exit.

    Commands:
      check     Checking the equivalence of hashes against evaluation of...
      compare   Compare two tables
      dump      Dump the content of the table on stdout
      generate  Table generation utility
      info      Getting information of a given database
      merge     Merge entries of the first database in the second



The first interesting command is ``info`` that provides information about the
database, like grammar used, inputs, used, number of entries etc.

The ``check`` command re-evaluate all expressions against the inputs of table
to ensure the hash is valid. **This is a very slow process** and should only
be used for debugging purposes.

The ``compare`` command takes two tables and compare them to know how many entries
they have in common thus not in common.

The ``merge`` command merge two tables as long as they are using the same set of inputs.


Table Generation
----------------

The ``generate`` command of the utility, enables generating new tables. It provides various parameters.
The help message is the following:

::

    Usage: qsynthesis-table-manager generate [OPTIONS] OUTPUT_FILE

      Table generation utility

    Options:
      -bs, --bitsize bitsize          Bit size of expressions
      --var-num INTEGER               Number of variables
      --input-num INTEGER             Number of inputs
      --random-level INTEGER          Randomness level of inputs 0 means higlhly
                                      biased to use corner-case values (0,1,-1)

      --op-num INTEGER                Operator number
      -v, --verbosity                 increase output verbosity
      --ops TEXT                      specifying operators to uses
      --inputs TEXT                   specifying input vector to use
      --hash-mode [RAW|FNV1A_128|MD5]
                                      Hash function for keys in table
      --watchdog FLOAT                Activate RAM watchdog (percentage of load
                                      when to stop)

      -c, --cst TEXT                  Constant to add in the generation process
      --linearization                 If set activate linearization of expressions
      -h, --help                      Show this message and exit.


The parameters are the following:

* ``bitsize``: size of expression to generate. At the moment tables cannot contain expression
  of different sizes. *(before looking a table the synthesize will ensure expressions are of same size)*
* ``var-num``: number of variables to include in the grammar
* ``input-num``: Size of the Input vector, on which each expression are evaluated. Too small
  vectors might induce false positives, while too long vectors might uselessly be too computation intensive (15 is good)
* ``random-level``: Number of random value that will be used as inputs. Low value favor values like (0, 1, -1)
* ``op-num``: Unless provided this argument select randomly X operators (among 8 at the moment)
* ``ops``: takes comma separated operators to use for generation (if not provided they are selected randomly)
* ``inputs``: Should be given as a1,b1,c1,a2,b2,c2 where a,b,c are the variable. (a1,b1,c1) is the first input etc.
  If not provided inputs are selected randomly using the ``random-level``.
* ``hash-mode``: Hashing function to apply on output vectors. **(use MD5)**
* ``watchdog``: Generation is highly RAM consuming *(exponential algorithm)*. That enable a watchdog and
  the value is the percentage of RAM above which the generation should be stopped.
* ``cst``: Additional constants to introduce in the generation process.
* ``linearization``: enable linearization of expression using sympy


A very detailed example where all the inputs, ops are defined in advance is the following line:

::

    qsynthesis-table-manager generate tmp.bin -t bin -bs 64 --var-num 3 --max-depth 5 -k 1 \
    --ops SUB,NEG,ADD,XOR,OR --hash-mode MD5 --watchdog 85 --input-num 15 --random-level 7


Once generated. If the generation was performed in 'bin' (thus :py:class:`LookupTableRaw`)
files can be imported in a Level-db database with ``qsynthesis-table-manager import table.bin new_table_ldb``.

.. _label_rest_api:

Oracle REST server
------------------

For large oracles it is convenient to serve them on an API instead of having them locally.
The synthesis is slower but more flexible. Qsynthesis provides ``qsynthesis-table-server``
allowing to serve Level-DB database via a REST API.

The command is straightforward and takes the table in parameter *(and optionally a port)* e.g:

::

    qsynthesis-table-server my_table_leveldb -p 8080

```

`doc/figs/reassembly.drawio`:

```drawio
<mxfile host="Electron" modified="2020-07-26T09:43:34.383Z" agent="5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) draw.io/13.3.9 Chrome/83.0.4103.119 Electron/9.0.5 Safari/537.36" etag="rEAsfB7TH3HPoPuadJJq" version="13.3.9" type="device"><diagram id="LYQNS9zcA0JcHrl_m_ya" name="Page-1">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</diagram></mxfile>
```

`doc/index.rst`:

```rst
QSynthesis documentation
========================

**QSynthesis** is a Python API to perform Greybox synthesis of bitvector
expressions. The base synthesis algorithm is based on
both a blackbox I/O based approach comparing solely input-to-output
pairs to perform the synthesis, but also a whitebox AST search
to synthesize sub-expressions *(if the root expression cannot be synthesized
all at once)*. Also, instead of deriving possible candidates on each expressions
to synthesize, QSynthesis relies on pre-computated expressions stored in a
database. The database keeps the mapping of an expression and its associated output
vector representing its behavior on a set of inputs. Given a bitvector expression
to synthesize, finding a candidate can thus be performed in
near O(1) as the lookup is the lookup cost in database. With the structure
used (Google Level-DB) the cost is thus Log(N) with N the number of entries
in the database.

.. toctree::
   :caption: Getting started
   :maxdepth: 2

    Installation <installation>
    API usage <api_usage>

.. toctree::
    :caption: Plugin Usage
    :maxdepth: 2

    Plugin Introduction <plugin/plugin_usage>

.. toctree::
    :caption: Python API
    :maxdepth: 3

    TritonAst <api/tritonast>
    Synthesis algorithms <api/synthesis>
    Oracles <api/table>
    Symbolic Execution utilities <api/sym_exec>
    Types <api/types>

.. toctree::
    :caption: Advanced Usage
    :maxdepth: 2

    Lookup table Management <dev_doc/table>


```

`doc/installation.rst`:

```rst
Installation
============

Installing **QSynthesis** is rather straightforward, you just need to:

* Use the provided `setup.py` to install QSynthesis
* (Optional) copy the `ida_plugin/qsynthesis_plugin.py` in the IDA Pro plugin folder
* (Optional) install additionnal dependencies to generate tables or to serve tables as server

Thus it can be done with:

.. code-block:: bash

    $ git clone https://github.com/quarkslab/qsynthesis.git
    $ cd qsynthesis
    $ pip3 install .

You're ready to go !

Optional dependencies
^^^^^^^^^^^^^^^^^^^^^

Not to install too many third-party libraries the default installation
only install the strict minimum. Various features requires installing
additional packages.

* **Table generation**: requires `dragonffi <https://github.com/aguinet/dragonffi>`_ and `sympy <https://www.sympy.org/en/index.html>`_ ``pip install .[generator]``
* **Reassemby**: requires `arybo <https://github.com/quarkslab/arybo>`_ and `llvmlite <https://github.com/numba/llvmlite>`_ ``pip install .[reassembly]``
* **Server**: requires `FastAPI <https://fastapi.tiangolo.com>`_ ``pip install .[server]``

You can install all dependencies all at once with ``pip install .[all]``.

Installing the IDA Plugin
-------------------------

Then to install the plugin just copy the file `ida_plugin/qsynthesis_plugin.py` in your IDA Pro plugin directory.

.. warning:: The plugin is solely working on IDA with Python3, and latest versions of IDA.

```

`doc/latexstyling.sty`:

```sty
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% packages
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{multicol}
\usepackage{multirow}
\usepackage{tabularx,colortbl}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% parametres
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\definecolor{mahogany}{rgb}{0.75,0.25,0}
\definecolor{template-strong}{RGB}{64,65,148}
\definecolor{template-light}{RGB}{237,239,240}

% colors from https://www.tenable.com/sc-dashboards/executive-vulnerability-metrics
\definecolor{template-critical}{RGB}{207,0,26}
\definecolor{template-high}{RGB}{232,76,90}
\definecolor{template-medium}{RGB}{250,156,40} %monero:{232,171,76}
\definecolor{template-low}{RGB}{204, 186, 85} %monero:{153,234,155}
\definecolor{template-improvment}{RGB}{133, 175, 190} %monero:{153,234,155}
\definecolor{template-informational}{RGB}{215,215,215}

% definition des couleurs des liens
\hypersetup{colorlinks,citecolor=InnerLinkColor,filecolor=black,linkcolor=InnerLinkColor,urlcolor=InnerLinkColor} 

%\renewcommand{\familydefault}{\sfdefault} % redefinition de la police
\setcounter{secnumdepth}{2}            % profondeur de la numerotation dans l'index
\setcounter{tocdepth}{2}               % profondeur de la numerotation dans le doc

% redefinition de la commande des chapitres
% http://www.ctex.org/documents/packages/layout/titlesec.pdf
\titleformat{\chapter}[display]{\LARGE\bfseries}{}{-100pt}{\textcolor{TitleColor}{\thechapter. }\textcolor{TitleColor}}[]
% suppression de l'espace enorme apres le chapitre
\titlespacing{\chapter}{0pt}{50pt}{\parsep}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% style des pages
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagestyle{fancy}                      % style de la page
\fancyhf{}                             % remise a zero du style
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

% redefinition de ``code`` afin qu'il soit en gras
%\renewcommand{\code}[1]{\texttt{\bfseries#1}}

% couleur de fond pour les extraits de code
\definecolor{VerbatimColor}{rgb}{0.95,0.95,1.0}

% definition de la mention confidentiel en fonction de la langue du document
\iflanguage{francais}{
  \newcommand{\confidential}{\chead{\textcolor{red}{[DIFFUSION RESTREINTE]}}}
}{
  %\newcommand{\confidential}{\chead{\textcolor{mahogany}{CONFIDENTIAL -- NOT FOR PUBLIC RELEASE}}}
  \newcommand{\confidential}{\chead{\textcolor{mahogany}{Public}}}
  %\newcommand{\confidential}{\chead{\textcolor{mahogany}{Draft}}}
}
%% la façon la plus sale d'enlever Confidential : l'effacer...

\fancypagestyle{plain}{
  \fancyhf{}
  \fancyfoot{}
  \iflanguage{francais}{
    \lfoot{Réf. : \myref}                     % pied de page gauche
  }{
    \lfoot{Ref.: \myref}
  }
  \cfoot{Quarkslab SAS}                 % pied de page centre
  \rfoot{\thepage}                       % pied de page droite

  \confidential                          % sans mention confidentiel : publication sur blog.quarkslab.com
}

\fancypagestyle{normal}{
  \fancyhf{}
  \fancyfoot{}
  \iflanguage{francais}{
    \lfoot{Réf. : \myref}                     % pied de page gauche
  }{
    \lfoot{Ref.: \myref}
  }
  \cfoot{Quarkslab SAS}                 % pied de page centre
  \rfoot{\thepage}                       % pied de page droite
  
  \confidential                          % sans mention confidentiel : publication sur blog.quarkslab.com
}

% redefinit la table des matieres pour avoir une page sans footer, et ne pas
% afficher le numero du chapitre (0)
\renewcommand{\tableofcontents}{
  \clearpage
  \pagenumbering{roman}
  \setcounter{page}{1}
  \thispagestyle{empty}
  {\Huge\bfseries \textcolor{TitleColor}{\contentsname \\}}

  \@starttoc{toc}
  
  % don't know why it replaces \fancypagestyle{normal}
  \iflanguage{francais}{
    \lfoot{Réf. : \myref}                     % pied de page gauche
  }{
    \lfoot{Ref.: \myref}
  }
  \cfoot{Quarkslab SAS}                 % pied de page centre
  \rfoot{\thepage}                       % pied de page droite
  
  % \confidential                          % mention confidentiel
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% page de garde
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\renewcommand{\maketitle}{
\thispagestyle{empty}
\setcounter{page}{0}
\vspace*{5.0cm}
{\huge{\bf{\@title}\\}
\line(1,0){424}
\vspace{0.8em}

\LARGE{\textcolor{TitleColor}{Release 0.1}}%Programme d'Analyse Statique et de Tests Instrumentés pour la Sécurité}}
}

\vfill

\begin{bfseries}
%  \begin{flushright}
%    \begin{large}
%      \begin{tabular}{r l}
%        \textcolor{InnerLinkColor}{Réf.}     & \myref\\
%        \textcolor{InnerLinkColor}{Version}  & \myversion\\
%        \textcolor{InnerLinkColor}{Date}     & \mydate\\
%	\textcolor{InnerLinkColor}{Preparé pour} & DGA\\
%	\textcolor{InnerLinkColor}{Réalisé par}  & Quarkslab\\
%      \end{tabular}
%    \end{large}
%
%    \vspace*{2.0cm}
%  \end{flushright}

  \begin{multicols}{2}
    \begin{flushright}
      \includegraphics[scale=0.2]{../../figs/logo_quarkslab_Securing_Q.png}
       \begin{large}
         \textcolor{TitleColor}{Quarkslab SAS}\\
         13 rue Saint Ambroise\\
         75011 Paris,
         France
       \end{large}
    \end{flushright}
  \end{multicols}
    
\end{bfseries}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% commands
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\Go}{\mathbb{G}_1}
\newcommand{\Gt}{\mathbb{G}_2}
\newcommand{\GT}{\mathbb{G}_T}
\newcommand{\ZZ}{\mathbb{Z}}

```

`doc/mock/qtracedb/__init__.py`:

```py
class DatabaseManager:
    pass
```

`doc/mock/qtracedb/archs/__init__.py`:

```py
class ArchsManager:
    pass

```

`doc/mock/qtracedb/archs/arch.py`:

```py
class Arch:
    pass

class Instr:
    pass
```

`doc/mock/qtracedb/archs/arm.py`:

```py
class ArchARM:
    pass

```

`doc/mock/qtracedb/archs/arm64.py`:

```py
class ArchARM64:
    pass

```

`doc/mock/qtracedb/archs/manager.py`:

```py
class ArchsManager:
    pass

```

`doc/mock/qtracedb/archs/x86.py`:

```py
class ArchX86:
    pass


class ArchX64:
    pass
```

`doc/mock/qtracedb/trace.py`:

```py
class Trace:
    pass
class MemAccessType:
    pass
class InstrCtx:
    pass
```

`doc/mock/triton.py`:

```py
from unittest.mock import MagicMock


class TritonContext:
    pass


ARCH = MagicMock()


class MemoryAccess:
    pass


class CALLBACK:
    pass


class MODE:
    pass


class Instruction:
    pass


class AST_REPRESENTATION:
    pass


class OPERAND:
    pass


AST_NODE = MagicMock()
    # LAND
    # LNOT
    # LOR
    # IFF
    # EQUAL
    # DISTINCT
    # BVNOT
    # BVAND
    # BVOR
    # BVXOR
    # BVNEG
    # BVADD
    # BVMUL
    # BVSUB
    # BVSHL
    # BVLSHR
    # BVROL  # Int x Bv -> Bv
    # BVROR  # Int x Bv -> Bv
    # BVUDIV
    # BVUREM
    # BVASHR
    # BVSDIV
    # BVSREM
    # BVSMOD
    # BVXNOR
    # BVNOR
    # BVNAND
    # ZEXT = AST_NODE.ZX  # Int x Bv -> Bv
    # SEXT = AST_NODE.SX  # Int x Bv -> Bv
    # CONCAT = AST_NODE.CONCAT
    # EXTRACT = AST_NODE.EXTRACT  # Int x Int x Bv -> Bv
    # # Other: Bool x BV x BV -> Bv
    # ITE = AST_NODE.ITE
    # # Boolean ops: BV x BV -> Bool
    # UGE = AST_NODE.BVUGE
    # UGT = AST_NODE.BVUGT
    # ULE = AST_NODE.BVULE
    # ULT = AST_NODE.BVULT
    # SLE = AST_NODE.BVSLE
    # SLT = AST_NODE.BVSLT
    # SGE = AST_NODE.BVSGE
    # SGT = AST_NODE.BVSGT


class SYMBOLIC:
    REGISTER_VARIABLE = 1
    MEMORY_VARIABLE = 2


```

`doc/plugin/plugin_usage.rst`:

```rst
IDA Plugin Walkthrough
======================

Introduction
------------

.. _label_intro_plugin:

The default shortcut to launch QSynthesis is: **Alt+S**


Main Interface
--------------

Figure shown below shows the main UI after having sequentially set the parameters
and clicked 'Run Triton' and 'Run Synthesis' to synthesize an expression.

.. figure:: ../figs/main-ui-example.png
   :scale: 100 %
   :align: center
   :alt: Main UI

From and To fields defines the address bounds of the trace where to perform
the symbolic execution. Note that the first occurence in the trace of the start
address is used. Similarly, the first occurence of the stop address after the start
address is used. The target is either a register, either a memory location. A
third is operand but is a high-level refinement for a register or memory.

The other parameter specifies options for the synthesis, kind of algorithm etc.
These parameters are directly sent to the APIs.

.. warning:: In full symbolic mode, 'From' and 'To' have to be located in the
             same basic block. *(Otherwise the algorithm cannot determine which
             parent/children to follow)*. For more broad sequence of instruction
             please use the API directly.

.. note:: In full symbolic the analysis process is the exact same. The only difference
          is that QSynthesis assumes that all items located between 'From' and 'To' are
          a sequential list of instructions.

Popup Actions
-------------

Various context-menu actions are registered in the IDA-View allowing to easily
select the 'From' and 'To' addresses right from the GUI. It also allows to synthesize
a given operand in the view. The image below shows the context-menu added.

.. figure:: ../figs/popup-actions.png
   :scale: 100 %
   :align: center
   :alt: Popup-actions

These three actions can directly be triggered with theirs shortcut Ctrl+Shift+A, Ctrl+Shift+Z
for 'From' and 'To' *(as it is cumbersome to copy past addresses)*. The last Ctrl+Shift+O takes
the operand under the mouse and adjust the target accordingly.

.. note:: The synthesizing operand action, automatically adjust the 'To' address depending
          on whether the operand is a destination operand or a source operand.


Exploiting results
==================

Results are shown in the two views of the main UI, but buttons at the bottom
provides various functionalities described hereafter.

Showing AST's
-------------

Bitvector expressions after symbolic expression and after synthesis can be printed using
the graph API of IDA. The image below shows the two graph side-by-side of the AST before
synthesis *(Show AST button in Triton side)* and the AST after synthesis *(Show AST button
in synthesis side)*

.. figure:: ../figs/asts.png
   :alt: AST shown side-by-side


Showing Depencencies
--------------------

Another feature is to show the dynamic slice dependency of a bitvector expression in the
IDA View. The button 'Show Deps' highlight in the IDA-View all instructions involved in
the computation of the expression. The image below shows the result obtained.

.. figure:: ../figs/deps.png
   :scale: 100 %
   :align: center
   :alt: Expression dependencies highlighted


Reassembly
----------

The last feature provided by the plugin is a trivial *(and unsound)* reassembly of the
synthesized AST into fresh unobfuscated instructions. The reassembly process use the
amazing `ayrbo <https://github.com/quarkslab/arybo>`_ project that turns Triton ASTs
back to LLVM and then compiled bytes. When clicking the 'Reassemble' button. A dialog
window asks for various parameters.

.. figure:: ../figs/reassembly-opts.png
   :scale: 75 %
   :align: center
   :alt: Reassembly options

The three scenarios are:

* No ticking of any options: The synthesized expression is reassembled in an IDA graph view
* Ticking 'patch functions bytes': All dependent instructions (cf. above), are erased with
  NOPs and the reassembled instructions are put on the 'To' location where it was extracted
* Ticking 'patch' + 'shrink function': The function is rewriting with only instructions not
  in the dependency and the reassembled instructions.

The two latest, do tamper the IDB *(for good :) )* and somehow save the synthesized expression
result directly back in the IDB. The figure below shows the result obtained with the
three variants of the reassembly.

.. figure:: ../figs/reassembly.png
   :align: center
   :alt: Reassembly


.. warning:: The reassembly does not take in account use-defs etc. The reassembly is purely
          syntactical. Thus it might work, but to program is unlikely to run well. A proper
          non-interference analysis should be performed to make sure the semantic is preserved.



Debugging
=========

.. note:: Once instanciated, it is possible to access the plugin object
          with ``from qsynthesis import qsynthesis_plugin``.
```

`doc/requirements.txt`:

```txt
sphinx_rtd_theme
sphinx!=5.2.0.post0
breathe
sphinx_fontawesome
sphinx-autodoc-typehints

# added for mock
psutil
ordered_set

```

`ida_plugin/qsynthesis_plugin.py`:

```py
#!/usr/bin/env python3

from qsynthesis.plugin.dependencies import ida_idaapi, ida_kernwin, QTRACEIDA_ENABLED, TRITON_ENABLED
import qsynthesis


class QSynthesisPlugin(ida_idaapi.plugin_t):
    """
    Main QSynthesis plugin object. Depending on the presence of Qtrace-IDA it
    behaves differently.
    """

    flags = ida_idaapi.PLUGIN_UNL
    comment = "QSynthesis IDA plugin"
    help = "Plugin to perform program synthesis of symbolic expressions"
    wanted_name = "QSynthesis"
    wanted_hotkey = "Alt-S"

    def init(self) -> int:
        """
        Initialize the plugin upon loading. Register it as an IDA addon so
        that Qtrace-IDA will be able to find it through its loading mechanism.
        If triton is not found disable it permanently.
        """
        addon_info = ida_kernwin.addon_info_t()
        addon_info.id = "com.quarkslab.qtraceida.qsynthesis.plugin"
        addon_info.name = self.wanted_name
        addon_info.producer = "Quarkslab"
        addon_info.version = qsynthesis.__version__
        addon_info.url = "https://github.com/quarkslab/qsynthesis"
        addon_info.freeform = "Copyright (c) 2020 - All Rights Reserved"
        ida_kernwin.register_addon(addon_info)
        self.view = None
        return ida_idaapi.PLUGIN_OK if TRITON_ENABLED else ida_idaapi.PLUGIN_SKIP

    def run(self, arg) -> None:
        """
        Run the plugin. If Qtrace-IDA is enabled, the action_handler_t
        should have been registered so call it. If no Qtrace-IDA is
        present open the main view as a standalone plugin.
        """
        print("Running QSynthesis")

        if QTRACEIDA_ENABLED and 'qtraceida' in globals():  # qtaceida has been loaded launched it through Qtrace-IDA mechanism
            import qtraceida
            qtrace = qtraceida.get_qtrace()  # Open Qtrace if it was not already done
            # If QtraceIDA enable the action should have been registered
            from qsynthesis.plugin.actions import SynthetizerViewHook
            ida_kernwin.process_ui_action(SynthetizerViewHook.view_id)
            if not qtrace.trace_opened():
                print("Please open a trace before using QSynthesis")
        else:  # Qtrace-IDA not loaded or not installed open QSynthesis on its own
            from qsynthesis.plugin.view import SynthesizerView
            self.view = SynthesizerView(None)
            self.view.Show()  # Show will call OnCreate that will call init
            self.view.open_no_trace()

    def term(self) -> None:
        pass


def PLUGIN_ENTRY():
    qsynthesis.qsynthesis_plugin = QSynthesisPlugin()
    return qsynthesis.qsynthesis_plugin


def main():
    # Standalone IDA-less mode. This way of launching QSynthesis
    # is mostly here for testing (faster than with IDA)
    import sys
    from PyQt5.QtWidgets import QApplication
    from qsynthesis.plugin.view import SynthesizerView
    app = QApplication(sys.argv)
    widget = SynthesizerView(None)
    widget.init()
    widget.show()
    app.exec_()


if __name__ == "__main__":
    main()

```

`qsynthesis/__init__.py`:

```py
from qsynthesis.algorithms import TopDownSynthesizer, PlaceHolderSynthesizer
from qsynthesis.grammar import TritonGrammar, BvOp
from qsynthesis.tables import InputOutputOracleREST, InputOutputOracleLevelDB, HashType
from qsynthesis.utils.symexec import SimpleSymExec
from qsynthesis.tritonast import TritonAst

import logging

__version__ = "0.1.2"

# Simple object used to retrieve the plugin in IDA
qsynthesis_plugin = None


def enable_logging(level: int = 0):
    logger = logging.getLogger("qsynthesis")
    if level:
        logger.setLevel(level)
    logger.disabled = False


def disable_logging():
    logger = logging.getLogger("qsynthesis")
    logger.disabled = True

```

`qsynthesis/algorithms/__init__.py`:

```py
from .synthesizer_td import TopDownSynthesizer
from .synthesizer_plhld import PlaceHolderSynthesizer

```

`qsynthesis/algorithms/synthesizer_base.py`:

```py
# built-in modules
from __future__ import annotations
import logging

# qsynthesis deps
from qsynthesis.tables.base import InputOutputOracle
from qsynthesis.tritonast import TritonAst
from qsynthesis.types import Input, List, Optional, Tuple, Union, Output

logger = logging.getLogger("qsynthesis")


class SynthesizerBase:
    """
    Base Synthesizer that provides base function for children classes.
    It provides function for a given TritonAst to evaluate it against
    oracle inputs and to perform the lookup in order to know
    if a shorter expression exists.
    """

    def __init__(self, ltms: Union[InputOutputOracle, List[InputOutputOracle]], only_first_match: bool = False, learning_new_exprs: bool = False):
        """
        Constructor that takes one or multiple oracles as input.

        :param ltms: Single oracle or a list
        :param only_first_match: boolean that stop interating over tables as soon as the lookup is successfull for one
        :param learning_new_exprs: boolean that enables improving the current table if if a synthesized entry appears
                                   to be bigger than the one submitted
        """
        self._ltms = [ltms] if isinstance(ltms, InputOutputOracle) else ltms
        self.only_first_match = only_first_match
        self.learning_enabled = learning_new_exprs

        # Caches use internally
        self.expr_cache = {}  # Dict expr_str -> synth_expr
        self.eval_cache = {}  # Dict associating a the hash of an AST to a map of inputs -> output

        # Stats
        self.call_to_eval = 0
        self.cache_hit = 0
        self.eval_count = 0

    def synthesize(self, ioast: TritonAst, check_sem: bool = False) -> Tuple[TritonAst, bool]:
        """
        Abstract function that synthesize the given TritonAst, into a smaller if it exists.
        The implementation of this function is delegated to children classes.

        :param ioast: TritonAst object to synthesize
        :param check_sem: boolean one whether to check the semantic equivalence of expression
                          before substituting them. That ensure soundness of the synthesis
        :returns: tuple with new TritonAst and whether some replacement took place or not

        .. warning:: Activating the `check_sem` parameter implies a strong overhead
                     on the synthesis as SMT queries are being performed for any candidates
        """
        raise NotImplementedError("Should be implemented in children class")

    def try_synthesis_lookup(self, cur_ast: TritonAst, check_sem: bool = False) -> Optional[TritonAst]:
        """
        Performs a direct synthesis lookup. And returns an optional TritonAst if it the
        I/O evaluation has been found in one of the tables. Unlike :meth:`SynthesizerBase.synthesize`
        which can go down the AST to try simplifying sub-AST here only the root node is
        attempted to be synthesized.

        :param cur_ast: TritonAst to synthesize
        :param check_sem: boolean on whether to check the semantic equivalence of expression
                          before performing substituting.
        :returns: optional TritonAst if the the AST has been synthesized
        """

        # Try all lookup-tables and pick the shortest expression
        best_len = 0
        best_expr = None
        vars_e = cur_ast.symvars
        size_e = cur_ast.node_count

        if cur_ast.hash in self.expr_cache:
            self.cache_hit += 1
            logger.debug("expression cache found !")
            return self.expr_cache[cur_ast.hash]

        for table in self._ltms:
            # skip tables not having enough variables or the wrong bitsize
            if table.var_number < len(vars_e) or table.bitsize != cur_ast.size:
                continue

            synth_ast = self.run_direct_synthesis(table, cur_ast)
            if synth_ast is None:
                continue

            # Check if we got something better
            e_node_cnt = synth_ast.node_count
            if (best_expr is None and e_node_cnt < size_e) or (e_node_cnt < best_len):
                logger.debug(f"[base] candidate expr accepted: current:{size_e} candidate:{e_node_cnt} (best:{best_len})  => {synth_ast.pp_str}")
                best_len, best_expr = e_node_cnt, synth_ast
                if self.only_first_match:
                    break
            else:
                pass

            if best_len == 1:  # It cannot go better that this, so we can stop
                break

        if best_expr is not None:
            self.expr_cache[cur_ast.hash] = best_expr
            if check_sem:
                if cur_ast.is_semantically_equal(best_expr):
                    logger.info("Expressions are semantically equal")
                else:
                    logger.error("Expressions are semantically different (return None)!!")
                    return None
            return best_expr

    def run_direct_synthesis(self, ltm: InputOutputOracle, cur_ast: TritonAst) -> Optional['TritonAst']:
        """
        Evaluate `cur_ast` on inputs provided by `ltm` the oracle which provide an
        output vector then used to perform the lookup in the database. If an entry is found
        it is returned.

        :param ltm: InputOutputOracle object in which to perform the query
        :param cur_ast: TritonAst object to synthesize
        :returns: optional TritonAst if the an entry was found
        """

        # Evaluate node on LTMs inputs
        outputs = [self.eval_ast(cur_ast, i) for i in ltm.inputs]

        if len(set(outputs)) == 1:  # If all outputs are equal then we consider this as a constant expression
            logger.debug(f"[base] Found constant expression in {ltm.name}: {cur_ast.pp_str} ===> {outputs[0]}")
            return cur_ast.mk_constant(outputs[0], cur_ast.size)
        else:
            # Lookup expression with same outputs in the LT
            lk_expr = ltm.lookup(outputs, cur_ast, use_cache=False)
            if lk_expr is None:
                return None
            else:
                if lk_expr.node_count > cur_ast.node_count:
                    logger.debug(f"[base] synthesized bigger expression ({lk_expr.pp_str}) than given ({cur_ast.pp_str})")
                    if ltm.is_writable and self.learning_enabled:
                        h = ltm.hash(outputs)
                        s = cur_ast.to_normalized_str()
                        logger.info(f"[base] expression {s} added to {ltm.name}")
                        ltm.add_entry(h, s)
                return lk_expr

    def eval_ast(self, ioast: TritonAst, input: Input) -> Output:
        """
        Run evaluation of the TritonAst `ioast` on the given Input (valuation for all vars).
        The result is an Output (integer)

        :param ioast: TritonAst to evaluate
        :type ioast: TritonAst
        :param input: Input on which to evaluate the AST. All variables of ioast must
                      be defined in input
        :type input: :py:obj:`qsynthesis.types.Input`
        :returns: Output which is the result of evaluation (made by Triton)
        :rtype: :py:obj:`qsynthesis.types.Output`
        """
        self.call_to_eval += 1
        tup_inputs = tuple(input.items())

        ast_hash = ioast.hash
        if ast_hash in self.eval_cache:
            if tup_inputs in self.eval_cache[ast_hash]:
                return self.eval_cache[ast_hash][tup_inputs]
        else:
            self.eval_cache[ast_hash] = {}

        output = ioast.eval_oracle(input)
        self.eval_count += 1
        self.eval_cache[ast_hash][tup_inputs] = output
        return output

```

`qsynthesis/algorithms/synthesizer_plhld.py`:

```py
# built-in modules
from typing import Tuple, Dict

# qsynthesis modules
from qsynthesis.tritonast import TritonAst
from qsynthesis.algorithms.synthesizer_tdbu import TopDownBottomUpSynthesizer, YieldT, logger


class PlaceHolderSynthesizer(TopDownBottomUpSynthesizer):
    """
    Synthesizer inherited from TopDownBottomUpSynthesizer which thus
    form the search in that manner. The specificity of this synthesizer
    is to temporarily replacing synthesized expressions with a placeholder
    variable that will 'abstract the behavior of the synthesized AST'. The
    intended effect is to recursively synthesized previously synthesized
    sub-AST (with these placeholders). At the end of the search all placeholder
    variables are substituted by their associated synthesized expression.
    """

    def synthesize(self, ioast: TritonAst, check_sem: bool = False) -> Tuple[TritonAst, bool]:
        """
        Performs the placeholder based top-down and then bottom-up search for synthesizing
        the given TritonAst.

        :param ioast: TritonAst object to synthesize
        :param check_sem: boolean one whether to check the semantic equivalence of expression
                          before substituting them. That ensure soundness of the synthesis
        :return: tuple with new TritonAst and whether some replacement took place or not

        .. warning:: Activating the `check_sem` parameter implies a strong overhead
                     on the synthesis as SMT queries are being performed for any candidates
        """
        ioast = ioast.duplicate()  # Make a copy of the AST to to modify it
        self.expr_cache = {}
        self.eval_cache = {}
        self.call_to_eval = 0
        self.eval_count = 0

        expr_repl_visitor = self._visit_replacement_bfs(ioast)
        new_expr_to_send = None  # hold Ast replacement
        expr_modified = False    # True as soon as one sub-ast has been synthesized
        replacements = {}        # AST -> Placeholder AST
        replacements_hashs = {}  # AST hash -> Placeholder
        cur_placeholder = 0

        while 1:
            logger.debug(f"[plhdr] sending: {new_expr_to_send.pp_str if new_expr_to_send is not None else None}")
            cur_ast, info = expr_repl_visitor.send(new_expr_to_send)  # Iterate generator

            if isinstance(info, bool):
                final_ast = cur_ast
                break # Don't do anything of final expr return

            # Check if not already substituted, if so yield directly the placeholder
            if cur_ast.hash in replacements_hashs:
                logger.debug(f"[plhdr] Hash match: {cur_ast.pp_str} ==> {replacements_hashs[cur_ast.hash].pp_str}")
                new_expr_to_send = replacements_hashs[cur_ast.hash]
                continue

            # If don't have children either constant or variable just continue
            if not cur_ast.has_children(): # FIXME: If constant maybe symbolizing it
                continue

            # Try synthesizing expression
            logger.debug(f"[phldr] try synthesis lookup: {cur_ast.pp_str if cur_ast.node_count < 50 else 'too large'} [{cur_ast.node_count}] [{info.name}]")
            synt_res = self.try_synthesis_lookup(cur_ast, check_sem)

            if synt_res is not None:
                expr_modified = True
            else:
                new_expr_to_send = None
                if info == YieldT.TopBottom:
                    continue
                else:  # BottomUp
                    if self._ast_binop_with_cst(cur_ast):  # If binary operation with a constant make a placeholder
                        synt_res = cur_ast
                    else:
                        continue

            # Here necessarily synthesized of BottomUp

            # Create the a placeholder whether or not we synthesized the expression !
            placeholder = ioast.mk_variable(f"plhd_{cur_placeholder}", synt_res.size)
            cur_placeholder += 1
            replacements[placeholder] = synt_res
            replacements_hashs[cur_ast.hash] = placeholder
            new_expr_to_send = placeholder
            logger.debug(f"[plhdr] Create Placeholder plhd_{cur_placeholder-1} for: {synt_res.pp_str} ptr_id: {synt_res.ptr_id}")

        logger.debug(f"[plhdr] AST before replacement: {final_ast.pp_str}")
        for k, v in replacements.items():
            logger.debug(f"Final replace {k.pp_str}  ==> {v.pp_str}")
        self.replace_all(final_ast, replacements, recursive=True)
        final_ast.update_all()
        logger.info(f"Final AST: {final_ast.pp_str}")
        return final_ast, expr_modified

    @staticmethod
    def _ast_binop_with_cst(ast: TritonAst) -> bool:
        """
        Find if either the left or right branch of an AST is a constant.
        That enable replacing them with placeholder variable to help the
        synthesis by temporarily getting rid of constants.

        :param ast: TritonAst
        :return: True if left or right child of the AST is a constant
        """
        return sum(x.is_constant() for x in ast.get_children()) != 0

    def replace_all(self, ast: TritonAst, replacement: Dict[TritonAst, TritonAst], recursive: bool = False) -> None:
        """
        Performs the final replacement of Placeholder variable with their synthesized expression equivalence
        in `ast` provided in parameter.

        :param ast: TritonAst object in which to perform all substitutions
        :param replacement: dictionnary of placeholder variable as TritonAst to synthesized expression (TritonAst)
        :param recursive: whether to also perform the substitution in synthesized expressions given in the dictionnary
        :return: None as the `ast` object is modified in place

        .. warning:: All the expressions to replace should be present only once because TritonAst objects
                     are not deepcopied. Thus duplicating it at various location of the AST would be various dangerous
                     for attributes coherence when calling update
        """
        try:
            new_expr_to_send = None
            hash_mapping = {k.hash: k for k in replacement}

            logger.debug(f"Len replacement: {len(replacement)}  len hash_mapping:{len(hash_mapping)}")

            g = ast.visit_replacement(update=False)

            while True:
                cur_ast = g.send(new_expr_to_send)
                new_expr_to_send = None
                cur_ast_id = cur_ast.hash

                if cur_ast_id in hash_mapping:  # Prefilter with hash to check if current ast might be substituted
                    key = hash_mapping[cur_ast_id]
                    logger.debug(f"cur_ast: {cur_ast.pp_str}  key:{key.pp_str}  equal:{cur_ast.expr.equalTo(key.expr)}")

                    if not cur_ast.expr.equalTo(key.expr):  # Check that they are equal
                        logger.warning("two different expressions !")

                    new_expr_to_send = replacement[key]
                    logger.debug(f"Will replace {cur_ast.pp_str}  ==> {new_expr_to_send.pp_str}")

                    if recursive:
                        self.replace_all(new_expr_to_send, replacement, recursive=recursive)
        except StopIteration:
            pass

```

`qsynthesis/algorithms/synthesizer_td.py`:

```py
# built-in module
from __future__ import annotations
from typing import Tuple

# qsynthesis deps
from qsynthesis.tritonast import TritonAst
from qsynthesis.algorithms.synthesizer_base import SynthesizerBase, logger


class TopDownSynthesizer(SynthesizerBase):
    """
    Synthesize with a Top-Down **only** AST search based on Triton AST.
    The complexity in worst case of the search is then O(n) with
    n the number of nodes in the AST to synthesize.
    """

    def synthesize(self, ioast: TritonAst, check_sem: bool = False) -> Tuple[TritonAst, bool]:
        """
        Perform the Top-Down search on the ioast to try synthesizing it. The algorithm first
        tries to synthesize the root node. If not successful descend recursively in all children
        of the AST to try substituting sub-ASTs.

        :param ioast: TritonAst object to synthesize
        :param check_sem: boolean one whether to check the semantic equivalence of expression
                          before substituting them. That ensure soundness of the synthesis
        :returns: tuple with new TritonAst and whether some replacement took place or not

        .. warning:: Activating the `check_sem` parameter implies a strong overhead
                     on the synthesis as SMT queries are being performed for any candidates
        """
        ioast = ioast.duplicate()  # Make a copy of the AST to modify it with breaking the one given in parameter
        self.expr_cache = {}
        self.eval_cache = {}
        self.call_to_eval = 0
        self.eval_count = 0

        next_expr_to_send = None
        has_been_synthesized = False
        is_first = True
        try:
            g = ioast.visit_replacement(update=True)
            while True:
                cur_ast = g.send(next_expr_to_send)
                next_expr_to_send = None  # reset next_expr_to_send

                if not cur_ast.has_children():  # If don't have children either constant or variable
                    continue

                logger.debug(f"try synthesis lookup: {cur_ast.pp_str} [{cur_ast.var_num}]")

                synt_res = self.try_synthesis_lookup(cur_ast, check_sem)

                if synt_res is not None:
                    has_been_synthesized = True
                    logger.debug(f"Replace: {cur_ast.pp_str} ===> {synt_res.pp_str}")
                    if is_first:  # root node has been synthesized
                        return synt_res, has_been_synthesized
                    else:
                        next_expr_to_send = synt_res

                is_first = False

        except StopIteration:
            return ioast, has_been_synthesized

```

`qsynthesis/algorithms/synthesizer_tdbu.py`:

```py
# built-in modules
from typing import List, Tuple, Generator, Union
from enum import IntEnum

# third-party modules
from ordered_set import OrderedSet

# qsynthesis modules
from qsynthesis.tables.base import InputOutputOracle
from qsynthesis.tritonast import TritonAst
from qsynthesis.algorithms.synthesizer_base import SynthesizerBase, logger


class YieldT(IntEnum):
    """
    Enum to identify the yield type in the huge
    generator that performs the AST search and
    substitution.
    """
    TopBottom = 1
    BottomUp = 2


class TopDownBottomUpSynthesizer(SynthesizerBase):
    """
    Synthesize with Top-Down then Bottom-Up AST search based on Triton AST.
    The idea behind this bi-directional search is that a node simplified in
    a sub-AST might enable synthesizing one of its parent by means of simplification
    if for instance we turn a two-variable AST in a one-variable AST.

    .. warning:: This class is not meant to be instanciated directly but rather
                 serving a common base for children class using this search strategy.
    """

    def __init__(self, ltms: Union[InputOutputOracle, List[InputOutputOracle]], only_first_match: bool = False, learning_new_exprs: bool = False):
        """
        Constructor that takes lookup tables as input.

        :param ltms: Single lookup table of a list of them
        :param only_first_match: boolean that stop interating over tables as soon as the lookup is successfull for one
        :param learning_new_exprs: boolean that enables improving the current table if if a synthesized entry appears
                                   to be bigger than the one submitted
        """
        super(TopDownBottomUpSynthesizer, self).__init__(ltms, only_first_match, learning_new_exprs)
        self.total_repl_td = 0
        self.total_repl_bu = 0

    def synthesize(self, ioast: TritonAst, check_sem: bool = False) -> Tuple[TritonAst, bool]:
        """
        Performs the Top-Down and then Bottom-Search to synthesize the AST

        :param ioast: TritonAst object to synthesize
        :param check_sem: boolean one whether to check the semantic equivalence of expression
                          before substituting them. That ensure soundness of the synthesis
        :returns: tuple with new TritonAst and whether some replacement took place or not

        .. warning:: Activating the `check_sem` parameter implies a strong overhead
                     on the synthesis as SMT queries are being performed for any candidates
        """
        ioast = ioast.duplicate()  # Make a copy of the ast not tamper it
        self.expr_cache = {}
        self.eval_cache = {}
        self.call_to_eval = 0
        self.eval_count = 0

        expr_repl_visitor = self._visit_replacement(ioast)
        new_expr_to_send = None
        expr_modified = False

        while 1:
            # logger.debug(f"Sending: {new_expr_to_send}")
            cur_expr, info = expr_repl_visitor.send(new_expr_to_send)  # Iterate generator
            # logger.debug(f"Receiving: {cur_expr}")
            if isinstance(info, bool):
                final_expr = cur_expr
                # logger.debug("final expression:", final_expr.replace("\n"," "))
                final_expr.update_all()
                return final_expr, expr_modified

            else:  # Try synthesizing expression
                logger.debug(f"try synthesis lookup: {cur_expr.pp_str if cur_expr.node_count < 50 else 'too large'}")
                synt_res = self.try_synthesis_lookup(cur_expr, check_sem)
                if synt_res is not None:
                    expr_modified = True
                new_expr_to_send = synt_res  # Send the result to the generator (thus either new expr or None)

    def _visit_replacement(self, ast: TritonAst, iff_replace=True, update=True) -> Generator[Tuple[TritonAst, Union[YieldT, bool]], TritonAst, None]:
        """
        Generator that will iterate over the AST. It will yield each sub-AST and is expecting
        through the send mechanism to receive None (meaning nothing has been found) or a TritonAst
        which means the AST just yielded have to be substituted by this one.

        .. note:: Deprecated to use. Use _visit_replacement_bfs instead
        """
        chs = ast.get_children()
        if not chs:  # If arity is 0 (variable and constant)
            yield ast, False  # Yield the final expr as-is
        else:
            # Normally here in Z3Ast check here if expression is bool
            rep = yield ast, YieldT.TopBottom  # First (Top-Down yield)

            if rep is not None:  # We should replace this expr
                self.total_repl_td += 1
                yield rep, True  # Final (yield)
            else:
                reps = {}  # index -> (expr, bool) the boolean true if expr was replaced
                for i, c in enumerate(chs):  # Iterate (and simplify) all childrens
                    g = self._visit_replacement(c, iff_replace, update)
                    recv = None
                    while 1:
                        it, info = g.send(recv)  # forward the new expression to the sub-generator
                        if isinstance(info, bool):  # is a final yield
                            reps[i] = it, info
                            break
                        else:
                            recv = yield it, info  # re-yield it above (and receive a new expression)

                if sum(x[1] for x in reps.values()) or not iff_replace:  # at least on replacement took place among children
                    for i, (e, b) in reps.items():
                        if b:  # expr has been replaced
                            ast.set_child(i, e)  # replace the child
                    if update:  # if one of the children got replaced and update, update fields
                        ast.update()
                    rep = yield ast, YieldT.BottomUp  # Second (Bottom-Up yield) (if not bool expr)
                    if rep is None:
                        yield ast, True  # Final yield
                    else:
                        self.total_repl_bu += 1
                        yield rep, True  # Final yield
                else:
                    yield ast, False

    def _visit_replacement_bfs(self, orig_ast: TritonAst) -> Generator[Tuple[TritonAst, Union[YieldT, bool]], TritonAst, None]:
        """
        Generator that will iterate over the AST. It will yield each sub-AST and is expecting
        through the send mechanism to receive None (meaning nothing has been found) or a TritonAst
        which means the AST just yielded have to be substituted by this one. The search is made in
        a Breath-First-Search manner as it provides better results for synthesis.

        :param orig_ast: TritonAst to iterate (and to modify)
        :returns: generator that always yield a TritonAst and either a yield type indicating whether it is during
                  the top-down or bottom-up search or a boolean indicating all substitutions have been performed
                  in the AST. The generate receive via send a new TritonAst or None
        """
        worklist = OrderedSet([orig_ast])
        bottomup_worklist = OrderedSet([orig_ast])
        modified = False
        mode = YieldT.TopBottom

        while worklist:
            ast = worklist.pop(0)
            logger.debug(f"\n[visit_replacement] pop [{ast.ptr_id}]({len(ast.get_children())}) {ast.pp_str}  worklist:[{len(worklist)}] bu_worklist:[{len(bottomup_worklist)}]")

            if not ast.is_leaf():
                rep = yield ast, mode  # Current yield (TopB, or BotUp)
            else:
                rep = None

            if rep is not None:  # We should replace this expr
                modified = True
                self.total_repl_td += 1 if mode == YieldT.TopBottom else 0
                self.total_repl_bu += 1 if mode == YieldT.BottomUp else 0
                if ast.is_root():
                    logger.debug(f"YIeld new root ahead of time: {rep.pp_str}")
                    yield rep, modified  # Final yield (ahead of time)
                else:
                    logger.debug(f"replace_self: {str(ast.expr)} => {rep.pp_str}")
                    ast.replace_self(rep, update_parents=True)
            else:
                if mode == YieldT.TopBottom:
                    logger.debug(f"[visit_replacement] worklist updates before wl:[{len(worklist)}] buwl:[{len(bottomup_worklist)}]")
                    worklist.update(ast.get_children())  # add child in the TopDown only if it has not been replaced
                    bottomup_worklist.add(ast)  # add itself in the BottomUp list !
                    logger.debug(f"[visit_replacement] worklist updates wl:[{len(worklist)}] buwl:[{len(bottomup_worklist)}]")

            if not worklist:
                logger.debug("--------------------------------- Switch Bottom Up -----------------------------------")
                logger.debug(f"AST at that time: {orig_ast.pp_str}")
                mode = YieldT.BottomUp
                worklist = bottomup_worklist[::-1]  # switch the worklist
                bottomup_worklist = []
        yield orig_ast, modified  # Final yield

```

`qsynthesis/grammar/__init__.py`:

```py
from .grammar import TritonGrammar
from .ops import BvOp

```

`qsynthesis/grammar/grammar.py`:

```py
# Standard modules
from __future__ import annotations
import random

# Qsynthesis types
from qsynthesis.types import BitSize, Char, Input, Dict, List, Tuple
from qsynthesis.tritonast import TritonAst
from qsynthesis.grammar.ops import BvOp, Operator, OPERATORS


class TritonGrammar(object):
    """
    Triton Grammar class. It represent a set of operators, and variables
    of a given size (only 64 bits at the moment).
    """

    def __init__(self, vars: List[Tuple[Char, BitSize]], ops: List[BvOp]):
        """
        Constructor taking a set of variables (name and size) and a set of operators.

        :param vars: list of tuple of (name ,size)
        :type vars: List[Tuple[:py:obj:`qsynthesis.types.Char`, :py:obj:`qsynthesis.types.BitSize`]]
        :param ops: list of BvOp representing operators
        :type ops: List[BvOp]
        """
        self.ops = ops
        self.vars_dict = {x[0]: x[1] for x in vars}  # Dict of str->size
        self.vars = list(self.vars_dict.keys())

        self.size = self.vars_dict[self.vars[0]]  # take size of the first var as they all have the same size

    @property
    def non_terminal_operators(self) -> List[Operator]:
        """
        Return the list of non-terminal operators. All unary and
        binary operators are non terminal as they can be derived.

        :return: list of operators namedtuples
        """
        return [OPERATORS[x] for x in self.ops]

    def gen_test_inputs(self, n: int) -> List[Input]:
        """
        Generate a list of ``n`` input. Thus it generate a random
        valuation for each variables of the grammar and that n times.

        :param n: Number of Input to generate (size of the list)
        :type n: int
        :returns: list of inputs
        :rtype: List[:py:obj:`qsynthesis.types.Input`]
        """
        return [{var: random.getrandbits(self.vars_dict[var]) for var in self.vars} for _ in range(n)]

    def str_to_expr(self, s: str, *args) -> TritonAst:
        """
        Convert a string in the format of the grammar into a TritonAst.
        In practice an args[0] should be a TritonAst from which to spawn
        a new TritonAst. That is required to get the same mapping of normalized
        variables than the one used by expr.

        :param s: expression string to convert to TritonAst
        :return: the TritonAst representing the expressions string
        :raises: NameError, TypeError
        """
        expr = args[0]
        return expr.normalized_str_to_ast(s)

    def to_dict(self) -> Dict:
        """
        Return a dictionnary representation of the grammar.
        This is used for serialization in database etc.
        """
        return dict(
            vars=[(n, sz) for n, sz in self.vars_dict.items()],
            operators=[x.name for x in self.ops]
        )

    @staticmethod
    def from_dict(g_dict: Dict) -> 'TritonGrammar':
        """
        Static method instanciating a TritonGrammar from its representation as
        a dictionnary.

        :param g_dict: dictionarry representation of the grammar
        :returns: TritonGrammar object
        """
        return TritonGrammar(g_dict['vars'], [BvOp[x] for x in g_dict['operators']])

```

`qsynthesis/grammar/jitting.py`:

```py
from qsynthesis.grammar.ops import BvOp
import pydffi
import array

# First, declare an FFI context
CODE = '''
#include <stdio.h>
#include <stdint.h> 
uint64_t add(uint64_t a, uint64_t b) { return a+b; }
uint64_t and(uint64_t a, uint64_t b) { return a&b; }
uint64_t or(uint64_t a, uint64_t b) { return a|b; }
uint64_t xor(uint64_t a, uint64_t b) { return a^b; }
uint64_t sub(uint64_t a, uint64_t b) { return a-b; }
uint64_t mul(uint64_t a, uint64_t b) { return a*b; }
uint64_t udiv(uint64_t a, uint64_t b) { return a/b; }
uint64_t usub(uint64_t a) { return -a; }
uint64_t invert(uint64_t a) { return ~a; }
uint64_t to_uint(int64_t a) { return (uint64_t) a; }
uint64_t urem(uint64_t a, uint64_t b) { return  b==0? a: a % b ; }
uint64_t ashr(uint64_t a, uint64_t b) { int bitsz = sizeof(uint64_t)*8; return (b >= bitsz)? ((int64_t) a) >> bitsz-1: ((int64_t) a) >> b; }
uint64_t sle(int64_t a, int64_t b) { return a <= b ; }
uint64_t slt(int64_t a, int64_t b) { return a < b ; }
uint64_t sge(int64_t a, int64_t b) { return a >= b ; }
uint64_t sgt(int64_t a, int64_t b) { return a > b ; }
uint64_t lshift(uint64_t a, uint64_t b) { return (b >= sizeof(uint64_t)*8)? 0: a << b; }
uint64_t rshift(uint64_t a, uint64_t b) { return (b >= sizeof(uint64_t)*8)? 0: a >> b; }
uint64_t rol(uint64_t i, uint64_t n) { int bitsz = 8*sizeof(n); return (n << (i%bitsz)) | (n >> (8*sizeof(n) - (i%bitsz))); }
uint64_t ror(uint64_t i, uint64_t n) { int bitsz = 8*sizeof(n); return (n >> (i%bitsz))|(n << (8*sizeof(n) - (i%bitsz))); }
uint64_t mod(uint64_t a, uint64_t b) { return a % b; }


void add_arr(uint64_t* dst, uint64_t* a, uint64_t* b, size_t n) { for(int i=0; i < n; i ++) { dst[i] = a[i] + b[i]; } }
void and_arr(uint64_t* dst, uint64_t* a, uint64_t* b, size_t n) { for(int i=0; i < n; i ++) { dst[i] = a[i] & b[i]; } }
void or_arr(uint64_t* dst, uint64_t* a, uint64_t* b, size_t n) { for(int i=0; i < n; i ++) { dst[i] = a[i] | b[i]; } }
void xor_arr(uint64_t* dst, uint64_t* a, uint64_t* b, size_t n) { for(int i=0; i < n; i ++) { dst[i] = a[i] ^ b[i]; } }
void sub_arr(uint64_t* dst, uint64_t* a, uint64_t* b, size_t n) { for(int i=0; i < n; i ++) { dst[i] = a[i] - b[i]; } }
void mul_arr(uint64_t* dst, uint64_t* a, uint64_t* b, size_t n) { for(int i=0; i < n; i ++) { dst[i] = a[i] * b[i]; } }
void udiv_arr(uint64_t* dst, uint64_t* a, uint64_t* b, size_t n) { for(int i=0; i < n; i ++) { dst[i] = a[i] / b[i]; } }
void usub_arr(uint64_t* dst, uint64_t* a, size_t n) { for(int i=0; i < n; i ++) { dst[i] = -a[i]; } }
void invert_arr(uint64_t* dst, uint64_t* a, size_t n) { for(int i=0; i < n; i ++) { dst[i] = ~a[i]; } }
void urem_arr(uint64_t* dst, uint64_t* a, uint64_t* b, size_t n) { for(int i=0; i < n; i ++) { dst[i] = b[i]==0? a[i]: a[i] % b[i] ; } }
void ashr_arr(uint64_t* dst, uint64_t* a, uint64_t* b, size_t n) { int bitsz = sizeof(uint64_t)*8; for(int i=0; i < n; i ++) { dst[i] = (b[i] >= bitsz)? ((int64_t) a[i]) >> bitsz-1: ((int64_t) a[i]) >> b[i]; } }
void sle_arr(uint64_t* dst, int64_t* a, int64_t* b, size_t n) { for(int i=0; i < n; i ++) { dst[i] = a[i] <= b[i] ; } }
void slt_arr(uint64_t* dst, int64_t* a, int64_t* b, size_t n) { for(int i=0; i < n; i ++) { dst[i] = a[i] < b[i] ; } }
void sge_arr(uint64_t* dst, int64_t* a, int64_t* b, size_t n) { for(int i=0; i < n; i ++) { dst[i] = a[i] >= b[i] ; } }
void sgt_arr(uint64_t* dst, int64_t* a, int64_t* b, size_t n) { for(int i=0; i < n; i ++) { dst[i] = a[i] > b[i] ; } }
void lshift_arr(uint64_t* dst, uint64_t* a, uint64_t* b, size_t n) { for(int i=0; i < n; i ++) { dst[i] = (b[i] >= sizeof(uint64_t)*8)? 0: a[i] << b[i]; } }
void rshift_arr(uint64_t* dst, uint64_t* a, uint64_t* b, size_t n) { for(int i=0; i < n; i ++) { dst[i] = (b[i] >= sizeof(uint64_t)*8)? 0: a[i] >> b[i]; } }
void rol_arr(uint64_t* dst, uint64_t* i, uint64_t* n, size_t sz) { for(int j=0; j < sz; j ++) { int bsz = 8*sizeof(n[j]); dst[j] = (n[j] << (i[j]%bsz)) | (n[j] >> (bsz - (i[j]%bsz))); } }
void ror_arr(uint64_t* dst, uint64_t* i, uint64_t* n, size_t sz) { for(int j=0; j < sz; j ++) { int bsz = 8*sizeof(n[j]); dst[j] = (n[j] >> (i[j]%bsz)) | (n[j] << (bsz - (i[j]%bsz))); } }
void mod_arr(uint64_t* dst, uint64_t* a, uint64_t* b, size_t n) { for(int i=0; i < n; i ++) { dst[i] = a[i] % b[i] ; } }
'''

ffi_ctx = pydffi.FFI(lazyJITWrappers=False)


def make_compilation_unit(bitsize: int):
    global ffi_ctx
    good_code = CODE.replace("64", str(bitsize))
    return ffi_ctx.compile(good_code)


def _get_func_name(op: 'Operator') -> str:
    return {
        BvOp.NOT: "invert",
        BvOp.AND: "and",
        BvOp.OR: "or",
        BvOp.XOR: "xor",
        BvOp.NEG: "usub",
        BvOp.ADD: "add",
        BvOp.MUL: "mul",
        BvOp.SUB: "sub",
        BvOp.SHL: "lshift",
        BvOp.LSHR: "rshift",
        BvOp.ROL: "rol",
        BvOp.ROR: "ror",
        BvOp.ASHR: "ashr",
    }[op.id]


def get_op_eval(cu, op):
    return getattr(cu.funcs, _get_func_name(op))


def get_op_eval_array(cu, op):
    return getattr(cu.funcs, f"{_get_func_name(op)}_arr")


def get_native_array_type(size_t, size):
    global ffi_ctx
    typ = {
        8: ffi_ctx.UInt8Ty,
        16: ffi_ctx.UInt16Ty,
        32: ffi_ctx.UInt32Ty,
        64: ffi_ctx.UInt64Ty
    }
    return ffi_ctx.arrayType(typ[size_t], size)


def init_array_cst(ffi_array, val, size, size_t) -> None:
    map = {8: 'B', 16: 'H', 32: 'I', 64: 'Q'}
    pydffi.view_as_bytes(ffi_array)[:] = array.array(map[size_t], [val]*size).tobytes()

```

`qsynthesis/grammar/ops.py`:

```py
from enum import IntEnum
from triton import AST_NODE
from collections import namedtuple
import operator


class BoolOp(IntEnum):
    """
    Enum of SMT boolean operators using Triton AST_NODE
    enum value
    """
    # Bool x Bool -> Bool
    AND = AST_NODE.LAND
    NOT = AST_NODE.LNOT
    LOR = AST_NODE.LOR
    IFF = AST_NODE.IFF
    EQUAL = AST_NODE.EQUAL
    DISTINCT = AST_NODE.DISTINCT


class BvOp(IntEnum):
    """
    Enum of SMT Bitvector operators as declared by Triton AST_NODE
    """
    # Basic ops
    NOT = AST_NODE.BVNOT
    AND = AST_NODE.BVAND
    OR = AST_NODE.BVOR
    XOR = AST_NODE.BVXOR
    NEG = AST_NODE.BVNEG
    ADD = AST_NODE.BVADD
    MUL = AST_NODE.BVMUL
    SUB = AST_NODE.BVSUB
    SHL = AST_NODE.BVSHL
    LSHR = AST_NODE.BVLSHR
    ROL = AST_NODE.BVROL  # Int x Bv -> Bv
    ROR = AST_NODE.BVROR  # Int x Bv -> Bv
    UDIV = AST_NODE.BVUDIV
    UREM = AST_NODE.BVUREM
    ASHR = AST_NODE.BVASHR
    SDIV = AST_NODE.BVSDIV
    SREM = AST_NODE.BVSREM
    SMOD = AST_NODE.BVSMOD
    # Extended
    XNOR = AST_NODE.BVXNOR
    NOR = AST_NODE.BVNOR
    NAND = AST_NODE.BVNAND
    # Change bit size
    ZEXT = AST_NODE.ZX  # Int x Bv -> Bv
    SEXT = AST_NODE.SX  # Int x Bv -> Bv
    CONCAT = AST_NODE.CONCAT
    EXTRACT = AST_NODE.EXTRACT  # Int x Int x Bv -> Bv
    # Other: Bool x BV x BV -> Bv
    ITE = AST_NODE.ITE
    # Boolean ops: BV x BV -> Bool
    UGE = AST_NODE.BVUGE
    UGT = AST_NODE.BVUGT
    ULE = AST_NODE.BVULE
    ULT = AST_NODE.BVULT
    SLE = AST_NODE.BVSLE
    SLT = AST_NODE.BVSLT
    SGE = AST_NODE.BVSGE
    SGT = AST_NODE.BVSGT


Operator = namedtuple("Operator", "id symbol eval_trit arity commutative id_eq id_zero is_prefix can_overflow bool_ret")


OPERATORS = {               # ID               strop    Trit op            arit comm   id_eq  id_zero is_pfx  can_ov bool_ret
    # BoolOp.EQUAL:    Operator(BoolOp.EQUAL,    "==",    operator.eq,     2,   True,  True,  False,  False,  False, True),
    # BoolOp.DISTINCT: Operator(BoolOp.DISTINCT, "!=",    operator.ne,     2,   True,  False, True,   False,  False, True),
    # BoolOp.IFF:      Operator(BoolOp.IFF,      "iff",   "iff",           2,   False, False, False,  False,  False, True),
    # BoolOp.LOR:      Operator(BoolOp.LOR,      "lor",   "lor",           2,   True,  True,  False,  True,   False, True),
    # BoolOp.AND:      Operator(BoolOp.AND,      "land",  "land",          2,   True,  True,  False,  True,   False, True),
    # BoolOp.NOT:      Operator(BoolOp.NOT,      "lnot",  "lnot",          1,   False, False, False,  True,   False, True),
    BvOp.NOT:        Operator(BvOp.NOT,        "~",     operator.invert,   1,   False, False, False,  True,   False, False),
    BvOp.AND:        Operator(BvOp.AND,        "&",     operator.and_,     2,   True,  True,  False,  False,  False, False),
    BvOp.OR:         Operator(BvOp.OR,         '|',     operator.or_,      2,   True,  True,  False,  False,  False, False),
    BvOp.XOR:        Operator(BvOp.XOR,        '^',     operator.xor,      2,   True,  False, True,   False,  False, False),
    BvOp.NEG:        Operator(BvOp.NEG,        '-',     operator.neg,      1,   False, False, False,  True,   False, False),
    BvOp.ADD:        Operator(BvOp.ADD,        '+',     operator.add,      2,   True,  False, False,  False,  True,  False),
    BvOp.MUL:        Operator(BvOp.MUL,        '*',     operator.mul,      2,   True,  False, False,  False,  True,  False),
    BvOp.SUB:        Operator(BvOp.SUB,        '-',     operator.sub,      2,   False, False, True,   False,  False, False),
    BvOp.SHL:        Operator(BvOp.SHL,        "<<",    operator.lshift,   2,   False, False, False,  False,  True,  False),
    BvOp.LSHR:       Operator(BvOp.LSHR,       ">>",    operator.rshift,   2,   False, False, False,  False,   False, False),

    BvOp.ROL:        Operator(BvOp.ROL,        "bvrol", "bvrol",           2,   False, False, False,  True,   False, False),
    BvOp.ROR:        Operator(BvOp.ROR,        "bvror", "bvror",           2,   False, False, False,  True,   False, False),
    # BvOp.UDIV:       Operator(BvOp.UDIV,       "/",     operator.truediv,2,   False, False, False,  False,  False, False), # TODO: Fix /0
    # BvOp.UREM:       Operator(BvOp.UREM,       "%",     operator.mod,    2,   False, False, False,  False,  False, False), # TODO: Fix /0
    BvOp.ASHR:       Operator(BvOp.ASHR,       "bvashr", "bvashr",         2,   False, False, False,  True,   False, False),
    # BvOp.SDIV:       Operator(BvOp.SDIV,       "bvsdiv","bvsdiv",        2,   False, False, False,  False,  False, False),
    # BvOp.SREM:       Operator(BvOp.SREM,       "bvsrem","bvsrem",        2,   False, False, True,   True,   False, False),
    # BvOp.SMOD:       Operator(BvOp.SMOD,       "bvsmod","bvsmod",        2,   False, False, True,   False,  False, False),
    # BvOp.XNOR:       Operator(BvOp.XNOR,       "bvxnor","bvxnor",        2,   True,  False, False,  True,   False, False),
    # BvOp.NOR:        Operator(BvOp.NOR,        "bvnor", "bvnor",         2,   True,  False, False,  True,   False, False),
    # BvOp.NAND:       Operator(BvOp.NAND,       "bvnand","bvnand",        2,   True,  False, False,  True,   False, False),
    # BvOp.ZEXT:       Operator(BvOp.ZEXT,       "zx",    "zx",            2,   False, True,  False,  True,   False, False),
    # BvOp.SEXT:       Operator(BvOp.SEXT,       "sx",    "sx",            2,   False, False, False,  True,   False, False), # FIXME: operator
    # BvOp.CONCAT:     Operator(BvOp.CONCAT,     "concat","concat",        2,   False, False, False,  True,   False, False), # FIXME: operator
    # BvOp.EXTRACT:    Operator(BvOp.EXTRACT,    "extract","extract",      2,   False, False, False,  True,   False, False), # FIXME: operator
    # BvOp.ITE:        Operator(BvOp.ITE,        "If",     "If",           3,   False, False, False,  True,   False, False),
    # BvOp.UGE:        Operator(BvOp.UGE,        ">=",     operator.ge,    2,   False, True,  False,  False,  False, True),
    # BvOp.UGT:        Operator(BvOp.UGT,        ">",      operator.gt,    2,   False, False, True,   False,  False, True),
    # BvOp.ULE:        Operator(BvOp.ULE,        "<=",     operator.le,    2,   False, True,  False,  False,  False, True),
    # BvOp.ULT:        Operator(BvOp.ULT,        "<",      operator.lt,    2,   False, False, True,   False,  False, True),
    # BvOp.SLE:        Operator(BvOp.SLE,        "bvsle",  "bvsle",        2,   False, True,  False,  True,   False, True),
    # BvOp.SLT:        Operator(BvOp.SLT,        "bvslt",  "bvslt",        2,   False, False, True,   True,   False, True),
    # BvOp.SGE:        Operator(BvOp.SGE,        "bvsge",  "bvsge",        2,   False, True,  False,  True,   False, True),
    # BvOp.SGT:        Operator(BvOp.SGT,        "bvsgt",  "bvsgt",        2,   False, False, True,   True,   False, True)
}

```

`qsynthesis/plugin/__init__.py`:

```py
from qsynthesis.plugin.actions import SynthetizerViewHook

hook_cls = SynthetizerViewHook


```

`qsynthesis/plugin/actions.py`:

```py
from qsynthesis.plugin.dependencies import ida_kernwin, TRITON_ENABLED, Trace


class SynthetizerViewHook(ida_kernwin.action_handler_t):
    """
    Standard hook to all Qtrace-IDA plugins. When used with
    Qtace-IDA, Qsynthesis is launched through this action_handler_t
    which will be registered in the qtrace-ida menu.
    """

    view_id = "QSynthesis"

    def __init__(self, qtrace: 'QtraceIDA'):
        """
        Constructor that receive a QtraceIDA instance (which is the main object of Qtrace-IDA
        holding the trace etc)
        """
        ida_kernwin.action_handler_t.__init__(self)
        from qtraceida.icons.raw_icons import ICON_DEBUG_ID, IDAIcon
        self.view = None
        self.name = "QSynthesis"  # SynthesizerView.NAME
        self.icon = IDAIcon.AST_TREE
        self.tooltip = "Synthesizing arithmetic expressions along the trace"
        self.qtrace = qtrace

    @property
    def is_enabled_by_trace(self) -> bool:
        """
        Boolean indicating if this qtraceida plugin should be enabled
        when a trace is opened.
        """
        return True

    def on_trace_opened(self, t: Trace) -> None:
        """
        Callback called when a trace is opened in Qtrace-IDA.
        Here we just forward the call to the main view.
        """
        if self.view:  # If the view has been instanciated
            self.view.on_trace_opened(t)

    def on_trace_closed(self) -> None:
        pass # TODO: Implementing proper deactivation of the view

    def activate(self, _) -> bool:
        """
        Main callback called when the menu entry is clicked or the Short-keys
        typed. This `action_handler_t` has to be implemented. If called the
        action open the QSynthesis view if not already done.
        """
        # pylint: disable=unused-argument
        from qsynthesis.plugin.view import SynthesizerView
        if self.view is None or self.view.closed:
            self.view = SynthesizerView(self.qtrace)
            self.view.Show()  # will call OnCreate and init and on_trace_opened by recursivity
        return True

    def update(self, _) -> int:
        """
        Callback called whenever the the hook is updated.
        If dependency are not satisfied always disabled otherwise ok.
        """
        if TRITON_ENABLED:
            return ida_kernwin.AST_DISABLE if self.is_enabled_by_trace else ida_kernwin.AST_ENABLE_ALWAYS
        else:
            self.tooltip = "Require Triton to run"
            return ida_kernwin.AST_DISABLE_ALWAYS

```

`qsynthesis/plugin/arch.py`:

```py
from typing import List, Optional

import capstone
from capstone import x86_const, arm_const, arm64_const, CS_AC_READ, CS_AC_WRITE
from enum import IntEnum
from collections import namedtuple

Reg = namedtuple("Reg", "name")


class Opnd:
    def __init__(self, cs_op, arch):
        self._cs_op = cs_op
        self._arch = arch

    @property
    def type(self):
        return self._cs_op.type

    def is_read(self) -> bool:
        return bool(self._cs_op.access & CS_AC_READ)

    def is_written(self) -> bool:
        return bool(self._cs_op.access & CS_AC_WRITE)

    def is_register(self) -> bool:
        return self.type == self._arch.optypes.REG

    def is_memory(self) -> bool:
        return self.type == self._arch.optypes.MEM


class Instr:
    def __init__(self, cs_ins, arch):
        self._cs_ins = cs_ins
        self._arch = arch

    @property
    def bytes(self):
        return bytes(self._cs_ins.bytes)

    def __str__(self):
        return self._cs_ins.mnemonic + " " + self._cs_ins.op_str

    @property
    def operands(self):
        return [Opnd(x, self._arch) for x in self._cs_ins.operands]


class Arch:
    _CSD = None

    def disasm(cls, asm: bytes, addr: int) -> List[Instr]:
        cls._CSD.detail = True
        return [Instr(x, cls) for x in cls._CSD.disasm(asm, addr)]

    def disasm_one(cls, asm: bytes, addr: int) -> Instr:
        r = cls.disasm(asm, addr)
        return r[0] if r else None



class _ArchX86(Arch):
    NAME = "x86"
    INS_PTR = Reg('eip')
    STK_PTR = Reg('esp')
    _CSD = capstone.Cs(capstone.CS_ARCH_X86, capstone.CS_MODE_32)
    nop_instruction = b"\x90"

    class optypes(IntEnum):
        INVALID = x86_const.X86_OP_INVALID
        IMM = x86_const.X86_OP_IMM
        REG = x86_const.X86_OP_REG
        MEM = x86_const.X86_OP_MEM


class _ArchX64(_ArchX86):
    NAME = "x86_64"
    INS_PTR = Reg('rip')
    STK_PTR = Reg('rsp')
    _CSD = capstone.Cs(capstone.CS_ARCH_X86, capstone.CS_MODE_64)



class _ArchARM(Arch):
    NAME = "ARM"
    INS_PTR = Reg('pc')
    STK_PTR = Reg('sp')
    _CSD = capstone.Cs(capstone.CS_ARCH_ARM, capstone.CS_MODE_ARM)
    nop_instruction = b"\x00\xf0\x20\xe3"

    class optypes(IntEnum):
        INVALID = arm_const.ARM_OP_INVALID
        REG = arm_const.ARM_OP_REG
        IMM = arm_const.ARM_OP_IMM
        MEM = arm_const.ARM_OP_MEM
        FP = arm_const.ARM_OP_FP
        CIMM = arm_const.ARM_OP_CIMM
        PIMM = arm_const.ARM_OP_PIMM
        SETEND = arm_const.ARM_OP_SETEND
        SYSREG = arm_const.ARM_OP_SYSREG


class _ArchARM64(Arch):
    NAME = "AARCH64"
    INS_PTR = Reg('x28')
    STK_PTR = Reg('sp')
    _CSD = capstone.Cs(capstone.CS_ARCH_ARM64, capstone.CS_MODE_ARM)
    nop_instruction = b"\x1f\x20\x03\xd5"

    class optypes(IntEnum):
        INVALID = arm64_const.ARM64_OP_INVALID
        REG = arm64_const.ARM64_OP_REG
        IMM = arm64_const.ARM64_OP_IMM
        MEM = arm64_const.ARM64_OP_MEM
        FP = arm64_const.ARM64_OP_FP
        CIMM = arm64_const.ARM64_OP_CIMM
        REG_MRS = arm64_const.ARM64_OP_REG_MRS
        REG_MSR = arm64_const.ARM64_OP_REG_MSR
        PSTATE = arm64_const.ARM64_OP_PSTATE
        SYS = arm64_const.ARM64_OP_SYS
        PREFETCH = arm64_const.ARM64_OP_PREFETCH
        BARRIER = arm64_const.ARM64_OP_BARRIER


ArchX86 = _ArchX86()
ArchX64 = _ArchX64()
ArchARM = _ArchARM()
ArchARM64 = _ArchARM64()


class ArchsManager:
    @staticmethod
    def get_supported_regs(arch: Arch) -> List[Reg]:
        if isinstance(arch, _ArchX64):
            return [Reg('RAX'), Reg('RBX'), Reg('RCX'), Reg('RDX'), Reg('RDI'), Reg('RSI'), Reg('RBP'), Reg('RSP'),
                    Reg('RIP'), Reg('EFLAGS'), Reg('R8'), Reg('R9'), Reg('R10'), Reg('R11'), Reg('R12'), Reg('R13'),
                    Reg('R14'), Reg('R15')]
        elif isinstance(arch, _ArchX86):
            return [Reg('EAX'), Reg('EBX'), Reg('ECX'), Reg('EDX'), Reg('EDI'), Reg('ESI'), Reg('EBP'), Reg('ESP'), Reg('EIP'), Reg('EFLAGS')]
        elif isinstance(arch, _ArchARM):
            return [Reg('R0'), Reg('R1'), Reg('R2'), Reg('R3'), Reg('R4'), Reg('R5'), Reg('R6'), Reg('R7'), Reg('R8'),
                    Reg('R9'), Reg('R10'), Reg('R11'), Reg('R12'), Reg('R13'), Reg('R14'), Reg('R15'), Reg('CPSR')]
        elif isinstance(arch, _ArchARM64):
            return [Reg('X0'), Reg('X1'), Reg('X2'), Reg('X3'), Reg('X4'), Reg('X5'), Reg('X6'), Reg('X7'), Reg('X8'),
                    Reg('X9'), Reg('X10'), Reg('X11'), Reg('X12'), Reg('X13'), Reg('X14'), Reg('X15'), Reg('X16'),
                    Reg('X17'), Reg('X18'), Reg('X19'), Reg('X20'), Reg('X21'), Reg('X22'), Reg('R23'), Reg('X24'),
                    Reg('X25'), Reg('X26'), Reg('X27'), Reg('X28'), Reg('X29'), Reg('X30')]
        else:
            assert False

```

`qsynthesis/plugin/ast_viewer.py`:

```py
# built-in modules
from typing import List

# qsynthesis modules
from qsynthesis.plugin.dependencies import ida_graph, Instr
from qsynthesis.tritonast import TritonAst


class AstViewer(ida_graph.GraphViewer):
    """
    GraphViewer to show AST Triton expressions
    """

    def __init__(self, title: str, ast: TritonAst):
        """
        Constructor.

        :param title: string title of the windows
        :param ast: TritonAst object to show
        """
        ida_graph.GraphViewer.__init__(self, title)
        self._ast = ast

    def OnRefresh(self) -> bool:
        """
        GraphViewer callback called whenever refreshing the view (so at least once)
        """
        self.Clear()
        self.draw()
        return True

    def OnGetText(self, ida_node_id: int) -> str:
        """
        GraphViewer callback whenever it needs to get the text associated to a node.
        Just return the string pre-computed in :meth:`AstViewer.draw`.

        :param ida_node_id: GraphViewer node id
        :return: text of the node
        """
        return self[ida_node_id]

    def Show(self) -> bool:
        """
        Called when showing the view
        """
        # TODO: Checking if its really required ?
        if not ida_graph.GraphViewer.Show(self):
            return False
        return True

    def draw(self) -> None:
        """
        Create the graph by iterating the AST and creating
        associated node in the GraphViewer object. The text
        of each node is their 'symbol' attribute.
        """
        n_id = self.AddNode(self._ast.symbol)
        worklist = [(n_id, self._ast)]

        while worklist:
            node_id, node = worklist.pop(0)

            for c in node.get_children():
                child_id = self.AddNode(c.symbol)
                self.AddEdge(node_id, child_id)
                worklist.append((child_id, c))


class BasicBlockViewer(ida_graph.GraphViewer):
    """
    Class to show handcrafted basic blocks with
    a given set of instructions.
    """
    def __init__(self, title: str, insts: List[Instr]):
        """
        Constructor. Takes window title and a list of instruction
        to show.
        """
        ida_graph.GraphViewer.__init__(self, title)
        self.insts = insts
        # TODO: Using ida_lines stuff to precompute 'colored' lines

    def OnRefresh(self) -> bool:
        """
         GraphViewer callback called whenever refreshing the view (so at least once)
         """
        self.Clear()
        self.draw()
        return True

    def OnGetText(self, ida_node_id: int) -> str:
        """
        GraphViewer callback whenever it needs to get the text associated to a node.
        Just return the string pre-computed in :meth:`BasicBlockViewer.draw`.

        :param ida_node_id: GraphViewer node id
        :return: text of the node
        """
        return self[ida_node_id]

    def Show(self):
        """ Called when showing the view """
        return False if not ida_graph.GraphViewer.Show(self) else True

    def draw(self) -> None:
        """ Add a single basic block corresponding to the concatenation of string instructions """
        self.AddNode("\n".join(str(x) for x in self.insts))

```

`qsynthesis/plugin/dependencies.py`:

```py
from unittest.mock import MagicMock

try:
    import ida_idaapi
    import ida_kernwin
    import ida_gdl
    import ida_funcs
    import ida_bytes
    import ida_idp
    import ida_nalt
    import ida_ua
    import ida_loader
    import ida_auto
    import ida_graph
    import ida_lines
    IDA_ENABLED = True
except ImportError:
    # If we cannot import ida Mock most of its API to works equally without
    class ida_kernwin:
        class PluginForm:
            pass
        action_handler_t = MagicMock()
    ida_idaapi = MagicMock()
    ida_gdl = MagicMock()
    ida_bytes = MagicMock()
    ida_idp = MagicMock()
    ida_nalt = MagicMock()
    ida_funcs = MagicMock()
    ida_ua = MagicMock()
    ida_loader = MagicMock()
    ida_auto = MagicMock()
    ida_graph = MagicMock()
    ida_lines = MagicMock()

    IDA_ENABLED = False


try:
    import qtraceida
    QTRACEIDA_ENABLED = True
except ImportError:
    QTRACEIDA_ENABLED = False


try:
    import qtracedb
    from qtracedb import DatabaseManager
    from qtracedb.trace import Trace, InstrCtx
    from qtracedb.archs.arch import Instr, Arch
    from qtracedb.manager import ArchsManager
    from qtracedb.archs.x86 import ArchX86, ArchX64
    from qtracedb.archs.arm import ArchARM
    from qtracedb.archs.arm64 import ArchARM64
    QTRACEDB_ENABLED = True
except ImportError as e:
    QTRACEDB_ENABLED = False
    from .arch import Arch, ArchX64, ArchARM, ArchARM64, ArchX86, Instr, ArchsManager
    # Set dummy vars
    DatabaseManager, Trace, InstrCtx = None, None, None


try:
    import triton
    TRITON_ENABLED = True
except ImportError:
    TRITON_ENABLED = False

```

`qsynthesis/plugin/popup_actions.py`:

```py
# third-party modules
from PyQt5 import QtWidgets

# qsynthesis deps
from qsynthesis.plugin.dependencies import ida_kernwin, ida_bytes, ida_ua, ida_lines
from qsynthesis.types import Addr


POPUP_PATH = "QSynthesis/"


class SynthetizeFromHere(ida_kernwin.action_handler_t):
    """
    Popup action that will be shown in the context-menu of the IDA-View (right-click).
    This action just takes the current line address and put it in the 'from' field
    of the Qsynthesis view.
    """

    def __init__(self, widget: 'SynthesizerView'):
        """
        Constructor. Take the QSynthesis main view as parameter.
        """
        ida_kernwin.action_handler_t.__init__(self)
        self.action_id = "Qsynthesis:from-here"
        self.text = "Synthesize from here"
        self.shortcut = "Ctrl+Shift+A"
        self.tooltip = "Start synthesizing from the current address"
        self.icon = 127 # GREEN_LIGHT  # 84  # BLOCK_DESCENT_FRM
        self.widget = widget

    def set_text_widget(self, ea: Addr) -> None:
        """
        Set the address given in parameter in the 'from' field of
        the Qsynthesis view.

        :param ea: address to set
        :return: Nones
        """
        self.widget.from_line.setText(f"{ea:#x}")

    def activate(self, ctx) -> bool:
        """
        Activation callback. Retrieve current address and set the from
        field of the QSynthesis view
        """
        ea = ida_kernwin.get_screen_ea()
        ea = ida_bytes.get_item_head(ea)  # Make sure we are on the head of the instruction
        if ida_bytes.is_code(ida_bytes.get_flags(ea)):
            self.set_text_widget(ea)
            return True
        else:
            QtWidgets.QMessageBox.critical(self.widget, "Invalid byte", f"Current address: {ea:#x} is not code")
            return False

    def update(self, _) -> int:
        """ Overridden method called on hook update """
        return ida_kernwin.AST_ENABLE_ALWAYS

    def register(self) -> bool:
        """
        Register the popup_action to the 'IDA View-A'.

        :return: True if the registration succeeded
        """
        idaview = ida_kernwin.find_widget("IDA View-A")
        if idaview is None:
            print("Can't find IDA View to attach action")
            return False
        else:
            action = ida_kernwin.action_desc_t(self.action_id, self.text, self, self.shortcut, self.tooltip, self.icon)
            res = ida_kernwin.register_action(action)
            res2 = ida_kernwin.attach_action_to_popup(idaview, None, self.action_id, POPUP_PATH)
            return res & res2

    def unregister(self) -> bool:
        """
        Remove popup action from the context menu of the view

        :return: True if unregistration succeeded
        """
        res = ida_kernwin.unregister_action(self.action_id)
        idaview = ida_kernwin.find_widget("IDA View-A")
        if idaview is None:
            print("Can't find IDA View to detach action")
            return False
        else:
            res2 = ida_kernwin.detach_action_from_popup(idaview, self.action_id)
        return res & res2


class SynthetizeToHere(SynthetizeFromHere):
    """
    Popup action that will be shown in the context-menu of the IDA-View (right-click).
    This action just takes the current line address and put it in the 'To' field
    of the Qsynthesis view.
    """

    def __init__(self, widget: 'SynthesizerView'):
        """
        Constructor. Take the QSynthesis main view as parameter.
        """
        super(SynthetizeToHere, self).__init__(widget)
        self.action_id = "Qsynthesis:to-here"
        self.text = "Synthesize up to here (included)"
        self.shortcut = "Ctrl+Shift+Z"
        self.tooltip = "Start synthesizing up to the current address (included)"
        self.icon = 120 # BREAKPOINT_PLUS

    def set_text_widget(self, ea: Addr) -> None:
        """
        Set the address given in parameter in the 'to' field of the Qsynthesis view.

        :param ea: address to set
        :return: None
        """
        self.widget.to_line.setText(f"{ea:#x}")


class SynthetizeOperand(SynthetizeFromHere):
    """
    Popup action that will be shown in the context-menu of the IDA-View
    and retrieve the current operand being selected. At the moment only
    full operand can be selected (e.g mov rax, [rbp + 4], 'rbp cannot
    be selected separately)
    """

    def __init__(self, widget: 'SynthesizerView'):
        """
        Constructor. Take the QSynthesis main view as parameter.
        """
        super(SynthetizeOperand, self).__init__(widget)
        self.action_id = "Qsynthesis:operand"
        self.text = "Synthesize operand"
        self.shortcut = "Ctrl+Shift+O"
        self.tooltip = "Synthesize the current operand at this address"
        self.icon = 12  # STAR_PLUS

    def activate(self, ctx) -> bool:
        """
        Upon clicking (or shortcut key typed) retrieve the current operand
        object and set various widget variable to be able to retrieve the
        information later on.

        :return: True if the operand is value and has successfully been retrieved
        """
        ea = ida_kernwin. get_screen_ea()
        ea = ida_bytes.get_item_head(ea)  # Make sure we are on the head of the instruction
        if ida_bytes.is_code(ida_bytes.get_flags(ea)):
            op_num = ida_kernwin.get_opnum()
            i = self.widget.get_instruction(ea)
            if i is None:
                QtWidgets.QMessageBox.critical(self.widget, "Invalid instruction", f"Cannot disassembl instruction at: {ea:#x}")
                return False
            op = i.operands[op_num]
            if op.is_register() or op.is_memory():
                self.widget.to_line.setText(f"{ea:#x}")
                self.widget.op_num = op_num
                self.widget.op_is_read = not op.is_written()

                # Switch to operand mode and set text
                self.widget.switch_to_target_operand()
                text = ida_lines.tag_remove(ida_ua.print_operand(ea, op_num))
                self.widget.operand_label.setText(f"{op_num}:{text} ({'write' if op.is_written() else 'read'})")
                return True
            else:
                QtWidgets.QMessageBox.critical(self.widget, "Invalid operand", f"Invalid operand type: {op.type}\nCannot synthesize such type")
                return False
        else:
            QtWidgets.QMessageBox.critical(self.widget, "Invalid byte", f"Current address: {ea:#x} is not code")
            return False

```

`qsynthesis/plugin/processor.py`:

```py
# Disclaimer:
# This file is a partial rip of the processor module of idacore
# it is meant to be replaced by idacore in a near future

# built-in modules
from enum import IntEnum

# third-party modules
from triton import ARCH

# qsynthesis modules
from qsynthesis.plugin.dependencies import ida_idp, ida_idaapi
from qsynthesis.plugin.dependencies import ArchX86, ArchX64, ArchARM, ArchARM64


class ProcessorType(IntEnum):
    """
    Enum of IDA Processor supported
    """
    UNKNOWN = -1
    PLFM_386 = ida_idp.PLFM_386       # Intel 80x86
    PLFM_ARM = ida_idp.PLFM_ARM       # Advanced RISC Machines


SUPPORTED_PROC = [ProcessorType.PLFM_386.value, ProcessorType.PLFM_ARM]


class ArchMode(IntEnum):
    """
    Enum of supported modes for each architectures
    """
    MODE32 = 0
    MODE64 = 1


class Processor:
    """
    Small idp wrapper to represent the current processor.
    """
    name = ida_idp.get_idp_name()
    id = ida_idp.ph_get_id()
    flag = ida_idp.ph_get_flag()
    type = ProcessorType.UNKNOWN if id not in SUPPORTED_PROC else ProcessorType(id)
    mode = ArchMode.MODE64 if ida_idaapi.get_inf_structure().is_64bit() else ArchMode.MODE32


def processor_to_triton_arch() -> ARCH:
    """
    Get the current IDB processor as a Triton ARCH object.

    :return: Triton ARCH from IDA processor type
    """
    if Processor.type == ProcessorType.PLFM_386:
        return ARCH.X86_64 if Processor.mode == ArchMode.MODE64 else ARCH.X86
    elif Processor.type == ProcessorType.PLFM_ARM:
        return ARCH.AARCH64 if Processor.mode == ArchMode.MODE64 else ARCH.ARM32
    else:
        assert False


def processor_to_arch():
    """
    Get the current IDB processor as a Qtrace-DB Arch object

    :return: Qtrace-DB Arch object from IDA processor type
    """
    if Processor.type == ProcessorType.PLFM_386:
        return ArchX64 if Processor.mode == ArchMode.MODE64 else ArchX86
    elif Processor.type == ProcessorType.PLFM_ARM:
        return ArchARM64 if Processor.mode == ArchMode.MODE64 else ArchARM
    else:
        assert False

```

`qsynthesis/plugin/slicer.py`:

```py
# built-in imports
from typing import Set
from collections import deque, namedtuple

# third-party imports
from triton import AST_NODE

# local imports
from qsynthesis.types import Addr

NodeInfo = namedtuple("NodeInfo", "id expr_off address")


def backslice(root_sym_expr: 'SymbolicExpression') -> Set[Addr]:
    """
    Extract backslice of given symbolic expression as a DGraph
    of instructions ids.

    :param ctx: Triton context to extract the backslice from
    :param root_sym_expr: target symbolic expression
    :return: A DGraph where each node corresponds to an instruction id
    """

    addrs = set()

    # Add root node to graph
    root_node_id, off, addr = [int(x) for x in root_sym_expr.getComment().split('#')]
    addrs.add(addr)

    # Create a queue of (node, parent_id) tuples
    nodes_to_process = deque()
    nodes_to_process.append((root_sym_expr.getAst(), root_node_id))
    handled = set()

    while len(nodes_to_process) > 0:

        node, parent_id = nodes_to_process.popleft()
        skip_node = False

        # If the given AstNode is a reference consume it
        # and then continue using the AstNode of the referenced
        # symbolic expression
        while node.getType() == AST_NODE.REFERENCE:
            # Get referenced symbolic expr
            se = node.getSymbolicExpression()

            # Get expression id
            instr_id, expr_nb, instr_addr = [int(x) for x in se.getComment().split('#')]
            expr_id = (instr_id, expr_nb)

            addrs.add(instr_addr)

            # Do not process this node if it has already been handled
            # NOTE: since we could come from an unseen parent we add
            # an edge before going to the next node
            if expr_id in handled:
                skip_node = True
                break
            else:
                handled.add(expr_id)

            # Move to the referenced AstNode
            parent_id = instr_id
            node = node.getSymbolicExpression().getAst()

        if skip_node:
            continue

        # Process children
        for child in node.getChildren():
            nodes_to_process.append((child, parent_id))

    return addrs

```

`qsynthesis/plugin/ui/Makefile`:

```
all:
	pyuic5 synthesis_view.ui -o synthesis_ui.py

```

`qsynthesis/plugin/ui/synthesis_ui.py`:

```py
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'synthesis_view.ui'
#
# Created by: PyQt5 UI code generator 5.14.2
#
# WARNING! All changes made in this file will be lost!


from PyQt5 import QtCore, QtGui, QtWidgets


class Ui_synthesis_view(object):
    def setupUi(self, synthesis_view):
        synthesis_view.setObjectName("synthesis_view")
        synthesis_view.resize(523, 622)
        self.verticalLayout_2 = QtWidgets.QVBoxLayout(synthesis_view)
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.verticalLayout = QtWidgets.QVBoxLayout()
        self.verticalLayout.setObjectName("verticalLayout")
        self.scrollArea = QtWidgets.QScrollArea(synthesis_view)
        self.scrollArea.setWidgetResizable(True)
        self.scrollArea.setObjectName("scrollArea")
        self.scrollAreaWidgetContents = QtWidgets.QWidget()
        self.scrollAreaWidgetContents.setGeometry(QtCore.QRect(0, 0, 558, 584))
        self.scrollAreaWidgetContents.setObjectName("scrollAreaWidgetContents")
        self.verticalLayout_4 = QtWidgets.QVBoxLayout(self.scrollAreaWidgetContents)
        self.verticalLayout_4.setObjectName("verticalLayout_4")
        self.verticalLayout_3 = QtWidgets.QVBoxLayout()
        self.verticalLayout_3.setObjectName("verticalLayout_3")
        self.main_title = QtWidgets.QLabel(self.scrollAreaWidgetContents)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.main_title.sizePolicy().hasHeightForWidth())
        self.main_title.setSizePolicy(sizePolicy)
        font = QtGui.QFont()
        font.setPointSize(14)
        self.main_title.setFont(font)
        self.main_title.setScaledContents(False)
        self.main_title.setAlignment(QtCore.Qt.AlignCenter)
        self.main_title.setObjectName("main_title")
        self.verticalLayout_3.addWidget(self.main_title)
        self.configurationBox = QtWidgets.QGroupBox(self.scrollAreaWidgetContents)
        self.configurationBox.setObjectName("configurationBox")
        self.verticalLayout_6 = QtWidgets.QVBoxLayout(self.configurationBox)
        self.verticalLayout_6.setObjectName("verticalLayout_6")
        self.configurationVLayout = QtWidgets.QVBoxLayout()
        self.configurationVLayout.setObjectName("configurationVLayout")
        self.traceLayout = QtWidgets.QHBoxLayout()
        self.traceLayout.setObjectName("traceLayout")
        self.trace_label = QtWidgets.QLabel(self.configurationBox)
        self.trace_label.setObjectName("trace_label")
        self.traceLayout.addWidget(self.trace_label)
        self.trace_type_box = QtWidgets.QComboBox(self.configurationBox)
        self.trace_type_box.setObjectName("trace_type_box")
        self.traceLayout.addWidget(self.trace_type_box)
        self.trace_line = QtWidgets.QLineEdit(self.configurationBox)
        self.trace_line.setObjectName("trace_line")
        self.traceLayout.addWidget(self.trace_line)
        self.configurationVLayout.addLayout(self.traceLayout)
        self.targetLayout = QtWidgets.QHBoxLayout()
        self.targetLayout.setObjectName("targetLayout")
        self.from_label = QtWidgets.QLabel(self.configurationBox)
        self.from_label.setEnabled(False)
        self.from_label.setObjectName("from_label")
        self.targetLayout.addWidget(self.from_label)
        self.from_line = QtWidgets.QLineEdit(self.configurationBox)
        self.from_line.setEnabled(False)
        self.from_line.setPlaceholderText("")
        self.from_line.setObjectName("from_line")
        self.targetLayout.addWidget(self.from_line)
        self.to_label = QtWidgets.QLabel(self.configurationBox)
        self.to_label.setEnabled(False)
        self.to_label.setObjectName("to_label")
        self.targetLayout.addWidget(self.to_label)
        self.to_line = QtWidgets.QLineEdit(self.configurationBox)
        self.to_line.setEnabled(False)
        self.to_line.setObjectName("to_line")
        self.targetLayout.addWidget(self.to_line)
        self.target_label = QtWidgets.QLabel(self.configurationBox)
        self.target_label.setEnabled(False)
        self.target_label.setObjectName("target_label")
        self.targetLayout.addWidget(self.target_label)
        self.target_box = QtWidgets.QComboBox(self.configurationBox)
        self.target_box.setEnabled(False)
        self.target_box.setObjectName("target_box")
        self.targetLayout.addWidget(self.target_box)
        self.register_box = QtWidgets.QComboBox(self.configurationBox)
        self.register_box.setEnabled(False)
        self.register_box.setObjectName("register_box")
        self.targetLayout.addWidget(self.register_box)
        self.mem_line = QtWidgets.QLineEdit(self.configurationBox)
        self.mem_line.setEnabled(False)
        self.mem_line.setObjectName("mem_line")
        self.targetLayout.addWidget(self.mem_line)
        self.operand_label = QtWidgets.QLabel(self.configurationBox)
        self.operand_label.setEnabled(False)
        self.operand_label.setObjectName("operand_label")
        self.targetLayout.addWidget(self.operand_label)
        self.configurationVLayout.addLayout(self.targetLayout)
        self.tableLayout = QtWidgets.QHBoxLayout()
        self.tableLayout.setObjectName("tableLayout")
        self.table_label = QtWidgets.QLabel(self.configurationBox)
        self.table_label.setEnabled(False)
        self.table_label.setObjectName("table_label")
        self.tableLayout.addWidget(self.table_label)
        self.table_type_box = QtWidgets.QComboBox(self.configurationBox)
        self.table_type_box.setEnabled(False)
        self.table_type_box.setObjectName("table_type_box")
        self.tableLayout.addWidget(self.table_type_box)
        self.table_line = QtWidgets.QLineEdit(self.configurationBox)
        self.table_line.setEnabled(False)
        self.table_line.setObjectName("table_line")
        self.tableLayout.addWidget(self.table_line)
        self.configurationVLayout.addLayout(self.tableLayout)
        self.algorithmLayout = QtWidgets.QHBoxLayout()
        self.algorithmLayout.setObjectName("algorithmLayout")
        self.algorithm_label = QtWidgets.QLabel(self.configurationBox)
        self.algorithm_label.setEnabled(False)
        self.algorithm_label.setObjectName("algorithm_label")
        self.algorithmLayout.addWidget(self.algorithm_label)
        self.algorithm_box = QtWidgets.QComboBox(self.configurationBox)
        self.algorithm_box.setEnabled(False)
        self.algorithm_box.setObjectName("algorithm_box")
        self.algorithmLayout.addWidget(self.algorithm_box)
        self.algorithm_type_label = QtWidgets.QLabel(self.configurationBox)
        self.algorithm_type_label.setEnabled(False)
        self.algorithm_type_label.setObjectName("algorithm_type_label")
        self.algorithmLayout.addWidget(self.algorithm_type_label)
        self.algorithm_type_box = QtWidgets.QComboBox(self.configurationBox)
        self.algorithm_type_box.setEnabled(False)
        self.algorithm_type_box.setObjectName("algorithm_type_box")
        self.algorithmLayout.addWidget(self.algorithm_type_box)
        self.qtrace_sym_type_box = QtWidgets.QComboBox(self.configurationBox)
        self.qtrace_sym_type_box.setEnabled(False)
        self.qtrace_sym_type_box.setObjectName("qtrace_sym_type_box")
        self.algorithmLayout.addWidget(self.qtrace_sym_type_box)
        spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.algorithmLayout.addItem(spacerItem)
        self.configurationVLayout.addLayout(self.algorithmLayout)
        self.experimentalLayout = QtWidgets.QHBoxLayout()
        self.experimentalLayout.setObjectName("experimentalLayout")
        self.label_9 = QtWidgets.QLabel(self.configurationBox)
        self.label_9.setObjectName("label_9")
        self.experimentalLayout.addWidget(self.label_9)
        self.verticalLayout_9 = QtWidgets.QVBoxLayout()
        self.verticalLayout_9.setObjectName("verticalLayout_9")
        self.learning_checkbox = QtWidgets.QCheckBox(self.configurationBox)
        self.learning_checkbox.setObjectName("learning_checkbox")
        self.verticalLayout_9.addWidget(self.learning_checkbox)
        self.check_sem_checkbox = QtWidgets.QCheckBox(self.configurationBox)
        self.check_sem_checkbox.setObjectName("check_sem_checkbox")
        self.verticalLayout_9.addWidget(self.check_sem_checkbox)
        self.experimentalLayout.addLayout(self.verticalLayout_9)
        spacerItem1 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.experimentalLayout.addItem(spacerItem1)
        self.configurationVLayout.addLayout(self.experimentalLayout)
        self.verticalLayout_6.addLayout(self.configurationVLayout)
        self.verticalLayout_3.addWidget(self.configurationBox)
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.tritonLayout = QtWidgets.QVBoxLayout()
        self.tritonLayout.setObjectName("tritonLayout")
        self.run_triton_button = QtWidgets.QPushButton(self.scrollAreaWidgetContents)
        self.run_triton_button.setEnabled(False)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.run_triton_button.sizePolicy().hasHeightForWidth())
        self.run_triton_button.setSizePolicy(sizePolicy)
        self.run_triton_button.setLayoutDirection(QtCore.Qt.LeftToRight)
        self.run_triton_button.setFlat(False)
        self.run_triton_button.setObjectName("run_triton_button")
        self.tritonLayout.addWidget(self.run_triton_button, 0, QtCore.Qt.AlignHCenter)
        self.triton_textarea = QtWidgets.QTextBrowser(self.scrollAreaWidgetContents)
        self.triton_textarea.setEnabled(False)
        self.triton_textarea.setObjectName("triton_textarea")
        self.tritonLayout.addWidget(self.triton_textarea)
        self.triton_button_group = QtWidgets.QHBoxLayout()
        self.triton_button_group.setObjectName("triton_button_group")
        self.show_deps_triton_button = QtWidgets.QPushButton(self.scrollAreaWidgetContents)
        self.show_deps_triton_button.setEnabled(False)
        self.show_deps_triton_button.setObjectName("show_deps_triton_button")
        self.triton_button_group.addWidget(self.show_deps_triton_button)
        self.line_2 = QtWidgets.QFrame(self.scrollAreaWidgetContents)
        self.line_2.setFrameShape(QtWidgets.QFrame.VLine)
        self.line_2.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_2.setObjectName("line_2")
        self.triton_button_group.addWidget(self.line_2)
        self.show_ast_triton_button = QtWidgets.QPushButton(self.scrollAreaWidgetContents)
        self.show_ast_triton_button.setEnabled(False)
        self.show_ast_triton_button.setObjectName("show_ast_triton_button")
        self.triton_button_group.addWidget(self.show_ast_triton_button)
        self.tritonLayout.addLayout(self.triton_button_group)
        self.horizontalLayout_2.addLayout(self.tritonLayout)
        self.line = QtWidgets.QFrame(self.scrollAreaWidgetContents)
        self.line.setFrameShape(QtWidgets.QFrame.VLine)
        self.line.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line.setObjectName("line")
        self.horizontalLayout_2.addWidget(self.line)
        self.synthesisLayout = QtWidgets.QVBoxLayout()
        self.synthesisLayout.setObjectName("synthesisLayout")
        self.run_synthesis_button = QtWidgets.QPushButton(self.scrollAreaWidgetContents)
        self.run_synthesis_button.setEnabled(False)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.run_synthesis_button.sizePolicy().hasHeightForWidth())
        self.run_synthesis_button.setSizePolicy(sizePolicy)
        self.run_synthesis_button.setObjectName("run_synthesis_button")
        self.synthesisLayout.addWidget(self.run_synthesis_button, 0, QtCore.Qt.AlignHCenter)
        self.synthesis_textarea = QtWidgets.QTextBrowser(self.scrollAreaWidgetContents)
        self.synthesis_textarea.setEnabled(False)
        self.synthesis_textarea.setObjectName("synthesis_textarea")
        self.synthesisLayout.addWidget(self.synthesis_textarea)
        self.horizontalLayout_4 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_4.setObjectName("horizontalLayout_4")
        self.show_ast_synthesis_button = QtWidgets.QPushButton(self.scrollAreaWidgetContents)
        self.show_ast_synthesis_button.setEnabled(False)
        self.show_ast_synthesis_button.setObjectName("show_ast_synthesis_button")
        self.horizontalLayout_4.addWidget(self.show_ast_synthesis_button)
        self.line_3 = QtWidgets.QFrame(self.scrollAreaWidgetContents)
        self.line_3.setFrameShape(QtWidgets.QFrame.VLine)
        self.line_3.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_3.setObjectName("line_3")
        self.horizontalLayout_4.addWidget(self.line_3)
        self.reassemble_button = QtWidgets.QPushButton(self.scrollAreaWidgetContents)
        self.reassemble_button.setEnabled(False)
        self.reassemble_button.setObjectName("reassemble_button")
        self.horizontalLayout_4.addWidget(self.reassemble_button)
        self.synthesisLayout.addLayout(self.horizontalLayout_4)
        self.horizontalLayout_2.addLayout(self.synthesisLayout)
        self.verticalLayout_3.addLayout(self.horizontalLayout_2)
        self.verticalLayout_4.addLayout(self.verticalLayout_3)
        self.scrollArea.setWidget(self.scrollAreaWidgetContents)
        self.verticalLayout.addWidget(self.scrollArea)
        self.verticalLayout_2.addLayout(self.verticalLayout)

        self.retranslateUi(synthesis_view)
        QtCore.QMetaObject.connectSlotsByName(synthesis_view)

    def retranslateUi(self, synthesis_view):
        _translate = QtCore.QCoreApplication.translate
        synthesis_view.setWindowTitle(_translate("synthesis_view", "QSynthesis"))
        self.main_title.setText(_translate("synthesis_view", "QSynthesis"))
        self.configurationBox.setTitle(_translate("synthesis_view", "Synthesis configuration"))
        self.trace_label.setText(_translate("synthesis_view", "Trace:"))
        self.from_label.setText(_translate("synthesis_view", "From:"))
        self.to_label.setText(_translate("synthesis_view", "To:"))
        self.target_label.setText(_translate("synthesis_view", "Target:"))
        self.operand_label.setText(_translate("synthesis_view", "TextLabel"))
        self.table_label.setText(_translate("synthesis_view", "Table:"))
        self.algorithm_label.setText(_translate("synthesis_view", "Algorithm:"))
        self.algorithm_type_label.setText(_translate("synthesis_view", "Type:"))
        self.label_9.setText(_translate("synthesis_view", "Experimental settings:"))
        self.learning_checkbox.setText(_translate("synthesis_view", "Learning new expressions"))
        self.check_sem_checkbox.setText(_translate("synthesis_view", "Check semantic expressions"))
        self.run_triton_button.setText(_translate("synthesis_view", "Run Triton"))
        self.show_deps_triton_button.setText(_translate("synthesis_view", "Show deps"))
        self.show_ast_triton_button.setText(_translate("synthesis_view", "Show AST"))
        self.run_synthesis_button.setText(_translate("synthesis_view", "Run Synthesis"))
        self.show_ast_synthesis_button.setText(_translate("synthesis_view", "Show AST"))
        self.reassemble_button.setText(_translate("synthesis_view", "Reassemble"))

```

`qsynthesis/plugin/ui/synthesis_view.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>synthesis_view</class>
 <widget class="QWidget" name="synthesis_view">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>523</width>
    <height>622</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>QSynthesis</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout_2">
   <item>
    <layout class="QVBoxLayout" name="verticalLayout">
     <item>
      <widget class="QScrollArea" name="scrollArea">
       <property name="widgetResizable">
        <bool>true</bool>
       </property>
       <widget class="QWidget" name="scrollAreaWidgetContents">
        <property name="geometry">
         <rect>
          <x>0</x>
          <y>0</y>
          <width>558</width>
          <height>584</height>
         </rect>
        </property>
        <layout class="QVBoxLayout" name="verticalLayout_4">
         <item>
          <layout class="QVBoxLayout" name="verticalLayout_3">
           <item>
            <widget class="QLabel" name="main_title">
             <property name="sizePolicy">
              <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
               <horstretch>0</horstretch>
               <verstretch>0</verstretch>
              </sizepolicy>
             </property>
             <property name="font">
              <font>
               <pointsize>14</pointsize>
              </font>
             </property>
             <property name="text">
              <string>QSynthesis</string>
             </property>
             <property name="scaledContents">
              <bool>false</bool>
             </property>
             <property name="alignment">
              <set>Qt::AlignCenter</set>
             </property>
            </widget>
           </item>
           <item>
            <widget class="QGroupBox" name="configurationBox">
             <property name="title">
              <string>Synthesis configuration</string>
             </property>
             <layout class="QVBoxLayout" name="verticalLayout_6">
              <item>
               <layout class="QVBoxLayout" name="configurationVLayout">
                <item>
                 <layout class="QHBoxLayout" name="traceLayout">
                  <item>
                   <widget class="QLabel" name="trace_label">
                    <property name="text">
                     <string>Trace:</string>
                    </property>
                   </widget>
                  </item>
                  <item>
                   <widget class="QComboBox" name="trace_type_box"/>
                  </item>
                  <item>
                   <widget class="QLineEdit" name="trace_line"/>
                  </item>
                 </layout>
                </item>
                <item>
                 <layout class="QHBoxLayout" name="targetLayout">
                  <item>
                   <widget class="QLabel" name="from_label">
                    <property name="enabled">
                     <bool>false</bool>
                    </property>
                    <property name="text">
                     <string>From:</string>
                    </property>
                   </widget>
                  </item>
                  <item>
                   <widget class="QLineEdit" name="from_line">
                    <property name="enabled">
                     <bool>false</bool>
                    </property>
                    <property name="placeholderText">
                     <string/>
                    </property>
                   </widget>
                  </item>
                  <item>
                   <widget class="QLabel" name="to_label">
                    <property name="enabled">
                     <bool>false</bool>
                    </property>
                    <property name="text">
                     <string>To:</string>
                    </property>
                   </widget>
                  </item>
                  <item>
                   <widget class="QLineEdit" name="to_line">
                    <property name="enabled">
                     <bool>false</bool>
                    </property>
                   </widget>
                  </item>
                  <item>
                   <widget class="QLabel" name="target_label">
                    <property name="enabled">
                     <bool>false</bool>
                    </property>
                    <property name="text">
                     <string>Target:</string>
                    </property>
                   </widget>
                  </item>
                  <item>
                   <widget class="QComboBox" name="target_box">
                    <property name="enabled">
                     <bool>false</bool>
                    </property>
                   </widget>
                  </item>
                  <item>
                   <widget class="QComboBox" name="register_box">
                    <property name="enabled">
                     <bool>false</bool>
                    </property>
                   </widget>
                  </item>
                  <item>
                   <widget class="QLineEdit" name="mem_line">
                    <property name="enabled">
                     <bool>false</bool>
                    </property>
                   </widget>
                  </item>
                  <item>
                   <widget class="QLabel" name="operand_label">
                    <property name="enabled">
                     <bool>false</bool>
                    </property>
                    <property name="text">
                     <string>TextLabel</string>
                    </property>
                   </widget>
                  </item>
                 </layout>
                </item>
                <item>
                 <layout class="QHBoxLayout" name="tableLayout">
                  <item>
                   <widget class="QLabel" name="table_label">
                    <property name="enabled">
                     <bool>false</bool>
                    </property>
                    <property name="text">
                     <string>Table:</string>
                    </property>
                   </widget>
                  </item>
                  <item>
                   <widget class="QComboBox" name="table_type_box">
                    <property name="enabled">
                     <bool>false</bool>
                    </property>
                   </widget>
                  </item>
                  <item>
                   <widget class="QLineEdit" name="table_line">
                    <property name="enabled">
                     <bool>false</bool>
                    </property>
                   </widget>
                  </item>
                 </layout>
                </item>
                <item>
                 <layout class="QHBoxLayout" name="algorithmLayout">
                  <item>
                   <widget class="QLabel" name="algorithm_label">
                    <property name="enabled">
                     <bool>false</bool>
                    </property>
                    <property name="text">
                     <string>Algorithm:</string>
                    </property>
                   </widget>
                  </item>
                  <item>
                   <widget class="QComboBox" name="algorithm_box">
                    <property name="enabled">
                     <bool>false</bool>
                    </property>
                   </widget>
                  </item>
                  <item>
                   <widget class="QLabel" name="algorithm_type_label">
                    <property name="enabled">
                     <bool>false</bool>
                    </property>
                    <property name="text">
                     <string>Type:</string>
                    </property>
                   </widget>
                  </item>
                  <item>
                   <widget class="QComboBox" name="algorithm_type_box">
                    <property name="enabled">
                     <bool>false</bool>
                    </property>
                   </widget>
                  </item>
                  <item>
                   <widget class="QComboBox" name="qtrace_sym_type_box">
                    <property name="enabled">
                     <bool>false</bool>
                    </property>
                   </widget>
                  </item>
                  <item>
                   <spacer name="horizontalSpacer">
                    <property name="orientation">
                     <enum>Qt::Horizontal</enum>
                    </property>
                    <property name="sizeHint" stdset="0">
                     <size>
                      <width>40</width>
                      <height>20</height>
                     </size>
                    </property>
                   </spacer>
                  </item>
                 </layout>
                </item>
                <item>
                 <layout class="QHBoxLayout" name="experimentalLayout">
                  <item>
                   <widget class="QLabel" name="label_9">
                    <property name="text">
                     <string>Experimental settings:</string>
                    </property>
                   </widget>
                  </item>
                  <item>
                   <layout class="QVBoxLayout" name="verticalLayout_9">
                    <item>
                     <widget class="QCheckBox" name="learning_checkbox">
                      <property name="text">
                       <string>Learning new expressions</string>
                      </property>
                     </widget>
                    </item>
                    <item>
                     <widget class="QCheckBox" name="check_sem_checkbox">
                      <property name="text">
                       <string>Check semantic expressions</string>
                      </property>
                     </widget>
                    </item>
                   </layout>
                  </item>
                  <item>
                   <spacer name="horizontalSpacer_2">
                    <property name="orientation">
                     <enum>Qt::Horizontal</enum>
                    </property>
                    <property name="sizeHint" stdset="0">
                     <size>
                      <width>40</width>
                      <height>20</height>
                     </size>
                    </property>
                   </spacer>
                  </item>
                 </layout>
                </item>
               </layout>
              </item>
             </layout>
            </widget>
           </item>
           <item>
            <layout class="QHBoxLayout" name="horizontalLayout_2">
             <item>
              <layout class="QVBoxLayout" name="tritonLayout">
               <item alignment="Qt::AlignHCenter">
                <widget class="QPushButton" name="run_triton_button">
                 <property name="enabled">
                  <bool>false</bool>
                 </property>
                 <property name="sizePolicy">
                  <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
                   <horstretch>0</horstretch>
                   <verstretch>0</verstretch>
                  </sizepolicy>
                 </property>
                 <property name="layoutDirection">
                  <enum>Qt::LeftToRight</enum>
                 </property>
                 <property name="text">
                  <string>Run Triton</string>
                 </property>
                 <property name="flat">
                  <bool>false</bool>
                 </property>
                </widget>
               </item>
               <item>
                <widget class="QTextBrowser" name="triton_textarea">
                 <property name="enabled">
                  <bool>false</bool>
                 </property>
                </widget>
               </item>
               <item>
                <layout class="QHBoxLayout" name="triton_button_group">
                 <item>
                  <widget class="QPushButton" name="show_deps_triton_button">
                   <property name="enabled">
                    <bool>false</bool>
                   </property>
                   <property name="text">
                    <string>Show deps</string>
                   </property>
                  </widget>
                 </item>
                 <item>
                  <widget class="Line" name="line_2">
                   <property name="orientation">
                    <enum>Qt::Vertical</enum>
                   </property>
                  </widget>
                 </item>
                 <item>
                  <widget class="QPushButton" name="show_ast_triton_button">
                   <property name="enabled">
                    <bool>false</bool>
                   </property>
                   <property name="text">
                    <string>Show AST</string>
                   </property>
                  </widget>
                 </item>
                </layout>
               </item>
              </layout>
             </item>
             <item>
              <widget class="Line" name="line">
               <property name="orientation">
                <enum>Qt::Vertical</enum>
               </property>
              </widget>
             </item>
             <item>
              <layout class="QVBoxLayout" name="synthesisLayout">
               <item alignment="Qt::AlignHCenter">
                <widget class="QPushButton" name="run_synthesis_button">
                 <property name="enabled">
                  <bool>false</bool>
                 </property>
                 <property name="sizePolicy">
                  <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
                   <horstretch>0</horstretch>
                   <verstretch>0</verstretch>
                  </sizepolicy>
                 </property>
                 <property name="text">
                  <string>Run Synthesis</string>
                 </property>
                </widget>
               </item>
               <item>
                <widget class="QTextBrowser" name="synthesis_textarea">
                 <property name="enabled">
                  <bool>false</bool>
                 </property>
                </widget>
               </item>
               <item>
                <layout class="QHBoxLayout" name="horizontalLayout_4">
                 <item>
                  <widget class="QPushButton" name="show_ast_synthesis_button">
                   <property name="enabled">
                    <bool>false</bool>
                   </property>
                   <property name="text">
                    <string>Show AST</string>
                   </property>
                  </widget>
                 </item>
                 <item>
                  <widget class="Line" name="line_3">
                   <property name="orientation">
                    <enum>Qt::Vertical</enum>
                   </property>
                  </widget>
                 </item>
                 <item>
                  <widget class="QPushButton" name="reassemble_button">
                   <property name="enabled">
                    <bool>false</bool>
                   </property>
                   <property name="text">
                    <string>Reassemble</string>
                   </property>
                  </widget>
                 </item>
                </layout>
               </item>
              </layout>
             </item>
            </layout>
           </item>
          </layout>
         </item>
        </layout>
       </widget>
      </widget>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`qsynthesis/plugin/view.py`:

```py
# built-in modules
from enum import Enum
from pathlib import Path
from typing import Tuple, Optional, List, Iterable

# third-party modules
from PyQt5 import QtWidgets, QtCore, QtGui  # provided by IDA

# qsynthesis modules
from qsynthesis.plugin.dependencies import DatabaseManager, Trace, InstrCtx, Instr, Arch, ArchsManager
from qsynthesis.plugin.dependencies import ida_kernwin, IDA_ENABLED, QTRACEIDA_ENABLED, QTRACEDB_ENABLED
from qsynthesis.plugin.dependencies import ida_bytes, ida_nalt, ida_ua, ida_funcs, ida_gdl, ida_loader, ida_lines
from qsynthesis.tables import InputOutputOracleLevelDB, InputOutputOracleREST
from qsynthesis.algorithms import TopDownSynthesizer, PlaceHolderSynthesizer
from qsynthesis.utils.symexec import SimpleSymExec
from qsynthesis.tritonast import ReassemblyError
from qsynthesis.plugin.processor import processor_to_triton_arch, Processor, ProcessorType, processor_to_arch
from qsynthesis.plugin.ast_viewer import AstViewer, BasicBlockViewer
from qsynthesis.plugin.popup_actions import SynthetizeFromHere, SynthetizeToHere, SynthetizeOperand
from qsynthesis.plugin.ui.synthesis_ui import Ui_synthesis_view
from qsynthesis.plugin import slicer
from qsynthesis.types import Addr


TEMPLATE_TRITON = '''<!DOCTYPE html>
<html lang="en">
<head>
    <style>
        body { font-size: large; }
        big { font-size: x-large; }
        td { padding: 5px; padding-left:10px; padding-right:10px; }
    </style>
</head>
<body>
    <center><table>
        <tr><td>Node count</td><td>Depth</td></tr>
        <tr><td align="center"><big><b>%d</b></big></td><td align="center"><big><b>%d</b></big></td></tr>
    </table></center>
    <hr/>
    <center>Inputs
    <table border style="border-style:dashed; margin-top:8px;" >
        %s
    </table>
    </center>
</body>
</html>
'''

TEMPLATE_SYNTHESIS = '''<!DOCTYPE html>
<html lang="en">
<head>
    <style>
        body { font-size: large; }
        big { font-size: x-large; }
        td { padding: 5px; padding-left:10px; padding-right:10px; }
    </style>
</head>
<body>
    <center>
        Simplified: <big style="color:%s;">%s</big><br/>
        Synthesiszed Expression<br/>
        %s
    </center>
    <hr/>
    <center><table>
        <tr><td>Node count</td><td>Depth</td><td>Scale</td></tr>
        <tr>
            <td align="center"><big><b>%d</b></big></td>
            <td align="center"><big><b>%d</b></big></td>
            <td align="center"><big><b>%.2f%c</b></big></td>
        </tr>
    </table></center>
</body>
</html>
'''


class TraceDbType(Enum):
    """ Enum of the Trace type (either database defined in config or a direct sqlite trace """
    CONFIG = 0
    SQLITE = 1


class TargetType(Enum):
    """ Enum of the target expression to be synthesized """
    REG = 0
    MEMORY = 1
    OPERAND = 2


class TableType(Enum):
    """ Enum of the different kind of Lookup Table usable """
    LEVELDB = 0
    HTTP = 1


class AlgorithmType(Enum):
    """ Algorithm type to perform """
    TOPDOWN = "Top-Down"
    PLHDR = "PlaceHolders"


class AnalysisType(Enum):
    """ Type of analysis either based on trace or fully symbolic using Triton only """
    QTRACE = 0
    FULL_SYMBOLIC = 1


class QtraceSymType(Enum):
    """ Mode for trace based DSE. Keeping everything symbolic or just parameters (w.r.t ABI) """
    FULL_SYMBOLIC = 0
    PARAM_SYMBOLIC = 1


class ShowDepState(Enum):
    """ Enum state for buttons showing dependencies """
    SHOW = "Highlight Deps"
    HIDE = "Hide Deps"



# class SynthesizerView(ida_kernwin.PluginForm, Ui_synthesis_view):#QtWidgets.QWidget, ida_kernwin.PluginForm,  Ui_synthesis_view):
class SynthesizerView(ida_kernwin.PluginForm, QtWidgets.QWidget, Ui_synthesis_view):
    """
    Main view of the QSynthesis plugin. Contains all the features implemented
    in the plugin.
    """

    NAME = "QSynthesis"

    def __init__(self, qtrace: Optional['QtraceIDA']):
        """
        Constructor. Take the QtraceIDA object if launched through QtraceIDA
        """
        QtWidgets.QWidget.__init__(self)
        ida_kernwin.PluginForm.__init__(self)
        self.qtrace = qtrace
        self.parent_widget = self

        # Visibility state
        self.closed = True

        # Popup actions
        self.popup_from_here = SynthetizeFromHere(self)
        self.popup_to_here = SynthetizeToHere(self)
        self.popup_operand = SynthetizeOperand(self)

        # Analysis variables
        self.symexec = None
        self.lookuptable = None
        self.ast = None
        self.synthesizer = None
        self.synth_ast = None
        # For operand synthesis
        self.stop_addr = None  # Address where to analysis end
        self.op_num = None
        self.op_is_read = False  # Negation of if the operand is written

        # If working on its own
        self._dbm = None
        self._trace = None
        self._arch = processor_to_arch()  # By default initialize it with current architecture

        # Expresssion highlighted
        self.highlighted_addr = {}  # addr -> backed_color

    @property
    def arch(self) -> Arch:
        """ Return current QtraceDB Arch object whether it comes from qtraceida or the trace directly """
        if QTRACEIDA_ENABLED and self.qtrace_mode:
            return self.qtrace.arch
        else:
            return self._arch

    @property
    def trace(self) -> Trace:
        """ Return current Trace object whether it comes from qtraceida or a manual loading """
        if QTRACEIDA_ENABLED and self.qtrace_mode:
            return self.qtrace.trace
        else:
            return self._trace

    @property
    def qtrace_mode(self) -> bool:
        """ Return whether QSynthesis was launched through qtrace or not """
        return self.qtrace is not None

    def get_instruction(self, ea: Addr) -> Instr:
        """
        Disassemble the current instruction as a QtraceDB Instruction object

        :param ea: address of the head of the instruction
        :return: instruction object

        .. warning:: The current address have to be code and being
                     the head of an instruction
        """
        opc = ida_bytes.get_bytes(ea, ida_bytes.get_item_size(ea))
        return self.arch.disasm_one(opc, ea)

    def is_lookuptable_loaded(self) -> bool:
        """ Return true if the lookup table is loaded """
        return self.lookuptable is not None

    def OnCreate(self, form) -> None:
        """
        PluginForm callback called when view is created. It initialize
        the whole view with all the widgets.
        """
        self.parent_widget = self.FormToPyQtWidget(form)
        # Init of the view has to be done here ?
        self.init()

        # Put that check here otherwise init will override this enabling
        # NOTE: Might be better to implement it in a proprer callback
        if self.trace:
            self.on_trace_opened(self.trace)
        else:
            self.set_algorithm_type_enable(AnalysisType.QTRACE, False)

    def Show(self) -> bool:
        """ Creates the form if not created or focuses it if it was """
        self.closed = False
        self.enable_popups()
        opts = ida_kernwin.PluginForm.WOPN_PERSIST
        r = ida_kernwin.PluginForm.Show(self, self.NAME, options=opts)
        ida_kernwin.set_dock_pos(self.NAME, "IDA View-A", ida_kernwin.DP_RIGHT)
        return r

    def OnClose(self, form) -> None:
        """ Window closed callback. Disable all popup actions """
        # Change visibility state
        print("qsynthesis closed")
        self.closed = True
        self.disable_popups()

    def enable_popups(self) -> None:
        """ Enable IDA View popup actions """
        self.popup_from_here.register()
        self.popup_to_here.register()
        self.popup_operand.register()

    def disable_popups(self) -> None:
        """ Disabled IDA View popup actions """
        self.popup_from_here.unregister()
        self.popup_to_here.unregister()
        self.popup_operand.unregister()

    def set_visible_all_layout(self, layout: QtWidgets.QLayout, val: bool) -> None:
        """
        Change the visibility of all the widgets contained in a layout

        :param layout: Layout widget in which to show/hide all sub-components
        :param val: Boolean value to either set visible or invisible
        :return: None
        """
        for i in range(layout.count()):
            item = layout.itemAt(i)
            item_w = item.widget()
            if item_w is None:
                if isinstance(item, QtWidgets.QLayout):
                    self.set_visible_all_layout(item, val)
            else:
                item_w.setVisible(val)

    def set_enabled_all_layout(self, layout: QtWidgets.QLayout, val: bool) -> None:
        """
        Change the 'enabled' state of all the widgets contained in a layout

        :param layout: Layout widget in which to enable/disable all sub-components
        :param val: Boolean value to either set enabled or disabled
        :return: None
        """
        for i in range(layout.count()):
            item = layout.itemAt(i)
            item_w = item.widget()
            if item_w is None:
                if isinstance(item, QtWidgets.QLayout):
                    self.set_enabled_all_layout(item, val)
            else:
                item_w.setEnabled(val)

    def init(self) -> None:
        """
        Initialization function called on view creation to instanciate
        all widgets and its default state.
        """
        self.setupUi(self.parent_widget)
        if QTRACEIDA_ENABLED or not QTRACEDB_ENABLED:  # The trace will be provided by qtraceida so not showing this
            self.set_visible_all_layout(self.traceLayout, False)
        else:  # Initialize the fields and actions
            self.trace_type_box.addItems([x.name for x in TraceDbType])
            self.trace_type_box.currentIndexChanged.connect(self.trace_type_changed)
            self.trace_line.focusInEvent = self.customfocusInEventTraceLine

        # Target configuration
        reg = QtCore.QRegExp("^(0x)?[a-fA-F0-9]+$")
        validator = QtGui.QRegExpValidator(reg)
        self.from_line.setValidator(validator)
        self.from_line.textChanged.connect(self.from_line_changed)
        self.from_line.editingFinished.connect(self.from_line_reset_style)
        self.to_line.textChanged.connect(self.to_line_changed)
        self.to_line.editingFinished.connect(self.to_line_reset_style)
        self.to_line.setValidator(validator)
        self.mem_line.textChanged.connect(self.mem_line_changed)
        self.mem_line.editingFinished.connect(self.mem_line_reset_style)
        self.mem_line.setValidator(validator)
        self.target_box.addItems([x.name for x in TargetType])
        self.target_box.currentIndexChanged.connect(self.target_changed)
        self.mem_line.setVisible(False)
        self.operand_label.setVisible(False)

        # Table configuration
        self.table_type_box.addItems([x.name for x in TableType])
        self.table_type_box.currentIndexChanged.connect(self.table_type_changed)
        self.table_line.focusInEvent = self.customfocusInEventLookupTableLine

        # Algorithm configuration
        self.algorithm_box.addItems([x.value for x in AlgorithmType])

        # Add both QTRACE, and FULL_SYMBOLIC algorithms and disabled them
        self.algorithm_type_box.addItems([x.name for x in AnalysisType])
        self.algorithm_type_box.currentIndexChanged.connect(self.algorithm_type_changed)
        self.set_algorithm_type_enable(AnalysisType.QTRACE, QTRACEDB_ENABLED)
        self.set_algorithm_type_enable(AnalysisType.FULL_SYMBOLIC, IDA_ENABLED)
        self.qtrace_sym_type_box.addItems([x.name for x in QtraceSymType])

        # Hide all experimental settings
        self.set_visible_all_layout(self.experimentalLayout, False)

        self.run_triton_button.clicked.connect(self.run_triton_clicked)
        self.show_deps_triton_button.setText(ShowDepState.SHOW.value)
        self.show_deps_triton_button.clicked.connect(self.triton_show_deps_clicked)
        self.show_ast_triton_button.clicked.connect(self.triton_show_ast_clicked)
        self.run_synthesis_button.clicked.connect(self.run_synthesis_clicked)
        self.show_ast_synthesis_button.clicked.connect(self.synthesis_show_ast_clicked)
        self.reassemble_button.clicked.connect(self.reassemble_clicked)

    def switch_to_target_operand(self) -> None:
        """ Change target type to operand. (Meant to be called by the popup action) """
        self.target_box.setCurrentIndex(TargetType.OPERAND.value)

    def set_algorithm_type_enable(self, alg: AnalysisType, enabled: bool):
        # We assume here that items are in order (with their value attribute)
        self.algorithm_type_box.model().item(alg.value).setEnabled(enabled)
        if not enabled:
            self.algorithm_type_box.setCurrentIndex(AnalysisType.FULL_SYMBOLIC.value if AnalysisType.QTRACE else AnalysisType.QTRACE.value)
            self.algorithm_type_changed()

    def algorithm_type_changed(self) -> None:
        """
        When changing algorithm type. Enable or disable the mode
        associated with Qtrace.
        """
        self.qtrace_sym_type_box.setEnabled(self.analysis_type == AnalysisType.QTRACE)

    @property
    def qtrace_sym_type(self) -> QtraceSymType:
        """ Return the current symbolic mode of analysis for trace DSE """
        return QtraceSymType(self.qtrace_sym_type_box.currentIndex())

    def from_line_reset_style(self) -> None:
        """ Reset from_line stylesheet """
        self.from_line.setStyleSheet("")

    def from_line_changed(self) -> None:
        """
        Callback called when something change in 'From' field. Validated it
        against the validator (and either show red / green around the box)
        """
        color = "green" if self.from_line.hasAcceptableInput() else "red"
        self.from_line.setStyleSheet(f"border: 1px solid {color}")

    def to_line_reset_style(self) -> None:
        """ Reset to_line stylesheet """
        self.to_line.setStyleSheet("")

    def to_line_changed(self) -> None:
        """
        Callback called when something change in 'To' field. Validated it
        against the validator (and either show red / green around the box)
        """
        color = "green" if self.to_line.hasAcceptableInput() else "red"
        self.to_line.setStyleSheet(f"border: 1px solid {color}")

    def mem_line_reset_style(self) -> None:
        """ Reset the memory line stylesheet """
        self.mem_line.setStyleSheet("")

    def mem_line_changed(self) -> None:
        """
        Callback called when something change in 'Memory' field. Validated it
        against the validator (and either show red / green around the box)
        """
        color = "green" if self.mem_line.hasAcceptableInput() else "red"
        self.mem_line.setStyleSheet(f"border: 1px solid {color}")

    def open_no_trace(self) -> None:
        """
        Function called when the plugin is opened wihtout any active
        trace.
        """
        self.on_trace_opened(None)
        self.set_algorithm_type_enable(AnalysisType.QTRACE, False)

    def on_trace_opened(self, trace: Optional[Trace]) -> None:
        """
        Callback called when a trace is opened either via Qtrace-IDA
        or directly when Qtrace-IDA is not available.

        :param trace: Trace just having been opened
        """
        if trace:
            print(f"QSynthesis: on_trace_opened ({trace})")
        self.set_algorithm_type_enable(AnalysisType.QTRACE, True)
        # Activate all configuration lines
        self.set_enabled_all_layout(self.targetLayout, True)
        # Initialize registers of the targetcombobox
        self.register_box.addItems([x.name for x in ArchsManager.get_supported_regs(self.arch)])
        self.set_enabled_all_layout(self.tableLayout, True)
        self.set_enabled_all_layout(self.algorithmLayout, True)
        self.run_triton_button.setEnabled(True)

    def target_changed(self, index: int) -> None:
        """ Enable and disable appropriate widget when changing the target selector """
        t = TargetType(index)
        if t == TargetType.REG:
            self.register_box.setVisible(True)
            self.mem_line.setVisible(False)
            self.operand_label.setVisible(False)
        elif t == TargetType.MEMORY:
            self.register_box.setVisible(False)
            self.operand_label.setVisible(False)
            self.mem_line.setVisible(True)
        elif t == TargetType.OPERAND:
            self.register_box.setVisible(False)
            self.mem_line.setVisible(False)
            self.operand_label.setVisible(True)
            self.operand_label.clear()
        else:
            assert False

    @property
    def target_type(self) -> TargetType:
        """ Return target type as an enum """
        return TargetType(self.target_box.currentIndex())

    @property
    def table_type(self) -> TableType:
        """ Return table type as an enum """
        return TableType(self.table_type_box.currentIndex())

    def table_type_changed(self, _) -> None:
        """ Called when table type changed. (just set a placeholder string) """
        self.table_line.setText("")
        if self.table_type == TableType.HTTP:
            self.table_line.setPlaceholderText('e.g: http://localhost')
        else:
            self.table_line.setPlaceholderText("")

    def customfocusInEventLookupTableLine(self, event) -> None:
        """
        Callback called when to focus is given to the table field.
        Instead of leaving the user writing a path, open a dialog
        to open a given file.
        """
        self.table_line.setStyleSheet("")
        if self.table_type == TableType.LEVELDB:
            filename = QtWidgets.QFileDialog.getExistingDirectory()
            filepath = Path(filename)
            if filepath.exists() and filepath.is_dir():
                self.table_line.setText(str(filepath))
            else:
                print(f"Invalid file: {filepath}")

            self.trace_line.focusNextChild()

    @property
    def algorithm(self) -> AlgorithmType:
        """ Return algorithm type as an enum """
        return AlgorithmType(self.algorithm_box.currentText())

    @property
    def analysis_type(self) -> AnalysisType:
        """ Return analysis type as an enum """
        return AnalysisType[self.algorithm_type_box.currentText()]

    def run_triton_clicked(self) -> None:
        """
        Triton button clicked callback. Verifies that all parameters are
        valid before triggering the symbolic execution. At the end delegate
        the computation to :meth:`SynthesizerView.run_triton_qtrace` or
        :meth:`SynthesizerView.run_triton_fullsym`.
        """
        self.ast = None  # Reset the AST variable
        self.triton_textarea.clear()  # clear
        self.set_enabled_synthesis_widgets(False)

        if self.is_lookuptable_loaded():
            if self.lookuptable.name != self.table_line.text():
                print("Reload lookup table")
                ret = self.load_lookup_table()
            else:
                ret = True
        else:
            ret = self.load_lookup_table()
        if not ret:
            return

        if self.analysis_type == AnalysisType.QTRACE:
            ret = self.run_triton_qtrace()
        elif self.analysis_type == AnalysisType.FULL_SYMBOLIC:
            ret = self.run_triton_fullsym()
        else:
            assert False

        if ret:
            self.on_triton_finished()

    def load_lookup_table(self) -> bool:
        """
        Open the lookup table selected. If LevelDB open database and if REST
        checks that the remote URL is reachable.

        :return: True if the opening succeeded
        """
        if not self.table_line.text():
            self.table_line.setStyleSheet("border: 1px solid red")
            return False
        if self.table_type == TableType.HTTP:
            try:
                self.lookuptable = InputOutputOracleREST.load(self.table_line.text())
            except ConnectionAbortedError as e:
                QtWidgets.QMessageBox.critical(self, "Table Loading", f"Error contacting {self.table_line}\n{e}")
                return False
        elif self.table_type == TableType.LEVELDB:
            try:
                self.lookuptable = InputOutputOracleLevelDB.load(self.table_line.text())
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "Table Loading", f"Error when loading database: {e}")
                return False
        return True

    def line_to_qtrace_inst(self, widget: QtWidgets.QLineEdit) -> Optional[InstrCtx]:
        """
        Retrieve a trace instruction from a LineEdit widget which content
        is meant to be an address.

        :param widget: LineEdit widget containing an address (in our context from_line and to_line)
        :return: First instruction in the trace hitting the address (if valid)
        """
        if not widget.hasAcceptableInput():
            widget.setStyleSheet("border: 1px solid red")
            return None
        else:
            addr = int(widget.text(), 16)
            inst = self.trace.get_first_instr_at_addr(addr)
            if inst is None:
                QtWidgets.QMessageBox.critical(self, "Invalid parameter", f"No instruction in trace at address: {addr:#x}")
                return None
            else:
                return inst

    def run_triton_qtrace(self) -> bool:
        """
        Run the symbolic execution with Triton on the Trace. First performs
        all the sanitization on the fields and then delegate computation to
        the `QtraceSymExec` object of qsynthesis.utils.

        :return: True if the symbolic execution procceeded without errors
        """
        # Make sure a trace is loaded before proceeding
        if self.trace is None:
            QtWidgets.QMessageBox.critical(self, "No trace", f"A trace should be loaded first ")
            return False

        from_inst = self.line_to_qtrace_inst(self.from_line)
        if from_inst is None:
            return False
        to_inst = self.line_to_qtrace_inst(self.to_line)
        if to_inst is None:
            return False
        if to_inst.id < from_inst.id:
            QtWidgets.QMessageBox.critical(self, "Invalid order", f"Instruction {from_inst.addr:#x}{from_inst} higher in the trace than {to_inst.addr:#x}{to_inst} ({from_inst.id} > {to_inst.id})")
            return False

        if self.target_type == TargetType.MEMORY:
            if not self.mem_line.hasAcceptableInput():
                self.mem_line.setStyleSheet("border: 1px solid red")
                return False
            else:
                mem_addr = int(self.mem_line.text(), 16)

        # Do not execute last instruction if operand & read operand else always execute last instruction
        off = 0 if self.target_type == TargetType.OPERAND and self.op_is_read else 1

        # Set the stop addr (for operand reassembly)
        self.stop_addr = to_inst.addr

        # At this point we are sur to have valid parameters

        from qsynthesis.utils.qtrace_symexec import QtraceSymExec, Mode
        m = Mode[self.qtrace_sym_type.name]
        self.symexec = QtraceSymExec(self.trace, m)
        self.symexec.initialize_register(self.arch.INS_PTR.name, from_inst.INS_PTR)
        self.symexec.initialize_register(self.arch.STK_PTR.name, from_inst.STK_PTR)
        self.symexec.process_instr_sequence(from_inst.id, to_inst.id+off)
        if self.target_type == TargetType.REG:
            self.ast = self.symexec.get_register_ast(self.register_box.currentText())
        elif self.target_type == TargetType.MEMORY:
            self.ast = self.symexec.get_memory_ast(mem_addr, int(self.lookuptable.bitsize/8))
        elif self.target_type == TargetType.OPERAND:
            if self.op_is_read: # if read disassemble only the last instruction
                inst = self.symexec.disassemble(to_inst.opcode, to_inst.addr)
                self.ast = self.symexec.get_operand_ast(self.op_num, inst)
            else:  # operand is write can directly get its ast
                self.ast = self.symexec.get_operand_ast(self.op_num)
        else:
            assert False
        self.symexec.ctx.clearCallbacks()  # Fix the bug from space / can also be fixed by making self.symexec object attribute
        return True

    def run_triton_fullsym(self) -> bool:
        """
        Run the symbolic execution in 'pure' symbolic (without trace). First performs
        all the sanitization on the fields and then delegate computation to the
        `SimpleSymExec` object of qsynthesis.utils.

        :return: True if the symbolic execution procceeded without errors
        """
        if Processor.type == ProcessorType.UNKNOWN:
            QtWidgets.QMessageBox.critical(self, "Unsupported arch", f"Architecture {Processor.name} is not supported by Triton")
            return False
        if not self.from_line.hasAcceptableInput():
            self.from_line.setStyleSheet("border: 1px solid red")
            return False
        if not self.to_line.hasAcceptableInput():
            self.to_line.setStyleSheet("border: 1px solid red")
            return False
        cur_addr = int(self.from_line.text(), 16)
        end_addr = int(self.to_line.text(), 16)
        if end_addr <= cur_addr:
            QtWidgets.QMessageBox.critical(self, "Invalid order", f"From {cur_addr:#x} must be lower than {end_addr:#x}")
            return False
        if not ida_bytes.is_mapped(cur_addr) or not ida_bytes.is_mapped(end_addr):
            QtWidgets.QMessageBox.critical(self, "Invalid address",
                                           f"From: {cur_addr:#x} or To: {end_addr:#x} is not mapped in memory")
            return False

        if self.target_type == TargetType.MEMORY:
            if not self.mem_line.hasAcceptableInput():
                self.mem_line.setStyleSheet("border: 1px solid red")
                return False
            else:
                mem_addr = int(self.mem_line.text(), 16)

        if self.target_type == TargetType.OPERAND and self.op_is_read:
            self.stop_addr = end_addr  # Do not execute last address
        else:
            self.stop_addr = ida_bytes.get_item_end(end_addr)  # Do execute 'to' address
        # At this point we are sur to have valid parameters

        # Create the purely symbolic executor
        self.symexec = SimpleSymExec(processor_to_triton_arch())
        from triton import MODE
        self.symexec.ctx.setMode(MODE.ONLY_ON_SYMBOLIZED, False)

        self.symexec.initialize_register(self.arch.INS_PTR.name, cur_addr)
        self.symexec.initialize_register(self.arch.STK_PTR.name, 0x800000)

        # Execute the range of instructions
        while cur_addr < self.stop_addr:  # Retrieve directly bytes from IDA
            if ida_bytes.is_code(ida_bytes.get_flags(cur_addr)):
                opc = ida_bytes.get_bytes(cur_addr, ida_bytes.get_item_size(cur_addr))
                if not self.symexec.execute(opc):
                    QtWidgets.QMessageBox.critical(self, "Symbolic Execution Error", f"Instruction at address {cur_addr:#x} seems unsupported by Triton")
                    return False
            else:
                QtWidgets.QMessageBox.critical(self, "Invalid byte", f"Stop on address: {cur_addr:#x} which is not code")
                return False
            cur_addr = ida_bytes.next_head(cur_addr, self.stop_addr)

        if self.target_type == TargetType.REG:
            self.ast = self.symexec.get_register_ast(self.register_box.currentText())
        elif self.target_type == TargetType.MEMORY:
            self.ast = self.symexec.get_memory_ast(mem_addr, int(self.lookuptable.bitsize/8))
        elif self.target_type == TargetType.OPERAND:
            if self.op_is_read: # if read disassemble only the last instruction
                opc = ida_bytes.get_bytes(self.stop_addr, ida_bytes.get_item_size(self.stop_addr))
                inst = self.symexec.disassemble(opc, self.stop_addr)
                self.ast = self.symexec.get_operand_ast(self.op_num, inst)
            else:  # operand is write can directly get its ast
                self.ast = self.symexec.get_operand_ast(self.op_num)
        else:
            assert False

        self.symexec.ctx.clearCallbacks()
        return True

    def on_triton_finished(self) -> None:
        """
        Function called when symbolic execution terminated successfully.
        Enable all the synthesis related widget in the view.
        """
        # Enable Triton fields
        self.triton_textarea.setEnabled(True)
        if IDA_ENABLED:
            self.show_deps_triton_button.setEnabled(True)
        if QTRACEIDA_ENABLED:
            self.show_ast_triton_button.setEnabled(True)

        # Fill the text area with the results
        self.fill_triton_results()

        # Enable all buttons related to synthesis
        self.set_enabled_synthesis_widgets(True)

    def fill_triton_results(self) -> None:
        """ Generate the resulting analysis HTML and fill the widget """
        if self.ast.symvars:
            tpl = '<tr><td align="center">%s</td><td align="center">%d</td></tr>'
            inp_s = "\n".join(tpl % (x.getAlias(), x.getBitSize()) for x in self.ast.symvars)
        else:
            inp_s = "<big><b>0</b></big>"
        self.triton_textarea.setHtml(TEMPLATE_TRITON % (self.ast.node_count, self.ast.depth, inp_s))

    def triton_show_deps_clicked(self) -> None:
        """
        Callback called when Show Dependencies is clicked. The function
        retrieve the dependencies (pre-computed during symbolic execution)
        and color the appropriate lines in the IDA view.
        """
        st = ShowDepState(self.show_deps_triton_button.text())
        if st == ShowDepState.SHOW:
            addrs = self.get_dependency_addresses()
            for addr in addrs:
                back = ida_nalt.get_item_color(addr)
                self.highlighted_addr[addr] = back
                ida_nalt.set_item_color(addr, 0xA1F7A1)

        else:
            for addr, color in self.highlighted_addr.items():
                ida_nalt.set_item_color(addr, color)
            self.highlighted_addr.clear()

        # Switch state
        self.show_deps_triton_button.setText(ShowDepState.HIDE.value if st == ShowDepState.SHOW else ShowDepState.SHOW.value)

    def get_dependency_addresses(self) -> List[Addr]:
        """
        Retrieve Triton 'SymbolicExpression' of the expression to synthesize as
        'SymbolicExpression' contain a comment field which contain the link between
        expressions and Instructions. The expression is given to the slicer iterate
        the expression to retrieve the set of instruction involved in computation.

        :return: list of addresses involved in the computation of the expression
        """
        if self.target_type == TargetType.REG:
            sym = self.symexec.get_register_symbolic_expression(self.register_box.currentText())
        elif self.target_type == TargetType.MEMORY:
            # FIXME: Sanitize memory value before using it
            mem_addr = int(self.mem_line.text(), 16)
            sym = self.symexec.get_memory_symbolic_expression(mem_addr, int(self.lookuptable.bitsize / 8))
        elif self.target_type == TargetType.OPERAND:
            sym = self.symexec.get_operand_symbolic_expression(self.op_num)
        else:
            assert False

        # Iterate all addresses
        return sorted(slicer.backslice(sym))

    def triton_show_ast_clicked(self) -> None:
        """ Show the AST of the triton expression """
        viewer = AstViewer("Triton AST", self.ast)
        viewer.Show()

    def run_synthesis_clicked(self) -> None:
        """
        Run the synthesis using the algorithm selected.
        """

        # Check the compatibiliy
        if not self.lookuptable.is_expr_compatible(self.ast):
            QtWidgets.QMessageBox.critical(self, "Incompatibility",
                                           f"Variables of the AST expression {self.ast.symvars} are incompatibles"
                                           f"with table variables {self.lookuptable.grammar.vars_dict} (in sizes)")
            return

        if self.algorithm == AlgorithmType.TOPDOWN:
            synthesizer = TopDownSynthesizer(self.lookuptable)
        else:
            synthesizer = PlaceHolderSynthesizer(self.lookuptable)
        self.synth_ast, _ = synthesizer.synthesize(self.ast)

        self.on_synthesis_finished()

    def on_synthesis_finished(self) -> None:
        """
        Upon synthesis termination. Enable the remaining buttons
        """
        # Enable Synthesis fields
        self.synthesis_textarea.setEnabled(True)
        if QTRACEIDA_ENABLED:
            self.show_ast_synthesis_button.setEnabled(True)
        if IDA_ENABLED:
            self.reassemble_button.setEnabled(True)

        # Fill the text area with the results
        self.fill_synthesis_results()

    def fill_synthesis_results(self) -> None:
        """
        Fill synthesis result widget as pre-formatted HTML
        """
        color, simp = ("green", "Yes") if self.ast.node_count > self.synth_ast.node_count else ("red", "No")
        ssexpr = "<small>(too large)</small>" if self.synth_ast.node_count > 12 else f"<big><b>{self.synth_ast.pp_str}</b></big>"
        scale = -(((self.ast.node_count - self.synth_ast.node_count) * 100) / self.ast.node_count)
        self.synthesis_textarea.setHtml(TEMPLATE_SYNTHESIS % (color, simp, ssexpr, self.synth_ast.node_count, self.synth_ast.depth, scale, '%'))

    def synthesis_show_ast_clicked(self) -> None:
        """ Show the AST of the synthesized expression """
        viewer = AstViewer("Synthesized AST", self.synth_ast)
        viewer.Show()

    def set_enabled_synthesis_widgets(self, val: bool) -> None:
        """
        Enable or Disable synthesis related widgets

        :param val: boolean on whether to enable or disable the widgets
        """
        self.run_synthesis_button.setEnabled(val)
        self.synthesis_textarea.setEnabled(val)
        if not val:  # In case we disable everything
            self.synthesis_textarea.clear()  # Clear synthesis view
            self.show_ast_synthesis_button.setEnabled(val)
            self.reassemble_button.setEnabled(val)

    def reassemble_clicked(self) -> None:
        """
        Callback clicked when Reassembly is clicked. Shows an additional
        window to select various parameters and the call the appropriate
        auxiliary function.
        """
        is_reg, reg = self.selected_expr_register()
        res = self.get_reassembly_options(ask_reg=not is_reg)
        if res:
            rg, patch_fun, shrink_fun, snap = res
            dst_reg = reg.lower() if is_reg else rg.lower()
            try:
                if patch_fun:
                    addrs = self.get_dependency_addresses()
                    asm_bytes = self.synth_ast.reassemble(dst_reg, self.arch.NAME)
                    if snap:  # Create a snapshot of the database
                        ss = ida_loader.snapshot_t()
                        ss.desc = f"Reassembly of {dst_reg} at {self.stop_addr:#x}"
                        ida_kernwin.take_database_snapshot(ss)
                    if shrink_fun:
                        self.patch_and_shrink_reassembly(addrs, asm_bytes)
                    else:
                        self.patch_reassembly(addrs, asm_bytes)
                else:
                    # Reassemble to instruction and show it in a View
                    raw_insts = self.synth_ast.reassemble(dst_reg, self.arch.NAME)
                    insts = self.arch.disasm(raw_insts, 0x0)
                    bb_viewer = BasicBlockViewer("Reassembly", insts)
                    bb_viewer.Show()
            except ReassemblyError as e:
                QtWidgets.QMessageBox.critical(self, "Reassembly error", f"Error: {e}")
        else:
            pass # Do nothing user click canceled on options

    @staticmethod
    def coallesce_addrs(addrs: Iterable[Addr]) -> List[Tuple[Addr, int]]:
        """ Convert list of addresses into blocks of addr+size """
        blocks = []
        for addr in addrs:
            sz = ida_bytes.get_item_size(addr)
            if not blocks:
                blocks.append((addr, sz))
            else:
                b_addr, b_sz = blocks[-1]
                if b_addr + b_sz == addr:  # We are next to the previous item
                    blocks[-1] = (b_addr, b_sz+sz)
                else:  # The address is not contiguous
                    blocks.append((addr, sz))
        return blocks

    def patch_reassembly(self, addrs: List[Addr], asm: bytes) -> None:
        """
        Patch given addresses with NOPs and put `asm` bytes corresponding
        to reassembled instruction on the last addresses to put reassembled
        byte near the location the expression was extracted from.

        :param addrs: sorted list of addresses to strip
        :param asm: reassembled instructino bytes
        """
        nop = self.arch.nop_instruction
        insts = self.arch.disasm(asm, 0x0)
        blocks = self.coallesce_addrs(addrs)
        if sum(x[1] for x in blocks) < len(asm):
            QtWidgets.QMessageBox.critical(self, "Reassembly error", f"No enough place to push back reassembled instructions")
            return

        block_addr, block_sz = blocks.pop()
        for i in insts[::-1]:
            data = i.bytes
            while len(data) > block_sz:  # While blocks are too small fill them with nop
                if block_sz != 0:
                    ida_bytes.patch_bytes(block_addr, nop * block_sz)  # Fill space of the block with NOPs
                if blocks:
                    block_addr, block_sz = blocks.pop()
                else:
                    QtWidgets.QMessageBox.critical(self, "Reassembly error", "No slot to place instruction remaining, abort")
                    return

            # Here there is meant to be enough space to place instruction
            p_addr = block_addr + block_sz - len(data)  # compute address where to patch within block
            self.safe_patch_instruction(p_addr, data)
            block_sz -= len(data)

        # All instructions have been put in blocks, fill the remaining ones with NOPs
        while blocks or block_sz:
            if block_sz:
                ida_bytes.patch_bytes(block_addr, nop * block_sz)  # Fill space of the block with NOPs
                block_sz = 0
            if blocks:
                block_addr, block_sz = blocks.pop()

    @staticmethod
    def safe_patch_instruction(ea: Addr, data: bytes) -> None:
        """
        Patch a single instruction with its bytes (data). Make sure IDA
        recognize it as an instruction after patching.

        :param ea: address to patch
        :param data: instruction bytes
        """
        ida_bytes.patch_bytes(ea, data)  # Patch bytes
        if not ida_bytes.is_code(ida_bytes.get_flags(ea)):  # Check that the address is now a code instruction, if not:
            ida_bytes.del_items(ea, 0, len(data))   # Del all types
            ida_ua.create_insn(ea)                  # Redecode instruction
        if not ida_bytes.is_code(ida_bytes.get_flags(ea)):
            print("Really can't create instruction at that location")

    @staticmethod
    def safe_patch_instruction_block(ea: Addr, data: bytes) -> None:
        """
        Patch an address with a bunch of instruction bytes (data). Make sure
        IDA recognize all of them as instruction after patching.

        :param ea: address where to patch
        :param data: instruction bytes to put as patch
        """
        print(f"safe_patch_instruction_block {ea:#x}: {data}")
        ida_bytes.patch_bytes(ea, data)  # Patch bytes
        ida_bytes.del_items(ea, 0, len(data))
        ida_ua.create_insn(ea)

    def patch_and_shrink_reassembly(self, addrs, asm) -> None:
        init_addr = addrs[0]
        f = ida_funcs.get_func(init_addr)
        f_start_ea = f.start_ea
        g = ida_gdl.FlowChart(f)
        low, high = init_addr, addrs[-1]
        block = None
        for bb in g:
            if bb.start_ea <= low < bb.end_ea and bb.start_ea <= high <= bb.end_ea:
                block = bb
        if block is None:
            QtWidgets.QMessageBox.critical(self, "Reassembly error", "Dependency slice have to be in the same basic block")
            return

        # Scan all items
        cur_addr = init_addr
        payload = b""
        while cur_addr < block.end_ea:  # Iterate the whole basicblock
            if not addrs and asm: # if we poped all the dependencies we can put the synthesized expr
                payload += asm
                asm = None
            
            if cur_addr not in addrs:  # Instruction not in dependency so keep it
                sz = ida_bytes.get_item_size(cur_addr)
                payload += ida_bytes.get_bytes(cur_addr, sz)
            else:
                addrs.remove(cur_addr)  # remove the address from deps

            cur_addr = ida_bytes.next_head(cur_addr, block.end_ea)

        if asm:  # If it has not been "Noned" it has not been put in payload
            print("reassembled payload has not been placed in the final basic bloc (abort reassembly)")
            return

        # Perform the final patching
        self.safe_patch_instruction_block(init_addr, payload)

        # If the block was the first of the function and we rewrote the head
        # and the function has been destroyed. Reconstruct it.
        if init_addr == f_start_ea and ida_funcs.get_func(init_addr) is None:
            res = ida_funcs.add_func(init_addr)
            print(f"Function reconstruction: {res}")
            return

        # If the block was the last of the function (adjust the end of the function)
        if f.end_ea == block.end_ea:
            print(f"adjust of the function to {init_addr+len(payload):#x}")
            ida_funcs.set_func_end(init_addr, init_addr+len(payload))

    def get_reassembly_options(self, ask_reg: bool = False) -> Optional[Tuple[str, bool, bool, bool]]:
        """
        Function showing a Dialog to ask reassembly parameters.

        :param ask_reg: boolean on whether to ask the destination register or not
        :return: optional list of options
        """
        dlg = QtWidgets.QDialog(parent=None)
        dlg.setWindowTitle('Reassembly options')

        v_layout = QtWidgets.QVBoxLayout(dlg)
        if ask_reg:
            h_layout = QtWidgets.QHBoxLayout()
            label_reg = QtWidgets.QLabel(dlg)
            label_reg.setText("Destination register:")
            h_layout.addWidget(label_reg)
            combobox = QtWidgets.QComboBox(dlg)
            combobox.addItems([x.name for x in ArchsManager.get_supported_regs(self.arch)])
            h_layout.addWidget(combobox)
            v_layout.addLayout(h_layout)

        patch_fun = QtWidgets.QCheckBox(dlg)
        patch_fun.setText("patch function bytes")
        v_layout.addWidget(patch_fun)

        shrink_fun = QtWidgets.QCheckBox(dlg)
        shrink_fun.setText("shrink function\n move some instruction instead of filling with NOPs.\nCan break disassembly"
                           " for relative instructions. (Works only for linear blocks)")
        shrink_fun.setEnabled(False)
        v_layout.addWidget(shrink_fun)

        def patch_checked():
            if patch_fun.isChecked():
                shrink_fun.setEnabled(True)
            else:
                shrink_fun.setEnabled(False)
                shrink_fun.setChecked(False)

        patch_fun.stateChanged.connect(patch_checked)

        snapshot = QtWidgets.QCheckBox(dlg)
        snapshot.setText("Snapshot database before patching")
        v_layout.addWidget(snapshot)

        buttonbox = QtWidgets.QDialogButtonBox(dlg)
        buttonbox.setOrientation(QtCore.Qt.Horizontal)
        buttonbox.setStandardButtons(QtWidgets.QDialogButtonBox.Cancel | QtWidgets.QDialogButtonBox.Ok)
        v_layout.addWidget(buttonbox)
        buttonbox.accepted.connect(dlg.accept)
        buttonbox.rejected.connect(dlg.reject)

        dlg.exec()

        if dlg.result():
            reg = combobox.currentText() if ask_reg else None
            return reg, patch_fun.isChecked(), shrink_fun.isChecked(), snapshot.isChecked()
        else:
            return None

    def selected_expr_register(self) -> Tuple[bool, Optional[str]]:
        """
        Return the currently selected register depending on target type.
        None if no register is selected
        """
        if self.target_type == TargetType.REG:
            return True, self.register_box.currentText()
        elif self.target_type == TargetType.MEMORY:
            return False, None
        elif self.target_type == TargetType.OPERAND:

            opc = ida_bytes.get_bytes(self.stop_addr, ida_bytes.get_item_size(self.stop_addr))
            inst = self.arch.disasm_one(opc, self.stop_addr)
            if inst is None:
                return False, None
            op = inst.operands[self.op_num]
            if op.is_register():
                op_name = ida_lines.tag_remove(ida_ua.print_operand(self.stop_addr, self.op_num))
                return True, op_name  # op.register.name
            else:
                return False, None

    # =====================  Utility functions when Qtrace-IDA is NOT available  ======================
    @property
    def trace_type(self) -> TraceDbType:
        """ Trace type to load as an enum """
        return TraceDbType(self.trace_type_box.currentIndex())

    def trace_type_changed(self, _):
        """ Trace field changed """
        self.trace_line.setText("")

    def customfocusInEventTraceLine(self, event):
        """ Triggered when getting the focus on trace line edit. To help to user selecting a trace. """
        self.trace_line.setText("")
        if self.trace_type == TraceDbType.CONFIG:
            self._dbm = DatabaseManager.from_qtracedb_config()
            t_name = self.get_trace_from_db()
            if t_name:
                self._trace = self._dbm.get_trace(t_name)
                self._arch = self._trace.get_arch()
                self.trace_line.setText(t_name)
                self.on_trace_opened(self._trace)
        elif self.trace_type == TraceDbType.SQLITE:
            filename = QtWidgets.QFileDialog.getOpenFileName()[0]
            filepath = Path(filename)
            if filepath.exists() and filepath.is_file():
                try:
                    self._dbm = DatabaseManager(f'sqlite:///{filepath.absolute()}')
                    self._trace = self._dbm.get_trace("x86_64")
                    self._arch = self._trace.get_arch()
                    self.trace_line.setText(str(filepath))
                    self.on_trace_opened(self._trace)
                except Exception:
                    print(f"Invalid database: {filepath}")
            else:
                print(f"Invalid file: {filepath}")
        self.trace_line.focusNextChild()

    def get_trace_from_db(self) -> Optional[str]:
        """
        Show a custom Dialog to select a trace from a list of traces
        retrieved via de qtracedb configuration.
        :return: optional name of the trace
        """
        dlg = QtWidgets.QDialog(parent=self)
        dlg.setWindowTitle('Qtrace-DB connection')
        dlg.setObjectName("Dialog")

        v_layout = QtWidgets.QVBoxLayout(dlg)
        combobox = QtWidgets.QComboBox(dlg)
        v_layout.addWidget(combobox)
        buttonbox = QtWidgets.QDialogButtonBox(dlg)
        buttonbox.setOrientation(QtCore.Qt.Horizontal)
        buttonbox.setStandardButtons(QtWidgets.QDialogButtonBox.Cancel | QtWidgets.QDialogButtonBox.Ok)
        v_layout.addWidget(buttonbox)

        # Fill list of traces
        combobox.addItems(self._dbm.list_traces())

        buttonbox.accepted.connect(dlg.accept)
        buttonbox.rejected.connect(dlg.reject)

        dlg.exec()

        if dlg.result():
            return combobox.currentText()
        else:
            return None

```

`qsynthesis/tables/__init__.py`:

```py
from .lookuptablerest import InputOutputOracleREST
from .lookuptablelvldb import InputOutputOracleLevelDB
from .base import HashType

```

`qsynthesis/tables/base.py`:

```py
# built-in libs
from __future__ import annotations
from pathlib import Path
from enum import IntEnum
import array
import hashlib
import threading
from collections import Counter
from time import time, sleep
import ctypes
import logging

# third-party libs
import psutil

# qsynthesis deps
from qsynthesis.grammar import TritonGrammar
from qsynthesis.tritonast import TritonAst
from qsynthesis.types import AstNode, Hash, Optional, List, Dict, Union, Tuple, Iterable, Input, Output, BitSize, Any, \
                             Generator

logger = logging.getLogger("qsynthesis")


class HashType(IntEnum):
    """
    Hash types supported by the Lookup table database. In practice solely md5
    is used, has it is the fastest of all
    """
    RAW = 1
    FNV1A_128 = 2
    MD5 = 3


class _EvalCtx(object):
    """
    Small debugging Triton evaluation context. It is used when manipulating
    tables in a standalone manner. It enables obtaining TritonAst out of
    the databqse entries.
    """
    def __init__(self, grammar):
        from triton import TritonContext, ARCH, AST_REPRESENTATION
        # Create the context
        self.ctx = TritonContext(ARCH.X86_64)
        self.ctx.setAstRepresentationMode(AST_REPRESENTATION.PYTHON)
        self.ast = self.ctx.getAstContext()

        # Create symbolic variables for grammar variables
        self.symvars = {}
        self.vars = {}
        for v, sz in grammar.vars_dict.items():
            sym_v = self.ctx.newSymbolicVariable(sz, v)
            self.symvars[v] = sym_v
            self.vars[v] = self.ast.variable(sym_v)

        # Create mapping to triton operators
        self.tops = {x: getattr(self.ast, x) for x in dir(self.ast) if not x.startswith("__")}

    def eval_str(self, s: str) -> AstNode:
        """Eval the string expression to create an AstNode object"""
        e = eval(s, self.tops, self.vars)
        bv_size = list(self.vars.values())[0].getBitvectorSize()  # Assume all vars are of same size
        if isinstance(e, int):  # In case the expression was in fact an int
            return self.ast.bv(e, bv_size)
        else:
            return e

    def set_symvar_values(self, args: Input) -> None:
        for v_name, value in args.items():
            self.ctx.setConcreteVariableValue(self.symvars[v_name], value)


class InputOutputOracle:
    """
    Base Lookup table class. Specify the interface that child class have to
    implement to be interoperable with other the synthesizer.
    """
    def __init__(self, gr: TritonGrammar, inputs: List[Input], hash_mode: HashType = HashType.RAW, f_name: Union[Path, str] = ""):
        """
        Constructor making a I/O oracle from a grammar a set of inputs and an hash type.

        :param gr: triton grammar
        :param inputs: List of inputs
        :param hash_mode: type of hash to be used as keys in tables
        :param f_name: file name of the table (when being loaded)
        """
        self._name = Path(f_name)
        self.grammar = gr
        self._bitsize = self.grammar.size
        self.expr_cache = {}
        self.lookup_count = 0
        self.lookup_found = 0
        self.cache_hit = 0
        self.hash_mode = hash_mode
        self._ectx = None
        # generation related fields
        self.watchdog = None
        self.max_mem = 0
        self.stop = False

        self.inputs = inputs

    @property
    def size(self) -> int:
        """Size of the table (number of entries)

        :rtype: int
        """
        raise NotImplementedError("Should be implemented by child class")

    def _get_item(self, h: Hash) -> Optional[str]:
        """
        From a given hash return the associated expression string if
        found in the lookup table.

        :param h: hash of the item to get
        :returns: raw expression string if found
        """
        raise NotImplementedError("Should be implemented by child class")

    def is_expr_compatible(self, expr: TritonAst) -> bool:
        """
        Check the compatibility of the given expression with the table.
        The function checks sizes of expr variables against the one of
        its own grammar.

        :param expr: TritonAst expression to check
        :return: True if the table can decide on this expression
        """
        e_vars = Counter(x.getBitSize() for x in expr.symvars)
        e_table = Counter(self.grammar.vars_dict.values())
        for sz, count in e_vars.items():
            if sz in e_table:
                if count > e_table[sz]:
                    return False
            else:
                return False
        return True

    def lookup(self, outputs: List[Output], *args,  use_cache: bool = True) -> Optional[TritonAst]:
        """
        Perform a lookup in the table with a given set of outputs corresponding
        to the evaluation of an AST against the Input of this exact same table.
        If an entry is found a TritonAst is created and returned.

        :param outputs: list of output result of evaluating an ast against the inputs of this table
        :type: List[:py:obj:`qsynthesis.types.Output`]
        :param args: args forwarded to grammar and ultimately to the tritonAst in charge of building a new TritonAst
        :param use_cache: Boolean enabling caching the the hash of outputs. A second call if the same outputs
                          (which is common) will not trigger a lookup in the database
        :returns: optional TritonAst corresponding of the expression found in the table
        """
        self.lookup_count += 1
        h = self.hash(outputs)
        if h in self.expr_cache and use_cache:
            self.cache_hit += 1
            return self.expr_cache[h]
        else:
            v = self._get_item(h)
            if v:
                self.lookup_found += 1
                try:
                    e = self.grammar.str_to_expr(v, *args)
                    self.expr_cache[h] = e
                    return e
                except NameError:
                    return None
                except TypeError:
                    return None
            else:
                return None

    def lookup_hash(self, h: Hash) -> Optional[str]:
        """
        Raw lookup for a given key in database.

        :param h: hash key to look for in database
        :type h: :py:obj:`qsynthesis.types.Hash`
        :returns: string of the expression if found
        :rtype: Optional[str]
        """
        return self._get_item(h)

    @property
    def is_writable(self) -> bool:
        """ Whether the table enable being written (with new expressions)

        :rtype: bool
        """
        return False

    @property
    def name(self) -> str:
        """ Name of the table

        :rtype: str
        """
        return str(self._name)

    @property
    def bitsize(self) -> BitSize:
        """ Size of expression in bit

        :rtype: :py:obj:`qsynthesis.types.BitSize`
        """
        return self._bitsize

    @property
    def var_number(self) -> int:
        """ Maximum number of variables contained in the table

        :rtype: int
        """
        return len(self.grammar.vars)

    @property
    def operator_number(self) -> int:
        """ Number of operators used in this table

        :rtype: int
        """
        return len(self.grammar.ops)

    @property
    def input_number(self) -> int:
        """ Number of inputs used in this table

        :rtype: int
        """
        return len(self.inputs)

    @staticmethod
    def _fnv1a_128(outs: List[Output]) -> Hash:
        """
        Hash the outputs using fnv1a_128 algorithm

        :param outs: list of outputs to hash
        :type outs: List[:py:obj:`qsynthesis.types.Output`]
        :returns: Hash value (int) corresponding to the fnv1a of outputs
        :rtype: :py:obj:`qsynthesis.types.Hash`
        """
        a = array.array('Q', outs)
        FNV1A_128_OFFSET = 0x6c62272e07bb014262b821756295c58d
        FNV1A_128_PRIME = 0x1000000000000000000013b  # 2^88 + 2^8 + 0x3b

        # Set the offset basis
        hash = FNV1A_128_OFFSET

        # For each character
        for byte in a.tobytes():
            # Xor with the current character
            hash ^= byte
            # Multiply by prime
            hash *= FNV1A_128_PRIME
            # Clamp
            hash &= 0xffffffffffffffffffffffffffffffff
        # Return the final hash as a number
        return hash

    @staticmethod
    def _md5(outs: List[Output]) -> Hash:
        """
        Hash the outputs using MD5 algorithm. Outputs are transformed into an array.
        That means the final bytes hashed are the concatenation of uint64 in little
        endian.

        :param outs: list of outputs to hash
        :type outs: List[:py:obj:`qsynthesis.types.Output`]
        :returns: Bytes corresponding to MD5 hash
        :type: :py:obj:`qsynthesis.types.Hash`
        """
        a = array.array('Q', outs)
        h = hashlib.md5(a.tobytes())
        return h.digest()

    def hash(self, outs: List[Output]) -> Hash:
        """
        Main hashing method that dispatch the outputs to the appropriate hashing
        function depending on the ``hash_mode`` of the table.

        :param outs: list of outputs to hash
        :type outs: List[:py:obj:`qsynthesis.types.Output`]
        :returns: Hash type (bytes, int ..) of the outputs
        :rtype: :py:obj:`qsynthesis.types.Hash`
        """
        if self.hash_mode == HashType.RAW:
            return tuple(outs)
        elif self.hash_mode == HashType.FNV1A_128:
            return self._fnv1a_128(outs)
        elif self.hash_mode == HashType.MD5:
            return self._md5(outs)

    def __iter__(self) -> Iterable[Tuple[Hash, str]]:
        """ Iterator of all the entries as an iterator of pair, hash, expression as string

        :rtype: Iterable[Tuple[:py:obj:`qsynthesis.types.Hash, str]]`
        """
        raise NotImplementedError("Should be implemented by child class")

    def _get_expr(self, expr: str) -> AstNode:
        """
        Utility function that returns a TritonAst from a given expression string.
        A TritonContext local to the table is created to enable generating such ASTs.

        :param expr: Expression
        :returns: TritonAst resulting of the parsing of s
        """
        if self._ectx is None:
            self._ectx = _EvalCtx(self.grammar)
        return self._ectx.eval_str(expr)

    def _set_input_lcontext(self, i: Union[int, Input]) -> None:
        """
        Set the given concrete values of variables in the local TritonContext.
        The parameter is either the ith input of the table, or directly an Input
        given a valuation for each variables. This function must be called before
        performing any evaluation of an AST.

        :param i: index of the input, or Input object (dict)
        :returns: None
        """
        if self._ectx is None:
            self._ectx = _EvalCtx(self.grammar)
        self._ectx.set_symvar_values(self.inputs[i] if isinstance(i, int) else i)

    def _eval_expr_inputs(self, expr: AstNode) -> List[Output]:
        """
        Evaluate a given Triton AstNode object on all inputs of the
        table. The result is a list of Output values.

        :param expr: Triton AstNode to evaluate
        :type expr: :py:obj:`qsynthesis.types.AstNode`
        :returns: list of output values (ready to be hashed)
        :rtype: List[:py:obj:`qsynthesis.types.Output`]
        """
        outs = []
        for i in range(len(self.inputs)):
            self._set_input_lcontext(i)
            outs.append(expr.evaluate())
        return outs

    def _watchdog_worker(self, threshold: Union[float, int]) -> None:
        """
        Function where the memory watchdog thread is running. This function
        allows interrupting table generation when it happens to fill the
        given threshold of RAM.

        :param threshold: percentage of RAM load that triggers the stop of generation
        """
        while not self.stop:
            sleep(2)
            mem = psutil.virtual_memory()
            self.max_mem = max(mem.used, self.max_mem)
            if mem.percent >= threshold:
                logger.warning(f"Threshold reached: {mem.percent}%")
                self.stop = True  # Should stop self and also main thread

    @staticmethod
    def _try_linearize(s: str, symbols: Dict[str, object]) -> str:
        """
        Try applying sympy to linearize ``s`` with the variable symbols
        ``symbols``. If any exception is raised in between to expression
        string is returned unchanged.

        :param s: expression string to linearize
        :param symbols: dictionnary of variables names to sympy symbol objects

        .. warning:: This function requires sympy to be installed !
        """
        import sympy
        try:
            lin = eval(s, symbols)
            if isinstance(lin, sympy.boolalg.BooleanFalse):
                logger.error(f"[linearization] expression {s} False")
            logger.debug(f"[linearization] expression linearized {s} => {lin}")
            return str(lin).replace(" ", "")
        except TypeError:
            return s
        except AttributeError as _:
            return s

    @staticmethod
    def _to_signed(value: int) -> int:
        return ctypes.c_longlong(value).value

    @staticmethod
    def _to_unsigned(value: int) -> int:
        return ctypes.c_ulonglong(value).value

    @staticmethod
    def _is_constant(v1: str) -> bool:
        try:
            int(v1)
            return True
        except ValueError:
            return False

    @staticmethod
    def _custom_permutations(l: List[Any]) -> Generator[Tuple[bool, Any, Any], None, None]:
        """
        Custom generator generating all the possible tuples from a list. But instead
        of iterating item i with all others 0..n, iterates i with all the previous 0..i.
        It generates a somewhat sorted generated that ensure pairs of items appearing
        first in the list will be yielded before.

        :param l: list of any item
        :returns: genreator of tuples generating all possibles pairs
        """
        for i in range(len(l)):
            for j in range(0, i):
                yield False, l[i], l[j]
                yield False, l[j], l[i]
            yield True, l[i], l[i]

    def generate(self,
                 bitsize: int,
                 constants: List[int] = [],
                 do_watch: bool = False,
                 watchdog_threshold: Union[int, float] = 90,
                 linearize: bool = False,
                 do_use_blacklist: bool = False,
                 limit: int = 0) -> None:
        """
        Generate a new lookup table from scratch with the variables and operators
        set in the constructor of the table.

        :param bitsize: Bitsize of expressions to generate
        :param constants: List of constants to use in the generation
        :param do_watch: Enable RAM watching thread to monitor memory
        :param watchdog_threshold: threshold to be sent to the memory watchdog
        :param linearize: whether or not to apply linearization on expressions
        :param do_use_blacklist: enable blacklist mechanism on commutative operators. Slower but less memory consuming
        :param limit: Maximum number of entries to generate
        :returns: None
        """
        if do_watch:
            self.watchdog = threading.Thread(target=self._watchdog_worker, args=[watchdog_threshold], daemon=True)
            logger.debug("Start watchdog")
            self.watchdog.start()
        if linearize:
            logger.info("Linearization enabled")
            import sympy
            symbols = {x: sympy.symbols(x) for x in self.grammar.vars}
        t0 = time()

        from qsynthesis.grammar import jitting  # Import it locally to make sure pydffi is not mandatory
        CU = jitting.make_compilation_unit(bitsize)
        N = self.input_number
        ArTy = jitting.get_native_array_type(bitsize, N)

        hash_fun = lambda x: hashlib.md5(bytes(x)).digest() if self.hash_mode == HashType.MD5 else self.hash

        # Initialize worklist with variables
        worklist = [(ArTy(), k) for k in self.grammar.vars]
        for i, inp in enumerate(self.inputs):
            for v, k in worklist:
                v[i] = inp[k]

        # Initialize worklist with constants
        csts = [(ArTy(), str(c)) for c in constants]
        for (ar, c) in csts:
            jitting.init_array_cst(ar, int(c), N, bitsize)
        worklist.extend(csts)

        # initialize set of hash
        hash_set = set(hash_fun(x[0]) for x in worklist)

        ops = sorted(self.grammar.non_terminal_operators, key=lambda x: x.arity == 1)  # sort operators to iterate on unary first
        cur_depth = 2
        blacklist = set()
        item_count = len(worklist)  # total number of expressions

        try:
            while cur_depth > 0:
                # Start a new depth
                n_items = len(worklist)  # number of items to process at a given depth
                t = time() - t0
                print(f"Depth {cur_depth} (size:{n_items}) (Time:{int(t/60)}m{t%60:.5f}s)")
                c = 0

                for i, (same, (vals1, name1), (vals2, name2)) in enumerate(self._custom_permutations(worklist)):
                    if same:
                        c += 1
                        print(f"process: {(c*100)/n_items:.2f}%\r", end="")

                    if 0 < limit <= item_count:
                        self.stop = True

                    if self.stop:
                        logger.warning("Threshold reached, generation interrupted")
                        raise KeyboardInterrupt()

                    # Check it here once then iterate operators
                    name1_cst, name2_cst = self._is_constant(name1), self._is_constant(name2)
                    is_both_constant = name1_cst & name2_cst

                    for op, op_eval in zip(ops, [jitting.get_op_eval_array(CU, x) for x in ops]):  # Iterate over all operators
                        if op.arity == 1:
                            new_vals = ArTy()
                            op_eval(new_vals, vals1, N)

                            h = hash_fun(new_vals)
                            if h not in hash_set:
                                if name1_cst:
                                    fmt = str(self._to_signed(new_vals[0]))  # any value is the new constant value
                                else:
                                    fmt = f"{op.symbol}({name1})" if len(name1) > 1 else f"{op.symbol}{name1}"
                                fmt = self._try_linearize(fmt, symbols) if linearize else fmt
                                logger.debug(f"[add] {fmt: <20} {h}")
                                hash_set.add(h)
                                item_count += 1
                                worklist.append((new_vals, fmt))  # add it in worklist if not already in LUT
                            else:
                                logger.debug(f"[drop] {op.symbol}{name1}  ")

                        else:  # arity is 2
                            # for identity (a op a) ignore it if the result is known to be 0 or a
                            if same and (op.id_eq or op.id_zero):
                                continue

                            sn1 = f'{name1}' if len(name1) == 1 else f'({name1})'
                            sn2 = f'{name2}' if len(name2) == 1 else f'({name2})'
                            fmt = f"{op.symbol}({name1},{name2})" if op.is_prefix else f"{sn1}{op.symbol}{sn2}"

                            if not linearize:
                                if fmt in blacklist:  # Ignore expression if they are in the blacklist
                                    continue

                            new_vals = ArTy()

                            op_eval(new_vals, vals1, vals2, N)

                            if is_both_constant:  # if both were constant use the constant as repr instead
                                fmt = str(self._to_signed(new_vals[0]))

                            h = hash_fun(new_vals)
                            if h not in hash_set:
                                if linearize:
                                    fmt = self._try_linearize(fmt, symbols) if linearize else fmt
                                    if fmt in blacklist:  # if linearize check blacklist here
                                        continue

                                logger.debug(f"[add] {fmt: <20} {h}")
                                hash_set.add(h)
                                item_count += 1
                                worklist.append((new_vals, fmt))

                                if op.commutative and do_use_blacklist and not is_both_constant:
                                    fmt = f"{op.symbol}({name2},{name1})" if op.is_prefix else f"{sn2}{op.symbol}{sn1}"
                                    fmt = self._try_linearize(fmt, symbols) if linearize else fmt
                                    blacklist.add(fmt)  # blacklist commutative equivalent e.g for a+b blacklist: b+a
                                    logger.debug(f"[blacklist] {fmt}")
                            else:
                                logger.debug(f"[drop] {op.symbol}({name1},{name2})" if op.is_prefix else f"[drop] ({name1}){op.symbol}({name2})")

                cur_depth += 1
        except KeyboardInterrupt:
            logger.info("Stop required")
        # In the end
        self.stop = True
        t = time() - t0
        print(f"Depth {cur_depth} (size:{len(worklist)}) (Time:{int(t/60)}m{t%60:.5f}s) [RAM:{self.__size_to_str(self.max_mem)}]")
        self.add_entries(worklist, calc_hash=True)
        if do_watch:
            self.watchdog.join()

    def add_entry(self, hash: Hash, value: str) -> None:
        """
        Abstract function to add an entry in the lookuptable.

        :param hash: already computed hash to add
        :type Hash: :py:obj:`qsynthesis.types.Hash`
        :param value: expression value to add in the table
        :type value: str
        """
        raise NotImplementedError("Should be implemented by child class")

    def add_entries(self, worklist: List[Tuple[Hash, str]], calc_hash: bool = False) -> None:
        """
        Add the given list of entries in the database. The boolean ``calc_hash`` indicates
        whether hashes are already computed or not. If false the function should hash the
        hash first.

        :param worklist: list of entries to add
        :type worklist: List[Tuple[:py:obj:`qsynthesis.types.Hash`, str]]
        :param calc_hash: whether or not hash should be performed on entries keys
        :returns: None
        """
        raise NotImplementedError("Should be implemented by child class")

    @staticmethod
    def create(filename: Union[str, Path], grammar: TritonGrammar, inputs: List[Input], hash_mode: HashType = HashType.RAW, constants: List[int] = []) -> 'InputOutputOracle':
        """
        Create a new empty lookup table with the given initial parameters, grammars, inputs
        and hash_mode.

        :param filename: filename of the table to create
        :param grammar: TritonGrammar object representing variables and operators
        :param inputs: list of inputs on which to perform evaluation
        :type inputs: List[:py:obj:`qsynthesis.types.Input`]
        :param hash_mode: Hashing mode for keys
        :param constants: list of constants used
        :returns: lookuptable instance object
        """
        raise NotImplementedError("Should be implemented by child class")

    @staticmethod
    def load(file: Union[Path, str]) -> 'InputOutputOracle':
        """
        Load the given lookup table and returns an instance object.

        :param file: Database file to load
        :returns: InputOutputOracle object
        """
        raise NotImplementedError("Should be implemented by child class")

    @staticmethod
    def __size_to_str(value: int) -> str:
        """ Return pretty printed representation of RAM usage for table generation """
        units = [(float(1024), "Kb"), (float(1024 ** 2), "Mb"), (float(1024 ** 3), "Gb")]
        for unit, s in units[::-1]:
            if value / unit < 1:
                continue
            else:  # We are on the right unit
                return f"{value/unit:.2f}{s}"
        return f"{value}B"

```

`qsynthesis/tables/lookuptablelvldb.py`:

```py
# built-in libs
from pathlib import Path
import hashlib
import json

# third-party libs
import plyvel

# qsynthesis deps
from qsynthesis.grammar import TritonGrammar, BvOp
from qsynthesis.tables.base import InputOutputOracle, HashType
from qsynthesis.types import Optional, List, Union, Tuple, Iterator, Hash, Input


META_KEY = b"metadatas"
VARS_KEY = b"variables"
INPUTS_KEY = b"inputs"
SIZE_KEY = b"size"


class InputOutputOracleLevelDB(InputOutputOracle):
    """
    Key-Value store oracle database based on Google Level-DB
    """
    def __init__(self, grammar: TritonGrammar, inputs: List[Input], hash_mode: HashType = HashType.RAW, f_name: str = ""):
        """
        Constructor making a InputOutputOracleLevelDB from a grammar a set of inputs and an hash type.

        :param grammar: triton grammar
        :param inputs: List of inputs
        :param hash_mode: type of hash to be used as keys in tables
        :param f_name: file name of the table (when being loaded)
        """
        super(InputOutputOracleLevelDB, self).__init__(grammar, inputs, hash_mode, f_name)
        self.db = None

    @staticmethod
    def create(filename: Union[str, Path], grammar: TritonGrammar, inputs: List[Input], hash_mode: HashType = HashType.RAW, constants: List[int] = []) -> 'InputOutputOracleLevelDB':
        """
        Create a new empty lookup table with the given initial parameters, grammars, inputs
        and hash_mode.

        :param filename: filename of the table to create
        :param grammar: TritonGrammar object representing variables and operators
        :param inputs: list of inputs on which to perform evaluation
        :param hash_mode: Hashing mode for keys
        :param constants: list of constants used
        :returns: InputOutputOracleLevelDB instance object
        """
        # TODO: If it exists deleting it ?
        db = plyvel.DB(str(filename), create_if_missing=True)

        metas = dict(hash_mode=hash_mode.name, operators=[x.name for x in grammar.ops], constants=constants)
        db.put(META_KEY, json.dumps(metas).encode())
        db.put(VARS_KEY, json.dumps(grammar.vars_dict).encode())
        db.put(INPUTS_KEY, json.dumps(inputs).encode())
        lkp = InputOutputOracleLevelDB(grammar=grammar, inputs=inputs, hash_mode=hash_mode, f_name=filename)
        lkp.db = db
        return lkp

    @staticmethod
    def load(file: Union[Path, str]) -> 'InputOutputOracleLevelDB':
        """
        Load the given lookup table and returns an instance object.

        :param file: Database file to load
        :returns: InputOutputOracleLevelDB object
        """
        db = plyvel.DB(str(file))
        metas = json.loads(db.get(META_KEY))
        ops = [BvOp[x] for x in metas['operators']]
        vrs = list(json.loads(db.get(VARS_KEY)).items())
        inps = json.loads(db.get(INPUTS_KEY))
        grammar = TritonGrammar(vars=vrs, ops=ops)
        lkp = InputOutputOracleLevelDB(grammar=grammar, inputs=inps, hash_mode=HashType[metas['hash_mode']], f_name=file)
        lkp.db = db
        return lkp

    def add_entry(self, hash: Hash, value: str) -> None:
        """
        Put the given hash and value in the leveldb trie.

        :param hash: already computed hash to add
        :param value: expression value to add in the table
        """
        self.db.put(hash, value.encode())
        self.db.put(SIZE_KEY, (str(int(self.db.get(SIZE_KEY))+1)).encode())

    def add_entries(self, entries: List[Tuple[Hash, str]], calc_hash: bool = False, chunk_size: int = 10000, update_count: bool = True) -> None:
        """
        Add the given list of entries in the database. The boolean ``calc_hash`` indicates
        whether hashes are already computed or not. If false the function should hash the
        hash first.

        :param entries: list of entries to add
        :param calc_hash: whether or not hash should be performed on entries keys
        :param chunk_size: size of a chunk for bulk insert in DB
        :param update_count: whether or not to update the count of entries in DB
        :returns: None
        """
        count = len(entries)

        def do_hash(x):
            return x if not calc_hash else (hashlib.md5(bytes(x)).digest() if self.hash_mode == HashType.MD5 else self.hash)

        for step in range(0, count, chunk_size):
            with self.db.write_batch(sync=True) as wb:
                for outs, s in entries[step:step+chunk_size]:
                    wb.put(do_hash(outs), s.encode())
        if update_count:
            cur_count = self.db.get(SIZE_KEY)
            new_count = count if cur_count is None else int(cur_count)+count
            self.db.put(SIZE_KEY, str(new_count).encode())

    def __iter__(self) -> Iterator[Tuple[Hash, str]]:
        """ Iterator of all the entries as an iterator of pair, hash, expression as string """
        for key, value in self.db:
            if key not in [META_KEY, VARS_KEY, INPUTS_KEY, SIZE_KEY]:
                yield key, value.decode()

    @property
    def is_writable(self) -> bool:
        """
        Whether the table enable being written (with new expressions)
        Level-db tables are considered to be always writable
        """
        return True

    @property
    def size(self) -> int:
        """Size of the table (number of entries)"""
        return int(self.db.get(SIZE_KEY))

    def _get_item(self, h: Hash) -> Optional[str]:
        """
        From a given hash return the associated expression string if
        found in the lookup table.

        :param h: hash of the item to get
        :returns: raw expression string if found
        """
        entry = self.db.get(h)
        return entry.decode() if entry else None

```

`qsynthesis/tables/lookuptablerest.py`:

```py
# built-in libs
from pathlib import Path
import binascii

# third-party libs
import requests

# qsynthesis deps
from qsynthesis.grammar import TritonGrammar
from qsynthesis.tables.base import InputOutputOracle, HashType, Hash
from qsynthesis.types import Input, Optional, List, Dict, Union, Tuple, Iterator


class InputOutputOracleREST(InputOutputOracle):
    """
    REST-based lookup table. The table given in parameter is meant to be an IP
    address serving the API (that can be served with qsynthesis-table-manager runserver)
    """

    def __init__(self, grammar: TritonGrammar, inputs: List[Input], hash_mode: HashType = HashType.RAW, f_name: str = ""):
        """
        Constructor making a lookuptable from a grammar a set of inputs and an hash type.

        :param grammar: triton grammar
        :param inputs: List of inputs
        :param hash_mode: type of hash to be used as keys in tables
        :param f_name: file name of the table (when being loaded)
        """
        super(InputOutputOracleREST, self).__init__(grammar, inputs, hash_mode, f_name)
        self.session = requests.Session()
        self._size = 0

    @staticmethod
    def create(filename: Union[str, Path], grammar: TritonGrammar, inputs: List[Input], hash_mode: HashType = HashType.RAW, constants: List[int] = []) -> 'InputOutputOracleREST':
        """
        Such tables cannot be created as they are read-only databases.
        """
        raise RuntimeError("REST Lookup tables cannot be created only loaded")

    @staticmethod
    def load(file: Union[Path, str]) -> 'InputOutputOracleREST':
        """
        Load a given table. The function perform a request to retrieve alll
        the basic informations about the table (size, grammar, inputs etc..)
        and to create a completely transparent table.
        """
        res = requests.get(file)
        if res.status_code == 200:
            data = res.json()
            g = TritonGrammar.from_dict(data['grammar'])
            lkp = InputOutputOracleREST(g, data['inputs'], HashType[data['hash_mode']], file)
            lkp._size = data["size"]
            lkp.session.headers['Host'] = file
            lkp._name = file
            return lkp
        else:
            raise ConnectionAbortedError(f"Cannot reach remote server (code:{res.status_code})")

    def add_entry(self, hash: Hash, value: str):
        """
        Function not implemented at the moment. No new expressions can be
        submitted at the moment.
        """
        raise NotImplementedError("REST Lookup Table are read-only at the moment")

    def add_entries(self, entries: List[Tuple[Hash, str]], calc_hash: bool = False, chunk_size: int = 10000) -> None:
        """
        Function not implemented at the moment. REST tables are read-only.
        """
        raise NotImplementedError("REST Lookup tables are read-only at the moment")

    def __iter__(self) -> Iterator[Tuple[Hash, str]]:
        """
        Iterating over all elements of the table is not implemented either.
        """
        raise NotImplementedError("Entries iteration is not implemented")

    @property
    def size(self) -> int:
        """Size of the table (number of entries)"""
        return self._size

    def _get_item(self, h: Hash) -> Optional[str]:
        """
        From a given hash return the associated expression string if found in
        the lookup table through a GET request.

        :param h: hash of the item to get
        :returns: raw expression string if found
        """
        hex_hash = binascii.hexlify(h).decode()
        res = self.session.get(str(self.name) + "/entry/" + hex_hash)
        if res.status_code == 200:
            data = res.json()
            return data['expression'] if data else None
        else:
            raise ConnectionError("REST query did not suceeded correctly")

```

`qsynthesis/tritonast.py`:

```py
# Standard modules
from __future__ import annotations
from enum import IntEnum
import random
from functools import reduce
import logging

# Third-party modules
from triton import TritonContext, AST_NODE, SYMBOLIC, ARCH

# QSynthesis imports
from qsynthesis.types import AstNode, List, Tuple, Generator, Dict, Union, Optional, AstType, SymVarMap, \
                             SymbolicVariable, Char, IOVector, Input, Output


logger = logging.getLogger('qsynthesis')


class ReassemblyError(Exception):
    """
    Wrapping exception for all exceptions that might be raised during the
    reassembly process.
    """
    pass


class SymVarType(IntEnum):
    """
    Enum representing the different types of SymbolicVariables of Triton
    """
    REGISTER = SYMBOLIC.REGISTER_VARIABLE
    MEMORY = SYMBOLIC.MEMORY_VARIABLE


op_str = {AST_NODE.ANY: "any", AST_NODE.ASSERT: "assert", AST_NODE.BV: "bv", AST_NODE.BVADD: "+",
          AST_NODE.BVAND: "&", AST_NODE.BVASHR: "bvashr", AST_NODE.BVLSHR: "bvlshr", AST_NODE.BVMUL: "*",
          AST_NODE.BVNAND: "bvnand", AST_NODE.BVNEG: "-", AST_NODE.BVNOR: "bvnor", AST_NODE.BVNOT: "not",
          AST_NODE.BVOR: "|", AST_NODE.BVROL: "bvrol", AST_NODE.BVROR: "bvror", AST_NODE.BVSDIV: "bvsdiv",
          AST_NODE.BVSGE: ">=s", AST_NODE.BVSGT: ">s", AST_NODE.BVSHL: "<<", AST_NODE.BVSLE: "<=s",
          AST_NODE.BVSLT: "<s", AST_NODE.BVSMOD: "bvsmod", AST_NODE.BVSREM: "bvsrem", AST_NODE.BVSUB: "-",
          AST_NODE.BVUDIV: "bvudiv", AST_NODE.BVUGE: ">=u", AST_NODE.BVUGT: ">u", AST_NODE.BVULE: "<=u",
          AST_NODE.BVULT: "<u", AST_NODE.BVUREM: "bvurem", AST_NODE.BVXNOR: "bvxnor", AST_NODE.BVXOR: "^",
          AST_NODE.COMPOUND: "compound", AST_NODE.CONCAT: "concat", AST_NODE.DECLARE: "declare", AST_NODE.DISTINCT: "distinct",
          AST_NODE.EQUAL: "=", AST_NODE.EXTRACT: "extract", AST_NODE.FORALL: "forall", AST_NODE.IFF: "iff",
          AST_NODE.INTEGER: "integer", AST_NODE.ITE: "ite", AST_NODE.LAND: "land", AST_NODE.LET: "let",
          AST_NODE.LNOT: "lnot", AST_NODE.LOR: "lor", AST_NODE.REFERENCE: "reference", AST_NODE.STRING: "string",
          AST_NODE.SX: "sx", AST_NODE.VARIABLE: "variable", AST_NODE.ZX: "zx"}


class TritonAst:
    """
    Wrapping class on top of Triton AstNode objects. This is the main entity manipulated
    throughout the synthesis process. It provides many utility fonctions on these ASTs
    like :attr:`TritonAst.node_count` holding the number of node of the AST, or
    :meth:`TritonAst.reassembly` that allows reassembling the AST into assembly.


    """

    def __init__(self, ctx: TritonContext, node: AstNode, node_c: int, depth: int, vars: SymVarMap, children: List['TritonAst']) -> 'TritonAst':
        """
        Instanciate a TritonAst with some precomputed fields given in parameters.

        :param ctx: Triton context
        :type ctx: `TritonContext <https://triton.quarkslab.com/documentation/doxygen/py_TritonContext_page.html>`_
        :param node: Triton AstNode to wrap
        :type node: :py:obj:`qsynthesis.types.AstNode`
        :param node_c: Number of nodes contained in the expression
        :type node_c: int
        :param depth: Depth of the expression (depth of the AST)
        :type depth: int
        :param vars: Variables contained in this expression
        :type vars: Dict[str, :py:obj:`qsynthesis.types.SymbolicVariable`]
        :param children: List of children as TritonAst instances
        :type children: List[TritonAst]

        .. warning:: This class is not meant to be instanciated directly. It must be instanciated
             trough the :meth:`~TritonAst.make_ast` method.
        """
        self.ctx = ctx
        self.ast = self.ctx.getAstContext()
        self.expr = node  # It needs to be unrolled !!!
        self.size = self.expr.getBitvectorSize()
        self._symvars = vars  # SymVarName -> SymbolicVariable object  e.g: {'SymVar_1': rdi, 'SymVar_2': rsi}
        self._mapping = {chr(x[0]): x[1] for x in zip(range(97, 127), self._symvars.values())}  # {'a': SymVar, 'b': SymVar}
        self._parents = set()

        self._node_count = node_c
        self._depth = depth
        self._children = children

    @property
    def parents(self) -> List['TritonAst']:
        """
        Return the list of parents of a given AST. An AST is meant to have only
        ONE parent but Triton share common expression with multiple parents (wihtin
        the same expression)

        :rtype: List[TritonAst]
        """
        return list(self._parents)

    @property
    def mapping(self) -> Dict[Char, SymbolicVariable]:
        """
        Mapping a placeholder character ('a', 'b', 'c' ..) to all the SymbolicVariable
        of the object.

        :rtype: Dict[:py:obj:`qsynthesis.types.Char`, :py:obj:`SymbolicVariable`]
        """
        return self._mapping

    @mapping.setter
    def mapping(self, value: Dict[Char, SymbolicVariable]) -> None:
        """
        Set the given mapping of placeholder to their SymbolicVariable in the object.
        """
        self._mapping = value

    @property
    def sub_map(self) -> Dict[Char, AstNode]:
        """
        Similar to mapping but map a placeholder character ('a', 'b', 'c' ..) to
        the AstNode counterpart of SymbolicVariables.

        :rtype: Dict[:py:obj:`qsynthesis.types.Char`, :py:obj:`qsynthesis.types.AstNode`]
        """
        return {k: self.ast.variable(v) for k, v in self.mapping.items()}

    @property
    def type(self) -> AstType:
        """
        Returns the type of current AstNode object. The
        type is identical to the AST_NODE enum of Triton.

        :rtype: :py:obj:`qsynthesis.types.AstType`
        """
        return AstType(self.expr.getType())

    @property
    def hash(self) -> int:
        """
        Returns the Triton hash of the AstNode. This hash is meant to be unique
        for all AstNode, but is also meant to be similar to commutative expressions.

        :rtype: int
        """
        return self.expr.getHash()

    @property
    def ptr_id(self) -> int:
        """
        Returns the hash of the AstNode object. This attribute is meant to differentiate
        to different python object have the exact same AST structure.

        :rtype: int
        """
        return hash(self.expr)

    def is_constant_expr(self) -> bool:
        """Returns whether the AST expression is constant or not (namely does not
        have any symbolic variables in it)."""
        return len(self.symvars) == 0

    def is_variable(self) -> bool:
        """Returns of the TritonAst is a variable node."""
        return self.type == AstType.VARIABLE

    def is_constant(self) -> bool:
        """Returns True if the type of the object is Bitvector (namely constant)"""
        return self.type == AstType.BV

    @property
    def variable_id(self) -> int:
        """
        Get the Triton unique id for a variable.

        :raises: KeyError
        """
        if self.is_variable():
            return self.expr.getSymbolicVariable().getId()
        else:
            raise KeyError("not a variable")

    @property
    def var_num(self) -> int:
        """Returns the number of different symbolic variables of the expression

        :rtype: int
        """
        return len(self._symvars)

    @property
    def pp_str(self) -> str:
        """Hacky function that strips masks used in the AST_REPRESENTATION.PYTHON
        of Triton.

        :rtype: str
        """
        return str(self.expr).replace(" & 0xFFFFFFFFFFFFFFFF", "").replace(" & 0xffffffffffffffff", "")


    def visit_expr(self) -> Generator['TritonAst', None, None]:
        """ Pre-Order visit of all the sub-AstNode"""
        def rec(e):
            yield e
            for c in e.get_children():
                yield from rec(c)
        yield from rec(self)

    @property
    def symvars(self) -> List[SymbolicVariable]:
        """Returns the list of SymbolicVariable object of the current object

        :rtype: List[:py:obj:`qsynthesis.types.SymbolicVariable`]
        """
        return list(self._symvars.values())

    @staticmethod
    def symvar_type(v: SymbolicVariable) -> SymVarType:
        """
        Static method returning the type of a given symbolic variable object

        :param v: symbolic variable object
        :type v: :py:obj:`qsynthesis.types.SymbolicVariable`
        :return: Type of the symbolic variables
        :rtype: :py:obj:`qsynthesis.types.SymVarType`
        """
        return SymVarType(v.getType())

    def get_children(self) -> List['TritonAst']:
        """Return the list of children TritonAst"""
        return self._children

    def has_children(self) -> bool:
        """True whether the object has children or not"""
        return self.get_children() != []

    def is_root(self) -> bool:
        """
        Return True whether the object is a root node (namely does not have
        any parents).
        """
        return not(bool(self.parents))

    def is_leaf(self) -> bool:
        """True if the AST has no children"""
        return self.get_children() == []

    @property
    def node_count(self) -> int:
        """Pre-computed O(1) count of the number of node contained in this AST.

        :rtype: int
        """
        return self._node_count

    @property
    def depth(self) -> int:
        """Pre-computed depth of the AST *(complexity O(1))*

        :rtype: int
        """
        return self._depth

    @property
    def symbol(self) -> str:
        """Returns the symbol of the current AstNode, operator if binary expression
        variable name if variable or constant value if constant.

        :rtype: str
        """
        t = self.type
        if t in [AstType.BV, AstType.VARIABLE]:
            return str(self.expr)
        elif t == AstType.INTEGER:
            return str(self.expr.getInteger())
        else:
            return op_str[t]

    def mk_constant(self, v: int, size: int) -> 'TritonAst':
        """Create a new constant as a TritonAst (holding a Triton bv object)."""
        return TritonAst(self.ctx, self.ast.bv(v, size), 1, 1, {}, [])

    def mk_variable(self, alias: str, size: int) -> 'TritonAst':
        """
        Create a new variable node as a TritonAst (holding a Triton variable object).
        The variable is created in the TritonContext of the current object.
        """
        s = self.ctx.newSymbolicVariable(size, alias)
        s.setAlias(alias)
        ast_s = self.ast.variable(s)
        return TritonAst(self.ctx, ast_s, 1, 1, {s.getName(): s}, [])

    def normalized_str_to_ast(self, s: str) -> 'TritonAst':
        """
        Evaluate expression like "a + b - 1" creating a triton AST expression out
        of it. All variables have to be present in the AST.

        :param s: expression to evaluate
        :return: Triton AST node of the expression

        .. warning:: the str expr must be obtained through the eval_oracle of the
                     exact same TritonAst (otherwise names would be shuffled)
        """
        try:
            e = eval(s, self.sub_map)
        except NameError as e:
            logger.warning(f"Expression {s} evaluation failed {self.sub_map}")
            raise e
        except TypeError as exc:
            logger.error(f"Type error when evaluating: {s}")
            # Try mangling expressions
            nast = self._try_mangle_ast(s, exc)
            if nast:
                return nast
            else:
                raise exc
        ast = self.make_ast(self.ctx, e)
        return ast

    def _try_mangle_ast(self, s: str, e: Exception) -> Optional['TritonAst']:
        """
        Hacky function to mangle expression like 'a**2' generated by sympy.
        Triton AST and SMT does not support pow operators thus they have to
        be unrolled. This function tries to do it and if succeed try to generate
        an AST out of it.

        :param s: expression to evaluate
        :return: Triton AST node of the expression
        """
        logger.warning(f"Try mangling {s}: {str(e)}")
        import re
        mod = False
        s2 = s
        if str(e) == "unsupported operand type(s) for ** or pow(): 'AstNode' and 'int'":
            for c, v in re.findall("([^\(*]+)\*\*(\d+)", s):
                sub_c = c
                trail = ""
                if c.count("(") != c.count(")") and c.endswith(")"):
                    sub_c = sub_c[:-1]
                    trail = ")"
                # logger.info(f"Found instance {c} with {v}")
                mod = True
                s2 = re.sub(re.escape(c+"**"+v), '*'.join([f"({sub_c})"]*int(v))+trail, s2)
            logger.warning(f"Mangle expr {s} to {s2}")
        if mod and s2 != s:
            return self.normalized_str_to_ast(s2)
        else:
            return None

    def to_normalized_str(self) -> str:
        """
        Normalize the AST (replace variables by placeholder 'a', 'b' ..) and return
        it as a string.
        """
        back = {}
        for name, ast_v in self.sub_map.items():  # Substitute aliases with the normalized names
            sym_v = ast_v.getSymbolicVariable()
            back[name] = sym_v.getAlias()
            sym_v.setAlias(name)
        final_s = self.pp_str  # FIXME: Make a proper iteration of the expression to generate something compliant with lookup tables
        for name, ast_v in self.sub_map.items():  # Restore true aliases
            sym_v = ast_v.getSymbolicVariable()
            sym_v.setAlias(back[name])
        return final_s

    def update_all(self) -> None:
        """
        Update all children recursively of the current object. Fields being updated
        are node_count, depth and symvars. This might be used when some of the AST
        has been rewritten. All pre-computed values are then 'dirty' and have to be
        updated.
        """
        def rec(a):
            chs = [rec(x) for x in a.get_children()]
            if chs:  # one of their child might have been updated so update
                a.update()
                return a
            else:
                return a
        rec(self)

    def update(self) -> None:
        """
        Update the current AST node, with information of its directly children.
        Information of children are thus considered genuine.
        """
        chs = self.get_children()
        if chs:
            self._symvars = reduce(lambda acc, x: dict(acc, **x._symvars), chs, {})
            self._depth = max((x.depth for x in chs), default=0)+1
            self._node_count = sum(x.node_count for x in chs)+1

    def update_parents(self, recursive: bool = True) -> None:
        """
        Update the parent of the current TritonAst. `recursive` indicates
        if it has to be performed recrusively. If so the complexity of the
        operation O(depth).
        :param recursive: whether to apply it recursively on parents
        """
        for p in self.parents:
            p.update()
        if recursive:
            for p in self.parents:
                p.update_parents(recursive=recursive)

    def set_child(self, i: int, ast: 'TritonAst', update_node: bool = True, update_parents: bool = False) -> None:
        """
        Replace the ith child of the current TritonAst with new given ast object. Optional
        parameters indicates if inner fields of the object and its parent have to be updated.

        :param i: index of the child to replace
        :param ast: TritonAst to be used as replacement of the child
        :param update_node: whether to update internal field of the current node (node_count, depth, symvars)
        :param update_parents: whether to update parents
        """
        if isinstance(i, TritonAst):
            i = {c: i for i, c in enumerate(self.get_children())}[i]  # retrieve number from instance
        if update_node:
            if not self.expr.setChild(i, ast.expr):
                assert False
        self._children[i] = ast  # implicitely unlink previous ast and replace it by the new
        ast._parents.add(self)   # add self as parent of the new ast
        self.update()            # update its own fields
        if update_parents:
            self.update_parents()

    def replace_self(self, repl: 'TritonAst', update_parents: bool = True) -> None:
        """
        Replace the current object by the given TritonAst. This function thus replace
        parents by replace the child that correspond to the current object by the replacement.
        :param repl: TritonAst used to replace the current object
        :param update_parents: whether to update parents or not
        """
        if len(self.parents):
            logger.debug("replace self while multiple parents !")
        is_first = True
        for p in self.parents:
            p.set_child(self, repl, update_node=is_first, update_parents=update_parents)
            self._parents.remove(p)  # remove its own parent
            # is_first = False

    @staticmethod
    def make_ast(ctx: TritonContext, exp: AstNode) -> 'TritonAst':
        """
        Main staticmethod meant to create all TritonAst object. This method iterates
        all the given expression ``expr`` recursively to create TritonAst's
        all the way down and pre-computing along the way the important fields like
        node_count, depth and symvars.

        :param ctx: Triton context on which to work on
        :param exp: AstNode object to iterate
        :returns: TritonAst instance wrapping the exp object
        """
        ptr_map = {}  # hash -> TritonAst

        def rec(e):
            h = hash(e)
            if h in ptr_map:  # if the pointer as already been seen
                return ptr_map[h]  # return it early
            typ = e.getType()
            if typ == AST_NODE.REFERENCE:
                return rec(e.getSymbolicExpression().getAst())
            elif typ == AST_NODE.BV:
                t = TritonAst(ctx, e, 1, 1, {}, [])
            elif typ == AST_NODE.INTEGER:
                t = TritonAst(ctx, e, 1, 1, {}, [])
            elif typ == AST_NODE.VARIABLE:
                symvar = e.getSymbolicVariable()
                name = symvar.getName()
                t = TritonAst(ctx, e, 1, 1, {name: symvar}, [])
            else:
                chs, symvs, node_c = [], {}, 1
                for ast_child in e.getChildren():
                    c = rec(ast_child)
                    symvs.update(c._symvars)
                    node_c += c.node_count
                    chs.append(c)
                depth = max(c.depth for c in chs)+1
                t = TritonAst(ctx, e, node_c, depth, symvs, chs)
                for c in chs:
                    c._parents.add(t)
            ptr_map[hash(e)] = t
            return t
        return rec(exp)

    def duplicate(self) -> 'TritonAst':
        """
        Create a new distinct instance of TritonAst
        """
        new_expr = self.ast.duplicate(self.expr)
        return TritonAst.make_ast(self.ctx, new_expr)

    def random_sampling(self, n: int) -> IOVector:
        """
        Generates a random list of I/O samples pair.

        :param n: number of samples to generate
        :return: a list of n (inputs, output) tuples
        :rtype: :py:obj:`qsynthesis.types.IOVector`
        """
        samples = []

        for _ in range(n):
            inputs = {k: random.getrandbits(v.getBitvectorSize()) for k, v in self.sub_map.items()}
            output = self.eval_oracle(inputs)
            samples.append((inputs, output))
        return samples

    def eval_oracle(self, inp: Input) -> Output:
        """
        Oracle corresponding to the wrapped AST. It takes a valuation for all its
        symbolic variables and as an oracle returns the associated output.

        :param inp: a mapping of variable to a given input value which will be used
                    as concrete values for the symbolic variables in the wrapped AST
        :type inp: :py:obj:`qsynthesis.types.Input`
        :return: The result computed by means of evaluating the AST
        :rtype: :py:obj:`qsynthesis.types.Output`
        """
        for v_name, symvar in self.mapping.items():
            self.ctx.setConcreteVariableValue(symvar, inp[v_name])
        return self.expr.evaluate()

    def compare_behavior(self, ast: TritonAst, inps: List[Input]) -> int:
        """
        Compare the current expression with the one given in parameter wrt theirs
        behavior on the given set of inputs. The comparison returns -1 if not applicable
        (as involving different variables, 0 if different and 1 if equal.

        :param ast: other ast to compare against
        :param inps: Set of inputs to use for evaluation
        :return: -1 if not applicable, 0 if different and 1 if equal
        :rtype: int
        """
        if set(x.getAlias() for x in self.mapping.values()).symmetric_difference(set(x.getAlias() for x in ast.mapping.values())):
            return -1  # Some variables are different
        backup = self.mapping
        print([self.eval_oracle(i) for i in inps])
        rev = {v.getAlias(): k for k, v in ast.mapping.items()}  # Map name -> pld   e.g: {'rsi': 'a', 'rdi': 'b'}
        self.mapping = {rev[vs.getAlias()]: vs for pld, vs in self.mapping.items()}  # keep own vars (vs) but remap on other ast identifier
        print(backup, self.mapping)
        tmp1 = [self.eval_oracle(i) for i in inps]
        tmp2 = [ast.eval_oracle(i) for i in inps]
        print(tmp1, "\n", tmp2)
        res = tmp1 == tmp2
        self.mapping = backup  # Restore backup submap
        return res

    def to_z3(self) -> 'z3.z3.ExprRef':
        """Returns the Z3 expression associated with the Triton AST expression"""
        return self.ast.tritonToZ3(self.expr)

    @staticmethod
    def from_z3(ctx: TritonContext, expr: 'z3.z3.ExprRef') -> 'TritonAst':
        """
        Create a TritonAst out of a Z3 expressions

        :param ctx: Triton Context in which to create the expression
        :param expr: Z3 expression
        :return: TritonAst

        .. warning:: This function is mostly untested !
        """
        astctx = ctx.getAstContext()
        ast = astctx.z3ToTriton(expr)
        return TritonAst.make_ast(ctx, ast)

    def is_semantically_equal(self, other: 'TritonAst') -> bool:
        """
        Allows checking if the current AST is semantically equal to the one provided.

        :param other: TritonAst on which to test against
        :returns: bool -- True if both ASTs are semantically equals
        """
        cst = self.ast.distinct(self.expr, other.expr)
        return not(self.ctx.isSat(cst))

    @staticmethod
    def dyn_node_count(expr: AstNode) -> int:
        """
        Returns the effective count of node of the expression by iterating the
        AstNode object recursively. The complexity is O(N) with N the number of node.

        :param expr: AstNode to iterate
        :type expr: :py:obj:`qsynthesis.types.AstNode`
        :returns: Number of nodes in the AST.

        .. note:: The way of counting nodes is different from the number of nodes of
                  Triton for which bitvector values are composed of 3 nodes. We count
                  them as one.
        """
        def rec(e):
            typ = e.getType()
            if typ == AST_NODE.REFERENCE:
                return rec(e.getSymbolicExpression().getAst())
            elif typ == AST_NODE.BV:
                return 1  # prevent counting BV childs as nodes
            else:
                return 1+sum(map(rec, e.getChildren()))
        return rec(expr)

    @staticmethod
    def dyn_depth(expr: AstNode) -> int:
        """
        Returns the effective depth of the node of the expression by iterating the
        AstNode object recursively. The complexity is O(N) with N the depth of the AST.

        :param expr: AstNode to iterate
        :type expr: :py:obj:`qsynthesis.types.AstNode`
        :returns: AST depth
        """
        def rec(e):
            typ = e.getType()
            if typ == AST_NODE.REFERENCE:
                return rec(e.getSymbolicExpression().getAst())
            elif typ == AST_NODE.BV:
                return 1  # prevent couting BV childs as nodes
            else:
                return 1+max(map(rec, e.getChildren()), default=0)
        return rec(expr)

    @staticmethod
    def _visit_replacement(ast: 'TritonAst') -> Generator[Union['TritonAst', Tuple['TritonAst', bool]], 'TritonAst', None]:
        rep = yield ast  # First (Top-Down yield)

        if rep is not None:  # We should replace this expr
            yield rep, True  # Final (yield)
        else:
            rep_took_place = False
            for i, c in enumerate(ast.get_children()):  # Iterate (and simplify) all childrens
                g = TritonAst._visit_replacement(c)
                recv = None
                while 1:
                    it = g.send(recv)  # forward the new expression to the sub-generator
                    if isinstance(it, tuple):  # is a final yield
                        if it[1]:  # A replacement took place
                            rep_took_place = True
                            ast.set_child(i, it[0])
                        break
                    else:
                        recv = yield it  # re-yield it above (and receive a new expression)
            yield ast, rep_took_place

    def _inplace_replace(self, other: 'TritonAst') -> None:
        logger.debug("Inplace replace")
        self.ctx, self.ast = other.ctx, other.ast
        self.expr = other.expr
        self.size = other.size
        self._symvars = other._symvars
        self._parents = other._parents
        self._node_count, self._depth = other._node_count, other._depth
        self._children = other._children

    def visit_replacement(self, update: bool = True) -> Generator['TritonAst', 'TritonAst', None]:
        """
        Triton AST expression replacement visitor in a Top-Down manner. It yields
        every sub-expression and replace it with the expression received throught
        the send mechanism.

        :param update: whether to update each node after having been replaced
        :return: generator of TritonAst, which for each AST yielded wait to
                 receive either None meaning the it should not be replaced or a new
                 TritonAst to be put in replacement.
        """
        v = self._visit_replacement(self)
        new_expr_to_send = None
        while True:
            cur_expr = v.send(new_expr_to_send)
            if isinstance(cur_expr, tuple):
                if update:
                    self.update_all()
                break
            else:
                new_expr_to_send = yield cur_expr
                if new_expr_to_send is not None and cur_expr == self:  # Changing root node so fusion fields and return
                    self._inplace_replace(new_expr_to_send)
                    return

    def reassemble(self, dst_reg: str, target_arch: Optional[str] = None) -> bytes:
        """
        Reassemble the TritonAst in assembly. ``dst_reg`` is the destination register of the
        result of the computation of the AST. Parameter ``target_arch`` is either a QtraceDB
        architecture object or the string identifier of the architecture as defined by the
        LLVM architecture triple: https://llvm.org/doxygen/classllvm_1_1Triple.html#a547abd13f7a3c063aa72c8192a868154
        If no architecture is provided, use the same than the one that the AST.

        :param dst_reg: destination register as lowercase string
        :param target_arch: target architecture in which to reassemble the AST
        :returns: bytes of the AST reassembled in the given architecture
        :raises: ReassemblyError

        .. warning:: This method requires the ``arybo`` library that can be installed with
           (pip3 install arybo).
        """
        def my_asm_binary(arybo_expr, dst_regs, inps, target):
            # FIXME: ``asm_binary`` of arybo is broken as it used the function
            # ObjectFileRef of llvmlite which is itself broken. Up until a fix
            # is pushed I have to reimplement asm_binary and retrieve bytes with
            # lief. cf: https://github.com/numba/llvmlite/issues/632
            mod = asm_module(arybo_expr, dst_regs, inps, target)
            M = llvm.parse_assembly(str(mod))
            M.verify()
            target = llvm_get_target(target)
            machine = target.create_target_machine()
            obj_bin = machine.emit_object(M)
            p = lief.parse(obj_bin)
            return bytes(p.get_section('.text').content)
        try:
            import lief
            from arybo.tools.triton_ import tritonast2arybo
            from arybo.lib.exprs_asm import asm_binary, asm_module, llvm, llvm_get_target
            if all(TritonAst.symvar_type(x) == SymVarType.REGISTER for x in self.symvars):
                if target_arch is None:
                    m = {ARCH.X86: "x86", ARCH.X86_64: "x86_64", ARCH.ARM32: "arm", ARCH.AARCH64: "aarch64"}
                    arch_name = m[self.ctx.getArchitecture()]
                else:
                    arch_name = target_arch.lower()
                arybo_expr = tritonast2arybo(self.expr, use_exprs=True, use_esf=False)
                inps = {x.getName(): (x.getAlias(), x.getBitSize()) for x in self.symvars}
                return my_asm_binary(arybo_expr, (dst_reg, self.size), inps, f"{arch_name}-unknown-unknwon")
            else:
                raise ReassemblyError("Can only reassemble if variable are registers (at the moment)")
        except ImportError as e:
            raise ReassemblyError(f"Cannot import arybo, while it is required (pip3 install arybo): {e}")
        except NameError:
            raise ReassemblyError(f"Invalid target architecture '{target_arch}' provided")
        except Exception as e:
            raise ReassemblyError(f"Something went wrong during reassembly: {e}")

    def make_graph(self) -> 'Graph':
        """
        Generate a graph object representing the AST
        as a graph_tool object.

        .. warning:: This method requires the ``graph_tool`` python library that can be installed
           by following `https://git.skewed.de/count0/graph-tool/-/wikis/installation-instructions`
        """
        from graph_tool import Graph
        graph = Graph(directed=True)

        graph.vp['sym'] = graph.new_vertex_property('string')
        graph.vp['vmap'] = graph.new_vertex_property('int64_t')
        n = graph.add_vertex(1)

        worklist = [(None, (self, n))]
        while worklist:
            na, (b, nb) = worklist.pop(0)

            graph.vp['sym'][nb] = b.symbol
            graph.vp['vmap'][nb] = id(b)

            if na is not None:
                graph.add_edge(na, nb)

            for c in b.get_children():
                nc = graph.add_vertex(1)
                worklist.append((nb, (c, nc)))
        return graph

```

`qsynthesis/types.py`:

```py
from triton import AST_NODE
from typing import TypeVar, Union, Tuple, List, Generator, Dict, Optional, Iterable, Any, Iterator
from enum import IntEnum

# Utils types
BitSize = int
"""Integer representing a size in bits"""

ByteSize = int
"""Integer representing a size in bytes"""

Addr = int
"""Integer representing an address"""

# Triton Types
AstNode = TypeVar("AstNode")
"""`AstNode <https://triton.quarkslab.com/documentation/doxygen/py_AstNode_page.html>`_ SMT logic formula as returned by Triton"""

AstType = IntEnum("AstType", {k: v for k, v in AST_NODE.__dict__.items() if isinstance(v, int)})
"""Enum of all AstNode possible types as defined by the `AST_NODE <https://triton.quarkslab.com/documentation/doxygen/py_AST_NODE_page.html>`_ object of Triton"""

Register = TypeVar("Register")
""""`Register <https://triton.quarkslab.com/documentation/doxygen/py_Register_page.html>`_ object as returned by Triton"""

SymbolicExpression = TypeVar("SymbolicExpression")
"""`SymbolicExpression <https://triton.quarkslab.com/documentation/doxygen/py_SymbolicExpression_page.html>`_ object as used by Triton"""

SymbolicVariable = TypeVar("SymbolicVariable")
"""`SymbolicVariable <https://triton.quarkslab.com/documentation/doxygen/py_SymbolicVariable_page.html>`_ object as generated by Triton"""

# TritonAst & Grammar Types
Expr = AstNode
"""Alias for :py:obj:`AstNode`, to abstract to Triton type"""

SymVarMap = Dict[str, SymbolicVariable]
"""Dictionnary of symbolic variables names to theirs Triton object instance"""


# Synthesis types
Hash = Union[bytes, int, Tuple[int]]
"""Hash abstract type used to performed lookup in tables. Given the HashType of the
table a Hash value might be hashed before being used to perform the lookup."""

Char = str
"""String of size one. Used to represent normalized variables names"""

Input = Dict[Char, int]
"""An Input is a valuation of all inputs variables of an expression"""

Output = int
"""Value resulting of evaluating an Input on a given expression"""

IOPair = Tuple[Input, Output]
"""Represent a given input valuation and the resulting output integer"""

IOVector = List[IOPair]
"""List of input-outputs pairs"""

```

`qsynthesis/utils/symexec.py`:

```py
# built-in libs
from __future__ import annotations
from typing import List, Set, Iterable, Union, Optional

# third-party libs
from triton import ARCH, CALLBACK, MODE, MemoryAccess, Instruction, AST_REPRESENTATION, OPERAND
from triton import TritonContext

# qsynthesis deps
from qsynthesis.tritonast import TritonAst
from qsynthesis.types import SymbolicExpression, Register, Addr, ByteSize, SymbolicVariable


class SimpleSymExec:
    """
    Helper class used to process a sequential bunch of instructions using Triton
    and mark as symbolic all memory and registers reads that occoured before a
    write to that same register or memory address
    """

    def __init__(self, arch: Union[ARCH, str]):
        """
        Initialize symbolic execution

        :param arch: Triton architecture identifier or string of it
        :type: `ARCH <https://triton.quarkslab.com/documentation/doxygen/py_ARCH_page.html>`_
        """
        arch = getattr(ARCH, arch.upper()) if isinstance(arch, str) else arch
        self.ctx = TritonContext(arch)
        self.ctx.setMode(MODE.ALIGNED_MEMORY, True)
        self.ctx.setMode(MODE.AST_OPTIMIZATIONS, True)
        self.ctx.setMode(MODE.CONSTANT_FOLDING, True)
        self.ctx.setMode(MODE.ONLY_ON_SYMBOLIZED, True)
        self.ctx.setAstRepresentationMode(AST_REPRESENTATION.PYTHON)

        self.mem_addr_seen = set()  # All addresses read / written during execution
        self.mem_symvars = []       # All memory symbolic variables
        self.reg_id_seen = set()    # Triton Id of registers written directly or initialized with a value
        self.reg_symvars = []       # All registers symbolic variables

        self._capturing = False

        # Add callbacks
        self.ctx.addCallback(CALLBACK.SET_CONCRETE_MEMORY_VALUE, self._mem_write_callback)
        self.ctx.addCallback(CALLBACK.GET_CONCRETE_MEMORY_VALUE, self._mem_read_callback)
        self.ctx.addCallback(CALLBACK.SET_CONCRETE_REGISTER_VALUE, self._reg_write_callback)
        self.ctx.addCallback(CALLBACK.GET_CONCRETE_REGISTER_VALUE, self._reg_read_callback)

        self.cur_inst = None
        self.inst_id = 0
        self._expr_id = 0
        self._inst_cbs = []

    @property
    def expr_id(self) -> int:
        """
        Within a single instruction, used to represent an expression id.
        Programmed as an auto-increment variable upon each read.

        :rtype: int
        """
        self._expr_id += 1
        return self._expr_id - 1

    @expr_id.setter
    def expr_id(self, value: int) -> None:
        """Set the given expr_id"""
        self._expr_id = value

    @property
    def arch(self) -> ARCH:
        """Return the triton architecture identifier of the current context

        :rtype: `ARCH <https://triton.quarkslab.com/documentation/doxygen/py_ARCH_page.html>`_
        """
        return self.ctx.getArchitecture()

    @property
    def flags_reg(self) -> Register:
        """
        Portable function the get the flag register accross all Triton
        supported architectures.

        :rtype: `Register <https://triton.quarkslab.com/documentation/doxygen/py_Register_page.html>`_
        """
        _mapper = {ARCH.X86: "eflags", ARCH.X86_64: "eflags", ARCH.ARM32: "cpsr", ARCH.AARCH64: "spsr"}  # Not really true for spsr
        return getattr(self.ctx.registers, _mapper[self.arch])

    @property
    def ins_ptr_reg(self) -> Register:
        """
        Portable function get get the instruction pointer register depending
        on the current architecture.

        :rtype: `Register <https://triton.quarkslab.com/documentation/doxygen/py_Register_page.html>`_
        """
        _mapper = {ARCH.X86: "eip", ARCH.X86_64: "rip", ARCH.ARM32: "pc", ARCH.AARCH64: "pc"}
        return getattr(self.ctx.registers, _mapper[self.arch])

    @property
    def current_address(self) -> Addr:
        """Return the address of the current instruction.

        :rtype: :py:obj:`qsynthesis.types.Addr`
        """
        return self.cur_inst.getAddress()

    def _turn_on(self) -> None:
        """Turn on capturing"""
        self._capturing = True

    def _turn_off(self) -> None:
        """Turn off capturing"""
        self._capturing = False

    def _mem_write_callback(self, _: TritonContext, ma: MemoryAccess, __: int) -> None:
        """
        Callback called by Triton upon each memory write. It is used to update a map
        of all addresses written.
        """
        if not self._capturing:
            return

        # Add bytes to set of written bytes
        self.mem_addr_seen |= self._memacc_to_all_addr(ma)

    def _mem_read_callback(self, ctx: TritonContext, ma: MemoryAccess) -> None:
        """
        Callback called by Triton upon each memory read. It is used to dynamically
        symbolized memory cells accessed that have not been seen before.
        """
        if not self._capturing:
            return

        # Retrieve all addresses of a given mem access
        addrs = self._memacc_to_all_addr(ma)

        # Get addrs which have not been written to and are not
        # yet been symbolized (eg. are not yet parameters)
        new_addrs = addrs - self.mem_addr_seen

        # Stop if we don't have any new address. This is also needed to stop
        # recursion since convertMemoryToSymbolicVariable will trigger again this callback
        if not new_addrs:
            return

        # Update mem_operands
        self.mem_addr_seen |= new_addrs

        # Symbolize all the memory cells that have not yet been seen
        # Coalesce adjacent bytes and create memory accesses' symvars
        for ma in self._coalesce_bytes_to_mas(new_addrs):
            symvar = self.symbolize_memory(ma)
            self.mem_symvars.append(symvar)

    def _reg_write_callback(self, ctx: TritonContext, reg: Register, _: int) -> None:
        """
        Callback called by Triton on each register write.
        """
        if not self._capturing:
            return

        # Add parent register to set of written registers)
        parent_reg = ctx.getParentRegister(reg)
        self.reg_id_seen.add(parent_reg.getId())

    def _reg_read_callback(self, ctx: TritonContext, reg: Register) -> None:
        """
        Callback called by Triton on each register read.
        """
        if not self._capturing:
            return

        parent_reg = ctx.getParentRegister(reg)
        parent_reg_id = parent_reg.getId()

        # Skip reg if it has already been written or is already an operand
        if parent_reg_id in self.reg_id_seen:
            return

        # Ignore flags and pc registers (and make sure we know it!)
        if parent_reg in [self.flags_reg, self.ins_ptr_reg]:
            return

        # Ignore registers which are immutables
        if not reg.isMutable():
            return

        # Symbolize the (full) register
        self.symbolize_register(parent_reg, 0)

    def get_register_ast(self, reg_name: Union[str, Register]) -> TritonAst:
        """
        Get the TritonAst associated with the given register. The register
        can either be a string or a triton register object.

        :param reg_name: register name or triton register
        :type reg_name: Union[str, `Register <https://triton.quarkslab.com/documentation/doxygen/py_Register_page.html>`_]
        :returns: the TritonAst associated to that register
        """
        reg = getattr(self.ctx.registers, reg_name.lower()) if isinstance(reg_name, str) else reg_name
        reg_se = self.ctx.getSymbolicRegister(reg)
        actx = self.ctx.getAstContext()
        if reg_se is None:
            e = actx.bv(self.ctx.getConcreteRegisterValue(reg), reg.getBitSize())
        else:
            e = actx.unroll(reg_se.getAst())
        return TritonAst.make_ast(self.ctx, e)

    def get_memory_ast(self, addr: Addr, size: ByteSize) -> TritonAst:
        """
        Get the TritonAst associated with the given address and size.

        :param addr: address of which to create the AST
        :type addr: :py:obj:`qsynthesis.types.Addr`
        :param size: Size of the read in memory (in bytes)
        :type size: :py:obj:`qsynthesis.types.ByteSize`
        :returns: the TritonAst of the memory content
        :rtype: TritonAst
        """
        ast = self.ctx.getMemoryAst(MemoryAccess(addr, size))
        actx = self.ctx.getAstContext()
        return TritonAst.make_ast(self.ctx, actx.unroll(ast))

    def get_operand_ast(self, op_num: int, inst: Optional[Instruction] = None) -> TritonAst:
        """
        Get the TritonAst of the of the ith operand. The instruction can be provided
        as an optional parameter. If not provided it takes the current instruction
        having been processed.

        :param op_num: operand number (starting at 0)
        :param inst: Triton Instruction of which to get the operand
        :type inst: Optional[`Instruction <https://triton.quarkslab.com/documentation/doxygen/py_Instruction_page.html>`_]
        :returns: the TritonAst of the operand
        :rtype: TritonAst
        """
        inst = self.cur_inst if inst is None else inst
        op = inst.getOperands()[op_num]
        actx = self.ctx.getAstContext()
        t = op.getType()
        if t == OPERAND.IMM:
            e = actx.bv(op.getValue(), op.getBitSize())
        elif t == OPERAND.REG:
            e = self.ctx.getRegisterAst(op)
        elif t == OPERAND.MEM:
            e = self.ctx.getMemoryAst(op)
        else:
            assert False
        return TritonAst.make_ast(self.ctx, actx.unroll(e))

    def get_register_symbolic_expression(self, reg_name: Union[str, Register]) -> SymbolicExpression:
        """
        Get the current SymbolicExpression (triton object) of the register given in parameter.

        :param reg_name: register name, or Register object
        :type reg_name: Union[str, `Register <https://triton.quarkslab.com/documentation/doxygen/py_Register_page.html>`_]
        :returns: current symbolic expression of the register
        :rtype: `SymbolicExpression <https://triton.quarkslab.com/documentation/doxygen/py_SymbolicExpression_page.html>`_
        """
        reg = getattr(self.ctx.registers, reg_name.lower()) if isinstance(reg_name, str) else reg_name
        return self.ctx.getSymbolicRegister(reg)

    def get_memory_symbolic_expression(self, addr: Addr, size: ByteSize) -> SymbolicExpression:
        """
        Get the current SymbolicExpression of the given address. As no symbolic expression are
        assigned to single memory bytes. The function creates a new symbolic expression representing
        the addr+size expression.

        :param addr: address in memory
        :type addr: :py:obj:`qsynthesis.types.Addr`
        :param size: size in bytes of the memory read
        :type ByteSize: :py:obj:`qsynthesis.types.ByteSize`
        :returns: symbolic expression representing the memory content value
        :rtype: `SymbolicExpression <https://triton.quarkslab.com/documentation/doxygen/py_SymbolicExpression_page.html>`_
        """
        ast = self.ctx.getMemoryAst(MemoryAccess(addr, size))
        sym = self.ctx.newSymbolicExpression(ast)
        sym.setComment(self._fmt_comment())
        return sym

    def get_operand_symbolic_expression(self, op_num: int) -> SymbolicExpression:
        """
        Get the symbolic expression of the ith operand of the current instruction being
        processed by the symbolic executor. Depending on the type of the operand
        calls :meth:`SimpleSymExec.get_register_symbolic_expression`, or
        :meth:`SimpleSymExec.get_memory_symbolic_expression`. For constants create
        a new symbolic expression.

        :param op_num: operand number
        :type op_num: int
        :returns: the symbolic expression of the operand
        :rtype: `SymbolicExpression <https://triton.quarkslab.com/documentation/doxygen/py_SymbolicExpression_page.html>`_
        """
        op = self.cur_inst.getOperands()[op_num]
        t = op.getType()
        if t == OPERAND.IMM:
            ast = self.ctx.getAstContext().bv(op.getValue(), op.getBitSize())
            sym = self.ctx.newSymbolicExpression(ast)
            sym.setComment(self._fmt_comment())
        elif t == OPERAND.REG:
            sym = self.get_register_symbolic_expression(op)
        elif t == OPERAND.MEM:
            sym = self.get_memory_symbolic_expression(op.getAddress(), op.getSize())
        else:
            assert False
        return sym

    def symbolize_register(self, reg: Register, value: int) -> SymbolicVariable:
        """
        Symbolize the given register with the associated concrete value.

        :param reg: Register to symbolize
        :type reg: `Register <https://triton.quarkslab.com/documentation/doxygen/py_Register_page.html>`_
        :param value: Concrete value to assign the register (required for soundness)
        :type value: int
        :returns: the symbolic variable created for the register
        :rtype: `SymbolicVariable <https://triton.quarkslab.com/documentation/doxygen/py_SymbolicVariable_page.html>`_
        """
        self.reg_id_seen.add(reg.getId())
        symvar = self.ctx.symbolizeRegister(reg, reg.getName())
        #symvar.setComment(comment)

        # Set comment on the register reference
        sreg = self.ctx.getSymbolicRegister(reg)
        sreg.setComment(self._fmt_comment())

        # We also set the symbolic var to the actual value of the register
        self.ctx.setConcreteVariableValue(symvar, value)
        self.reg_symvars.append(symvar)
        return symvar

    def symbolize_memory(self, mem: MemoryAccess) -> SymbolicVariable:
        """
        Symbolize the given triton MemoryAccess. Into a new SymbolicVariable.

        :param mem: memory access to symbolize
        :type mem: `MemAccess <https://triton.quarkslab.com/documentation/doxygen/py_MemoryAccess_page.html>`_
        :returns: symbolic variable representing the content
        :rtype: `SymbolicVariable <https://triton.quarkslab.com/documentation/doxygen/py_SymbolicVariable_page.html>`_
        """
        # The issue here is that we need to assign a specific comment
        # on symbolic expression to attach them to a specific instruction
        # and being able to perform slicing afterward. But there is no
        # direct manner to get symbolic expressions created by the
        # symbolizeMemory

        # symbolize the MemAccess and obtain a SymbolicVariable object
        alias = f"mem_{mem.getAddress():#x}_{mem.getSize()}_{self.inst_id}"
        symvar = self.ctx.symbolizeMemory(mem, alias)
        symvar.setComment(self._fmt_comment())

        # Iterate each address of the MemAccess to obtain the SymbolicExpression
        # of the address. Put for each of them the right comment
        addr = mem.getAddress()
        end = addr + mem.getSize()
        cur_mem_exp = None
        while addr < end:
            cur_mem_exp = self.ctx.getSymbolicMemory(addr)
            cur_mem_exp.setComment(self._fmt_comment())
            addr += 1

        # Each SymbolicExpression have a uniq Id. The way they are created
        # (I heuristically know that the one before the last cur_mem_exp)
        # is the expression concating all of them thus also add a comment on it
        var_exp = self.ctx.getSymbolicExpression(cur_mem_exp.getId()-1)
        var_exp.setComment(self._fmt_comment())
        return symvar

    def initialize_register(self, reg: Union[str, Register], value: int) -> None:
        """
        Initialize a register by giving it an initial value. Register can
        either be a string or a Register object.

        :param reg: reg name string or register object
        :type reg: Union[str, `Register <https://triton.quarkslab.com/documentation/doxygen/py_Register_page.html>`_]
        :param value: integer value of the register
        """
        reg = getattr(self.ctx.registers, reg.lower()) if isinstance(reg, str) else reg
        self.reg_id_seen.add(reg.getId())
        self.ctx.setConcreteRegisterValue(reg, value)

    def disassemble(self, opcode: bytes, addr: Optional[Addr] = None) -> Instruction:
        """
        Disassemble a given opcode using Triton. Returns a Triton Instruction object.
        The Instruction is not been symbolically executed but the internal `cur_inst`
        attribute is set. The address is optional.
        If not provided the current instruction pointer in the internal context is used.

        :param opcode: bytes of the instruction
        :type opcode: bytes
        :param addr: address of the instruction
        :type addr: Optional[:py:obj:`qsynthesis.types.Addr`]
        :returns: Triton Instruction object
        :rtype: `Instruction <https://triton.quarkslab.com/documentation/doxygen/py_Instruction_page.html>`_
        """
        inst = Instruction(addr, opcode[:16]) if addr is not None else Instruction(opcode[:16])
        self.ctx.disassembly(inst)
        self.cur_inst = inst  # Set it if require to query get_operand_symbolic_expression
        return inst

    def execute_blob(self, data: bytes, addr: Addr) -> bool:
        """
        Execute instructions of the blob while the program counter
        remains in the blob. Consume the whole data and execute it
        symbolically.

        .. warning: This method writes payload into triton context.

        :param data: bytes of instructions to execute
        :type data: bytes
        :param addr:  address of the first instruction
        :type addr: :py:obj:`qsynthesis.types.Addr`
        :returns: True if execution of all instructions succeeded
        :rtype: bool
        """
        self.ctx.setConcreteMemoryAreaValue(addr, data)  # set concrete data in memory
        self.ctx.setConcreteRegisterValue(self.ins_ptr_reg, addr) # set program counter value
        pc = addr

        while addr <= pc < (addr + len(data)):  # while we remain in the blob
            opcode = self.ctx.getConcreteMemoryAreaValue(pc, 16) 
            if not self.execute(opcode, pc):
                return False
            pc =  self.ctx.getConcreteRegisterValue(self.ins_ptr_reg)
            
        return True

    def execute_basic_block(self, data: bytes, addr: Optional[Addr] = None) -> bool:
        """
        Execute a whole bunch of bytes as instructions. Consume the whole
        data and execute it symbolically. No payload is written in the triton
        context. The basic block is executed 'out of thin air'.

        :param data: bytes of instructions to execute
        :type data: bytes
        :param addr: optional address of the first instruction
        :type addr: Optional[:py:obj:`qsynthesis.types.Addr`]
        :returns: True if execution of all instructions succeeded
        :rtype: bool
        """
        blob = data[:]
        while blob:
            i = self.disassemble(blob, addr)
            addr = None  # reset to None if it was provided
            if not self.execute_instruction(i):
                return False
            blob = blob[i.getSize():]
        return True

    def execute(self, opcode: bytes, addr: Optional[Addr] = None) -> bool:
        """
        Symbolically execute the given opcode at the given optional address.

        :param opcode: bytes of the instruction
        :type opcode: bytes
        :param addr: optional address of the instruction
        :type addr: Optional[:py:obj:`qsynthesis.types.Addr`]
        :returns: True if the instruction has sucessfully been processed
        :rtype: bool
        """
        inst = Instruction(addr, opcode) if addr is not None else Instruction(opcode)
        return self.execute_instruction(inst)

    def execute_instruction(self, instr: Instruction) -> bool:
        """
        Symbolically execute the given triton Instruction already instanciated.

        :param instr: Triton Instruction
        :type instr: `Instruction <https://triton.quarkslab.com/documentation/doxygen/py_Instruction_page.html>`_
        :returns: True if the processing has successfully been performed
        :rtype: bool
        """
        # Update object values
        self.cur_inst = instr
        self.inst_id += 1
        self.expr_id = 0

        # Process instruction
        self._turn_on()

        # Call any instruction callback if any
        if self._inst_cbs:
            for cb in self._inst_cbs:
                cb(instr)
        
        r = self.ctx.processing(instr)

        # Set a unique comment on each symbolic expressions
        for e in instr.getSymbolicExpressions():
            e.setComment(self._fmt_comment())

        self._turn_off()
        return r

    def _fmt_comment(self) -> str:
        """Return a string identifying a SymbolicExpression in a unique manner"""
        return f"{self.inst_id}#{self.expr_id}#{self.current_address}"

    def add_instruction_callback(self, cb: Callable) -> None:
        """
        Add an Instruction callback that will be called for every
        instruction executed.
        """
        self._inst_cbs.append(cb)

    @staticmethod
    def _memacc_to_all_addr(ma: MemoryAccess) -> Set[int]:
        """Return a set of all addresses of a MemoryAccess"""
        addr = ma.getAddress()
        return set(range(addr, addr+ma.getSize()))

    @staticmethod
    def _split_unaligned_access(addr: Addr, size: ByteSize) -> List[MemoryAccess]:
        max_ma_size = 64  # Max aligned memory access size
        ma_size = 1
        splitted_ma = []
        current_addr = addr + size
        while ma_size < max_ma_size:
            if size & 0x1:
                current_addr -= ma_size
                splitted_ma.append(MemoryAccess(current_addr, ma_size))
            ma_size <<= 1
            size >>= 1
        for _ in range(size):
            current_addr -= ma_size
            splitted_ma.append(MemoryAccess(current_addr, ma_size))
        return splitted_ma

    @staticmethod
    def _coalesce_bytes_to_mas(ma_bytes: Iterable[Addr]) -> List[MemoryAccess]:
        """Convert a bunch of addresses into a list of MemoryAccess"""
        tmp_mem_accesses = []
        sorted_bytes = sorted(ma_bytes)
        addr, size = sorted_bytes[0], 1
        for b in sorted_bytes[1:]:
            if b == addr + size:
                size += 1
            else:
                tmp_mem_accesses.append((addr, size))
                addr = b
                size = 1
        tmp_mem_accesses.append((addr, size))
        coalesced_ma = []
        for addr, size in tmp_mem_accesses:
            coalesced_ma.extend(SimpleSymExec._split_unaligned_access(addr, size))
        return coalesced_ma

```

`setup.py`:

```py
#!/usr/bin/env python3
# coding: utf-8
"""Installation script for qsynthesis module."""

from setuptools import setup, find_packages

generate_deps = ['sympy']
server_deps = ['fastapi', 'uvicorn']
assembly_deps = ["arybo", "llvmlite"]

with open("README.md") as f:
    README = f.read()

setup(
    name="qsynthesis",
    version="0.1.2",
    description="Python API to synthesize Triton AST's",
    long_description_content_type='text/markdown',
    long_description=README,
    packages=find_packages(),
    url="https://github.com/quarkslab/qsynthesis",
    project_urls={
        "Documentation": "https://quarkslab.github.io/qsynthesis/",
        "Bug Tracker": "https://github.com/quarkslab/qsynthesis/issues",
        "Source": "https://github.com/quarkslab/qsynthesis"
    },
    setup_requires=[],
    install_requires=["triton-library",
                      "ordered_set",
                      "psutil",
                      "click",
                      "plyvel",
                      "requests",
                      "capstone",
                      "pydffi>=0.9.1"],
    tests_require=[],
    license="AGPL-3.0",
    author="Robin David",
    classifiers=[
        'Topic :: Security',
        'Environment :: Console',
        'Operating System :: OS Independent',
    ],
    extras_require={
        'all': assembly_deps+generate_deps+server_deps,
        'reassembly': assembly_deps,
        'generator': generate_deps,
        'server': server_deps
    },
    test_suite="",
    scripts=['bin/qsynthesis-table-manager', 'bin/qsynthesis-table-server']
)

```

`tests/test_fullsym.py`:

```py
import logging
import sys

from triton import ARCH

from qsynthesis import SimpleSymExec, TopDownSynthesizer, InputOutputOracleLevelDB
import qsynthesis
import logging
logging.basicConfig(level=logging.DEBUG)

qsynthesis.enable_logging()


RIP_ADDR = 0x40B160
RSP_ADDR = 0x800000

blob = b'UH\x89\xe5H\x89}\xf8H\x89u\xf0H\x89U\xe8H\x89M\xe0L\x89E\xd8H\x8bE' \
       b'\xe0H\xf7\xd0H\x0bE\xf8H\x89\xc2H\x8bE\xe0H\x01\xd0H\x8dH\x01H\x8b' \
       b'E\xf8H+E\xe8H\x8bU\xe8H\xf7\xd2H\x0bU\xf8H\x01\xd2H)\xd0H\x83\xe8' \
       b'\x02H!\xc1H\x8bE\xe0H\xf7\xd0H\x0bE\xf8H\x89\xc2H\x8bE\xe0H\x01\xd0' \
       b'H\x8dp\x01H\x8bE\xf8H+E\xe8H\x8bU\xe8H\xf7\xd2H\x0bU\xf8H\x01\xd2' \
       b'H)\xd0H\x83\xe8\x02H\t\xf0H)\xc1H\x89\xc8H\x83\xe8\x01]\xc3'


def test(oracle_file):
    # Perform symbolic execution of the instructions
    symexec = SimpleSymExec(ARCH.X86_64)
    symexec.initialize_register('rip', RIP_ADDR)
    symexec.initialize_register('rsp', RSP_ADDR)
    symexec.execute_blob(blob, RIP_ADDR)
    rax = symexec.get_register_ast("rax")

    # Load lookup tables
    ltm = InputOutputOracleLevelDB.load(oracle_file)

    # Perform Synthesis of the expression
    synthesizer = TopDownSynthesizer(ltm)
    synt_rax, simp = synthesizer.synthesize(rax)

    # Print synthesis results
    print(f"simplified: {simp}")
    print(f"synthesized expression: {synt_rax.pp_str}")
    sz, nsz = rax.node_count, synt_rax.node_count
    print(f"size: {rax.node_count} -> {synt_rax.node_count}\nsize reduction:{((sz-nsz)*100)/sz:.2f}%")
    return symexec, rax, synt_rax


if __name__ == "__main__":
    if len(sys.argv) != 2:
        print(f"./{sys.argv[0]} oracle_table")
        sys.exit(1)
    sx, rax, srax = test(sys.argv[1])
'''
simplified: True
synthesized expression: (((~(rcx)) & rdi) ^ (~(rdx)))
size: 51 -> 7
size reduction:86.27%
'''
```