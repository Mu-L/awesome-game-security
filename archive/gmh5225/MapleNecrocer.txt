Project Path: arc_gmh5225_MapleNecrocer_9baambdq

Source Tree:

```txt
arc_gmh5225_MapleNecrocer_9baambdq
├── LICENSE
├── MapleNecrocer
│   ├── AndroidForm.Designer.cs
│   ├── AndroidForm.cs
│   ├── AndroidForm.resx
│   ├── AvatarForm.Designer.cs
│   ├── AvatarForm.cs
│   ├── AvatarForm.resx
│   ├── AvatarFormDraw.cs
│   ├── CashEffectForm.Designer.cs
│   ├── CashEffectForm.cs
│   ├── CashEffectForm.resx
│   ├── CashForm.Designer.cs
│   ├── CashForm.cs
│   ├── CashForm.resx
│   ├── ChairForm.Designer.cs
│   ├── ChairForm.cs
│   ├── ChairForm.resx
│   ├── CharaSim
│   │   ├── CharaEquip.cs
│   │   ├── CharaProp.cs
│   │   ├── CharaSimLoader.cs
│   │   ├── Character.cs
│   │   └── CharacterStatus.cs
│   ├── CharaSimControl
│   │   ├── AControl.cs
│   │   ├── ACtrlButton.cs
│   │   ├── ACtrlVScroll.cs
│   │   ├── AfrmEquip.cs
│   │   ├── AfrmEquip.resx
│   │   ├── AfrmItem.cs
│   │   ├── AfrmItem.resx
│   │   ├── AfrmStat.cs
│   │   ├── AfrmStat.resx
│   │   ├── AfrmTooltip.cs
│   │   ├── AfrmTooltip.resx
│   │   ├── ButtonState.cs
│   │   ├── CashPackageRender.cs
│   │   ├── CharaSimControlGroup.cs
│   │   ├── GearGraphics.cs
│   │   ├── GearTooltipRender.cs
│   │   ├── GearTooltipRender2.cs
│   │   ├── HelpTooltipRender.cs
│   │   ├── ItemMouseEventArgs.cs
│   │   ├── ItemMouseEventHandler.cs
│   │   ├── ItemTooltipRender.cs
│   │   ├── ItemTooltipRender2.cs
│   │   ├── MobTooltipRenderer.cs
│   │   ├── NpcTooltipRenderer.cs
│   │   ├── ObjectMouseEventArgs.cs
│   │   ├── ObjectMouseEventHandler.cs
│   │   ├── RecipeTooltipRender.cs
│   │   ├── RenderHelper.cs
│   │   ├── SetItemTooltipRender.cs
│   │   ├── SkillTooltipRender.cs
│   │   ├── SkillTooltipRender2.cs
│   │   ├── TextBlock.cs
│   │   └── TooltipRender.cs
│   ├── ChatRingForm.Designer.cs
│   ├── ChatRingForm.cs
│   ├── ChatRingForm.resx
│   ├── Client
│   │   ├── AfterImage.cs
│   │   ├── Android.cs
│   │   ├── ChatBalloon.cs
│   │   ├── DamageNumber.cs
│   │   ├── Familiar.cs
│   │   ├── Footholds.cs
│   │   ├── ItemDrop.cs
│   │   ├── LadderRopes.cs
│   │   ├── MapBack.cs
│   │   ├── MapObj.cs
│   │   ├── MapParticle.cs
│   │   ├── MapPortal.cs
│   │   ├── MapTile.cs
│   │   ├── MapleChair.cs
│   │   ├── MapleCharacter.cs
│   │   ├── MapleCharacterEx.cs
│   │   ├── MapleEffect.cs
│   │   ├── MapleMap.cs
│   │   ├── MapleTV.cs
│   │   ├── Mob.cs
│   │   ├── Morph.cs
│   │   ├── MouseEx.cs
│   │   ├── NameTag.cs
│   │   ├── Npc.cs
│   │   ├── Particle
│   │   │   ├── Camera.cs
│   │   │   ├── IRandom.cs
│   │   │   ├── MapScene.cs
│   │   │   ├── MeshBatcher.cs
│   │   │   ├── MeshItem.cs
│   │   │   ├── Particle.cs
│   │   │   ├── ParticleData.cs
│   │   │   ├── ParticleDesc.cs
│   │   │   ├── ParticleEmitter.cs
│   │   │   ├── ParticleItem.cs
│   │   │   ├── ParticleRandom.cs
│   │   │   ├── ParticleRender.cs
│   │   │   ├── ParticleSystem.cs
│   │   │   ├── RenderEnv.cs
│   │   │   ├── ResourceLoader.cs
│   │   │   ├── SceneItem.cs
│   │   │   ├── SceneNode.cs
│   │   │   ├── TextMesh.cs
│   │   │   └── TextureAtlas.cs
│   │   ├── Pet.cs
│   │   ├── Reactor.cs
│   │   ├── Skill.cs
│   │   ├── Sound.cs
│   │   ├── SpriteEngine
│   │   │   ├── GameCanvas.cs
│   │   │   ├── Global.cs
│   │   │   ├── Keyboard.cs
│   │   │   ├── NURBSCurve.cs
│   │   │   ├── SpriteBatchEx.cs
│   │   │   ├── SpriteEngine.cs
│   │   │   ├── SpriteUtils.cs
│   │   │   ├── TextUtils.cs
│   │   │   ├── TextureLoader.cs
│   │   │   └── XnaFont.cs
│   │   ├── TamingMob.cs
│   │   ├── ToolTip.cs
│   │   └── UI
│   │       ├── Framework
│   │       │   ├── 0
│   │       │   ├── AlignmentHelper.cs
│   │       │   ├── Button.cs
│   │       │   ├── ContentAlignment.cs
│   │       │   ├── Control.cs
│   │       │   ├── ControlManager.cs
│   │       │   ├── DrawHelper.cs
│   │       │   ├── Extensions.cs
│   │       │   ├── Form.cs
│   │       │   ├── IControls.cs
│   │       │   ├── Label.cs
│   │       │   └── TextArea.cs
│   │       ├── GameCursor.cs
│   │       ├── MiniMap.cs
│   │       └── UI.Utils.cs
│   ├── ConsumeForm.Designer.cs
│   ├── ConsumeForm.cs
│   ├── ConsumeForm.resx
│   ├── DPIUtil.cs
│   ├── DamageSkinForm.Designer.cs
│   ├── DamageSkinForm.cs
│   ├── DamageSkinForm.resx
│   ├── DataGridViewEx.cs
│   ├── EffectRingForm.Designer.cs
│   ├── EffectRingForm.cs
│   ├── EffectRingForm.resx
│   ├── EtcForm.Designer.cs
│   ├── EtcForm.cs
│   ├── EtcForm.resx
│   ├── Extension.cs
│   ├── FamiliarForm.Designer.cs
│   ├── FamiliarForm.cs
│   ├── FamiliarForm.resx
│   ├── FrameListDraw.cs
│   ├── GraphicsExtension.cs
│   ├── ImageFilter.cs
│   ├── MainForm.Designer.cs
│   ├── MainForm.cs
│   ├── MainForm.resx
│   ├── MapleNecrocer.csproj
│   ├── MapleStoryGM_Icon.ico
│   ├── MedalForm.Designer.cs
│   ├── MedalForm.cs
│   ├── MedalForm.resx
│   ├── MobForm.Designer.cs
│   ├── MobForm.cs
│   ├── MobForm.resx
│   ├── MorphForm.Designer.cs
│   ├── MorphForm.cs
│   ├── MorphForm.resx
│   ├── MountForm.Designer.cs
│   ├── MountForm.cs
│   ├── MountForm.resx
│   ├── NpcForm.Designer.cs
│   ├── NpcForm.cs
│   ├── NpcForm.resx
│   ├── ObjInfoForm.Designer.cs
│   ├── ObjInfoForm.cs
│   ├── ObjInfoForm.resx
│   ├── OptionForm.Designer.cs
│   ├── OptionForm.cs
│   ├── OptionForm.resx
│   ├── PetForm.Designer.cs
│   ├── PetForm.cs
│   ├── PetForm.resx
│   ├── Program.cs
│   ├── Properties
│   │   ├── Resources.Designer.cs
│   │   └── Resources.resx
│   ├── ReactorForm.Designer.cs
│   ├── ReactorForm.cs
│   ├── ReactorForm.resx
│   ├── RenderForm.Designer.cs
│   ├── RenderForm.cs
│   ├── RenderForm.resx
│   ├── RenderFormDraw.cs
│   ├── Resources
│   │   ├── 01050088.img.info.iconRaw.png
│   │   ├── Aha-Soft-Hardware-Floppy.32.png
│   │   ├── picture.png
│   │   └── resize-picture-icon.png
│   ├── RingForm.Designer.cs
│   ├── RingForm.cs
│   ├── RingForm.resx
│   ├── SaveMapForm.Designer.cs
│   ├── SaveMapForm.cs
│   ├── SaveMapForm.resx
│   ├── ScaleForm.Designer.cs
│   ├── ScaleForm.cs
│   ├── ScaleForm.resx
│   ├── SelectFolderForm.Designer.cs
│   ├── SelectFolderForm.cs
│   ├── SelectFolderForm.resx
│   ├── SkillForm.Designer.cs
│   ├── SkillForm.cs
│   ├── SkillForm.resx
│   ├── SoulEffectForm.Designer.cs
│   ├── SoulEffectForm.cs
│   ├── SoulEffectForm.resx
│   ├── SoundPlayer
│   │   ├── 0
│   │   ├── BassSoundPlayer.cs
│   │   ├── CustomSoundFile.cs
│   │   ├── ISoundFile.cs
│   │   ├── ISoundPlayer.cs
│   │   └── PlayState.cs
│   ├── TitleForm.Designer.cs
│   ├── TitleForm.cs
│   ├── TitleForm.resx
│   ├── TotemEffectForm.Designer.cs
│   ├── TotemEffectForm.cs
│   ├── TotemEffectForm.resx
│   ├── ViewForm.Designer.cs
│   ├── ViewForm.cs
│   ├── ViewForm.resx
│   ├── Win32.cs
│   ├── WorldMapForm.Designer.cs
│   ├── WorldMapForm.cs
│   ├── WorldMapForm.resx
│   └── WzUtils.cs
├── MapleNecrocer.sln
├── README.md
├── WzComparerR2.Common
│   ├── Animation
│   │   ├── Frame.cs
│   │   ├── FrameAnimationData.cs
│   │   ├── FrameAnimator.cs
│   │   ├── ISpineAnimationData.cs
│   │   ├── ISpineAnimator.cs
│   │   ├── KeyFrame.cs
│   │   ├── ModelBound.cs
│   │   ├── MultiFrameAnimationData.cs
│   │   ├── MultiFrameAnimator.cs
│   │   ├── SpineAnimationData.cs
│   │   ├── SpineAnimationDataV2.cs
│   │   ├── SpineAnimationDataV4.cs
│   │   ├── SpineAnimator.cs
│   │   ├── SpineAnimatorV2.cs
│   │   ├── SpineAnimatorV4.cs
│   │   └── WzSpineTextureLoader.cs
│   ├── BitmapOrigin.cs
│   ├── BuildInApngEncoder.cs
│   ├── BuildInGifEncoder.cs
│   ├── Calculator.cs
│   ├── CharaSim
│   │   ├── Addition.cs
│   │   ├── AdditionType.cs
│   │   ├── AlienStone.cs
│   │   ├── AlienStoneGrade.cs
│   │   ├── CashPackage.cs
│   │   ├── Commodity.cs
│   │   ├── ExclusiveEquip.cs
│   │   ├── FormulaVersion.cs
│   │   ├── Gear.cs
│   │   ├── GearGrade.cs
│   │   ├── GearLevelInfo.cs
│   │   ├── GearPropType.cs
│   │   ├── GearSealedInfo.cs
│   │   ├── GearState.cs
│   │   ├── GearType.cs
│   │   ├── HyperSkillType.cs
│   │   ├── Item.cs
│   │   ├── ItemBase.cs
│   │   ├── ItemBaseType.cs
│   │   ├── ItemCoreSpecType.cs
│   │   ├── ItemPropType.cs
│   │   ├── ItemSpecType.cs
│   │   ├── ItemStringHelper.cs
│   │   ├── Mob.cs
│   │   ├── MobElemAttr.cs
│   │   ├── Npc.cs
│   │   ├── Potential.cs
│   │   ├── Recipe.cs
│   │   ├── RecipeItemInfo.cs
│   │   ├── RecipePropType.cs
│   │   ├── SetItem.cs
│   │   ├── SetItemActiveSkill.cs
│   │   ├── SetItemBonusByTime.cs
│   │   ├── SetItemEffect.cs
│   │   ├── SetItemIDList.cs
│   │   ├── SetItemIDPart.cs
│   │   ├── SetItemOptionToMob.cs
│   │   ├── Skill.cs
│   │   ├── SummaryParams.cs
│   │   ├── SummaryParser.cs
│   │   └── TooltipHelp.cs
│   ├── Class1.cs
│   ├── Config
│   │   ├── ConfigArrayList.cs
│   │   ├── ConfigItem.cs
│   │   ├── ConfigItemCollectionBase.cs
│   │   ├── ConfigManager.cs
│   │   ├── ConfigSectionBase.cs
│   │   └── SectionNameAttribute.cs
│   ├── Controls
│   │   ├── AlphaForm.cs
│   │   ├── AnimationClipOptions.cs
│   │   ├── AnimationControl.Designer.cs
│   │   ├── AnimationControl.cs
│   │   ├── AnimationItem.cs
│   │   ├── AnimationItemEventArgs.cs
│   │   ├── AnimationRecoder.cs
│   │   ├── FrmProgressDialog.Designer.cs
│   │   ├── FrmProgressDialog.cs
│   │   ├── FrmProgressDialog.resx
│   │   ├── GraphicsDeviceControl.cs
│   │   ├── GraphicsDeviceService.cs
│   │   ├── ProgressDialog.cs
│   │   ├── ProgressDialogContext.cs
│   │   └── ServiceContainer.cs
│   ├── Gif.cs
│   ├── GifCanvas.cs
│   ├── GifEncoder.cs
│   ├── GifFrame.cs
│   ├── GifLayer.cs
│   ├── GlobalFindNodeFunction.cs
│   ├── IGifFrame.cs
│   ├── ImageDataObject.cs
│   ├── IndexGifEncoder.cs
│   ├── Properties
│   │   └── AssemblyInfo.cs
│   ├── Rendering
│   │   ├── AnimationGraphics.cs
│   │   ├── BlendEx.cs
│   │   ├── D2DContext.cs
│   │   ├── D2DFactory.cs
│   │   ├── D2DFont.cs
│   │   ├── D2DRenderer.cs
│   │   ├── DxExtension.cs
│   │   ├── Effect
│   │   │   ├── EffectCompiler.bat
│   │   │   ├── Macros.fxh
│   │   │   ├── PngEffect.fx
│   │   │   └── PngEffect.mgfxo
│   │   ├── MonogameUtils.cs
│   │   ├── PngEffect.cs
│   │   ├── SpriteBatchEx.cs
│   │   ├── TextUtils.cs
│   │   ├── WzLibExtension.cs
│   │   ├── XnaFont.cs
│   │   └── XnaFontRenderer.cs
│   ├── SpineLoader.cs
│   ├── StringLinker.cs
│   ├── StringResult.cs
│   ├── Text
│   │   ├── DocumentElements.cs
│   │   ├── Parser.cs
│   │   └── TextRenderer.cs
│   ├── WzComparerR2.Common.csproj
│   └── Wz_NodeExtension2.cs
├── WzComparerR2.PluginBase
│   ├── FindWzEventArgs.cs
│   ├── FindWzEventHandler.cs
│   ├── PluginContext.cs
│   ├── PluginContextProvider.cs
│   ├── PluginEntry.cs
│   ├── PluginInfo.cs
│   ├── PluginManager.cs
│   ├── Properties
│   │   └── AssemblyInfo.cs
│   ├── WzComparerR2.PluginBase.csproj
│   ├── WzNodeEventArgs.cs
│   └── WzStructureEventArgs.cs
└── WzComparerR2.WzLib
    ├── Properties
    │   └── AssemblyInfo.cs
    ├── WzComparerR2.WzLib.csproj
    ├── Wz_Capabilities.cs
    ├── Wz_Crypto.cs
    ├── Wz_Directory.cs
    ├── Wz_File.cs
    ├── Wz_Header.cs
    ├── Wz_Image.cs
    ├── Wz_Node.cs
    ├── Wz_Png.cs
    ├── Wz_RawData.cs
    ├── Wz_Sound.cs
    ├── Wz_SoundType.cs
    ├── Wz_Structure.cs
    ├── Wz_Type.cs
    ├── Wz_Uol.cs
    └── Wz_Vector.cs

```

`LICENSE`:

```
The MIT License (MIT)
 
Copyright © 2023 Elem8100

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

```

`MapleNecrocer.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.4.33110.190
MinimumVisualStudioVersion = 10.0.40219.1
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "MapleNecrocer", "MapleNecrocer\MapleNecrocer.csproj", "{26F139AC-ACFE-411F-9A16-0AA1B986714D}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "WzComparerR2.Common", "WzComparerR2.Common\WzComparerR2.Common.csproj", "{A8CD1D1B-EFCE-4398-B79C-27B5A70D5A67}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "WzComparerR2.WzLib", "WzComparerR2.WzLib\WzComparerR2.WzLib.csproj", "{94604397-1673-4DD6-B937-C2AA603C5E7D}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "WzComparerR2.PluginBase", "WzComparerR2.PluginBase\WzComparerR2.PluginBase.csproj", "{29D42561-B432-434D-88FD-166C1EFD3650}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Debug|x64 = Debug|x64
		Release|Any CPU = Release|Any CPU
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{26F139AC-ACFE-411F-9A16-0AA1B986714D}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{26F139AC-ACFE-411F-9A16-0AA1B986714D}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{26F139AC-ACFE-411F-9A16-0AA1B986714D}.Debug|x64.ActiveCfg = Debug|x64
		{26F139AC-ACFE-411F-9A16-0AA1B986714D}.Debug|x64.Build.0 = Debug|x64
		{26F139AC-ACFE-411F-9A16-0AA1B986714D}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{26F139AC-ACFE-411F-9A16-0AA1B986714D}.Release|Any CPU.Build.0 = Release|Any CPU
		{26F139AC-ACFE-411F-9A16-0AA1B986714D}.Release|x64.ActiveCfg = Release|x64
		{26F139AC-ACFE-411F-9A16-0AA1B986714D}.Release|x64.Build.0 = Release|x64
		{A8CD1D1B-EFCE-4398-B79C-27B5A70D5A67}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{A8CD1D1B-EFCE-4398-B79C-27B5A70D5A67}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{A8CD1D1B-EFCE-4398-B79C-27B5A70D5A67}.Debug|x64.ActiveCfg = Debug|Any CPU
		{A8CD1D1B-EFCE-4398-B79C-27B5A70D5A67}.Debug|x64.Build.0 = Debug|Any CPU
		{A8CD1D1B-EFCE-4398-B79C-27B5A70D5A67}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{A8CD1D1B-EFCE-4398-B79C-27B5A70D5A67}.Release|Any CPU.Build.0 = Release|Any CPU
		{A8CD1D1B-EFCE-4398-B79C-27B5A70D5A67}.Release|x64.ActiveCfg = Release|Any CPU
		{A8CD1D1B-EFCE-4398-B79C-27B5A70D5A67}.Release|x64.Build.0 = Release|Any CPU
		{94604397-1673-4DD6-B937-C2AA603C5E7D}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{94604397-1673-4DD6-B937-C2AA603C5E7D}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{94604397-1673-4DD6-B937-C2AA603C5E7D}.Debug|x64.ActiveCfg = Debug|Any CPU
		{94604397-1673-4DD6-B937-C2AA603C5E7D}.Debug|x64.Build.0 = Debug|Any CPU
		{94604397-1673-4DD6-B937-C2AA603C5E7D}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{94604397-1673-4DD6-B937-C2AA603C5E7D}.Release|Any CPU.Build.0 = Release|Any CPU
		{94604397-1673-4DD6-B937-C2AA603C5E7D}.Release|x64.ActiveCfg = Release|Any CPU
		{94604397-1673-4DD6-B937-C2AA603C5E7D}.Release|x64.Build.0 = Release|Any CPU
		{29D42561-B432-434D-88FD-166C1EFD3650}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{29D42561-B432-434D-88FD-166C1EFD3650}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{29D42561-B432-434D-88FD-166C1EFD3650}.Debug|x64.ActiveCfg = Debug|Any CPU
		{29D42561-B432-434D-88FD-166C1EFD3650}.Debug|x64.Build.0 = Debug|Any CPU
		{29D42561-B432-434D-88FD-166C1EFD3650}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{29D42561-B432-434D-88FD-166C1EFD3650}.Release|Any CPU.Build.0 = Release|Any CPU
		{29D42561-B432-434D-88FD-166C1EFD3650}.Release|x64.ActiveCfg = Release|Any CPU
		{29D42561-B432-434D-88FD-166C1EFD3650}.Release|x64.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {83BB50BB-1BB8-43A6-8C90-BAF2C24A0399}
	EndGlobalSection
EndGlobal

```

`MapleNecrocer/AndroidForm.Designer.cs`:

```cs
namespace MapleNecrocer
{
    partial class AndroidForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            label1 = new Label();
            textBox1 = new TextBox();
            button1 = new Button();
            tabControl1 = new TabControl();
            tabPage1 = new TabPage();
            tabPage2 = new TabPage();
            tabControl1.SuspendLayout();
            SuspendLayout();
            // 
            // label1
            // 
            label1.AutoSize = true;
            label1.Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            label1.Location = new Point(24, 15);
            label1.Name = "label1";
            label1.Size = new Size(52, 18);
            label1.TabIndex = 4;
            label1.Text = "Search";
            // 
            // textBox1
            // 
            textBox1.Location = new Point(82, 12);
            textBox1.Name = "textBox1";
            textBox1.Size = new Size(120, 24);
            textBox1.TabIndex = 3;
            textBox1.TextChanged += textBox1_TextChanged;
            // 
            // button1
            // 
            button1.Location = new Point(291, 12);
            button1.Name = "button1";
            button1.Size = new Size(79, 28);
            button1.TabIndex = 5;
            button1.Text = "Remove";
            button1.UseVisualStyleBackColor = true;
            button1.Click += button1_Click;
            // 
            // tabControl1
            // 
            tabControl1.Anchor = AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right;
            tabControl1.Controls.Add(tabPage1);
            tabControl1.Controls.Add(tabPage2);
            tabControl1.Location = new Point(6, 42);
            tabControl1.Name = "tabControl1";
            tabControl1.SelectedIndex = 0;
            tabControl1.Size = new Size(379, 592);
            tabControl1.TabIndex = 6;
            tabControl1.SelectedIndexChanged += tabControl1_SelectedIndexChanged;
            // 
            // tabPage1
            // 
            tabPage1.Location = new Point(4, 26);
            tabPage1.Name = "tabPage1";
            tabPage1.Padding = new Padding(3);
            tabPage1.Size = new Size(371, 562);
            tabPage1.TabIndex = 0;
            tabPage1.Text = "Android";
            tabPage1.UseVisualStyleBackColor = true;
            // 
            // tabPage2
            // 
            tabPage2.Location = new Point(4, 28);
            tabPage2.Name = "tabPage2";
            tabPage2.Padding = new Padding(3);
            tabPage2.Size = new Size(371, 560);
            tabPage2.TabIndex = 1;
            tabPage2.Text = "Custom";
            tabPage2.UseVisualStyleBackColor = true;
            // 
            // AndroidForm
            // 
            AutoScaleMode = AutoScaleMode.None;
            ClientSize = new Size(389, 640);
            Controls.Add(tabControl1);
            Controls.Add(button1);
            Controls.Add(label1);
            Controls.Add(textBox1);
            Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            KeyPreview = true;
            MaximumSize = new Size(407, 687);
            Name = "AndroidForm";
            StartPosition = FormStartPosition.CenterScreen;
            Text = "Android";
            TopMost = true;
            FormClosing += AndroidForm_FormClosing;
            Shown += AndroidForm_Shown;
            KeyDown += AndroidForm_KeyDown;
            tabControl1.ResumeLayout(false);
            ResumeLayout(false);
            PerformLayout();
        }

        #endregion

        private Label label1;
        private TextBox textBox1;
        private Button button1;
        private TabControl tabControl1;
        private TabPage tabPage1;
        private TabPage tabPage2;
    }
}
```

`MapleNecrocer/AndroidForm.cs`:

```cs
using Manina.Windows.Forms;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

using System.Globalization;

namespace MapleNecrocer;

public partial class AndroidForm : Form
{
    public AndroidForm()
    {
        InitializeComponent();
        Instance = this;
    }
    public static AndroidForm Instance;
    DataGridViewEx AndroidListGrid;
    ImageListView ImageGrid;
    List<string> IDList = new();

    void CellClick(BaseDataGridView DataGrid, DataGridViewCellEventArgs e)
    {
        if (AndroidPlayer.Instance == null)
            AndroidPlayer.SpawnNew();

        IDList.Clear();
        string AndroidID = DataGrid.Rows[e.RowIndex].Cells[0].Value.ToString();
        int Num = Wz.GetInt("Character/Android/" + AndroidID + ".img/info/android");
        string ImgNum = Num.ToString().PadLeft(4, '0') + ".img";

        foreach (var Iter in Wz.GetNodes("Etc/Android/" + ImgNum))
        {
            if (Iter.Text == "basic")
            {
                foreach (var Iter2 in Iter.Nodes)
                    IDList.Add(Iter2.ToInt().ToString().PadLeft(8, '0'));

            }
            if (Iter.Text == "costume")
            {
                foreach (var Iter2 in Iter.Nodes)
                {
                    foreach (var Iter3 in Iter2.Nodes)
                    {
                        if (Iter3.Text == "0")
                            IDList.Add(Iter3.ToInt().ToString().PadLeft(8, '0'));
                    }
                }
            }
        }
        //add head
        for (int i = IDList.Count - 1; i >= 0; i--)
        {
            if (IDList[i].LeftStr(4) == "0000")
                IDList.Add("000120" + IDList[i].RightStr(2).PadLeft(2, '0'));
        }

        string Str = "";
        foreach (var i in IDList)
            Str = Str + i + '-';
        AndroidPlayer.Instance.Spawn(Str);
        AndroidNameTag.Remove();
        AndroidNameTag.Create(ImgNum);
        AndroidNameTag.Instance.MedalName = "Android";
        AndroidNameTag.Instance.InitData();
        AndroidNameTag.ReDraw();
    }
    private void AndroidForm_Shown(object sender, EventArgs e)
    {
        this.FormClosing += (s, e1) =>
        {
            this.Hide();
            e1.Cancel = true;
        };

        AndroidListGrid = new(85, 203, 0, 0, 220, 400, true, tabControl1.TabPages[0]);
        AndroidListGrid.Dock = DockStyle.Fill;
        AndroidListGrid.SearchGrid.Dock = DockStyle.Fill;
        AndroidListGrid.RowTemplate.Height = 40;

        var Graphic = AndroidListGrid.CreateGraphics();
        var Font = new System.Drawing.Font(FontFamily.GenericSansSerif, 20, FontStyle.Bold);
        Graphic.DrawString("Loading...", Font, Brushes.Black, 10, 50);

        AndroidListGrid.CellClick += (s, e) =>
        {
            CellClick(AndroidListGrid, e);
        };

        AndroidListGrid.SearchGrid.CellClick += (s, e) =>
        {
            CellClick(AndroidListGrid.SearchGrid, e);
        };

        AndroidListGrid.SetToolTipEvent(WzType.Character, this);

        ImageGrid = new ImageListView();
        ImageGrid.Parent = tabControl1.TabPages[1];
        ImageGrid.Anchor = (AnchorStyles.Left | AnchorStyles.Right | AnchorStyles.Top | AnchorStyles.Bottom);
        ImageGrid.Dock = DockStyle.Fill;
        ImageGrid.BackColor = SystemColors.Window;
        ImageGrid.Colors.BackColor = SystemColors.ButtonFace;
        ImageGrid.Colors.SelectedBorderColor = Color.Red;
        ImageGrid.Colors.HoverColor1 = SystemColors.ButtonFace;
        ImageGrid.Colors.HoverColor2 = SystemColors.ButtonFace;
        ImageGrid.BorderStyle = BorderStyle.Fixed3D;
        ImageGrid.ThumbnailSize = new System.Drawing.Size(100, 100);
        ImageGrid.ItemClick += (o, e) =>
        {
            if (AndroidPlayer.Instance == null)
                AndroidPlayer.SpawnNew();
            string IDs = e.Item.FileName;
            AndroidPlayer.Instance.Spawn(IDs);

            AndroidNameTag.Remove();
            AndroidNameTag.Create("0001.img");
            AndroidNameTag.Instance.MedalName = "Android";
            AndroidNameTag.Instance.InitData();
            AndroidNameTag.ReDraw();

        };
        if (!Wz.HasNode("Character/Android"))
            return;

        string AndroidName = "";
        Bitmap Bmp = null;
        foreach (var Img in Wz.GetNodes("Character/Android"))
        {
            if (Img.Text.LeftStr(4) == "0167")
                continue;
            if (!Char.IsNumber(Img.Text[0]))
                continue;
            string ID = Img.ImgID();
            if (Wz.HasNode("String/Eqp.img/Eqp/Android/" + ID.IntID()))
                AndroidName = Wz.GetStr("String/Eqp.img/Eqp/Android/" + ID.IntID() + "/name");
            if (Wz.HasNode("Character/Android/" + Img.Text + "/info/iconD"))
                Bmp = Wz.GetBmp("Character/Android/" + Img.Text + "/info/iconD");
            AndroidListGrid.Rows.Add(ID, Bmp, AndroidName);
        }
        for (int i = 0; i < AndroidListGrid.Rows.Count; i++)
        {
            AndroidListGrid.Rows[i].Cells[1].Style.Alignment = DataGridViewContentAlignment.MiddleCenter;
            AndroidListGrid.Rows[i].Cells[2].Style.Alignment = DataGridViewContentAlignment.TopLeft;
        }
    }

    private void button1_Click(object sender, EventArgs e)
    {
        AndroidNameTag.Remove();
        if (AndroidPlayer.Instance != null)
        {
            AndroidPlayer.Instance.RemoveSprites();
            AndroidPlayer.Instance.Dead();
            AndroidPlayer.Instance = null;
            EngineFunc.SpriteEngine.Dead();
        }
    }

    private void tabControl1_SelectedIndexChanged(object sender, EventArgs e)
    {
        void LoadAvatarPics()
        {
            string[] Files = Directory.GetFiles(System.Environment.CurrentDirectory + "\\Images");
            foreach (var i in Files)
            {
                string Name = Path.GetFileName(i);
                Name = Name.Replace(".png", "");
                Bitmap Png = new Bitmap(i);
                ImageGrid.Items.Add(Name, Png);
                Png.Dispose();
            }
        }
        if (tabControl1.SelectedIndex == 1)
        {
            LoadAvatarPics();
        }

    }

    private void AndroidForm_KeyDown(object sender, KeyEventArgs e)
    {
        if (e.Alt)
            e.Handled = true;
        if (!textBox1.Focused)
            ActiveControl = null;
    }

    private void textBox1_TextChanged(object sender, EventArgs e)
    {
        AndroidListGrid.Search(textBox1.Text);
    }

    private void AndroidForm_FormClosing(object sender, FormClosingEventArgs e)
    {
        MainForm.Instance.ToolTipView.Visible = false;
    }
}

```

`MapleNecrocer/AndroidForm.resx`:

```resx
<root>
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`MapleNecrocer/AvatarForm.Designer.cs`:

```cs
namespace MapleNecrocer
{
    partial class AvatarForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(AvatarForm));
            button1 = new Button();
            button2 = new Button();
            button3 = new Button();
            button4 = new Button();
            button5 = new Button();
            button6 = new Button();
            button7 = new Button();
            button8 = new Button();
            button9 = new Button();
            button10 = new Button();
            button11 = new Button();
            button12 = new Button();
            button13 = new Button();
            button14 = new Button();
            button15 = new Button();
            button16 = new Button();
            button17 = new Button();
            button18 = new Button();
            button19 = new Button();
            button20 = new Button();
            SaveCharButton = new Button();
            tabControl1 = new TabControl();
            tabPage1 = new TabPage();
            tabPage2 = new TabPage();
            tabPage3 = new TabPage();
            DyeGrid = new DataGridView();
            tabPage7 = new TabPage();
            button22 = new Button();
            LabelLightness = new Label();
            LabelSat = new Label();
            LabelHue = new Label();
            label8 = new Label();
            label7 = new Label();
            label6 = new Label();
            LightnessTrackBar = new TrackBar();
            SatTrackBar = new TrackBar();
            HueTrackBar = new TrackBar();
            DyePicture = new PictureBox();
            DyeGrid2 = new DataGridView();
            tabPage4 = new TabPage();
            textBox1 = new TextBox();
            label3 = new Label();
            panel1 = new Panel();
            UseButton = new Button();
            pictureBox1 = new PictureBox();
            label1 = new Label();
            label2 = new Label();
            tabPage5 = new TabPage();
            tabPage6 = new TabPage();
            label10 = new Label();
            ScrollBarH = new HScrollBar();
            AdjH = new Label();
            AdjW = new Label();
            ScrollBarW = new HScrollBar();
            label13 = new Label();
            YLabel = new Label();
            ScrollBarY = new HScrollBar();
            AdjY = new Label();
            AdjX = new Label();
            ScrollBarX = new HScrollBar();
            Xlabel = new Label();
            button21 = new Button();
            panel2 = new Panel();
            FrameListBox = new ListBox();
            label4 = new Label();
            comboBox1 = new ComboBox();
            ShowToolTil_CheckBox = new CheckBox();
            label5 = new Label();
            EarListBox = new ComboBox();
            tabControl1.SuspendLayout();
            tabPage3.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)DyeGrid).BeginInit();
            tabPage7.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)LightnessTrackBar).BeginInit();
            ((System.ComponentModel.ISupportInitialize)SatTrackBar).BeginInit();
            ((System.ComponentModel.ISupportInitialize)HueTrackBar).BeginInit();
            ((System.ComponentModel.ISupportInitialize)DyePicture).BeginInit();
            ((System.ComponentModel.ISupportInitialize)DyeGrid2).BeginInit();
            tabPage4.SuspendLayout();
            panel1.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)pictureBox1).BeginInit();
            tabPage6.SuspendLayout();
            SuspendLayout();
            // 
            // button1
            // 
            button1.Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            button1.Image = (Image)resources.GetObject("button1.Image");
            button1.ImageAlign = ContentAlignment.MiddleRight;
            button1.Location = new Point(7, 8);
            button1.Name = "button1";
            button1.Size = new Size(103, 41);
            button1.TabIndex = 0;
            button1.Tag = "20";
            button1.Text = "  Head";
            button1.TextAlign = ContentAlignment.MiddleLeft;
            button1.UseVisualStyleBackColor = true;
            button1.Click += button1_Click;
            // 
            // button2
            // 
            button2.Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            button2.Image = (Image)resources.GetObject("button2.Image");
            button2.ImageAlign = ContentAlignment.MiddleRight;
            button2.Location = new Point(110, 8);
            button2.Name = "button2";
            button2.Size = new Size(103, 41);
            button2.TabIndex = 1;
            button2.Tag = "1";
            button2.Text = "   Body";
            button2.TextAlign = ContentAlignment.MiddleLeft;
            button2.UseVisualStyleBackColor = true;
            button2.Click += button1_Click;
            // 
            // button3
            // 
            button3.Font = new Font("Tahoma", 8F, FontStyle.Regular, GraphicsUnit.Point);
            button3.Image = (Image)resources.GetObject("button3.Image");
            button3.ImageAlign = ContentAlignment.MiddleRight;
            button3.Location = new Point(213, 8);
            button3.Name = "button3";
            button3.Size = new Size(103, 41);
            button3.TabIndex = 2;
            button3.Tag = "2";
            button3.Text = "Weapon-1";
            button3.TextAlign = ContentAlignment.MiddleLeft;
            button3.UseVisualStyleBackColor = true;
            button3.Click += button1_Click;
            // 
            // button4
            // 
            button4.Font = new Font("Tahoma", 8F, FontStyle.Regular, GraphicsUnit.Point);
            button4.Image = (Image)resources.GetObject("button4.Image");
            button4.ImageAlign = ContentAlignment.MiddleRight;
            button4.Location = new Point(316, 8);
            button4.Name = "button4";
            button4.Size = new Size(103, 41);
            button4.TabIndex = 3;
            button4.Tag = "3";
            button4.Text = "Weapon-2";
            button4.TextAlign = ContentAlignment.MiddleLeft;
            button4.UseVisualStyleBackColor = true;
            button4.Click += button1_Click;
            // 
            // button5
            // 
            button5.Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            button5.Image = (Image)resources.GetObject("button5.Image");
            button5.ImageAlign = ContentAlignment.MiddleRight;
            button5.Location = new Point(7, 49);
            button5.Name = "button5";
            button5.Size = new Size(103, 41);
            button5.TabIndex = 4;
            button5.Tag = "4";
            button5.Text = "  Cap-1";
            button5.TextAlign = ContentAlignment.MiddleLeft;
            button5.UseVisualStyleBackColor = true;
            button5.Click += button1_Click;
            // 
            // button6
            // 
            button6.Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            button6.Image = (Image)resources.GetObject("button6.Image");
            button6.ImageAlign = ContentAlignment.MiddleRight;
            button6.Location = new Point(110, 49);
            button6.Name = "button6";
            button6.Size = new Size(103, 41);
            button6.TabIndex = 5;
            button6.Tag = "5";
            button6.Text = "  Cap-2";
            button6.TextAlign = ContentAlignment.MiddleLeft;
            button6.UseVisualStyleBackColor = true;
            button6.Click += button1_Click;
            // 
            // button7
            // 
            button7.Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            button7.Image = (Image)resources.GetObject("button7.Image");
            button7.ImageAlign = ContentAlignment.MiddleRight;
            button7.Location = new Point(213, 49);
            button7.Name = "button7";
            button7.Size = new Size(103, 41);
            button7.TabIndex = 6;
            button7.Tag = "6";
            button7.Text = "  Coat";
            button7.TextAlign = ContentAlignment.MiddleLeft;
            button7.UseVisualStyleBackColor = true;
            button7.Click += button1_Click;
            // 
            // button8
            // 
            button8.Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            button8.Image = (Image)resources.GetObject("button8.Image");
            button8.ImageAlign = ContentAlignment.MiddleRight;
            button8.Location = new Point(316, 49);
            button8.Name = "button8";
            button8.Size = new Size(103, 41);
            button8.TabIndex = 7;
            button8.Tag = "7";
            button8.Text = "  Pants";
            button8.TextAlign = ContentAlignment.MiddleLeft;
            button8.UseVisualStyleBackColor = true;
            button8.Click += button1_Click;
            // 
            // button9
            // 
            button9.Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            button9.Image = (Image)resources.GetObject("button9.Image");
            button9.ImageAlign = ContentAlignment.MiddleRight;
            button9.Location = new Point(7, 90);
            button9.Name = "button9";
            button9.Size = new Size(103, 41);
            button9.TabIndex = 8;
            button9.Tag = "8";
            button9.Text = "Longcoat";
            button9.TextAlign = ContentAlignment.MiddleLeft;
            button9.UseVisualStyleBackColor = true;
            button9.Click += button1_Click;
            // 
            // button10
            // 
            button10.Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            button10.Image = (Image)resources.GetObject("button10.Image");
            button10.ImageAlign = ContentAlignment.MiddleRight;
            button10.Location = new Point(110, 90);
            button10.Name = "button10";
            button10.Size = new Size(103, 41);
            button10.TabIndex = 9;
            button10.Tag = "9";
            button10.Text = "  Cape";
            button10.TextAlign = ContentAlignment.MiddleLeft;
            button10.UseVisualStyleBackColor = true;
            button10.Click += button1_Click;
            // 
            // button11
            // 
            button11.Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            button11.Image = (Image)resources.GetObject("button11.Image");
            button11.ImageAlign = ContentAlignment.MiddleRight;
            button11.Location = new Point(213, 90);
            button11.Name = "button11";
            button11.Size = new Size(103, 41);
            button11.TabIndex = 10;
            button11.Tag = "10";
            button11.Text = "  Shield";
            button11.TextAlign = ContentAlignment.MiddleLeft;
            button11.UseVisualStyleBackColor = true;
            button11.Click += button1_Click;
            // 
            // button12
            // 
            button12.Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            button12.Image = (Image)resources.GetObject("button12.Image");
            button12.ImageAlign = ContentAlignment.MiddleRight;
            button12.Location = new Point(316, 90);
            button12.Name = "button12";
            button12.Size = new Size(103, 41);
            button12.TabIndex = 11;
            button12.Tag = "11";
            button12.Text = "  Glove";
            button12.TextAlign = ContentAlignment.MiddleLeft;
            button12.UseVisualStyleBackColor = true;
            button12.Click += button1_Click;
            // 
            // button13
            // 
            button13.Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            button13.Image = (Image)resources.GetObject("button13.Image");
            button13.ImageAlign = ContentAlignment.MiddleRight;
            button13.Location = new Point(7, 131);
            button13.Name = "button13";
            button13.Size = new Size(103, 41);
            button13.TabIndex = 12;
            button13.Tag = "12";
            button13.Text = "  Shoes";
            button13.TextAlign = ContentAlignment.MiddleLeft;
            button13.UseVisualStyleBackColor = true;
            button13.Click += button1_Click;
            // 
            // button14
            // 
            button14.Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            button14.Image = (Image)resources.GetObject("button14.Image");
            button14.ImageAlign = ContentAlignment.MiddleRight;
            button14.Location = new Point(110, 131);
            button14.Name = "button14";
            button14.Size = new Size(103, 41);
            button14.TabIndex = 13;
            button14.Tag = "13";
            button14.Text = "Hair-1";
            button14.TextAlign = ContentAlignment.MiddleLeft;
            button14.UseVisualStyleBackColor = true;
            button14.Click += button1_Click;
            // 
            // button15
            // 
            button15.Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            button15.Image = (Image)resources.GetObject("button15.Image");
            button15.ImageAlign = ContentAlignment.MiddleRight;
            button15.Location = new Point(213, 131);
            button15.Name = "button15";
            button15.Size = new Size(103, 41);
            button15.TabIndex = 14;
            button15.Tag = "14";
            button15.Text = "Hair-2";
            button15.TextAlign = ContentAlignment.MiddleLeft;
            button15.UseVisualStyleBackColor = true;
            button15.Click += button1_Click;
            // 
            // button16
            // 
            button16.Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            button16.Image = (Image)resources.GetObject("button16.Image");
            button16.ImageAlign = ContentAlignment.MiddleRight;
            button16.Location = new Point(316, 131);
            button16.Name = "button16";
            button16.Size = new Size(103, 41);
            button16.TabIndex = 15;
            button16.Tag = "15";
            button16.Text = "  Face-1";
            button16.TextAlign = ContentAlignment.MiddleLeft;
            button16.UseVisualStyleBackColor = true;
            button16.Click += button1_Click;
            // 
            // button17
            // 
            button17.Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            button17.Image = (Image)resources.GetObject("button17.Image");
            button17.ImageAlign = ContentAlignment.MiddleRight;
            button17.Location = new Point(7, 172);
            button17.Name = "button17";
            button17.Size = new Size(103, 41);
            button17.TabIndex = 16;
            button17.Tag = "16";
            button17.Text = "  Face-2";
            button17.TextAlign = ContentAlignment.MiddleLeft;
            button17.UseVisualStyleBackColor = true;
            button17.Click += button1_Click;
            // 
            // button18
            // 
            button18.Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            button18.Image = (Image)resources.GetObject("button18.Image");
            button18.ImageAlign = ContentAlignment.MiddleRight;
            button18.Location = new Point(110, 172);
            button18.Name = "button18";
            button18.Size = new Size(103, 41);
            button18.TabIndex = 17;
            button18.Tag = "17";
            button18.Text = " FaceAcc";
            button18.TextAlign = ContentAlignment.MiddleLeft;
            button18.UseVisualStyleBackColor = true;
            button18.Click += button1_Click;
            // 
            // button19
            // 
            button19.Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            button19.Image = (Image)resources.GetObject("button19.Image");
            button19.ImageAlign = ContentAlignment.MiddleRight;
            button19.Location = new Point(213, 172);
            button19.Name = "button19";
            button19.Size = new Size(103, 41);
            button19.TabIndex = 18;
            button19.Tag = "18";
            button19.Text = " Glass";
            button19.TextAlign = ContentAlignment.MiddleLeft;
            button19.UseVisualStyleBackColor = true;
            button19.Click += button1_Click;
            // 
            // button20
            // 
            button20.Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            button20.Image = (Image)resources.GetObject("button20.Image");
            button20.ImageAlign = ContentAlignment.MiddleRight;
            button20.Location = new Point(316, 172);
            button20.Name = "button20";
            button20.Size = new Size(103, 41);
            button20.TabIndex = 19;
            button20.Tag = "19";
            button20.Text = "Earring";
            button20.TextAlign = ContentAlignment.MiddleLeft;
            button20.UseVisualStyleBackColor = true;
            button20.Click += button1_Click;
            // 
            // SaveCharButton
            // 
            SaveCharButton.Font = new Font("Microsoft JhengHei UI", 13F, FontStyle.Regular, GraphicsUnit.Pixel);
            SaveCharButton.Location = new Point(220, 220);
            SaveCharButton.Name = "SaveCharButton";
            SaveCharButton.Size = new Size(108, 32);
            SaveCharButton.TabIndex = 20;
            SaveCharButton.Text = "Save Character";
            SaveCharButton.UseVisualStyleBackColor = true;
            SaveCharButton.Click += SaveCharButton_Click;
            // 
            // tabControl1
            // 
            tabControl1.Anchor = AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right;
            tabControl1.Controls.Add(tabPage1);
            tabControl1.Controls.Add(tabPage2);
            tabControl1.Controls.Add(tabPage3);
            tabControl1.Controls.Add(tabPage7);
            tabControl1.Controls.Add(tabPage4);
            tabControl1.Controls.Add(tabPage5);
            tabControl1.Controls.Add(tabPage6);
            tabControl1.Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            tabControl1.Location = new Point(7, 260);
            tabControl1.Name = "tabControl1";
            tabControl1.SelectedIndex = 0;
            tabControl1.Size = new Size(779, 636);
            tabControl1.TabIndex = 21;
            tabControl1.SelectedIndexChanged += tabControl1_SelectedIndexChanged;
            // 
            // tabPage1
            // 
            tabPage1.Location = new Point(4, 26);
            tabPage1.Name = "tabPage1";
            tabPage1.Padding = new Padding(3);
            tabPage1.Size = new Size(771, 606);
            tabPage1.TabIndex = 0;
            tabPage1.Text = "Equip";
            tabPage1.UseVisualStyleBackColor = true;
            // 
            // tabPage2
            // 
            tabPage2.Location = new Point(4, 26);
            tabPage2.Name = "tabPage2";
            tabPage2.Padding = new Padding(3);
            tabPage2.Size = new Size(771, 606);
            tabPage2.TabIndex = 1;
            tabPage2.Text = "Load  Character";
            tabPage2.UseVisualStyleBackColor = true;
            // 
            // tabPage3
            // 
            tabPage3.Controls.Add(DyeGrid);
            tabPage3.Location = new Point(4, 26);
            tabPage3.Name = "tabPage3";
            tabPage3.Padding = new Padding(3);
            tabPage3.Size = new Size(771, 606);
            tabPage3.TabIndex = 2;
            tabPage3.Text = "Dye";
            tabPage3.UseVisualStyleBackColor = true;
            // 
            // DyeGrid
            // 
            DyeGrid.AllowUserToAddRows = false;
            DyeGrid.AllowUserToResizeColumns = false;
            DyeGrid.AllowUserToResizeRows = false;
            DyeGrid.BackgroundColor = SystemColors.ButtonFace;
            DyeGrid.CellBorderStyle = DataGridViewCellBorderStyle.SingleHorizontal;
            DyeGrid.ColumnHeadersHeightSizeMode = DataGridViewColumnHeadersHeightSizeMode.AutoSize;
            DyeGrid.ColumnHeadersVisible = false;
            DyeGrid.Dock = DockStyle.Fill;
            DyeGrid.Location = new Point(3, 3);
            DyeGrid.MultiSelect = false;
            DyeGrid.Name = "DyeGrid";
            DyeGrid.RowHeadersVisible = false;
            DyeGrid.RowHeadersWidth = 40;
            DyeGrid.RowTemplate.Height = 40;
            DyeGrid.ShowCellToolTips = false;
            DyeGrid.Size = new Size(765, 600);
            DyeGrid.TabIndex = 0;
            DyeGrid.CellClick += DyeGrid_CellClick;
            // 
            // tabPage7
            // 
            tabPage7.Controls.Add(button22);
            tabPage7.Controls.Add(LabelLightness);
            tabPage7.Controls.Add(LabelSat);
            tabPage7.Controls.Add(LabelHue);
            tabPage7.Controls.Add(label8);
            tabPage7.Controls.Add(label7);
            tabPage7.Controls.Add(label6);
            tabPage7.Controls.Add(LightnessTrackBar);
            tabPage7.Controls.Add(SatTrackBar);
            tabPage7.Controls.Add(HueTrackBar);
            tabPage7.Controls.Add(DyePicture);
            tabPage7.Controls.Add(DyeGrid2);
            tabPage7.Location = new Point(4, 26);
            tabPage7.Name = "tabPage7";
            tabPage7.Size = new Size(771, 606);
            tabPage7.TabIndex = 6;
            tabPage7.Text = "Dye2";
            tabPage7.UseVisualStyleBackColor = true;
            // 
            // button22
            // 
            button22.Location = new Point(295, 526);
            button22.Name = "button22";
            button22.Size = new Size(144, 44);
            button22.TabIndex = 11;
            button22.Text = "OK";
            button22.UseVisualStyleBackColor = true;
            button22.Click += button22_Click;
            // 
            // LabelLightness
            // 
            LabelLightness.AutoSize = true;
            LabelLightness.Font = new Font("Tahoma", 16F, FontStyle.Regular, GraphicsUnit.Pixel);
            LabelLightness.Location = new Point(152, 477);
            LabelLightness.Name = "LabelLightness";
            LabelLightness.Size = new Size(18, 19);
            LabelLightness.TabIndex = 10;
            LabelLightness.Text = "0";
            // 
            // LabelSat
            // 
            LabelSat.AutoSize = true;
            LabelSat.Font = new Font("Tahoma", 16F, FontStyle.Regular, GraphicsUnit.Pixel);
            LabelSat.Location = new Point(152, 435);
            LabelSat.Name = "LabelSat";
            LabelSat.Size = new Size(18, 19);
            LabelSat.TabIndex = 9;
            LabelSat.Text = "0";
            // 
            // LabelHue
            // 
            LabelHue.AutoSize = true;
            LabelHue.Font = new Font("Tahoma", 16F, FontStyle.Regular, GraphicsUnit.Pixel);
            LabelHue.Location = new Point(152, 393);
            LabelHue.Name = "LabelHue";
            LabelHue.Size = new Size(18, 19);
            LabelHue.TabIndex = 8;
            LabelHue.Text = "0";
            // 
            // label8
            // 
            label8.AutoSize = true;
            label8.Font = new Font("Tahoma", 16F, FontStyle.Regular, GraphicsUnit.Pixel);
            label8.Location = new Point(68, 477);
            label8.Name = "label8";
            label8.Size = new Size(86, 19);
            label8.TabIndex = 7;
            label8.Text = "Lightness :";
            // 
            // label7
            // 
            label7.AutoSize = true;
            label7.Font = new Font("Tahoma", 16F, FontStyle.Regular, GraphicsUnit.Pixel);
            label7.Location = new Point(62, 435);
            label7.Name = "label7";
            label7.Size = new Size(92, 19);
            label7.TabIndex = 6;
            label7.Text = "Saturation :";
            // 
            // label6
            // 
            label6.AutoSize = true;
            label6.Font = new Font("Tahoma", 16F, FontStyle.Regular, GraphicsUnit.Pixel);
            label6.Location = new Point(106, 393);
            label6.Name = "label6";
            label6.Size = new Size(48, 19);
            label6.TabIndex = 5;
            label6.Text = "Hue :";
            // 
            // LightnessTrackBar
            // 
            LightnessTrackBar.AutoSize = false;
            LightnessTrackBar.Location = new Point(202, 475);
            LightnessTrackBar.Maximum = 100;
            LightnessTrackBar.Minimum = -100;
            LightnessTrackBar.Name = "LightnessTrackBar";
            LightnessTrackBar.Size = new Size(356, 25);
            LightnessTrackBar.TabIndex = 4;
            LightnessTrackBar.TickStyle = TickStyle.None;
            LightnessTrackBar.Scroll += LightnessTrackBar_Scroll;
            // 
            // SatTrackBar
            // 
            SatTrackBar.AutoSize = false;
            SatTrackBar.LargeChange = 1;
            SatTrackBar.Location = new Point(202, 431);
            SatTrackBar.Maximum = 100;
            SatTrackBar.Minimum = -100;
            SatTrackBar.Name = "SatTrackBar";
            SatTrackBar.Size = new Size(356, 25);
            SatTrackBar.TabIndex = 3;
            SatTrackBar.TickStyle = TickStyle.None;
            SatTrackBar.Scroll += SatTrackBar_Scroll;
            // 
            // HueTrackBar
            // 
            HueTrackBar.AutoSize = false;
            HueTrackBar.LargeChange = 1;
            HueTrackBar.Location = new Point(202, 389);
            HueTrackBar.Maximum = 360;
            HueTrackBar.Name = "HueTrackBar";
            HueTrackBar.Size = new Size(356, 25);
            HueTrackBar.TabIndex = 2;
            HueTrackBar.TickStyle = TickStyle.None;
            HueTrackBar.Scroll += HueTrackBar_Scroll;
            // 
            // DyePicture
            // 
            DyePicture.BorderStyle = BorderStyle.FixedSingle;
            DyePicture.Location = new Point(325, 300);
            DyePicture.Name = "DyePicture";
            DyePicture.Size = new Size(93, 79);
            DyePicture.SizeMode = PictureBoxSizeMode.StretchImage;
            DyePicture.TabIndex = 1;
            DyePicture.TabStop = false;
            // 
            // DyeGrid2
            // 
            DyeGrid2.AllowUserToAddRows = false;
            DyeGrid2.AllowUserToDeleteRows = false;
            DyeGrid2.AllowUserToResizeColumns = false;
            DyeGrid2.AllowUserToResizeRows = false;
            DyeGrid2.ColumnHeadersHeightSizeMode = DataGridViewColumnHeadersHeightSizeMode.AutoSize;
            DyeGrid2.ColumnHeadersVisible = false;
            DyeGrid2.Location = new Point(202, 24);
            DyeGrid2.Name = "DyeGrid2";
            DyeGrid2.RowHeadersVisible = false;
            DyeGrid2.RowHeadersWidth = 51;
            DyeGrid2.RowTemplate.Height = 29;
            DyeGrid2.SelectionMode = DataGridViewSelectionMode.FullRowSelect;
            DyeGrid2.Size = new Size(356, 268);
            DyeGrid2.TabIndex = 0;
            DyeGrid2.CellClick += DyeGrid2_CellClick;
            // 
            // tabPage4
            // 
            tabPage4.Controls.Add(textBox1);
            tabPage4.Controls.Add(label3);
            tabPage4.Controls.Add(panel1);
            tabPage4.Location = new Point(4, 26);
            tabPage4.Name = "tabPage4";
            tabPage4.Padding = new Padding(3);
            tabPage4.Size = new Size(771, 606);
            tabPage4.TabIndex = 3;
            tabPage4.Text = "Search";
            tabPage4.UseVisualStyleBackColor = true;
            // 
            // textBox1
            // 
            textBox1.Location = new Point(184, 76);
            textBox1.Name = "textBox1";
            textBox1.Size = new Size(245, 24);
            textBox1.TabIndex = 2;
            textBox1.TextChanged += textBox1_TextChanged;
            // 
            // label3
            // 
            label3.AutoSize = true;
            label3.Location = new Point(116, 79);
            label3.Name = "label3";
            label3.Size = new Size(52, 18);
            label3.TabIndex = 1;
            label3.Text = "Search";
            // 
            // panel1
            // 
            panel1.BorderStyle = BorderStyle.FixedSingle;
            panel1.Controls.Add(UseButton);
            panel1.Controls.Add(pictureBox1);
            panel1.Controls.Add(label1);
            panel1.Controls.Add(label2);
            panel1.Location = new Point(114, 21);
            panel1.Name = "panel1";
            panel1.Size = new Size(315, 49);
            panel1.TabIndex = 0;
            // 
            // UseButton
            // 
            UseButton.Location = new Point(263, 6);
            UseButton.Name = "UseButton";
            UseButton.Size = new Size(45, 35);
            UseButton.TabIndex = 3;
            UseButton.Text = "Use";
            UseButton.UseVisualStyleBackColor = true;
            UseButton.Click += UseButton_Click;
            // 
            // pictureBox1
            // 
            pictureBox1.Location = new Point(74, 3);
            pictureBox1.Name = "pictureBox1";
            pictureBox1.Size = new Size(40, 40);
            pictureBox1.SizeMode = PictureBoxSizeMode.CenterImage;
            pictureBox1.TabIndex = 1;
            pictureBox1.TabStop = false;
            // 
            // label1
            // 
            label1.AutoSize = true;
            label1.Location = new Point(3, 16);
            label1.Name = "label1";
            label1.Size = new Size(0, 18);
            label1.TabIndex = 0;
            // 
            // label2
            // 
            label2.AutoSize = true;
            label2.Location = new Point(110, 16);
            label2.Name = "label2";
            label2.Size = new Size(0, 18);
            label2.TabIndex = 2;
            // 
            // tabPage5
            // 
            tabPage5.Location = new Point(4, 26);
            tabPage5.Name = "tabPage5";
            tabPage5.Padding = new Padding(3);
            tabPage5.Size = new Size(771, 606);
            tabPage5.TabIndex = 4;
            tabPage5.Text = "Spawn";
            tabPage5.UseVisualStyleBackColor = true;
            // 
            // tabPage6
            // 
            tabPage6.Controls.Add(label10);
            tabPage6.Controls.Add(ScrollBarH);
            tabPage6.Controls.Add(AdjH);
            tabPage6.Controls.Add(AdjW);
            tabPage6.Controls.Add(ScrollBarW);
            tabPage6.Controls.Add(label13);
            tabPage6.Controls.Add(YLabel);
            tabPage6.Controls.Add(ScrollBarY);
            tabPage6.Controls.Add(AdjY);
            tabPage6.Controls.Add(AdjX);
            tabPage6.Controls.Add(ScrollBarX);
            tabPage6.Controls.Add(Xlabel);
            tabPage6.Controls.Add(button21);
            tabPage6.Controls.Add(panel2);
            tabPage6.Controls.Add(FrameListBox);
            tabPage6.Location = new Point(4, 26);
            tabPage6.Name = "tabPage6";
            tabPage6.Padding = new Padding(3);
            tabPage6.Size = new Size(771, 606);
            tabPage6.TabIndex = 5;
            tabPage6.Text = "Export";
            tabPage6.UseVisualStyleBackColor = true;
            // 
            // label10
            // 
            label10.AutoSize = true;
            label10.Location = new Point(528, 50);
            label10.Name = "label10";
            label10.Size = new Size(23, 18);
            label10.TabIndex = 14;
            label10.Text = "H:";
            // 
            // ScrollBarH
            // 
            ScrollBarH.LargeChange = 1;
            ScrollBarH.Location = new Point(581, 49);
            ScrollBarH.Maximum = 512;
            ScrollBarH.Minimum = 100;
            ScrollBarH.Name = "ScrollBarH";
            ScrollBarH.Size = new Size(184, 17);
            ScrollBarH.TabIndex = 13;
            ScrollBarH.Value = 200;
            ScrollBarH.Scroll += hScrollBar1_Scroll;
            // 
            // AdjH
            // 
            AdjH.AutoSize = true;
            AdjH.Location = new Point(548, 50);
            AdjH.Name = "AdjH";
            AdjH.Size = new Size(32, 18);
            AdjH.TabIndex = 12;
            AdjH.Text = "200";
            // 
            // AdjW
            // 
            AdjW.AutoSize = true;
            AdjW.Location = new Point(289, 50);
            AdjW.Name = "AdjW";
            AdjW.Size = new Size(32, 18);
            AdjW.TabIndex = 11;
            AdjW.Text = "200";
            // 
            // ScrollBarW
            // 
            ScrollBarW.LargeChange = 1;
            ScrollBarW.Location = new Point(318, 50);
            ScrollBarW.Maximum = 512;
            ScrollBarW.Minimum = 100;
            ScrollBarW.Name = "ScrollBarW";
            ScrollBarW.ScaleScrollBarForDpiChange = false;
            ScrollBarW.Size = new Size(184, 18);
            ScrollBarW.TabIndex = 10;
            ScrollBarW.Value = 200;
            ScrollBarW.Scroll += hScrollBar1_Scroll;
            // 
            // label13
            // 
            label13.AutoSize = true;
            label13.Location = new Point(265, 50);
            label13.Name = "label13";
            label13.Size = new Size(27, 18);
            label13.TabIndex = 9;
            label13.Text = "W:";
            // 
            // YLabel
            // 
            YLabel.AutoSize = true;
            YLabel.Location = new Point(527, 16);
            YLabel.Name = "YLabel";
            YLabel.Size = new Size(23, 18);
            YLabel.TabIndex = 8;
            YLabel.Text = "Y:";
            // 
            // ScrollBarY
            // 
            ScrollBarY.LargeChange = 1;
            ScrollBarY.Location = new Point(581, 17);
            ScrollBarY.Maximum = 256;
            ScrollBarY.Minimum = -256;
            ScrollBarY.Name = "ScrollBarY";
            ScrollBarY.Size = new Size(184, 17);
            ScrollBarY.TabIndex = 7;
            ScrollBarY.Value = 18;
            ScrollBarY.Scroll += hScrollBar1_Scroll;
            // 
            // AdjY
            // 
            AdjY.AutoSize = true;
            AdjY.Location = new Point(546, 17);
            AdjY.Name = "AdjY";
            AdjY.Size = new Size(24, 18);
            AdjY.TabIndex = 6;
            AdjY.Text = "18";
            // 
            // AdjX
            // 
            AdjX.AutoSize = true;
            AdjX.Location = new Point(283, 18);
            AdjX.Name = "AdjX";
            AdjX.Size = new Size(24, 18);
            AdjX.TabIndex = 5;
            AdjX.Text = "45";
            // 
            // ScrollBarX
            // 
            ScrollBarX.LargeChange = 1;
            ScrollBarX.Location = new Point(324, 18);
            ScrollBarX.Maximum = 256;
            ScrollBarX.Minimum = -256;
            ScrollBarX.Name = "ScrollBarX";
            ScrollBarX.Size = new Size(178, 18);
            ScrollBarX.TabIndex = 4;
            ScrollBarX.Value = 45;
            ScrollBarX.Scroll += hScrollBar1_Scroll;
            // 
            // Xlabel
            // 
            Xlabel.AutoSize = true;
            Xlabel.Location = new Point(265, 18);
            Xlabel.Name = "Xlabel";
            Xlabel.Size = new Size(22, 18);
            Xlabel.TabIndex = 3;
            Xlabel.Text = "X:";
            // 
            // button21
            // 
            button21.Location = new Point(177, 28);
            button21.Name = "button21";
            button21.Size = new Size(71, 38);
            button21.TabIndex = 2;
            button21.Text = "Save";
            button21.UseVisualStyleBackColor = true;
            button21.Click += button21_Click;
            // 
            // panel2
            // 
            panel2.Location = new Point(204, 80);
            panel2.Name = "panel2";
            panel2.Size = new Size(512, 513);
            panel2.TabIndex = 1;
            // 
            // FrameListBox
            // 
            FrameListBox.FormattingEnabled = true;
            FrameListBox.ItemHeight = 17;
            FrameListBox.Location = new Point(16, 28);
            FrameListBox.Name = "FrameListBox";
            FrameListBox.Size = new Size(143, 565);
            FrameListBox.TabIndex = 0;
            FrameListBox.SelectedIndexChanged += FrameListBox_SelectedIndexChanged;
            // 
            // label4
            // 
            label4.AutoSize = true;
            label4.Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            label4.Location = new Point(453, 224);
            label4.Name = "label4";
            label4.Size = new Size(77, 18);
            label4.TabIndex = 22;
            label4.Text = "Expression";
            // 
            // comboBox1
            // 
            comboBox1.Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            comboBox1.FormattingEnabled = true;
            comboBox1.Items.AddRange(new object[] { "blink", "hit", "smile", "troubled", "cry", "angry", "bewildered", "stunned", "vomit", "oops", "cheers", "chu", "wink", "pain", "glitter", "despair", "love", "shine", "blaze", "hum", "bowing", "hot", "dam", "qBlue" });
            comboBox1.Location = new Point(533, 222);
            comboBox1.Name = "comboBox1";
            comboBox1.Size = new Size(134, 25);
            comboBox1.TabIndex = 23;
            comboBox1.SelectedIndexChanged += comboBox1_SelectedIndexChanged;
            // 
            // ShowToolTil_CheckBox
            // 
            ShowToolTil_CheckBox.AutoSize = true;
            ShowToolTil_CheckBox.Checked = true;
            ShowToolTil_CheckBox.CheckState = CheckState.Checked;
            ShowToolTil_CheckBox.Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            ShowToolTil_CheckBox.Location = new Point(27, 226);
            ShowToolTil_CheckBox.Name = "ShowToolTil_CheckBox";
            ShowToolTil_CheckBox.Size = new Size(83, 22);
            ShowToolTil_CheckBox.TabIndex = 24;
            ShowToolTil_CheckBox.Text = "Tool Tip";
            ShowToolTil_CheckBox.UseVisualStyleBackColor = true;
            ShowToolTil_CheckBox.CheckedChanged += ShowToolTil_CheckBox_CheckedChanged;
            // 
            // label5
            // 
            label5.AutoSize = true;
            label5.Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            label5.Location = new Point(501, 257);
            label5.Name = "label5";
            label5.Size = new Size(29, 18);
            label5.TabIndex = 25;
            label5.Text = "Ear";
            // 
            // EarListBox
            // 
            EarListBox.Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            EarListBox.FormattingEnabled = true;
            EarListBox.Location = new Point(533, 253);
            EarListBox.Name = "EarListBox";
            EarListBox.Size = new Size(134, 25);
            EarListBox.TabIndex = 26;
            EarListBox.SelectedIndexChanged += EarListBox_SelectedIndexChanged;
            // 
            // AvatarForm
            // 
            AutoScaleMode = AutoScaleMode.None;
            ClientSize = new Size(1103, 903);
            Controls.Add(EarListBox);
            Controls.Add(label5);
            Controls.Add(ShowToolTil_CheckBox);
            Controls.Add(comboBox1);
            Controls.Add(label4);
            Controls.Add(tabControl1);
            Controls.Add(SaveCharButton);
            Controls.Add(button20);
            Controls.Add(button19);
            Controls.Add(button18);
            Controls.Add(button17);
            Controls.Add(button16);
            Controls.Add(button15);
            Controls.Add(button14);
            Controls.Add(button13);
            Controls.Add(button12);
            Controls.Add(button11);
            Controls.Add(button10);
            Controls.Add(button9);
            Controls.Add(button8);
            Controls.Add(button7);
            Controls.Add(button6);
            Controls.Add(button5);
            Controls.Add(button4);
            Controls.Add(button3);
            Controls.Add(button2);
            Controls.Add(button1);
            Font = new Font("Microsoft JhengHei UI", 9F, FontStyle.Regular, GraphicsUnit.Pixel);
            MinimumSize = new Size(1000, 0);
            Name = "AvatarForm";
            StartPosition = FormStartPosition.CenterScreen;
            Text = "Avatar";
            TopMost = true;
            FormClosing += AvatarForm_FormClosing;
            Load += AvatarForm_Load;
            tabControl1.ResumeLayout(false);
            tabPage3.ResumeLayout(false);
            ((System.ComponentModel.ISupportInitialize)DyeGrid).EndInit();
            tabPage7.ResumeLayout(false);
            tabPage7.PerformLayout();
            ((System.ComponentModel.ISupportInitialize)LightnessTrackBar).EndInit();
            ((System.ComponentModel.ISupportInitialize)SatTrackBar).EndInit();
            ((System.ComponentModel.ISupportInitialize)HueTrackBar).EndInit();
            ((System.ComponentModel.ISupportInitialize)DyePicture).EndInit();
            ((System.ComponentModel.ISupportInitialize)DyeGrid2).EndInit();
            tabPage4.ResumeLayout(false);
            tabPage4.PerformLayout();
            panel1.ResumeLayout(false);
            panel1.PerformLayout();
            ((System.ComponentModel.ISupportInitialize)pictureBox1).EndInit();
            tabPage6.ResumeLayout(false);
            tabPage6.PerformLayout();
            ResumeLayout(false);
            PerformLayout();
        }

        #endregion

        private Button button1;
        private Button button2;
        private Button button3;
        private Button button4;
        private Button button5;
        private Button button6;
        private Button button7;
        private Button button8;
        private Button button9;
        private Button button10;
        private Button button11;
        private Button button12;
        private Button button13;
        private Button button14;
        private Button button15;
        private Button button16;
        private Button button17;
        private Button button18;
        private Button button19;
        private Button button20;
        private Button SaveCharButton;
        private TabControl tabControl1;
        private TabPage tabPage1;
        private TabPage tabPage2;
        private TabPage tabPage3;
        private DataGridView DyeGrid;
        private TabPage tabPage4;
        private Panel panel1;
        private Label label2;
        private PictureBox pictureBox1;
        private Label label1;
        private TextBox textBox1;
        private Label label3;
        private Button UseButton;
        private TabPage tabPage5;
        private Label label4;
        public ComboBox comboBox1;
        private CheckBox ShowToolTil_CheckBox;
        private Label label5;
        private ComboBox EarListBox;
        private TabPage tabPage6;
        private ListBox FrameListBox;
        private Panel panel2;
        private Label Xlabel;
        private Button button21;
        private Label label10;
        private HScrollBar ScrollBarH;
        private Label AdjH;
        private Label AdjW;
        private HScrollBar ScrollBarW;
        private Label label13;
        private Label YLabel;
        private HScrollBar ScrollBarY;
        private Label AdjY;
        private Label AdjX;
        private HScrollBar ScrollBarX;
        private TabPage tabPage7;
        private DataGridView DyeGrid2;
        private PictureBox DyePicture;
        private TrackBar SatTrackBar;
        private TrackBar HueTrackBar;
        private TrackBar LightnessTrackBar;
        private Label LabelLightness;
        private Label LabelSat;
        private Label LabelHue;
        private Label label8;
        private Label label7;
        private Label label6;
        private Button button22;
    }
}
```

`MapleNecrocer/AvatarForm.cs`:

```cs
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Net.NetworkInformation;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using DevComponents.DotNetBar.Controls;
using Manina.Windows.Forms;
using Microsoft.Xna.Framework.Graphics;
using WzComparerR2.CharaSim;
using WzComparerR2.CharaSimControl;
using WzComparerR2.Common;
using WzComparerR2.PluginBase;
using WzComparerR2.Text;
using WzComparerR2.WzLib;
using static Manina.Windows.Forms.Utility;

using static System.Windows.Forms.VisualStyles.VisualStyleElement;
using System.Drawing.Imaging;

namespace MapleNecrocer;

public partial class AvatarForm : Form
{
    public AvatarForm()
    {
        InitializeComponent();
        AvatarFormDraw = new();
        AvatarFormDraw.Width = 260;
        AvatarFormDraw.Height = 200;
        AvatarFormDraw.Left = 453;
        AvatarFormDraw.Top = 9;
        AvatarFormDraw.Parent = this;

        FrameListDraw = new();
        FrameListDraw.Width = 512;
        FrameListDraw.Height = 512;
        FrameListDraw.Left = 0;
        FrameListDraw.Top = 0;
        FrameListDraw.Parent = panel2;
        Instance = this;
    }
    private string[] AllFrames = {"walk1.0", "walk1.1", "walk1.2", "walk1.3", "walk2.0", "walk2.1", "walk2.2", "walk2.3",
        "stand1.0", "stand1.1", "stand1.2", "stand2.0", "stand2.1", "stand2.2", "alert.0", "alert.1", "alert.2",
        "swingO1.0", "swingO1.1", "swingO1.2", "swingO2.0", "swingO2.1", "swingO2.2", "swingO3.0", "swingO3.1", "swingO3.2",
        "swingOF.0", "swingOF.1", "swingOF.2", "swingOF.3",
        "swingT1.0", "swingT1.1", "swingT1.2", "swingT2.0", "swingT2.1", "swingT2.2", "swingT3.0", "swingT3.1", "swingT3.2",
        "swingTF.0", "swingTF.1", "swingTF.2", "swingTF.3",
        "swingP1.0", "swingP1.1", "swingP1.2", "swingP2.0", "swingP2.1", "swingP2.2",
        "swingPF.0", "swingPF.1", "swingPF.2", "swingPF.3",
        "stabO1.0", "stabO1.1", "stabO2.0", "stabO2.1", "stabOF.0", "stabOF.1", "stabOF.2",
        "stabT1.0", "stabT1.1", "stabT1.2", "stabT2.0", "stabT2.1", "stabT2.2", "stabTF.0", "stabTF.1", "stabTF.2", "stabTF.3",
        "shoot1.0", "shoot1.1", "shoot1.2", "shoot2.0", "shoot2.1", "shoot2.2", "shoot2.3", "shoot2.4", "shootF.0", "shootF.1", "shootF.2",
        "proneStab.0", "proneStab.1", "prone.0", "heal.0", "heal.1", "heal.2", "fly.0", "fly.1", "jump.0", "sit.0", "ladder.0", "ladder.1", "rope.0", "rope.1", "rope.1" };
    private static bool LoadedFrameList;
    public static bool SelectedFrame;
    public static int SelectedFrameNum;
    public static string SelectedAction;
    public static int AdjustX = 45, AdjustY = 18, AdjustW = 200, AdjustH = 200;
    public static bool ChangeExpressionListBox;
    public static AvatarForm Instance;
    public static AvatarFormDraw AvatarFormDraw;
    public static FrameListDraw FrameListDraw;
    static bool ShowToolTip = true;
    ImageListView[] ImageGrids = new ImageListView[21];
    ImageListView AvatarListView;
    public DataGridViewEx Inventory;
    public DataGridViewEx SearchGrid;
    void AddInventory()
    {
        if (Inventory.Columns.Count == 4)
        {
            Inventory.Columns.RemoveAt(3);
        }
        DataGridViewButtonColumn dgvButton = new DataGridViewButtonColumn();
        dgvButton.Width = 29;
        dgvButton.UseColumnTextForButtonValue = true;
        dgvButton.Text = "X";
        dgvButton.AutoSizeMode = DataGridViewAutoSizeColumnMode.None;
        dgvButton.CellTemplate.Style.Padding = new Padding(2, 10, 2, 10);
        Inventory.Columns.Add(dgvButton);

        Inventory.Rows.Clear();

        Player.EqpList.Sort();
        for (int i = 0; i < Player.EqpList.Count; i++)
        {
            var ID = Player.EqpList[i];

            string Dir = Equip.GetDir(ID);
            string Name = "";
            if (Wz.HasNode("String/Eqp.img"))
                Name = Wz.GetNodeA("String/Eqp.img/Eqp").GetStr(Dir + ID.IntID() + "/name");
            else if (Wz.HasNode("String/Item.img/Eqp"))
                Name = Wz.GetNodeA("String/Item.img/Eqp").GetStr(Dir + ID.IntID() + "/name");
            var Entry = Wz.GetNodeA("Character/" + Dir + ID + ".img");
            PartName PartName = Equip.GetPart(ID);

            Bitmap Bmp;
            switch (PartName)
            {
                case PartName.Head:
                    Bmp = Entry.GetNode("front/head").ExtractPng();
                    break;
                case PartName.Body:
                    Bmp = Entry.GetNode("stand1/0/body").ExtractPng();
                    break;
                case PartName.Hair:
                    Bmp = Entry.GetNode("default/hairOverHead").ExtractPng();
                    break;
                case PartName.Face:
                    Bmp = Entry.GetNode("default/face").ExtractPng();
                    break;
                default:
                    Bmp = Entry.GetNode("info/icon").ExtractPng();
                    break;
            }
            Inventory.Rows.Add(ID, Bmp, Name);
        }

        for (int i = 0; i < Inventory.Rows.Count; i++)
        {
            Inventory.Rows[i].Cells[1].Style.Alignment = DataGridViewContentAlignment.MiddleCenter;
            Inventory.Rows[i].Cells[2].Style.Alignment = DataGridViewContentAlignment.TopLeft;
        }
        if (Inventory.Columns.Count > 2)
        {
            DataGridViewCellStyle dataGridViewCellStyle2 = new DataGridViewCellStyle();
            dataGridViewCellStyle2.Padding = new Padding(0, 0, 1000, 0);
            Inventory.Rows[0].Cells[3].Style = dataGridViewCellStyle2;
            Inventory.Rows[1].Cells[3].Style = dataGridViewCellStyle2;
        }
    }

    void AddEqps(string EqpID)
    {
        string NewID = EqpID;
        PartName NewPart = Equip.GetPart(EqpID);
        if (NewPart == PartName.SitTamingMob)
            return;

        for (int i = Player.EqpList.Count - 1; i >= 0; i--)
        {
            var OldPart = Equip.GetPart(Player.EqpList[i]);

            if (NewPart == OldPart)
            {
                SetEffect.Remove(Player.EqpList[i]);
                ItemEffect.Remove(Player.EqpList[i]);
                Player.EqpList.RemoveAt(i);
            }
            if ((NewPart == PartName.Weapon) && (OldPart == PartName.CashWeapon))
                Player.EqpList.RemoveAt(i);
            if ((NewPart == PartName.CashWeapon) && (OldPart == PartName.Weapon))
                Player.EqpList.RemoveAt(i);
            if ((NewPart == PartName.Coat) || (NewPart == PartName.Pants))
            {
                if (OldPart == PartName.Longcoat)
                    Player.EqpList.RemoveAt(i);
            }
            if (NewPart == PartName.Longcoat)
            {
                if ((OldPart == PartName.Coat) || (OldPart == PartName.Pants))
                    Player.EqpList.RemoveAt(i);
            }
        }

        Player.EqpList.Add(NewID);

        if (ItemEffect.AllList.Contains(EqpID))
            ItemEffect.Create(EqpID, EffectType.Equip);

        if (SetEffect.AllList.ContainsKey(EqpID))
            SetEffect.Create(EqpID);
    }
    void ResetDyeGrid()
    {
        DyeGrid.Rows.Clear();
        DyeGrid.Columns.Clear();
        for (int i = 0; i <= 16; i++)
        {
            var Icon = new DataGridViewImageColumn();
            DyeGrid.Columns.AddRange(Icon);
        }

        for (int i = 0; i < Inventory.RowCount; i++)
        {
            if (Inventory.Rows[i].Cells[1].Value is Bitmap)
            {
                var Bmp = (Bitmap)Inventory.Rows[i].Cells[1].Value;
                DyeGrid.Rows.Add(Bmp, Bmp, Bmp, Bmp, Bmp, Bmp, Bmp, Bmp, Bmp, Bmp, Bmp, Bmp, Bmp, Bmp, Bmp, Bmp, Bmp);
            }
        }

        for (int Col = 0; Col <= 16; Col++)
        {
            for (int Row = 0; Row < DyeGrid.RowCount; Row++)
            {
                var Bmp = (Bitmap)DyeGrid.Rows[Row].Cells[Col].Value;
                if (Col <= 15)
                    ImageFilter.HSL(ref Bmp, Col * 25);
                else
                    ImageFilter.HSL(ref Bmp, 0, -200);
                DyeGrid.Rows[Row].Cells[Col].Value = Bmp;
            }
            DyeGrid.Columns[Col].Width = 45;
        }
    }

    void ResetDyeGrid2()
    {
        DyeGrid2.Rows.Clear();
        DyeGrid2.Columns.Clear();
        if (DyeGrid2.Columns.Count == 0)
        {
            foreach (DataGridViewColumn dgvc in Inventory.Columns)
            {
                DyeGrid2.Columns.Add(dgvc.Clone() as DataGridViewColumn);
            }
        }

        DataGridViewRow row = new DataGridViewRow();

        for (int i = 0; i < Inventory.Rows.Count; i++)
        {
            row = (DataGridViewRow)Inventory.Rows[i].Clone();
            int intColIndex = 0;
            foreach (DataGridViewCell cell in Inventory.Rows[i].Cells)
            {
                row.Cells[intColIndex].Value = cell.Value;
                intColIndex++;
            }
            DyeGrid2.Rows.Add(row);
        }

        DyeGrid2.AllowUserToAddRows = false;
        DyeGrid2.Refresh();
        DyeGrid2.Columns[3].Visible = false;
    }

    private void AvatarForm_Load(object sender, EventArgs e)
    {

        this.FormClosing += (s, e1) =>
        {
            this.Hide();
            e1.Cancel = true;
        };

        for (int i = 1; i <= 20; i++)
        {
            ImageGrids[i] = new ImageListView();
            ImageGrids[i].Parent = tabControl1.TabPages[0];
            ImageGrids[i].Anchor = (AnchorStyles.Left | AnchorStyles.Right | AnchorStyles.Top | AnchorStyles.Bottom);
            ImageGrids[i].Dock = DockStyle.Fill;
            ImageGrids[i].BackColor = SystemColors.Window;
            ImageGrids[i].Colors.BackColor = SystemColors.ButtonFace;
            ImageGrids[i].Colors.SelectedBorderColor = Color.Red;

            ImageGrids[i].BorderStyle = BorderStyle.Fixed3D;
            ImageGrids[i].ThumbnailSize = new System.Drawing.Size(32, 32);
            ImageGrids[i].ItemClick += (o, e) =>
            {
                AddEqps(e.Item.FileName);
                AddInventory();
                Game.Player.RemoveSprites();
                for (int i = 0; i < Player.EqpList.Count; i++)
                {
                    Game.Player.Spawn(Player.EqpList[i]);
                }
                ResetDye2();
            };
            ImageGrids[i].ItemHover += (o, e) =>
            {
                if (ShowToolTip)
                {
                    if (e.Item == null) return;
                    Wz_Node Node = Wz.GetNodeByID(e.Item.FileName, WzType.Character);
                    MainForm.Instance.QuickView(Node);
                    MainForm.Instance.ToolTipView.Owner = this;

                }
            };

        }

        AvatarListView = new ImageListView();
        AvatarListView.Parent = tabControl1.TabPages[1];
        AvatarListView.Anchor = (AnchorStyles.Left | AnchorStyles.Right | AnchorStyles.Top | AnchorStyles.Bottom);
        AvatarListView.Dock = DockStyle.Fill;
        AvatarListView.BackColor = SystemColors.Window;
        AvatarListView.Colors.BackColor = SystemColors.ButtonFace;
        AvatarListView.Colors.SelectedBorderColor = Color.Red;
        AvatarListView.Colors.HoverColor1 = SystemColors.ButtonFace;
        AvatarListView.Colors.HoverColor2 = SystemColors.ButtonFace;
        AvatarListView.BorderStyle = BorderStyle.Fixed3D;
        AvatarListView.ThumbnailSize = new System.Drawing.Size(100, 100);
        AvatarListView.ItemClick += (o, e) =>
        {
            ResetDye2();
            switch (tabControl1.SelectedIndex)
            {
                case 1:
                    foreach (var Iter in ItemEffect.UseList.Keys)
                        ItemEffect.UseList[Iter].Dead();
                    ItemEffect.UseList.Clear();

                    foreach (var Iter in SetEffect.UseList.Keys)
                        SetEffect.UseList[Iter].Dead();
                    SetEffect.UseList.Clear();

                    Player.EqpList.Clear();
                    Game.Player.ShowHair = false;
                    Game.Player.DressCap = false;
                    Game.Player.RemoveSprites();

                    string[] Split = e.Item.FileName.Split("-");
                    var EqpList = Split.ToList();
                    EqpList.Sort();
                    for (int i = 1; i < EqpList.Count; i++)
                    {
                        AddEqps(EqpList[i]);
                        Game.Player.Spawn(EqpList[i]);
                    }
                    AddInventory();
                    break;
                case 5:
                    string IDs = e.Item.FileName;
                    PlayerEx.Spawn(IDs);
                    break;
            }
        };

        Inventory = new(75, 174, 795, 8, 300, 880, true, this);
        Inventory.RowTemplate.Height = 45;
        Inventory.DefaultCellStyle.WrapMode = DataGridViewTriState.True;
        Inventory.Columns[2].AutoSizeMode = DataGridViewAutoSizeColumnMode.Fill;
        Inventory.DefaultCellStyle.Font = new Font("Tahoma", 15, GraphicsUnit.Pixel);
        Inventory.Anchor = (AnchorStyles.Right | AnchorStyles.Top | AnchorStyles.Bottom);
        Inventory.DefaultCellStyle.SelectionBackColor = System.Drawing.Color.White;
        Inventory.DefaultCellStyle.SelectionForeColor = System.Drawing.Color.Black;
        Inventory.CellContentClick += (s, e) =>
        {
            if (e.ColumnIndex != 3)
                return;
            int Row = e.RowIndex;
            var Part = Equip.GetPart(Player.EqpList[Row]);
            string DeleteID = Player.EqpList[Row];
            Player.EqpList.RemoveAt(Row);

            if (ItemEffect.AllList.Contains(DeleteID))
                ItemEffect.Remove(DeleteID);
            if (SetEffect.AllList.ContainsKey(DeleteID))
                SetEffect.Remove(DeleteID);

            var ID = Inventory.Rows[e.RowIndex].Cells[0].Value.ToString();
            Inventory.Rows.RemoveAt(e.RowIndex);
            switch (Part)
            {
                case PartName.Hair:
                    Game.Player.ShowHair = false;
                    break;
                case PartName.Cap:
                    Game.Player.DressCap = false;
                    break;
            }
            Player.EqpList.Sort();
            Game.Player.RemoveSprites();
            for (int i = 0; i < Player.EqpList.Count; i++)
            {
                Game.Player.Spawn(Player.EqpList[i]);
            }
            if (tabControl1.SelectedIndex == 2)
                ResetDyeGrid();
            if (tabControl1.SelectedIndex == 3)
                ResetDyeGrid2();
            ResetDye2();
        };

        Inventory.SetToolTipEvent(WzType.Character, this);

        AddEqps("00002000");
        AddInventory();
        ResetDyeGrid();
        ResetDyeGrid2();
        foreach (var Iter in Wz.GetNodes("Character/00012000.img/front"))
        {
            if (Iter.Text != "head")
            {
                EarListBox.Items.Add(Iter.Text);
            }
        }

        if (EarListBox.Items.Count == 0)
        {
            EarListBox.Visible = false;
            label5.Visible = false;
        }

    }


    List<string> PartList = new();
    private void button1_Click(object sender, EventArgs e)
    {
        MainForm.Instance.ToolTipView.Visible = false;
        tabControl1.SelectedIndex = 0;
        string CharacterDir = "";
        string ButtonText = ((System.Windows.Forms.Button)sender).Text.Trim(' ');

        switch (ButtonText)
        {
            case "Head":
            case "Body":
                CharacterDir = "";
                break;
            case "Weapon-1":
            case "Weapon-2":
                CharacterDir = "Weapon";
                break;
            case "Cap-1":
            case "Cap-2":
                CharacterDir = "Cap";
                break;
            case "Hair-1":
            case "Hair-2":
                CharacterDir = "Hair";
                break;
            case "Face-1":
            case "Face-2":
                CharacterDir = "Face";
                break;
            case "FaceAcc":
            case "Glass":
            case "Earring":
                CharacterDir = "Accessory";
                break;
            default:
                CharacterDir = ButtonText;
                break;
        }
        int PartIndex = ((System.Windows.Forms.Button)sender).Tag.ToString().ToInt();
        for (int i = 1; i <= 20; i++)
            ImageGrids[i].Visible = false;
        ImageGrids[PartIndex].Visible = true;

        if (!PartList.Contains(ButtonText))
        {
            var Graphic = ImageGrids[PartIndex].CreateGraphics();
            var Font = new System.Drawing.Font(FontFamily.GenericSansSerif, 20, FontStyle.Bold);
            Graphic.DrawString("Loading...", Font, Brushes.Black, 150, 150);

            Wz_Node.WzNodeCollection Dir = null;
            string Path = "";
            if (CharacterDir == "")
            {
                Dir = MainForm.TreeNode.Nodes["Character"].Nodes;
                Path = "Character/";
            }
            else
            {
                Dir = MainForm.TreeNode.Nodes["Character"].Nodes[CharacterDir].Nodes;
                Path = "Character/" + CharacterDir + "/";
            }

            int Num = 0;
            bool InRange(int Low, int High) => (Num >= Low) && (Num <= High);

            Win32.SendMessage(ImageGrids[PartIndex].Handle, false);
            foreach (var img in Dir)
            {
                if (!Char.IsNumber(img.Text[0]))
                    continue;
                switch (ButtonText)
                {
                    case "Head":
                        if (img.Text.LeftStr(4) == "0000")
                            continue;
                        break;
                    case "Body":
                        if (img.Text.LeftStr(4) == "0001")
                            continue;
                        break;
                }

                foreach (var Iter in Wz.GetNodeA(Path + img.Text).Nodes)
                {
                    string Left4() => Iter.ImgName().LeftStr(4);
                    Num = Iter.ImgID().ToInt() / 1000;
                    switch (ButtonText)
                    {
                        case "Weapon-1":
                            if (Left4() == "0170")
                                continue;
                            break;
                        case "Weapon-2":
                            if (Left4() != "0170")
                                continue;
                            break;
                        case "Cap-1":
                            if (!InRange(1000, 1003))
                                continue;
                            break;
                        case "Cap-2":
                            if (!InRange(1004, 1006))
                                continue;
                            break;
                        case "Hair-1":
                            if (!InRange(30, 56))
                                continue;
                            break;
                        case "Hair-2":
                            if (!InRange(57, 85))
                                continue;
                            break;
                        case "Face-1":
                            if (!InRange(20, 23))
                                continue;
                            break;
                        case "Face-2":
                            if (!InRange(24, 65))
                                continue;
                            break;
                        case "FaceAcc":
                            if (Left4() != "0101")
                                continue;
                            break;
                        case "Glass":
                            if (Left4() != "0102")
                                continue;
                            break;
                        case "Earring":
                            if (Left4() != "0103")
                                continue;
                            break;
                    }

                    switch (ButtonText)
                    {
                        case "Head":
                            if (Iter.Text == "front")
                                ImageGrids[PartIndex].Items.Add(img.ImgID(), Iter.GetNode("head").ExtractPng());
                            break;
                        case "Body":
                            if (Iter.Text == "stand1")
                                ImageGrids[PartIndex].Items.Add(img.ImgID(), Iter.GetNode("0/body").ExtractPng());
                            break;
                        case "Face-1":
                        case "Face-2":
                            if (Iter.Nodes["face"] != null)
                                ImageGrids[PartIndex].Items.Add(Iter.ImgID(), Iter.GetNode("face").ExtractPng());
                            break;
                        case "Hair-1":
                        case "Hair-2":
                            if (Iter.Nodes["hairOverHead"] != null)
                                ImageGrids[PartIndex].Items.Add(Iter.ImgID(), Iter.GetNode("hairOverHead").ExtractPng());
                            break;
                        default:
                            if (Iter.Nodes["icon"] != null)
                                ImageGrids[PartIndex].Items.Add(Iter.ImgID(), Iter.GetNode("icon").ExtractPng());
                            break;
                    }
                }

            }
            Win32.SendMessage(ImageGrids[PartIndex].Handle, true);
            ImageGrids[PartIndex].Refresh();
            PartList.Add(ButtonText);
        }

    }

    private void SaveCharButton_Click(object sender, EventArgs e)
    {
        RenderTarget2D SaveTexture = null;
        int WX = (int)(Game.Player.X - EngineFunc.SpriteEngine.Camera.X - 55);
        int WY = (int)(Game.Player.Y - EngineFunc.SpriteEngine.Camera.Y - 90);
        EngineFunc.Canvas.DrawTarget(ref SaveTexture, 100, 100, () =>
        {
            EngineFunc.Canvas.DrawCropArea(AvatarFormDraw.AvatarPanelTexture, 0, 0, new Microsoft.Xna.Framework.Rectangle(WX, WY, WX + 100, WY + 100), 0, 0, 1, 1, 0, false, false, 255, 255, 255, 255, false);
        });

        string PngName = "";
        for (int i = 0; i < Player.EqpList.Count; i++)
            PngName = PngName + Player.EqpList[i] + "-";

        Stream stream = File.OpenWrite(System.Environment.CurrentDirectory + "\\Images\\" + PngName + ".png");
        SaveTexture.SaveAsPng(stream, 100, 100);
        stream.Dispose();
        SaveTexture.Dispose();

        Bitmap Png = new Bitmap(System.Environment.CurrentDirectory + "\\Images\\" + PngName + ".png");
        AvatarListView.Items.Add(PngName, Png);
        Png.Dispose();
    }

    static bool Loaded;
    static bool SearchGridLoaded;

    void DumpEqpString(Wz_Node Node)
    {
        if (Node.Text == "name")
        {
            if (Node.ParentNode.Text.Length == 5)
                SearchGrid.Rows.Add("000" + Node.ParentNode.Text, " " + Node.ToStr());
            else
                SearchGrid.Rows.Add("0" + Node.ParentNode.Text, " " + Node.ToStr());
        }
        foreach (var Iter in Node.Nodes)
        {
            if ((Node.Text != "Android") && (Node.Text != "ArcaneForce") && (Node.Text != "Bits") && (Node.Text != "Dragon") &&
             (Node.Text != "Mechanic") && (Node.Text != "PetEquip") && (Node.Text != "Skillskin") && (Node.Text != "Taming") &&
             (Node.Text != "MonsterBattle") && (Node.Text.LeftStr(3) != "135") && (Node.Text.LeftStr(3) != "150") &&
             (Node.Text.LeftStr(3) != "151") && (Node.Text.LeftStr(3) != "160") && (Node.Text.LeftStr(3) != "169") &&
             (Node.Text.LeftStr(3) != "111") && (Node.Text.LeftStr(3) != "112") && (Node.Text.LeftStr(3) != "114"))
                DumpEqpString(Iter);
        }
    }

    void CellClick(BaseDataGridView DataGrid, DataGridViewCellEventArgs e)
    {
        var ID = DataGrid.Rows[e.RowIndex].Cells[0].Value.ToString();
        label1.Text = ID;
        label2.Text = DataGrid.Rows[e.RowIndex].Cells[1].Value.ToString();
        string Dir = Equip.GetDir(ID);
        string Name = "";
        // if (Wz.IsDataWz)
        //   Name = Wz.GetStr("String/Eqp.img/Eqp/" + Dir + ID.IntID() + "/name");
        // else
        //   Name = Wz.GetStr("String/Item.img/Eqp/" + Dir + ID.IntID() + "/name");
        var Entry = Wz.GetNodeA("Character/" + Dir + ID + ".img");
        PartName PartName = Equip.GetPart(ID);
        Bitmap Bmp = null;
        if (Bmp != null)
            Bmp.Dispose();
        switch (PartName)
        {
            case PartName.Hair:
                Bmp = Entry.GetNode("default/hairOverHead").ExtractPng();
                break;
            case PartName.Face:
                Bmp = Entry.GetNode("default/face").ExtractPng();
                break;
            default:
                Bmp = Entry.GetNode("info/icon").ExtractPng();
                break;
        }
        pictureBox1.Image = Bmp;

    }
    private void tabControl1_SelectedIndexChanged(object sender, EventArgs e)
    {
        if (tabControl1.SelectedIndex != 0)
            MainForm.Instance.ToolTipView.Visible = false;

        void LoadAvatarPics()
        {
            string[] Files = Directory.GetFiles(System.Environment.CurrentDirectory + "\\Images");
            foreach (var i in Files)
            {
                string Name = Path.GetFileName(i);
                Name = Name.Replace(".png", "");
                Bitmap Png = new Bitmap(i);
                AvatarListView.Items.Add(Name, Png);
                Png.Dispose();
            }
        }

        switch (tabControl1.SelectedIndex)
        {
            case 0:

                if (MainForm.Instance.ToolTipView.Parent != null)
                {
                    MainForm.Instance.ToolTipView.Dispose();
                    MainForm.Instance.ToolTipView = null;
                    MainForm.Instance.ToolTipView = new AfrmTooltip();
                    MainForm.Instance.ToolTipView.Visible = true;
                    MainForm.Instance.ToolTipView.StringLinker = MainForm.Instance.stringLinker;
                    MainForm.Instance.ToolTipView.ShowID = true;
                    MainForm.Instance.ToolTipView.ShowMenu = true;
                    MainForm.Instance.ToolTipView.StartPosition = FormStartPosition.CenterParent;
                }
                SelectedFrame = false;
                break;
            case 1:
                if (!Loaded)
                {
                    LoadAvatarPics();
                    Loaded = true;
                }
                AvatarListView.Parent = tabControl1.TabPages[1];
                SelectedFrame = false;
                break;
            case 2:
                ResetDyeGrid();

                SelectedFrame = false;
                break;

            case 3:
                ResetDyeGrid2();
                SelectedFrame = false;
                break;
            case 4:
                if (!SearchGridLoaded)
                {
                    SearchGrid = new(60, 184, 114, 109, 315, 400, false, tabControl1.TabPages[4]);
                    SearchGrid.CellClick += (s, e) =>
                    {
                        CellClick(SearchGrid, e);
                    };

                    SearchGrid.SearchGrid.CellClick += (s, e) =>
                    {
                        CellClick(SearchGrid.SearchGrid, e);
                    };


                    SearchGrid.CellMouseEnter += (s, e) =>
                    {
                        if (e.RowIndex >= 0 && e.ColumnIndex >= 0)
                        {
                            SearchGrid[0, e.RowIndex].Style.BackColor = Color.LightCyan;
                            SearchGrid[1, e.RowIndex].Style.BackColor = Color.LightCyan;
                        }
                        if (ShowToolTip)
                        {
                            string ID = SearchGrid.Rows[e.RowIndex].Cells[0].Value.ToString();
                            Wz_Node Node = Wz.GetNodeByID(ID, WzType.Character);
                            MainForm.Instance.QuickView(Node);
                            // MainForm.Instance.ToolTipView.Location = new Point(448, 395);
                        }
                    };

                    SearchGrid.CellMouseLeave += (s, e) =>
                    {
                        if (e.RowIndex >= 0 && e.ColumnIndex >= 0)
                        {
                            SearchGrid[0, e.RowIndex].Style.BackColor = Color.White;
                            SearchGrid[1, e.RowIndex].Style.BackColor = Color.White;
                        }
                    };

                    SearchGrid.SearchGrid.CellMouseEnter += (s, e) =>
                    {
                        if (e.RowIndex >= 0 && e.ColumnIndex >= 0)
                        {
                            SearchGrid.SearchGrid[0, e.RowIndex].Style.BackColor = Color.LightCyan;
                            SearchGrid.SearchGrid[1, e.RowIndex].Style.BackColor = Color.LightCyan;
                        }
                        if (ShowToolTip)
                        {
                            string ID = SearchGrid.SearchGrid.Rows[e.RowIndex].Cells[0].Value.ToString();
                            Wz_Node Node = Wz.GetNodeByID(ID, WzType.Character);
                            MainForm.Instance.QuickView(Node);
                            // MainForm.Instance.ToolTipView.Location = new Point(448, 395);
                        }
                    };

                    SearchGrid.SearchGrid.CellMouseLeave += (s, e) =>
                    {
                        if (e.RowIndex >= 0 && e.ColumnIndex >= 0)
                        {
                            SearchGrid.SearchGrid[0, e.RowIndex].Style.BackColor = Color.White;
                            SearchGrid.SearchGrid[1, e.RowIndex].Style.BackColor = Color.White;
                        }
                    };

                    var Graphic = SearchGrid.CreateGraphics();
                    var Font = new System.Drawing.Font(FontFamily.GenericSansSerif, 20, FontStyle.Bold);
                    Graphic.DrawString("Loading...", Font, Brushes.Black, 10, 50);

                    string ID = null;
                    string name = null;
                    Win32.SendMessage(SearchGrid.Handle, false);
                    if (Wz.IsDataWz)
                        DumpEqpString(Wz.GetNodeA("String/Item.img/Eqp"));
                    else
                        DumpEqpString(Wz.GetNodeA("String/Eqp.img/Eqp"));
                    Win32.SendMessage(SearchGrid.Handle, true);
                    SearchGrid.Refresh();
                    SearchGridLoaded = true;
                }
                // MainForm.Instance.ToolTipView.TopLevel = false;
                // MainForm.Instance.ToolTipView.IsMdiContainer = false;
                // MainForm.Instance.ToolTipView.Parent = this;
                SelectedFrame = false;
                break;

            case 5:
                if (!Loaded)
                {
                    LoadAvatarPics();
                    Loaded = true;
                }
                AvatarListView.Parent = tabControl1.TabPages[5];
                SelectedFrame = false;
                break;

            case 6:
                if (!LoadedFrameList)
                {
                    foreach (var i in AllFrames)
                        FrameListBox.Items.Add(i);
                    LoadedFrameList = true;
                }

                break;
        }

    }

    private void DyeGrid_CellClick(object sender, DataGridViewCellEventArgs e)
    {

        int Col = e.ColumnIndex;
        string ID = Inventory.Rows[e.RowIndex].Cells[0].Value.ToString();
        string Dir = Equip.GetDir(ID);
        Wz_Node Entry;
        if (ItemEffect.AllList.Contains(ID))
            Entry = Wz.GetNodeA("Effect/ItemEff.img/" + ID.IntID());
        else
            Entry = Wz.GetNodeA("Character/" + Dir + ID + ".img");

        if (Col <= 15)
            Wz.DumpData(Entry, Wz.EquipData, Wz.EquipImageLib, true, Col * 25);
        else
            Wz.DumpData(Entry, Wz.EquipData, Wz.EquipImageLib, true, 0, -200);
    }

    private void textBox1_TextChanged(object sender, EventArgs e)
    {
        SearchGrid.Search(textBox1.Text);
    }

    private void UseButton_Click(object sender, EventArgs e)
    {
        if (label1.Text == "")
            return;
        AddEqps(label1.Text);
        AddInventory();
        Game.Player.RemoveSprites();
        for (int i = 0; i < Player.EqpList.Count; i++)
        {
            Game.Player.Spawn(Player.EqpList[i]);
        }

        ResetDye2();
    }

    private void comboBox1_SelectedIndexChanged(object sender, EventArgs e)
    {
        ChangeExpressionListBox = true;
    }



    private void ShowToolTil_CheckBox_CheckedChanged(object sender, EventArgs e)
    {
        ShowToolTip = !ShowToolTip;
        MainForm.Instance.ToolTipView.Visible = ShowToolTip;
    }


    private void AvatarForm_FormClosing(object sender, FormClosingEventArgs e)
    {
        MainForm.Instance.ToolTipView.Visible = false;
        SelectedFrame = false;
    }

    private void EarListBox_SelectedIndexChanged(object sender, EventArgs e)
    {
        Game.Player.EarType = EarListBox.Text;
    }

    private void FrameListBox_SelectedIndexChanged(object sender, EventArgs e)
    {
        SelectedFrame = true;
        string SelectedItem = FrameListBox.SelectedItem.ToString();
        var Split = SelectedItem.Split('.');
        SelectedFrameNum = Split[1].ToInt();
        SelectedAction = Split[0];
    }

    private void button21_Click(object sender, EventArgs e)
    {
        RenderTarget2D SaveTexture = null;
        int WX = (int)(Game.Player.X - EngineFunc.SpriteEngine.Camera.X - 155) + AdjustX;
        int WY = (int)(Game.Player.Y - EngineFunc.SpriteEngine.Camera.Y - 160) + AdjustY;

        int Width = WX + AdjustW - WX;
        int Height = WY + AdjustH - WY;
        EngineFunc.Canvas.DrawTarget(ref SaveTexture, Width, Height, () =>
        {
            EngineFunc.Canvas.DrawCropArea(FrameListDraw.AvatarPanelTexture, 0, 0, new Microsoft.Xna.Framework.Rectangle(WX, WY, WX + AdjustW, WY + AdjustH), 0, 0, 1, 1, 0, false, false, 255, 255, 255, 255, false);
        });
        Stream stream = File.OpenWrite(System.Environment.CurrentDirectory + "\\Export\\" + FrameListBox.SelectedItem.ToString() + ".png");
        SaveTexture.SaveAsPng(stream, Width, Height);
        stream.Dispose();
        SaveTexture.Dispose();
    }

    private void hScrollBar1_Scroll(object sender, ScrollEventArgs e)
    {
        switch (((HScrollBar)sender).Name)
        {
            case "ScrollBarX":
                AdjX.Text = ScrollBarX.Value.ToString();
                AdjustX = ScrollBarX.Value;
                break;
            case "ScrollBarY":
                AdjY.Text = ScrollBarY.Value.ToString();
                AdjustY = AdjY.Text.ToInt();
                break;
            case "ScrollBarW":
                AdjW.Text = ScrollBarW.Value.ToString();
                AdjustW = AdjW.Text.ToInt();
                break;
            case "ScrollBarH":
                AdjH.Text = ScrollBarH.Value.ToString();
                AdjustH = AdjH.Text.ToInt();
                break;

        }
    }


    int RowIndex;

    private void DyeGrid2_CellClick(object sender, DataGridViewCellEventArgs e)
    {
        HueTrackBar.Value = 0;
        SatTrackBar.Value = 0;
        LightnessTrackBar.Value = 0;
        LabelHue.Text = "0";
        LabelSat.Text = "0";
        LabelLightness.Text = "0";
        DyePicture.Image = (Bitmap)DyeGrid2.Rows[e.RowIndex].Cells[1].Value;
        RowIndex = e.RowIndex;
    }
   

    void SetDye2()
    {
        if (DyePicture.Image == null)
            return;
        Bitmap Bmp = (Bitmap)DyeGrid2.Rows[RowIndex].Cells[1].Value;
        Bitmap Image = null;
        ImageFilter.HSL(ref Bmp, HueTrackBar.Value, SatTrackBar.Value, LightnessTrackBar.Value);
       
        DyePicture.Image = Bmp;
        LabelHue.Text = HueTrackBar.Value.ToString();
        LabelSat.Text = SatTrackBar.Value.ToString();
        LabelLightness.Text = LightnessTrackBar.Value.ToString();
    }

    void ResetDye2()
    {
        DyePicture.Image = null;
        HueTrackBar.Value = 0;
        SatTrackBar.Value = 0;
        LightnessTrackBar.Value = 0;
        LabelHue.Text = "0";
        LabelSat.Text = "0";
        LabelLightness.Text = "0";
    }

    private void HueTrackBar_Scroll(object sender, EventArgs e)
    {
        SetDye2();
    }

    private void SatTrackBar_Scroll(object sender, EventArgs e)
    {
        SetDye2();
    }

    private void LightnessTrackBar_Scroll(object sender, EventArgs e)
    {
        SetDye2();
    }

    private void button22_Click(object sender, EventArgs e)
    {
        string ID = DyeGrid2.Rows[RowIndex].Cells[0].Value.ToString();
        string Dir = Equip.GetDir(ID);
        Wz_Node Entry;
        if (ItemEffect.AllList.Contains(ID))
            Entry = Wz.GetNodeA("Effect/ItemEff.img/" + ID.IntID());
        else
            Entry = Wz.GetNodeA("Character/" + Dir + ID + ".img");

        Wz.DumpData(Entry, Wz.EquipData, Wz.EquipImageLib, true, HueTrackBar.Value, SatTrackBar.Value, LightnessTrackBar.Value);
    }
}


```

`MapleNecrocer/AvatarForm.resx`:

```resx
<root>
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <assembly alias="System.Drawing" name="System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
  <data name="button1.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAACAAAAAdCAYAAADLnm6HAAAABGdBTUEAALGOfPtRkwAAACBjSFJNAACH
        DwAAjA8AAP1SAACBQAAAfXkAAOmLAAA85QAAGcxzPIV3AAAKOWlDQ1BQaG90b3Nob3AgSUNDIHByb2Zp
        bGUAAEjHnZZ3VFTXFofPvXd6oc0w0hl6ky4wgPQuIB0EURhmBhjKAMMMTWyIqEBEEREBRZCggAGjoUis
        iGIhKKhgD0gQUGIwiqioZEbWSnx5ee/l5ffHvd/aZ+9z99l7n7UuACRPHy4vBZYCIJkn4Ad6ONNXhUfQ
        sf0ABniAAaYAMFnpqb5B7sFAJC83F3q6yAn8i94MAUj8vmXo6U+ng/9P0qxUvgAAyF/E5mxOOkvE+SJO
        yhSkiu0zIqbGJIoZRomZL0pQxHJijlvkpZ99FtlRzOxkHlvE4pxT2clsMfeIeHuGkCNixEfEBRlcTqaI
        b4tYM0mYzBXxW3FsMoeZDgCKJLYLOKx4EZuImMQPDnQR8XIAcKS4LzjmCxZwsgTiQ7mkpGbzuXHxArou
        S49uam3NoHtyMpM4AoGhP5OVyOSz6S4pyalMXjYAi2f+LBlxbemiIluaWltaGpoZmX5RqP+6+Dcl7u0i
        vQr43DOI1veH7a/8UuoAYMyKarPrD1vMfgA6tgIgd/8Pm+YhACRFfWu/8cV5aOJ5iRcIUm2MjTMzM424
        HJaRuKC/6386/A198T0j8Xa/l4fuyollCpMEdHHdWClJKUI+PT2VyeLQDf88xP848K/zWBrIieXwOTxR
        RKhoyri8OFG7eWyugJvCo3N5/6mJ/zDsT1qca5Eo9Z8ANcoISN2gAuTnPoCiEAESeVDc9d/75oMPBeKb
        F6Y6sTj3nwX9+65wifiRzo37HOcSGExnCfkZi2viawnQgAAkARXIAxWgAXSBITADVsAWOAI3sAL4gWAQ
        DtYCFogHyYAPMkEu2AwKQBHYBfaCSlAD6kEjaAEnQAc4DS6Ay+A6uAnugAdgBIyD52AGvAHzEARhITJE
        geQhVUgLMoDMIAZkD7lBPlAgFA5FQ3EQDxJCudAWqAgqhSqhWqgR+hY6BV2ArkID0D1oFJqCfoXewwhM
        gqmwMqwNG8MM2An2hoPhNXAcnAbnwPnwTrgCroOPwe3wBfg6fAcegZ/DswhAiAgNUUMMEQbigvghEUgs
        wkc2IIVIOVKHtCBdSC9yCxlBppF3KAyKgqKjDFG2KE9UCIqFSkNtQBWjKlFHUe2oHtQt1ChqBvUJTUYr
        oQ3QNmgv9Cp0HDoTXYAuRzeg29CX0HfQ4+g3GAyGhtHBWGE8MeGYBMw6TDHmAKYVcx4zgBnDzGKxWHms
        AdYO64dlYgXYAux+7DHsOewgdhz7FkfEqeLMcO64CBwPl4crxzXhzuIGcRO4ebwUXgtvg/fDs/HZ+BJ8
        Pb4LfwM/jp8nSBN0CHaEYEICYTOhgtBCuER4SHhFJBLVidbEACKXuIlYQTxOvEIcJb4jyZD0SS6kSJKQ
        tJN0hHSedI/0ikwma5MdyRFkAXknuZF8kfyY/FaCImEk4SXBltgoUSXRLjEo8UISL6kl6SS5VjJHslzy
        pOQNyWkpvJS2lIsUU2qDVJXUKalhqVlpirSptJ90snSxdJP0VelJGayMtoybDFsmX+awzEWZMQpC0aC4
        UFiULZR6yiXKOBVD1aF6UROoRdRvqP3UGVkZ2WWyobJZslWyZ2RHaAhNm+ZFS6KV0E7QhmjvlygvcVrC
        WbJjScuSwSVzcopyjnIcuUK5Vrk7cu/l6fJu8onyu+U75B8poBT0FQIUMhUOKlxSmFakKtoqshQLFU8o
        3leClfSVApXWKR1W6lOaVVZR9lBOVd6vfFF5WoWm4qiSoFKmclZlSpWiaq/KVS1TPaf6jC5Ld6In0Svo
        PfQZNSU1TzWhWq1av9q8uo56iHqeeqv6Iw2CBkMjVqNMo1tjRlNV01czV7NZ874WXouhFa+1T6tXa05b
        RztMe5t2h/akjpyOl06OTrPOQ12yroNumm6d7m09jB5DL1HvgN5NfVjfQj9ev0r/hgFsYGnANThgMLAU
        vdR6KW9p3dJhQ5Khk2GGYbPhqBHNyMcoz6jD6IWxpnGE8W7jXuNPJhYmSSb1Jg9MZUxXmOaZdpn+aqZv
        xjKrMrttTjZ3N99o3mn+cpnBMs6yg8vuWlAsfC22WXRbfLS0suRbtlhOWWlaRVtVWw0zqAx/RjHjijXa
        2tl6o/Vp63c2ljYCmxM2v9ga2ibaNtlOLtdZzllev3zMTt2OaVdrN2JPt4+2P2Q/4qDmwHSoc3jiqOHI
        dmxwnHDSc0pwOub0wtnEme/c5jznYuOy3uW8K+Lq4Vro2u8m4xbiVun22F3dPc692X3Gw8Jjncd5T7Sn
        t+duz2EvZS+WV6PXzAqrFetX9HiTvIO8K72f+Oj78H26fGHfFb57fB+u1FrJW9nhB/y8/Pb4PfLX8U/z
        /z4AE+AfUBXwNNA0MDewN4gSFBXUFPQm2Dm4JPhBiG6IMKQ7VDI0MrQxdC7MNaw0bGSV8ar1q66HK4Rz
        wzsjsBGhEQ0Rs6vdVu9dPR5pEVkQObRGZ03WmqtrFdYmrT0TJRnFjDoZjY4Oi26K/sD0Y9YxZ2O8Yqpj
        ZlgurH2s52xHdhl7imPHKeVMxNrFlsZOxtnF7YmbineIL4+f5rpwK7kvEzwTahLmEv0SjyQuJIUltSbj
        kqOTT/FkeIm8nhSVlKyUgVSD1ILUkTSbtL1pM3xvfkM6lL4mvVNAFf1M9Ql1hVuFoxn2GVUZbzNDM09m
        SWfxsvqy9bN3ZE/kuOd8vQ61jrWuO1ctd3Pu6Hqn9bUboA0xG7o3amzM3zi+yWPT0c2EzYmbf8gzySvN
        e70lbEtXvnL+pvyxrR5bmwskCvgFw9tst9VsR23nbu/fYb5j/45PhezCa0UmReVFH4pZxde+Mv2q4quF
        nbE7+0ssSw7uwuzi7Rra7bD7aKl0aU7p2B7fPe1l9LLCstd7o/ZeLV9WXrOPsE+4b6TCp6Jzv+b+Xfs/
        VMZX3qlyrmqtVqreUT13gH1g8KDjwZYa5ZqimveHuIfu1nrUttdp15UfxhzOOPy0PrS+92vG140NCg1F
        DR+P8I6MHA082tNo1djYpNRU0gw3C5unjkUeu/mN6zedLYYtta201qLj4Ljw+LNvo78dOuF9ovsk42TL
        d1rfVbdR2grbofbs9pmO+I6RzvDOgVMrTnV32Xa1fW/0/ZHTaqerzsieKTlLOJt/duFczrnZ86nnpy/E
        XRjrjup+cHHVxds9AT39l7wvXbnsfvlir1PvuSt2V05ftbl66hrjWsd1y+vtfRZ9bT9Y/NDWb9nffsPq
        RudN65tdA8sHzg46DF645Xrr8m2v29fvrLwzMBQydHc4cnjkLvvu5L2key/vZ9yff7DpIfph4SOpR+WP
        lR7X/aj3Y+uI5ciZUdfRvidBTx6Mscae/5T+04fx/Kfkp+UTqhONk2aTp6fcp24+W/1s/Hnq8/npgp+l
        f65+ofviu18cf+mbWTUz/pL/cuHX4lfyr468Xva6e9Z/9vGb5Dfzc4Vv5d8efcd41/s+7P3EfOYH7IeK
        j3ofuz55f3q4kLyw8Bv3hPP74uYdwgAAAAlwSFlzAAAOvAAADrwBlbxySQAABz5JREFUSEutlw1wlNUV
        hpe2o5afREBAqMUIClLbTQmQZtp0pp1a0CqpIK6mBS0DtoUCoxSETgELUUCLCoGIaCKgVgNUFAVKBhJA
        EJKQhISkScgPScj/H7urTaMoefuc/TYjSqyQ9sy8s/B93z3ve84959wb12XYUOAGc93u73vd7tu+gO95
        3d/9jtc92u0dNODavcFvDf+zhQJPdHRUvcfzgOLjV8mxC6AjCLPzoAV8rMLMXfLcHSXPxCixdgGINkfd
        sZ4jRw4/Hhf3JI7PGUvQfPA1Sm01UnsdqAcVPC6VmsvQwP/VAI4pad0sTZ/yUxMSB0YGvF6mbRox4uac
        6uqqAKX0b4CIT5qkD87yz3LISi4CxK08s+cGXy3PCllj797Vrh0rdEfkqGr8jnDcf7n1Cg0N2Zqa+o4a
        GiAKGKntMPLmz4hbIewk6xK897HeRNWnkZU0tRUk6JZv962H4yqHqmtbmJz8UpD4U9AK/NKH5syi/Cri
        L8DLuqZ8qfTvCErWnPvG6apvfH18kOsSC4uICN9XVHQSUisq23evE7nvzJWTG7yVCDgtle2Rqv4mFcer
        h8tlWejSZiYmxkNqZhVtAii4D6kDS3tXBF+FgADWlr0rVb4pFSZo5ezbfXA97FB+3jyrVz8eoGd1EKT/
        X9XoocK7IvivIGteuqMpCwHbpQoEVGzSx+8vt67Icyg/s1ETJ97R4PUGo+7ER7RUd1Jv8Nq28Vu5Typ/
        QzpDHZRsUtWeReof2vMQnCEOtWMRDz30AKRm7PunFJ+RW+TdFkD0rbRi+Q4iB/mvSic2qKP6Re1ZP/MC
        nKscasfCY2Pvdfit1420W2m/CAEBJ4g8mP78l6UMJmn5eh1Y/6BtwxqH2rHw2KkeR4CRB6ImhV05vlx8
        TsBOiTmgjDgpa45Slv3ABDztUDsWHuuZBDuz3cht/zqdWCV3KSZYZJeA7zvR+k8i3hYU8AJbwFjPnqqU
        xbd1IWDSRASQ/rPvUCy7pJpUnGQ6Y9Yc22QLkAIfnWHPWhDSUgBRBu+yQS6g7Vro/cAaWrhqt1MDBVuk
        9NWI8Cj7z98yAcscasf6T7o9AgGkLOM5ftYyNFhgyusOowshrRD5IW7FcWMez45J1aD2qENSSqSnWWPr
        LIBG3nkRUoeoSjqgkAl7+E9S6gT9brTLBLzhUGPDhoUtf2Teb3Vw+1w+/AtpWozaRdLRP0rHn0D9804b
        NafjjMwEyGitXIoq8zHpEN8eepT95VsrtFy+L9zkpN2COMMgyo1X+8H5mn/PcN33q5ma8+hjCul1TXJA
        wNRp9yth6xZNHjuEKJmGOQjInCft+KGUOEZ6+2dSCuIKcGpFVbwZQv7/8s3S+hC+uUHaPV46soC1T5NB
        E7ICHxRdwVMIW4mABLXnbtSuzbwT26p2ZaYf1g1Drt/h+uXdE/zr1q7R72PG6EID7ZJFVNngvVnSzinS
        K2MRMVk6tYEaId15iNz2YylhoLQ1UnrrLlL7IFeApawzQvbacALi48sQxbMKhDefVOyUGM34yQD5D/A9
        FhkZKVfUOJxwm7n/F2O0+SlSWYOITNKfs4Tf+ZBPY/8WIvx1qjoZIYnSXsS9GSPt590x2zYiN2RR6ZlE
        achGRN5GssZhZOu4xAzv59JSt0vLF84ICBgb4ZYrbOjQ/XU1VYq5M1ovrYJQp1hM+tIRkEtUeeylzfPq
        f5ABnFXv5dmLvFsnnXzWSbURZoCsZ1hOhnIp5FIEW+2coQuaDuiVjc/oN1zVOlJm63xzpfLy0jTsxsH7
        rQzC5s74tY4fOazZD09XTdn7TvGc/Kuz37UQN9AJPmstWs+OZ6vy2hSpiOo2snwizadGCl9jLaQVbxF1
        cAiVEX3Fa3pi8R/ka7YrWzto1r0/H2vdEGYC+g4ZPCix9kyxPPfcpX3bIP2IQdJMCzXQmudoJz93wMBA
        MiDEz7XrXDHvuT+0HKEVibKMzqghQyas1A4gRnA5OEVn5HDSns/h2/d4/qTSVkUp7Pq+icZtAgI2sF9o
        EkJUV0y7dXAo2d3OEJiGF0/BIOy5n4upH0E2J1o4fCxTlRa1HUKIKF6pttNLtGD6jzp2zxsl3/PhGnfL
        N9v6uFxJQdpLbOvRfSzWJ5DQLj4jv1hAMAMGm4427QLf8NtCxqrIQAlzooZCPbdWb6+J0XUDehfidwqX
        wQ39rw7cBa4LMH2Z9end+/WcVJwIx23Mc7vVWMoD0ULkN2Gclo1E3cQYbiVjNUzMAkjPJnGc71TRzll6
        dcVk9rjHc0G3V2Y9r+6xPW7pNCYto1WWYm42jexhAwXaeJDbLqQVFGcR53wVxVfHafdBkvxpjyhu8Z0a
        2DfU/kJa5HjrvnlGDrsxfdrUCUw52rFoOXtLr5eAMlqwhC6pf1ZbHh8vT/RgeRhko28daun2gK8FPPwf
        zKo08tbBvarcN/XxuodfC0JBiNd9U2+ve1Q/L++XgM6/BweBKzCX6z8ZtU2chs3wWgAAAABJRU5ErkJg
        gg==
</value>
  </data>
  <data name="button2.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAABUAAAAfCAYAAAAIjIbwAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAO
        vAAADrwBlbxySQAAAbRJREFUSEutlAGVgzAMhqflLJyFWZiFWZiFs4AFLGABC1jAQi//n6RtWIGOu7zl
        8ZolH3/TlNsFS2keEp66vG4Ooaf5J6zFPzKFrHNxUQloGr9TGr741NQ+S0KR3xKhtS+Tt6LbCPXnPjS3
        4tQi8L+gcG79CLhofy3/1BRKYKunAI4GfV2BboHiVCnQ6UW3/FOT4j2V16DHKuEOla0TLPNqdU3Ljd+f
        T+8noHIJ4AdQLcpQAwSgeA207duteoPqdm3LXNsMKqRSR6DBCH42oQGIbTPmqnDHUcw7b/eeQPPx0dy+
        AqGG0KlA4QLhmh+Pe1GYVUqsqZSHAqhtUwoZ9xZYEQH2ogLd66erwg2BO9QBUox1yOXL7mkd2lBYBdQt
        McZiidmamTmuUKw13DZPyF6gQY3G2aZnWjvAtZXiltKsdn/7LasUYXR21H6oFFYVt6A6HVhruM8qtXkC
        YBqHdx5YbUFRUy0OcnpcgHrxQQt6D6wAM/RgCmJ7snkwOIuoJkDj//jv/aUbVdvvKA9K+1ZiyBHnTdTR
        2ragJGeIzCbnUz5tkuwF+X9T5rA6h0QzD/zRb7df0ueaSUgs/TwAAAAASUVORK5CYII=
</value>
  </data>
  <data name="button3.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAACAAAAAeCAYAAABNChwpAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAO
        vAAADrwBlbxySQAAAMJJREFUWEftlNENwyAMRJmlK3SFzsIKrMAKnYUVugKzuD0bRySt+ufjhydZRGcp
        7yIlSQuQMUuQ3ru01paUkJrvR4FaK7WEyl/PrCfkzAJn+Wfy40Yr8FOOfEwo/+QhzDfnywHecFyz5UDl
        1xIsuSOlFC3gJahyf/prCVvHcsjxh8N4Cca3/iXHIEeJ6AInuYPc1nouk4eisi13kNs6FpVtuYPc1rGo
        bMsd5LaORWVb7iC3dSwqm+XIxlCYhVRxSim9AaqNF30gzegIAAAAAElFTkSuQmCC
</value>
  </data>
  <data name="button4.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAACAAAAAeCAYAAABNChwpAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAO
        vAAADrwBlbxySQAAAMJJREFUWEftlNENwyAMRJmlK3SFzsIKrMAKnYUVugKzuD0bRySt+ufjhydZRGcp
        7yIlSQuQMUuQ3ru01paUkJrvR4FaK7WEyl/PrCfkzAJn+Wfy40Yr8FOOfEwo/+QhzDfnywHecFyz5UDl
        1xIsuSOlFC3gJahyf/prCVvHcsjxh8N4Cca3/iXHIEeJ6AInuYPc1nouk4eisi13kNs6FpVtuYPc1rGo
        bMsd5LaORWVb7iC3dSwqm+XIxlCYhVRxSim9AaqNF30gzegIAAAAAElFTkSuQmCC
</value>
  </data>
  <data name="button5.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAACEAAAAUCAYAAAADU1RxAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAO
        vAAADrwBlbxySQAAAThJREFUSEu9kgGRwyAQRbFQC2fhLMRCLNRCLGDhLMRCLMRCLMQC5cNClmXTJKS9
        P/NmmC7wXzqYG3En+FpCgVuXkmXMmH50j+7vK0KxXGZHZplskFGEmkONW8ww08rnhIj5HSKNItS0BQJv
        JUik+jcaRajFF9tlAxLpCwlNgotAolWEFGL2JCqBD0pQdZlKADmQuCMSC1jstOa38B8S8RJcxlI8Rp+7
        EmH9RkSVqCKLOZ+SwOF5fLrRdiqYYU8W3hFokQiD9fETcH1XkWZg9nsBl9K4IrEVP3v/EgmsE0IIaFJS
        6KxEFEjl01AKKOWAC3CkzBmJspwLKMVAKwa5nONFTB8F9iSKi3HIxkHB1fKJkPdARpVIl4hymfB7Q7kM
        n+V5OMQEjhL2YX8qTBx8xGFaDvJCzsUY8wLKPXYYAZ7yHgAAAABJRU5ErkJggg==
</value>
  </data>
  <data name="button6.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAACEAAAAUCAYAAAADU1RxAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAO
        vAAADrwBlbxySQAAAThJREFUSEu9kgGRwyAQRbFQC2fhLMRCLNRCLGDhLMRCLMRCLMQC5cNClmXTJKS9
        P/NmmC7wXzqYG3En+FpCgVuXkmXMmH50j+7vK0KxXGZHZplskFGEmkONW8ww08rnhIj5HSKNItS0BQJv
        JUik+jcaRajFF9tlAxLpCwlNgotAolWEFGL2JCqBD0pQdZlKADmQuCMSC1jstOa38B8S8RJcxlI8Rp+7
        EmH9RkSVqCKLOZ+SwOF5fLrRdiqYYU8W3hFokQiD9fETcH1XkWZg9nsBl9K4IrEVP3v/EgmsE0IIaFJS
        6KxEFEjl01AKKOWAC3CkzBmJspwLKMVAKwa5nONFTB8F9iSKi3HIxkHB1fKJkPdARpVIl4hymfB7Q7kM
        n+V5OMQEjhL2YX8qTBx8xGFaDvJCzsUY8wLKPXYYAZ7yHgAAAABJRU5ErkJggg==
</value>
  </data>
  <data name="button7.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAAB4AAAAaCAYAAACgoey0AAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAO
        vAAADrwBlbxySQAAAVZJREFUSEu1k4GRgkAQBMnJWEzhUzAWUzAFU/gUSOFTUHrX4feXO+84+a6aUmB3
        GiyZOnmkZFrXd2NFMC85X64WnVe4drnd7ZOEa0NYCUSpgkg5nb/+yG/zj4UOr+oH3wpllGehpIAo3qhu
        gC6vbGPLERUiyQEEmRG5LWYkz5SkQuIeuW9UiE+hvCPO0+2KLTYsWDiCeKM4XPWLT73Q8Ig873CsPjyu
        c2wgwhD/4L1iCbQnqc5nOTMrGhoV613Okbgo14CkZA/stsS8gvhc66wDUUx60G4WSyhpSQx2EjFouQdJ
        ELNfEtakEW9bKMlLx1lMR0H4VgpWKGpyndP3KJY8pAsrjGQxSJjF8am9rp+lZosEkcPE9+/ZFmr0ykee
        mK4mNfm/i0GymE9+7mV9C6WZKIs5VAwSZUo3cOjPLUEp+WkJPV63D1vM1ISSau+Vj8hlrXQwTU/pxSc8
        mC9YZgAAAABJRU5ErkJggg==
</value>
  </data>
  <data name="button8.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAABsAAAAcCAYAAACQ0cTtAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAO
        vAAADrwBlbxySQAAAhBJREFUSEu1lAGxgzAMhrEwLbMwC1iYBSxgAQtYwAIWZmEWun5J04XSMnh3L3c5
        oM3/f03brTsR4UL+OcRgemjO/TbX4bZL0yC+EiGsUxjunaQBfdbAvL/Ga0ABhfDKsCNomcCW4TwwhKXP
        wPd420HLBBLmWwZNsUN81O44RJCB812g5LKuYZziGONxPtcVIBaAj9q1IxvRESmGjMUE9OijeQLMz29H
        QAx0trMQ3ms291AD+wRGYg5w010//AQqrMwIBmaLyO90mLq0vAbjfDwonVc+O8Z4T4vI0LSd1vWZrfwa
        mglPD4jZ6qzcSvzUdh8qApaMxJSx+O23ETMPke/0fh6GQQFDaAZmiJE35mlwDzs6N4U4GGKA3DiuNCZm
        hCnjAmIRBczq8FX7bWxhpBMbUFYcnztQWiBjpjmGcQH8BanAqNvBqK1oWjAVeVCxLf04emF4TvMW5rbf
        NNRQq5JvBHoqQQZDVIONS6z3MPQJxhw1te4U5oLv5fXOIraNOi2XkDlqvNbrWlspK7ookvEWzLay1Mmg
        bF3lvFqiGDLOvNSjS9toWtP535sUbf6CHIjiCoiQcYFxbgZMegMx749Ai+IBA7R/DV/MuxUXITXMl1oP
        3cKY4DZVrr6JrbgI7cy2sHIMbVij+CeMenROewwz0D/AqNNyjUMY81pWDTU3oNMyl3IXfrLMX1HTkC66
        7gP4KIMZayIhtAAAAABJRU5ErkJggg==
</value>
  </data>
  <data name="button9.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAAB0AAAAfCAYAAAAbW8YEAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAO
        vAAADrwBlbxySQAAAnhJREFUSEullQGV4zAMREuhFEphKYRCKYTCUQiFUiiFUCiFo1AKWX3Fo8o+N0l7
        8968ZBNrvmU73dOGli/9tZbH47E8n89DZqxMbfJheTEahmEZxzF8v983jQSf5/kjsBfRAQIseL7XJKTc
        NUDekbVGHpMXqWNCgHFtJZgmpQl92inyAsDTNLk1e/3NPc88/GLjf1YD/qZLtJzHn9ifLD0DRocOHM6V
        tfTkrHH7Wob71aFaup4Bc/UODcR4nMFkrZHbWq7zuBZbWCvBJO8GiI29THbIbLJcA34AGoWn69kBUgtD
        ucv/gmpZgW4JYAuljnpW6ijYB1GgLuWeAqpDVE7vp936QIdacQ8mkMxyB5SOS4age+BYGiwooVjfYvbt
        dnP7CQWMCzSDN6EaHAMtZP5jp/cvJ3hazT2ei2+rfZxdyaGWDO1r5HXAXlQNsm7bLtWdOsRMQvtJjqBa
        NeUxMd47LSm60YC8d62ZBFeHArTD5xl0z2poZcqK8A5IT3rpBogEz5PoQu16uVziP5Fc8nbV/XHIBurv
        Deq/SgmqLdDEPO+Aqm+1VQW15eNe3fqeFrDGYM/ckRdXQPamSFCXPfduGijvAStjD+zFBAUUIIfCD8ga
        4PuJ7JB44BtoztkCBzROolxOIqc7oJxSe56hXHvgTSjfVswQUHbpLKD2zD8xoPwANN0yjisme0XUWgsy
        tHTiXWP7+/XutdQtVN2SmdxV/IIosAIWZyiqoA04/AYaXUagQEX+3P5mOTOUe/9WU7cb4ApedYnaYExX
        2itJz3tQuQN3vYW2wPZTQNy3UFyBO50ifygJ1gLV6T/QV+g7b6pXcMQHdTr9AiHxw5FMQ1j1AAAAAElF
        TkSuQmCC
</value>
  </data>
  <data name="button10.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAAB4AAAAfCAYAAADwbH0HAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAO
        vAAADrwBlbxySQAAAh5JREFUSEu1lg1xwzAMhUOhFEKhFEqhFEKhFEphFEphFEphWDI9/diS7Tp2dtOd
        zrEj6bOe0rsug7af8D8ZF3m/Lvv+c0+OvfnrsTTdclFk1lLhZb3vy3ULfrl5fzrfOCflTsIjNPmtcD0v
        LoXcdXvt6/1rHnx9vin5m4tUIAeLXW88CuRZ/iw8JaNQ7NK7uwjtEYscD8WFUE/Kjhkli1wR7mDoWoFQ
        hoGPDDSf79oVkHkrWGXGHudWPMeL/IjFOgOWQpCLOmDoZZV5G5Sc93SO96aOh+NiconxrqUQZCM3gJc1
        ffF6Ib6kwnPXNF/tmp8PwBzUBrvZstQlWOACtq7pK9fLoLYg2iaSqcxYGWzzTau5qODBpdyoqd41SXbg
        /FXTap3yXs664AGgWYaSM1Tnm8De6ayUuprzULde5g6Yu1FwmjMrVIIpZhpMa/6w+mCWW3MyeFxuubED
        5/lOgE/InaEVGOv/gKPMWiT+lD6D84xbYIqbAVfzPQU+7voYrNAIpncmNUMzOHbdAzsonnm+s2DOJfCg
        3FW3U2B6F8HwGtzqugkelpre8Yw/gj/LLYEtsEElQdyD3Tl3XYBj1xGs3dbg8K8jJyQww935MTjC+SW6
        84ncrQSkQGetc5G7AKMmGoBXYIN4MJ4tYNCaYKvdBLOkspHk2PGoycUZKmBXF5Y6x7McuZcAwsuAAWMw
        cm0twc6bdhjQMZ/bqbEsv8gP23/GZA+7AAAAAElFTkSuQmCC
</value>
  </data>
  <data name="button11.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAABcAAAAfCAYAAAAMeVbNAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAO
        vAAADrwBlbxySQAAAeJJREFUSEvtlm1xhTAQRWMhFrCAhVjAQixgAQtYwAIWsPAsYCHN2WRTSIFH6Uyn
        P3pndl4IN2eXfPAwBwo5vqNbY8Lr9XoE995fjgvLsjyGd10XnHOHY8M8zwW+rquabsUwDAVeJxAwhi38
        KPBoGx/+aZpC3/cFbq3dJZBBxjQBncG3Hq6P4IDxcF3gVI4w+5h1Gxg1AdI2sAwoQcX4d5UDJ4C11uxC
        Zd0cbDsF24wCp5Daqwku4a6xsZ2mQKAaGW7tEKzxkqBr4xxHf3MX3lXwppvjHIcwzWtKEOEmw/0TuIAB
        xRjGSI4iQcMTxOqBG+NkQV1jHsB5fKbBTcH3S3Bep4bKWdCfwE0fE8QggTxFhsc+wLfg7OEazlZjV6QK
        fXoKCcCpauZcgFdwPRz1giZ4qjBFgqZoT+HwChzVlQPX6uskeBWcdssenk5zhs9x3o7gg28lAYFIgi8P
        FM8R3LXtJ5xFOYMT4zgWOO+UAv6T8P4f/itweYWy9TZwBSOF4y0JMryAKzgqcAbr3t7C8Whs4dqHX+G5
        b6cCp0JOGQNocy9ZikoCfHyzdBdglcDrP2P60+0igesxRxRCW+5eSICI3ys4gd59bdUq4Hdw1oTr1H1f
        t+C0U9f3pYO/wDdxImM+AMxGtqQ+TlrhAAAAAElFTkSuQmCC
</value>
  </data>
  <data name="button12.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAABsAAAAZCAYAAADAHFVeAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAO
        vAAADrwBlbxySQAAAV9JREFUSEu1lIttxCAQRN1TWnALruVauFrSQlpILdcC8ewHhuVjItkjjcwuMA98
        1m03KAU/ppQ+W/o+jpTSkd77/gg0h76+TthuvhGaAxAoPm+V/atAebbQZdUAhsT6BInf+gQMfcuYah0S
        awPKDQ1qeV2VgFlorN10Q7zaGayE9MyQWA+AyDRXqgM46KrG2O2gGlapbLJFVVg0z/kYT99PsAgsi22B
        fMYxbFR7L4LcDawH8l4vnD0DwQSrQPhHyAHWm8J6IOzhcQWzZg9UvU4O5zoE+z+J934Ohq2AOPQKhDH1
        HeQqMFuQaw71sAFI9tiY9yBfMSqdhH3TDAQHEDIkBzX6lzCb7L3S0QE6YQU2AOaNTejZww8s/RAQQ0w6
        58AODJLm8FZrIJeusbX8NbI0cAE2CiAp8DTG2qrVhAoIY+rNAoIu1+VAP71A3NSX1TfIwzywOYC2n1M8
        wD+1bX+/DaAQeEobeQAAAABJRU5ErkJggg==
</value>
  </data>
  <data name="button13.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAABkAAAAbCAYAAACJISRoAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAO
        vAAADrwBlbxySQAAAU1JREFUSEu1k4txwyAQRNWCa3ELacEtqAW3QAvUohbUk5M9WGb5CVCSndnxCHHv
        SdjebubT6J8kATXneVrjvdupwIhzLvW3kojMoei+71bkOA4r9oex+RgAUajCEbwFJauiiMgFGn4XpURE
        Q1lEtdODa8EIqH4SSMO1UqDrKOYDZhwD4Jier0claRX7UMwGxDiZZCTiHhbzATNOJsGPoBQpuCzmA+Y6
        JtHz996bCFHgyz2tuob5gLkON2bDKGT4JLwU4IHw5nG+mQS3q59PhsfUk/CNIehJbNEdu/Xtv7jJyuO6
        EhDekyQ4BaiCsAcwFfB6SuDPt3VFpG0cUS4AcFbSE1GCe0YtkoG1lLRELcGyRAWzErACsk6C/peAqcDa
        kWBGYn+yFhxtCQBfESA2QJFCtRrCZwVMEvXCp2cxE7uUCtQq9sXejkJ6Xcy2fQMm8R2k8V8PuQAAAABJ
        RU5ErkJggg==
</value>
  </data>
  <data name="button14.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAADAAAAAjCAYAAADSQImyAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAO
        vAAADrwBlbxySQAAAppJREFUWEfVlYtxGzEMRNVCanELrsW1uAW3kFrSgmq5ZHF89AJH6mfpIu0M5kiQ
        AN9SHPvwYC0WVaPc02pmZFcTpw5zwBpoOX5scy12Ewem+Hpf4TyUU7Dn7df3vpaT6nwXxYEfb9+QDr78
        fl+Wz5xjn0yQUw/WWs/dFUAY+dPAFGHi+BVfcsCyl7Hq1WsSd1Vq3mH/3XYKwRPtl6jAHlyCgj2qKef9
        SNGkw+lml2O/YcAx5CHwGbzAPTzfznTdbKLfCNFNGLyH7/UYmakGlGePzm5xs1JjQQQ0gYnBW4+9MtT2
        1jVBYkBfDwwWI1eLohWmgfSbLs/Iwfp+rdk6htgnuBF4nSvEseJcpw4N4AwOoLSubx23Xm7AQbXGGCOE
        eFasyxTNCJqPgDbwLfp88ksBSS1fxgo9MbFcayI1UqHGDhfRbpOD/YmkvMGTo68AyclU7C89DLzGUFFE
        YYJvwAFq8ACQ43Z73uDVz29fBgCnlhp6sFdsK+Jc3Z0a++0A52Mak3dw5allL31ZZ666+gt5HXHKxGhh
        0ywOMng36PDKuwF91U9NyTPXV3M3QB1z1RDav5adV28kOAVj5bWuhg7uB2hM3nMDiNhTn5m+IwO6HNWs
        pXNFocMxdgAOstwsH6pzU8Dy7qlXYELgis95j6QEPIO3eWo4yrfcTNEfAzxNhf8K2seaxlE5UUAD6Q3W
        5fltzvJnlGAFybmE5sprb4mheqPZ7et7Z6XbriaKAdeGJRVU+AcqwWpeDVzKsWmgcaw8XhsDMDCe/Apd
        LKYGbb6HkgF/RrCcMlCTe8MjP7ebAP7cL+B6SgOX/h9AV22+o/zcdPsvaQB4xS1/VP6XAdePDDyDAv7a
        5/NsetnbR8C/rAH08gYkM3E4/AXSWlWtCD67JQAAAABJRU5ErkJggg==
</value>
  </data>
  <data name="button15.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAADAAAAAjCAYAAADSQImyAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAO
        vAAADrwBlbxySQAAAppJREFUWEfVlYtxGzEMRNVCanELrsW1uAW3kFrSgmq5ZHF89AJH6mfpIu0M5kiQ
        AN9SHPvwYC0WVaPc02pmZFcTpw5zwBpoOX5scy12Ewem+Hpf4TyUU7Dn7df3vpaT6nwXxYEfb9+QDr78
        fl+Wz5xjn0yQUw/WWs/dFUAY+dPAFGHi+BVfcsCyl7Hq1WsSd1Vq3mH/3XYKwRPtl6jAHlyCgj2qKef9
        SNGkw+lml2O/YcAx5CHwGbzAPTzfznTdbKLfCNFNGLyH7/UYmakGlGePzm5xs1JjQQQ0gYnBW4+9MtT2
        1jVBYkBfDwwWI1eLohWmgfSbLs/Iwfp+rdk6htgnuBF4nSvEseJcpw4N4AwOoLSubx23Xm7AQbXGGCOE
        eFasyxTNCJqPgDbwLfp88ksBSS1fxgo9MbFcayI1UqHGDhfRbpOD/YmkvMGTo68AyclU7C89DLzGUFFE
        YYJvwAFq8ACQ43Z73uDVz29fBgCnlhp6sFdsK+Jc3Z0a++0A52Mak3dw5allL31ZZ666+gt5HXHKxGhh
        0ywOMng36PDKuwF91U9NyTPXV3M3QB1z1RDav5adV28kOAVj5bWuhg7uB2hM3nMDiNhTn5m+IwO6HNWs
        pXNFocMxdgAOstwsH6pzU8Dy7qlXYELgis95j6QEPIO3eWo4yrfcTNEfAzxNhf8K2seaxlE5UUAD6Q3W
        5fltzvJnlGAFybmE5sprb4mheqPZ7et7Z6XbriaKAdeGJRVU+AcqwWpeDVzKsWmgcaw8XhsDMDCe/Apd
        LKYGbb6HkgF/RrCcMlCTe8MjP7ebAP7cL+B6SgOX/h9AV22+o/zcdPsvaQB4xS1/VP6XAdePDDyDAv7a
        5/NsetnbR8C/rAH08gYkM3E4/AXSWlWtCD67JQAAAABJRU5ErkJggg==
</value>
  </data>
  <data name="button16.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAABoAAAAQCAYAAAAI0W+oAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAO
        vAAADrwBlbxySQAAASlJREFUOE/dk+GRhCAMhW2BFmiBFmiBFq4FWrCFbcEWbMEWbIEWcu8FVOBkx9n9
        d9/Mm4EkL1HEqbBBAi26+wwL7RD79HLQbeLpwHfNe02hC9Qa4aG7+ndSXtBdkurhW9zVjdQgMc6aIM65
        YSFIUJ2HN8q6rk2sU2bfRbZNxFqrg0IISBoxxl5FLfyG6J200UH2Tdprnv8MzoMoY8z5NtY6NWjBAA46
        Hs57fzZNKT/4IS0mWgm4rFViQ3pP8JevBrEM1qEExEDrbE6DFgw4PK9o5CfQp0etvhotJlh7KPGMIwz7
        Gh8P0iMzOOaXk7RdF6qCl+eCAUa5pHZ+tLwfogXguATUsiwlesLfoaUkGkpqSClTEm9BC//PIefT6e45
        te8T/z/mi+OYpl/lqqMnHfpRSAAAAABJRU5ErkJggg==
</value>
  </data>
  <data name="button17.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAABoAAAAQCAYAAAAI0W+oAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAO
        vAAADrwBlbxySQAAASlJREFUOE/dk+GRhCAMhW2BFmiBFmiBFq4FWrCFbcEWbMEWbIEWcu8FVOBkx9n9
        d9/Mm4EkL1HEqbBBAi26+wwL7RD79HLQbeLpwHfNe02hC9Qa4aG7+ndSXtBdkurhW9zVjdQgMc6aIM65
        YSFIUJ2HN8q6rk2sU2bfRbZNxFqrg0IISBoxxl5FLfyG6J200UH2Tdprnv8MzoMoY8z5NtY6NWjBAA46
        Hs57fzZNKT/4IS0mWgm4rFViQ3pP8JevBrEM1qEExEDrbE6DFgw4PK9o5CfQp0etvhotJlh7KPGMIwz7
        Gh8P0iMzOOaXk7RdF6qCl+eCAUa5pHZ+tLwfogXguATUsiwlesLfoaUkGkpqSClTEm9BC//PIefT6e45
        te8T/z/mi+OYpl/lqqMnHfpRSAAAAABJRU5ErkJggg==
</value>
  </data>
  <data name="button18.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAABkAAAAgCAYAAADnnNMGAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAO
        vAAADrwBlbxySQAAAYdJREFUSEu1lguVgzAQRbGAhdWyFrBQC1jAQizEQixgAQtYoHlhJpsMkw9dOufc
        8smbuUDLOR3OGg//UWX0GaCtXUEuZkMd++a+BuZHyepMk3E8r1Rb07BmvifhMJWakfxLMn5LAqhBXdOI
        EjznXsldLneCE/Pr99EtiBKUc+5YlunRrTF/32WQ7Pv+OBAFyU9FwkVXo4JBWi9oSlA86FjNFfcK1GRV
        CSoO392VgkyKihJUJji2nIpMiqIEby+qS8B0iqIkDPWVSWoCRhP1SMI+wp9KhKhLMk3TeU4KAAliRkjw
        IrYlQUSPryDIMrclJKKAXy0I0swdiVvX2ECBy+CUmCGBpcEswa/XH+cShILI2si2bUXSHPqMsW0JQiy6
        C/rmeemXMGhKjyXpOnqlBPuZxPpbZpEcTuGMdB15+aiqEm7g5nSYhNe1u1AlmkjK5JYzmqAokSLAgzQ4
        IwWYU5WkIsCDNDgjBaApARClMg0M1wQgk+Cl4tCTQM4SFB98jv+TSC+eYBjeeyuQz93W7cwAAAAASUVO
        RK5CYII=
</value>
  </data>
  <data name="button19.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAAB4AAAAWCAYAAADXYyzPAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAO
        vAAADrwBlbxySQAAAi1JREFUSEu1VIGRgzAMYwVW6ApdgRWyAitkBa+QFbyCV8gKrNAV8pJT85SHv/aP
        V09XCIlly4bhA7QD/itcpEptNmvTqbRyE+fz2eXwwFuxWKvlO4nn2ic43e/BQiyPcwTfHjhaeweeNP/7
        bYcvTON9FZzH9Jfgv8Gd4n+/xQURFlKc5Hp/fBle2tMWW7y6YBX7kdkF8AHdDqWLLMvDqlbTWS0SOBGP
        tS3fwU+bZZIWouVeVG6ieci6E3fSnQCvN8NyxIDf798Cr85Fpy4qY1aBcBont4bi7gqELFvjerhCRgJs
        UbRpI7Leb20m/DBEC0TJLgyy6pjyIO8Bg4BqUsW5tTUkkyJDjIxh5XPqdVlcePCpiNyFjAQKrl2Ye2If
        nEkYEkXl+nTJsM9kJPNKintcJBuv5iaWwxcMPS5Jcpkko+dC6lzKbjOtTi7aq/WK3SV3yv9534mEQpzk
        +R7mG83QGy1mZe4/hdO1LsLM+bxvG1pJ/kOSIGcCrqzCO9KREN4PVsAfWl3MrBoE7YE+cm2+vfSFLUms
        0iul6AmZlKEQWkxRDiXP9zCv6NMLUb7TyHYvSjS55QWOGFpR9kSr1DmJwkFb6sMY4+j7vMc69geigYaK
        2BI5o0KXjkUsguf68XPEprONnhTtVDXDLCQQM4G5gLUcUlYaou9U+wlc3OcCMxHkbJjgC/gUZeu4tx+5
        Dh6cpFCIkUxq/85eDQ9OITI+GrHODf+NrdgbgsPwBazu0LJ/ZvdQAAAAAElFTkSuQmCC
</value>
  </data>
  <data name="button20.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAACAAAAAeCAYAAABNChwpAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAO
        vAAADrwBlbxySQAAAmBJREFUWEe9lg2xwjAQhGsBC1jAAhawgIVawAIWsIAFLGABC3nzXbLlml76w5vp
        zuy0SS63m00f87oGkuPuSK/XK30+HyPjPL0fzMDj8Ui32203AxJKx+Mx9X1v3MvAKHIMMCeSRHmvMaor
        /AlLkds6zzzMYtfr1cie+/3ujfraVVgTua3zpAbhy+WSzuezUWZk5Pl8qk/UK0Q6nU5LG0biXBXivHsq
        FUxUyc0iumuNjTSVAYn7daWoNHin5yYTihmqkQSJF2pc6jxsjhpvhPEmE3XMEuc0kObMuXuuYfX0kRHe
        15iYxCwT+rBowjpzPINrEyYm1iRhRVAGmIOIv99v+53gnTUabzUxU5uLKYBsYC4vjX+oIDWYULxLJugn
        E62rsyY+ZubyUjecHvBkzLwaL5lQClwphpjLS19MYmYuL2UDEXQVsNW4wGpIAEbfQhgz83DOAOtqvpQC
        NaQQ1TVjzsudzUfQtzAXb4HV8QNWXbHBEojAGiJRCjIsE2sN8KyvwTZHYA0B1iUoMPYmWvEWDAaoi/4a
        JgICawiwyYN6fTuAmhkDwAzAKK3mKQHNuTv/sXItmIK6QurolVtOMBhoGbVm/r4R8s354lUjAzTDHAfQ
        XnoVepi40mScp7+YCGCAsU7OZu4SUS8O9eeopCojthdilPUyP8EgQFEtwmaZQFDCEucDE5mjhw4D6QXR
        yXIxrAFiEpeAiAn+iyJSL6o7FmWEXuo3d3qPYbMX92KYOBwOQ7QYEiMDW8QFK1Yj6BurOSZEmfHiJOhi
        Xy3uYRt1Oi8eNPbjmv9G1BT+iK77AzG+Z99zAuJLAAAAAElFTkSuQmCC
</value>
  </data>
</root>
```

`MapleNecrocer/AvatarFormDraw.cs`:

```cs
using Microsoft.Xna.Framework;
using MonoGame.Forms.Controls;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using Microsoft.Xna.Framework;
using Color = Microsoft.Xna.Framework.Color;
using DevComponents.DotNetBar;

using Microsoft.Xna.Framework.Graphics;
using System.Drawing;
using WzComparerR2.CharaSim;

namespace MapleNecrocer;

public class AvatarFormDraw : MonoGameControl
{
    public AvatarFormDraw()
    {
        Instance = this;
    }
    public static AvatarFormDraw Instance;
    public static RenderTarget2D AvatarPanelTexture;
    private static RenderTarget2D CheckBoardTexture;

    protected override void Initialize()
    {

        base.Initialize();
        this.AlwaysEnableKeyboardInput = true;
        EngineFunc.Canvas.DrawTarget(ref CheckBoardTexture, 260, 200, () =>
        {
            for (int J = 0; J < 200; J++)
            {
                for (int I = 0; I < 260; I++)
                {
                    if ((I == 0) || (J == 0) || (I == 259) || (J == 199))
                        EngineFunc.Canvas.Pixel(I, J, new Color(0, 0, 0));
                    else if (((I / 8) + (J / 8)) % 2 == 0)  // put checkboard pattern
                        EngineFunc.Canvas.Pixel(I, J, new Color(205, 205, 205));
                    else
                        EngineFunc.Canvas.Pixel(I, J, new Color(255, 255, 255));
                }
            }
        });

        EngineFunc.Canvas.DrawTarget(ref AvatarPanelTexture, 4096, 4096, () => { });
        this.SetMultiSampleCount(0);
    }

    protected override void Update(GameTime gameTime)
    {
        EngineFunc.Canvas.GraphicsDevice.SetRenderTarget(AvatarPanelTexture);
        EngineFunc.Canvas.GraphicsDevice.Clear(Microsoft.Xna.Framework.Color.Transparent);
        EngineFunc.SpriteEngine.DrawEx("Player", "ItemEffect", "SetEffect");
        EngineFunc.Canvas.GraphicsDevice.SetRenderTarget(null);
    }

    protected override void Draw()
    {
        EngineFunc.Canvas.Draw(CheckBoardTexture, 0, 0);
        // Editor.graphics.Clear(Color.Aqua);
        int WX = (int)(Game.Player.X - EngineFunc.SpriteEngine.Camera.X - 130 + MapleChair.BodyRelMove.X - TamingMob.Navel.X);
        int WY = (int)(Game.Player.Y - EngineFunc.SpriteEngine.Camera.Y - 160 + MapleChair.BodyRelMove.Y - TamingMob.Navel.Y);
        EngineFunc.Canvas.DrawCropArea(AvatarPanelTexture, 0, 0, new Microsoft.Xna.Framework.Rectangle(WX, WY, WX + 280, WY + 200), 0, 0, 1, 1, 0, false, false, 255, 255, 255, 255, false, BlendMode.NonPremultiplied2);
    }

}


```

`MapleNecrocer/CashEffectForm.Designer.cs`:

```cs
namespace MapleNecrocer
{
    partial class CashEffectForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            tabControl1 = new TabControl();
            tabPage1 = new TabPage();
            tabPage2 = new TabPage();
            label1 = new Label();
            textBox1 = new TextBox();
            button1 = new Button();
            tabControl1.SuspendLayout();
            SuspendLayout();
            // 
            // tabControl1
            // 
            tabControl1.Anchor = AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right;
            tabControl1.Controls.Add(tabPage1);
            tabControl1.Controls.Add(tabPage2);
            tabControl1.Location = new Point(3, 57);
            tabControl1.Name = "tabControl1";
            tabControl1.SelectedIndex = 0;
            tabControl1.Size = new Size(353, 508);
            tabControl1.TabIndex = 3;
            // 
            // tabPage1
            // 
            tabPage1.Location = new Point(4, 26);
            tabPage1.Name = "tabPage1";
            tabPage1.Padding = new Padding(3);
            tabPage1.Size = new Size(345, 478);
            tabPage1.TabIndex = 0;
            tabPage1.Text = "tabPage1";
            tabPage1.UseVisualStyleBackColor = true;
            // 
            // tabPage2
            // 
            tabPage2.Location = new Point(4, 28);
            tabPage2.Name = "tabPage2";
            tabPage2.Padding = new Padding(3);
            tabPage2.Size = new Size(345, 476);
            tabPage2.TabIndex = 1;
            tabPage2.Text = "tabPage2";
            tabPage2.UseVisualStyleBackColor = true;
            // 
            // label1
            // 
            label1.AutoSize = true;
            label1.Location = new Point(12, 20);
            label1.Name = "label1";
            label1.Size = new Size(52, 18);
            label1.TabIndex = 4;
            label1.Text = "Search";
            // 
            // textBox1
            // 
            textBox1.Location = new Point(70, 17);
            textBox1.Name = "textBox1";
            textBox1.Size = new Size(115, 24);
            textBox1.TabIndex = 5;
            textBox1.TextChanged += textBox1_TextChanged;
            // 
            // button1
            // 
            button1.Location = new Point(231, 14);
            button1.Name = "button1";
            button1.Size = new Size(87, 28);
            button1.TabIndex = 6;
            button1.Text = "Remove";
            button1.UseVisualStyleBackColor = true;
            button1.Click += button1_Click;
            // 
            // CashEffectForm
            // 
            AutoScaleMode = AutoScaleMode.None;
            ClientSize = new Size(359, 577);
            Controls.Add(button1);
            Controls.Add(textBox1);
            Controls.Add(label1);
            Controls.Add(tabControl1);
            Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            KeyPreview = true;
            MaximumSize = new Size(377, 1000);
            Name = "CashEffectForm";
            StartPosition = FormStartPosition.CenterScreen;
            Text = "CashEffect";
            TopMost = true;
            Shown += CashEffectForm_Shown;
            KeyDown += CashEffectForm_KeyDown;
            tabControl1.ResumeLayout(false);
            ResumeLayout(false);
            PerformLayout();
        }

        #endregion

        private TabControl tabControl1;
        private TabPage tabPage1;
        private TabPage tabPage2;
        private Label label1;
        private TextBox textBox1;
        private Button button1;
    }
}
```

`MapleNecrocer/CashEffectForm.cs`:

```cs
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Security.Policy;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using WzComparerR2.CharaSim;

namespace MapleNecrocer;

public partial class CashEffectForm : Form
{
    public CashEffectForm()
    {
        InitializeComponent();
        Instance = this;
    }
    public static CashEffectForm Instance;
    DataGridViewEx CashEffectListGrid;

    void CellClick(BaseDataGridView DataGrid, DataGridViewCellEventArgs e)
    {

        var ID = DataGrid.Rows[e.RowIndex].Cells[0].Value.ToString();
        ItemEffect.Remove(EffectType.Cash);
        ItemEffect.Create(ID, EffectType.Cash);
    }
    private void CashEffectForm_Shown(object sender, EventArgs e)
    {
        this.FormClosing += (s, e1) =>
        {
            this.Hide();
            e1.Cancel = true;
        };

        CashEffectListGrid = new(90, 174, 0, 0, 220, 700, true, tabControl1.TabPages[0]);
        CashEffectListGrid.Dock = DockStyle.Fill;
        CashEffectListGrid.SearchGrid.Dock = DockStyle.Fill;

        var Graphic = CashEffectListGrid.CreateGraphics();
        var Font = new System.Drawing.Font(FontFamily.GenericSansSerif, 20, FontStyle.Bold);
        Graphic.DrawString("Loading...", Font, Brushes.Black, 10, 50);
        CashEffectListGrid.CellClick += (s, e) =>
        {
            CellClick(CashEffectListGrid, e);
        };

        CashEffectListGrid.SearchGrid.CellClick += (s, e) =>
        {
            CellClick(CashEffectListGrid.SearchGrid, e);
        };

        string CashEffectName = "";
        Bitmap Bmp = null;
        var Entry = Wz.GetNode("Item/Cash/0501.img");
        Win32.SendMessage(CashEffectListGrid.Handle, false);
        foreach (var Iter in Entry.Nodes)
        {
            if (Iter.Text == "05010044")
                continue;
            if (Iter.Text == "05012000")
                continue;
            if (Iter.Text == "05012001")
                continue;
            if (Iter.Text == "05010099")
                continue;
            if (Wz.HasNode("String/Cash.img/" + Iter.Text.IntID()))
                CashEffectName = Wz.GetNode("String/Cash.img/" + Iter.Text.IntID()).GetStr("name");
            else
                CashEffectName = "";
            if (Iter.HasNode("info/icon"))
                Bmp = Iter.GetNode("info/icon").ExtractPng();

            CashEffectListGrid.Rows.Add(Iter.Text, Bmp, CashEffectName);
        }
        Win32.SendMessage(CashEffectListGrid.Handle, true);
        CashEffectListGrid.Refresh();
        for (int i = 0; i < CashEffectListGrid.Rows.Count; i++)
        {
            CashEffectListGrid.Rows[i].Cells[1].Style.Alignment = DataGridViewContentAlignment.MiddleCenter;
            CashEffectListGrid.Rows[i].Cells[2].Style.Alignment = DataGridViewContentAlignment.TopLeft;
        }
    }

    private void button1_Click(object sender, EventArgs e)
    {
        ItemEffect.Remove(EffectType.Cash);
    }

    private void textBox1_TextChanged(object sender, EventArgs e)
    {
        CashEffectListGrid.Search(textBox1.Text);
    }

    private void CashEffectForm_KeyDown(object sender, KeyEventArgs e)
    {
        if (e.Alt)
            e.Handled = true;
        if (!textBox1.Focused)
            ActiveControl = null;
    }
}

```

`MapleNecrocer/CashEffectForm.resx`:

```resx
<root>
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`MapleNecrocer/CashForm.Designer.cs`:

```cs
namespace MapleNecrocer
{
    partial class CashForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            panel1 = new Panel();
            UseButton = new Button();
            pictureBox1 = new PictureBox();
            label1 = new Label();
            label2 = new Label();
            tabControl1 = new TabControl();
            tabPage1 = new TabPage();
            tabPage2 = new TabPage();
            textBox1 = new TextBox();
            panel1.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)pictureBox1).BeginInit();
            tabControl1.SuspendLayout();
            tabPage2.SuspendLayout();
            SuspendLayout();
            // 
            // panel1
            // 
            panel1.BorderStyle = BorderStyle.FixedSingle;
            panel1.Controls.Add(UseButton);
            panel1.Controls.Add(pictureBox1);
            panel1.Controls.Add(label1);
            panel1.Controls.Add(label2);
            panel1.Location = new Point(50, 9);
            panel1.Name = "panel1";
            panel1.Size = new Size(320, 49);
            panel1.TabIndex = 9;
            // 
            // UseButton
            // 
            UseButton.Location = new Point(263, 6);
            UseButton.Name = "UseButton";
            UseButton.Size = new Size(52, 35);
            UseButton.TabIndex = 3;
            UseButton.Text = "Drop";
            UseButton.TextAlign = ContentAlignment.MiddleLeft;
            UseButton.UseVisualStyleBackColor = true;
            UseButton.Click += UseButton_Click;
            // 
            // pictureBox1
            // 
            pictureBox1.Location = new Point(74, 3);
            pictureBox1.Name = "pictureBox1";
            pictureBox1.Size = new Size(40, 40);
            pictureBox1.SizeMode = PictureBoxSizeMode.CenterImage;
            pictureBox1.TabIndex = 1;
            pictureBox1.TabStop = false;
            // 
            // label1
            // 
            label1.AutoSize = true;
            label1.Location = new Point(3, 16);
            label1.Name = "label1";
            label1.Size = new Size(0, 18);
            label1.TabIndex = 0;
            // 
            // label2
            // 
            label2.AutoSize = true;
            label2.Location = new Point(110, 16);
            label2.Name = "label2";
            label2.Size = new Size(0, 18);
            label2.TabIndex = 2;
            // 
            // tabControl1
            // 
            tabControl1.Anchor = AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right;
            tabControl1.Controls.Add(tabPage1);
            tabControl1.Controls.Add(tabPage2);
            tabControl1.Location = new Point(4, 64);
            tabControl1.Name = "tabControl1";
            tabControl1.Padding = new Point(6, 0);
            tabControl1.SelectedIndex = 0;
            tabControl1.Size = new Size(420, 580);
            tabControl1.TabIndex = 10;
            tabControl1.SelectedIndexChanged += tabControl1_SelectedIndexChanged;
            // 
            // tabPage1
            // 
            tabPage1.Location = new Point(4, 24);
            tabPage1.Name = "tabPage1";
            tabPage1.Padding = new Padding(3);
            tabPage1.Size = new Size(412, 552);
            tabPage1.TabIndex = 0;
            tabPage1.Text = "Icons";
            tabPage1.UseVisualStyleBackColor = true;
            // 
            // tabPage2
            // 
            tabPage2.Controls.Add(textBox1);
            tabPage2.Location = new Point(4, 26);
            tabPage2.Name = "tabPage2";
            tabPage2.Padding = new Padding(3, 3, 3, 5);
            tabPage2.Size = new Size(412, 550);
            tabPage2.TabIndex = 1;
            tabPage2.Text = "Search";
            tabPage2.UseVisualStyleBackColor = true;
            // 
            // textBox1
            // 
            textBox1.Location = new Point(112, 6);
            textBox1.Name = "textBox1";
            textBox1.Size = new Size(162, 24);
            textBox1.TabIndex = 5;
            textBox1.TextChanged += textBox1_TextChanged;
            // 
            // CashForm
            // 
            AutoScaleMode = AutoScaleMode.None;
            ClientSize = new Size(432, 650);
            Controls.Add(tabControl1);
            Controls.Add(panel1);
            Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            KeyPreview = true;
            Name = "CashForm";
            StartPosition = FormStartPosition.CenterScreen;
            Text = "CashForm";
            TopMost = true;
            FormClosing += CashForm_FormClosing;
            Shown += CashForm_Shown;
            KeyDown += CashForm_KeyDown;
            panel1.ResumeLayout(false);
            panel1.PerformLayout();
            ((System.ComponentModel.ISupportInitialize)pictureBox1).EndInit();
            tabControl1.ResumeLayout(false);
            tabPage2.ResumeLayout(false);
            tabPage2.PerformLayout();
            ResumeLayout(false);
        }

        #endregion

        private Panel panel1;
        private Button UseButton;
        private PictureBox pictureBox1;
        private Label label1;
        private Label label2;
        private TabControl tabControl1;
        private TabPage tabPage1;
        private TabPage tabPage2;
        private TextBox textBox1;
    }
}
```

`MapleNecrocer/CashForm.cs`:

```cs
using Manina.Windows.Forms;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using WzComparerR2.WzLib;

namespace MapleNecrocer;

public partial class CashForm : Form
{
    public CashForm()
    {
        InitializeComponent();
        Instance = this;
    }
    public static CashForm Instance;
    ImageListView ImageGrid;
    DataGridViewEx CashListGrid;
    bool HasLoaded1;
   
    private void CashForm_Shown(object sender, EventArgs e)
    {
        this.FormClosing += (s, e1) =>
        {
            this.Hide();
            e1.Cancel = true;
        };

        ImageGrid = new ImageListView();
        ImageGrid.Parent = tabControl1.TabPages[0];
        ImageGrid.Anchor = (AnchorStyles.Left | AnchorStyles.Right | AnchorStyles.Top | AnchorStyles.Bottom);
        ImageGrid.Dock = DockStyle.Fill;
        ImageGrid.BackColor = SystemColors.Window;
        ImageGrid.Colors.BackColor = SystemColors.ButtonFace;
        ImageGrid.Colors.SelectedBorderColor = Color.Red;
        ImageGrid.BorderStyle = BorderStyle.Fixed3D;
        ImageGrid.ThumbnailSize = new System.Drawing.Size(32, 32);
        ImageGrid.ItemClick += (o, e) =>
        {
            string ID = (e.Item.FileName);
            label1.Text = ID;
            pictureBox1.Image = Wz.GetBmp("Item/Cash/" + ID.LeftStr(4) + ".img/" + ID + "/info/icon");
            label2.Text = Wz.GetStr("String/Cash.img/" + ID.IntID() + "/name");
        };

        ImageGrid.ItemHover += (o, e) =>
        {
            if (e.Item == null) return;
            Wz_Node Node = Wz.GetNodeByID(e.Item.FileName, WzType.Item);
            MainForm.Instance.QuickView(Node);
            MainForm.Instance.ToolTipView.Owner = this;
        };

        var Graphic = ImageGrid.CreateGraphics();
        var Font = new System.Drawing.Font(FontFamily.GenericSansSerif, 20, FontStyle.Bold);
        Graphic.DrawString("Loading...", Font, Brushes.Black, 10, 50);
        Win32.SendMessage(ImageGrid.Handle, false);
        Bitmap Bmp = null;
        foreach (var Img in Wz.GetNodes("Item/Cash"))
        {
            if (!Char.IsNumber(Img.Text[0]))
                continue;
            foreach (var Iter in Wz.GetNodes("Item/Cash/" + Img.Text))
            {
                if (Iter.HasNode("info/icon"))
                    Bmp = Iter.GetBmp("info/icon");
                ImageGrid.Items.Add(Iter.Text, Bmp);
            }
        }
        ImageGrid.Sort();
        Win32.SendMessage(ImageGrid.Handle, true);
        ImageGrid.Refresh();
    }

    private void tabControl1_SelectedIndexChanged(object sender, EventArgs e)
    {
        label1.Text = "";
        pictureBox1.Image = null;
        label2.Text = "";
        if (tabControl1.SelectedIndex == 1)
        {
            if (HasLoaded1)
                return;

            CashListGrid = new(80, 185, 0, 20, 220, 530, true, tabControl1.TabPages[1]);
            CashListGrid.Anchor = (AnchorStyles.Left | AnchorStyles.Right | AnchorStyles.Top | AnchorStyles.Bottom);
            CashListGrid.Dock = DockStyle.Fill;
            tabControl1.TabPages[1].Padding = new Padding(0, 35, 0, 0);
            CashListGrid.SearchGrid.Dock = DockStyle.Fill;
            CashListGrid.RowTemplate.Height = 40;

            var Graphic = CashListGrid.CreateGraphics();
            var Font = new System.Drawing.Font(FontFamily.GenericSansSerif, 20, FontStyle.Bold);
            Graphic.DrawString("Loading...", Font, Brushes.Black, 10, 50);
            void CellClick(BaseDataGridView DataGrid, DataGridViewCellEventArgs e)
            {
                string ID = DataGrid.Rows[e.RowIndex].Cells[0].Value.ToString();
                label1.Text = ID;
                pictureBox1.Image = (Bitmap)DataGrid.Rows[e.RowIndex].Cells[1].Value;
                label2.Text = DataGrid.Rows[e.RowIndex].Cells[2].Value.ToString();
            }

            CashListGrid.CellClick += (s, e) =>
            {
                CellClick(CashListGrid, e);
            };

            CashListGrid.SearchGrid.CellClick += (s, e) =>
            {
                CellClick(CashListGrid.SearchGrid, e);
            };
            CashListGrid.SetToolTipEvent(WzType.Item, this);


            Win32.SendMessage(CashListGrid.Handle, false);
            Bitmap Bmp = null;
            string ConsumeName = "";
            foreach (var Img in Wz.GetNodes("Item/Cash"))
            {
                if (!Char.IsNumber(Img.Text[0]))
                    continue;
                foreach (var Iter in Wz.GetNodes("Item/Cash/" + Img.Text))
                {
                    string ID = Iter.Text;
                    string IntID = ID.IntID();
                    if (Wz.HasNode("String/Cash.img/" + IntID))
                        ConsumeName = Wz.GetStr("String/Cash.img/" + IntID + "/name");
                    if (Iter.HasNode("info/icon"))
                        Bmp = Iter.GetBmp("info/icon");
                    CashListGrid.Rows.Add(ID, Bmp, ConsumeName);
                }
            }

            Win32.SendMessage(CashListGrid.Handle, true);
            CashListGrid.Refresh();
            for (int i = 0; i < CashListGrid.Rows.Count; i++)
            {
                CashListGrid.Rows[i].Cells[1].Style.Alignment = DataGridViewContentAlignment.MiddleCenter;
                CashListGrid.Rows[i].Cells[2].Style.Alignment = DataGridViewContentAlignment.TopLeft;
            }
            HasLoaded1 = true;
        }
    }

    private void textBox1_TextChanged(object sender, EventArgs e)
    {
        CashListGrid.Search(textBox1.Text);
    }

    private void UseButton_Click(object sender, EventArgs e)
    {
        if (label1.Text.Trim(' ') != "")
            ItemDrop.Drop((int)Game.Player.X, (int)Game.Player.Y, 0, label1.Text.Trim(' '));
    }

    private void CashForm_KeyDown(object sender, KeyEventArgs e)
    {
        if (e.Alt)
            e.Handled = true;
        if (!textBox1.Focused)
            ActiveControl = null;
    }

    private void CashForm_FormClosing(object sender, FormClosingEventArgs e)
    {
        MainForm.Instance.ToolTipView.Visible = false;
    }
}

```

`MapleNecrocer/CashForm.resx`:

```resx
<root>
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`MapleNecrocer/ChairForm.Designer.cs`:

```cs
namespace MapleNecrocer
{
    partial class ChairForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            label1 = new Label();
            textBox1 = new TextBox();
            tabControl1 = new TabControl();
            tabPage1 = new TabPage();
            tabPage2 = new TabPage();
            tabControl1.SuspendLayout();
            SuspendLayout();
            // 
            // label1
            // 
            label1.AutoSize = true;
            label1.Font = new Font("Tahoma", 15F, FontStyle.Regular, GraphicsUnit.Pixel);
            label1.Location = new Point(49, 14);
            label1.Name = "label1";
            label1.Size = new Size(52, 18);
            label1.TabIndex = 0;
            label1.Text = "Search";
            // 
            // textBox1
            // 
            textBox1.Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            textBox1.Location = new Point(107, 12);
            textBox1.Name = "textBox1";
            textBox1.Size = new Size(145, 24);
            textBox1.TabIndex = 1;
            textBox1.TextChanged += textBox1_TextChanged;
            // 
            // tabControl1
            // 
            tabControl1.Anchor = AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right;
            tabControl1.Controls.Add(tabPage1);
            tabControl1.Controls.Add(tabPage2);
            tabControl1.Location = new Point(12, 51);
            tabControl1.Name = "tabControl1";
            tabControl1.SelectedIndex = 0;
            tabControl1.Size = new Size(335, 711);
            tabControl1.TabIndex = 2;
            // 
            // tabPage1
            // 
            tabPage1.Location = new Point(4, 21);
            tabPage1.Name = "tabPage1";
            tabPage1.Padding = new Padding(3);
            tabPage1.Size = new Size(327, 686);
            tabPage1.TabIndex = 0;
            tabPage1.Text = "tabPage1";
            tabPage1.UseVisualStyleBackColor = true;
            // 
            // tabPage2
            // 
            tabPage2.Location = new Point(4, 28);
            tabPage2.Name = "tabPage2";
            tabPage2.Padding = new Padding(3);
            tabPage2.Size = new Size(327, 479);
            tabPage2.TabIndex = 1;
            tabPage2.Text = "tabPage2";
            tabPage2.UseVisualStyleBackColor = true;
            // 
            // ChairForm
            // 
            AutoScaleMode = AutoScaleMode.None;
            ClientSize = new Size(359, 774);
            Controls.Add(tabControl1);
            Controls.Add(textBox1);
            Controls.Add(label1);
            Font = new Font("Microsoft JhengHei UI", 9F, FontStyle.Regular, GraphicsUnit.Pixel);
            KeyPreview = true;
            MaximumSize = new Size(377, 1000);
            Name = "ChairForm";
            StartPosition = FormStartPosition.CenterScreen;
            Text = "Chair";
            TopMost = true;
            FormClosing += ChairForm_FormClosing;
            Load += ChairForm_Load;
            Shown += ChairForm_Shown;
            KeyDown += ChairForm_KeyDown;
            tabControl1.ResumeLayout(false);
            ResumeLayout(false);
            PerformLayout();
        }

        #endregion

        private Label label1;
        private TextBox textBox1;
        private TabControl tabControl1;
        private TabPage tabPage1;
        private TabPage tabPage2;
    }
}
```

`MapleNecrocer/ChairForm.cs`:

```cs
using System.ComponentModel;
using System.Windows.Forms;
using WzComparerR2.CharaSim;
using WzComparerR2.WzLib;

namespace MapleNecrocer;

public partial class ChairForm : Form
{
    public ChairForm()
    {
        InitializeComponent();
        Instance = this;
    }
    public static ChairForm Instance;
    public DataGridViewEx ChairListGrid;

    private void ChairForm_Load(object sender, EventArgs e)
    {

    }


    void CellClick(BaseDataGridView DataGrid, DataGridViewCellEventArgs e)
    {
        if (Morph.IsUse)
            return;
        if (!MapleChair.CanUse)
            return;
        var ID = DataGrid.Rows[e.RowIndex].Cells[0].Value.ToString();

        MapleChair.Remove();

        TamingMob.Remove();
        ItemEffect.Remove(EffectType.Chair);

        MapleChair.Create(ID);

        if (ItemEffect.AllList.Contains(ID))
            ItemEffect.Create(ID, EffectType.Chair);
        MapleChair.IsUse = true;


    }

    private void ChairForm_Shown(object sender, EventArgs e)
    {
        this.FormClosing += (s, e1) =>
        {
            this.Hide();
            e1.Cancel = true;
        };

        ChairListGrid = new(90, 164, 0, 0, 220, 400, true, tabControl1.TabPages[0]);
        ChairListGrid.Dock = DockStyle.Fill;
        ChairListGrid.SearchGrid.Dock = DockStyle.Fill;

        var Graphic = ChairListGrid.CreateGraphics();
        var Font = new System.Drawing.Font(FontFamily.GenericSansSerif, 20, FontStyle.Bold);
        Graphic.DrawString("Loading...", Font, Brushes.Black, 10, 50);


        ChairListGrid.CellClick += (s, e) =>
        {
            CellClick(ChairListGrid, e);
        };

        ChairListGrid.SearchGrid.CellClick += (s, e) =>
        {
            CellClick(ChairListGrid.SearchGrid, e);
        };

        ChairListGrid.SetToolTipEvent(WzType.Item, this);


        Win32.SendMessage(ChairListGrid.Handle, false);

        Wz_Node Entry = null;
        if (Wz.HasNode("String/Ins.img"))
            Entry = Wz.GetNode("String/Ins.img");
        else if (Wz.HasNode("String/Item.img/Ins")) //old Data.wz
            Entry = Wz.GetNode("String/Item.img/Ins");
        foreach (var Img in Wz.GetNodeA("Item/Install").Nodes)
        {
            if (Img.Text.LeftStr(4) != "0301" && Img.Text.LeftStr(4) != "0302")
                continue;
            foreach (var Iter in Wz.GetNodeA("Item/Install/" + Img.Text).Nodes)
            {
                string ChairName = Entry.GetStr(Iter.Text.IntID() + "/name");
                Bitmap Bmp = null;
                if (Iter.HasNode("info/icon"))
                    Bmp = Iter.GetNode("info/icon").ExtractPng();
                ChairListGrid.Rows.Add(Iter.Text, Bmp, ChairName);
            }
        }

        if (Wz.HasNode("Item/Cash/0520.img"))
        {
            foreach (var Iter in Wz.GetNodes("Item/Cash/0520.img"))
            {
                if (Iter.Text.LeftStr(5) != "05204")
                    continue;
                string ChairName = Wz.GetStr("String/Cash.img/" + Iter.Text.IntID() + "/name");
                Bitmap Bmp = null;
                if (Iter.HasNode("info/icon"))
                    Bmp = Iter.GetNode("info/icon").ExtractPng();
                ChairListGrid.Rows.Add(Iter.Text, Bmp, ChairName);

            }
        }
        Win32.SendMessage(ChairListGrid.Handle, true);
        ChairListGrid.Refresh();

        for (int i = 0; i < ChairListGrid.Rows.Count; i++)
        {
            ChairListGrid.Rows[i].Cells[1].Style.Alignment = DataGridViewContentAlignment.MiddleCenter;
            ChairListGrid.Rows[i].Cells[2].Style.Alignment = DataGridViewContentAlignment.TopLeft;
        }

        ChairListGrid.Sort(ChairListGrid.Columns[0], ListSortDirection.Ascending);
    }

    private void textBox1_TextChanged(object sender, EventArgs e)
    {
        ChairListGrid.Search(textBox1.Text);
    }

    private void ChairForm_KeyDown(object sender, KeyEventArgs e)
    {
        if (e.Alt)
            e.Handled = true;
        if (!textBox1.Focused)
            ActiveControl = null;
    }

    private void ChairForm_FormClosing(object sender, FormClosingEventArgs e)
    {
        MainForm.Instance.ToolTipView.Visible = false;
    }
}

```

`MapleNecrocer/ChairForm.resx`:

```resx
<root>
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`MapleNecrocer/CharaSim/CharaEquip.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace WzComparerR2.CharaSim
{
    public class CharaEquip
    {
        public CharaEquip()
        {
            int slotsCount = 66;
            gearSlots = new Gear[slotsCount];
            cashGearSlots = new Gear[slotsCount];
        }

        public const int RingCount = 6;
        public const int PendantCount = 2;

        private Gear[] gearSlots;
        private Gear[] cashGearSlots;


        public Gear[] GearSlots
        {
            get { return gearSlots; }
        }

        public Gear[] CashGearSlots
        {
            get { return cashGearSlots; }
        }

        public int GetGearSlot(GearType type, int index)
        {
            switch (type)
            {
                //line 0
                case GearType.badge: return 0;
                case GearType.cap: return 1;
                case GearType.ring:
                    switch (index)
                    {
                        case 0: return 8;
                        case 1: return 9;
                        case 2: return 23;
                        case 3: return 24;
                        case 4: return 2;
                        case 5: return 7;
                        default: return -1;
                    }
                case GearType.android: return 3;
                case GearType.machineHeart: return 4;
                //line 1
                case GearType.medal: return 5;
                case GearType.faceAccessory: return 6;
                //line 2
                case GearType.pocket: return 10;
                case GearType.eyeAccessory: return 11;
                case GearType.pendant:
                    switch (index)
                    {
                        case 0: return 17;
                        case 1: return 12;
                        default: return -1;
                    }
                case GearType.earrings: return 13;
                case GearType.shoulderPad: return 14;
                //line 3
                case GearType.cape: return 15;
                case GearType.coat:
                case GearType.longcoat: return 16;
                default:
                    if (Gear.IsLeftWeapon(type) || Gear.IsDoubleHandWeapon(type))
                        return 18;
                    else if (Gear.IsSubWeapon(type))
                        return 19;
                    else
                        return -1;
                //line 4
                case GearType.glove: return 20;
                case GearType.pants: return 21;
                case GearType.belt: return 22;
                //line 5
                case GearType.shoes: return 27;
                //dragon
                case GearType.dragonMask: return 35;
                case GearType.dragonPendant: return 36;
                case GearType.dragonWings: return 37;
                case GearType.dragonTail: return 38;
                //machine
                case GearType.machineTransistors: return 39;
                case GearType.machineEngine: return 40;
                case GearType.machineBody: return 41;
                case GearType.machineArms: return 42;
                case GearType.machineLegs: return 43;
                //totem
                case GearType.totem:
                    switch (index)
                    {
                        case 0: return 44;
                        case 1: return 45;
                        case 2: return 46;
                        default: return -1;
                    }
            }
        }

        public IEnumerable<Gear> GearsEquiped
        {
            get
            {
                foreach (Gear gear in gearSlots)
                {
                    if (gear != null)
                        yield return gear;
                }
                foreach (Gear gear in cashGearSlots)
                {
                    if (gear != null)
                        yield return gear;
                }
            }
        }

        public bool AddGear(Gear gear, out Gear[] removedGears)
        {
            if (gear == null)
            {
                removedGears = new Gear[0];
                return false;
            }
            int emptyIdx = GetEmptySlotIndex(gear.type, gear.Cash);
            return AddGear(gear, emptyIdx, out removedGears);
        }

        public bool AddGear(Gear gear, int index, out Gear[] removedGears)
        {
            if (gear == null)
            {
                removedGears = new Gear[0];
                return false;
            }
            int slotIdx = GetGearSlot(gear.type, index);
            if (slotIdx == -1)
            {
                removedGears = new Gear[0];
                return false;
            }
            List<Gear> removedGearList = new List<Gear>();

            Gear[] slotList = gear.Cash ? cashGearSlots : gearSlots;
            if (slotList[slotIdx] != null) //移除同槽
            {
                removedGearList.Add(slotList[slotIdx]);
            }
            slotList[slotIdx] = gear; //装备上
            Gear preRemove = getPreRemoveGears(gear.type, gear.Cash);
            if (preRemove != null) //移除冲突装备
            {
                removedGearList.Add(preRemove);
            }

            removedGears = removedGearList.ToArray();
            return true;
        }

        public int GetEmptySlotIndex(GearType gearType, bool cash)
        {
            Gear[] slotList = cash ? cashGearSlots : gearSlots;
            int max;
            switch (gearType)
            {
                case GearType.ring: max = RingCount; break;
                case GearType.pendant: max = PendantCount; break;
                default: return 0;
            }
            for (int i = 0; i < max; i++)
            {
                if (slotList[GetGearSlot(gearType, i)] == null)
                    return i;
            }
            return 0;
        }

        private Gear getPreRemoveGears(GearType newGearType, bool cash)
        {
            Gear[] slotList = cash ? cashGearSlots : gearSlots;

            if (Gear.IsDoubleHandWeapon(newGearType)) //双手 移除副手
            {
                Gear gear = slotList[GetGearSlot(GearType.shield, 0)];
                if (gear != null)
                    return gear;
            }
            else if (Gear.IsSubWeapon(newGearType)) //副手 移除双手
            {
                Gear gear = slotList[GetGearSlot(GearType.ohSword, 0)];
                if (gear != null
                    && (Gear.IsDoubleHandWeapon(gear.type)
                    || (newGearType != GearType.magicArrow && gear.type == GearType.dualBow))) //非魔法箭 移除双弓的主手
                    return gear;
            }
            else if (newGearType == GearType.dualBow) //双弩 移除非魔法箭的副手
            {
                Gear gear = slotList[GetGearSlot(GearType.magicArrow, 0)];
                if (gear != null && gear.type != GearType.magicArrow)
                {
                    return gear;
                }
            }
            else if (newGearType == GearType.pants) //下装 移除套服
            {
                Gear gear = slotList[GetGearSlot(GearType.longcoat, 0)];
                if (gear != null && gear.type == GearType.longcoat)
                {
                    return gear;
                }
            }
            else if (newGearType == GearType.pants) //套服 移除下装
            {
                Gear gear = slotList[GetGearSlot(GearType.pants, 0)];
                if (gear != null && gear.type == GearType.pants)
                {
                    return gear;
                }
            }

            return null;
        }
    }
}

```

`MapleNecrocer/CharaSim/CharaProp.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace WzComparerR2.CharaSim
{
    public class CharaProp
    {
        public CharaProp()
        {
        }

        public CharaProp(int totalMax)
        {
            this.totalMax = totalMax;
        }

        private int baseVal; //基础值
        private int gearAdd; //装备附加值
        private int buffAdd; //技能buff增加值
        private int eBuffAdd; //技能增加的enhance值
        private int rate; //装备潜能百分比
        private int aBuffRate; //主动buff百分比 如骰子
        private int pBuffRate; //被动buff百分比 如盾防精通
        private int totalMax;
        private bool smart; //当前的技能buff增加值是否为smart
        
        public int BaseVal
        {
            get { return baseVal; }
            set { baseVal = value; }
        }
        
        public int GearAdd
        {
            get { return gearAdd; }
            set { gearAdd = value; }
        }
        
        public int BuffAdd
        {
            get { return buffAdd; }
            set { buffAdd = value; }
        }
        
        public int EBuffAdd
        {
            get { return eBuffAdd; }
            set { eBuffAdd = value; }
        }
        
        public int Rate
        {
            get { return rate; }
            set { rate = value; }
        }

        public int ABuffRate
        {
            get { return aBuffRate; }
            set { aBuffRate = value; }
        }
        
        public int PBuffRate
        {
            get { return pBuffRate; }
            set { pBuffRate = value; }
        }
        
        public bool Smart
        {
            get { return smart; }
            set { smart = value; }
        }

        public int TotalMax
        {
            get { return totalMax; }
            set { totalMax = value; }
        }

        public int GetSum()
        {
            int origSum = (baseVal + gearAdd + buffAdd + eBuffAdd) * (100 + rate + aBuffRate + pBuffRate) / 100;
            return this.totalMax > 0 ? Math.Min(this.totalMax, origSum) : origSum;
        }

        public int GetGearReqSum()
        {
            int origSum = (baseVal + gearAdd + buffAdd) * (100 + rate + aBuffRate + pBuffRate) / 100;
            return this.totalMax > 0 ? Math.Min(this.totalMax, origSum) : origSum;
        }

        public void ResetAdd()
        {
            gearAdd = 0;
            eBuffAdd = 0;
            buffAdd = 0;
            rate = 0;
            aBuffRate = 0;
            pBuffRate = 0;
            smart = false;
        }

        public void ResetAll()
        {
            baseVal = 0;
            ResetAdd();
        }

        public override string ToString()
        {
            int sum = GetSum();
            return baseVal == sum ? baseVal.ToString() :
                string.Format("{0} ({1}+{2})", sum, baseVal, sum - baseVal);
        }

        public string ToStringDetail(out int red)
        {
            int sum = GetSum();
            int baseSum = (baseVal + gearAdd) +
                (baseVal + gearAdd + buffAdd + eBuffAdd) * (rate + aBuffRate) / 100;
            if (buffAdd == 0 && eBuffAdd == 0 && pBuffRate == 0 && baseSum <= sum)
            {
                red = Math.Sign(aBuffRate);
                return baseSum.ToString();
            }

            red = Math.Sign(sum - baseSum);
            return (sum == baseSum) ? sum.ToString() :
                string.Format("{0} ({1}{2}{3})", sum, baseSum, (sum - baseSum >= 0) ? "+" : "-", sum - baseSum);
        }
    }
}

```

`MapleNecrocer/CharaSim/CharaSimLoader.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;
using WzComparerR2.WzLib;
using WzComparerR2.PluginBase;

namespace WzComparerR2.CharaSim
{
    public static class CharaSimLoader
    {
        static CharaSimLoader()
        {
            LoadedSetItems = new Dictionary<int, SetItem>();
            LoadedExclusiveEquips = new Dictionary<int, ExclusiveEquip>();
            LoadedCommoditiesBySN = new Dictionary<int, Commodity>();
            LoadedCommoditiesByItemId = new Dictionary<int, Commodity>();
        }

        public static Dictionary<int, SetItem> LoadedSetItems { get; private set; }
        public static Dictionary<int, ExclusiveEquip> LoadedExclusiveEquips { get; private set; }
        public static Dictionary<int, Commodity> LoadedCommoditiesBySN { get; private set; }
        public static Dictionary<int, Commodity> LoadedCommoditiesByItemId { get; private set; }

        public static void LoadSetItemsIfEmpty()
        {
            if (LoadedSetItems.Count == 0)
            {
                LoadSetItems();
            }
        }

        public static void LoadSetItems()
        {
            //搜索setItemInfo.img
            Wz_Node etcWz = PluginManager.FindWz(Wz_Type.Etc);
            if (etcWz == null)
                return;
            Wz_Node setItemNode = etcWz.FindNodeByPath("SetItemInfo.img", true);
            if (setItemNode == null)
                return;

            //搜索ItemOption.img
            Wz_Node itemWz = PluginManager.FindWz(Wz_Type.Item);
            if (itemWz == null)
                return;
            Wz_Node optionNode = itemWz.FindNodeByPath("ItemOption.img", true);
            if (optionNode == null)
                return;

            LoadedSetItems.Clear();
            foreach (Wz_Node node in setItemNode.Nodes)
            {
                int setItemIndex;
                if (Int32.TryParse(node.Text, out setItemIndex))
                {
                    SetItem setItem = SetItem.CreateFromNode(node, optionNode);
                    if (setItem != null)
                        LoadedSetItems[setItemIndex] = setItem;
                }
            }
        }

        public static void LoadExclusiveEquipsIfEmpty()
        {
            if (LoadedExclusiveEquips.Count == 0)
            {
                LoadExclusiveEquips();
            }
        }

        public static void LoadExclusiveEquips()
        {
            Wz_Node exclusiveNode = PluginManager.FindWz("Etc/ExclusiveEquip.img");
            if (exclusiveNode == null)
                return;

            LoadedExclusiveEquips.Clear();
            foreach (Wz_Node node in exclusiveNode.Nodes)
            {
                int exclusiveEquipIndex;
                if (Int32.TryParse(node.Text, out exclusiveEquipIndex))
                {
                    ExclusiveEquip exclusiveEquip = ExclusiveEquip.CreateFromNode(node);
                    if (exclusiveEquip != null)
                        LoadedExclusiveEquips[exclusiveEquipIndex] = exclusiveEquip;
                }
            }
        }

        public static void LoadCommoditiesIfEmpty()
        {
            if (LoadedCommoditiesBySN.Count == 0 && LoadedCommoditiesByItemId.Count == 0)
            {
                LoadCommodities();
            }
        }

        public static void LoadCommodities()
        {
            Wz_Node commodityNode = PluginManager.FindWz("Etc/Commodity.img");
            if (commodityNode == null)
                return;

            LoadedCommoditiesBySN.Clear();
            LoadedCommoditiesByItemId.Clear();
            foreach (Wz_Node node in commodityNode.Nodes)
            {
                int commodityIndex;
                if (Int32.TryParse(node.Text, out commodityIndex))
                {
                    Commodity commodity = Commodity.CreateFromNode(node);
                    if (commodity != null)
                    {
                        LoadedCommoditiesBySN[commodity.SN] = commodity;
                        if (commodity.ItemId / 10000 == 910)
                            LoadedCommoditiesByItemId[commodity.ItemId] = commodity;
                    }
                }
            }
        }

        public static void ClearAll()
        {
            LoadedSetItems.Clear();
            LoadedExclusiveEquips.Clear();
        }

        public static int GetActionDelay(string actionName)
        {
            if (string.IsNullOrEmpty(actionName))
            {
                return 0;
            }
            Wz_Node actionNode = PluginManager.FindWz("Character/00002000.img/" + actionName);
            if (actionNode == null)
            {
                return 0;
            }

            int delay = 0;
            foreach (Wz_Node frameNode in actionNode.Nodes)
            {
                Wz_Node delayNode = frameNode.Nodes["delay"];
                if (delayNode != null)
                {
                    delay += Math.Abs(delayNode.GetValue<int>());
                }
            }

            return delay;
        }
    }
}

```

`MapleNecrocer/CharaSim/Character.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace WzComparerR2.CharaSim
{
    public class Character
    {
        public Character()
        {
            this.status = new CharacterStatus();
            this.status.Job = 0;
            this.status.Level = 1;
            this.status.MaxHP.BaseVal = 50;
            this.status.HP = 50;
            this.status.MaxMP.BaseVal = 10;
            this.status.MP = 10;
            this.status.Strength.BaseVal = 12;
            this.status.Dexterity.BaseVal = 5;
            this.status.Intelligence.BaseVal = 4;
            this.status.Luck.BaseVal = 4;

            this.status.CriticalRate.BaseVal = 5;
            this.status.MoveSpeed.BaseVal = 100;
            this.status.Jump.BaseVal = 100;
            //this.status.CriticalDamageMax.BaseVal = 150;
            //this.status.CriticalDamageMin.BaseVal = 120;
            this.status.CriticalDamage.BaseVal = 0;

            this.itemSlots = new ItemBase[5][];
            for (int i = 0; i < this.itemSlots.Length; i++)
            {
                this.itemSlots[i] = new ItemBase[96];
            }

            this.equip = new CharaEquip();
        }

        private static FormulaVersion version;

        /// <summary>
        /// 获取或设置角色属性计算的公式版本。
        /// </summary>
        public static FormulaVersion Version
        {
            get { return Character.version; }
            set { Character.version = value; }
        }

        private string name;
        private string guild;
        private CharacterStatus status;
        private ItemBase[][] itemSlots;
        private CharaEquip equip;

        public string Name
        {
            get { return name; }
            set { name = value; }
        }

        public string Guild
        {
            get { return guild; }
            set { guild = value; }
        }

        public CharacterStatus Status
        {
            get { return status; }
        }

        public ItemBase[][] ItemSlots
        {
            get { return itemSlots; }
        }
        public CharaEquip Equip
        {
            get { return equip; }
            set { equip = value; }
        }

        public void UpdateProps()
        {
            status.Strength.ResetAdd();
            status.Dexterity.ResetAdd();
            status.Intelligence.ResetAdd();
            status.Luck.ResetAdd();
            status.MaxHP.ResetAdd();
            status.MaxMP.ResetAdd();

            status.PADamage.ResetAll();
            status.MADamage.ResetAll();
            status.PDDamage.ResetAll();
            status.MDDamage.ResetAll();
            status.PAccurate.ResetAll();
            status.MAccurate.ResetAll();
            status.PEvasion.ResetAll();
            status.MEvasion.ResetAll();

            status.MoveSpeed.ResetAdd();
            status.Jump.ResetAdd();
            status.CriticalRate.ResetAdd();
            //status.CriticalDamageMax.ResetAdd();
            //status.CriticalDamageMin.ResetAdd();
            status.CriticalDamage.ResetAdd();
            status.DamageRate.ResetAll();

            //foreach (Buff buff in buffs)
            //{
            //    foreach (KeyValuePair<GearPropType, int> prop in buff.props)
            //    {
            //        AddBuffProp(prop.Key, prop.Value, buff.Type == BuffType.passiveSkill);
            //    }
            //}

            foreach (Gear gear in equip.GearsEquiped)
            {
                if (gear.State == GearState.enable)
                {
                    foreach (KeyValuePair<GearPropType, int> prop in gear.Props)
                    {
                        addProp(prop.Key, prop.Value);
                    }
                    foreach (Potential potential in gear.Options)
                    {
                        if (potential != null)
                        {
                            foreach (KeyValuePair<GearPropType, int> prop in potential.props)
                            {
                                addProp(prop.Key, prop.Value);
                            }
                        }
                    }
                    foreach (Addition addition in gear.Additions)
                    {
                        foreach (KeyValuePair<GearPropType, int> prop in getAdditionProps(addition))
                        {
                            addProp(prop.Key, prop.Value);
                        }
                    }
                }
            }

            checkSetItemEnabled();
            foreach (SetItem setItem in CharaSimLoader.LoadedSetItems.Values)
            {
                foreach (SetItemEffect effect in setItem.Effects.Values)
                {
                    if (effect.Enabled)
                    {
                        foreach (KeyValuePair<GearPropType, object> prop in effect.Props)
                        {
                            if (prop.Key == GearPropType.Option)
                            {
                                List<Potential> potens = prop.Value as List<Potential>;
                                foreach (Potential p in potens)
                                {
                                    foreach (KeyValuePair<GearPropType, int> pprop in p.props)
                                    {
                                        addProp(pprop.Key, pprop.Value);
                                    }
                                }
                            }
                            else
                            {
                                addProp(prop.Key, Convert.ToInt32(prop.Value));
                            }
                        }
                    }
                }
            }

            int[] sum = new int[4] { status.Strength.GetSum(),
                status.Dexterity.GetSum(),
                status.Intelligence.GetSum(),
                status.Luck.GetSum() };
            if (version == FormulaVersion.Bigbang)
            {
                status.PDDamage.BaseVal = (int)Math.Floor(sum[0] * 1.2 + sum[1] * 0.5 + sum[2] * 0.4 + sum[3] * 0.5);
                status.MDDamage.BaseVal = (int)Math.Floor(sum[0] * 0.4 + sum[1] * 0.5 + sum[2] * 1.2 + sum[3] * 0.5);
                status.PAccurate.BaseVal = (int)Math.Floor(sum[1] * 1.2 + sum[3] * 1.0);
                status.MAccurate.BaseVal = (int)Math.Floor(sum[2] * 1.2 + sum[3] * 1.0);
                status.PEvasion.BaseVal = sum[1] * 1 + sum[3] * 2;
                status.MEvasion.BaseVal = sum[2] * 1 + sum[3] * 2;
            }
            else if (version == FormulaVersion.Chaos)
            {
                status.PDDamage.BaseVal = (int)Math.Floor(sum[0] * 1.5 + sum[1] * 0.4 + sum[2] * 0 + sum[3] * 0.4);
                status.MDDamage.BaseVal = (int)Math.Floor(sum[0] * 0 + sum[1] * 0.4 + sum[2] * 1.5 + sum[3] * 0.4);
                status.PAccurate.BaseVal = (int)Math.Floor(sum[0] * 0.4 + sum[1] * 1.6 + sum[2] * 0 + sum[3] * 0.8);
                status.MAccurate.BaseVal = (int)Math.Floor(sum[0] * 0 + sum[1] * 0.4 + sum[2] * 1.6 + sum[3] * 0.8);
                status.PEvasion.BaseVal = (int)Math.Floor(sum[0] * 0.2 + sum[1] * 0.6 + sum[2] * 0 + sum[3] * 1.4);
                status.MEvasion.BaseVal = (int)Math.Floor(sum[0] * 0 + sum[1] * 0.2 + sum[2] * 0.6 + sum[3] * 1.4);
            }
        }

        private void addProp(GearPropType type, int value)
        {
            switch (type)
            {
                case GearPropType.incSTR: status.Strength.GearAdd += value; break;
                case GearPropType.incSTRr: status.Strength.Rate += value; break;
                case GearPropType.incDEX: status.Dexterity.GearAdd += value; break;
                case GearPropType.incDEXr: status.Dexterity.Rate += value; break;
                case GearPropType.incINT: status.Intelligence.GearAdd += value; break;
                case GearPropType.incINTr: status.Intelligence.Rate += value; break;
                case GearPropType.incLUK: status.Luck.GearAdd += value; break;
                case GearPropType.incLUKr: status.Luck.Rate += value; break;
                case GearPropType.incAllStat:
                    status.Strength.GearAdd += value;
                    status.Dexterity.GearAdd += value;
                    status.Intelligence.GearAdd += value;
                    status.Luck.GearAdd += value;
                    break;
                case GearPropType.incPAD: status.PADamage.GearAdd += value; break;
                case GearPropType.incPADr: status.PADamage.Rate += value; break;
                case GearPropType.incPDD: status.PDDamage.GearAdd += value; break;
                case GearPropType.incPDDr: status.PDDamage.Rate += value; break;
                case GearPropType.incMAD: status.MADamage.GearAdd += value; break;
                case GearPropType.incMADr: status.MADamage.Rate += value; break;
                case GearPropType.incMDD: status.MDDamage.GearAdd += value; break;
                case GearPropType.incMDDr: status.MDDamage.Rate += value; break;

                case GearPropType.incACC: status.PAccurate.GearAdd += value; status.MAccurate.GearAdd += value; break;
                case GearPropType.incACCr: status.PAccurate.Rate += value; status.MAccurate.Rate += value; break;
                case GearPropType.incEVA: status.PEvasion.GearAdd += value; status.MEvasion.GearAdd += value; break;
                case GearPropType.incEVAr: status.PEvasion.Rate += value; status.MEvasion.Rate += value; break;
                case GearPropType.incCr: status.CriticalRate.GearAdd += value; break;

                case GearPropType.incMHP: status.MaxHP.GearAdd += value; break;
                case GearPropType.incMHPr: status.MaxHP.Rate += value; break;
                case GearPropType.incMMP: status.MaxMP.GearAdd += value; break;
                case GearPropType.incMMPr: status.MaxMP.Rate += value; break;
                case GearPropType.incSpeed: status.MoveSpeed.GearAdd += value; break;
                case GearPropType.incJump: status.Jump.GearAdd += value; break;

                //case GearPropType.incCriticaldamageMax: status.CriticalDamageMax.GearAdd += value; break;
                //case GearPropType.incCriticaldamageMin: status.CriticalDamageMin.GearAdd += value; break;
                case GearPropType.incCriticaldamage: status.CriticalDamage.GearAdd += value; break;
            }
        }

        private Dictionary<GearPropType, int> getAdditionProps(Addition addition)
        {
            Dictionary<GearPropType, int> props = new Dictionary<GearPropType, int>();
            if (addition != null &&
                (addition.Type == AdditionType.critical || addition.Type == AdditionType.statinc))
            {
                bool con = false;
                switch (addition.ConType)
                {
                    case GearPropType.reqLevel:
                        con = (this.status.Level >= addition.ConValue[0]);
                        break;
                    case GearPropType.reqJob:
                        foreach (int val in addition.ConValue)
                        {
                            con |= this.status.Job == val;
                        }
                        break;
                    case GearPropType.reqCraft:
                    default:
                        con = true;
                        break;
                }
                if (con)
                {
                    string strcr; int cr;
                    if (addition.Props.TryGetValue("prob", out strcr) && Int32.TryParse(strcr, out cr))
                        props.Add(GearPropType.incCr, cr);

                    if (addition.Type == AdditionType.statinc)
                    {
                        foreach (var kv in addition.Props)
                        {
                            try
                            {
                                GearPropType propType = (GearPropType)Enum.Parse(typeof(GearPropType), kv.Key);
                                if ((int)propType > 0 && (int)propType < 100)
                                    props.Add(propType, Convert.ToInt32(kv.Value));
                            }
                            catch
                            {
                            }
                        }
                    }
                }
            }
            return props;
        }

        private void checkSetItemEnabled()
        {
            //重置所有setItem
            List<int> idList = new List<int>();
            foreach (SetItem setItem in CharaSimLoader.LoadedSetItems.Values)
            {
                foreach (KeyValuePair<int, SetItemIDPart> idPart in setItem.ItemIDs.Parts)
                {
                    idList.AddRange(idPart.Value.ItemIDs.Keys);
                    foreach (int id in idList)
                    {
                        idPart.Value.ItemIDs[id] = false;
                    }
                    idList.Clear();
                }
                setItem.currentCount = 0;
            }
            //验证有效装备
            int setItemID;
            foreach (Gear gear in equip.GearsEquiped)
            {
                if (gear.State == GearState.enable
                    && gear.Props.TryGetValue(GearPropType.setItemID, out setItemID))
                {
                    CharaSimLoader.LoadedSetItems[setItemID].ItemIDs[gear.ItemID] = true;
                    CharaSimLoader.LoadedSetItems[setItemID].currentCount++;
                }
            }
            //验证所有setItem
            foreach (SetItem setItem in CharaSimLoader.LoadedSetItems.Values)
            {
                foreach (KeyValuePair<int, SetItemEffect> effect in setItem.Effects)
                {
                    effect.Value.Enabled = (setItem.currentCount >= effect.Key);
                }
            }
        }

        public void ChangeGear(Gear newGear)
        {
            int emptyIdx = this.equip.GetEmptySlotIndex(newGear.type, newGear.Cash);
            ChangeGear(newGear, emptyIdx);
        }

        public void ChangeGear(Gear newGear, int index)
        {
            ItemBase[] itemTab = this.itemSlots[0];
            int newGearIndex = Array.IndexOf<ItemBase>(itemTab, newGear);
            if (newGearIndex < 0 || newGear.State != GearState.itemList)
            {
                throw new InvalidOperationException("Unknown Error: Equipment not in the inventory.");
            }

            int onlyEquip;
            if (newGear.Props.TryGetValue(GearPropType.onlyEquip, out onlyEquip) && onlyEquip > 0)
            {
                foreach (Gear gear in this.equip.GearsEquiped)
                {
                    if (gear.ItemID == newGear.ItemID)
                    {
                        throw new InvalidOperationException("This item can only be equipped at any one time.");
                    }
                }
            }

            string errorString;
            if (!checkGearReq(newGear, out errorString))
            {
                throw new InvalidOperationException(errorString);
            }

            Gear[] removedGear;
            if (!this.equip.AddGear(newGear, out removedGear))
            {
                throw new InvalidOperationException("Unknown Error: Failed to add equipment.");
            }

            CheckGearEnabled();

            if (newGear.State == GearState.enable)
            {
                Queue<int> emptyItemSlot = new Queue<int>();
                emptyItemSlot.Enqueue(newGearIndex);

                if (removedGear.Length > 1) //检查剩余背包大小
                {
                    for (int i = 0; i < itemTab.Length; i++)
                    {
                        if (itemTab[i] == null)
                        {
                            emptyItemSlot.Enqueue(i);
                        }
                    }
                }
                if (emptyItemSlot.Count >= removedGear.Length)
                {
                    for (int i = 0; i < removedGear.Length; i++)
                    {
                        Gear gear = removedGear[i];
                        gear.State = GearState.itemList;
                        itemTab[emptyItemSlot.Dequeue()] = gear;
                    }
                    return; //函数出口
                }
                else
                {
                    errorString = "Your inventory is full.";
                }
            }
            else
            {
                errorString = "You do not meet the required conditions to equip this item.";
            }

            //还原装备
            foreach (Gear gear in removedGear)
            {
                Gear[] arg;
                this.equip.AddGear(gear, index, out arg); //可以证明直接输入index是可以还原的。
            }
            newGear.State = GearState.itemList;
            throw new InvalidOperationException(errorString);
        }

        private bool checkGearReq(Gear gear, out string errorMessage)
        {
            if (Gear.IsMechanicGear(gear.type) && status.Job / 100 != 35)
            {
                errorMessage = "Mechanic only";
                return false;
            }
            if (Gear.IsDragonGear(gear.type) && status.Job / 100 != 22)
            {
                errorMessage = "Evan only";
                return false;
            }
            if (gear.type == GearType.katara && status.Job / 10 != 43)
            {
                errorMessage = "Dual Blades only";
                return false;
            }
            if (gear.type == GearType.shield &&
                (status.Job / 10 == 43 || status.Job / 100 == 23 || status.Job / 100 == 31))
            {
                errorMessage = "This class cannot equip shields.";
                return false;
            }
            if (gear.type == GearType.magicArrow && status.Job / 100 != 23)
            {
                errorMessage = "Mercedes only";
                return false;
            }
            if (gear.type == GearType.demonShield && status.Job / 100 != 31)
            {
                errorMessage = "Demon only";
                return false;
            }
            if (!checkGearPropReq(gear))
            {
                errorMessage = "You do not meet the required conditions to equip this item.";
                return false;
            }
            errorMessage = null;
            return true;
        }

        private bool checkGearPropReq(Gear gear)
        {
            return checkGearPropReq(gear.Props, GearPropType.reqSTR, status.Strength.GetGearReqSum())
                && checkGearPropReq(gear.Props, GearPropType.reqDEX, status.Dexterity.GetGearReqSum())
                && checkGearPropReq(gear.Props, GearPropType.reqINT, status.Intelligence.GetGearReqSum())
                && checkGearPropReq(gear.Props, GearPropType.reqLUK, status.Luck.GetGearReqSum())
                && checkGearPropReq(gear.Props, GearPropType.reqLevel, status.Level)
                && checkGearPropReq(gear.Props, GearPropType.reqPOP, status.Pop)
                && checkGearJobReq(gear.Props, gear.type);
        }

        private bool checkGearPropReq(Dictionary<GearPropType, int> props, GearPropType prop, int value)
        {
            int v;
            if (!props.TryGetValue(prop, out v) || value >= v)
            {
                return true;
            }
            return false;
        }

        private bool checkGearJobReq(Dictionary<GearPropType, int> props, GearType type)
        {
            int reqJob;
            props.TryGetValue(GearPropType.reqJob, out reqJob);
            int jobClass = status.Job % 1000 / 100;
            if (reqJob == 0) //全职
                return true;
            if (reqJob == -1) //新手
                return jobClass == 0;
            return (reqJob & (1 << (jobClass - 1))) != 0;
        }

        /// <summary>
        /// 检查指定的职业ID是否归属于标准职业。
        /// </summary>
        /// <param name="jobID">要检查的职业ID。</param>
        /// <param name="baseJob">标准职业代码。0-新手 1-战士 2-法师 3-弓手 4-飞侠 5-海盗</param>
        /// <returns></returns>
        public static bool CheckJobReq(int jobID, int baseJob)
        {
            switch (jobID / 100)
            {
                case 27: return baseJob == 2; //夜光
                case 36: return baseJob == 4 || baseJob == 5; //煎饼
                default:
                    return jobID / 100 % 10 == baseJob;
            }
        }

        public bool CheckGearEnabled()
        {
            List<Gear> gearsEquip = new List<Gear>(this.equip.GearsEquiped);
            List<GearState> oldStates = new List<GearState>(gearsEquip.Count);
            foreach (Gear gear in gearsEquip)
            {
                oldStates.Add(gear.State);
                gear.State = GearState.enable;
            }

            while (true)
            {
                bool reset = false;
                //逐个装备判定装备要求
                foreach (Gear gear in gearsEquip)
                {
                    if (gear.State == GearState.enable)
                    {
                        gear.State = GearState.disable;
                        UpdateProps();

                        //判定装备要求
                        if (!checkGearPropReq(gear))
                        {
                            reset = true; //如果不符合 无效化装备 进行下一轮判断
                            break;
                        }

                        //恢复有效性
                        gear.State = GearState.enable;
                    }
                }
                if (!reset) //如果本轮判断没变化则停止 可以证明是不会进入死循环的
                    break;
            }

            for (int i = 0; i < gearsEquip.Count; i++)
            {
                if (gearsEquip[i].State != oldStates[i]) //装备状态变化
                {
                    return true;
                }
            }

            return false;
        }

        public void CalcAttack(out double max, out double min)
        {
            int sign;
            CalcAttack(out max, out min, out sign);
        }

        public void CalcAttack(out double max, out double min, out int sign)
        {
            max = CalcAttack(status.Strength.GetSum(),
                status.Dexterity.GetSum(),
                status.Intelligence.GetSum(),
                status.Luck.GetSum(),
                status.PADamage.GetSum(),
                status.MADamage.GetSum(),
                GearType.totem,
                version);
            min = max * status.Mastery.GetSum() / 100;
            sign = 0;
        }

        public static double CalcAttack(int str, int dex, int inte, int luk, int pad, int mad,
            GearType WeaponType, FormulaVersion version)
        {
            switch (WeaponType)
            {
                case GearType.ohSword:
                case GearType.ohAxe:
                case GearType.ohBlunt:
                    return (str * 4 + dex) * 1.2 * pad * 0.01;
                case GearType.dagger:
                    return (str + dex + luk * 4) * 1.3 * pad * 0.01;
                case GearType.cane:
                    return (dex + luk * 4) * 1.3 * pad * 0.01;
                case GearType.wand:
                case GearType.staff:
                    return (inte * 4 + luk) * 1.0 * mad * 0.01;
                case GearType.barehand:
                    return (str * 4 + dex) * 1.43 * 1 * 0.01;
                case GearType.thSword:
                case GearType.thAxe:
                case GearType.thBlunt:
                    if (version == FormulaVersion.Bigbang)
                        return (str * 4 + dex) * 1.32 * pad * 0.01;
                    else if (version == FormulaVersion.Chaos)
                        return (str * 4 + dex) * 1.34 * pad * 0.01;
                    break;
                case GearType.spear:
                case GearType.polearm:
                    return (str * 4 + dex) * 1.49 * pad * 0.01;
                case GearType.bow:
                    if (version == FormulaVersion.Bigbang)
                        return (dex * 4 + str) * 1.2 * pad * 0.01;
                    else if (version == FormulaVersion.Chaos)
                        return (dex * 4 + str) * 1.3 * pad * 0.01;
                    break;

                case GearType.crossbow:
                    return (dex * 4 + str) * 1.35 * pad * 0.01;
                case GearType.throwingGlove:
                    return (dex + luk * 4) * 1.75 * pad * 0.01;
                case GearType.knuckle:
                    return (str * 4 + dex) * 1.7 * pad * 0.01;
                case GearType.gun:
                    return (dex * 4 + str) * 1.5 * pad * 0.01;
                case GearType.dualBow:
                    return (dex * 4 + str) * 1.3 * pad * 0.01;
                case GearType.handCannon:
                    return (str * 4 + dex) * 1.5 * pad * 0.01;
            }
            return 0;
        }

        private static long[] _exptnl = new long[]
        {
            15,34,57,92,
            135,372,560,840,
            1242,2207026470,2902427248153
        };

        public static long ExpToNextLevel(int level)
        {
            long exp;
            if (level < 1 || level > 300)
                return -1;
            if (level < 10)
                return _exptnl[level - 1];
            if (level >= 10 && level <= 14)
                return ExpToNextLevel(9);
            if (level >= 15 && level <= 29)
            {
                exp = ExpToNextLevel(14);
                while (level > 14)
                {
                    exp = (long)(exp * 1.2);
                    level -= 1;
                }
                return exp;
            }
            if (level >= 30 && level <= 34)
                return ExpToNextLevel(29);
            if (level >= 35 && level <= 39)
            {
                exp = ExpToNextLevel(34);
                while (level > 34)
                {
                    exp = (long)(exp * 1.2);
                    level -= 1;
                }
                return exp;
            }
            if (level >= 40 && level <= 59)
            {
                exp = ExpToNextLevel(39);
                while (level > 39)
                {
                    exp = (long)(exp * 1.08);
                    level -= 1;
                }
                return exp;
            }
            if (level >= 60 && level <= 64)
                return ExpToNextLevel(59);
            if (level >= 65 && level <= 74)
            {
                exp = ExpToNextLevel(64);
                while (level > 64)
                {
                    exp = (long)(exp * 1.075);
                    level -= 1;
                }
                return exp;
            }
            if (level >= 75 && level <= 89)
            {
                exp = ExpToNextLevel(74);
                while (level > 74)
                {
                    exp = (long)(exp * 1.07);
                    level -= 1;
                }
                return exp;
            }
            if (level >= 90 && level <= 99)
            {
                exp = ExpToNextLevel(89);
                while (level > 89)
                {
                    exp = (long)(exp * 1.065);
                    level -= 1;
                }
                return exp;
            }
            if (level >= 100 && level <= 104)
                return ExpToNextLevel(99);
            if (level >= 105 && level <= 139)
            {
                exp = ExpToNextLevel(104);
                while (level > 104)
                {
                    exp = (long)(exp * 1.065);
                    level -= 1;
                }
                return exp;
            }
            if (level >= 140 && level <= 169)
            {
                exp = ExpToNextLevel(139);
                while (level > 139)
                {
                    exp = (long)(exp * 1.0625);
                    level -= 1;
                }
                return exp;
            }
            if (level >= 170 && level <= 199)
            {
                exp = ExpToNextLevel(169);
                while (level > 169)
                {
                    exp = (long)(exp * 1.05);
                    level -= 1;
                }
                return exp;
            }
            if (level == 200)
                return _exptnl[9];
            if (level >= 201 && level <= 209)
            {
                exp = ExpToNextLevel(200);
                while (level > 200)
                {
                    exp = (long)(exp * 1.12);
                    level -= 1;
                }
                return exp;
            }
            if (level >= 210 && level <= 214)
            {
                exp = (long)(ExpToNextLevel(209) * 1.6);
                while (level > 210)
                {
                    exp = (long)(exp * 1.11);
                    level -= 1;
                }
                return exp;
            }
            if (level >= 215 && level <= 219)
            {
                exp = (long)(ExpToNextLevel(214) * 1.3);
                while (level > 215)
                {
                    exp = (long)(exp * 1.09);
                    level -= 1;
                }
                return exp;
            }
            if (level >= 220 && level <= 224)
            {
                exp = (long)(ExpToNextLevel(219) * 1.3);
                while (level > 220)
                {
                    exp = (long)(exp * 1.07);
                    level -= 1;
                }
                return exp;
            }
            if (level >= 225 && level <= 229)
            {
                exp = (long)(ExpToNextLevel(224) * 1.38);
                while (level > 225)
                {
                    exp = (long)(exp * 1.05);
                    level -= 1;
                }
                return exp;
            }
            if (level >= 230 && level <= 234)
            {
                exp = (long)(ExpToNextLevel(229) * 1.6);
                while (level > 230)
                {
                    exp = (long)(exp * 1.03);
                    level -= 1;
                }
                return exp;
            }
            if (level >= 235 && level <= 239)
            {
                exp = (long)(ExpToNextLevel(234) * 1.38);
                while (level > 235)
                {
                    exp = (long)(exp * 1.03);
                    level -= 1;
                }
                return exp;
            }
            if (level >= 240 && level <= 244)
            {
                exp = (long)(ExpToNextLevel(239) * 1.6);
                while (level > 240)
                {
                    exp = (long)(exp * 1.03);
                    level -= 1;
                }
                return exp;
            }
            if (level >= 245 && level <= 249)
            {
                exp = (long)(ExpToNextLevel(244) * 1.38);
                while (level > 245)
                {
                    exp = (long)(exp * 1.03);
                    level -= 1;
                }
                return exp;
            }
            if (level >= 250 && level <= 259)
            {
                exp = (long)(ExpToNextLevel(249) * 1.6 + 0.5);
                while (level > 250)
                {
                    exp = (long)(exp * 1.03);
                    level -= 1;
                }
                return exp;
            }
            if (level == 260)
                return _exptnl[10];
            if (level >= 261 && level <= 269)
            {
                exp = ExpToNextLevel(260);
                while (level > 260)
                {
                    exp = (long)(exp * 1.01);
                    level -= 1;
                }
                return exp;
            }
            if (level >= 270 && level <= 274)
            {
                exp = ExpToNextLevel(269) * 2;
                while (level > 269)
                {
                    exp = (long)(exp * 1.01);
                    level -= 1;
                }
                return exp;
            }
            if (level >= 275 && level <= 279)
            {
                exp = (long)(ExpToNextLevel(274) * 2.02);
                while (level > 275)
                {
                    exp = (long)(exp * 1.1);
                    level -= 1;
                }
                return exp;
            }
            if (level >= 280 && level <= 284)
            {
                exp = (long)(ExpToNextLevel(279) * 2.02);
                while (level > 280)
                {
                    exp = (long)(exp * 1.1);
                    level -= 1;
                }
                return exp;
            }
            if (level >= 285 && level <= 289)
            {
                exp = (long)(ExpToNextLevel(284) * 2.02);
                while (level > 285)
                {
                    exp = (long)(exp * 1.1);
                    level -= 1;
                }
                return exp;
            }
            if (level >= 290 && level <= 294)
            {
                exp = (long)(ExpToNextLevel(289) * 2.02);
                while (level > 290)
                {
                    exp = (long)(exp * 1.1);
                    level -= 1;
                }
                return exp;
            }
            if (level >= 295 && level <= 298)
            {
                exp = (long)(ExpToNextLevel(294) * 2.02);
                while (level > 295)
                {
                    exp = (long)(exp * 1.1);
                    level -= 1;
                }
                return exp;
            }
            if (level == 299)
                return (long)(ExpToNextLevel(298) * 1.5);
            return 0;
        }
    }
}

```

`MapleNecrocer/CharaSim/CharacterStatus.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Reflection;

namespace WzComparerR2.CharaSim
{
    public class CharacterStatus
    {
        public CharacterStatus()
        {
            this.maxHP = new CharaProp(99999);
            this.maxMP = new CharaProp(99999);
            this.pdd = new CharaProp(9999);
            this.mdd = new CharaProp(9999);
            this.pAcc = new CharaProp(9999);
            this.mAcc = new CharaProp(9999);
            this.pEva = new CharaProp(9999);
            this.mEva = new CharaProp(9999);

            FieldInfo[] fields = this.GetType().GetFields(BindingFlags.Instance | BindingFlags.NonPublic);
            foreach (FieldInfo f in fields)
            {
                if (f.FieldType == typeof(CharaProp) && f.GetValue(this) == null)
                {
                    f.SetValue(this, new CharaProp());
                }
            }
        }

        private int job;
        private int level;
        private int hp;
        private int mp;
        private long exp;
        private int ap;
        private int pop;

        private CharaProp maxHP;
        private CharaProp maxMP;
        private CharaProp str = null;
        private CharaProp dex = null;
        private CharaProp inte = null;
        private CharaProp luk = null;

        private CharaProp pad = null;
        private CharaProp mad = null;
        private CharaProp pdd;
        private CharaProp mdd;
        private CharaProp pAcc;
        private CharaProp mAcc;
        private CharaProp pEva;
        private CharaProp mEva;
        private CharaProp crit = null;
        private CharaProp move = null;
        private CharaProp jump = null;
        //private CharaProp critDamMax = null;
        //private CharaProp critDamMin = null;
        private CharaProp critDam = null;
        private CharaProp mastery = null;
        private CharaProp damR = null;
        private CharaProp bossDamR = null;
        private CharaProp finalDamR = null;
        private CharaProp ignoreMobDefR = null;
        private CharaProp statusRes = null;
        private CharaProp knockbackRes = null;

        #region 基础属性
        /// <summary>
        /// 获取或设置角色的职业代码。
        /// </summary>
        public int Job
        {
            get { return job; }
            set { job = value; }
        }
        
        /// <summary>
        /// 获取或设置角色的等级。
        /// </summary>
        public int Level
        {
            get { return level; }
            set { level = value; }
        }

        /// <summary>
        /// 获取或设置角色的当前HP。
        /// </summary>
        public int HP
        {
            get { hp = Math.Max(0, Math.Min(maxHP.GetSum(), hp)); return hp; }
            set { value = Math.Max(0, Math.Min(maxHP.GetSum(), value)); hp = value; }
        }

        /// <summary>
        /// 获取角色的HP上限。
        /// </summary>
        public CharaProp MaxHP
        {
            get { return maxHP; }
        }
        
        /// <summary>
        /// 获取或设置角色的当前MP。
        /// </summary>
        public int MP
        {
            get { mp = Math.Max(0, Math.Min(maxMP.GetSum(), mp)); return mp; }
            set { value = Math.Max(0, Math.Min(maxMP.GetSum(), value)); mp = value; }
        }

        /// <summary>
        /// 获取角色的MP上限。
        /// </summary>
        public CharaProp MaxMP
        {
            get { return maxMP; }
        }
        
        /// <summary>
        /// 获取或设置角色的当前经验值。
        /// </summary>
        public long Exp
        {
            get { exp = (Exptnl == -1) ? -1 : Math.Max(0, Math.Min(Exptnl - 1, exp)); return exp; }
            set { value = (Exptnl == -1) ? -1 : Math.Max(0, Math.Min(Exptnl - 1, value)); exp = value; }
        }

        /// <summary>
        /// 获取角色当前升级经验值。
        /// </summary>
        public long Exptnl
        {
            get { return Character.ExpToNextLevel(this.level); }
        }

        /// <summary>
        /// 获取或设置角色的人气度。
        /// </summary>
        public int Pop
        {
            get { return pop; }
            set { pop = value; }
        }

        /// <summary>
        /// 获取或设置角色的可分配AP。
        /// </summary>
        public int Ap
        {
            get { return ap; }
            set { if (value >= 0)ap = value; }
        }

        /// <summary>
        /// 获取角色的力量值。
        /// </summary>
        public CharaProp Strength
        {
            get { return str; }
        }
        
        /// <summary>
        /// 获取角色的敏捷值。
        /// </summary>
        public CharaProp Dexterity
        {
            get { return dex; }
        }
        
        /// <summary>
        /// 获取角色的智力值。
        /// </summary>
        public CharaProp Intelligence
        {
            get { return inte; }
        }

        /// <summary>
        /// 获取角色的运气值。
        /// </summary>
        public CharaProp Luck
        {
            get { return luk; }
        }
        #endregion

        #region 扩展属性
        /// <summary>
        /// 获取角色的攻击力，这是一个隐藏属性。
        /// </summary>
        public CharaProp PADamage
        {
            get { return pad; }
        }
        
        /// <summary>
        /// 获取角色的魔法攻击力，这是一个隐藏属性。
        /// </summary>
        public CharaProp MADamage
        {
            get { return mad; }
        }
        
        /// <summary>
        /// 获取角色的物理防御力。
        /// </summary>
        public CharaProp PDDamage
        {
            get { return pdd; }
        }

        /// <summary>
        /// 获取角色的魔法防御力。
        /// </summary>
        public CharaProp MDDamage
        {
            get { return mdd; }
        }
       
        /// <summary>
        /// 获取角色的物理命中率。
        /// </summary>
        public CharaProp PAccurate
        {
            get { return pAcc; }
        }
        
        /// <summary>
        /// 获取角色的魔法命中率。
        /// </summary>
        public CharaProp MAccurate
        {
            get { return mAcc; }
        }
        
        /// <summary>
        /// 获取角色的物理回避率。
        /// </summary>
        public CharaProp PEvasion
        {
            get { return pEva; }
        }
        
        /// <summary>
        /// 获取角色的魔法回避率。
        /// </summary>
        public CharaProp MEvasion
        {
            get { return mEva; }
        }
        
        /// <summary>
        /// 获取角色的暴击率，这是一个百分比属性。
        /// </summary>
        public CharaProp CriticalRate
        {
            get { return crit; }
        }
        
        /// <summary>
        /// 获取角色的移动速度，这是一个百分比属性。
        /// </summary>
        public CharaProp MoveSpeed
        {
            get { return move; }
        }
        
        /// <summary>
        /// 获取角色的跳跃力，这是一个百分比属性。
        /// </summary>
        public CharaProp Jump
        {
            get { return jump; }
        }
        
        /*/// <summary>
        /// 获取角色的暴击最大伤害，这是一个隐藏的百分比属性。
        /// </summary>
        public CharaProp CriticalDamageMax
        {
            get { return critDamMax; }
        }*/
        
        /*/// <summary>
        /// 获取角色的暴击最小伤害，这是一个隐藏的百分比属性。
        /// </summary>
        public CharaProp CriticalDamageMin
        {
            get { return critDamMin; }
        }*/

        /// <summary>
        /// 获取角色的暴击伤害，这是一个隐藏的百分比属性。
        /// </summary>
        public CharaProp CriticalDamage
        {
            get { return critDam; }
        }

        /// <summary>
        /// 获取角色的攻击熟练度，这是一个隐藏的百分比属性。
        /// </summary>
        public CharaProp Mastery
        {
            get { return mastery; }
        }
        
        /// <summary>
        /// 获取角色的攻击力百分比加成，这是一个隐藏的百分比属性。
        /// </summary>
        public CharaProp DamageRate
        {
            get { return damR; }
        }

        /// <summary>
        /// 获取角色的BOSS攻击力百分比加成，这是一个隐藏的百分比属性。
        /// </summary>
        public CharaProp BossDamageRate
        {
            get { return bossDamR; }
        }

        public CharaProp FinalDamageRate
        {
            get { return finalDamR; }
        }

        public CharaProp IgnoreMobDefenceRate
        {
            get { return ignoreMobDefR; }
        }

        public CharaProp StatusResistance
        {
            get { return statusRes; }
        }

        public CharaProp KnockbackResistance
        {
            get { return knockbackRes; }
        }
        #endregion
    }
}

```

`MapleNecrocer/CharaSimControl/AControl.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;
using System.Windows.Forms;

namespace WzComparerR2.CharaSimControl
{
    public abstract class AControl
    {
        public AControl()
        {
        }

        private Point location;
        private Size size;
        private bool visible;

        public Point Location
        {
            get { return location; }
            set { location = value; }
        }

        public Size Size
        {
            get { return size; }
            set { size = value; }
        }

        public bool Visible
        {
            get { return visible; }
            set { visible = value; }
        }

        public Rectangle Rectangle
        {
            get { return new Rectangle(this.location, this.size); }
        }

        public abstract void Draw(Graphics g);

        public virtual void OnMouseClick(MouseEventArgs e)
        {
            if (IsMouseContains(e.Location))
            {
                if (this.MouseClick != null)
                    this.MouseClick(this, e);
            }
        }

        public virtual void OnMouseDown(MouseEventArgs e)
        {
        }

        public virtual void OnMouseUp(MouseEventArgs e)
        {
        }

        public virtual void OnMouseMove(MouseEventArgs e)
        {
        }

        public virtual void OnMouseWheel(MouseEventArgs e)
        {
        }

        protected virtual bool IsMouseContains(Point mouseLocation)
        {
            return this.visible && this.Rectangle.Contains(mouseLocation);
        }

        protected MouseEventArgs ToChildEventargs(MouseEventArgs e)
        {
            return new MouseEventArgs(e.Button, e.Clicks, e.X - this.Location.X, e.Y - this.Location.Y, e.Delta);
        }

        public event MouseEventHandler MouseClick;
    }
}

```

`MapleNecrocer/CharaSimControl/ACtrlButton.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;
using System.Windows.Forms;

namespace WzComparerR2.CharaSimControl
{
    public class ACtrlButton : AControl
    {
        public ACtrlButton()
        {
            this.Visible = true;
        }

        private BitmapOrigin normal;
        private BitmapOrigin pressed;
        private BitmapOrigin mouseOver;
        private BitmapOrigin disabled;

        private ButtonState state;

        public BitmapOrigin Normal
        {
            get { return normal; }
            set { normal = value; }
        }

        public BitmapOrigin Pressed
        {
            get { return pressed; }
            set { pressed = value; }
        }

        public BitmapOrigin MouseOver
        {
            get { return mouseOver; }
            set { mouseOver = value; }
        }

        public BitmapOrigin Disabled
        {
            get { return disabled; }
            set { disabled = value; }
        }

        public ButtonState State
        {
            get { return state; }
            set
            {
                if (state != value)
                {
                    state = value;
                    OnButtonStateChanged();
                }
            }
        }

        public BitmapOrigin CurrentBitmap
        {
            get
            {
                switch (this.state)
                {
                    default:
                    case ButtonState.Normal: return this.normal;
                    case ButtonState.Pressed: return this.pressed;
                    case ButtonState.MouseOver: return this.mouseOver;
                    case ButtonState.Disabled: return this.disabled;
                }
            }
        }

        /// <summary>
        /// 应用当前的ButtonState和Location，绘制对应的图像。
        /// </summary>
        /// <param Name="g">要绘制的绘图表面。</param>
        public override void Draw(Graphics g)
        {
            this.Draw(g, new Point(0, 0));
        }

        /// <summary>
        /// 应用当前的ButtonState、Location以及给定的坐标偏移，绘制对应的图像。
        /// </summary>
        /// <param Name="g">要绘制的绘图表面。</param>
        /// <param Name="Offset">表示对于绘图原点的坐标偏移。</param>
        public void Draw(Graphics g, Point offset)
        {
            if (g == null || !this.Visible)
                return;
            BitmapOrigin bmp = this.CurrentBitmap;
            if (bmp.Bitmap != null)
                g.DrawImage(bmp.Bitmap, bmp.OpOrigin.X + this.Location.X + offset.X, bmp.OpOrigin.Y + this.Location.Y + offset.Y);
        }

        public override void OnMouseMove(MouseEventArgs e)
        {
            if (this.IsMouseContains(e.Location))
            {
                if (this.State == ButtonState.Normal)
                {
                    this.State = ButtonState.MouseOver;
                }
            }
            else if (this.state != ButtonState.Disabled)
            {
                this.State = ButtonState.Normal;
            }

            base.OnMouseMove(e);
        }

        public override void OnMouseDown(MouseEventArgs e)
        {
            if (this.IsMouseContains(e.Location))
            {
                if (this.State == ButtonState.Normal || this.State == ButtonState.MouseOver)
                {
                    this.State = ButtonState.Pressed;
                }
            }
            base.OnMouseDown(e);
        }

        public override void OnMouseUp(MouseEventArgs e)
        {
            if (this.IsMouseContains(e.Location))
            {
                if (this.State == ButtonState.Pressed)
                {
                    this.State = ButtonState.MouseOver;
                }
            }

            base.OnMouseUp(e);
        }

        protected virtual void OnButtonStateChanged()
        {
            if (this.ButtonStateChanged != null)
            {
                this.ButtonStateChanged(this, EventArgs.Empty);
            }
        }

        public override void OnMouseClick(MouseEventArgs e)
        {
            if (this.state != ButtonState.Disabled)
            {
                base.OnMouseClick(e);
            }
        }

        public event EventHandler ButtonStateChanged;
    }
}

```

`MapleNecrocer/CharaSimControl/ACtrlVScroll.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;
using System.Windows.Forms;

namespace WzComparerR2.CharaSimControl
{
    public class ACtrlVScroll : AControl
    {
        public ACtrlVScroll()
        {
            this.btnPrev = new ACtrlButton();
            this.btnNext = new ACtrlButton();
            this.btnThumb = new ACtrlButton();
            this.picBase = new ACtrlButton();
            this.btnPrev.ButtonStateChanged += new EventHandler(childBtn_ButtonStateChanged);
            this.btnPrev.MouseClick += new MouseEventHandler(btnPrev_MouseClick);
            this.btnNext.ButtonStateChanged += new EventHandler(childBtn_ButtonStateChanged);
            this.btnNext.MouseClick += new MouseEventHandler(btnNext_MouseClick);
            this.btnThumb.ButtonStateChanged += new EventHandler(childBtn_ButtonStateChanged);
            this.picBase.ButtonStateChanged += new EventHandler(childBtn_ButtonStateChanged);
        }

        ACtrlButton btnPrev;
        ACtrlButton btnNext;
        ACtrlButton btnThumb;
        ACtrlButton picBase;
        int minimum;
        int maximum;
        int value;
        bool isScrolling;

        public int Minimum
        {
            get { return minimum; }
            set
            {
                if (this.minimum != value)
                {
                    value = Math.Min(value, maximum);
                    minimum = value;
                    this.Value = this.Value;
                    this.OnValueChanged();
                }
            }
        }

        public int Maximum
        {
            get { return maximum; }
            set
            {
                if (this.maximum != value)
                {
                    value = Math.Max(minimum, value);
                    maximum = value;
                    this.Value = this.Value;
                    this.OnValueChanged();
                }
            }
        }

        public int Value
        {
            get
            {
                return this.value;
            }
            set
            {
                value = Math.Min(Math.Max(this.minimum, value), this.maximum);
                if (this.value != value)
                {
                    this.value = value;
                    this.OnValueChanged();
                }
            }
        }

        public ACtrlButton BtnPrev
        {
            get { return btnPrev; }
        }

        public ACtrlButton BtnNext
        {
            get { return btnNext; }
        }

        public ACtrlButton BtnThumb
        {
            get { return btnThumb; }
        }

        public ACtrlButton PicBase
        {
            get { return picBase; }
        }

        public bool Enabled
        {
            get { return !(this.minimum == this.maximum); }
        }

        private Point? scrollableLocation;
        private Size? scrollableSize;

        public Point? ScrollableLocation
        {
            get { return scrollableLocation; }
            set { scrollableLocation = value; }
        }

        public Size? ScrollableSize
        {
            get { return scrollableSize; }
            set { scrollableSize = value; }
        }

        public Rectangle ScrollableRectangle
        {
            get { return new Rectangle(this.scrollableLocation ?? this.Location, this.scrollableSize ?? this.Size); }
        }

        public override void OnMouseMove(MouseEventArgs e)
        {
            if (!this.Enabled)
            {
                setAllState(ButtonState.Disabled);
                return;
            }

            if (IsMouseContains(e.Location))
            {
                MouseEventArgs e2 = ToChildEventargs(e);

                foreach (ACtrlButton btn in this.buttons)
                {
                    btn.OnMouseMove(e2);
                }
                if (this.isScrolling)
                {
                    this.scrolling(e.Location);
                }
            }
            else
            {
                setAllState(ButtonState.Normal);
            }
            
            base.OnMouseMove(e);
        }

        public override void OnMouseDown(MouseEventArgs e)
        {
            if (!this.Enabled)
            {
                setAllState(ButtonState.Disabled);
                return;
            }

            if (IsMouseContains(e.Location))
            {
                this.isScrolling = true;
                MouseEventArgs e2 = ToChildEventargs(e);

                foreach (ACtrlButton btn in this.buttons)
                {
                    btn.OnMouseDown(e2);
                }
            }

            base.OnMouseDown(e);
        }

        public override void OnMouseUp(MouseEventArgs e)
        {
            if (!this.Enabled)
            {
                setAllState(ButtonState.Disabled);
                return;
            }

            if (IsMouseContains(e.Location))
            {
                MouseEventArgs e2 = ToChildEventargs(e);

                foreach (ACtrlButton btn in this.buttons)
                {
                    btn.OnMouseUp(e2);
                }

            }
            this.isScrolling = false;
            base.OnMouseUp(e);
        }

        public override void OnMouseClick(MouseEventArgs e)
        {
            if (!this.Enabled)
            {
                setAllState(ButtonState.Disabled);
                return;
            }

            if (IsMouseContains(e.Location))
            {
                MouseEventArgs e2 = ToChildEventargs(e);

                foreach (ACtrlButton btn in this.buttons)
                {
                    btn.OnMouseClick(e2);
                }
            }

            base.OnMouseClick(e);
        }

        public override void OnMouseWheel(MouseEventArgs e)
        {
            if (!this.Enabled)
            {
                setAllState(ButtonState.Disabled);
                return;
            }
            if (this.IsScrollableMouseContains(e.Location))
            {
                if (e.Delta > 0)
                {
                    this.Value -= 1;
                }
                else if (e.Delta < 0)
                {
                    this.Value += 1;
                }
            }

            base.OnMouseWheel(e);
        }

        private bool IsScrollableMouseContains(Point mouseLocation)
        {
            return this.Visible && this.ScrollableRectangle.Contains(mouseLocation);
        }

        private void btnPrev_MouseClick(object sender, MouseEventArgs e)
        {
            this.Value -= 1;
        }

        private void btnNext_MouseClick(object sender, MouseEventArgs e)
        {
            this.Value += 1;
        }

        private void setAllState(ButtonState buttonState)
        {
            btnPrev.State = buttonState;
            btnNext.State = buttonState;
            btnThumb.State = buttonState;
            picBase.State = buttonState;
        }

        private IEnumerable<ACtrlButton> buttons
        {
            get
            {
                yield return btnPrev;
                yield return btnNext;
                yield return btnThumb;
            }
        }

        public override void Draw(Graphics g)
        {
            if (g == null || !this.Visible)
                return;
            if (picBase != null)
            {
                BitmapOrigin curBmp = picBase.CurrentBitmap;
                g.SetClip(this.Rectangle);
                for (int h = 0; h < Size.Height; h += curBmp.Bitmap.Size.Height)
                {
                    g.DrawImage(curBmp.Bitmap, Location.X, Location.Y + h);
                }
                g.ResetClip();
            }
            if (btnPrev != null)
            {
                btnPrev.Draw(g, this.Location);
            }
            if (btnNext != null)
            {
                btnNext.Draw(g, this.Location);
            }
            if (btnThumb != null)
            {
                btnThumb.Location = new Point(0, calcThumbLocationY());
                btnThumb.Draw(g, this.Location);
            }
        }

        private int calcThumbLocationY()
        {
            if (this.minimum == this.maximum)
                return 0;
            int totalHeight = this.Size.Height - this.btnPrev.Size.Height - this.btnNext.Size.Height - this.btnThumb.Size.Height;
            int thumbY = totalHeight * this.value / (this.maximum - this.minimum);
            return thumbY + this.btnPrev.Size.Height;
        }

        private void childBtn_ButtonStateChanged(object sender, EventArgs e)
        {
            this.OnChildButtonStateChanged();
        }

        private void scrolling(Point mouseLocation)
        {
            if (this.minimum == this.maximum)
                return;
            Point origin = new Point(this.Location.X, this.Location.Y + this.btnPrev.Size.Height + this.btnThumb.Size.Height / 2);
            Size size = new Size(this.Size.Width, this.Size.Height - this.btnPrev.Size.Height - this.btnNext.Size.Height - this.btnThumb.Size.Height);
            Rectangle scrollingRect = new Rectangle(origin, size);
            this.Value = (int)Math.Round(1.0 * (this.maximum - this.minimum) * (mouseLocation.Y - scrollingRect.Y) / scrollingRect.Height);
        }

        protected virtual void OnValueChanged()
        {
            if (this.ValueChanged != null)
            {
                this.ValueChanged(this, EventArgs.Empty);
            }
        }

        protected virtual void OnChildButtonStateChanged()
        {
            if (this.ChildButtonStateChanged != null)
            {
                this.ChildButtonStateChanged(this, EventArgs.Empty);
            }
        }

        public event EventHandler ValueChanged;
        public event EventHandler ChildButtonStateChanged;
    }
}

```

`MapleNecrocer/CharaSimControl/AfrmEquip.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Windows.Forms;
using System.Drawing;
using System.Text;
using CharaSimResource;
using WzComparerR2.CharaSim;
using WzComparerR2.Common;
using WzComparerR2.Controls;

namespace WzComparerR2.CharaSimControl
{
    public class AfrmEquip : AlphaForm
    {
        public AfrmEquip()
        {
            sec = new int[5];
            for (int i = 0; i < sec.Length; i++)
                sec[i] = 1 << i;

            initCtrl();
            this.AllowDrop = true;
            this.TotemVisible = false;
        }

        private BitVector32 partVisible;
        private int[] sec;

        private Point baseOffset;
        private Point newLocation;
        private bool waitForRefresh;
        private Character character;

        private ACtrlButton btnPet;
        private ACtrlButton btnDragon;
        private ACtrlButton btnMechanic;
        private ACtrlButton btnAndroid;
        private ACtrlButton btnClose;

        public Character Character
        {
            get { return character; }
            set { character = value; }
        }

        public bool PetVisible
        {
            get { return partVisible[sec[0]]; }
            private set { partVisible[sec[0]] = value; }
        }

        public bool DragonVisible
        {
            get { return partVisible[sec[1]]; }
            private set
            {
                partVisible[sec[1]] = value;
                if (value)
                {
                    partVisible[sec[2]] = false;
                    partVisible[sec[3]] = false;
                }
            }
        }

        public bool MechanicVisible
        {
            get { return partVisible[sec[2]]; }
            private set
            {
                partVisible[sec[2]] = value;
                if (value)
                {
                    partVisible[sec[1]] = false;
                    partVisible[sec[3]] = false;
                }
            }
        }

        public bool AndroidVisible
        {
            get { return partVisible[sec[3]]; }
            private set
            {
                partVisible[sec[3]] = value;
                if (value)
                {
                    partVisible[sec[1]] = false;
                    partVisible[sec[2]] = false;
                }
            }
        }

        public bool TotemVisible
        {
            get { return partVisible[sec[4]]; }
            private set { partVisible[sec[4]] = value; }
        }

        private Rectangle DragonRect
        {
            get
            {
                return new Rectangle(
                    new Point(baseOffset.X - Resource.Equip_dragon_backgrnd.Width, baseOffset.Y),
                    Resource.Equip_dragon_backgrnd.Size);
            }
        }

        private Rectangle MechanicRect
        {
            get
            {
                return new Rectangle(
                    new Point(baseOffset.X - Resource.Equip_mechanic_backgrnd.Width, baseOffset.Y),
                    Resource.Equip_mechanic_backgrnd.Size);
            }
        }

        private Rectangle AndroidRect
        {
            get
            {
                return new Rectangle(
                    new Point(baseOffset.X - Resource.Equip_Android_backgrnd.Width, baseOffset.Y),
                    Resource.Equip_Android_backgrnd.Size);
            }
        }

        private Rectangle PetRect
        {
            get
            {
                return new Rectangle(
                    new Point(baseOffset.X + Resource.Equip_character_backgrnd.Width,
                        baseOffset.Y + Resource.Equip_character_backgrnd.Height - Resource.Equip_pet_backgrnd.Height),
                    Resource.Equip_pet_backgrnd.Size);
            }
        }

        private Rectangle TotemRect
        {
            get
            {
                return new Rectangle(
                    new Point(baseOffset.X - Resource.Equip_totem_backgrnd.Width,
                        baseOffset.Y + Resource.Equip_character_backgrnd.Height - Resource.Equip_totem_backgrnd.Height),
                    Resource.Equip_pet_backgrnd.Size);
            }
        }

        private void initCtrl()
        {
            this.btnPet = new ACtrlButton();
            this.btnPet.Normal = new BitmapOrigin(Resource.Equip_character_BtPet_normal_0);
            this.btnPet.Pressed = new BitmapOrigin(Resource.Equip_character_BtPet_pressed_0);
            this.btnPet.MouseOver = new BitmapOrigin(Resource.Equip_character_BtPet_mouseOver_0);
            this.btnPet.Disabled = new BitmapOrigin(Resource.Equip_character_BtPet_disabled_0);
            this.btnPet.Location = new Point(142, 266);
            this.btnPet.Size = new Size(32, 12);
            this.btnPet.ButtonStateChanged += new EventHandler(aCtrl_RefreshCall);
            this.btnPet.MouseClick += new System.Windows.Forms.MouseEventHandler(btnPet_MouseClick);

            this.btnDragon = new ACtrlButton();
            this.btnDragon.Normal = new BitmapOrigin(Resource.Equip_character_BtDragon_normal_0);
            this.btnDragon.Pressed = new BitmapOrigin(Resource.Equip_character_BtDragon_pressed_0);
            this.btnDragon.MouseOver = new BitmapOrigin(Resource.Equip_character_BtDragon_mouseOver_0);
            this.btnDragon.Disabled = new BitmapOrigin(Resource.Equip_character_BtDragon_disabled_0);
            this.btnDragon.Location = new Point(10, 266);
            this.btnDragon.Size = new Size(43, 12);
            this.btnDragon.ButtonStateChanged += new EventHandler(aCtrl_RefreshCall);
            this.btnDragon.MouseClick += new MouseEventHandler(btnDragon_MouseClick);

            this.btnMechanic = new ACtrlButton();
            this.btnMechanic.Normal = new BitmapOrigin(Resource.Equip_character_BtMechanic_normal_0);
            this.btnMechanic.Pressed = new BitmapOrigin(Resource.Equip_character_BtMechanic_pressed_0);
            this.btnMechanic.MouseOver = new BitmapOrigin(Resource.Equip_character_BtMechanic_mouseOver_0);
            this.btnMechanic.Disabled = new BitmapOrigin(Resource.Equip_character_BtMechanic_disabled_0);
            this.btnMechanic.Location = new Point(10, 266);
            this.btnMechanic.Size = new Size(43, 12);
            this.btnMechanic.ButtonStateChanged += new EventHandler(aCtrl_RefreshCall);
            this.btnMechanic.MouseClick += new MouseEventHandler(btnMechanic_MouseClick);

            this.btnAndroid = new ACtrlButton();
            this.btnAndroid.Normal = new BitmapOrigin(Resource.Equip_character_BtAndroid_normal_0);
            this.btnAndroid.Pressed = new BitmapOrigin(Resource.Equip_character_BtAndroid_pressed_0);
            this.btnAndroid.MouseOver = new BitmapOrigin(Resource.Equip_character_BtAndroid_mouseOver_0);
            this.btnAndroid.Disabled = new BitmapOrigin(Resource.Equip_character_BtAndroid_disabled_0);
            this.btnAndroid.Location = new Point(65, 266);
            this.btnAndroid.Size = new Size(25, 12);
            this.btnAndroid.ButtonStateChanged += new EventHandler(aCtrl_RefreshCall);
            this.btnAndroid.MouseClick += new MouseEventHandler(btnAndroid_MouseClick);

            this.btnClose = new ACtrlButton();
            this.btnClose.Normal = new BitmapOrigin(Resource.BtClose3_normal_0);
            this.btnClose.Pressed = new BitmapOrigin(Resource.BtClose3_pressed_0);
            this.btnClose.MouseOver = new BitmapOrigin(Resource.BtClose3_mouseOver_0);
            this.btnClose.Disabled = new BitmapOrigin(Resource.BtClose3_disabled_0);
            this.btnClose.Location = new Point(162, 6);
            this.btnClose.Size = new Size(13, 13);
            this.btnClose.ButtonStateChanged += new EventHandler(aCtrl_RefreshCall);
            this.btnClose.MouseClick += new MouseEventHandler(btnClose_MouseClick);
        }

        public override void Refresh()
        {
            this.preRender();
            this.SetBitmap(this.Bitmap);
            this.CaptionRectangle = new Rectangle(this.baseOffset, new Size(Resource.Equip_character_backgrnd.Width, 24));
            this.Location = newLocation;
            base.Refresh();
        }

        protected override bool captionHitTest(Point point)
        {
            Rectangle rect = this.btnClose.Rectangle;
            rect.Offset(this.baseOffset);
            if (rect.Contains(point))
                return false;
            return base.captionHitTest(point);
        }

        private void preRender()
        {
            if (Bitmap != null)
                Bitmap.Dispose();

            //处理按钮可见
            setControlState();

            //计算图像大小
            Point baseOffsetnew = calcRenderBaseOffset();
            Size size = Resource.Equip_character_backgrnd.Size;
            size.Width += baseOffsetnew.X;
            if (this.PetVisible)
                size.Width += Resource.Equip_pet_backgrnd.Width;

            //处理偏移
            this.newLocation = new Point(this.Location.X + this.baseOffset.X - baseOffsetnew.X,
                this.Location.Y + this.baseOffset.Y - baseOffsetnew.Y);
            this.baseOffset = baseOffsetnew;

            //绘制图像
            Bitmap bitmap = new Bitmap(size.Width, size.Height);
            Graphics g = Graphics.FromImage(bitmap);

            renderBase(g);
            if (this.DragonVisible) renderDragon(g);
            else if (this.MechanicVisible) renderMechanic(g);
            else if (this.AndroidVisible) renderAndroid(g);
            if (this.PetVisible) renderPet(g);
            if (this.TotemVisible) renderTotem(g);

            g.Dispose();
            this.Bitmap = bitmap;
        }

        private Point calcRenderBaseOffset()
        {
            if (this.DragonVisible)
                return new Point(Resource.Equip_dragon_backgrnd.Width, 0);
            else if (this.MechanicVisible)
                return new Point(Resource.Equip_mechanic_backgrnd.Width, 0);
            else if (this.AndroidVisible)
                return new Point(Resource.Equip_Android_backgrnd.Width, 0);
            else
                return new Point(Resource.Equip_totem_backgrnd.Width, 0);
        }

        private void setControlState()
        {
            if (this.character == null)
            {
                this.btnDragon.Visible = false;
                this.btnMechanic.Visible = false;
                this.DragonVisible = false;
                this.MechanicVisible = false;
            }
            else
            {
                if (this.character.Status.Job / 100 == 22) //龙神
                {
                    this.btnDragon.Visible = true;
                }
                else
                {
                    this.btnDragon.Visible = false;
                    this.DragonVisible = false;
                }

                if (this.character.Status.Job / 100 == 35) //机械
                {
                    this.btnMechanic.Visible = true;
                }
                else
                {
                    this.btnMechanic.Visible = false;
                    this.MechanicVisible = false;
                }
            }
        }

        private void renderBase(Graphics g)
        {
            g.TranslateTransform(baseOffset.X, baseOffset.Y);
            g.DrawImage(Resource.Equip_character_backgrnd, 0, 0);
            g.DrawImage(Resource.Equip_character_backgrnd2, 6, 22);
            g.DrawImage(Resource.Equip_character_backgrnd3, 10, 27);
            g.DrawImage(Resource.Equip_character_cashPendant, 76, 93);
            g.DrawImage(Resource.Equip_character_charmPocket, 10, 93);
            if (this.character != null
                && (this.character.Status.Job / 100 == 23 || this.character.Status.Job == 2002))
            {
                g.DrawImage(Resource.Equip_character_magicArrow, 142, 126);
            }

            foreach (AControl aCtrl in this.aControls)
            {
                aCtrl.Draw(g);
            }

            if (this.character != null)
            {
                for (int i = 0; i < 30; i++)
                {
                    Gear gear = this.character.Equip.GearSlots[i];
                    if (gear != null)
                    {
                        int dx = 10 + i % 5 * 33, dy = 27 + i / 5 * 33;
                        drawGearIcon(gear, g, dx, dy);
                    }
                }
            }
            g.ResetTransform();
        }

        private void renderDragon(Graphics g)
        {
            Rectangle rect = this.DragonRect;
            g.TranslateTransform(rect.X, rect.Y);
            g.DrawImage(Resource.Equip_dragon_backgrnd, 0, 0);
            g.DrawImage(Resource.Equip_dragon_backgrnd2, 6, 22);
            g.DrawImage(Resource.Equip_dragon_backgrnd3, 10, 29);

            if (this.character != null)
            {
                for (int i = 35; i < 39; i++)
                {
                    Gear gear = this.character.Equip.GearSlots[i];
                    if (gear != null)
                    {
                        int dx = 10 + (i - 35) * 33, dy = 22 + (((i - 1) % 2) + 1) * 33;
                        drawGearIcon(gear, g, dx, dy);
                    }
                }
            }
            g.ResetTransform();
        }

        private void renderMechanic(Graphics g)
        {
            Rectangle rect = this.MechanicRect;
            g.TranslateTransform(rect.X, rect.Y);
            g.DrawImage(Resource.Equip_mechanic_backgrnd, 0, 0);
            g.DrawImage(Resource.Equip_mechanic_backgrnd2, 6, 22);
            g.DrawImage(Resource.Equip_mechanic_backgrnd3, 12, 35);

            if (this.character != null)
            {
                int dx, dy;
                for (int i = 39; i < 44; i++)
                {
                    Gear gear = this.character.Equip.GearSlots[i];
                    if (gear != null)
                    {
                        switch (i)
                        {
                            case 39: dx = 1; dy = 1; break;
                            case 40: dx = 1; dy = 2; break;
                            case 41: dx = 2; dy = 2; break;
                            case 42: dx = 0; dy = 3; break;
                            case 43: dx = 1; dy = 3; break;
                            default: continue;
                        }
                        dx = 10 + dx * 33;
                        dy = 22 + dy * 33;
                        drawGearIcon(gear, g, dx, dy);
                    }
                }
            }
            g.ResetTransform();
        }

        private void renderPet(Graphics g)
        {
            Rectangle rect = this.PetRect;
            g.TranslateTransform(rect.X, rect.Y);
            g.DrawImage(Resource.Equip_pet_backgrnd, 0, 0);
            g.DrawImage(Resource.Equip_pet_backgrnd2, 6, 21);
            g.DrawImage(Resource.Equip_pet_backgrnd3, 11, 27);
            g.ResetTransform();
        }

        private void renderAndroid(Graphics g)
        {
            Rectangle rect = this.AndroidRect;
            g.TranslateTransform(rect.X, rect.Y);
            g.DrawImage(Resource.Equip_Android_backgrnd, 0, 0);
            g.DrawImage(Resource.Equip_Android_backgrnd2, 6, 24);
            g.DrawImage(Resource.Equip_Android_backgrnd3, 12, 28);
            g.ResetTransform();
        }

        private void renderTotem(Graphics g)
        {
            Rectangle rect = this.TotemRect;
            g.TranslateTransform(rect.X, rect.Y);
            g.DrawImage(Resource.Equip_totem_backgrnd, 0, 0);
            g.ResetTransform();
        }

        private void drawGearIcon(Gear gear, Graphics g, int x, int y)
        {
            if (gear == null || g == null)
                return;
            if (gear.State == GearState.disable)
                g.DrawImage(Resource.Equip_character_disabled, x, y);
            Pen pen = GearGraphics.GetGearItemBorderPen(gear.Grade);
            if (pen != null)
            {
                Point[] path = GearGraphics.GetIconBorderPath(x, y);
                g.DrawLines(pen, path);
            }
            g.DrawImage(gear.Icon.Bitmap,
                x - gear.Icon.Origin.X,
                y + 32 - gear.Icon.Origin.Y);
        }

        private IEnumerable<AControl> aControls
        {
            get
            {
                yield return btnDragon;
                yield return btnMechanic;
                yield return btnPet;
                yield return btnClose;
                yield return btnAndroid;
            }
        }

        private void aCtrl_RefreshCall(object sender, EventArgs e)
        {
            this.waitForRefresh = true;
        }

        private void btnPet_MouseClick(object sender, MouseEventArgs e)
        {
            this.PetVisible = !this.PetVisible;
            this.waitForRefresh = true;
        }

        private void btnDragon_MouseClick(object sender, MouseEventArgs e)
        {
            this.DragonVisible = !this.DragonVisible;
            this.waitForRefresh = true;
        }

        private void btnMechanic_MouseClick(object sender, MouseEventArgs e)
        {
            this.MechanicVisible = !this.MechanicVisible;
            this.waitForRefresh = true;
        }

        private void btnAndroid_MouseClick(object sender, MouseEventArgs e)
        {
            this.AndroidVisible = !this.AndroidVisible;
            this.waitForRefresh = true;
        }

        private void btnClose_MouseClick(object sender, MouseEventArgs e)
        {
            this.Visible = false;
        }

        protected override void OnMouseMove(MouseEventArgs e)
        {
            MouseEventArgs childArgs = new MouseEventArgs(e.Button, e.Clicks, e.X - baseOffset.X, e.Y - baseOffset.Y, e.Delta);

            foreach (AControl ctrl in this.aControls)
            {
                ctrl.OnMouseMove(childArgs);
            }

            if (this.waitForRefresh)
            {
                this.Refresh();
                waitForRefresh = false;
            }

            base.OnMouseMove(e);
        }

        protected override void OnMouseDown(MouseEventArgs e)
        {
            MouseEventArgs childArgs = new MouseEventArgs(e.Button, e.Clicks, e.X - baseOffset.X, e.Y - baseOffset.Y, e.Delta);

            foreach (AControl ctrl in this.aControls)
            {
                ctrl.OnMouseDown(childArgs);
            }

            if (this.waitForRefresh)
            {
                this.Refresh();
                waitForRefresh = false;
            }

            base.OnMouseDown(e);
        }

        protected override void OnMouseUp(MouseEventArgs e)
        {
            MouseEventArgs childArgs = new MouseEventArgs(e.Button, e.Clicks, e.X - baseOffset.X, e.Y - baseOffset.Y, e.Delta);

            foreach (AControl ctrl in this.aControls)
            {
                ctrl.OnMouseUp(childArgs);
            }

            if (this.waitForRefresh)
            {
                this.Refresh();
                waitForRefresh = false;
            }

            base.OnMouseUp(e);
        }

        private void InitializeComponent()
        {
            SuspendLayout();
            // 
            // AfrmEquip
            // 
            AutoScaleMode = AutoScaleMode.None;
            ClientSize = new Size(300, 300);
            Font = new Font("Microsoft JhengHei UI", 9F, FontStyle.Regular, GraphicsUnit.Pixel);
            Location = new Point(0, 0);
            Name = "AfrmEquip";
            ResumeLayout(false);
        }

        protected override void OnMouseClick(MouseEventArgs e)
        {
            MouseEventArgs childArgs = new MouseEventArgs(e.Button, e.Clicks, e.X - baseOffset.X, e.Y - baseOffset.Y, e.Delta);

            foreach (AControl ctrl in this.aControls)
            {
                ctrl.OnMouseClick(childArgs);
            }

            if (this.waitForRefresh)
            {
                this.Refresh();
                waitForRefresh = false;
            }

            base.OnMouseClick(e);
        }
    }
}

```

`MapleNecrocer/CharaSimControl/AfrmEquip.resx`:

```resx
<root>
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`MapleNecrocer/CharaSimControl/AfrmItem.cs`:

```cs
using System;
using System.Drawing;
using System.Collections.Generic;
using System.Windows.Forms;
using System.Text;
using CharaSimResource;
using WzComparerR2.CharaSim;
using WzComparerR2.Common;
using WzComparerR2.Controls;

namespace WzComparerR2.CharaSimControl
{
    public class AfrmItem : AlphaForm
    {
        public AfrmItem()
        {
            this.AllowDrop = true;
            initCtrl();
        }

        private ItemTab[] itemTabs;
        private bool fullMode;
        private bool selectedIndexChanging;
        private ACtrlVScroll vScroll;
        private Character character;

        private ACtrlButton btnFull;
        private ACtrlButton btnSmall;
        private ACtrlButton btnCoin3;
        private ACtrlButton btnCoin4;
        private ACtrlButton btnPoint;
        private ACtrlButton btnGather;
        private ACtrlButton btnSort;
        private ACtrlButton btnDisassemble3;
        private ACtrlButton btnDisassemble4;
        private ACtrlButton btnExtract3;
        private ACtrlButton btnExtract4;
        private ACtrlButton btnAppraise3;
        private ACtrlButton btnAppraise4;
        private ACtrlButton btnBits3;
        private ACtrlButton btnBits4;
        private ACtrlButton btnPot3;
        private ACtrlButton btnPot4;
        private ACtrlButton btnUpgrade3;
        private ACtrlButton btnUpgrade4;
        private ACtrlButton btnToad3;
        private ACtrlButton btnToad4;
        private ACtrlButton btnCashshop;
        private ACtrlButton btnClose;
        private bool waitForRefresh;

        public event ItemMouseEventHandler ItemMouseDown;
        public event ItemMouseEventHandler ItemMouseUp;
        public event ItemMouseEventHandler ItemMouseClick;
        public event ItemMouseEventHandler ItemMouseMove;
        public event EventHandler ItemMouseLeave;

        public Character Character
        {
            get { return character; }
            set
            {
                character = value;

                for (int i = 0; i < this.itemTabs.Length; i++)
                {
                    if (this.character == null || !this.itemTabs[i].SetItemSource(character.ItemSlots[i]))
                    {
                        this.itemTabs[i].ClearItems();
                    }
                }
            }
        }

        private void initCtrl()
        {
            this.itemTabs = new ItemTab[5];
            for (int i = 0; i < itemTabs.Length; i++)
            {
                this.itemTabs[i] = new ItemTab(this);
                this.itemTabs[i].TabEnabled = new BitmapOrigin((Bitmap)Resource.ResourceManager.GetObject("Item_Tab_enabled_" + i),
                   -9 - 31 * i, -28);
                this.itemTabs[i].TabDisabled = new BitmapOrigin((Bitmap)Resource.ResourceManager.GetObject("Item_Tab_disabled_" + i),
                    -9 - 31 * i, -28);
            }
            this.itemTabs[0].Selected = true;

            this.vScroll = new ACtrlVScroll();

            this.vScroll.PicBase.Normal = new BitmapOrigin(Resource.VScr9_enabled_base);
            this.vScroll.PicBase.Disabled = new BitmapOrigin(Resource.VScr9_disabled_base);

            this.vScroll.BtnPrev.Normal = new BitmapOrigin(Resource.VScr9_enabled_prev0);
            this.vScroll.BtnPrev.Pressed = new BitmapOrigin(Resource.VScr9_enabled_prev1);
            this.vScroll.BtnPrev.MouseOver = new BitmapOrigin(Resource.VScr9_enabled_prev2);
            this.vScroll.BtnPrev.Disabled = new BitmapOrigin(Resource.VScr9_disabled_prev);
            this.vScroll.BtnPrev.Size = this.vScroll.BtnPrev.Normal.Bitmap.Size;
            this.vScroll.BtnPrev.Location = new Point(0, 0);

            this.vScroll.BtnNext.Normal = new BitmapOrigin(Resource.VScr9_enabled_next0);
            this.vScroll.BtnNext.Pressed = new BitmapOrigin(Resource.VScr9_enabled_next1);
            this.vScroll.BtnNext.MouseOver = new BitmapOrigin(Resource.VScr9_enabled_next2);
            this.vScroll.BtnNext.Disabled = new BitmapOrigin(Resource.VScr9_disabled_next);
            this.vScroll.BtnNext.Size = this.vScroll.BtnNext.Normal.Bitmap.Size;
            this.vScroll.BtnNext.Location = new Point(0, 195);

            this.vScroll.BtnThumb.Normal = new BitmapOrigin(Resource.VScr9_enabled_thumb0);
            this.vScroll.BtnThumb.Pressed = new BitmapOrigin(Resource.VScr9_enabled_thumb1);
            this.vScroll.BtnThumb.MouseOver = new BitmapOrigin(Resource.VScr9_enabled_thumb0);
            this.vScroll.BtnThumb.Size = this.vScroll.BtnThumb.Normal.Bitmap.Size;

            this.vScroll.Location = new Point(152, 51);
            this.vScroll.Size = new Size(11, 207);
            this.vScroll.ScrollableLocation = new Point(10, 51);
            this.vScroll.ScrollableSize = new Size(153, 207);
            this.vScroll.ValueChanged += new EventHandler(vScroll_ValueChanged);
            this.vScroll.ChildButtonStateChanged += new EventHandler(aCtrl_RefreshCall);

            this.btnFull = new ACtrlButton();
            this.btnFull.Normal = new BitmapOrigin(Resource.Item_BtFull_normal_0);
            this.btnFull.Pressed = new BitmapOrigin(Resource.Item_BtFull_pressed_0);
            this.btnFull.MouseOver = new BitmapOrigin(Resource.Item_BtFull_mouseOver_0);
            this.btnFull.Disabled = new BitmapOrigin(Resource.Item_BtFull_disabled_0);
            this.btnFull.Location = new Point(147, 267);
            this.btnFull.Size = new Size(16, 16);
            this.btnFull.MouseClick += new MouseEventHandler(btnFull_MouseClick);
            this.btnFull.ButtonStateChanged += new EventHandler(aCtrl_RefreshCall);

            this.btnSmall = new ACtrlButton();
            this.btnSmall.Normal = new BitmapOrigin(Resource.Item_BtSmall_normal_0);
            this.btnSmall.Pressed = new BitmapOrigin(Resource.Item_BtSmall_pressed_0);
            this.btnSmall.MouseOver = new BitmapOrigin(Resource.Item_BtSmall_mouseOver_0);
            this.btnSmall.Disabled = new BitmapOrigin(Resource.Item_BtSmall_disabled_0);
            this.btnSmall.Location = new Point(153, 337);
            this.btnSmall.Size = new Size(16, 16);
            this.btnSmall.MouseClick += new MouseEventHandler(btnSmall_MouseClick);
            this.btnSmall.ButtonStateChanged += new EventHandler(aCtrl_RefreshCall);

            this.btnCoin3 = new ACtrlButton();
            this.btnCoin3.Normal = new BitmapOrigin(Resource.Item_BtCoin3_normal_0);
            this.btnCoin3.Pressed = new BitmapOrigin(Resource.Item_BtCoin3_pressed_0);
            this.btnCoin3.MouseOver = new BitmapOrigin(Resource.Item_BtCoin3_mouseOver_0);
            this.btnCoin3.Disabled = new BitmapOrigin(Resource.Item_BtCoin3_disabled_0);
            this.btnCoin3.Location = new Point(9, 267);
            this.btnCoin3.Size = new Size(38, 16);
            this.btnCoin3.ButtonStateChanged += new EventHandler(aCtrl_RefreshCall);

            this.btnCoin4 = new ACtrlButton();
            this.btnCoin4.Normal = new BitmapOrigin(Resource.Item_BtCoin4_normal_0);
            this.btnCoin4.Pressed = new BitmapOrigin(Resource.Item_BtCoin4_pressed_0);
            this.btnCoin4.MouseOver = new BitmapOrigin(Resource.Item_BtCoin4_mouseOver_0);
            this.btnCoin4.Disabled = new BitmapOrigin(Resource.Item_BtCoin4_disabled_0);
            this.btnCoin4.Location = new Point(9, 337);
            this.btnCoin4.Size = new Size(40, 16);
            this.btnCoin4.ButtonStateChanged += new EventHandler(aCtrl_RefreshCall);

            this.btnPoint = new ACtrlButton();
            this.btnPoint.Normal = new BitmapOrigin(Resource.Item_BtPoint_normal_0);
            this.btnPoint.Pressed = new BitmapOrigin(Resource.Item_BtPoint_pressed_0);
            this.btnPoint.MouseOver = new BitmapOrigin(Resource.Item_BtPoint_mouseOver_0);
            this.btnPoint.Disabled = new BitmapOrigin(Resource.Item_BtPoint_disabled_0);
            this.btnPoint.Location = new Point(9, 285);
            this.btnPoint.Size = new Size(82, 16);
            this.btnPoint.ButtonStateChanged += new EventHandler(aCtrl_RefreshCall);

            this.btnGather = new ACtrlButton();
            this.btnGather.Normal = new BitmapOrigin(Resource.Item_BtGather_normal_0);
            this.btnGather.Pressed = new BitmapOrigin(Resource.Item_BtGather_pressed_0);
            this.btnGather.MouseOver = new BitmapOrigin(Resource.Item_BtGather_mouseOver_0);
            this.btnGather.Disabled = new BitmapOrigin(Resource.Item_BtGather_disabled_0);
            this.btnGather.Location = new Point(130, 267);
            this.btnGather.Size = new Size(16, 16);
            this.btnGather.ButtonStateChanged += new EventHandler(aCtrl_RefreshCall);
            this.btnGather.MouseClick += new MouseEventHandler(btnGather_MouseClick);

            this.btnSort = new ACtrlButton();
            this.btnSort.Normal = new BitmapOrigin(Resource.Item_BtSort_normal_0);
            this.btnSort.Pressed = new BitmapOrigin(Resource.Item_BtSort_pressed_0);
            this.btnSort.MouseOver = new BitmapOrigin(Resource.Item_BtSort_mouseOver_0);
            this.btnSort.Disabled = new BitmapOrigin(Resource.Item_BtSort_disabled_0);
            this.btnSort.Location = new Point(130, 267);
            this.btnSort.Size = new Size(16, 16);
            this.btnSort.ButtonStateChanged += new EventHandler(aCtrl_RefreshCall);
            this.btnSort.MouseClick += new MouseEventHandler(btnSort_MouseClick);

            this.btnDisassemble3 = new ACtrlButton();
            this.btnDisassemble3.Normal = new BitmapOrigin(Resource.Item_BtDisassemble3_normal_0);
            this.btnDisassemble3.Pressed = new BitmapOrigin(Resource.Item_BtDisassemble3_pressed_0);
            this.btnDisassemble3.MouseOver = new BitmapOrigin(Resource.Item_BtDisassemble3_mouseOver_0);
            this.btnDisassemble3.Disabled = new BitmapOrigin(Resource.Item_BtDisassemble3_disabled_0);
            this.btnDisassemble3.Location = new Point(9, 303);
            this.btnDisassemble3.Size = new Size(24, 24);
            this.btnDisassemble3.ButtonStateChanged += new EventHandler(aCtrl_RefreshCall);

            this.btnDisassemble4 = new ACtrlButton();
            this.btnDisassemble4.Normal = new BitmapOrigin(Resource.Item_BtDisassemble4_normal_0);
            this.btnDisassemble4.Pressed = new BitmapOrigin(Resource.Item_BtDisassemble4_pressed_0);
            this.btnDisassemble4.MouseOver = new BitmapOrigin(Resource.Item_BtDisassemble4_mouseOver_0);
            this.btnDisassemble4.Disabled = new BitmapOrigin(Resource.Item_BtDisassemble4_disabled_0);
            this.btnDisassemble4.Location = new Point(412, 337);
            this.btnDisassemble4.Size = new Size(16, 16);
            this.btnDisassemble4.ButtonStateChanged += new EventHandler(aCtrl_RefreshCall);

            this.btnExtract3 = new ACtrlButton();
            this.btnExtract3.Normal = new BitmapOrigin(Resource.Item_BtExtract3_normal_0);
            this.btnExtract3.Pressed = new BitmapOrigin(Resource.Item_BtExtract3_pressed_0);
            this.btnExtract3.MouseOver = new BitmapOrigin(Resource.Item_BtExtract3_mouseOver_0);
            this.btnExtract3.Disabled = new BitmapOrigin(Resource.Item_BtExtract3_disabled_0);
            this.btnExtract3.Location = new Point(35, 303);
            this.btnExtract3.Size = new Size(24, 24);
            this.btnExtract3.ButtonStateChanged += new EventHandler(aCtrl_RefreshCall);

            this.btnExtract4 = new ACtrlButton();
            this.btnExtract4.Normal = new BitmapOrigin(Resource.Item_BtExtract4_normal_0);
            this.btnExtract4.Pressed = new BitmapOrigin(Resource.Item_BtExtract4_pressed_0);
            this.btnExtract4.MouseOver = new BitmapOrigin(Resource.Item_BtExtract4_mouseOver_0);
            this.btnExtract4.Disabled = new BitmapOrigin(Resource.Item_BtExtract4_disabled_0);
            this.btnExtract4.Location = new Point(430, 337);
            this.btnExtract4.Size = new Size(16, 16);
            this.btnExtract4.ButtonStateChanged += new EventHandler(aCtrl_RefreshCall);

            this.btnAppraise3 = new ACtrlButton();
            this.btnAppraise3.Normal = new BitmapOrigin(Resource.Item_BtAppraise3_normal_0);
            this.btnAppraise3.Pressed = new BitmapOrigin(Resource.Item_BtAppraise3_pressed_0);
            this.btnAppraise3.MouseOver = new BitmapOrigin(Resource.Item_BtAppraise3_mouseOver_0);
            this.btnAppraise3.Disabled = new BitmapOrigin(Resource.Item_BtAppraise3_disabled_0);
            this.btnAppraise3.Location = new Point(61, 303);
            this.btnAppraise3.Size = new Size(24, 24);
            this.btnAppraise3.ButtonStateChanged += new EventHandler(aCtrl_RefreshCall);

            this.btnAppraise4 = new ACtrlButton();
            this.btnAppraise4.Normal = new BitmapOrigin(Resource.Item_BtAppraise4_normal_0);
            this.btnAppraise4.Pressed = new BitmapOrigin(Resource.Item_BtAppraise4_pressed_0);
            this.btnAppraise4.MouseOver = new BitmapOrigin(Resource.Item_BtAppraise4_mouseOver_0);
            this.btnAppraise4.Disabled = new BitmapOrigin(Resource.Item_BtAppraise4_disabled_0);
            this.btnAppraise4.Location = new Point(448, 337);
            this.btnAppraise4.Size = new Size(16, 16);
            this.btnAppraise4.ButtonStateChanged += new EventHandler(aCtrl_RefreshCall);

            this.btnBits3 = new ACtrlButton();
            this.btnBits3.Normal = new BitmapOrigin(Resource.Item_BtBits3_normal_0);
            this.btnBits3.Pressed = new BitmapOrigin(Resource.Item_BtBits3_pressed_0);
            this.btnBits3.MouseOver = new BitmapOrigin(Resource.Item_BtBits3_mouseOver_0);
            this.btnBits3.Disabled = new BitmapOrigin(Resource.Item_BtBits3_disabled_0);
            this.btnBits3.Location = new Point(113, 303);
            this.btnBits3.Size = new Size(24, 24);
            this.btnBits3.ButtonStateChanged += new EventHandler(aCtrl_RefreshCall);

            this.btnBits4 = new ACtrlButton();
            this.btnBits4.Normal = new BitmapOrigin(Resource.Item_BtBits4_normal_0);
            this.btnBits4.Pressed = new BitmapOrigin(Resource.Item_BtBits4_pressed_0);
            this.btnBits4.MouseOver = new BitmapOrigin(Resource.Item_BtBits4_mouseOver_0);
            this.btnBits4.Disabled = new BitmapOrigin(Resource.Item_BtBits4_disabled_0);
            this.btnBits4.Location = new Point(484, 337);
            this.btnBits4.Size = new Size(16, 16);
            this.btnBits4.ButtonStateChanged += new EventHandler(aCtrl_RefreshCall);

            this.btnPot3 = new ACtrlButton();
            this.btnPot3.Normal = new BitmapOrigin(Resource.Item_BtPot3_normal_0);
            this.btnPot3.Pressed = new BitmapOrigin(Resource.Item_BtPot3_pressed_0);
            this.btnPot3.MouseOver = new BitmapOrigin(Resource.Item_BtPot3_mouseOver_0);
            this.btnPot3.Disabled = new BitmapOrigin(Resource.Item_BtPot3_disabled_0);
            this.btnPot3.Location = new Point(87, 303);
            this.btnPot3.Size = new Size(24, 24);
            this.btnPot3.ButtonStateChanged += new EventHandler(aCtrl_RefreshCall);

            this.btnPot4 = new ACtrlButton();
            this.btnPot4.Normal = new BitmapOrigin(Resource.Item_BtPot4_normal_0);
            this.btnPot4.Pressed = new BitmapOrigin(Resource.Item_BtPot4_pressed_0);
            this.btnPot4.MouseOver = new BitmapOrigin(Resource.Item_BtPot4_mouseOver_0);
            this.btnPot4.Disabled = new BitmapOrigin(Resource.Item_BtPot4_disabled_0);
            this.btnPot4.Location = new Point(466, 337);
            this.btnPot4.Size = new Size(16, 16);
            this.btnPot4.ButtonStateChanged += new EventHandler(aCtrl_RefreshCall);

            this.btnUpgrade3 = new ACtrlButton();
            this.btnUpgrade3.Normal = new BitmapOrigin(Resource.Item_BtUpgrade3_normal_0);
            this.btnUpgrade3.Pressed = new BitmapOrigin(Resource.Item_BtUpgrade3_pressed_0);
            this.btnUpgrade3.MouseOver = new BitmapOrigin(Resource.Item_BtUpgrade3_mouseOver_0);
            this.btnUpgrade3.Disabled = new BitmapOrigin(Resource.Item_BtUpgrade3_disabled_0);
            this.btnUpgrade3.Location = new Point(139, 303);
            this.btnUpgrade3.Size = new Size(24, 24);
            this.btnUpgrade3.ButtonStateChanged += new EventHandler(aCtrl_RefreshCall);

            this.btnUpgrade4 = new ACtrlButton();
            this.btnUpgrade4.Normal = new BitmapOrigin(Resource.Item_BtUpgrade4_normal_0);
            this.btnUpgrade4.Pressed = new BitmapOrigin(Resource.Item_BtUpgrade4_pressed_0);
            this.btnUpgrade4.MouseOver = new BitmapOrigin(Resource.Item_BtUpgrade4_mouseOver_0);
            this.btnUpgrade4.Disabled = new BitmapOrigin(Resource.Item_BtUpgrade4_disabled_0);
            this.btnUpgrade4.Location = new Point(392, 337);
            this.btnUpgrade4.Size = new Size(16, 16);
            this.btnUpgrade4.ButtonStateChanged += new EventHandler(aCtrl_RefreshCall);

            this.btnToad3 = new ACtrlButton();
            this.btnToad3.Normal = new BitmapOrigin(Resource.Item_BtToad3_normal_0);
            this.btnToad3.Pressed = new BitmapOrigin(Resource.Item_BtToad3_pressed_0);
            this.btnToad3.MouseOver = new BitmapOrigin(Resource.Item_BtToad3_mouseOver_0);
            this.btnToad3.Disabled = new BitmapOrigin(Resource.Item_BtToad3_disabled_0);
            this.btnToad3.Location = new Point(113, 303);
            this.btnToad3.Size = new Size(24, 24);
            this.btnToad3.ButtonStateChanged += new EventHandler(aCtrl_RefreshCall);

            this.btnToad4 = new ACtrlButton();
            this.btnToad4.Normal = new BitmapOrigin(Resource.Item_BtToad4_normal_0);
            this.btnToad4.Pressed = new BitmapOrigin(Resource.Item_BtToad4_pressed_0);
            this.btnToad4.MouseOver = new BitmapOrigin(Resource.Item_BtToad4_mouseOver_0);
            this.btnToad4.Disabled = new BitmapOrigin(Resource.Item_BtToad4_disabled_0);
            this.btnToad4.Location = new Point(484, 337);
            this.btnToad4.Size = new Size(16, 16);
            this.btnToad4.ButtonStateChanged += new EventHandler(aCtrl_RefreshCall);

            this.btnCashshop = new ACtrlButton();
            this.btnCashshop.Normal = new BitmapOrigin(Resource.Item_BtCashshop_normal_0);
            this.btnCashshop.Pressed = new BitmapOrigin(Resource.Item_BtCashshop_pressed_0);
            this.btnCashshop.MouseOver = new BitmapOrigin(Resource.Item_BtCashshop_mouseOver_0);
            this.btnCashshop.Disabled = new BitmapOrigin(Resource.Item_BtCashshop_disabled_0);
            this.btnCashshop.Location = new Point(502, 337);
            this.btnCashshop.Size = new Size(82, 16);
            this.btnCashshop.ButtonStateChanged += new EventHandler(aCtrl_RefreshCall);

            this.btnClose = new ACtrlButton();
            this.btnClose.Normal = new BitmapOrigin(Resource.BtClose3_normal_0);
            this.btnClose.Pressed = new BitmapOrigin(Resource.BtClose3_pressed_0);
            this.btnClose.MouseOver = new BitmapOrigin(Resource.BtClose3_mouseOver_0);
            this.btnClose.Disabled = new BitmapOrigin(Resource.BtClose3_disabled_0);
            this.btnClose.Location = new Point(150, 6);
            this.btnClose.Size = new Size(13, 13);
            this.btnClose.ButtonStateChanged += new EventHandler(aCtrl_RefreshCall);
            this.btnClose.MouseClick += new MouseEventHandler(btnClose_MouseClick);
        }

        public override void Refresh()
        {
            this.preRender();
            this.SetBitmap(this.Bitmap);
            this.CaptionRectangle = new Rectangle(0, 0, this.Bitmap.Width, 24);
            base.Refresh();
        }

        protected override bool captionHitTest(Point point)
        {
            if (this.btnClose.Rectangle.Contains(point))
                return false;
            return base.captionHitTest(point);
        }

        private void preRender()
        {
            if (Bitmap != null)
                Bitmap.Dispose();

            if (this.btnGather.Visible)
            {
                this.btnSort.Visible = false;
            }
            else
            {
                this.btnSort.Visible = true;
            }

            if (this.fullMode)
            {
                this.btnFull.Visible = false;
                this.btnSmall.Visible = true;
                this.vScroll.Visible = false;
                this.btnCoin3.Visible = false;
                this.btnCoin4.Visible = true;
                this.btnPoint.Location = new Point(190, 337);
                this.btnGather.Location = new Point(135, 337);
                this.btnSort.Location = new Point(135, 337);
                this.btnDisassemble3.Visible = false;
                this.btnDisassemble4.Visible = true;
                this.btnExtract3.Visible = false;
                this.btnExtract4.Visible = true;
                this.btnAppraise3.Visible = false;
                this.btnAppraise4.Visible = true;
                this.btnBits3.Visible = false;
                this.btnBits4.Visible = true;
                this.btnPot3.Visible = false;
                this.btnPot4.Visible = true;
                this.btnUpgrade3.Visible = false;
                this.btnUpgrade4.Visible = true;
                this.btnToad3.Visible = false;
                this.btnToad4.Visible = true;
                this.btnCashshop.Visible = true;
                this.btnClose.Location = new Point(574, 6);
                renderFull();
            }
            else
            {
                this.btnFull.Visible = true;
                this.btnSmall.Visible = false;
                this.vScroll.Visible = true;
                this.vScroll.Maximum = this.SelectedTab.ScrollMaxValue - 6;
                this.vScroll.Value = this.SelectedTab.ScrollValue;
                this.btnCoin3.Visible = true;
                this.btnCoin4.Visible = false;
                this.btnPoint.Location = new Point(9, 285);
                this.btnGather.Location = new Point(130, 267);
                this.btnSort.Location = new Point(130, 267);
                this.btnDisassemble3.Visible = true;
                this.btnDisassemble4.Visible = false;
                this.btnExtract3.Visible = true;
                this.btnExtract4.Visible = false;
                this.btnAppraise3.Visible = true;
                this.btnAppraise4.Visible = false;
                this.btnBits3.Visible = true;
                this.btnBits4.Visible = false;
                this.btnPot3.Visible = true;
                this.btnPot4.Visible = false;
                this.btnUpgrade3.Visible = true;
                this.btnUpgrade4.Visible = false;
                this.btnToad3.Visible = true;
                this.btnToad4.Visible = false;
                this.btnCashshop.Visible = false;
                this.btnClose.Location = new Point(150, 6);
                renderSmall();
            }
        }

        private void renderSmall()
        {
            this.Bitmap = new Bitmap(Resource.Item_backgrnd);
            Graphics g = Graphics.FromImage(this.Bitmap);
            g.DrawImage(Resource.Item_backgrnd2, 6, 23);
            renderTabs(g);
            g.DrawImage(Resource.Item_backgrnd3, 7, 45);
            foreach (AControl ctrl in this.aControls)
            {
                ctrl.Draw(g);
            }

            ItemBase[] itemArray = this.SelectedTab.Items;
            int idxOffset = 4 * this.SelectedTab.ScrollValue;
            for (int i = 0; i < 24; i++)
            {
                Point origin = getItemIconOrigin(i);
                origin.Offset(0, 32);
                renderItemBase(g, itemArray[i + idxOffset], origin);
            }

            StringFormat format = new StringFormat();
            format.Alignment = StringAlignment.Far;
            g.DrawString("0", GearGraphics.EquipDetailFont, Brushes.Black, 128f, 270f, format);
            g.DrawString("0", GearGraphics.EquipDetailFont, Brushes.Black, 160f, 287f, format);

            g.Dispose();
        }

        private void renderFull()
        {
            this.Bitmap = new Bitmap(Resource.Item_FullBackgrnd);
            Graphics g = Graphics.FromImage(this.Bitmap);
            g.DrawImage(Resource.Item_FullBackgrnd2, 6, 23);
            renderTabs(g);
            g.DrawImage(Resource.Item_FullBackgrnd3, 7, 45);
            foreach (AControl ctrl in this.aControls)
            {
                ctrl.Draw(g);
            }

            ItemBase[] itemArray = this.SelectedTab.Items;
            for (int i = 0; i < itemArray.Length; i++)
            {
                int idx = i % 32, group = i / 32;
                Point origin = getItemIconOrigin(i);
                origin.Offset(0, 32);
                renderItemBase(g, itemArray[i], origin);
            }

            StringFormat format = new StringFormat();
            format.Alignment = StringAlignment.Far;
            g.DrawString("0", GearGraphics.EquipDetailFont, Brushes.Black, 131f, 340f, format);
            g.DrawString("0", GearGraphics.EquipDetailFont, Brushes.Black, 341f, 340f, format);

            g.Dispose();
        }

        private void renderTabs(Graphics g)
        {
            for (int i = 0; i < this.itemTabs.Length; i++)
            {
                if (this.itemTabs[i].Selected)
                {
                    Point pos = this.itemTabs[i].TabEnabled.OpOrigin;
                    // if (this.fullMode)
                    pos.Offset(0, -2);
                    g.DrawImage(this.itemTabs[i].TabEnabled.Bitmap, pos);
                }
                else
                {
                    g.DrawImage(this.itemTabs[i].TabDisabled.Bitmap, this.itemTabs[i].TabEnabled.OpOrigin);
                }
            }
        }

        private void renderItemBase(Graphics g, ItemBase itemBase, Point origin)
        {
            if (itemBase is Gear)
                renderGear(g, itemBase as Gear, origin);
            else if (itemBase is Item)
                renderItem(g, itemBase as Item, origin);
        }

        private void renderGear(Graphics g, Gear gear, Point origin)
        {
            if (g == null || gear == null)
                return;
            Pen pen = GearGraphics.GetGearItemBorderPen(gear.Grade);
            if (pen != null)
            {
                Point[] path = GearGraphics.GetIconBorderPath(origin.X, origin.Y - 32);
                g.DrawLines(pen, path);
            }
            g.DrawImage(Resource.Item_shadow, origin.X + 3, origin.Y - 6);
            if (gear.IconRaw.Bitmap != null)
            {
                g.DrawImage(gear.IconRaw.Bitmap, origin.X - gear.IconRaw.Origin.X, origin.Y - gear.IconRaw.Origin.Y);
            }
            if (gear.Cash)
            {
                Bitmap cashImg = null;
                Point cashOrigin = new Point(12, 12);

                int value;
                if (gear.Props.TryGetValue(GearPropType.royalSpecial, out value) && value > 0)
                {
                    string resKey = $"CashShop_img_CashItem_label_{value - 1}";
                    cashImg = Resource.ResourceManager.GetObject(resKey) as Bitmap;
                }
                else if (gear.Props.TryGetValue(GearPropType.masterSpecial, out value) && value > 0)
                {
                    cashImg = Resource.CashShop_img_CashItem_label_3;
                }
                else if (gear.Props.TryGetValue(GearPropType.BTSLabel, out value) && value > 0)
                {
                    cashImg = Resource.CashShop_img_CashItem_label_10;
                    cashOrigin = new Point(cashImg.Width, cashImg.Height);
                }
                else if (gear.Props.TryGetValue(GearPropType.BLACKPINKLabel, out value) && value > 0)
                {
                    cashImg = Resource.CashShop_img_CashItem_label_11;
                    cashOrigin = new Point(cashImg.Width, cashImg.Height);
                }
                if (cashImg == null) //default cashImg
                {
                    cashImg = Resource.CashItem_0;
                }

                //g.DrawImage(cashImg, origin.X + 20, origin.Y - 12);
                g.DrawImage(cashImg, origin.X + 32 - cashOrigin.X, origin.Y - cashOrigin.Y);
            }
            if (gear.TimeLimited)
            {
                g.DrawImage(Resource.Item_timeLimit_0, origin.X, origin.Y - 32);
            }
        }

        private void renderItem(Graphics g, Item item, Point origin)
        {
            if (g == null || item == null)
                return;
            g.DrawImage(Resource.Item_shadow, origin.X + 3, origin.Y - 6);
            if (item.IconRaw.Bitmap != null)
            {
                g.DrawImage(item.IconRaw.Bitmap, origin.X - item.IconRaw.Origin.X, origin.Y - item.IconRaw.Origin.Y);
            }
            if (item.Cash)
            {
                Bitmap cashImg = null;
                Point cashOrigin = new Point(12, 12);

                int value;
                if (item.Props.TryGetValue(ItemPropType.wonderGrade, out value) && value > 0)
                {
                    string resKey = $"CashShop_img_CashItem_label_{value + 3}";
                    cashImg = Resource.ResourceManager.GetObject(resKey) as Bitmap;
                }
                else if (item.Props.TryGetValue(ItemPropType.BTSLabel, out value) && value > 0)
                {
                    cashImg = Resource.CashShop_img_CashItem_label_10;
                    cashOrigin = new Point(cashImg.Width, cashImg.Height);
                }
                else if (item.Props.TryGetValue(ItemPropType.BLACKPINKLabel, out value) && value > 0)
                {
                    cashImg = Resource.CashShop_img_CashItem_label_11;
                    cashOrigin = new Point(cashImg.Width, cashImg.Height);
                }
                if (cashImg == null) //default cashImg
                {
                    cashImg = Resource.CashItem_0;
                }

                g.DrawImage(cashImg, origin.X + 32 - cashOrigin.X, origin.Y - cashOrigin.Y);
            }
            if (item.TimeLimited)
            {
                g.DrawImage(Resource.Item_timeLimit_0, origin.X, origin.Y - 32);
            }
            if (item.ItemID / 1000 == 3017)
            {
                g.DrawImage(Resource.Item_monsterCollection_0, origin.X, origin.Y - 32);
            }
        }

        private Point getItemIconOrigin(int index)
        {
            int idx = index % 32, group = index / 32;
            Point p = new Point((idx % 4 + group * 4) * 36, idx / 4 * 35);
            p.Offset(10, 51);
            return p;
        }

        public int GetSlotIndexByPoint(Point point)
        {
            Point p = point;
            p.Offset(-10, -51);
            if (p.X < 0 || p.Y < 0)
                return -1;
            int x = p.X / 36, y = p.Y / 35;
            if ((fullMode ? y >= 8 : y >= 6) || (fullMode ? x >= 16 : x >= 4))
                return -1;
            int idx = y * 4 + x % 4 + x / 4 * 32;
            if (new Rectangle(getItemIconOrigin(idx), new Size(33, 33)).Contains(point))
                return idx;
            else
                return -1;
        }

        public int GetItemIndexByPoint(Point point)
        {
            int slotIdx = GetSlotIndexByPoint(point);
            if (slotIdx != -1 && !this.fullMode)
            {
                slotIdx += 4 * this.SelectedTab.ScrollValue;
            }
            return slotIdx;
        }

        public ItemBase GetItemByPoint(Point point)
        {
            int itemIdx = GetItemIndexByPoint(point);
            if (itemIdx > -1 && itemIdx < this.SelectedTab.Items.Length)
                return this.SelectedTab.Items[itemIdx];
            else
                return null;
        }

        #region 重写和响应事件
        protected override void OnMouseMove(MouseEventArgs e)
        {
            foreach (AControl ctrl in this.aControls)
            {
                ctrl.OnMouseMove(e);
            }

            if (this.waitForRefresh)
            {
                this.Refresh();
                waitForRefresh = false;
            }

            base.OnMouseMove(e);

            ItemBase item = GetItemByPoint(e.Location);
            if (item != null)
                this.OnItemMouseMove(new ItemMouseEventArgs(e, item));
            else
                this.OnItemMouseLeave(EventArgs.Empty);
        }

        protected override void OnMouseDown(MouseEventArgs e)
        {
            foreach (AControl ctrl in this.aControls)
            {
                ctrl.OnMouseDown(e);
            }

            if (this.waitForRefresh)
            {
                this.Refresh();
                waitForRefresh = false;
            }

            base.OnMouseDown(e);

            ItemBase item = GetItemByPoint(e.Location);
            if (item != null)
                this.OnItemMouseDown(new ItemMouseEventArgs(e, item));
        }

        protected override void OnMouseUp(MouseEventArgs e)
        {
            foreach (AControl ctrl in this.aControls)
            {
                ctrl.OnMouseUp(e);
            }

            if (this.waitForRefresh)
            {
                this.Refresh();
                waitForRefresh = false;
            }

            base.OnMouseUp(e);

            ItemBase item = GetItemByPoint(e.Location);
            if (item != null)
                this.OnItemMouseUp(new ItemMouseEventArgs(e, item));
        }

        protected override void OnMouseClick(MouseEventArgs e)
        {
            //处理选择选项卡
            tab_OnMouseClick(e);

            foreach (AControl ctrl in this.aControls)
            {
                ctrl.OnMouseClick(e);
            }

            if (this.waitForRefresh)
            {
                this.Refresh();
                waitForRefresh = false;
            }

            base.OnMouseClick(e);

            ItemBase item = GetItemByPoint(e.Location);
            if (item != null)
                this.OnItemMouseClick(new ItemMouseEventArgs(e, item));
        }

        protected override void OnMouseWheel(MouseEventArgs e)
        {
            foreach (AControl ctrl in this.aControls)
            {
                ctrl.OnMouseWheel(e);
            }

            if (this.waitForRefresh)
            {
                this.Refresh();
                waitForRefresh = false;
            }

            base.OnMouseWheel(e);
        }

        protected override void OnKeyDown(KeyEventArgs e)
        {
            if (e.KeyCode == Keys.Tab)
            {
                this.SelectedIndex = (this.SelectedIndex + 1) % this.itemTabs.Length;
                this.Refresh();
            }

            base.OnKeyDown(e);
        }

        protected virtual void OnItemMouseDown(ItemMouseEventArgs e)
        {
            if (this.ItemMouseDown != null)
                this.ItemMouseDown(this, e);
        }

        protected virtual void OnItemMouseUp(ItemMouseEventArgs e)
        {
            if (this.ItemMouseUp != null)
                this.ItemMouseUp(this, e);
        }

        protected virtual void OnItemMouseClick(ItemMouseEventArgs e)
        {
            if (this.ItemMouseClick != null)
                this.ItemMouseClick(this, e);
        }

        protected virtual void OnItemMouseMove(ItemMouseEventArgs e)
        {
            if (this.ItemMouseMove != null)
                this.ItemMouseMove(this, e);
        }

        protected virtual void OnItemMouseLeave(EventArgs e)
        {
            if (this.ItemMouseLeave != null)
                this.ItemMouseLeave(this, e);
        }
        #endregion

        private void tab_OnMouseClick(MouseEventArgs e)
        {
            if (e.Button == MouseButtons.Left)
            {
                for (int i = 0; i < this.itemTabs.Length; i++)
                {
                    Rectangle rect;
                    if (this.itemTabs[i].Selected)
                    {
                        rect = this.itemTabs[i].TabEnabled.Rectangle;
                    }
                    else
                    {
                        rect = this.itemTabs[i].TabDisabled.Rectangle;
                    }
                    if (rect.Contains(e.Location))
                    {
                        if (this.SelectedIndex != i)
                        {
                            this.SelectedIndex = i;
                            this.btnGather.Visible = true; //切换tab时重置btnGather状态
                            this.waitForRefresh = true;
                        }
                        break;
                    }
                }
            }
        }

        private void btnSmall_MouseClick(object sender, MouseEventArgs e)
        {
            this.fullMode = false;
            this.waitForRefresh = true;
        }

        private void btnFull_MouseClick(object sender, MouseEventArgs e)
        {
            this.fullMode = true;
            this.waitForRefresh = true;
        }

        private void vScroll_ValueChanged(object sender, EventArgs e)
        {
            this.SelectedTab.ScrollValue = this.vScroll.Value;
            this.waitForRefresh = true;
        }

        private void btnGather_MouseClick(object sender, MouseEventArgs e)
        {
            this.btnGather.Visible = !this.btnGather.Visible;
            this.gather();
            this.waitForRefresh = true;
        }

        private void btnSort_MouseClick(object sender, MouseEventArgs e)
        {
            this.btnGather.Visible = !this.btnGather.Visible;
            this.sort();
            this.waitForRefresh = true;
        }

        private void btnClose_MouseClick(object sender, MouseEventArgs e)
        {
            this.Visible = false;
        }

        private void aCtrl_RefreshCall(object sender, EventArgs e)
        {
            this.waitForRefresh = true;
        }

        private void gather()
        {
            ItemBase[] itemArray = this.SelectedTab.Items;
            Queue<int> nullQueue = new Queue<int>();
            for (int i = 0; i < itemArray.Length; i++)
            {
                if (itemArray[i] == null)
                {
                    nullQueue.Enqueue(i);
                }
                else if (nullQueue.Count > 0)
                {
                    int nullIdx = nullQueue.Dequeue();
                    itemArray[nullIdx] = itemArray[i];
                    itemArray[i] = null;
                    nullQueue.Enqueue(i);
                }
            }
        }

        private void sort()
        {
            ItemBase[] itemArray = this.SelectedTab.Items;
            Array.Sort<ItemBase>(itemArray, (a, b) =>
            {
                if (a == null) return 1;
                if (b == null) return -1;
                return a.ItemID - b.ItemID;
            });
        }

        private IEnumerable<AControl> aControls
        {
            get
            {
                yield return this.vScroll;
                yield return this.btnFull;
                yield return this.btnSmall;
                yield return this.btnCoin3;
                yield return this.btnCoin4;
                yield return this.btnPoint;
                yield return this.btnGather;
                yield return this.btnSort;
                yield return this.btnDisassemble3;
                yield return this.btnDisassemble4;
                yield return this.btnExtract3;
                yield return this.btnExtract4;
                yield return this.btnAppraise3;
                yield return this.btnAppraise4;
                yield return this.btnBits3;
                yield return this.btnBits4;
                yield return this.btnPot3;
                yield return this.btnPot4;
                yield return this.btnUpgrade3;
                yield return this.btnUpgrade4;
                yield return this.btnToad3;
                yield return this.btnToad4;
                yield return this.btnCashshop;
                yield return this.btnClose;
            }
        }

        public ItemTab[] ItemTabs
        {
            get { return this.itemTabs; }
        }

        /// <summary>
        /// 获取或设置一个bool值，它表示是否当前背包显示为大背包模式。
        /// </summary>
        public bool FullMode
        {
            get { return fullMode; }
            set { fullMode = value; }
        }

        /// <summary>
        /// 获取或设置正在选中的背包选项卡的索引。
        /// </summary>
        public int SelectedIndex
        {
            get
            {
                for (int i = 0; i < this.itemTabs.Length; i++)
                {
                    if (this.itemTabs[i].Selected)
                        return i;
                }
                this.itemTabs[0].Selected = true;
                return 0;
            }
            set
            {
                value = Math.Min(Math.Max(value, 0), this.itemTabs.Length - 1);
                this.selectedIndexChanging = true;
                for (int i = 0; i < this.itemTabs.Length; i++)
                {
                    this.itemTabs[i].Selected = (i == value);
                }
                this.selectedIndexChanging = false;
            }
        }

        public bool AddItem(ItemBase item)
        {
            if (item == null)
                return false;

            int idx;
            switch (item.Type)
            {
                case ItemBaseType.Equip: idx = 0; break;
                case ItemBaseType.Consume: idx = 1; break;
                case ItemBaseType.Install: idx = 3; break;
                case ItemBaseType.Etc: idx = 2; break;
                case ItemBaseType.Cash: idx = 4; break;
                default: return false;
            }

            ItemBase[] itemArray = this.itemTabs[idx].Items;

            for (int i = 0; i < itemArray.Length; i++)
            {
                if (itemArray[i] == null)
                {
                    itemArray[i] = (ItemBase)item.Clone();
                    this.SelectedIndex = idx;
                    this.itemTabs[idx].ScrollValue = (i - 20) / 4;
                    this.Refresh();
                    return true;
                }
            }
            return false;
        }

        private void InitializeComponent()
        {
            SuspendLayout();
            // 
            // AfrmItem
            // 
            AutoScaleMode = AutoScaleMode.None;
            ClientSize = new Size(300, 300);
            Font = new Font("Microsoft JhengHei UI", 9F, FontStyle.Regular, GraphicsUnit.Pixel);
            Location = new Point(0, 0);
            Name = "AfrmItem";
            ResumeLayout(false);
        }

        public void RemoveItem(int index)
        {
            ItemBase[] itemArray = this.SelectedTab.Items;
            if (index >= 0 && index < itemArray.Length && itemArray[index] != null)
            {
                itemArray[index] = null;
                this.Refresh();
            }
        }

        /// <summary>
        /// 获取或设置正在选中的背包选项卡。
        /// </summary>
        public ItemTab SelectedTab
        {
            get { return this.itemTabs[this.SelectedIndex]; }
            set { this.SelectedIndex = Array.IndexOf(this.itemTabs, value); }
        }

        public class ItemTab
        {
            public ItemTab(AfrmItem owner)
            {
                this.owner = owner;
                this.items = new ItemBase[ItemCount];
            }

            public const int ItemCount = 128;
            private AfrmItem owner;
            private ItemBase[] items;
            private bool selected;
            private BitmapOrigin tabEnabled;
            private BitmapOrigin tabDisabled;
            private int scrollValue;

            public ItemBase[] Items
            {
                get { return this.items; }
            }

            public bool Selected
            {
                get { return selected; }
                set
                {
                    if (selected != value)
                    {
                        if (!this.owner.selectedIndexChanging)
                            this.owner.SelectedIndex = Array.IndexOf(this.owner.itemTabs, this);
                        this.selected = value;
                    }
                }
            }

            public bool SetItemSource(ItemBase[] items)
            {
                if (items == null || items.Length != ItemCount)
                {
                    return false;
                }
                else
                {
                    this.items = items;
                    return true;
                }
            }

            public void ClearItems()
            {
                for (int i = 0; i < this.items.Length; i++)
                {
                    this.items[i] = null;
                }
            }

            public BitmapOrigin TabEnabled
            {
                get { return tabEnabled; }
                set { tabEnabled = value; }
            }

            public BitmapOrigin TabDisabled
            {
                get { return tabDisabled; }
                set { tabDisabled = value; }
            }

            public int ScrollMaxValue
            {
                get { return this.items.Length / 4; }
            }

            public int ScrollValue
            {
                get { return scrollValue; }
                set
                {
                    value = Math.Min(Math.Max(0, value), ScrollMaxValue);
                    scrollValue = value;
                }
            }
        }
    }
}
```

`MapleNecrocer/CharaSimControl/AfrmItem.resx`:

```resx
<root>
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`MapleNecrocer/CharaSimControl/AfrmStat.cs`:

```cs
using System;
using System.Linq;
using System.Drawing;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Windows.Forms;
using System.Text;
using System.Text.RegularExpressions;
using CharaSimResource;
using WzComparerR2.CharaSim;
using WzComparerR2.Common;
using WzComparerR2.Controls;
using WzComparerR2.WzLib;

namespace WzComparerR2.CharaSimControl
{
    public class AfrmStat : AlphaForm
    {
        public AfrmStat()
        {
            sec = new int[2];
            for (int i = 0; i < sec.Length; i++)
                sec[i] = 1 << i;

            hyperStatList = new int[] { 80000400, 80000401, 80000402, 80000403, 80000404, 80000405, 80000406, 80000409, 80000410, 80000412, 80000413, 80000414, 80000416, 80000417, 80000419, 80000420, 80000421 };
            hyperStatBitmapList = hyperStatList.Select(id => Resource.ResourceManager.GetObject("HyperStat_Window_statList_" + id) as Bitmap).ToArray();

            initCtrl();
        }

        private BitVector32 partVisible;
        private int[] sec;
        private Point baseOffset;
        private Point newLocation;
        private Character character;
        private List<TooltipHelpRect> helpList;
        private List<TooltipHelpRect> helpDetailList;
        private int hyperStatScrollValue;
        private int[] hyperStatList;
        private Bitmap[] hyperStatBitmapList;
        private Skill[] hyperStatSkillList;

        private ACtrlButton btnHPUp;
        private ACtrlButton btnMPUp;
        private ACtrlButton btnStrUp;
        private ACtrlButton btnDexUp;
        private ACtrlButton btnIntUp;
        private ACtrlButton btnLukUp;
        private ACtrlButton btnAuto;
        private ACtrlButton btnClose;
        private ACtrlButton btnDetailOpen;
        private ACtrlButton btnDetailClose;
        private ACtrlButton btnHyperStatOpen;
        private ACtrlButton btnHyperStatClose;
        private ACtrlButton btnAbility;
        private ACtrlButton btnHpUp;
        private ACtrlVScroll vScroll;
        private ACtrlButton btnLVUp1;
        private ACtrlButton btnLVUp2;
        private ACtrlButton btnLVUp3;
        private ACtrlButton btnLVUp4;
        private ACtrlButton btnLVUp5;
        private ACtrlButton btnLVUp6;
        private ACtrlButton btnLVUp7;
        private ACtrlButton btnLVUp8;
        private ACtrlButton btnLVUp9;
        private ACtrlButton btnLVUp10;
        private ACtrlButton btnLVUp11;
        private ACtrlButton btnLVUp12;
        private ACtrlButton btnReset;
        private ACtrlButton btnReduce;
        private bool waitForRefresh;

        public event ObjectMouseEventHandler ObjectMouseMove;
        public event EventHandler ObjectMouseLeave;

        public Character Character
        {
            get { return character; }
            set { character = value; }
        }

        public bool DetailVisible
        {
            get { return partVisible[sec[0]]; }
            private set { partVisible[sec[0]] = value; }
        }

        public bool HyperStatVisible
        {
            get { return partVisible[sec[1]]; }
            private set { partVisible[sec[1]] = value; }
        }

        private Rectangle DetailRect
        {
            get
            {
                return new Rectangle(
                    new Point(baseOffset.X + Resource.Stat_main_backgrnd.Width, baseOffset.Y),
                    Resource.Stat_detail_backgrnd.Size);
            }
        }

        private Rectangle HyperStatRect
        {
            get
            {
                return new Rectangle(
                    new Point(baseOffset.X - Resource.HyperStat_Window_backgrnd.Width, baseOffset.Y),
                    Resource.HyperStat_Window_backgrnd.Size);
            }
        }

        private void initCtrl()
        {
            this.btnHPUp = new ACtrlButton();
            this.btnHPUp.Location = new Point(187, 121);

            this.btnMPUp = new ACtrlButton();
            this.btnMPUp.Location = new Point(187, 139);

            this.btnStrUp = new ACtrlButton();
            this.btnStrUp.Location = new Point(187, 208);

            this.btnDexUp = new ACtrlButton();
            this.btnDexUp.Location = new Point(187, 226);

            this.btnIntUp = new ACtrlButton();
            this.btnIntUp.Location = new Point(187, 244);

            this.btnLukUp = new ACtrlButton();
            this.btnLukUp.Location = new Point(187, 262);

            this.btnLVUp1 = new ACtrlButton();
            this.btnLVUp1.Location = new Point(147, 43);

            this.btnLVUp2 = new ACtrlButton();
            this.btnLVUp2.Location = new Point(147, 61);

            this.btnLVUp3 = new ACtrlButton();
            this.btnLVUp3.Location = new Point(147, 79);

            this.btnLVUp4 = new ACtrlButton();
            this.btnLVUp4.Location = new Point(147, 97);

            this.btnLVUp5 = new ACtrlButton();
            this.btnLVUp5.Location = new Point(147, 115);

            this.btnLVUp6 = new ACtrlButton();
            this.btnLVUp6.Location = new Point(147, 133);

            this.btnLVUp7 = new ACtrlButton();
            this.btnLVUp7.Location = new Point(147, 151);

            this.btnLVUp8 = new ACtrlButton();
            this.btnLVUp8.Location = new Point(147, 169);

            this.btnLVUp9 = new ACtrlButton();
            this.btnLVUp9.Location = new Point(147, 187);

            this.btnLVUp10 = new ACtrlButton();
            this.btnLVUp10.Location = new Point(147, 205);

            this.btnLVUp11 = new ACtrlButton();
            this.btnLVUp11.Location = new Point(147, 223);

            this.btnLVUp12 = new ACtrlButton();
            this.btnLVUp12.Location = new Point(147, 241);

            ACtrlButton[] addBtnList = new ACtrlButton[] { btnHPUp, btnMPUp, btnStrUp, btnDexUp, btnIntUp, btnLukUp, btnLVUp1, btnLVUp2, btnLVUp3, btnLVUp4, btnLVUp5, btnLVUp6, btnLVUp7, btnLVUp8, btnLVUp9, btnLVUp10, btnLVUp11, btnLVUp12 };
            for (int i = 0; i < addBtnList.Length; i++)
            {
                addBtnList[i].Normal = new BitmapOrigin(Resource.Stat_main_BtUp_normal_0);
                addBtnList[i].MouseOver = new BitmapOrigin(Resource.Stat_main_BtUp_mouseOver_0);
                addBtnList[i].Pressed = new BitmapOrigin(Resource.Stat_main_BtUp_pressed_0);
                addBtnList[i].Disabled = new BitmapOrigin(Resource.Stat_main_BtUp_disabled_0);
                addBtnList[i].Size = new Size(12, 12);
                addBtnList[i].ButtonStateChanged += new EventHandler(aCtrl_RefreshCall);
            }

            this.btnClose = new ACtrlButton();
            this.btnClose.Normal = new BitmapOrigin(Resource.BtClose3_normal_0);
            this.btnClose.Pressed = new BitmapOrigin(Resource.BtClose3_pressed_0);
            this.btnClose.MouseOver = new BitmapOrigin(Resource.BtClose3_mouseOver_0);
            this.btnClose.Disabled = new BitmapOrigin(Resource.BtClose3_disabled_0);
            this.btnClose.Location = new Point(190, 6);
            this.btnClose.Size = new Size(13, 13);
            this.btnClose.ButtonStateChanged += new EventHandler(aCtrl_RefreshCall);
            this.btnClose.MouseClick += new MouseEventHandler(btnClose_MouseClick);

            this.btnDetailOpen = new ACtrlButton();
            this.btnDetailOpen.Normal = new BitmapOrigin(Resource.Stat_main_BtDetailOpen_normal_0);
            this.btnDetailOpen.Pressed = new BitmapOrigin(Resource.Stat_main_BtDetailOpen_pressed_0);
            this.btnDetailOpen.MouseOver = new BitmapOrigin(Resource.Stat_main_BtDetailOpen_mouseOver_0);
            this.btnDetailOpen.Disabled = new BitmapOrigin(Resource.Stat_main_BtDetailOpen_disabled_0);
            this.btnDetailOpen.Location = new Point(132, 288);
            this.btnDetailOpen.Size = new Size(68, 16);
            this.btnDetailOpen.ButtonStateChanged += new EventHandler(aCtrl_RefreshCall);
            this.btnDetailOpen.MouseClick += new MouseEventHandler(btnDetailOpen_MouseClick);

            this.btnDetailClose = new ACtrlButton();
            this.btnDetailClose.Normal = new BitmapOrigin(Resource.Stat_main_BtDetailClose_normal_0);
            this.btnDetailClose.Pressed = new BitmapOrigin(Resource.Stat_main_BtDetailClose_pressed_0);
            this.btnDetailClose.MouseOver = new BitmapOrigin(Resource.Stat_main_BtDetailClose_mouseOver_0);
            this.btnDetailClose.Disabled = new BitmapOrigin(Resource.Stat_main_BtDetailClose_disabled_0);
            this.btnDetailClose.Location = new Point(132, 288);
            this.btnDetailClose.Size = new Size(68, 16);
            this.btnDetailClose.ButtonStateChanged += new EventHandler(aCtrl_RefreshCall);
            this.btnDetailClose.MouseClick += new MouseEventHandler(btnDetailClose_MouseClick);

            this.btnHyperStatOpen = new ACtrlButton();
            this.btnHyperStatOpen.Normal = new BitmapOrigin(Resource.Stat_main_BtHyperStatOpen_normal_0);
            this.btnHyperStatOpen.Pressed = new BitmapOrigin(Resource.Stat_main_BtHyperStatOpen_pressed_0);
            this.btnHyperStatOpen.MouseOver = new BitmapOrigin(Resource.Stat_main_BtHyperStatOpen_mouseOver_0);
            this.btnHyperStatOpen.Disabled = new BitmapOrigin(Resource.Stat_main_BtHyperStatOpen_disabled_0);
            this.btnHyperStatOpen.Location = new Point(12, 288);
            this.btnHyperStatOpen.Size = new Size(71, 16);
            this.btnHyperStatOpen.ButtonStateChanged += new EventHandler(aCtrl_RefreshCall);
            this.btnHyperStatOpen.MouseClick += new MouseEventHandler(btnHyperStatOpen_MouseClick);

            this.btnHyperStatClose = new ACtrlButton();
            this.btnHyperStatClose.Normal = new BitmapOrigin(Resource.Stat_main_BtHyperStatClose_normal_0);
            this.btnHyperStatClose.Pressed = new BitmapOrigin(Resource.Stat_main_BtHyperStatClose_pressed_0);
            this.btnHyperStatClose.MouseOver = new BitmapOrigin(Resource.Stat_main_BtHyperStatClose_mouseOver_0);
            this.btnHyperStatClose.Disabled = new BitmapOrigin(Resource.Stat_main_BtHyperStatClose_disabled_0);
            this.btnHyperStatClose.Location = new Point(12, 288);
            this.btnHyperStatClose.Size = new Size(71, 16);
            this.btnHyperStatClose.ButtonStateChanged += new EventHandler(aCtrl_RefreshCall);
            this.btnHyperStatClose.MouseClick += new MouseEventHandler(btnHyperStatClose_MouseClick);

            this.btnAuto = new ACtrlButton();
            this.btnAuto.Normal = new BitmapOrigin(Resource.Stat_main_BtAuto_normal_3);
            this.btnAuto.Pressed = new BitmapOrigin(Resource.Stat_main_BtAuto_pressed_0);
            this.btnAuto.MouseOver = new BitmapOrigin(Resource.Stat_main_BtAuto_mouseOver_0);
            this.btnAuto.Disabled = new BitmapOrigin(Resource.Stat_main_BtAuto_disabled_0);
            this.btnAuto.Location = new Point(128, 162);
            this.btnAuto.Size = new Size(67, 34);
            this.btnAuto.ButtonStateChanged += new EventHandler(aCtrl_RefreshCall);

            this.btnAbility = new ACtrlButton();
            this.btnAbility.Normal = new BitmapOrigin(Resource.Stat_detail_BtAbility_normal_0);
            this.btnAbility.Pressed = new BitmapOrigin(Resource.Stat_detail_BtAbility_pressed_0);
            this.btnAbility.MouseOver = new BitmapOrigin(Resource.Stat_detail_BtAbility_mouseOver_0);
            this.btnAbility.Disabled = new BitmapOrigin(Resource.Stat_detail_BtAbility_disabled_0);
            this.btnAbility.Location = new Point(152, 286);
            this.btnAbility.Size = new Size(50, 16);
            this.btnAbility.ButtonStateChanged += new EventHandler(aCtrl_RefreshCall);

            this.btnHpUp = new ACtrlButton();
            this.btnHpUp.Normal = new BitmapOrigin(Resource.Stat_detail_BtHpUp_normal_0);
            this.btnHpUp.Pressed = new BitmapOrigin(Resource.Stat_detail_BtHpUp_pressed_0);
            this.btnHpUp.MouseOver = new BitmapOrigin(Resource.Stat_detail_BtHpUp_mouseOver_0);
            this.btnHpUp.Disabled = new BitmapOrigin(Resource.Stat_detail_BtHpUp_disabled_0);
            this.btnHpUp.Location = new Point(185, 312);
            this.btnHpUp.Size = new Size(17, 16);
            this.btnHpUp.ButtonStateChanged += new EventHandler(aCtrl_RefreshCall);
            this.btnHpUp.MouseClick += new MouseEventHandler(btnDetailClose_MouseClick);

            this.vScroll = new ACtrlVScroll();

            this.vScroll.PicBase.Normal = new BitmapOrigin(Resource.VScr9_enabled_base);
            this.vScroll.PicBase.Disabled = new BitmapOrigin(Resource.VScr9_disabled_base);

            this.vScroll.BtnPrev.Normal = new BitmapOrigin(Resource.VScr9_enabled_prev0);
            this.vScroll.BtnPrev.Pressed = new BitmapOrigin(Resource.VScr9_enabled_prev1);
            this.vScroll.BtnPrev.MouseOver = new BitmapOrigin(Resource.VScr9_enabled_prev2);
            this.vScroll.BtnPrev.Disabled = new BitmapOrigin(Resource.VScr9_disabled_prev);
            this.vScroll.BtnPrev.Size = this.vScroll.BtnPrev.Normal.Bitmap.Size;
            this.vScroll.BtnPrev.Location = new Point(0, 0);

            this.vScroll.BtnNext.Normal = new BitmapOrigin(Resource.VScr9_enabled_next0);
            this.vScroll.BtnNext.Pressed = new BitmapOrigin(Resource.VScr9_enabled_next1);
            this.vScroll.BtnNext.MouseOver = new BitmapOrigin(Resource.VScr9_enabled_next2);
            this.vScroll.BtnNext.Disabled = new BitmapOrigin(Resource.VScr9_disabled_next);
            this.vScroll.BtnNext.Size = this.vScroll.BtnNext.Normal.Bitmap.Size;
            this.vScroll.BtnNext.Location = new Point(0, 202);

            this.vScroll.BtnThumb.Normal = new BitmapOrigin(Resource.VScr9_enabled_thumb0);
            this.vScroll.BtnThumb.Pressed = new BitmapOrigin(Resource.VScr9_enabled_thumb1);
            this.vScroll.BtnThumb.MouseOver = new BitmapOrigin(Resource.VScr9_enabled_thumb0);
            this.vScroll.BtnThumb.Size = this.vScroll.BtnThumb.Normal.Bitmap.Size;

            this.vScroll.Location = new Point(163, 41);
            this.vScroll.Size = new Size(11, 214);
            this.vScroll.ScrollableLocation = new Point(11, 41);
            this.vScroll.ScrollableSize = new Size(163, 214);
            this.vScroll.ValueChanged += new EventHandler(vScroll_ValueChanged);
            this.vScroll.ChildButtonStateChanged += new EventHandler(aCtrl_RefreshCall);

            this.btnReset = new ACtrlButton();
            this.btnReset.Normal = new BitmapOrigin(Resource.Stat_detail_BtAbility_normal_0);
            this.btnReset.Pressed = new BitmapOrigin(Resource.Stat_detail_BtAbility_pressed_0);
            this.btnReset.MouseOver = new BitmapOrigin(Resource.Stat_detail_BtAbility_mouseOver_0);
            this.btnReset.Disabled = new BitmapOrigin(Resource.Stat_detail_BtAbility_disabled_0);
            this.btnReset.Location = new Point(123, 288);
            this.btnReset.Size = new Size(50, 16);
            this.btnReset.ButtonStateChanged += new EventHandler(aCtrl_RefreshCall);

            this.btnReduce = new ACtrlButton();
            this.btnReduce.Normal = new BitmapOrigin(Resource.HyperStat_Window_BtReduce_normal_0);
            this.btnReduce.Pressed = new BitmapOrigin(Resource.HyperStat_Window_BtReduce_pressed_0);
            this.btnReduce.MouseOver = new BitmapOrigin(Resource.HyperStat_Window_BtReduce_mouseOver_0);
            this.btnReduce.Disabled = new BitmapOrigin(Resource.HyperStat_Window_BtReduce_disabled_0);
            this.btnReduce.Location = new Point(11, 288);
            this.btnReduce.Size = new Size(17, 16);
            this.btnReduce.ButtonStateChanged += new EventHandler(aCtrl_RefreshCall);
            this.btnReduce.MouseClick += new MouseEventHandler(btnHyperStatOpen_MouseClick);
        }

        private IEnumerable<AControl> aControls
        {
            get
            {
                yield return btnHPUp;
                yield return btnMPUp;
                yield return btnStrUp;
                yield return btnDexUp;
                yield return btnIntUp;
                yield return btnLukUp;
                yield return btnAuto;
                yield return btnClose;
                yield return btnDetailOpen;
                yield return btnDetailClose;
                yield return btnHyperStatOpen;
                yield return btnHyperStatClose;
            }
        }

        private IEnumerable<AControl> aDetailControls
        {
            get
            {
                yield return btnAbility;
                yield return btnHpUp;
            }
        }

        private IEnumerable<AControl> aHyperStatControls
        {
            get
            {
                yield return vScroll;
                yield return btnLVUp1;
                yield return btnLVUp2;
                yield return btnLVUp3;
                yield return btnLVUp4;
                yield return btnLVUp5;
                yield return btnLVUp6;
                yield return btnLVUp7;
                yield return btnLVUp8;
                yield return btnLVUp9;
                yield return btnLVUp10;
                yield return btnLVUp11;
                yield return btnLVUp12;
                yield return btnReset;
                yield return btnReduce;
            }
        }

        public override void Refresh()
        {
            this.preRender();
            this.SetBitmap(this.Bitmap);
            this.CaptionRectangle = new Rectangle(this.baseOffset, new Size(Resource.Stat_main_backgrnd.Width, 24));
            this.Location = newLocation;
            base.Refresh();
        }

        protected override bool captionHitTest(Point point)
        {
            Rectangle rect = this.btnClose.Rectangle;
            rect.Offset(this.baseOffset);
            if (rect.Contains(point))
                return false;
            return base.captionHitTest(point);
        }

        private void preRender()
        {
            if (Bitmap != null)
                Bitmap.Dispose();

            setControlState();

            Point baseOffsetnew = calcRenderBaseOffset();
            Size size = Resource.Stat_main_backgrnd.Size;
            size.Width += baseOffsetnew.X;
            if (this.DetailVisible)
                size = new Size(size.Width + Resource.Stat_detail_backgrnd.Width, Resource.Stat_detail_backgrnd.Height);

            this.newLocation = new Point(this.Location.X + this.baseOffset.X - baseOffsetnew.X,
                this.Location.Y + this.baseOffset.Y - baseOffsetnew.Y);
            this.baseOffset = baseOffsetnew;

            //绘制背景
            Bitmap stat = new Bitmap(size.Width, size.Height);
            Graphics g = Graphics.FromImage(stat);
            renderBase(g);
            if (this.DetailVisible)
                renderDetail(g);
            if (this.HyperStatVisible)
                renderHyperStat(g);

            //绘制按钮
            g.TranslateTransform(baseOffset.X, baseOffset.Y);
            foreach (AControl ctrl in this.aControls)
            {
                ctrl.Draw(g);
            }
            g.ResetTransform();

            g.TranslateTransform(this.DetailRect.X, this.DetailRect.Y);
            foreach (AControl ctrl in this.aDetailControls)
            {
                ctrl.Draw(g);
            }
            g.ResetTransform();

            g.TranslateTransform(this.HyperStatRect.X, this.HyperStatRect.Y);
            foreach (AControl ctrl in this.aHyperStatControls)
            {
                ctrl.Draw(g);
            }
            g.ResetTransform();

            g.Dispose();
            this.Bitmap = stat;

            if (helpList == null)
            {
                this.helpList = new List<TooltipHelpRect>();
                foreach (Wz_Node helpNode in PluginBase.PluginManager.FindWz("String/ToolTipHelp.img/Game/UIWnd/Stat")?.Nodes ?? Enumerable.Empty<Wz_Node>())
                {
                    Wz_Vector lt = helpNode.Nodes["lt"]?.Value as Wz_Vector ?? new Wz_Vector(0, 0);
                    Wz_Vector rb = helpNode.Nodes["rb"]?.Value as Wz_Vector ?? new Wz_Vector(0, 0);
                    helpList.Add(new TooltipHelpRect(new Rectangle(lt.X, lt.Y, rb.X - lt.X, rb.Y - lt.Y), new TooltipHelp(helpNode.Nodes["Title"].GetValueEx<string>(null), helpNode.Nodes["Desc"].GetValueEx<string>(null))));
                }
                if (helpList.Count == 0)
                {
                    helpList = null;
                }
            }

            if (helpDetailList == null)
            {
                this.helpDetailList = new List<TooltipHelpRect>();
                foreach (Wz_Node helpNode in PluginBase.PluginManager.FindWz("String/ToolTipHelp.img/Game/UIWnd/StatDetail")?.Nodes ?? Enumerable.Empty<Wz_Node>())
                {
                    Wz_Vector lt = helpNode.Nodes["lt"]?.Value as Wz_Vector ?? new Wz_Vector(0, 0);
                    Wz_Vector rb = helpNode.Nodes["rb"]?.Value as Wz_Vector ?? new Wz_Vector(0, 0);
                    helpDetailList.Add(new TooltipHelpRect(new Rectangle(lt.X, lt.Y, rb.X - lt.X, rb.Y - lt.Y), new TooltipHelp(helpNode.Nodes["Title"].GetValueEx<string>(null), helpNode.Nodes["Desc"].GetValueEx<string>(null))));
                }
                if (helpDetailList.Count == 0)
                {
                    helpDetailList = null;
                }
            }

            if (hyperStatSkillList == null)
            {
                try
                {
                    hyperStatSkillList = hyperStatList.Select(id => id.ToString().PadLeft(7, '0')).Select(id => Skill.CreateFromNode(PluginBase.PluginManager.FindWz("Skill/" + (Regex.IsMatch(id, @"80\d{6}") ? id.Substring(0, 6) : id.Substring(0, id.Length - 4)) + ".img/skill/" + id), PluginBase.PluginManager.FindWz)).ToArray();
                }
                catch (Exception ex)
                {
                    hyperStatSkillList = null;
                }
            }
        }

        private Point calcRenderBaseOffset()
        {
            if (this.HyperStatVisible)
                return new Point(Resource.HyperStat_Window_backgrnd.Width, 0);
            else
                return new Point(0, 0);
        }

        private void setControlState()
        {
            if (this.DetailVisible)
            {
                this.btnDetailOpen.Visible = false;
                this.btnDetailClose.Visible = true;
                this.btnAbility.Visible = true;
                this.btnHpUp.Visible = true;
            }
            else
            {
                this.btnDetailOpen.Visible = true;
                this.btnDetailClose.Visible = false;
                this.btnAbility.Visible = true;
                this.btnHpUp.Visible = false;
            }

            if (this.HyperStatVisible)
            {
                this.btnHyperStatOpen.Visible = true;
                this.btnHyperStatClose.Visible = false;
                this.vScroll.Visible = true;
                this.vScroll.Maximum = hyperStatList.Length - 12;
                this.vScroll.Value = this.hyperStatScrollValue;
                this.btnLVUp1.Visible = true;
                this.btnLVUp2.Visible = true;
                this.btnLVUp3.Visible = true;
                this.btnLVUp4.Visible = true;
                this.btnLVUp5.Visible = true;
                this.btnLVUp6.Visible = true;
                this.btnLVUp7.Visible = true;
                this.btnLVUp8.Visible = true;
                this.btnLVUp9.Visible = true;
                this.btnLVUp10.Visible = true;
                this.btnLVUp11.Visible = true;
                this.btnLVUp12.Visible = true;
                this.btnReset.Visible = true;
                this.btnReduce.Visible = true;
            }
            else
            {
                this.btnHyperStatOpen.Visible = false;
                this.btnHyperStatClose.Visible = true;
                this.vScroll.Visible = false;
                this.btnLVUp1.Visible = false;
                this.btnLVUp2.Visible = false;
                this.btnLVUp3.Visible = false;
                this.btnLVUp4.Visible = false;
                this.btnLVUp5.Visible = false;
                this.btnLVUp6.Visible = false;
                this.btnLVUp7.Visible = false;
                this.btnLVUp8.Visible = false;
                this.btnLVUp9.Visible = false;
                this.btnLVUp10.Visible = false;
                this.btnLVUp11.Visible = false;
                this.btnLVUp12.Visible = false;
                this.btnReset.Visible = false;
                this.btnReduce.Visible = false;
            }

            if (this.character != null)
            {
                CharacterStatus charStat = this.character.Status;
                setButtonEnabled(this.btnHPUp, charStat.Ap > 0 && charStat.MaxHP.BaseVal < charStat.MaxHP.TotalMax);
                setButtonEnabled(this.btnMPUp, charStat.Ap > 0 && charStat.MaxMP.BaseVal < charStat.MaxMP.TotalMax);
                setButtonEnabled(this.btnStrUp, charStat.Ap > 0/* && charStat.Strength.BaseVal <= 999*/);
                setButtonEnabled(this.btnDexUp, charStat.Ap > 0/* && charStat.Dexterity.BaseVal <= 999*/);
                setButtonEnabled(this.btnIntUp, charStat.Ap > 0/* && charStat.Intelligence.BaseVal <= 999*/);
                setButtonEnabled(this.btnLukUp, charStat.Ap > 0/* && charStat.Luck.BaseVal <= 999*/);
                setButtonEnabled(this.btnAuto, charStat.Ap > 0);
            }
            else
            {
                foreach (AControl ctrl in this.aControls)
                {
                    setButtonEnabled(ctrl as ACtrlButton, true);
                }
            }
        }

        private void setButtonEnabled(ACtrlButton button, bool enabled)
        {
            if (button == null)
                return;
            if (enabled)
            {
                if (button.State == ButtonState.Disabled)
                {
                    button.State = ButtonState.Normal;
                }
            }
            else
            {
                if (button.State != ButtonState.Disabled)
                {
                    button.State = ButtonState.Disabled;
                }
            }
        }

        private void renderBase(Graphics g)
        {
            g.TranslateTransform(baseOffset.X, baseOffset.Y);
            g.DrawImage(Resource.Stat_main_backgrnd, 0, 0);
            g.DrawImage(Resource.Stat_main_backgrnd2, 6, 22);
            g.DrawImage(Resource.Stat_main_backgrnd3, 7, 156);

            if (this.character != null)
            {
                CharacterStatus charStat = this.character.Status;
                //绘制自动分配
                // g.DrawImage(charStat.Ap > 0 ? Resource.Stat_main_BtAuto_normal_3 : Resource.Stat_main_BtAuto_disabled_0, 94, 180);
                /*switch (charStat.Job / 100 % 10)//绘制角色属性灰色背景
                {
                    case 0:
                    case 1:
                    case 3:
                    case 5:
                        g.DrawImage(Resource.Stat_main_Disabled_INT, 11, 296);
                        g.DrawImage(Resource.Stat_main_Disabled_LUK, 11, 314);
                        break;
                    case 2:
                        g.DrawImage(Resource.Stat_main_Disabled_STR, 11, 260);
                        g.DrawImage(Resource.Stat_main_Disabled_DEX, 11, 278);
                        break;
                    case 4:
                        g.DrawImage(Resource.Stat_main_Disabled_STR, 11, 260);
                        g.DrawImage(Resource.Stat_main_Disabled_INT, 11, 296);
                        break;
                }*/
                g.DrawString(this.character.Name, GearGraphics.EquipDetailFont, GearGraphics.StatDetailGrayBrush, 72f, 32f);
                g.DrawString(ItemStringHelper.GetJobName(charStat.Job), GearGraphics.EquipDetailFont, GearGraphics.StatDetailGrayBrush, 72f, 50f);
                /*g.DrawString(charStat.Level.ToString(), GearGraphics.ItemDetailFont, GearGraphics.StatDetailGrayBrush, 72f, 68f);
                g.DrawString(charStat.Exp + " (" + (charStat.Exp == -1 ? 0 : ((long)charStat.Exp * 100 / charStat.Exptnl)) + "%)",
                    GearGraphics.ItemDetailFont, GearGraphics.StatDetailGrayBrush, 72f, 86f);
                g.DrawString("1", GearGraphics.ItemDetailFont, GearGraphics.StatDetailGrayBrush, 72f, 104f);
                g.DrawString("0 (0%)", GearGraphics.ItemDetailFont, GearGraphics.StatDetailGrayBrush, 72f, 122f);*/
                g.DrawString(string.IsNullOrEmpty(this.character.Guild) ? "-" : this.character.Guild, GearGraphics.EquipDetailFont, GearGraphics.StatDetailGrayBrush, 72f, 68f);
                g.DrawString(charStat.Pop.ToString(), GearGraphics.EquipDetailFont, GearGraphics.StatDetailGrayBrush, 72f, 86f);
                int brushSign;

                double max, min;
                this.character.CalcAttack(out max, out min, out brushSign);
                g.DrawString(max == 0 ? "0" : Math.Round(min) + " ~ " + Math.Round(max), GearGraphics.EquipDetailFont, getDetailBrush(brushSign), 72f, 104f);
                g.DrawString(charStat.HP + " / " + charStat.MaxHP.GetSum(), GearGraphics.EquipDetailFont, GearGraphics.StatDetailGrayBrush, 72f, 122f);
                g.DrawString(charStat.MP + " / " + charStat.MaxMP.GetSum(), GearGraphics.EquipDetailFont, GearGraphics.StatDetailGrayBrush, 72f, 140f);

                g.DrawString(charStat.Ap.ToString().PadLeft(4), GearGraphics.EquipDetailFont, GearGraphics.StatDetailGrayBrush, 73f, 181f);
                g.DrawString(charStat.Strength.ToString(), GearGraphics.EquipDetailFont, GearGraphics.StatDetailGrayBrush, 72f, 210f);
                g.DrawString(charStat.Dexterity.ToString(), GearGraphics.EquipDetailFont, GearGraphics.StatDetailGrayBrush, 72f, 228f);
                g.DrawString(charStat.Intelligence.ToString(), GearGraphics.EquipDetailFont, GearGraphics.StatDetailGrayBrush, 72f, 246f);
                g.DrawString(charStat.Luck.ToString(), GearGraphics.EquipDetailFont, GearGraphics.StatDetailGrayBrush, 72f, 264f);
            }
            g.ResetTransform();
        }

        private void renderDetail(Graphics g)
        {
            Rectangle rect = this.DetailRect;
            g.TranslateTransform(rect.X, rect.Y);
            g.DrawImage(Resource.Stat_detail_backgrnd, 0, 1);
            g.DrawImage(Resource.Stat_detail_backgrnd2, 7, 8);
            g.DrawImage(Resource.Stat_detail_backgrnd3, 12, 13);
            g.DrawImage(Resource.Stat_detail_backgrnd4, 12, 222);

            g.DrawImage(Resource.Stat_detail_abilityTitle_normal_0, 12, 195);
            g.DrawImage(Resource.Stat_detail_metierLine_disabled_0, 15, 225);
            g.DrawImage(Resource.Stat_detail_metierLine_disabled_1, 15, 244);
            g.DrawImage(Resource.Stat_detail_metierLine_disabled_1, 15, 263);

            if (this.character != null)
            {
                CharacterStatus charStat = this.character.Status;
                //g.DrawString("0 ( 0% )", GearGraphics.GearDetailFont, getDetailBrush(0), 72f, 16f);
                //g.DrawString("0", GearGraphics.GearDetailFont, getDetailBrush(0), 72f, 34f);
                int brushSign;

                double max, min;
                this.character.CalcAttack(out max, out min, out brushSign);
                float y = 26f;
                g.DrawString(max == 0 ? "0" : Math.Round(min) + " ~ " + Math.Round(max), GearGraphics.EquipDetailFont, getDetailBrush(brushSign), 72f, (y += 18f));
                StringFormat format = new StringFormat();
                format.Alignment = StringAlignment.Far;
                g.DrawString(charStat.DamageRate.GetSum() + "%", GearGraphics.EquipDetailFont, charStat.DamageRate.BuffAdd > 0 ? Brushes.Red : GearGraphics.StatDetailGrayBrush, 104f, (y += 18f), format);
                g.DrawString(charStat.BossDamageRate.GetSum() + "%", GearGraphics.EquipDetailFont, charStat.BossDamageRate.BuffAdd > 0 ? Brushes.Red : GearGraphics.StatDetailGrayBrush, 200f, y, format);
                g.DrawString(charStat.FinalDamageRate.GetSum() + "%", GearGraphics.EquipDetailFont, charStat.FinalDamageRate.BuffAdd > 0 ? Brushes.Red : GearGraphics.StatDetailGrayBrush, 104f, (y += 18f), format);
                g.DrawString(charStat.IgnoreMobDefenceRate.GetSum() + "%", GearGraphics.EquipDetailFont, charStat.IgnoreMobDefenceRate.BuffAdd > 0 ? Brushes.Red : GearGraphics.StatDetailGrayBrush, 200f, y, format);
                g.DrawString(charStat.CriticalRate.GetSum() + "%", GearGraphics.EquipDetailFont, charStat.CriticalRate.BuffAdd > 0 ? Brushes.Red : GearGraphics.StatDetailGrayBrush, 104f, (y += 18f), format);
                g.DrawString(charStat.CriticalDamage.GetSum() + ".00%", GearGraphics.EquipDetailFont, charStat.CriticalDamage.BuffAdd > 0 ? Brushes.Red : GearGraphics.StatDetailGrayBrush, 72f, (y += 18f));
                g.DrawString(charStat.StatusResistance.GetSum().ToString(), GearGraphics.EquipDetailFont, charStat.StatusResistance.BuffAdd > 0 ? Brushes.Red : GearGraphics.StatDetailGrayBrush, 103f, (y += 18f), format);
                g.DrawString(charStat.KnockbackResistance.GetSum() + "%", GearGraphics.EquipDetailFont, charStat.KnockbackResistance.BuffAdd > 0 ? Brushes.Red : GearGraphics.StatDetailGrayBrush, 200f, y, format);
                g.DrawString(charStat.PDDamage.ToStringDetail(out brushSign), GearGraphics.EquipDetailFont, getDetailBrush(brushSign), 72f, (y += 18f));
                /*g.DrawString(charStat.MDDamage.ToStringDetail(out brushSign), GearGraphics.ItemDetailFont, getDetailBrush(brushSign), 72f, (y += 18f));
                g.DrawString(charStat.PAccurate.ToStringDetail(out brushSign), GearGraphics.ItemDetailFont, getDetailBrush(brushSign), 72f, (y += 18f));
                g.DrawString(charStat.MAccurate.ToStringDetail(out brushSign), GearGraphics.ItemDetailFont, getDetailBrush(brushSign), 72f, (y += 18f));
                g.DrawString(charStat.PEvasion.ToStringDetail(out brushSign), GearGraphics.ItemDetailFont, getDetailBrush(brushSign), 72f, (y += 18f));
                g.DrawString(charStat.MEvasion.ToStringDetail(out brushSign), GearGraphics.ItemDetailFont, getDetailBrush(brushSign), 72f, (y += 18f));*/
                g.DrawString(charStat.MoveSpeed.GetSum() + "%", GearGraphics.EquipDetailFont, getDetailBrush(0), 104f, (y += 18f), format);
                g.DrawString(charStat.Jump.GetSum() + "%", GearGraphics.EquipDetailFont, getDetailBrush(0), 200f, y, format);
                g.DrawString("0", GearGraphics.EquipDetailFont, getDetailBrush(0), 72f, 289f);
            }

            g.ResetTransform();
        }

        private void renderHyperStat(Graphics g)
        {
            Rectangle rect = this.HyperStatRect;
            g.TranslateTransform(rect.X, rect.Y);
            g.DrawImage(Resource.HyperStat_Window_backgrnd, 0, 0);
            g.DrawImage(Resource.HyperStat_Window_backgrnd2, 6, 7);
            g.DrawImage(Resource.HyperStat_Window_backgrnd3, 11, 41);

            StringFormat format = new StringFormat();
            format.Alignment = StringAlignment.Far;
            for (int i = 0; i < 12; i++)
            {
                g.DrawImage(hyperStatBitmapList[hyperStatScrollValue + i], 16, 43 + 18 * i);
                g.DrawString("0", GearGraphics.EquipDetailFont, getDetailBrush(0), 139f, 44f + 18f * i, format);
            }
            g.DrawString("0", GearGraphics.EquipDetailFont, getDetailBrush(0), 169f, 269f, format);

            g.ResetTransform();
        }

        private Brush getDetailBrush(int sign)
        {
            switch (sign)
            {
                case 1: return Brushes.Red;
                case -1: return Brushes.Blue;
                case 0:
                default: return GearGraphics.StatDetailGrayBrush;
            }

        }

        public TooltipHelp GetPairByPoint(Point point)
        {
            Point p = point;
            if (DetailVisible && DetailRect.Contains(p))
            {
                p = Point.Subtract(point, new Size(DetailRect.X, DetailRect.Y));
                return helpDetailList?.FirstOrDefault(t => t.Rect.Contains(p))?.Help;
            }
            p = Point.Subtract(point, new Size(baseOffset.X, baseOffset.Y));
            return helpList?.FirstOrDefault(t => t.Rect.Contains(p))?.Help;
        }

        public int GetSlotIndexByPoint(Point point)
        {
            Point p = point;
            p.Offset(-11, -41);
            if (p.X < 0 || p.Y < 0)
                return -1;
            int idx = p.Y / 18;
            if (new Rectangle(new Point(0, idx * 18), new Size(71, 16)).Contains(p))
                return idx;
            else
                return -1;
        }

        public int GetHyperStatIndexByPoint(Point point)
        {
            int slotIdx = GetSlotIndexByPoint(point);
            if (slotIdx != -1)
            {
                slotIdx += this.hyperStatScrollValue;
            }
            return slotIdx;
        }

        public Skill GetHyperStatByPoint(Point point)
        {
            if (HyperStatVisible && HyperStatRect.Contains(point) && hyperStatSkillList != null)
            {
                int hyperStatIdx = GetHyperStatIndexByPoint(Point.Subtract(point, new Size(HyperStatRect.X, HyperStatRect.Y)));
                if (hyperStatIdx > -1 && hyperStatIdx < this.hyperStatSkillList.Length)
                    return this.hyperStatSkillList[hyperStatIdx];
                else
                    return null;
            }
            return null;
        }

        private void btnClose_MouseClick(object sender, MouseEventArgs e)
        {
            this.Visible = false;
        }

        private void aCtrl_RefreshCall(object sender, EventArgs e)
        {
            this.waitForRefresh = true;
        }

        private void btnDetailOpen_MouseClick(object sender, MouseEventArgs e)
        {
            this.DetailVisible = true;
            this.waitForRefresh = true;
        }

        private void btnDetailClose_MouseClick(object sender, MouseEventArgs e)
        {
            this.DetailVisible = false;
            this.waitForRefresh = true;
        }

        private void btnHyperStatOpen_MouseClick(object sender, MouseEventArgs e)
        {
            this.HyperStatVisible = false;
            this.waitForRefresh = true;
        }

        private void btnHyperStatClose_MouseClick(object sender, MouseEventArgs e)
        {
            this.HyperStatVisible = true;
            this.waitForRefresh = true;
        }

        private void vScroll_ValueChanged(object sender, EventArgs e)
        {
            this.hyperStatScrollValue = this.vScroll.Value;
            this.waitForRefresh = true;
        }

        protected override void OnMouseMove(MouseEventArgs e)
        {
            MouseEventArgs childArgs = new MouseEventArgs(e.Button, e.Clicks, e.X - baseOffset.X, e.Y - baseOffset.Y, e.Delta);

            foreach (AControl ctrl in this.aControls)
            {
                ctrl.OnMouseMove(childArgs);
            }

            MouseEventArgs detailChildArgs = new MouseEventArgs(e.Button, e.Clicks, e.X - DetailRect.X, e.Y - DetailRect.Y, e.Delta);

            foreach (AControl ctrl in this.aDetailControls)
            {
                ctrl.OnMouseMove(detailChildArgs);
            }

            MouseEventArgs hyperStatChildArgs = new MouseEventArgs(e.Button, e.Clicks, e.X - HyperStatRect.X, e.Y - HyperStatRect.Y, e.Delta);

            foreach (AControl ctrl in this.aHyperStatControls)
            {
                ctrl.OnMouseMove(hyperStatChildArgs);
            }

            if (this.waitForRefresh)
            {
                this.Refresh();
                waitForRefresh = false;
            }

            base.OnMouseMove(e);

            object obj = GetPairByPoint(e.Location);
            if (obj == null)
                obj = GetHyperStatByPoint(e.Location);
            if (obj != null)
                this.OnObjectMouseMove(new ObjectMouseEventArgs(e, obj));
            else
                this.OnObjectMouseLeave(EventArgs.Empty);
        }

        protected override void OnMouseDown(MouseEventArgs e)
        {
            MouseEventArgs childArgs = new MouseEventArgs(e.Button, e.Clicks, e.X - baseOffset.X, e.Y - baseOffset.Y, e.Delta);

            foreach (AControl ctrl in this.aControls)
            {
                ctrl.OnMouseDown(childArgs);
            }

            MouseEventArgs detailChildArgs = new MouseEventArgs(e.Button, e.Clicks, e.X - DetailRect.X, e.Y - DetailRect.Y, e.Delta);

            foreach (AControl ctrl in this.aDetailControls)
            {
                ctrl.OnMouseDown(detailChildArgs);
            }

            MouseEventArgs hyperStatChildArgs = new MouseEventArgs(e.Button, e.Clicks, e.X - HyperStatRect.X, e.Y - HyperStatRect.Y, e.Delta);

            foreach (AControl ctrl in this.aHyperStatControls)
            {
                ctrl.OnMouseDown(hyperStatChildArgs);
            }

            if (this.waitForRefresh)
            {
                this.Refresh();
                waitForRefresh = false;
            }

            base.OnMouseDown(e);
        }

        protected override void OnMouseUp(MouseEventArgs e)
        {
            MouseEventArgs childArgs = new MouseEventArgs(e.Button, e.Clicks, e.X - baseOffset.X, e.Y - baseOffset.Y, e.Delta);

            foreach (AControl ctrl in this.aControls)
            {
                ctrl.OnMouseUp(childArgs);
            }

            MouseEventArgs detailChildArgs = new MouseEventArgs(e.Button, e.Clicks, e.X - DetailRect.X, e.Y - DetailRect.Y, e.Delta);

            foreach (AControl ctrl in this.aDetailControls)
            {
                ctrl.OnMouseUp(detailChildArgs);
            }

            MouseEventArgs hyperStatChildArgs = new MouseEventArgs(e.Button, e.Clicks, e.X - HyperStatRect.X, e.Y - HyperStatRect.Y, e.Delta);

            foreach (AControl ctrl in this.aHyperStatControls)
            {
                ctrl.OnMouseUp(hyperStatChildArgs);
            }

            if (this.waitForRefresh)
            {
                this.Refresh();
                waitForRefresh = false;
            }

            base.OnMouseUp(e);
        }

        protected override void OnMouseClick(MouseEventArgs e)
        {
            MouseEventArgs childArgs = new MouseEventArgs(e.Button, e.Clicks, e.X - baseOffset.X, e.Y - baseOffset.Y, e.Delta);

            foreach (AControl ctrl in this.aControls)
            {
                ctrl.OnMouseClick(childArgs);
            }

            MouseEventArgs detailChildArgs = new MouseEventArgs(e.Button, e.Clicks, e.X - DetailRect.X, e.Y - DetailRect.Y, e.Delta);

            foreach (AControl ctrl in this.aDetailControls)
            {
                ctrl.OnMouseClick(detailChildArgs);
            }

            MouseEventArgs hyperStatChildArgs = new MouseEventArgs(e.Button, e.Clicks, e.X - HyperStatRect.X, e.Y - HyperStatRect.Y, e.Delta);

            foreach (AControl ctrl in this.aHyperStatControls)
            {
                ctrl.OnMouseClick(hyperStatChildArgs);
            }

            if (this.waitForRefresh)
            {
                this.Refresh();
                waitForRefresh = false;
            }

            base.OnMouseClick(e);
        }

        protected override void OnMouseWheel(MouseEventArgs e)
        {
            MouseEventArgs childArgs = new MouseEventArgs(e.Button, e.Clicks, e.X - baseOffset.X, e.Y - baseOffset.Y, e.Delta);

            foreach (AControl ctrl in this.aControls)
            {
                ctrl.OnMouseWheel(childArgs);
            }

            MouseEventArgs detailChildArgs = new MouseEventArgs(e.Button, e.Clicks, e.X - DetailRect.X, e.Y - DetailRect.Y, e.Delta);

            foreach (AControl ctrl in this.aDetailControls)
            {
                ctrl.OnMouseWheel(detailChildArgs);
            }

            MouseEventArgs hyperStatChildArgs = new MouseEventArgs(e.Button, e.Clicks, e.X - HyperStatRect.X, e.Y - HyperStatRect.Y, e.Delta);

            foreach (AControl ctrl in this.aHyperStatControls)
            {
                ctrl.OnMouseWheel(hyperStatChildArgs);
            }

            if (this.waitForRefresh)
            {
                this.Refresh();
                waitForRefresh = false;
            }

            base.OnMouseWheel(e);
        }

        protected virtual void OnObjectMouseMove(ObjectMouseEventArgs e)
        {
            if (this.ObjectMouseMove != null)
                this.ObjectMouseMove(this, e);
        }

        private void InitializeComponent()
        {
            SuspendLayout();
            // 
            // AfrmStat
            // 
            AutoScaleMode = AutoScaleMode.None;
            ClientSize = new Size(300, 300);
            Font = new Font("Microsoft JhengHei UI", 9F, FontStyle.Regular, GraphicsUnit.Pixel);
            Location = new Point(0, 0);
            Name = "AfrmStat";
            ResumeLayout(false);
        }

        protected virtual void OnObjectMouseLeave(EventArgs e)
        {
            if (this.ObjectMouseLeave != null)
                this.ObjectMouseLeave(this, e);
        }

        public class TooltipHelpRect
        {
            public TooltipHelpRect(Rectangle rect, TooltipHelp pair)
            {
                this.rect = rect;
                this.help = pair;
            }

            private Rectangle rect;
            private TooltipHelp help;

            public Rectangle Rect
            {
                get { return rect; }
            }

            public TooltipHelp Help
            {
                get { return help; }
            }
        }
    }
}
```

`MapleNecrocer/CharaSimControl/AfrmStat.resx`:

```resx
<root>
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`MapleNecrocer/CharaSimControl/AfrmTooltip.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;
using System.Windows.Forms;
using WzComparerR2.Common;
using WzComparerR2.CharaSim;
using WzComparerR2.Controls;

namespace WzComparerR2.CharaSimControl
{

    public class AfrmTooltip : AlphaForm
    {

        public AfrmTooltip()
        {
            this.menu = new ContextMenuStrip();
            this.menu.Items.Add(new ToolStripMenuItem("Copy", null, tsmiCopy_Click));
            this.menu.Items.Add(new ToolStripMenuItem("Save", null, tsmiSave_Click));
            this.ContextMenuStrip = this.menu;

            this.Size = new Size(1, 1);
            this.HideOnHover = true;
            this.GearRender = new GearTooltipRender2();
            this.ItemRender = new ItemTooltipRender2();
            this.SkillRender = new SkillTooltipRender2();
            this.RecipeRender = new RecipeTooltipRender();
            this.MobRender = new MobTooltipRenderer();
            this.NpcRender = new NpcTooltipRenderer();
            this.HelpRender = new HelpTooltipRender();
            this.SetItemRender = new SetItemTooltipRender();
            this.SizeChanged += AfrmTooltip_SizeChanged;

            this.MouseClick += AfrmTooltip_MouseClick;

        }

        private object item;

        private ContextMenuStrip menu;
        private bool showMenu;
        private bool showID;

        public Object TargetItem
        {
            get { return item; }
            set { item = value; }
        }

        public StringLinker StringLinker { get; set; }
        public Character Character { get; set; }

        public GearTooltipRender2 GearRender { get; private set; }
        public ItemTooltipRender2 ItemRender { get; private set; }
        public SkillTooltipRender2 SkillRender { get; private set; }
        public RecipeTooltipRender RecipeRender { get; private set; }
        public MobTooltipRenderer MobRender { get; private set; }
        public NpcTooltipRenderer NpcRender { get; private set; }
        public HelpTooltipRender HelpRender { get; private set; }
        public SetItemTooltipRender SetItemRender { get; private set; }

        public string ImageFileName { get; set; }

        public bool ShowID
        {
            get { return this.showID; }
            set
            {
                this.showID = value;
                this.GearRender.ShowObjectID = value;
                this.ItemRender.ShowObjectID = value;
                this.SkillRender.ShowObjectID = value;
                this.RecipeRender.ShowObjectID = value;
            }
        }

        public bool ShowMenu
        {
            get { return showMenu; }
            set { showMenu = value; }
        }

        public override void Refresh()
        {
            this.PreRender();
            if (this.Bitmap != null)
            {
                this.SetBitmap(Bitmap);
                this.CaptionRectangle = new Rectangle(0, 0, Bitmap.Width, Bitmap.Height);
                base.Refresh();
            }
        }

        public void PreRender()
        {
            if (this.item == null)
                return;

            TooltipRender renderer;
            if (item is Item)
            {
                renderer = ItemRender;
                ItemRender.Item = this.item as Item;
            }
            else if (item is Gear)
            {
                renderer = GearRender;
                GearRender.Gear = this.TargetItem as Gear;

                if (false)
                {
                    Gear g = GearRender.Gear;
                    if (this.StringLinker.StringEqp.ContainsKey(g.ItemID))
                    {
                        this.StringLinker.StringEqp[g.ItemID].Name = "暴君之高卡文黑锅";
                        this.StringLinker.StringEqp[g.ItemID].Desc = @"""#c这个锅 我背了！#"" ————gaokawen";
                    }
                    g.Star = 25;
                    g.Grade = GearGrade.SS;
                    g.AdditionGrade = GearGrade.B;
                    g.Props[GearPropType.reqLevel] = 250;
                    g.Props[GearPropType.reqSTR] = 6;
                    g.Props[GearPropType.reqDEX] = 6;
                    g.Props[GearPropType.reqINT] = 6;
                    g.Props[GearPropType.reqLUK] = 6;
                    g.Props[GearPropType.reqPOP] = 666;
                    g.Props[GearPropType.level] = 1;
                    g.Props[GearPropType.reqJob] = 0;
                    g.Props[GearPropType.incPAD] = 6;
                    g.Props[GearPropType.incMAD] = 6;
                    g.Props[GearPropType.incPDD] = 666;
                    g.Props[GearPropType.incMDD] = 666;
                    g.Props[GearPropType.tuc] = 66;
                    g.Props[GearPropType.superiorEqp] = 1;
                    g.Props[GearPropType.tradeAvailable] = 2;
                    //g.Props[GearPropType.charismaEXP] = 88;
                    //g.Props[GearPropType.willEXP] = 88;
                    //g.Props[GearPropType.charmEXP] = 88;
                    g.Props[GearPropType.nActivatedSocket] = 1;
                    //g.Props[GearPropType.setItemID] = 135;
                    //g.Options[0] = Potential.LoadFromWz(60001, 3);
                    //g.Options[1] = Potential.LoadFromWz(60001, 3);
                    //g.Options[2] = Potential.LoadFromWz(60001, 3);
                    //g.AdditionalOptions[0] = Potential.LoadFromWz(32086, 10);
                    //g.AdditionalOptions[1] = Potential.LoadFromWz(32086, 10);
                    //g.AdditionalOptions[2] = Potential.LoadFromWz(32086, 10);
                }
            }
            else if (item is Skill)
            {
                renderer = SkillRender;
                SkillRender.Skill = this.item as Skill;
            }
            else if (item is Recipe)
            {
                renderer = RecipeRender;
                RecipeRender.Recipe = this.item as Recipe;
            }
            else if (item is Mob)
            {
                renderer = MobRender;
                MobRender.MobInfo = this.item as Mob;
            }
            else if (item is Npc)
            {
                renderer = NpcRender;
                NpcRender.NpcInfo = this.item as Npc;
            }
            else if (item is TooltipHelp)
            {
                renderer = HelpRender;
                HelpRender.Pair = this.item as TooltipHelp;
            }
            else if (item is SetItem)
            {
                renderer = SetItemRender;
                SetItemRender.SetItem = this.item as SetItem;
            }
            else
            {
                this.Bitmap = null;
                renderer = null;
                return;
            }
            renderer.StringLinker = StringLinker;
            this.Bitmap = renderer.Render();
        }

        void AfrmTooltip_MouseClick(object sender, System.Windows.Forms.MouseEventArgs e)
        {
            if (e.Button == MouseButtons.Right && this.showMenu)
            {
                this.menu.Show(this, e.Location);
            }
        }

        void tsmiCopy_Click(object sender, EventArgs e)
        {
            if (this.Bitmap != null)
            {
                using (System.IO.MemoryStream stream = new System.IO.MemoryStream())
                {
                    var dataObj = new DataObject();
                    dataObj.SetData(DataFormats.Bitmap, this.Bitmap);
                    Byte[] dibData = ConvertToDib(this.Bitmap);
                    stream.Write(dibData, 0, dibData.Length);
                    dataObj.SetData(DataFormats.Dib, stream);
                    Clipboard.SetDataObject(dataObj, true);
                }
            }
        }

        private Byte[] ConvertToDib(Image image) // https://stackoverflow.com/a/46424800
        {
            Byte[] bm32bData;
            Int32 width = image.Width;
            Int32 height = image.Height;
            // Ensure image is 32bppARGB by painting it on a new 32bppARGB image.
            using (Bitmap bm32b = new Bitmap(image.Width, image.Height, System.Drawing.Imaging.PixelFormat.Format32bppArgb))
            {
                using (Graphics gr = Graphics.FromImage(bm32b))
                    gr.DrawImage(image, new Rectangle(0, 0, bm32b.Width, bm32b.Height));
                // Bitmap format has its lines reversed.
                bm32b.RotateFlip(RotateFlipType.Rotate180FlipX);
                Int32 stride;
                bm32bData = GetImageData(bm32b, out stride);
            }
            // BITMAPINFOHEADER struct for DIB.
            Int32 hdrSize = 0x28;
            Byte[] fullImage = new Byte[hdrSize + 12 + bm32bData.Length];
            //Int32 biSize;
            WriteIntToByteArray(fullImage, 0x00, 4, true, (UInt32)hdrSize);
            //Int32 biWidth;
            WriteIntToByteArray(fullImage, 0x04, 4, true, (UInt32)width);
            //Int32 biHeight;
            WriteIntToByteArray(fullImage, 0x08, 4, true, (UInt32)height);
            //Int16 biPlanes;
            WriteIntToByteArray(fullImage, 0x0C, 2, true, 1);
            //Int16 biBitCount;
            WriteIntToByteArray(fullImage, 0x0E, 2, true, 32);
            //BITMAPCOMPRESSION biCompression = BITMAPCOMPRESSION.BITFIELDS;
            WriteIntToByteArray(fullImage, 0x10, 4, true, 3);
            //Int32 biSizeImage;
            WriteIntToByteArray(fullImage, 0x14, 4, true, (UInt32)bm32bData.Length);
            // These are all 0. Since .net clears new arrays, don't bother writing them.
            //Int32 biXPelsPerMeter = 0;
            //Int32 biYPelsPerMeter = 0;
            //Int32 biClrUsed = 0;
            //Int32 biClrImportant = 0;

            // The aforementioned "BITFIELDS": colour masks applied to the Int32 pixel value to get the R, G and B values.
            WriteIntToByteArray(fullImage, hdrSize + 0, 4, true, 0x00FF0000);
            WriteIntToByteArray(fullImage, hdrSize + 4, 4, true, 0x0000FF00);
            WriteIntToByteArray(fullImage, hdrSize + 8, 4, true, 0x000000FF);
            Array.Copy(bm32bData, 0, fullImage, hdrSize + 12, bm32bData.Length);
            return fullImage;
        }

        private Byte[] GetImageData(Bitmap sourceImage, out Int32 stride) // https://stackoverflow.com/a/43706643
        {
            System.Drawing.Imaging.BitmapData sourceData = sourceImage.LockBits(new Rectangle(0, 0, sourceImage.Width, sourceImage.Height), System.Drawing.Imaging.ImageLockMode.ReadOnly, sourceImage.PixelFormat);
            stride = sourceData.Stride;
            Byte[] data = new Byte[stride * sourceImage.Height];
            System.Runtime.InteropServices.Marshal.Copy(sourceData.Scan0, data, 0, data.Length);
            sourceImage.UnlockBits(sourceData);
            return data;
        }

        private void WriteIntToByteArray(Byte[] data, Int32 startIndex, Int32 bytes, Boolean littleEndian, UInt32 value) // https://stackoverflow.com/a/46424800
        {
            Int32 lastByte = bytes - 1;
            if (data.Length < startIndex + bytes)
                throw new ArgumentOutOfRangeException("startIndex", "Data array is too small to write a " + bytes + "-byte value at offset " + startIndex + ".");
            for (Int32 index = 0; index < bytes; index++)
            {
                Int32 offs = startIndex + (littleEndian ? index : lastByte - index);
                data[offs] = (Byte)(value >> (8 * index) & 0xFF);
            }
        }

        void tsmiSave_Click(object sender, EventArgs e)
        {
            if (this.Bitmap != null && this.item != null)
            {
                using (SaveFileDialog dlg = new SaveFileDialog())
                {
                    dlg.Filter = "PNG (*.png)|*.png|*.*|*.*";
                    dlg.FileName = this.ImageFileName;

                    if (dlg.ShowDialog() == DialogResult.OK)
                    {
                        this.Bitmap.Save(dlg.FileName, System.Drawing.Imaging.ImageFormat.Png);
                    }
                }
            }
        }

        private void InitializeComponent()
        {
            SuspendLayout();
            // 
            // AfrmTooltip
            // 
            AutoScaleMode = AutoScaleMode.None;
            ClientSize = new Size(300, 300);
            Font = new Font("Microsoft JhengHei UI", 9F, FontStyle.Regular, GraphicsUnit.Pixel);
            Location = new Point(0, 0);
            Name = "AfrmTooltip";
            ResumeLayout(false);
        }

        void AfrmTooltip_SizeChanged(object sender, EventArgs e)
        {
            if (this.Bitmap != null)
                this.SetClientSizeCore(this.Bitmap.Width, this.Bitmap.Height);
        }
    }
}

```

`MapleNecrocer/CharaSimControl/AfrmTooltip.resx`:

```resx
<root>
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`MapleNecrocer/CharaSimControl/ButtonState.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace WzComparerR2.CharaSimControl
{
    public enum ButtonState
    {
        Normal = 0,
        Pressed,
        MouseOver,
        Disabled
    }
}

```

`MapleNecrocer/CharaSimControl/CashPackageRender.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Text.RegularExpressions;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Windows.Forms;
using Resource = CharaSimResource.Resource;
using WzComparerR2.PluginBase;
using WzComparerR2.WzLib;
using WzComparerR2.Common;
using WzComparerR2.CharaSim;

namespace WzComparerR2.CharaSimControl
{
    public class CashPackageTooltipRender : TooltipRender
    {
        public CashPackageTooltipRender()
        {
        }

        public CashPackage CashPackage { get; set; }

        public override object TargetItem
        {
            get { return this.CashPackage; }
            set { this.CashPackage = value as CashPackage; }
        }

        public override Bitmap Render()
        {
            int picHeight;
            Bitmap originBmp = RenderCashPackage(out picHeight);
            Bitmap tooltip = new Bitmap(originBmp.Width, picHeight);
            Graphics g = Graphics.FromImage(tooltip);

            //绘制背景区域
            GearGraphics.DrawNewTooltipBack(g, 0, 0, tooltip.Width, tooltip.Height);

            //复制图像
            g.DrawImage(originBmp, 0, 0, new Rectangle(0, 0, tooltip.Width, picHeight), GraphicsUnit.Pixel);

            if (originBmp != null)
                originBmp.Dispose();

            if (this.ShowObjectID)
            {
                GearGraphics.DrawGearDetailNumber(g, 3, 3, CashPackage.ItemID.ToString("d8"), true);
            }

            g.Dispose();
            return tooltip;
        }

        private Bitmap RenderCashPackage(out int picH)
        {
            Bitmap cashBitmap = new Bitmap(260, DefaultPicHeight);
            Graphics g = Graphics.FromImage(cashBitmap);
            StringFormat format = new StringFormat();
            format.Alignment = StringAlignment.Center;

            int totalPrice = 0, totalOriginalPrice = 0;
            Commodity commodityPackage = new Commodity();
            if (CharaSimLoader.LoadedCommoditiesByItemId.ContainsKey(CashPackage.ItemID))
                commodityPackage = CharaSimLoader.LoadedCommoditiesByItemId[CashPackage.ItemID];

            int fullWidth = Math.Max(220, TextRenderer.MeasureText(g, CashPackage.name, GearGraphics.ItemNameFont2, new Size(int.MaxValue, int.MaxValue), TextFormatFlags.NoPrefix).Width + 12 * 2);
            int[] columnWidth = { CashPackage.SN.Count < 8 ? fullWidth : 220, 220, 220 };

            for (int i = 0; i < CashPackage.SN.Count; ++i)
            {
                Commodity commodity = CharaSimLoader.LoadedCommoditiesBySN[CashPackage.SN[i]];
                string name = null;

                StringResult sr = null;
                if (StringLinker != null)
                {
                    if (StringLinker.StringEqp.TryGetValue(commodity.ItemId, out sr))
                    {
                        name = sr.Name;
                    }
                    else if (StringLinker.StringItem.TryGetValue(commodity.ItemId, out sr))
                    {
                        name = sr.Name;
                    }
                    else
                    {
                        name = "(null)";
                    }
                }
                if (sr == null)
                {
                    name = "(null)";
                }

                int nameWidth = TextRenderer.MeasureText(g, name.Replace(Environment.NewLine, ""), GearGraphics.ItemDetailFont, new Size(int.MaxValue, int.MaxValue), TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix).Width;
                if (commodity.Bonus == 0)
                {
                    if (commodity.originalPrice > 0 && commodity.Price < commodity.originalPrice)
                        nameWidth += 55 + 31 + 6 + 8;
                    else
                        nameWidth += 55 + 8;
                }
                else
                    nameWidth += 55 + 38 + 6 + 8;

                if (CashPackage.SN.Count < 8)
                {
                    columnWidth[0] = Math.Max(columnWidth[0], nameWidth);
                }
                else if (CashPackage.SN.Count < 27)
                {
                    if (i < (CashPackage.SN.Count + 1) / 2)
                        columnWidth[0] = Math.Max(columnWidth[0], nameWidth);
                    else
                        columnWidth[1] = Math.Max(columnWidth[1], nameWidth);
                }
                else
                {
                    if (i < (CashPackage.SN.Count + 2) / 3)
                        columnWidth[0] = Math.Max(columnWidth[0], nameWidth);
                    else if (i < (2 * CashPackage.SN.Count + 2) / 3)
                        columnWidth[1] = Math.Max(columnWidth[1], nameWidth);
                    else
                        columnWidth[2] = Math.Max(columnWidth[2], nameWidth);
                }
            }

            if (CashPackage.SN.Count < 8)
                fullWidth = Math.Max(fullWidth, columnWidth[0]);
            else if (CashPackage.SN.Count < 27)
                fullWidth = Math.Max(fullWidth, columnWidth[0] + columnWidth[1] - 4);
            else
                fullWidth = Math.Max(fullWidth, columnWidth[0] + columnWidth[1] + columnWidth[2] - 8);

            if (fullWidth > 220)
            {
                //重构大小
                g.Dispose();
                cashBitmap.Dispose();

                cashBitmap = new Bitmap(fullWidth, DefaultPicHeight);
                g = Graphics.FromImage(cashBitmap);
            }

            picH = 10;
            TextRenderer.DrawText(g, CashPackage.name, GearGraphics.ItemNameFont2, new Point(cashBitmap.Width, picH), Color.White, TextFormatFlags.HorizontalCenter | TextFormatFlags.NoPrefix);
            picH += 14;
            if (commodityPackage.termStart > 0 || commodityPackage.termEnd != null)
            {
                string term = "";
                if (commodityPackage.termStart > 0)
                    //term += string.Format("{1:D2}/{2:D2}/{0:D2} {3:D2}:00 ", commodityPackage.termStart / 1000000, (commodityPackage.termStart / 10000) % 100, (commodityPackage.termStart / 100) % 100);
                    //term += string.Format("{1:D2}/{2}/{0} {3}:00:00", commodityPackage.termStart / 1000000, (commodityPackage.termStart / 10000) % 100, (commodityPackage.termStart / 100) % 100);
                term += string.Format("{1:D2}/{2}/{0} {3}:00:00", commodityPackage.termStart / 1000000, (commodityPackage.termStart / 10000) % 100, (commodityPackage.termStart / 100) % 100, commodityPackage.termStart % 100);
                //term += "-";
                if (commodityPackage.termStart > 0 && commodityPackage.termEnd != null)
                    term += "\n~";
                else
                    term += " ~";

                if (commodityPackage.termEnd != null)
                {
                    int termEndDate = Convert.ToInt32(commodityPackage.termEnd.Split('/')[0]);
                    int termEndTime = Convert.ToInt32(commodityPackage.termEnd.Split('/')[1]);
                    term += string.Format(" {1:D2}/{2}/{0} {3:D2}:{4:D2}:{5:D2} UTC", termEndDate / 10000, (termEndDate / 100) % 100, termEndDate % 100, termEndTime / 10000, (termEndTime / 100) % 100, termEndTime % 100);
                }
                //term += " >";

                picH += 8;
                //term += " >";
                TextRenderer.DrawText(g, term, GearGraphics.ItemDetailFont2, new Point(cashBitmap.Width, picH), ((SolidBrush)GearGraphics.OrangeBrush4).Color, TextFormatFlags.HorizontalCenter);
                picH += 16 * term.Split('\n').Length;
                //picH += 12; < --- commented because of line above, check!
            }
            if (commodityPackage.Limit > 0)
            {
                string limit = null;
                switch (commodityPackage.Limit)
                {
                    case 2:
                        //Max Purchase
                        break;
                    case 3:
                        limit = "Purchase Limit per Nexon ID";
                        break;
                    case 4:
                        limit = "Character Limited Sale";
                        break;
                    default:
                        limit = commodityPackage.Limit.ToString();
                        break;
                }
                if (limit != null && limit.Length > 0)
                {
                    TextRenderer.DrawText(g, "<" + limit + ">", GearGraphics.ItemDetailFont2, new Point(cashBitmap.Width, picH), ((SolidBrush)GearGraphics.OrangeBrush4).Color, TextFormatFlags.HorizontalCenter);
                    picH += 12;
                }
            }
            picH += 19;

            int right = cashBitmap.Width - 18;
            if (CashPackage.desc != null && CashPackage.desc.Length > 0)
                CashPackage.desc += "";
            CashPackage.desc += "\n";
            if (CashPackage.onlyCash == 0)
                GearGraphics.DrawString(g, CashPackage.desc + "", GearGraphics.ItemDetailFont2, 11, right, ref picH, 16);
            //GearGraphics.DrawString(g, CashPackage.desc + "\n#(Not applicable to free bonus items) Buy this with Nexon Cash and you can trade it with another user once if unused.", GearGraphics.ItemDetailFont2, 11, right, ref picH, 16);
            else
                GearGraphics.DrawString(g, CashPackage.desc + "\n#Can only be purchased with NX.#", GearGraphics.ItemDetailFont2, 11, right, ref picH, 16);

            bool hasLine = false;
            picH -= 0;//default is 4

            int picStartH = picH, picEndH = 0, columnLeft = 0, columnRight = columnWidth[0];

            for (int i = 0; i < CashPackage.SN.Count; ++i)
            {
                if (CashPackage.SN.Count >= 8 && CashPackage.SN.Count < 27)
                {
                    if (i == (CashPackage.SN.Count + 1) / 2)
                    {
                        hasLine = false;
                        picEndH = picH;
                        picH = picStartH;
                        columnLeft = columnWidth[0] - 2;
                        columnRight = columnWidth[0] + columnWidth[1] - 4;
                    }
                }
                else if (CashPackage.SN.Count >= 27)
                {
                    if (i == (CashPackage.SN.Count + 2) / 3)
                    {
                        hasLine = false;
                        picEndH = picH;
                        picH = picStartH;
                        columnLeft = columnWidth[0] - 2;
                        columnRight = columnWidth[0] + columnWidth[1] - 4;
                    }
                    else if (i == (2 * CashPackage.SN.Count + 2) / 3)
                    {
                        hasLine = false;
                        picEndH = picH;
                        picH = picStartH;
                        columnLeft = columnWidth[0] + columnWidth[1] - 6;
                        columnRight = columnWidth[0] + columnWidth[1] + columnWidth[2] - 8;
                    }
                }

                if (hasLine)
                {
                    g.DrawImage(Resource.CSDiscount_Line, columnLeft + 13, picH);
                    picH += 1;
                }

                Commodity commodity = CharaSimLoader.LoadedCommoditiesBySN[CashPackage.SN[i]];
                string name = null, info = null, time = null;
                BitmapOrigin IconRaw = new BitmapOrigin();

                StringResult sr = null;
                if (StringLinker != null)
                {
                    Wz_Node iconNode = null;
                    if (StringLinker.StringEqp.TryGetValue(commodity.ItemId, out sr))
                    {
                        name = sr.Name;
                        string[] fullPaths = sr.FullPath.Split('\\');
                        iconNode = PluginBase.PluginManager.FindWz(string.Format(@"Character\{0}\{1:D8}.img\info\iconRaw", String.Join("\\", new List<string>(fullPaths).GetRange(2, fullPaths.Length - 3).ToArray()), commodity.ItemId));
                    }
                    else if (StringLinker.StringItem.TryGetValue(commodity.ItemId, out sr))
                    {
                        name = sr.Name;
                        if (Regex.IsMatch(sr.FullPath, @"^(Cash|Consume|Etc|Ins).img\\.+$"))
                        {
                            string itemType = null;
                            if (Regex.IsMatch(sr.FullPath, @"^Cash.img\\.+$"))
                                itemType = "Cash";
                            else if (Regex.IsMatch(sr.FullPath, @"^Consume.img\\.+$"))
                                itemType = "Consume";
                            else if (Regex.IsMatch(sr.FullPath, @"^Etc.img\\.+$"))
                                itemType = "Etc";
                            else if (Regex.IsMatch(sr.FullPath, @"^Ins.img\\.+$"))
                                itemType = "Install";
                            iconNode = PluginBase.PluginManager.FindWz(string.Format(@"Item\{0}\{1:D4}.img\{2:D8}\info\iconRaw", itemType, commodity.ItemId / 10000, commodity.ItemId));
                        }
                        else if (Regex.IsMatch(sr.FullPath, @"^Pet.img\\.+$"))
                        {
                            iconNode = PluginBase.PluginManager.FindWz(string.Format(@"Item\Pet\{0:D7}.img\info\iconRaw", commodity.ItemId));
                        }
                    }
                    else
                    {
                        name = "(null)";
                    }
                    if (iconNode != null)
                    {
                        IconRaw = BitmapOrigin.CreateFromNode(iconNode, PluginBase.PluginManager.FindWz);
                    }
                }
                if (sr == null)
                {
                    name = "(null)";
                }

                if (commodity.Bonus == 0)
                {
                    if (commodity.Count > 1)
                        info += "(" + commodity.Count + ") ";//count (개)
                    if (commodity.originalPrice == 0)
                    {
                        foreach (var commodity2 in CharaSimLoader.LoadedCommoditiesBySN.Values)
                        {
                            if (commodity2.ItemId == commodity.ItemId && commodity2.Count == commodity.Count && commodity2.Period == commodity.Period && commodity2.gameWorld == commodity.gameWorld && commodity2.Price > commodity.originalPrice)
                                commodity.originalPrice = commodity2.Price;
                        }
                        if (commodity.originalPrice == commodity.Price)
                            commodity.originalPrice = 0;
                    }
                    if (commodity.originalPrice > 0 && commodity.Price < commodity.originalPrice)
                    {
                        info += commodity.originalPrice + " NX        "; // HERE is making space between original price and discounted price
                        totalOriginalPrice += commodity.originalPrice;
                    }
                    else
                    {
                        totalOriginalPrice += commodity.Price;
                    }
                    info += commodity.Price + " NX";
                    totalPrice += commodity.Price;
                }
                else
                {
                    info += "(" + commodity.Count + ") ";//count (개)
                    if (commodity.originalPrice > 0)
                    {
                        info += commodity.originalPrice + " NX";
                        totalOriginalPrice += commodity.originalPrice;
                    }
                    else
                    {
                        info += commodity.Price + " NX";
                        totalOriginalPrice += commodity.Price;
                    }
                }

                if (commodity.Period > 0)
                {
                    time = "AVAILABLE FOR " + commodity.Period + " DAYS.";
                }

                g.DrawImage(Resource.CSDiscount_backgrnd, columnLeft + 13, picH + 12);
                if (IconRaw.Bitmap != null)
                {
                    g.DrawImage(IconRaw.Bitmap, columnLeft + 13 + 1 - IconRaw.Origin.X, picH + 12 + 33 - IconRaw.Origin.Y);
                }
                if (time == null)
                {
                    TextRenderer.DrawText(g, name.TrimEnd(Environment.NewLine.ToCharArray()), GearGraphics.ItemDetailFont, new Point(columnLeft + 55, picH + 17), Color.White, TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix);
                    if (commodity.Bonus == 0)
                    {
                        TextRenderer.DrawText(g, info, GearGraphics.ItemDetailFont, new Point(columnLeft + 55, picH + 33), Color.White, TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix);
                        if (commodity.originalPrice > 0 && commodity.Price < commodity.originalPrice)
                        {
                            int width = TextRenderer.MeasureText(g, info.Substring(0, info.IndexOf("      ")), GearGraphics.ItemDetailFont, new Size(int.MaxValue, int.MaxValue), TextFormatFlags.NoPadding).Width;
                            g.DrawLine(Pens.White, columnLeft + 55, picH + 33 + 4, columnLeft + 55 + width + 1, picH + 33 + 4);
                            g.DrawImage(Resource.CSDiscount_arrow, columnLeft + 55 + width + 10, picH + 33 + 1);
                            DrawDiscountNum(g, "-" + (int)(100 - 100.0 * commodity.Price / commodity.originalPrice) + "%", columnRight - 40, picH + 16, StringAlignment.Near);
                        }
                    }
                    else
                    {
                        TextRenderer.DrawText(g, info, GearGraphics.ItemDetailFont, new Point(columnLeft + 55, picH + 33), Color.Red, TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix);
                        g.DrawImage(Resource.CSDiscount_bonus, columnRight - 47, picH + 29);
                    }
                }
                else
                {
                    TextRenderer.DrawText(g, name.Replace(Environment.NewLine, ""), GearGraphics.ItemDetailFont, new Point(columnLeft + 55, picH + 8), Color.White, TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix);
                    if (commodity.Bonus == 0)
                    {
                        TextRenderer.DrawText(g, info, GearGraphics.ItemDetailFont, new Point(columnLeft + 55, picH + 24), Color.White, TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix);
                        if (commodity.originalPrice > 0 && commodity.Price < commodity.originalPrice)
                        {
                            int width = TextRenderer.MeasureText(g, info.Substring(0, info.IndexOf("      ")), GearGraphics.ItemDetailFont, new Size(int.MaxValue, int.MaxValue), TextFormatFlags.NoPadding).Width;
                            g.DrawLine(Pens.White, columnLeft + 55, picH + 24 + 4, columnLeft + 55 + width + 1, picH + 24 + 4);
                            g.DrawImage(Resource.CSDiscount_arrow, columnLeft + 55 + width + 10, picH + 24 + 1);
                            DrawDiscountNum(g, "-" + (int)(100 - 100.0 * commodity.Price / commodity.originalPrice) + "%", columnRight - 40, picH + 7, StringAlignment.Near);
                        }
                    }
                    else
                    {
                        TextRenderer.DrawText(g, info, GearGraphics.ItemDetailFont, new Point(columnLeft + 55, picH + 24), Color.Red, TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix);
                        g.DrawImage(Resource.CSDiscount_bonus, columnRight - 47, picH + 20);
                    }
                    TextRenderer.DrawText(g, time, GearGraphics.ItemDetailFont, new Point(columnLeft + 55, picH + 39), Color.White, TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix);
                }
                picH += 57;

                hasLine = true;
            }

            if (picEndH != 0)
                picH = picEndH;

            g.DrawLine(Pens.White, 13, picH, cashBitmap.Width - 8, picH);
            picH += 11;

            g.DrawImage(Resource.CSDiscount_total, 9, picH + 1);
            if (totalOriginalPrice == totalPrice)
            {
                TextRenderer.DrawText(g, totalPrice + " NX", GearGraphics.ItemDetailFont, new Point(35, picH), Color.White, TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix);
            }
            else
            {
                TextRenderer.DrawText(g, totalOriginalPrice + " NX      " + totalPrice + " NX", GearGraphics.ItemDetailFont, new Point(35, picH), Color.White, TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix);
                TextRenderer.DrawText(g, totalOriginalPrice + " NX", GearGraphics.ItemDetailFont, new Point(35, picH), Color.Red, TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix);
                g.DrawImage(Resource.CSDiscount_arrow, 35 + TextRenderer.MeasureText(g, totalOriginalPrice + " NX", GearGraphics.ItemDetailFont, new Size(int.MaxValue, int.MaxValue), TextFormatFlags.NoPadding).Width + 5, picH + 1);
                DrawDiscountNum(g, "-" + (int)((100 - 100.0 * totalPrice / totalOriginalPrice)) + "%", cashBitmap.Width - 40, picH - 1, StringAlignment.Near);
            }
            picH += 11;

            picH += 13;
            format.Dispose();
            g.Dispose();
            return cashBitmap;
        }

        private void DrawDiscountNum(Graphics g, string numString, int x, int y, StringAlignment align)
        {
            if (g == null || numString == null)
                return;
            bool near = align == StringAlignment.Near;

            for (int i = 0; i < numString.Length; i++)
            {
                char c = near ? numString[i] : numString[numString.Length - i - 1];
                Image image = null;
                Point origin = Point.Empty;
                switch (c)
                {
                    case '-':
                        image = Resource.ResourceManager.GetObject("CSDiscount_w") as Image;
                        break;
                    case '%':
                        image = Resource.ResourceManager.GetObject("CSDiscount_e") as Image;
                        break;
                    default:
                        if ('0' <= c && c <= '9')
                        {
                            image = Resource.ResourceManager.GetObject("CSDiscount_" + c) as Image;
                        }
                        break;
                }

                if (image != null)
                {
                    if (near)
                    {
                        g.DrawImage(image, x + origin.X, y + origin.Y);
                        x += image.Width + origin.X;
                    }
                    else
                    {
                        x -= image.Width + origin.X;
                        g.DrawImage(image, x + origin.X, y + origin.Y);
                    }
                }
            }
        }
    }
}
```

`MapleNecrocer/CharaSimControl/CharaSimControlGroup.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Windows.Forms;
using System.Drawing;
using System.Text;
using WzComparerR2.Common;
using WzComparerR2.CharaSim;
using WzComparerR2.Controls;
using WzComparerR2.WzLib;

namespace WzComparerR2.CharaSimControl
{
    public class CharaSimControlGroup
    {
        public CharaSimControlGroup()
        {
            tooltip = new AfrmTooltip();
            tooltip.TopMost = true;
        }

        private AfrmTooltip tooltip;
        private AfrmItem frmItem;
        private AfrmStat frmStat;
        private AfrmEquip frmEquip;
        private Character character;
        private StringLinker stringLinker;

        public AfrmItem UIItem
        {
            get
            {
                if (frmItem == null)
                {
                    frmItem = new AfrmItem();
                    frmItem.KeyDown += new KeyEventHandler(afrm_KeyDown);
                    frmItem.MouseDown += new MouseEventHandler(frmItem_MouseDown);
                    frmItem.DragOver += new DragEventHandler(frmItem_DragOver);
                    frmItem.DragDrop += new DragEventHandler(frmItem_DragDrop);
                    frmItem.ItemMouseMove += new ItemMouseEventHandler(frmItem_ItemMouseMove);
                    frmItem.ItemMouseLeave += new EventHandler(frmItem_ItemMouseLeave);
                    frmItem.Character = this.character;
                }
                return frmItem;
            }
        }

        public AfrmStat UIStat
        {
            get
            {
                if (frmStat == null)
                {
                    frmStat = new AfrmStat();
                    frmStat.KeyDown += new KeyEventHandler(afrm_KeyDown);
                    frmStat.ObjectMouseMove += new ObjectMouseEventHandler(frmStat_ObjectMouseMove);
                    frmStat.ObjectMouseLeave += new EventHandler(frmStat_ObjectMouseLeave);
                    frmStat.Character = this.character;
                }
                return frmStat;
            }
        }

        public AfrmEquip UIEquip
        {
            get
            {
                if (frmEquip == null)
                {
                    frmEquip = new AfrmEquip();
                    frmEquip.KeyDown += new KeyEventHandler(afrm_KeyDown);
                    frmEquip.MouseDown += new MouseEventHandler(frmEquip_MouseDown);
                    frmEquip.DragOver += new DragEventHandler(frmEquip_DragOver);
                    frmEquip.DragDrop += new DragEventHandler(frmEquip_DragDrop);
                    frmEquip.Character = this.character;
                }
                return frmEquip;
            }
        }

        public Character Character
        {
            get { return character; }
            set
            {
                this.character = value;
                this.tooltip.Character = value;
                if (frmEquip != null)
                    this.frmEquip.Character = value;
                if (frmStat != null)
                    this.frmStat.Character = value;
                if (frmEquip != null)
                    this.frmEquip.Character = value;
            }
        }

        public StringLinker StringLinker
        {
            get { return stringLinker; }
            set
            {
                this.stringLinker = value;
                this.tooltip.StringLinker = value;
            }
        }

        private void afrm_KeyDown(object sender, KeyEventArgs e)
        {
            Form frm = sender as Form;
            if (frm == null)
                return;

            switch (e.KeyCode)
            {
                case Keys.Escape:
                    frm.Hide();
                    break;
                case Keys.F1:
                    break;
                case Keys.Up:
                    frm.Top -= 1;
                    break;
                case Keys.Down:
                    frm.Top += 1;
                    break;
                case Keys.Left:
                    frm.Left -= 1;
                    break;
                case Keys.Right:
                    frm.Left += 1;
                    break;
                case Keys.I:
                    frmItem.Visible = !frmItem.Visible;
                    break;
                case Keys.S:
                    frmStat.Visible = !frmStat.Visible;
                    break;
                case Keys.E:
                    frmEquip.Visible = !frmEquip.Visible;
                    break;
            }
        }

        private void frmItem_MouseDown(object sender, MouseEventArgs e)
        {
            ItemBase dragItem = frmItem.GetItemByPoint(e.Location);

            if (dragItem != null)
            {
                if (Control.ModifierKeys == Keys.Control)
                {
                    int originIdx = Array.IndexOf<ItemBase>(frmItem.SelectedTab.Items, dragItem);
                    if (originIdx > -1)
                    {
                        frmItem.SelectedTab.Items[originIdx] = null;
                        frmItem.Refresh();
                    }
                }
                else
                {
                    frmItem.DoDragDrop(dragItem, DragDropEffects.Move);
                    tooltip.Visible = false;
                }
            }
        }

        private ItemBase getDragDataItem(IDataObject data)
        {
            ItemBase dragItem;
            if (data != null
                && ((dragItem = data.GetData(typeof(Item)) as Item) != null
                || (dragItem = data.GetData(typeof(Gear)) as Gear) != null))
            {
                return dragItem;
            }
            return null;
        }

        private void frmItem_DragOver(object sender, DragEventArgs e)
        {
            ItemBase dragItem;
            int idx;
            if ((e.AllowedEffect & DragDropEffects.Move) != 0
                && (idx = frmItem.GetItemIndexByPoint(frmItem.PointToClient(new Point(e.X, e.Y)))) != -1
                && (dragItem = getDragDataItem(e.Data)) != null)
            {
                e.Effect = DragDropEffects.Move;
            }
            else
            {
                e.Effect = DragDropEffects.None;
            }
        }

        private void frmItem_DragDrop(object sender, DragEventArgs e)
        {
            if ((e.Effect & (DragDropEffects.Move)) == 0)
            {
                return;
            }

            ItemBase dragItem;
            int dropIdx, originIdx;
            if ((dragItem = getDragDataItem(e.Data)) == null
                || (originIdx = Array.IndexOf<ItemBase>(frmItem.SelectedTab.Items, dragItem)) == -1)
            {
                return;
            }
            dropIdx = frmItem.GetItemIndexByPoint(frmItem.PointToClient(new Point(e.X, e.Y)));
            if (dropIdx == -1) //移除装备
            {
                frmItem.SelectedTab.Items[originIdx] = null;
            }
            else if (originIdx != dropIdx)
            {
                frmItem.SelectedTab.Items[originIdx] = frmItem.SelectedTab.Items[dropIdx];
                frmItem.SelectedTab.Items[dropIdx] = dragItem;
            }
            else
            {
                return;
            }
            frmItem.Refresh();
        }

        private void frmItem_ItemMouseMove(object sender, ItemMouseEventArgs e)
        {
            if (e.Item == null)
            {
                tooltip.Visible = false;
                return;
            }
            if (e.Item != tooltip.TargetItem)
            {
                tooltip.TargetItem = e.Item;
                tooltip.Refresh();
            }
            Point pos = frmItem.PointToScreen(e.Location);
            pos.Offset(5, 5);
            tooltip.Location = pos;
            tooltip.Visible = true;
            tooltip.BringToFront();
        }

        private void frmItem_ItemMouseLeave(object sender, EventArgs e)
        {
            tooltip.Visible = false;
        }

        private void frmStat_ObjectMouseMove(object sender, ObjectMouseEventArgs e)
        {
            if (e.Obj is Skill && !this.stringLinker.HasValues)
            {
                this.stringLinker.Load(PluginBase.PluginManager.FindWz(Wz_Type.String).GetValueEx<Wz_File>(null), PluginBase.PluginManager.FindWz(Wz_Type.Item).GetValueEx<Wz_File>(null), PluginBase.PluginManager.FindWz(Wz_Type.Etc).GetValueEx<Wz_File>(null));
            }
            if (e.Obj == null)
            {
                tooltip.Visible = false;
                return;
            }
            if (e.Obj != tooltip.TargetItem)
            {
                tooltip.TargetItem = e.Obj;
                tooltip.Refresh();
            }
            Point pos = frmStat.PointToScreen(e.Location);
            pos.Offset(5, 5);
            tooltip.Location = pos;
            tooltip.Visible = true;
            tooltip.BringToFront();
        }

        private void frmStat_ObjectMouseLeave(object sender, EventArgs e)
        {
            tooltip.Visible = false;
        }

        private void frmEquip_MouseDown(object sender, MouseEventArgs e)
        {
            //throw new NotImplementedException();
        }

        private void frmEquip_DragOver(object sender, DragEventArgs e)
        {
            //throw new NotImplementedException();
        }

        private void frmEquip_DragDrop(object sender, DragEventArgs e)
        {
            //throw new NotImplementedException();
        }
    }
}

```

`MapleNecrocer/CharaSimControl/GearGraphics.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Drawing;
using System.Drawing.Imaging;
using System.Drawing.Drawing2D;
using System.Runtime.InteropServices;
using System.Windows.Forms;
using CharaSimResource;
using WzComparerR2.CharaSim;
using TR = System.Windows.Forms.TextRenderer;
using TextFormatFlags = System.Windows.Forms.TextFormatFlags;
using WzComparerR2.Text;
using WzComparerR2.WzLib;
using GraphicsExtension;
using DPIUtils;

namespace WzComparerR2.CharaSimControl
{
    /// <summary>
    /// 提供一系列的静态Graphics工具，用来绘制物品tooltip。
    /// </summary>
    public static class GearGraphics
    {
        static GearGraphics()
        {
            TBrushes = new Dictionary<string, TextureBrush>();
            TBrushes["n"] = new TextureBrush(Resource.UIToolTip_img_Item_Frame2_n, WrapMode.Tile);
            TBrushes["ne"] = new TextureBrush(Resource.UIToolTip_img_Item_Frame2_ne, WrapMode.Clamp);
            TBrushes["e"] = new TextureBrush(Resource.UIToolTip_img_Item_Frame2_e, WrapMode.Tile);
            TBrushes["se"] = new TextureBrush(Resource.UIToolTip_img_Item_Frame2_se, WrapMode.Clamp);
            TBrushes["s"] = new TextureBrush(Resource.UIToolTip_img_Item_Frame2_s, WrapMode.Tile);
            TBrushes["sw"] = new TextureBrush(Resource.UIToolTip_img_Item_Frame2_sw, WrapMode.Clamp);
            TBrushes["w"] = new TextureBrush(Resource.UIToolTip_img_Item_Frame2_w, WrapMode.Tile);
            TBrushes["nw"] = new TextureBrush(Resource.UIToolTip_img_Item_Frame2_nw, WrapMode.Clamp);
            TBrushes["c"] = new TextureBrush(Resource.UIToolTip_img_Item_Frame2_c, WrapMode.Tile);
            SetFontFamily("Arial");
        }

        public static readonly Dictionary<string, TextureBrush> TBrushes;
        public static readonly Font ItemNameFont = new Font("Arial", 12f, FontStyle.Bold, GraphicsUnit.Pixel);
        public static readonly Font ItemDetailFont = new Font("Arial", 12f, GraphicsUnit.Pixel);
        public static readonly Font EquipDetailFont = new Font("Arial", 11f, GraphicsUnit.Pixel);
        public static readonly Font EpicGearDetailFont = new Font("Arial", 11f, GraphicsUnit.Pixel);
        public static readonly Font TahomaFont = new Font("Tahoma", 12f, GraphicsUnit.Pixel);
        public static readonly Font SetItemPropFont = new Font("Arial", 11f, GraphicsUnit.Pixel);
        public static readonly Font ItemReqLevelFont = new Font("Arial", 11f, GraphicsUnit.Pixel);

        public static Font ItemNameFont2 { get; private set; }
        public static Font ItemDetailFont2 { get; private set; }
        public static Font EquipDetailFont2 { get; private set; }

        public static void SetFontFamily(string fontName)
        {
            if (ItemNameFont2 != null)
            {
                ItemNameFont2.Dispose();
                ItemNameFont2 = null;
            }
            ItemNameFont2 = new Font(fontName, 12f, FontStyle.Bold, GraphicsUnit.Pixel);

            if (ItemDetailFont2 != null)
            {
                ItemDetailFont2.Dispose();
                ItemDetailFont2 = null;
            }
            ItemDetailFont2 = new Font(fontName, 12f, GraphicsUnit.Pixel);

            if (EquipDetailFont2 != null)
            {
                EquipDetailFont2.Dispose();
                EquipDetailFont2 = null;
            }
            EquipDetailFont2 = new Font(fontName, 11f, GraphicsUnit.Pixel);
        }

        public static readonly Color GearBackColor = Color.FromArgb(204, 0, 51, 85);
        public static readonly Color EpicGearBackColor = Color.FromArgb(170, 68, 0, 0);
        public static readonly Color GearIconBackColor = Color.FromArgb(238, 187, 204, 221);
        public static readonly Color EpicGearIconBackColor = Color.FromArgb(221, 204, 187, 187);

        public static readonly Brush GearBackBrush = new SolidBrush(GearBackColor);
        public static readonly Brush EpicGearBackBrush = new SolidBrush(EpicGearBackColor);
        public static readonly Pen GearBackPen = new Pen(GearBackColor);
        public static readonly Pen EpicGearBackPen = new Pen(EpicGearBackColor);
        public static readonly Brush GearIconBackBrush = new SolidBrush(GearIconBackColor);
        public static readonly Brush GearIconBackBrush2 = new SolidBrush(Color.FromArgb(187, 238, 238, 238));
        public static readonly Brush EpicGearIconBackBrush = new SolidBrush(EpicGearIconBackColor);
        public static readonly Brush StatDetailGrayBrush = new SolidBrush(Color.FromArgb(85, 85, 85));

        public static readonly Color OrangeBrushColor = Color.FromArgb(255, 153, 0);
        /// <summary>
        /// 表示物品说明中带有#c标识的橙色字体画刷。
        /// </summary>
        public static readonly Brush OrangeBrush = new SolidBrush(OrangeBrushColor);
        /// <summary>
        /// 表示物品附加属性中橙色字体画刷。
        /// </summary>
        public static readonly Brush OrangeBrush2 = new SolidBrush(Color.FromArgb(255, 170, 0));
        /// <summary>
        /// 表示装备职业额外说明中使用的橙黄色画刷。
        /// </summary>
        public static readonly Brush OrangeBrush3 = new SolidBrush(Color.FromArgb(255, 204, 0));
        public static readonly Brush OrangeBrush4 = new SolidBrush(Color.FromArgb(255, 136, 17));
        /// <summary>
        /// 表示装备属性额外说明中使用的绿色画刷。
        /// </summary>
        public static readonly Brush GreenBrush2 = new SolidBrush(Color.FromArgb(204, 255, 0));
        public static readonly Color GrayColor2 = Color.FromArgb(153, 153, 153);
        /// <summary>
        /// 表示用于绘制“攻击力提升”文字的灰色画刷。
        /// </summary>
        public static readonly Brush GrayBrush2 = new SolidBrush(GrayColor2);
        /// <summary>
        /// 表示套装名字的绿色画刷。
        /// </summary>
        public static readonly Brush SetItemNameBrush = new SolidBrush(Color.FromArgb(119, 255, 0));
        /// <summary>
        /// 表示套装属性不可用的灰色画刷。
        /// </summary>
        public static readonly Brush SetItemGrayBrush = new SolidBrush(Color.FromArgb(119, 136, 153));
        /// <summary>
        /// 表示装备tooltip中金锤子描述文字的颜色画刷。
        /// </summary>
        public static readonly Brush GoldHammerBrush = new SolidBrush(Color.FromArgb(255, 238, 204));
        /// <summary>
        /// 表示灰色品质的装备名字画刷，额外属性小于0。
        /// </summary>
        public static readonly Brush GearNameBrushA = new SolidBrush(Color.FromArgb(187, 187, 187));
        /// <summary>
        /// 表示白色品质的装备名字画刷，额外属性为0~5。
        /// </summary>
        public static readonly Brush GearNameBrushB = new SolidBrush(Color.FromArgb(255, 255, 255));
        /// <summary>
        /// 表示橙色品质的装备名字画刷，额外属性为0~5，并且已经附加卷轴。
        /// </summary>
        public static readonly Brush GearNameBrushC = new SolidBrush(Color.FromArgb(255, 170, 0));
        private static Color gearBlueColor = Color.FromArgb(102, 255, 255);
        /// <summary>
        /// 表示蓝色品质的装备名字画刷，额外属性为6~22。
        /// </summary>
        public static readonly Brush GearNameBrushD = new SolidBrush(gearBlueColor);
        private static Color gearPurpleColor = Color.FromArgb(153, 102, 255);
        /// <summary>
        /// 表示紫色品质的装备名字画刷，额外属性为23~39。
        /// </summary>
        public static readonly Brush GearNameBrushE = new SolidBrush(gearPurpleColor);
        private static Color gearGoldColor = Color.FromArgb(255, 205, 0);
        /// <summary>
        /// 表示金色品质的装备名字画刷，额外属性为40~54。
        /// </summary>
        public static readonly Brush GearNameBrushF = new SolidBrush(gearGoldColor);
        private static Color gearGreenColor = Color.FromArgb(204, 255, 0);
        /// <summary>
        /// 表示绿色品质的装备名字画刷，额外属性为55~69。
        /// </summary>
        public static readonly Brush GearNameBrushG = new SolidBrush(gearGreenColor);
        /// <summary>
        /// 表示红色品质的装备名字画刷，额外属性为70以上。
        /// </summary>
        public static readonly Brush GearNameBrushH = new SolidBrush(Color.FromArgb(255, 0, 102));
        public static readonly Brush BlueBrush = new SolidBrush(Color.FromArgb(0, 204, 255));

        public static readonly Color gearCyanColor = Color.FromArgb(102, 255, 255);

        /// <summary>
        /// 表示装备属性变化的青色画刷。
        /// </summary>
        public static readonly Brush GearPropChangeBrush = new SolidBrush(gearCyanColor);
        public static readonly Color skillYellowColor = Color.FromArgb(244, 244, 68);
        public static readonly Color itemPinkColor = Color.FromArgb(255, 102, 204);
        public static readonly Color itemPurpleColor = Color.FromArgb(187, 119, 255);

        public static Brush GetGearNameBrush(int diff, bool up, bool cash = false, bool petEquip = false)
        {
            if (cash && !petEquip)
                return GearNameBrushB;
            if (diff < 0)
                return GearNameBrushA;
            if (diff < 6 || petEquip)
            {
                if (!up)
                    return GearNameBrushB;
                else
                    return GearNameBrushC;
            }
            if (diff < 23)
                return GearNameBrushD;
            if (diff < 40)
                return GearNameBrushE;
            if (diff < 55)
                return GearNameBrushF;
            if (diff < 70)
                return GearNameBrushG;
            return GearNameBrushH;
        }

        public static readonly Pen GearItemBorderPenC = new Pen(Color.FromArgb(255, 0, 102));
        public static readonly Pen GearItemBorderPenB = new Pen(gearBlueColor);
        public static readonly Pen GearItemBorderPenA = new Pen(gearPurpleColor);
        public static readonly Pen GearItemBorderPenS = new Pen(gearGoldColor);
        public static readonly Pen GearItemBorderPenSS = new Pen(gearGreenColor);
        public static Pen GetGearItemBorderPen(GearGrade grade)
        {
            switch (grade)
            {
                case GearGrade.B:
                    return GearItemBorderPenB;
                case GearGrade.A:
                    return GearItemBorderPenA;
                case GearGrade.S:
                    return GearItemBorderPenS;
                case GearGrade.SS:
                    return GearItemBorderPenSS;
                default:
                    return null;
            }
        }

        public static Brush GetPotentialTextBrush(GearGrade grade)
        {
            switch (grade)
            {
                default:
                case GearGrade.B: return GearPropChangeBrush;
                case GearGrade.A: return GearNameBrushE;
                case GearGrade.S: return GearNameBrushF;
                case GearGrade.SS: return GreenBrush2;
            }
        }

        /// <summary>
        /// 在指定区域绘制包含宏代码的字符串。
        /// </summary>
        /// <param Name="g">绘图所关联的graphics。</param>
        /// <param Name="s">要绘制的string。</param>
        /// <param Name="font">要绘制string的字体。</param>
        /// <param Name="x">起始的x坐标。</param>
        /// <param Name="X1">每行终止的x坐标。</param>
        /// <param Name="y">起始行的y坐标。</param>
        public static void DrawString(Graphics g, string s, Font font, int x, int x1, ref int y, int height, Color? orangeColor = null, Color? textColor = null)
        {
            if (s == null)
                return;

            using (var r = new FormattedTextRenderer())
            {
                if (HasNonASCIIChars(s))
                {
                    r.WordWrapEnabled = false;
                }
                else
                {
                    r.WordWrapEnabled = true;
                }
                r.UseGDIRenderer = true;
                r.DrawString(g, s, font, x, x1, ref y, height, orangeColor, textColor);
            }
        }

        public static void DrawPlainText(Graphics g, string s, Font font, Color color, int x, int x1, ref int y, int height)
        {
            if (s == null)
                return;

            using (var r = new FormattedTextRenderer())
            {
                if (HasNonASCIIChars(s))
                {
                    r.WordWrapEnabled = false;
                }
                else
                {
                    r.WordWrapEnabled = true;
                }
                r.UseGDIRenderer = true;
                r.DrawPlainText(g, s, font, color, x, x1, ref y, height);
            }
        }

        public static Bitmap EnlargeBitmap(Bitmap bitmap)
        { 
            BitmapData data = bitmap.LockBits(new Rectangle(0, 0, bitmap.Width, bitmap.Height), System.Drawing.Imaging.ImageLockMode.ReadOnly, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
            IntPtr p = data.Scan0;
            byte[] origin = new byte[bitmap.Width * bitmap.Height * 4];
            Marshal.Copy(p, origin, 0, origin.Length);
            bitmap.UnlockBits(data);
            byte[] newByte = new byte[origin.Length * 4];
            byte[] buffer = new byte[4];
            for (int i = 0; i < bitmap.Height; i++)
            {
                for (int j = 0; j < bitmap.Width; j++)
                {
                    Array.Copy(origin, getOffset(j, i, bitmap.Width), buffer, 0, 4);
                    Array.Copy(buffer, 0, newByte, getOffset(2 * j, 2 * i, bitmap.Width * 2), 4);
                    Array.Copy(buffer, 0, newByte, getOffset(2 * j + 1, 2 * i, bitmap.Width * 2), 4);
                }
                Array.Copy(newByte, getOffset(0, 2 * i, bitmap.Width * 2), newByte, getOffset(0, 2 * i + 1, bitmap.Width * 2), bitmap.Width * 8);
            }
            Bitmap newBitmap = new Bitmap(bitmap.Width * 2, bitmap.Height * 2);
            data = newBitmap.LockBits(new Rectangle(0, 0, newBitmap.Width, newBitmap.Height), ImageLockMode.WriteOnly, PixelFormat.Format32bppArgb);
            Marshal.Copy(newByte, 0, data.Scan0, newByte.Length);
            newBitmap.UnlockBits(data);
            return newBitmap;
        }

        public static Bitmap EnlargeBitmap2(Bitmap bitmap)
        {
            BitmapData data = bitmap.LockBits(new Rectangle(0, 0, bitmap.Width, bitmap.Height), System.Drawing.Imaging.ImageLockMode.ReadOnly, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
            IntPtr p = data.Scan0;
            byte[] origin = new byte[bitmap.Width * bitmap.Height * 4];
            Marshal.Copy(p, origin, 0, origin.Length);
            bitmap.UnlockBits(data);
            byte[] newByte = new byte[origin.Length * 4];
            byte[] buffer = new byte[4];
            for (int i = 0; i < bitmap.Height; i++)
            {
                for (int j = 0; j < bitmap.Width; j++)
                {
                    Array.Copy(origin, getOffset(j, i, bitmap.Width), buffer, 0, 4);
                    Array.Copy(buffer, 0, newByte, getOffset(2 * j, 2 * i, bitmap.Width * 2), 4);
                    Array.Copy(buffer, 0, newByte, getOffset(2 * j + 1, 2 * i, bitmap.Width * 2), 4);
                }
                Array.Copy(newByte, getOffset(0, 2 * i, bitmap.Width * 2), newByte, getOffset(0, 2 * i + 1, bitmap.Width * 2), bitmap.Width * 8);
            }
            Bitmap newBitmap = new Bitmap(bitmap.Width * 2, bitmap.Height * 2);
            data = newBitmap.LockBits(new Rectangle(0, 0, newBitmap.Width, newBitmap.Height), ImageLockMode.WriteOnly, PixelFormat.Format32bppArgb);
            Marshal.Copy(newByte, 0, data.Scan0, newByte.Length);
            newBitmap.UnlockBits(data);
            newBitmap.SetResolution(DPIUtil.dpiX*1.2f,DPIUtil.dpiY*1.2f);
            return newBitmap;
        }
        private static int getOffset(int x, int y, int width, int unit = 4)
        {
            return (y * width + x) * unit;
        }

        public static Point[] GetBorderPath(int dx, int width, int height)
        {
            List<Point> pointList = new List<Point>(13);
            pointList.Add(new Point(dx + 1, 0));
            pointList.Add(new Point(dx + 1, 1));
            pointList.Add(new Point(dx + 0, 1));
            pointList.Add(new Point(dx + 0, height - 2));
            pointList.Add(new Point(dx + 1, height - 2));
            pointList.Add(new Point(dx + 1, height - 1));
            pointList.Add(new Point(dx + width - 2, height - 1));
            pointList.Add(new Point(dx + width - 2, height - 2));
            pointList.Add(new Point(dx + width - 1, height - 2));
            pointList.Add(new Point(dx + width - 1, 1));
            pointList.Add(new Point(dx + width - 2, 1));
            pointList.Add(new Point(dx + width - 2, 0));
            pointList.Add(new Point(dx + 1, 0));
            return pointList.ToArray();
        }

        public static Point[] GetIconBorderPath(int x, int y)
        {
            Point[] pointList = new Point[5];
            pointList[0] = new Point(x + 32, y + 31);
            pointList[1] = new Point(x + 32, y);
            pointList[2] = new Point(x, y);
            pointList[3] = new Point(x, y + 32);
            pointList[4] = new Point(x + 31, y + 32);
            return pointList;
        }

        public static void DrawGearDetailNumber(Graphics g, int x, int y, string num, bool can)
        {
            Bitmap bitmap;
            for (int i = 0; i < num.Length; i++)
            {
                switch (num[i])
                {
                    case '0':
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                    case '8':
                    case '9':
                        string resourceName = (can ? "ToolTip_Equip_Can_" : "ToolTip_Equip_Cannot_") + num[i];
                        bitmap = (Bitmap)Resource.ResourceManager.GetObject(resourceName);
                        g.DrawImage2(bitmap, x, y);
                        x += bitmap.Width + 1;
                        break;
                    case '-':
                        bitmap = can ? Resource.ToolTip_Equip_Can_none : Resource.ToolTip_Equip_Cannot_none;
                        g.DrawImage2(bitmap, x, y + 3);
                        x += bitmap.Width + 1;
                        break;
                    case '%':
                        bitmap = can ? Resource.ToolTip_Equip_Can_percent : Resource.ToolTip_Equip_Cannot_percent;
                        g.DrawImage2(bitmap, x + 1, y);
                        x += bitmap.Width + 2;
                        break;
                }
            }
        }

        public static void DrawGearGrowthNumber(Graphics g, int x, int y, string num, bool can)
        {
            Bitmap bitmap;
            for (int i = 0; i < num.Length; i++)
            {
                switch (num[i])
                {
                    case '0':
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                    case '8':
                    case '9':
                        string resourceName = (can ? "ToolTip_Equip_GrowthEnabled_" : "ToolTip_Equip_Cannot_") + num[i];
                        bitmap = (Bitmap)Resource.ResourceManager.GetObject(resourceName);
                        g.DrawImage2(bitmap, x, y);
                        x += bitmap.Width + 1;
                        break;
                    case '-':
                        bitmap = can ? Resource.ToolTip_Equip_GrowthDisabled_none : Resource.ToolTip_Equip_GrowthDisabled_none;
                        g.DrawImage2(bitmap, x, y);
                        x += bitmap.Width + 1;
                        break;
                    case '%':
                        bitmap = can ? Resource.ToolTip_Equip_GrowthEnabled_percent : Resource.ToolTip_Equip_GrowthEnabled_percent;
                        g.DrawImage2(bitmap, x + 7, y - 4);
                        x += bitmap.Width + 1;
                        break;
                    case 'm':
                        bitmap = can ? Resource.ToolTip_Equip_GrowthEnabled_max : Resource.ToolTip_Equip_GrowthEnabled_max;
                        g.DrawImage2(bitmap, x, y);
                        x += bitmap.Width + 1;
                        break;
                }
            }
        }

        public static void DrawNewTooltipBack(Graphics g, int x, int y, int width, int height)
        {
            Dictionary<string, TextureBrush> res = TBrushes;
            //测算准线
            int[] guideX = new int[4] { 0, res["w"].Image.Width, width - res["e"].Image.Width, width };
            int[] guideY = new int[4] { 0, res["n"].Image.Height, height - res["s"].Image.Height, height };
            for (int i = 0; i < guideX.Length; i++) guideX[i] += x;
            for (int i = 0; i < guideY.Length; i++) guideY[i] += y;
            //绘制四角
            FillRect(g, res["nw"], guideX, guideY, 0, 0, 1, 1);
            FillRect(g, res["ne"], guideX, guideY, 2, 0, 3, 1);
            FillRect(g, res["sw"], guideX, guideY, 0, 2, 1, 3);
            FillRect(g, res["se"], guideX, guideY, 2, 2, 3, 3);
            //填充上下区域
            if (guideX[2] > guideX[1])
            {
                FillRect(g, res["n"], guideX, guideY, 1, 0, 2, 1);
                FillRect(g, res["s"], guideX, guideY, 1, 2, 2, 3);
            }
            //填充左右区域
            if (guideY[2] > guideY[1])
            {
                FillRect(g, res["w"], guideX, guideY, 0, 1, 1, 2);
                FillRect(g, res["e"], guideX, guideY, 2, 1, 3, 2);
            }
            //填充中心
            if (guideX[2] > guideX[1] && guideY[2] > guideY[1])
            {
                FillRect(g, res["c"], guideX, guideY, 1, 1, 2, 2);
            }
        }

        private static void FillRect(Graphics g, TextureBrush brush, int[] guideX, int[] guideY, int x0, int y0, int x1, int y1)
        {
            brush.ResetTransform();
            brush.TranslateTransform(guideX[x0], guideY[y0]);
            g.FillRectangle(brush, guideX[x0], guideY[y0], guideX[x1] - guideX[x0], guideY[y1] - guideY[y0]);
        }

        public static void DrawNameTag(Graphics g, Wz_Node resNode, string tagName, int picW, ref int picH)
        {
            if (g == null || resNode == null)
                return;

            //加载资源和文本颜色
            var wce = new[] { "w", "c", "e" }.Select(n =>
            {
                var node = resNode.FindNodeByPath(n);
                if (node == null)
                {
                    return new BitmapOrigin();
                }
                return BitmapOrigin.CreateFromNode(node, PluginBase.PluginManager.FindWz);
            }).ToArray();

            Color color = Color.FromArgb(resNode.FindNodeByPath("clr").GetValueEx(-1));

            //测试y轴大小
            int offsetY = wce.Min(bmp => bmp.OpOrigin.Y);
            int height = wce.Max(bmp => bmp.Rectangle.Bottom);

            //测试宽度
            var font = GearGraphics.ItemDetailFont2;
            var fmt = StringFormat.GenericTypographic;
            //int width = string.IsNullOrEmpty(tagName) ? 0 : (int)Math.Ceiling(g.MeasureString(tagName, font, 261, fmt).Width);
            int width = string.IsNullOrEmpty(tagName) ? 0 : TextRenderer.MeasureText(g, tagName, font, new Size(int.MaxValue, int.MaxValue), TextFormatFlags.NoPadding).Width;
            if (wce[1].Bitmap != null)
            {
                width = (int)Math.Ceiling(1.0 * width / wce[1].Bitmap.Width) * wce[1].Bitmap.Width;
            }
            int left = picW / 2 - width / 2;
            int right = left + width;

            //开始绘制背景
            picH -= offsetY;
            if (wce[0].Bitmap != null)
            {
                g.DrawImage2(wce[0].Bitmap, left - wce[0].Origin.X, picH - wce[0].Origin.Y);
            }
            if (wce[1].Bitmap != null) //不用拉伸 用纹理平铺 看运气
            {
                var brush = new TextureBrush(wce[1].Bitmap);
                Rectangle rect = new Rectangle(left, picH - wce[1].Origin.Y, right - left, brush.Image.Height);
                brush.TranslateTransform(rect.X, rect.Y);
                g.FillRectangle(brush, rect);
                brush.Dispose();
            }
            if (wce[2].Bitmap != null)
            {
                g.DrawImage2(wce[2].Bitmap, right - wce[2].Origin.X, picH - wce[2].Origin.Y);
            }

            //绘制文字
            if (!string.IsNullOrEmpty(tagName))
            {
                var brush = new SolidBrush(color);
                //g.DrawString(tagName, font, brush, left, picH, fmt);
                g.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAliasGridFit;
                //TextRenderer.DrawText(g, tagName, font, new Point(left, picH - 2), color, TextFormatFlags.NoPadding);2 juni
                TextRenderer.DrawText(g, tagName, font, new Rectangle(left, picH, right - left, int.MaxValue), color, TextFormatFlags.HorizontalCenter | TextFormatFlags.NoPadding);
                //TextRenderer.DrawText(g, tagName, font, new Rectangle(left, picH, right - left, int.MaxValue), color, TextFormatFlags.NoPadding);
                g.TextRenderingHint = System.Drawing.Text.TextRenderingHint.ClearTypeGridFit;
                brush.Dispose();
            }

            picH += height;
        }

        [DllImport("user32.dll")]
        private static extern IntPtr SendMessage(IntPtr hwnd, UInt32 wMsg, IntPtr wParam, IntPtr lParam);
        private const int WM_SETREDRAW = 0xB;

        public static void SetRedraw(System.Windows.Forms.Control control, bool enable)
        {
            if (control != null)
            {
                SendMessage(control.Handle, WM_SETREDRAW, new IntPtr(enable ? 1 : 0), IntPtr.Zero);
            }
        }

        private class FormattedTextRenderer : WzComparerR2.Text.TextRenderer<Font>, IDisposable
        {
            public FormattedTextRenderer()
            {
                fmt = (StringFormat)StringFormat.GenericTypographic.Clone();
            }

            public bool UseGDIRenderer { get; set; }

            const int MAX_RANGES = 32;
            StringFormat fmt;

            Graphics g;
            RectangleF infinityRect;
            int drawX;
            Color defaultColor;
            Color orangeColor;

            public void DrawString(Graphics g, string s, Font font, int x, int x1, ref int y, int height, Color? orangeColor = null, Color? textColor = null)
            {
                //初始化环境
                this.g = g;
                this.drawX = x;
                this.defaultColor = textColor ?? Color.White;
                if (orangeColor != null)
                {
                    this.orangeColor = (Color)orangeColor;
                }
                else
                {
                    this.orangeColor = GearGraphics.OrangeBrushColor;
                }
                float fontLineHeight = GetFontLineHeight(font);
                this.infinityRect = new RectangleF(0, 0, ushort.MaxValue, fontLineHeight);

                base.DrawFormatString(s, font, x1 - x, ref y, height);
            }

            public void DrawPlainText(Graphics g, string s, Font font, Color color, int x, int x1, ref int y, int height)
            {
                //初始化环境
                this.g = g;
                this.drawX = x;
                this.defaultColor = color;
                float fontLineHeight = GetFontLineHeight(font);
                this.infinityRect = new RectangleF(0, 0, ushort.MaxValue, fontLineHeight);

                //base.DrawPlainText(s, font, x1 - x, ref y, height);
                if (TextRenderer.MeasureText(g, s, font, new Size(int.MaxValue, int.MaxValue), TextFormatFlags.NoPadding).Width <= x1 - x)
                {
                    TextRenderer.DrawText(g, s, font, new Point(x, y), color, TextFormatFlags.NoPadding);
                    y += height;
                }
                else
                {
                    base.DrawPlainText(s, font, x1 - x, ref y, height);
                }
            }

            private float GetFontLineHeight(Font font)
            {
                var ff = font.FontFamily;
                return (float)Math.Ceiling(1.0 * font.Height * ff.GetLineSpacing(font.Style) / ff.GetEmHeight(font.Style));
            }

            protected override void MeasureRuns(List<Run> runs)
            {
                List<Run> tempRuns = new List<Run>(MAX_RANGES);

                foreach (var run in runs)
                {
                    tempRuns.Add(run);
                    if (tempRuns.Count >= MAX_RANGES)
                    {
                        MeasureBatch(tempRuns);
                        tempRuns.Clear();
                    }
                }

                MeasureBatch(tempRuns);

                //failed
                if (runs.Where(run => !run.IsBreakLine && run.Length > 0)
                    .All(run => run.Width == 0))
                {
                    float x = 0;
                    foreach (var run in runs.Where(r => !r.IsBreakLine))
                    {
                        run.X = (int)Math.Round(x);
                        float width = 0;
                        for (int i = 0; i < run.Length; i++)
                        {
                            var chr = this.sb[run.StartIndex + i];
                            width += chr > 0xff ? this.font.Size : (this.font.Size / 2);
                        }
                        run.Width = (int)Math.Round(x);
                        x += width;
                    }
                }
            }

            private void MeasureBatch(List<Run> runs)
            {
                string text = sb.ToString();
                if (runs.Count > 0 && !runs.All(run => run.IsBreakLine))
                {
                    fmt.SetMeasurableCharacterRanges(runs.Select(r => new CharacterRange(r.StartIndex, r.Length)).ToArray());
                    var regions = g.MeasureCharacterRanges(text, font, infinityRect, fmt);
                    for (int i = 0; i < runs.Count; i++)
                    {
                        var layout = new RectangleF();
                        if (this.UseGDIRenderer)
                            layout = new RectangleF(new Point(TR.MeasureText(g, text.Substring(0, runs[i].StartIndex), font, Size.Round(infinityRect.Size), TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix).Width, 0), TR.MeasureText(g, text.Substring(runs[i].StartIndex, runs[i].Length), font, Size.Round(infinityRect.Size), TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix));
                        else
                            layout = regions[i].GetBounds(g);
                        runs[i].X = (int)Math.Round(layout.Left);
                        runs[i].Width = (int)Math.Round(layout.Width);
                        if (i < regions.Length)
                            regions[i].Dispose();
                    }
                }
            }

            protected override Rectangle[] MeasureChars(int startIndex, int length)
            {
                string word = sb.ToString(startIndex, length);
                Rectangle[] rects = new Rectangle[length];

                for (int i = 0; i < length; i += MAX_RANGES)
                { //批次
                    int chrCount = Math.Min(length - i, MAX_RANGES);
                    fmt.SetMeasurableCharacterRanges(
                        Enumerable.Range(i, chrCount)
                        .Select(start => new CharacterRange(start, 1))
                        .ToArray());
                    var regions = g.MeasureCharacterRanges(word, font, infinityRect, fmt);
                    for (int i1 = 0; i1 < regions.Length; i1++)
                    {
                        var rect = new RectangleF();
                        if (this.UseGDIRenderer)
                            rect = new RectangleF(new Point(0, 0), TR.MeasureText(g, "" + word[i + i1], font, Size.Round(infinityRect.Size), TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix));
                        else
                            rect = regions[i1].GetBounds(g);
                        rects[i + i1] = new Rectangle(
                            (int)Math.Round(rect.Left),
                            (int)Math.Round(rect.Top),
                            (int)Math.Round(rect.Width),
                            (int)Math.Round(rect.Height)
                            );
                    }
                }

                //failed
                if (rects.All(rect => rect.Width == 0))
                {
                    float x = 0;
                    for (int i = 0; i < rects.Length; i++)
                    {
                        var chr = this.sb[startIndex + i];
                        var width = chr > 0xff ? this.font.Size : (this.font.Size / 2);
                        rects[i] = new Rectangle(
                            (int)Math.Round(x),
                            0,
                            (int)Math.Round(width),
                            font.Height
                            );
                    }
                }

                return rects;
            }

            protected override void Flush(StringBuilder sb, int startIndex, int length, int x, int y, string colorID)
            {
                string content = sb.ToString(startIndex, length);
                Color color;
                switch (colorID)
                {
                    case "c": color = this.orangeColor; break;
                    case "g": color = GearGraphics.gearGreenColor; break;
                    case "$": color = GearGraphics.gearCyanColor; break;
                    case "$$": color = GearGraphics.gearBlueColor; break;
                    default: color = this.defaultColor; break;
                }
                if (this.UseGDIRenderer)
                {
                    TR.DrawText(g, content, font, new Point(this.drawX + x, y), color, TextFormatFlags.NoPrefix | TextFormatFlags.NoPadding);
                }
                else
                {
                    using (var brush = new SolidBrush(color))
                    {
                        g.DrawString(content, font, brush, this.drawX + x, y, fmt);
                    }
                }
            }

            public void Dispose()
            {
                if (fmt != null)
                    fmt.Dispose();
            }
        }

        public static bool HasNonASCIIChars(string str)
        {
            return System.Text.Encoding.UTF8.GetByteCount(str) != str.Length;
        }
    }
}

```

`MapleNecrocer/CharaSimControl/GearTooltipRender.cs`:

```cs
using System;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Collections.Generic;
using System.Text;
using CharaSimResource;
using WzComparerR2.Common;
using WzComparerR2.CharaSim;

namespace WzComparerR2.CharaSimControl
{
    public class GearTooltipRender : TooltipRender
    {
        public GearTooltipRender()
        {
        }

        private Gear gear;
        private CharacterStatus charStat;

        public Gear Gear
        {
            get { return gear; }
            set { gear = value; }
        }

        public CharacterStatus CharacterStatus
        {
            get { return charStat; }
            set { charStat = value; }
        }

        public override Bitmap Render()
        {
            if (this.gear == null)
            {
                return null;
            }
            int picHeight, iconY, picHeight2, picHeight3;
            Bitmap left = renderBase(out picHeight, out iconY);
            Bitmap add = renderAddition(out picHeight2);
            Bitmap set = renderSetItem(out picHeight3);

            //整合图像
            int width = 252;
            if (add != null) width += 252;
            if (set != null) width += 252;
            Bitmap tooltip = new Bitmap(width, Math.Max(Math.Max(picHeight, picHeight2), picHeight3));
            Graphics g = Graphics.FromImage(tooltip);
            bool epic = gear.Epic;

            width = 0;
            //绘制主图
            if (left != null)
            {
                g.FillRectangle(epic ? GearGraphics.EpicGearBackBrush : GearGraphics.GearBackBrush, 2, 2, 248, picHeight - 4);
                g.CompositingMode = CompositingMode.SourceCopy;
                g.FillRectangle(epic ? GearGraphics.EpicGearIconBackBrush : GearGraphics.GearIconBackBrush, 14, iconY, 68, 68);
                g.CompositingMode = CompositingMode.SourceOver;
                g.DrawImage(left, 0, 0, new Rectangle(0, 0, 252, picHeight - 2), GraphicsUnit.Pixel);
                //绘制外边框
                g.DrawLines(epic ? GearGraphics.EpicGearBackPen : GearGraphics.GearBackPen, GearGraphics.GetBorderPath(0, 252, picHeight));
                //绘制等级边框
                Pen pen = GearGraphics.GetGearItemBorderPen(gear.Grade);
                if (pen != null)
                {
                    g.DrawLines(pen, getRankBorderPath(picHeight));
                }
                width += 252;
            }

            //绘制addition
            if (add != null)
            {
                //底色和边框
                g.FillRectangle(epic ? GearGraphics.EpicGearBackBrush : GearGraphics.GearBackBrush, width + 2, 2, 248, picHeight - 4);
                g.DrawLines(epic ? GearGraphics.EpicGearBackPen : GearGraphics.GearBackPen, GearGraphics.GetBorderPath(width, 252, picHeight));
                //复制原图
                g.DrawImage(add, width, 0, new Rectangle(0, 0, 252, picHeight2), GraphicsUnit.Pixel);
                add.Dispose();
                width += 252;
            }

            //绘制setitem
            if (set != null)
            {
                //底色和边框
                g.FillRectangle(GearGraphics.GearBackBrush, width + 2, 2, 248, picHeight3 - 4);
                g.DrawLines(GearGraphics.GearBackPen, GearGraphics.GetBorderPath(width, 252, picHeight3));
                //复制原图
                g.DrawImage(set, width, 0, new Rectangle(0, 0, 252, picHeight3), GraphicsUnit.Pixel);
                set.Dispose();
                width += 252;
            }

               // GearGraphics.DrawGearDetailNumber(g, 2, 2, gear.ItemID.ToString("d8"), true);

            g.Dispose();

            return tooltip;
        }

        private Bitmap renderBase(out int picHeight, out int iconY)
        {
            //绘制左侧部分
            Bitmap leftPart = new Bitmap(252, DefaultPicHeight);
            Graphics g = Graphics.FromImage(leftPart);
            StringFormat format = new StringFormat();
            int value;

            picHeight = 10;
            if (gear.Star > 0) //绘制星星
            {
                if (gear.Star < 5)
                {
                    for (int i = 0; i < gear.Star; i++)
                    {
                        g.DrawImage(Resource.ToolTip_Equip_Star_Star, 126 - gear.Star * 13 / 2 + 13 * i, picHeight);
                    }
                    picHeight += 18;
                }
                else
                {
                    int star = gear.Star % 5, star2 = gear.Star / 5;
                    int dx = 126 - (13 * star + 26 * star2) / 2;
                    for (int i = 0; i < 1; i++, dx += 26)
                    {
                        g.DrawImage(Resource.ToolTip_Equip_Star_Star2, dx, picHeight);
                    }
                    for (int i = 0; i < star; i++, dx += 13)
                    {
                        g.DrawImage(Resource.ToolTip_Equip_Star_Star, dx, picHeight + 5);
                    }
                    for (int i = 1; i < star2; i++, dx += 26)
                    {
                        g.DrawImage(Resource.ToolTip_Equip_Star_Star2, dx, picHeight);
                    }
                    picHeight += 28;
                }
            }

            //装备标题
            StringResult sr;
            if (StringLinker == null || !StringLinker.StringEqp.TryGetValue(gear.ItemID, out sr))
            {
                sr = new StringResult();
                sr.Name = "(null)";
            }
            string gearName = sr.Name;
            string nameAdd = gear.ScrollUp > 0 ? ("+" + gear.ScrollUp) : null;
            switch (Gear.GetGender(gear.ItemID))
            {
                case 0: nameAdd += " Male"; break;
                case 1: nameAdd += " Female"; break;
            }
            if (!string.IsNullOrEmpty(nameAdd))
            {
                gearName += " (" + nameAdd + ")";
            }
            format.Alignment = StringAlignment.Center;
            g.DrawString(gearName, GearGraphics.ItemNameFont,
                GearGraphics.GetGearNameBrush(gear.diff, gear.ScrollUp > 0), 124, picHeight, format);//绘制装备名称
            picHeight += 19;

            //装备rank
            string rankStr;
            if (gear.GetBooleanValue(GearPropType.specialGrade))
                rankStr = ItemStringHelper.GetGearGradeString(GearGrade.Special);
            else
                rankStr = ItemStringHelper.GetGearGradeString(gear.Grade);
            g.DrawString(rankStr, GearGraphics.EquipDetailFont, Brushes.White, 127, picHeight, format);
            picHeight += 21;

            //额外属性
            for (int i = 0; i < 2; i++)
            {
                string attrStr = GetGearAttributeString(i);
                if (!string.IsNullOrEmpty(attrStr))
                {
                    g.DrawString(attrStr, GearGraphics.EquipDetailFont, GearGraphics.OrangeBrush4, 126, picHeight, format);
                    picHeight += 19;
                }
            }

            //装备限时
            if (gear.TimeLimited)
            {
                DateTime time = DateTime.Now.AddDays(7d);
                string expireStr = time.ToString("USABLE UNTIL M-d-yyyy AT HH:mm");
                g.DrawString(expireStr, GearGraphics.EquipDetailFont, Brushes.White, 126, picHeight, format);
                picHeight += 16;
            }

            picHeight += 1;
            iconY = picHeight + 1;
            bool epic = gear.Epic;

            //绘制图标
            if (gear.Icon.Bitmap != null)
            {
                g.DrawImage(GearGraphics.EnlargeBitmap(gear.Icon.Bitmap),
                    14 + (1 - gear.Icon.Origin.X) * 2,
                    iconY + (33 - gear.Icon.Origin.Y) * 2);
            }
            if (gear.Cash)
            {
                g.DrawImage(GearGraphics.EnlargeBitmap(Resource.CashItem_0),
                    14 + 68 - 26,
                    iconY + 68 - 26);
            }

            //绘制属性要求
            drawGearReq(g, ref picHeight);

            //绘制装备等级
            if (gear.Props.TryGetValue(GearPropType.level, out value))
            {
                g.DrawImage(Resource.ToolTip_Equip_GrowthEnabled_itemLEV, 96, picHeight);
                GearGraphics.DrawGearGrowthNumber(g, 160, picHeight + 4, (value == -1) ? "m" : value.ToString(), true);
                picHeight += 12;
                g.DrawImage(Resource.ToolTip_Equip_GrowthEnabled_itemEXP, 96, picHeight);
                GearGraphics.DrawGearGrowthNumber(g, 160, picHeight + 4, (value == -1) ? "m" : "0%", true);
            }
            else
            {
                g.DrawImage(Resource.ToolTip_Equip_GrowthDisabled_itemLEV, 96, picHeight);
                g.DrawImage(Resource.ToolTip_Equip_GrowthDisabled_none, 160, picHeight + 4 + 3);
                picHeight += 12;
                g.DrawImage(Resource.ToolTip_Equip_GrowthDisabled_itemEXP, 96, picHeight);
                g.DrawImage(Resource.ToolTip_Equip_GrowthDisabled_none, 160, picHeight + 4 + 3);
            }
            picHeight += 12;
            if (gear.Props.TryGetValue(GearPropType.durability, out value))
            {
                if (value > 100) value = 100;
                g.DrawImage(value > 0 ? Resource.ToolTip_Equip_Can_durability : Resource.ToolTip_Equip_Cannot_durability, 96, picHeight);
                GearGraphics.DrawGearDetailNumber(g, 173, picHeight, value.ToString() + "%", value > 0);
            }
            picHeight += 13;

            //绘制职业要求
            int reqJob;
            gear.Props.TryGetValue(GearPropType.reqJob, out reqJob);
            g.DrawString("Beginner", GearGraphics.EquipDetailFont, reqJob > 0 ? Brushes.Red : Brushes.White, 10, picHeight);
            if (reqJob == 0) reqJob = 0x1f;//0001 1111
            if (reqJob == -1) reqJob = 0; //0000 0000
            g.DrawString("Warrior", GearGraphics.EquipDetailFont, (reqJob & 1) == 0 ? Brushes.Red : Brushes.White, 46, picHeight);
            g.DrawString("Magician", GearGraphics.EquipDetailFont, (reqJob & 2) == 0 ? Brushes.Red : Brushes.White, 82, picHeight);
            g.DrawString("Bowman", GearGraphics.EquipDetailFont, (reqJob & 4) == 0 ? Brushes.Red : Brushes.White, 130, picHeight);
            g.DrawString("Thief", GearGraphics.EquipDetailFont, (reqJob & 8) == 0 ? Brushes.Red : Brushes.White, 178, picHeight);
            g.DrawString("Pirate", GearGraphics.EquipDetailFont, (reqJob & 16) == 0 ? Brushes.Red : Brushes.White, 214, picHeight);
            picHeight += 19;

            //额外职业要求
            string extraReq = ItemStringHelper.GetExtraJobReqString(gear.type) ??
                (gear.Props.TryGetValue(GearPropType.reqSpecJob, out value) ? ItemStringHelper.GetExtraJobReqString(value) : null);
            if (!string.IsNullOrEmpty(extraReq))
            {
                g.DrawString(extraReq, GearGraphics.EquipDetailFont, GearGraphics.OrangeBrush4, 124, picHeight, format);
                picHeight += 18;
            }

            //分割线1号
            g.DrawLine(Pens.White, 6, picHeight, 245, picHeight);
            picHeight += 9;

            bool hasPart2 = false;
            //绘制属性
            if (gear.Props.TryGetValue(GearPropType.superiorEqp, out value) && value > 0)
            {
                g.DrawString("Superior", GearGraphics.ItemNameFont, GearGraphics.SetItemNameBrush, 126, picHeight, format);
                picHeight += 18;
            }
            if (gear.Props.TryGetValue(GearPropType.limitBreak, out value) && value > 0)
            {
                g.DrawString("Damage Cap", GearGraphics.ItemNameFont, GearGraphics.SetItemNameBrush, 126, picHeight, format);
                picHeight += 18;
            }

            bool isWeapon = Gear.IsLeftWeapon(gear.type) || Gear.IsDoubleHandWeapon(gear.type);
            string typeStr = ItemStringHelper.GetGearTypeString(gear.type);
            if (!string.IsNullOrEmpty(typeStr))
            {
                g.DrawString("·", GearGraphics.EquipDetailFont, Brushes.White, 8, picHeight);
                g.DrawString((isWeapon ? "WEAPON" : "EQUIPMENT") + "CATEGORY : " + typeStr,
                    GearGraphics.EquipDetailFont, Brushes.White, 20, picHeight);
                picHeight += 16;
                hasPart2 = true;
            }
            if (gear.Props.TryGetValue(GearPropType.attackSpeed, out value))
            {
                g.DrawString("·", GearGraphics.EquipDetailFont, Brushes.White, 8, picHeight);
                g.DrawString("Attack Speed: " + ItemStringHelper.GetAttackSpeedString(value),
                    GearGraphics.EquipDetailFont, Brushes.White, 20, picHeight);
                picHeight += 16;
                hasPart2 = true;
            }
            List<GearPropType> props = new List<GearPropType>();
            foreach (KeyValuePair<GearPropType, int> p in gear.Props)
            {
                if ((int)p.Key < 100 && p.Value != 0)
                    props.Add(p.Key);
            }
            props.Sort();
            foreach (GearPropType type in props)
            {
                g.DrawString("·", GearGraphics.EquipDetailFont, Brushes.White, 8, picHeight);
                g.DrawString(ItemStringHelper.GetGearPropString(type, gear.Props[type]), (epic && Gear.IsEpicPropType(type)) ? GearGraphics.EpicGearDetailFont : GearGraphics.EquipDetailFont, Brushes.White, 20, picHeight);
                picHeight += 16;
                hasPart2 = true;
            }
            bool hasTuc = gear.HasTuc && gear.Props.TryGetValue(GearPropType.tuc, out value);
            if (hasTuc)
            {
                g.DrawString("Remaining Enhancements: " + value , GearGraphics.EquipDetailFont, Brushes.White, 8, picHeight);
                picHeight += 16;
                hasPart2 = true;
            }
            if (gear.Props.TryGetValue(GearPropType.limitBreak, out value) && value > 0)
            {
                g.DrawString(ItemStringHelper.GetGearPropString(GearPropType.limitBreak, value), GearGraphics.EquipDetailFont, GearGraphics.SetItemNameBrush, 8, picHeight);
                picHeight += 16;
                hasPart2 = true;
            }

            if (hasTuc && gear.Hammer > -1)
            {
                if (gear.Hammer == 2)
                {
                    g.DrawString("", GearGraphics.EquipDetailFont, Brushes.White, 8, picHeight);
                    picHeight += 16;
                }
                if (gear.Props.TryGetValue(GearPropType.superiorEqp, out value) && value > 0)
                {
                    g.DrawString(ItemStringHelper.GetGearPropString(GearPropType.superiorEqp, value), GearGraphics.EquipDetailFont, GearGraphics.SetItemNameBrush, 8, picHeight);
                    picHeight += 16;
                }
                if (gear.Star > 0)
                {
                    //g.DrawString("APPLIED" + gear.Star + "STAR ENHANCEMENT", GearGraphics.EquipDetailFont, GearGraphics.OrangeBrush, 8, picHeight);
                    g.DrawString("Star Force:" + Gear.Star + "/" + gear.GetMaxStar() + "Stars Infused", GearGraphics.EquipDetailFont, GearGraphics.OrangeBrush, 8, picHeight);
                    picHeight += 16;
                }
                picHeight += 2;
                g.TextRenderingHint = System.Drawing.Text.TextRenderingHint.ClearTypeGridFit;
                g.DrawString("Hammers Applied", GearGraphics.EquipDetailFont, GearGraphics.GoldHammerBrush, 8, picHeight);
                //g.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;
                g.DrawString(": " + gear.Hammer.ToString() + (gear.Hammer == 2 ? "(MAX)" : null), GearGraphics.TahomaFont, GearGraphics.GoldHammerBrush, 140, picHeight - 2);
                //g.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SystemDefault;
                picHeight += 14;
                hasPart2 = true;
            }
               
            
            //分割线2号
            if (hasPart2)
            {
                g.DrawLine(Pens.White, 6, picHeight, 245, picHeight);
                picHeight += 9;
            }

            //绘制潜能
            int optionCount = 0;
            foreach (Potential potential in gear.Options)
            {
                if (potential != null)
                {
                    g.DrawString("·", GearGraphics.EquipDetailFont, Brushes.White, 8, picHeight);
                    g.DrawString(potential.ConvertSummary(), GearGraphics.EquipDetailFont, Brushes.White, 20, picHeight);
                    picHeight += 16;
                    optionCount++;
                }
            }
            if (optionCount>0){
                picHeight += 4 * optionCount;
            }
            else if (gear.CanPotential)
            {
                GearGraphics.DrawString(g, "Potential. (Click on the magnifying glass button in the item window to unleash.)",
                    GearGraphics.EquipDetailFont, 8, 236, ref picHeight, 16);
                picHeight += 4;
            }

            //绘制附加潜能
            int adOptionCount = 0;
            foreach (Potential potential in gear.AdditionalOptions)
            {
                if (potential != null)
                {
                    adOptionCount++;
                }
            }
            if (adOptionCount > 0)
            {
                //分割线3号
                picHeight -= 3;
                g.DrawLine(Pens.White, 6, picHeight, 245, picHeight);
                g.DrawImage(GetAdditionalOptionIcon(gear.AdditionGrade), 8, picHeight+1);
                g.DrawString("Bonus Potential", GearGraphics.EquipDetailFont, GearGraphics.SetItemNameBrush, 26, picHeight+2);
                picHeight += 24;

                foreach (Potential potential in gear.AdditionalOptions)
                {
                    if (potential != null)
                    {
                        g.DrawString("+", GearGraphics.EquipDetailFont, Brushes.White, 8, picHeight);
                        g.DrawString(potential.ConvertSummary(), GearGraphics.EquipDetailFont, Brushes.White, 20, picHeight);
                        picHeight += 18;
                        adOptionCount++;
                    }
                }
                picHeight += 5;
            }

            //绘制desc
            if (!string.IsNullOrEmpty(sr.Desc))
            {
                if (optionCount > 0) picHeight -= 2;
                picHeight -= 3;
                GearGraphics.DrawString(g, sr.Desc, GearGraphics.EquipDetailFont, 8, 236, ref picHeight, 16);
                picHeight += 5;
            }
            if (gear.Props.TryGetValue(GearPropType.tradeAvailable, out value) && value != 0)
            {
                g.DrawString(ItemStringHelper.GetGearPropString(GearPropType.tradeAvailable, value),
                    GearGraphics.EquipDetailFont,
                    GearGraphics.OrangeBrush,
                    14, picHeight - 5);
                picHeight += 16;
            }

            if (gear.Props.TryGetValue(GearPropType.accountShareTag, out value) && value != 0)
            {
                GearGraphics.DrawString(g, "#c" + ItemStringHelper.GetGearPropString(GearPropType.accountShareTag, 1) + "#",
                     GearGraphics.EquipDetailFont, 8, 236, ref picHeight, 16);
                picHeight += 16;
            }

            //绘制倾向
            if (gear.State == GearState.itemList)
            {
                string incline = null;
                GearPropType[] inclineTypes = new GearPropType[]{
                    GearPropType.charismaEXP,
                    GearPropType.senseEXP,
                    GearPropType.insightEXP,
                    GearPropType.willEXP,
                    GearPropType.craftEXP,
                    GearPropType.charmEXP };

                string[] inclineString = new string[]{
                    " Ambition"," Empathy"," Insight"," Willpower"," Diligence"," Charm"};

                for (int i = 0; i < inclineTypes.Length; i++)
                {
                    if (gear.Props.TryGetValue(inclineTypes[i], out value) && value > 0)
                    {
                        incline += ", " + value + inclineString[i];
                        //incline += ", " + value + " " + inclineString[i];
                    }
                }

                if (!string.IsNullOrEmpty(incline))
                {
                    picHeight -= 5;
                    GearGraphics.DrawString(g, "#cGrants " + incline.Substring(1) + " EXP when first equipped (up to the daily maximum).#",
                        GearGraphics.EquipDetailFont, 8, 236, ref picHeight, 16);
                    picHeight += 8;
                }
            }
            format.Dispose();
            g.Dispose();
            return leftPart;
        }

        private Bitmap renderAddition(out int picHeight)
        {
            Bitmap addBitmap = null;
            picHeight = 0;
            if (gear.Additions.Count > 0)
            {
                addBitmap = new Bitmap(252, DefaultPicHeight);
                Graphics g = Graphics.FromImage(addBitmap);
                StringBuilder sb = new StringBuilder();
                foreach (Addition addition in gear.Additions)
                {
                    string conString = addition.GetConString(), propString = addition.GetPropString();
                    if (!string.IsNullOrEmpty(conString) || !string.IsNullOrEmpty(propString))
                    {
                        sb.Append("- ");
                        if (!string.IsNullOrEmpty(conString))
                            sb.AppendLine(conString);
                        if (!string.IsNullOrEmpty(propString))
                            sb.AppendLine(propString);
                        sb.AppendLine();
                    }
                }
                if (sb.Length > 0)
                {
                    picHeight = 10;
                    GearGraphics.DrawString(g, sb.ToString(), GearGraphics.EquipDetailFont, 8, 236, ref picHeight, 16);
                }
                g.Dispose();
            }
            return addBitmap;
        }

        private Bitmap renderSetItem(out int picHeight)
        {
            Bitmap setBitmap = null;
            int setID;
            picHeight = 0;
            if (gear.Props.TryGetValue(GearPropType.setItemID, out setID))
            {
                SetItem setItem;
                if (!CharaSimLoader.LoadedSetItems.TryGetValue(setID, out setItem))
                    return null;
                setBitmap = new Bitmap(252, DefaultPicHeight);
                Graphics g = Graphics.FromImage(setBitmap);
                StringFormat format = new StringFormat();
                format.Alignment = StringAlignment.Center;

                picHeight = 10;
                g.DrawString(setItem.SetItemName, GearGraphics.EquipDetailFont, GearGraphics.SetItemNameBrush, 126, 10, format);
                picHeight += 25;

                format.Alignment=StringAlignment.Far;

                foreach (var setItemPart in setItem.ItemIDs.Parts)
                {
                    string itemName = setItemPart.Value.RepresentName;
                    string typeName = setItemPart.Value.TypeName;

                    if (string.IsNullOrEmpty(itemName) || string.IsNullOrEmpty(typeName))
                    {
                        foreach (var itemID in setItemPart.Value.ItemIDs)
                        {
                            StringResult sr;
                            if (!StringLinker.StringEqp.TryGetValue(itemID.Key, out sr))
                            {
                                sr = new StringResult();
                                sr.Name = "(null)";
                            }
                            itemName = sr.Name;
                            typeName = ItemStringHelper.GetSetItemGearTypeString(Gear.GetGearType(itemID.Key));
                            break;
                        }
                    }

                    itemName = itemName ?? string.Empty;
                    typeName = typeName ?? "EQUIPMENT";

                    Brush brush = setItemPart.Value.Enabled ? Brushes.White : GearGraphics.SetItemGrayBrush;
                    g.DrawString(itemName, GearGraphics.EquipDetailFont, brush, 8, picHeight);
                    g.DrawString("(" + typeName + ")", GearGraphics.EquipDetailFont, brush, 246, picHeight, format);
                    picHeight += 18;
                }

                picHeight += 5;
                g.DrawLine(Pens.White, 6, picHeight, 245, picHeight);//分割线
                picHeight += 9;
                foreach (KeyValuePair<int, SetItemEffect> effect in setItem.Effects)
                {
                    g.DrawString(effect.Key + " Set Items Equipped", GearGraphics.EquipDetailFont, GearGraphics.SetItemNameBrush, 8, picHeight);
                    picHeight += 16;
                    Brush brush = effect.Value.Enabled ? Brushes.White : GearGraphics.SetItemGrayBrush;
                    foreach (KeyValuePair<GearPropType, object> prop in effect.Value.Props)
                    {
                        if (prop.Key == GearPropType.Option)
                        {
                            List<Potential> ops = (List<Potential>)prop.Value;
                            foreach (Potential p in ops)
                            {
                                g.DrawString(p.ConvertSummary(), GearGraphics.SetItemPropFont, brush, 8, picHeight);
                                picHeight += 16;
                            }
                        }
                        else
                        {
                            g.DrawString(ItemStringHelper.GetGearPropString(prop.Key, Convert.ToInt32(prop.Value)),
                                GearGraphics.SetItemPropFont, brush, 8, picHeight);
                            picHeight += 16;
                        }
                    }
                }
                picHeight += 11;
                format.Dispose();
                g.Dispose();
            }
            return setBitmap;
        }

        private string GetGearAttributeString(int line)
        {
            int value;
            List<string> tags = new List<string>();
            switch (line)
            {
                case 0:
                    if (gear.Props.TryGetValue(GearPropType.only, out value) && value != 0)
                    {
                        tags.Add(ItemStringHelper.GetGearPropString(GearPropType.only, value));
                    }
                    if (gear.Props.TryGetValue(GearPropType.tradeBlock, out value) && value != 0)
                    {
                        tags.Add(ItemStringHelper.GetGearPropString(GearPropType.tradeBlock, value));
                    }
                    if (gear.Props.TryGetValue(GearPropType.accountSharable, out value) && value != 0)
                    {
                        tags.Add(ItemStringHelper.GetGearPropString(GearPropType.accountSharable, value));
                    }
                    if (gear.Props.TryGetValue(GearPropType.equipTradeBlock, out value) && value != 0)
                    {
                        if (gear.State == GearState.itemList)
                        {
                            tags.Add(ItemStringHelper.GetGearPropString(GearPropType.equipTradeBlock, value));
                        }
                        else
                        {
                            string tradeBlock = ItemStringHelper.GetGearPropString(GearPropType.tradeBlock, 1);
                            if (!tags.Contains(tradeBlock))
                                tags.Add(tradeBlock);
                        }
                    }
                    //if (gear.Props.TryGetValue(GearPropType.noPotential, out value) && value != 0)
                    //{
                    //    tags.Add(ItemStringHelper.GetGearPropString(GearPropType.noPotential, value));
                    //}
                    if (gear.Props.TryGetValue(GearPropType.fixedPotential, out value) && value != 0)
                    {
                        tags.Add(ItemStringHelper.GetGearPropString(GearPropType.fixedPotential, value));
                    }
                    break;
                case 1:
                    if (gear.Props.TryGetValue(GearPropType.onlyEquip, out value) && value != 0)
                    {
                        tags.Add(ItemStringHelper.GetGearPropString(GearPropType.onlyEquip, value));
                    }
                    if (gear.Props.TryGetValue(GearPropType.notExtend, out value) && value != 0)
                    {
                        tags.Add(ItemStringHelper.GetGearPropString(GearPropType.notExtend, value));
                    }
                    break;
            }
            return tags.Count > 0 ? string.Join(", ", tags.ToArray()) : null;
        }

        private void drawGearReq(Graphics g, ref int picHeight)
        {
            int value;
            bool isGetProp;
            bool can;

            //等级要求
            isGetProp = gear.Props.TryGetValue(GearPropType.reqLevel, out value);
            can = (charStat == null || charStat.Level >= value);
            g.DrawImage(can ? Resource.ToolTip_Equip_Can_reqLEV : Resource.ToolTip_Equip_Cannot_reqLEV, 96, picHeight);
            GearGraphics.DrawGearDetailNumber(g, 156, picHeight + 4, isGetProp ? value.ToString() : "-", can);
            picHeight += 12;

            //力量要求
            isGetProp = gear.Props.TryGetValue(GearPropType.reqSTR, out value);
            can = (charStat == null || charStat.Strength.GetSum() >= value);
            g.DrawImage(can ? Resource.ToolTip_Equip_Can_reqSTR : Resource.ToolTip_Equip_Cannot_reqSTR, 96, picHeight);
            GearGraphics.DrawGearDetailNumber(g, 156, picHeight + 4, isGetProp ? value.ToString() : "-", can);
            picHeight += 12;

            //敏捷要求
            isGetProp = gear.Props.TryGetValue(GearPropType.reqDEX, out value);
            can = (charStat == null || charStat.Dexterity.GetSum() >= value);
            g.DrawImage(can ? Resource.ToolTip_Equip_Can_reqDEX : Resource.ToolTip_Equip_Cannot_reqDEX, 96, picHeight);
            GearGraphics.DrawGearDetailNumber(g, 156, picHeight + 4, isGetProp ? value.ToString() : "-", can);
            picHeight += 12;

            //智力要求
            isGetProp = gear.Props.TryGetValue(GearPropType.reqINT, out value);
            can = (charStat == null || charStat.Intelligence.GetSum() >= value);
            g.DrawImage(can ? Resource.ToolTip_Equip_Can_reqINT : Resource.ToolTip_Equip_Cannot_reqINT, 96, picHeight);
            GearGraphics.DrawGearDetailNumber(g, 156, picHeight + 4, isGetProp ? value.ToString() : "-", can);
            picHeight += 12;

            //运气要求
            isGetProp = gear.Props.TryGetValue(GearPropType.reqLUK, out value);
            can = (charStat == null || charStat.Luck.GetSum() >= value);
            g.DrawImage(can ? Resource.ToolTip_Equip_Can_reqLUK : Resource.ToolTip_Equip_Cannot_reqLUK, 96, picHeight);
            GearGraphics.DrawGearDetailNumber(g, 156, picHeight + 4, isGetProp ? value.ToString() : "-", can);
            picHeight += 12;

            //人气要求
            isGetProp = gear.Props.TryGetValue(GearPropType.reqPOP, out value);
            can = (charStat == null || charStat.Pop >= value);
            g.DrawImage(can ? Resource.ToolTip_Equip_Can_reqPOP : Resource.ToolTip_Equip_Cannot_reqPOP, 96, picHeight);
            GearGraphics.DrawGearDetailNumber(g, 156, picHeight + 4, isGetProp ? value.ToString() : "-", can);
            picHeight += 12;
        }

        private Image GetAdditionalOptionIcon(GearGrade grade)
        {
            switch (grade)
            {
                case GearGrade.B: return Resource.AdditionalOptionTooltip_rare;
                case GearGrade.A: return Resource.AdditionalOptionTooltip_epic;
                case GearGrade.S: return Resource.AdditionalOptionTooltip_unique;
                case GearGrade.SS: return Resource.AdditionalOptionTooltip_legendary;
            }
            return null;
        }

        private Point[] getRankBorderPath(int height)
        {
            List<Point> pointList = new List<Point>(5);
            pointList.Add(new Point(252 - 4, height - 5));
            pointList.Add(new Point(252 - 4, 4));
            pointList.Add(new Point(4, 4));
            pointList.Add(new Point(4, height - 4));
            pointList.Add(new Point(252 - 5, height - 4));
            return pointList.ToArray();
        }

    }
}

```

`MapleNecrocer/CharaSimControl/GearTooltipRender2.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Text;
using System.Text.RegularExpressions;
using System.Windows.Forms;
using Resource = CharaSimResource.Resource;
using WzComparerR2.Common;
using WzComparerR2.CharaSim;
using WzComparerR2.WzLib;
using GraphicsExtension;
using DPIUtils;

namespace WzComparerR2.CharaSimControl
{
    public class GearTooltipRender2 : TooltipRender
    {
        static GearTooltipRender2()
        {
            res = new Dictionary<string, TextureBrush>();
            res["t"] = new TextureBrush(Resource.UIToolTip_img_Item_Frame_top, WrapMode.Clamp);
            res["line"] = new TextureBrush(Resource.UIToolTip_img_Item_Frame_line, WrapMode.Tile);
            res["dotline"] = new TextureBrush(Resource.UIToolTip_img_Item_Frame_dotline, WrapMode.Clamp);
            res["b"] = new TextureBrush(Resource.UIToolTip_img_Item_Frame_bottom, WrapMode.Clamp);
            res["cover"] = new TextureBrush(Resource.UIToolTip_img_Item_Frame_cover, WrapMode.Clamp);
        }

        private static Dictionary<string, TextureBrush> res;

        public GearTooltipRender2()
        {
        }

        private CharacterStatus charStat;

        public Gear Gear { get; set; }

        public override object TargetItem
        {
            get { return this.Gear; }
            set { this.Gear = value as Gear; }
        }

        public CharacterStatus CharacterStatus
        {
            get { return charStat; }
            set { charStat = value; }
        }

        public bool ShowSpeed { get; set; }
        public bool ShowLevelOrSealed { get; set; }
        public bool ShowMedalTag { get; set; } = true;
        public bool IsCombineProperties { get; set; } = true;

        public TooltipRender SetItemRender { get; set; }

        public override Bitmap Render()
        {
            if (this.Gear == null)
            {
                return null;
            }

            int[] picH = new int[4];
            Bitmap left = RenderBase(out picH[0]);
            Bitmap add = RenderAddition(out picH[1]);
            Bitmap set = RenderSetItem(out picH[2]);
            Bitmap levelOrSealed = null;
            if (this.ShowLevelOrSealed)
            {
                levelOrSealed = RenderLevelOrSealed(out picH[3]);
            }

            int width = 261;
            if (add != null) width += add.Width;
            if (set != null) width += set.Width;
            if (levelOrSealed != null) width += levelOrSealed.Width;
            int height = 0;
            for (int i = 0; i < picH.Length; i++)
            {
                height = Math.Max(height, picH[i]);
            }
            Bitmap tooltip = new Bitmap(width, height);
            Graphics g = Graphics.FromImage(tooltip);
         
          
            //绘制主图
            width = 0;
            if (left != null)
            {
                //绘制背景
                g.DrawImage2(res["t"].Image, width, 0);
                FillRect(g, res["line"], width, 13, picH[0] - 13);
                g.DrawImage2(res["b"].Image, width, picH[0] - 13);

                //复制图像
                var left2=left;
                left2.SetResolution(DPIUtil.dpiX, DPIUtil.dpiY);
                g.DrawImage(left2, width, 0, new Rectangle(0, 0, left.Width, picH[0]), GraphicsUnit.Pixel);

                //cover
                g.DrawImage2(res["cover"].Image, 3, 3);

                width += left.Width;
                left2.Dispose();
            }

            //绘制addition
            if (add != null)
            {
                //绘制背景
                g.DrawImage2(res["t"].Image, width, 0);
                FillRect(g, res["line"], width, 13, tooltip.Height - 13);
                g.DrawImage2(res["b"].Image, width, tooltip.Height - 13);

                //复制原图
                var add2=add;
                add2.SetResolution(DPIUtil.dpiX, DPIUtil.dpiY);
                g.DrawImage(add2, width, 0, new Rectangle(0, 0, add.Width, picH[1]), GraphicsUnit.Pixel);

                width += add.Width;
                add2.Dispose();
            }

            //绘制setitem
            if (set != null)
            {
                //绘制背景
                //g.DrawImage(res["t"].Image, width, 0);
                //FillRect(g, res["line"], width, 13, picH[2] - 13);
                //g.DrawImage(res["b"].Image, width, picH[2] - 13);

                //复制原图
                var set2=set;
                set2.SetResolution(DPIUtil.dpiX, DPIUtil.dpiY);
                g.DrawImage(set2, width, 0, new Rectangle(0, 0, set.Width, picH[2]), GraphicsUnit.Pixel);
                width += set.Width;
                set2.Dispose();
            }

            //绘制levelOrSealed
            if (levelOrSealed != null)
            {
                //绘制背景
                g.DrawImage2(res["t"].Image, width, 0);
                FillRect(g, res["line"], width, 13, picH[3] - 13);
                g.DrawImage2(res["b"].Image, width, picH[3] - 13);

                //复制原图
                var levelOrSealed2= levelOrSealed;
                levelOrSealed2.SetResolution(DPIUtil.dpiX, DPIUtil.dpiY);
                g.DrawImage(levelOrSealed2, width, 0, new Rectangle(0, 0, levelOrSealed2.Width, picH[3]), GraphicsUnit.Pixel);
                width += levelOrSealed2.Width;
                levelOrSealed2.Dispose();
            }

            if (this.ShowObjectID)
            {
                GearGraphics.DrawGearDetailNumber(g, 3, 3, Gear.ItemID.ToString("d8"), true);
            }

            g.Dispose();
            return tooltip;
        }

        private Bitmap RenderBase(out int picH)
        {
            Bitmap bitmap = new Bitmap(261, DefaultPicHeight);
            Graphics g = Graphics.FromImage(bitmap);
            g.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SystemDefault;
            StringFormat format = (StringFormat)StringFormat.GenericTypographic.Clone();
            int value, value2;

            picH = 13;
            DrawStar2(g, ref picH); //绘制星星

            //绘制装备名称
            StringResult sr;
            if (StringLinker == null || !StringLinker.StringEqp.TryGetValue(Gear.ItemID, out sr))
            {
                sr = new StringResult();
                sr.Name = "(null)";
            }
            string gearName = sr.Name;
            switch (Gear.GetGender(Gear.ItemID))
            {
                case 0: gearName += " (Male)"; break;
                case 1: gearName += " (Female)"; break;
            }
            string nameAdd = Gear.ScrollUp > 0 ? ("+" + Gear.ScrollUp) : null;
            if (!string.IsNullOrEmpty(nameAdd))
            {
                gearName += " (" + nameAdd + ")";
            }

            g.DrawImage2(Resource.ToolTip_Equip_Dot_0, 9, picH + 5);//GMS Version blue dot in EQUIPMENT
            format.Alignment = StringAlignment.Near;//GMS Version
            TextRenderer.DrawText(g, gearName, GearGraphics.ItemNameFont2,
                //GearGraphics.GetGearNameBrush(Gear.diff, Gear.ScrollUp > 0, Gear.ItemID / 10000 == 180), 15, picH, format);//GMS Version
                //new Point(14, picH), Gear.Cash ? ((SolidBrush)GearGraphics.GearNameBrushB).Color : ((SolidBrush)GearGraphics.GetGearNameBrush(Gear.diff, Gear.ScrollUp > 0, Gear.ItemID / 10000 == 180)).Color, TextFormatFlags.Left | TextFormatFlags.NoPrefix); // Use this line and not above
                new Point(14, picH), ((SolidBrush)GearGraphics.GetGearNameBrush(Gear.diff, Gear.ScrollUp > 0, Gear.Cash, Gear.ItemID / 10000 == 180)).Color, TextFormatFlags.Left | TextFormatFlags.NoPrefix);
            picH += 23;

            //装备rank
            string rankStr = null;
            if (Gear.GetBooleanValue(GearPropType.specialGrade))
            {
                rankStr = ItemStringHelper.GetGearGradeString(GearGrade.Special);
            }
            else if (!Gear.Cash) //T98后C级物品依然显示
            {
                rankStr = ItemStringHelper.GetGearGradeString(Gear.Grade);
            }
            if (rankStr != null)
            {
                TextRenderer.DrawText(g, rankStr, GearGraphics.EquipDetailFont, new Point(261, picH), Color.White, TextFormatFlags.HorizontalCenter);
                picH += 15;
            }

            if (Gear.Props.TryGetValue(GearPropType.royalSpecial, out value) && value > 0)
            {
                switch (value)
                {
                    case 1:
                        TextRenderer.DrawText(g, "Special Label", GearGraphics.EquipDetailFont, new Point(261, picH), ((SolidBrush)GearGraphics.GearNameBrushA).Color, TextFormatFlags.HorizontalCenter);
                        break;
                    case 2:
                        TextRenderer.DrawText(g, "Red Label", GearGraphics.EquipDetailFont, new Point(261, picH), ((SolidBrush)GearGraphics.GearNameBrushH).Color, TextFormatFlags.HorizontalCenter);
                        break;
                    case 3:
                        TextRenderer.DrawText(g, "Black Label", GearGraphics.EquipDetailFont, new Point(261, picH), ((SolidBrush)GearGraphics.GearNameBrushF).Color, TextFormatFlags.HorizontalCenter);
                        break;
                }
                picH += 15;
            }
            else if (Gear.Props.TryGetValue(GearPropType.masterSpecial, out value) && value > 0)
            {
                TextRenderer.DrawText(g, "Master Label", GearGraphics.EquipDetailFont, new Point(261, picH), ((SolidBrush)GearGraphics.BlueBrush).Color, TextFormatFlags.HorizontalCenter);
                picH += 15;
            }
            else if (Gear.Props.TryGetValue(GearPropType.BTSLabel, out value) && value > 0)
            {
                TextRenderer.DrawText(g, "BTS Label", GearGraphics.EquipDetailFont, new Point(70, picH), Color.FromArgb(187, 102, 238), TextFormatFlags.HorizontalCenter);
                picH += 15;
            }
            else if (Gear.Props.TryGetValue(GearPropType.BLACKPINKLabel, out value) && value > 0)
            {
                TextRenderer.DrawText(g, "BLACKPINK Label", GearGraphics.EquipDetailFont, new Point(261, picH), Color.FromArgb(255, 136, 170), TextFormatFlags.HorizontalCenter);
                picH += 15;
            }

            //额外属性
            var attrList = GetGearAttributeString();
            if (attrList.Count > 0)
            {
                var font = GearGraphics.EquipDetailFont;
                string attrStr = null;
                for (int i = 0; i < attrList.Count; i++)
                {
                    var newStr = (attrStr != null ? (attrStr + ", ") : null) + attrList[i];
                    //if (TextRenderer.MeasureText(g, newStr, font, new Size(int.MaxValue, int.MaxValue), TextFormatFlags.NoPadding).Width > 261 - 7) pr - CharaSim: Suppress ExclusiveEquip line for same gear name
                    if (TextRenderer.MeasureText(g, newStr, font, new Size(int.MaxValue, int.MaxValue), TextFormatFlags.NoPadding).Width > 261 - 13)
                    {
                        TextRenderer.DrawText(g, attrStr, GearGraphics.EquipDetailFont, new Point(261, picH), ((SolidBrush)GearGraphics.OrangeBrush2).Color, TextFormatFlags.HorizontalCenter | TextFormatFlags.NoPadding);
                        picH += 15;
                        attrStr = attrList[i];
                    }
                    else
                    {
                        attrStr = newStr;
                    }
                }
                if (!string.IsNullOrEmpty(attrStr))
                {
                    TextRenderer.DrawText(g, attrStr, GearGraphics.EquipDetailFont, new Point(261, picH), ((SolidBrush)GearGraphics.OrangeBrush2).Color, TextFormatFlags.HorizontalCenter | TextFormatFlags.NoPadding);
                    picH += 15;
                }
            }

            //装备限时
            if (Gear.TimeLimited)
            {
                DateTime time = DateTime.Now.AddDays(7d);
                string expireStr = "Usable Until: " + time.ToString(@"M\/d\/yyyy HH\:mm") + " UTC";
                TextRenderer.DrawText(g, expireStr, GearGraphics.EquipDetailFont, new Point(bitmap.Width, picH), Color.White, TextFormatFlags.HorizontalCenter | TextFormatFlags.NoPadding);
                picH += 15;
            }
            else if (Gear.GetBooleanValue(GearPropType.abilityTimeLimited))
            {
                DateTime time = DateTime.Now.AddDays(7d);
                string expireStr;
                if (!Gear.Cash)
                {
                    expireStr = "Effects Last Until: " + time.ToString(@"M\/d\/yyyy HH\:mm") + " UTC";
                }
                else
                {
                    expireStr = "Usable Until: " + time.ToString(@"M\/d\/yyyy HH\:mm") + " UTC";
                }
                TextRenderer.DrawText(g, expireStr, GearGraphics.EquipDetailFont, new Point(bitmap.Width, picH), Color.White, TextFormatFlags.HorizontalCenter | TextFormatFlags.NoPadding);
                picH += 15;
            }

            //分割线1号
            picH += 7;
            g.DrawImage2(res["dotline"].Image, 0, picH);

            //绘制装备图标
            if (Gear.Grade > 0 && (int)Gear.Grade <= 4) //绘制外框
            {
                Image border = Resource.ResourceManager.GetObject("UIToolTip_img_Item_ItemIcon_" + (int)Gear.Grade) as Image;
                if (border != null)
                {
                    g.DrawImage2(border, 13, picH + 11);
                }
            }
             Bitmap c= Resource.UIToolTip_img_Item_ItemIcon_base;
           // c.SetResolution(96/0.8f,96/0.8f);
             g.DrawImage2(Resource.UIToolTip_img_Item_ItemIcon_base, 12, picH + 10); //绘制背景
          //  g.DrawImage(c, 12, picH + 10); //绘制背景

            if (Gear.IconRaw.Bitmap != null) //绘制icon
            {
                var attr = new System.Drawing.Imaging.ImageAttributes();
                var matrix = new System.Drawing.Imaging.ColorMatrix(
                    new[] {
                        new float[] { 1, 0, 0, 0, 0 },
                        new float[] { 0, 1, 0, 0, 0 },
                        new float[] { 0, 0, 1, 0, 0 },
                        new float[] { 0, 0, 0, 0.5f, 0 },
                        new float[] { 0, 0, 0, 0, 1 },
                        });
                attr.SetColorMatrix(matrix);

                //绘制阴影
                var shade = Resource.UIToolTip_img_Item_ItemIcon_shade;
               // shade.SetResolution(96*0.8f,96*0.8f);
                g.DrawImage2(shade,
                    new Rectangle(18 + 9, picH + 15 + 54, shade.Width, shade.Height),
                    0, 0, shade.Width, shade.Height,
                    GraphicsUnit.Pixel,
                    attr);
                //绘制图标
               
                g.DrawImage2(GearGraphics.EnlargeBitmap2(Gear.IconRaw.Bitmap),
                    18 + (1 - Gear.IconRaw.Origin.X) * 2,
                    picH + 15 + (33 - Gear.IconRaw.Origin.Y) * 2);

                attr.Dispose();
            }
            if (Gear.Cash) //绘制cash标识
            {
                Bitmap cashImg = null;
                Point cashOrigin = new Point(12, 12);

                if (Gear.Props.TryGetValue(GearPropType.royalSpecial, out value) && value > 0)
                {
                    string resKey = $"CashShop_img_CashItem_label_{value - 1}";
                    cashImg = Resource.ResourceManager.GetObject(resKey) as Bitmap;
                }
                else if (Gear.Props.TryGetValue(GearPropType.masterSpecial, out value) && value > 0)
                {
                    cashImg = Resource.CashShop_img_CashItem_label_3;
                }
                else if (Gear.Props.TryGetValue(GearPropType.BTSLabel, out value) && value > 0)
                {
                    cashImg = Resource.CashShop_img_CashItem_label_10;
                    cashOrigin = new Point(cashImg.Width, cashImg.Height);
                }
                else if (Gear.Props.TryGetValue(GearPropType.BLACKPINKLabel, out value) && value > 0)
                {
                    cashImg = Resource.CashShop_img_CashItem_label_11;
                    cashOrigin = new Point(cashImg.Width, cashImg.Height);
                }
                if (cashImg == null) //default cashImg
                {
                    cashImg = Resource.CashItem_0;
                }

                g.DrawImage2(GearGraphics.EnlargeBitmap2(cashImg),
                    18 + 68 - cashOrigin.X * 2 - 2,
                    picH + 15 + 68 - cashOrigin.Y * 2 - 2);
            }
            //检查星岩
            bool hasSocket = Gear.GetBooleanValue(GearPropType.nActivatedSocket);
            if (hasSocket)
            {
                Bitmap socketBmp = GetAlienStoneIcon();
                if (socketBmp != null)
                {
                    g.DrawImage2(GearGraphics.EnlargeBitmap(socketBmp),
                        18 + 2,
                        picH + 15 + 3);
                }
            }

            g.DrawImage2(Resource.UIToolTip_img_Item_ItemIcon_old, 14 - 2 + 5, picH + 9 + 5);
            g.DrawImage2(Resource.UIToolTip_img_Item_ItemIcon_cover, 16, picH + 14); //绘制左上角cover

            //绘制攻击力变化
            format.Alignment = StringAlignment.Far;
            TextRenderer.DrawText(g, "ATT INCREASE", GearGraphics.EquipDetailFont, new Point(248 - TextRenderer.MeasureText(g, "ATT INCREASE", GearGraphics.EquipDetailFont, new Size(int.MaxValue, int.MaxValue), TextFormatFlags.NoPadding).Width, picH + 10), ((SolidBrush)GearGraphics.GrayBrush2).Color, TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix);
            g.DrawImage2(Resource.UIToolTip_img_Item_Equip_Summary_incline_0, 249 - 19, picH + 27); //暂时画个0

            //绘制属性需求
            DrawGearReq(g, 97, picH + 59);
            picH += 94;

            //绘制属性变化
            DrawPropDiffEx(g, 12, picH);
            picH += 20;

            //绘制职业需求
            DrawJobReq(g, ref picH);

            if (Gear.type == GearType.android && Gear.Props.TryGetValue(GearPropType.android, out value) && value > 0)
            {
                TextRenderer.DrawText(g, "Appearance:", GearGraphics.EquipDetailFont, new Point(13, picH), Color.White, TextFormatFlags.NoPadding);
                picH += 15;

                Wz_Node android = PluginBase.PluginManager.FindWz(string.Format("Etc/Android/{0:D4}.img", value));

                int morphID = android?.Nodes["info"]?.Nodes["morphID"]?.GetValueEx<int>(0) ?? 0;
                BitmapOrigin appearance = BitmapOrigin.CreateFromNode(PluginBase.PluginManager.FindWz(morphID != 0 ? string.Format("Morph/{0:D4}.img/stand/0", morphID) : "Npc/0010300.img/stand/0"), PluginBase.PluginManager.FindWz);
                appearance.Bitmap.RotateFlip(RotateFlipType.RotateNoneFlipX);

                g.DrawImage2(appearance.Bitmap, 63, picH + 9);
                picH += 9 + appearance.Bitmap.Height + 13;

                Wz_Node costume = android?.Nodes["costume"];
                List<string> randomParts = new List<string>();
                if (costume?.Nodes["face"]?.Nodes["1"] != null)
                {
                    randomParts.Add("Face");
                }
                if (costume?.Nodes["hair"]?.Nodes["1"] != null)
                {
                    randomParts.Add("Hair");
                }
                if (costume?.Nodes["skin"]?.Nodes["1"] != null)
                {
                    randomParts.Add("Skin");
                }
                if (randomParts.Count > 0)
                {
                    GearGraphics.DrawString(g, $"#c{string.Join(", ", randomParts)} The image is an example. The android's appearance is determined upon equipping it for the first time.#", GearGraphics.EquipDetailFont, 13, 244, ref picH, 15, ((SolidBrush)GearGraphics.OrangeBrush2).Color);
                }
            }

            //分割线2号
            g.DrawImage2(res["dotline"].Image, 0, picH);
            picH += 8;

            bool hasPart2 = Gear.Cash;
            format.Alignment = StringAlignment.Center;

            //绘制属性
            if (Gear.Props.TryGetValue(GearPropType.superiorEqp, out value) && value > 0)
            {
                TextRenderer.DrawText(g, "Superior", GearGraphics.EquipDetailFont, new Point(261, picH), ((SolidBrush)GearGraphics.GreenBrush2).Color, TextFormatFlags.HorizontalCenter);
                picH += 15;
            }
            if (Gear.Props.TryGetValue(GearPropType.limitBreak, out value) && value > 0)
            {
                TextRenderer.DrawText(g, "Damage Cap", GearGraphics.EquipDetailFont, new Point(261, picH), ((SolidBrush)GearGraphics.GreenBrush2).Color, TextFormatFlags.HorizontalCenter);
                picH += 16;
            }

            //绘制装备升级
            if (Gear.Props.TryGetValue(GearPropType.level, out value) && !Gear.FixLevel)
            {
                bool max = (Gear.Levels != null && value >= Gear.Levels.Count);
                TextRenderer.DrawText(g, "Growth Level: " + (max ? "MAX" : value.ToString()), GearGraphics.EquipDetailFont, new Point(12, picH), ((SolidBrush)GearGraphics.OrangeBrush3).Color, TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix);
                picH += 15;
                string expString = Gear.Levels != null && Gear.Levels.First().Point != 0 ? ": 0/" + Gear.Levels.First().Point : ": 0%";
                TextRenderer.DrawText(g, "Growth EXP" + (max ? ": MAX" : expString), GearGraphics.EquipDetailFont, new Point(12, picH), ((SolidBrush)GearGraphics.OrangeBrush3).Color, TextFormatFlags.NoPadding);
                picH += 15;
            }
            else if (Gear.ItemID / 1000 == 1712)
            {
                TextRenderer.DrawText(g, "Growth Level: 1", GearGraphics.EquipDetailFont, new Point(12, picH), ((SolidBrush)GearGraphics.OrangeBrush3).Color, TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix);
                picH += 15;
                TextRenderer.DrawText(g, "Item EXP: 1 / 12 ( 8% )", GearGraphics.EquipDetailFont, new Point(12, picH), ((SolidBrush)GearGraphics.OrangeBrush3).Color, TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix);
                picH += 15;
            }
            else if (Gear.ItemID / 1000 == 1713)
            {
                TextRenderer.DrawText(g, "Growth Level: 1", GearGraphics.EquipDetailFont, new Point(12, picH), ((SolidBrush)GearGraphics.OrangeBrush3).Color, TextFormatFlags.NoPadding);
                picH += 15;
                TextRenderer.DrawText(g, "Item EXP : 1 / 29 ( 3% )", GearGraphics.EquipDetailFont, new Point(12, picH), ((SolidBrush)GearGraphics.OrangeBrush3).Color, TextFormatFlags.NoPadding);
                picH += 15;
            }

            if (Gear.Props.TryGetValue(GearPropType.@sealed, out value))
            {
                bool max = (Gear.Seals != null && value >= Gear.Seals.Count);
                TextRenderer.DrawText(g, "Unseal Stage : " + (max ? "MAX" : value.ToString()), GearGraphics.EquipDetailFont, new Point(12, picH), ((SolidBrush)GearGraphics.OrangeBrush3).Color, TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix);
                picH += 15;
                TextRenderer.DrawText(g, "Unseal EXP : " + (max ? "MAX" : "0%"), GearGraphics.EquipDetailFont, new Point(12, picH), ((SolidBrush)GearGraphics.OrangeBrush3).Color, TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix);
                picH += 15;
            }

            //绘制耐久度
            if (Gear.Props.TryGetValue(GearPropType.durability, out value))
            {
                TextRenderer.DrawText(g, "Durability: " + "100%", GearGraphics.EquipDetailFont, new Point(12, picH), ((SolidBrush)GearGraphics.GreenBrush2).Color, TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix);
                picH += 15;
            }

            //装备类型 - blank typeStr are for One-handed Weapon and Two-handed Weapon respectively
            bool isWeapon = Gear.IsWeapon(Gear.type);
            string typeStr = ItemStringHelper.GetGearTypeString(Gear.type);
            if (!string.IsNullOrEmpty(typeStr))
            {
                if (isWeapon)
                {
                    typeStr = "Type: " + typeStr;
                }
                else
                {
                    typeStr = "Type: " + typeStr;
                }

                if (!Gear.Cash && (Gear.IsLeftWeapon(Gear.type) || Gear.type == GearType.katara))
                {
                    typeStr += "";
                }
                else if (!Gear.Cash && Gear.IsDoubleHandWeapon(Gear.type))
                {
                    typeStr += "";
                }
                TextRenderer.DrawText(g, typeStr, GearGraphics.EquipDetailFont, new Point(12, picH), Color.White, TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix);
                picH += 15;
                hasPart2 = true;
            }

            if (!Gear.Props.TryGetValue(GearPropType.attackSpeed, out value)
                && (Gear.IsWeapon(Gear.type) || Gear.type == GearType.katara)) //找不到攻速的武器
            {
                value = 6; //给予默认速度
            }
            //  if (gear.Props.TryGetValue(GearPropType.attackSpeed, out value) && value > 0)
            if (!Gear.Cash && value > 0)
            {
                TextRenderer.DrawText(g, "Attack Speed: " + ItemStringHelper.GetAttackSpeedString(value),
                    GearGraphics.EquipDetailFont, new Point(13, picH), Color.White, TextFormatFlags.NoPadding);
                picH += 15;
                hasPart2 = true;
            }
            //机器人等级
            if (Gear.Props.TryGetValue(GearPropType.grade, out value) && value > 0)
            {
                TextRenderer.DrawText(g, "Rank: " + value, GearGraphics.EquipDetailFont, new Point(12, picH), Color.White, TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix);
                picH += 15;
                hasPart2 = true;
            }


            //一般属性
            List<GearPropType> props = new List<GearPropType>();
            foreach (KeyValuePair<GearPropType, int> p in Gear.PropsV5) //5转过滤
            {
                if ((int)p.Key < 100 && p.Value != 0)
                    props.Add(p.Key);
            }
            foreach (KeyValuePair<GearPropType, int> p in Gear.AbilityTimeLimited)
            {
                if ((int)p.Key < 100 && p.Value != 0 && !props.Contains(p.Key))
                    props.Add(p.Key);
            }
            props.Sort();
            //bool epic = Gear.Props.TryGetValue(GearPropType.epicItem, out value) && value > 0;
            foreach (GearPropType type in props)
            {
                //var font = (epic && Gear.IsEpicPropType(type)) ? GearGraphics.EpicGearDetailFont : GearGraphics.EquipDetailFont;
                //g.DrawString(ItemStringHelper.GetGearPropString(type, Gear.Props[type]), font, Brushes.White, 11, picH);
                //picH += 16;

                //绘制属性变化
                Gear.StandardProps.TryGetValue(type, out value); //standard value
                if (value > 0 || Gear.Props[type] > 0)
                {
                    var propStr = ItemStringHelper.GetGearPropDiffString(type, Gear.Props[type], value);
                    GearGraphics.DrawString(g, propStr, GearGraphics.EquipDetailFont, 12, 256, ref picH, 15);//changes the vertical distance of stats in tooltip, such as STR, DEX, INT etc.
                    hasPart2 = true;
                }
            }

            //戒指特殊潜能 (Ring Special Potential)
            int ringOpt, ringOptLv;
            if (Gear.Props.TryGetValue(GearPropType.ringOptionSkill, out ringOpt)
                && Gear.Props.TryGetValue(GearPropType.ringOptionSkillLv, out ringOptLv))
            {
                var opt = Potential.LoadFromWz(ringOpt, ringOptLv, PluginBase.PluginManager.FindWz);
                if (opt != null)
                {
                    TextRenderer.DrawText(g, opt.ConvertSummary(), GearGraphics.EquipDetailFont, new Point(12, picH), Color.White, TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix);
                    picH += 16;
                    hasPart2 = true;
                }
            }

            bool hasReduce = Gear.Props.TryGetValue(GearPropType.reduceReq, out value);
            if (hasReduce && value > 0)
            {
                TextRenderer.DrawText(g, ItemStringHelper.GetGearPropString(GearPropType.reduceReq, value), GearGraphics.EquipDetailFont, new Point(12, picH), Color.White, TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix);
                picH += 15;
                hasPart2 = true;
            }

            bool hasTuc = Gear.HasTuc && Gear.Props.TryGetValue(GearPropType.tuc, out value);
            if (Gear.GetBooleanValue(GearPropType.exceptUpgrade))
            {
                TextRenderer.DrawText(g, "Unable to enhance", GearGraphics.EquipDetailFont, new Point(12, picH), Color.White, TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix);
                picH += 15;
            }
            else if (hasTuc)
            {
                GearGraphics.DrawString(g, "Remaining Enhancements: " + value + "\n#c(Available Recoveries: 0)#", GearGraphics.EquipDetailFont, 12, 244, ref picH, 15, orangeColor: ((SolidBrush)GearGraphics.OrangeBrush3).Color);
                //GearGraphics.DrawString(g, "Remaining Enhancements: " + value + (Gear.Cash ? "" : "\n#c(Available Recoveries: 0)#"), GearGraphics.EquipDetailFont, 13, 244, ref picH, 15, orangeColor: ((SolidBrush)GearGraphics.OrangeBrush3).Color); <-- Enable this line when GMS removes the Available Recoveries line for cash items.
                hasPart2 = true;
            }
            if (Gear.Props.TryGetValue(GearPropType.limitBreak, out value) && value > 0) //突破上限
            {
                TextRenderer.DrawText(g, ItemStringHelper.GetGearPropString(GearPropType.limitBreak, value), GearGraphics.EquipDetailFont, new Point(12, picH), ((SolidBrush)GearGraphics.GreenBrush2).Color, TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix);
                picH += 15;
                hasPart2 = true;
            }

            if (!Gear.CanPotential && !Gear.Cash)
            {
                TextRenderer.DrawText(g, "This item cannot gain Potential.", GearGraphics.EquipDetailFont, new Point(12, picH), Color.White, TextFormatFlags.NoPadding);
                picH += 15;
            }
            if (Gear.Props.TryGetValue(GearPropType.fixedPotential, out value) && value > 0)
            {
                TextRenderer.DrawText(g, "Cannot Set Bonus Potential", GearGraphics.EquipDetailFont, new Point(12, picH), Color.White, TextFormatFlags.NoPadding);
                picH += 15;
            }

            //星星锤子
            if (hasTuc && Gear.Hammer > -1 && Gear.GetMaxStar() > 0)
            {
                if (Gear.Hammer == 2)
                {
                    TextRenderer.DrawText(g, "", GearGraphics.EquipDetailFont, new Point(12, picH), Color.White, TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix);
                    picH += 15;
                }
                if (Gear.Props.TryGetValue(GearPropType.superiorEqp, out value) && value > 0) //极真
                {
                    GearGraphics.DrawPlainText(g, ItemStringHelper.GetGearPropString(GearPropType.superiorEqp, value), GearGraphics.EquipDetailFont, ((SolidBrush)GearGraphics.GreenBrush2).Color, 12, 256, ref picH, 15);//GMS - Superior green line change 
                }

                if (!Gear.GetBooleanValue(GearPropType.exceptUpgrade))
                {
                    int maxStar = Gear.GetMaxStar();

                    if (Gear.Star > 0) //星星
                    {
                        //TextRenderer.DrawText(g, "APPLIED " + Gear.Star + " STAR ENHANCEMENT (UP TO " + maxStar + ")", GearGraphics.EquipDetailFont, new Point(11, picH), Color.White, TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix);
                        TextRenderer.DrawText(g, "Star Force:" + Gear.Star + "/" + maxStar + "Stars Infused", GearGraphics.EquipDetailFont, new Point(12, picH), Color.White, TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix);
                        picH += 15;
                    }
                    else
                    {
                        //TextRenderer.DrawText(g, "Can be enhanced up to " + maxStar + " Star.", GearGraphics.EquipDetailFont, new Point(12, picH), Color.White, TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix);
                        //picH += 15;
                    }
                }
                picH += 0;
                TextRenderer.DrawText(g, "Hammers Applied", GearGraphics.EquipDetailFont, new Point(12, picH), Color.White, TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix);
                g.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;
                g.DrawString(": " + Gear.Hammer.ToString() + (Gear.Hammer == 2 ? "(MAX)" : null), GearGraphics.EquipDetailFont, Brushes.White, 93, picH + 1);
                g.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SystemDefault;
                picH += 15;
                hasPart2 = true;
            }

            picH += 3;//original value is '8'. 3 is perfect.

            /*if (hasTuc && Gear.PlatinumHammer > -1)
            {
                g.DrawString("白金锤强化次数:" + Gear.PlatinumHammer, GearGraphics.ItemDetailFont, Brushes.White, 11, picH);// CMS 'Platinum Hammer'
                picH += 16;
                hasPart2 = true;
            }*/

            if (Gear.type == GearType.shovel || Gear.type == GearType.pickaxe)
            {
                string skillName = null;
                switch (Gear.type)
                {
                    case GearType.shovel: skillName = "Herbalism"; break;
                    case GearType.pickaxe: skillName = "Mining"; break;
                }
                if (Gear.Props.TryGetValue(GearPropType.gatherTool_incSkillLevel, out value) && value > 0)
                {
                    TextRenderer.DrawText(g, skillName + " Skill: +" + value, GearGraphics.EquipDetailFont, new Point(12, picH), Color.White, TextFormatFlags.NoPadding);
                    picH += 15;
                    hasPart2 = true;
                }
                if (Gear.Props.TryGetValue(GearPropType.gatherTool_incSpeed, out value) && value > 0)
                {
                    TextRenderer.DrawText(g, skillName + " Speed: +" + value + "%", GearGraphics.EquipDetailFont, new Point(12, picH), Color.White, TextFormatFlags.NoPadding);
                    picH += 15;
                    hasPart2 = true;
                }
                if (Gear.Props.TryGetValue(GearPropType.gatherTool_incNum, out value) && value > 0)
                {
                    TextRenderer.DrawText(g, "Up to " + value + " items can be acquired", GearGraphics.EquipDetailFont, new Point(12, picH), Color.White, TextFormatFlags.NoPadding);
                    picH += 15;
                    hasPart2 = true;
                }
                if (Gear.Props.TryGetValue(GearPropType.gatherTool_reqSkillLevel, out value) && value > 0)
                {
                    TextRenderer.DrawText(g, "Requires " + value + " " + skillName + " Skill ", GearGraphics.EquipDetailFont, new Point(12, picH), Color.White, TextFormatFlags.NoPadding);
                    picH += 15;
                    hasPart2 = true;
                }
            }

            picH += 5;

            //绘制浮动属性
            if ((Gear.VariableStat != null && Gear.VariableStat.Count > 0))
            {
                if (hasPart2) //分割线...
                {
                    picH -= 1;
                    g.DrawImage2(res["dotline"].Image, 0, picH);
                    picH += 8;
                }

                int reqLvl;
                Gear.Props.TryGetValue(GearPropType.reqLevel, out reqLvl);
                TextRenderer.DrawText(g, "Stats increase with Character Level (Up to Lv. " + reqLvl + ")", GearGraphics.EquipDetailFont, new Point(261, picH), ((SolidBrush)GearGraphics.OrangeBrush3).Color, TextFormatFlags.HorizontalCenter);
                picH += 20;

                int reduceLvl;
                Gear.Props.TryGetValue(GearPropType.reduceReq, out reduceLvl);

                int curLevel = charStat == null ? reqLvl : Math.Min(charStat.Level, reqLvl);

                foreach (var kv in Gear.VariableStat)
                {
                    int dLevel = curLevel - reqLvl + reduceLvl;
                    //int addVal = (int)Math.Floor(kv.Value * dLevel);
                    //这里有一个计算上的错误 换方式执行
                    int addVal = (int)Math.Floor(new decimal(kv.Value) * dLevel);
                    string text = ItemStringHelper.GetGearPropString(kv.Key, addVal, 1);
                    text += string.Format(" ({0:f1} x {1})", kv.Value, dLevel);
                    TextRenderer.DrawText(g, text, GearGraphics.EquipDetailFont, new Point(12, picH), ((SolidBrush)GearGraphics.OrangeBrush3).Color, TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix);
                    picH += 20;
                }

                if (hasReduce)
                {
                    TextRenderer.DrawText(g, "When upgrading or enhancing, it will be viewed as  " + reqLvl, GearGraphics.EquipDetailFont, new Point(12, picH), ((SolidBrush)GearGraphics.GrayBrush2).Color, TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix);//text is cut-off in GMS as well, once it is fixed, add >> Lv. << after 'as'.
                    picH += 16;
                }
            }

            //绘制潜能 (Drawing Potential)
            int optionCount = 0;
            foreach (Potential potential in Gear.Options)
            {
                if (potential != null)
                {
                    optionCount++;
                }
            }

            if (optionCount > 0)
            {
                //分割线3号
                if (hasPart2)
                {
                    g.DrawImage2(res["dotline"].Image, 0, picH);
                    picH += 8;
                }
                g.DrawImage(GetAdditionalOptionIcon(Gear.Grade), 9, picH - 2);
                TextRenderer.DrawText(g, "Potential", GearGraphics.EquipDetailFont, new Point(27, picH), ((SolidBrush)GearGraphics.GetPotentialTextBrush(Gear.Grade)).Color, TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix);
                picH += 15;
                foreach (Potential potential in Gear.Options)
                {
                    if (potential != null)
                    {
                        GearGraphics.DrawString(g, potential.ConvertSummary(), GearGraphics.EquipDetailFont2, 12, 244, ref picH, 15);
                        //TextRenderer.DrawText(g, potential.ConvertSummary(), GearGraphics.EquipDetailFont2, new Point(11, picH), Color.White, TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix);
                        //picH += 15;
                    }
                }
            }

            if (hasSocket)
            {
                g.DrawLine(Pens.White, 6, picH, 254, picH);
                picH += 8;
                GearGraphics.DrawString(g, ItemStringHelper.GetGearPropString(GearPropType.nActivatedSocket, 1),
                    GearGraphics.EquipDetailFont, 12, 244, ref picH, 16);
                picH += 3;
            }

            //绘制附加潜能
            int adOptionCount = 0;
            foreach (Potential potential in Gear.AdditionalOptions)
            {
                if (potential != null)
                {
                    adOptionCount++;
                }
            }
            if (adOptionCount > 0)
            {
                //分割线4号
                if (hasPart2)
                {
                    g.DrawImage2(res["dotline"].Image, 0, picH);
                    picH += 8;
                }
                g.DrawImage(GetAdditionalOptionIcon(Gear.AdditionGrade), 9, picH - 2);
                TextRenderer.DrawText(g, "Bonus Potential", GearGraphics.EquipDetailFont, new Point(27, picH), ((SolidBrush)GearGraphics.GetPotentialTextBrush(Gear.AdditionGrade)).Color, TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix);
                picH += 15;

                foreach (Potential potential in Gear.AdditionalOptions)
                {
                    if (potential != null)
                    {
                        GearGraphics.DrawString(g, "+ " + potential.ConvertSummary(), GearGraphics.EquipDetailFont2, 12, 244, ref picH, 15);
                        //TextRenderer.DrawText(g, "+ " + potential.ConvertSummary(), GearGraphics.EquipDetailFont2, new Point(11, picH), Color.White, TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix);
                        //picH += 15;
                    }
                }
                //picH += 5;
            }

            if (Gear.Props.TryGetValue(GearPropType.Etuc, out value) && value > 0)
            {
                //分割线5号
                if (hasPart2)
                {
                    g.DrawImage2(res["dotline"].Image, 0, picH);
                    picH += 8;
                }
                TextRenderer.DrawText(g, "Exceptional Enhancement is possible.  (Max" + "\ntime(s):  " + value + ")", GearGraphics.EquipDetailFont, new Point(13, picH), Color.White, TextFormatFlags.NoPadding);
                picH += 39;
            }

            //绘制desc
            List<string> desc = new List<string>();
            GearPropType[] descTypes = new GearPropType[]{
                GearPropType.tradeAvailable,
                GearPropType.accountShareTag,
                GearPropType.jokerToSetItem,
                GearPropType.plusToSetItem,
                GearPropType.colorvar,
            };
            foreach (GearPropType type in descTypes)
            {
                if (Gear.Props.TryGetValue(type, out value) && value != 0)
                {
                    //desc.Add(" " + ItemStringHelper.GetGearPropString(type, value)); (Korean edit code)
                    desc.Add(ItemStringHelper.GetGearPropString(type, value));
                }
            }

            if (!string.IsNullOrEmpty(Gear.EpicHs) && sr[Gear.EpicHs] != null)
            {
                desc.Add(sr[Gear.EpicHs].Replace("#", " #"));
            }

            //绘制倾向
            if (Gear.State == GearState.itemList)
            {
                string incline = null;
                GearPropType[] inclineTypes = new GearPropType[]{
                    GearPropType.charismaEXP,
                    GearPropType.insightEXP,
                    GearPropType.willEXP,
                    GearPropType.craftEXP,
                    GearPropType.senseEXP,
                    GearPropType.charmEXP };

                string[] inclineString = new string[]{
                    " Ambition"," Insight"," Willpower"," Diligence"," Empathy"," Charm"};

                for (int i = 0; i < inclineTypes.Length; i++)
                {
                    bool success = Gear.Props.TryGetValue(inclineTypes[i], out value);

                    if (inclineTypes[i] == GearPropType.charmEXP && Gear.Cash)
                    {
                        success = true;
                        switch (Gear.type)
                        {
                            case GearType.cashWeapon: value = 60; break;
                            /*case GearType.shield:
                            case GearType.katara: value = 60; break;*/
                            case GearType.cap: value = 50; break;
                            case GearType.cape: value = 30; break;
                            case GearType.longcoat: value = 60; break;
                            case GearType.coat: value = 30; break;
                            case GearType.pants: value = 30; break;
                            case GearType.shoes: value = 40; break;
                            case GearType.glove: value = 40; break;
                            case GearType.earrings: value = 40; break;
                            case GearType.faceAccessory: value = 40; break;
                            case GearType.eyeAccessory: value = 40; break;
                            default: success = false; break;
                        }

                        if (Gear.Props.TryGetValue(GearPropType.cashForceCharmExp, out value2))
                        {
                            success = true;
                            value = value2;
                        }
                    }

                    if (success && value > 0)
                    {
                        incline += ", " + value + inclineString[i];
                        //incline += ", " + value + " " + inclineString[i];
                    }
                }

                /*if (!string.IsNullOrEmpty(Gear.EpicHs) && sr[Gear.EpicHs] != null)
                {
                    desc.Add(sr[Gear.EpicHs].Replace("#", "#"));
                }*/

                desc.Add("");

                if (!string.IsNullOrEmpty(incline))
                {
                    desc.Add("#cGrants " + incline.Substring(2) + " EXP when first equipped (up to the daily maximum).");
                }

                if (Gear.Cash && (!Gear.Props.TryGetValue(GearPropType.noMoveToLocker, out value) || value == 0) && (!Gear.Props.TryGetValue(GearPropType.tradeBlock, out value) || value == 0) && (!Gear.Props.TryGetValue(GearPropType.accountSharable, out value) || value == 0))
                {
                    desc.Add("#cThis item cannot be traded once it has been used.#");
                }

                if (Gear.type != GearType.pickaxe && Gear.type != GearType.shovel && PluginBase.PluginManager.FindWz(string.Format("Effect/ItemEff.img/{0}/effect", Gear.ItemID)) != null)
                {
                    desc.Add("This item does not show in some situations, such as in the #cCharacter Info window.#");
                }

                if (Gear.Props.TryGetValue(GearPropType.noPetEquipStatMoveItem, out value) && value != 0)
                {
                    desc.Add("");
                    desc.Add("You cannot use the Pet Equipment Stat Transfer Scroll on this item.");
                }

                if (desc.Count >= 1 && desc.Last() == "")
                {
                    desc.RemoveAt(desc.Count - 1);
                }
            }

            //判断是否绘制徽章
            Wz_Node medalResNode = null;
            bool willDrawMedalTag = this.ShowMedalTag
                && this.Gear.Props.TryGetValue(GearPropType.medalTag, out value)
                && this.TryGetMedalResource(value, out medalResNode);

            //判断是否绘制技能desc
            string levelDesc = null;
            if (Gear.FixLevel && Gear.Props.TryGetValue(GearPropType.level, out value))
            {
                var levelInfo = Gear.Levels.FirstOrDefault(info => info.Level == value);
                if (levelInfo != null && levelInfo.Prob == levelInfo.ProbTotal && !string.IsNullOrEmpty(levelInfo.HS))
                {
                    levelDesc = sr[levelInfo.HS];
                }
            }

            if (!string.IsNullOrEmpty(sr.Desc) || !string.IsNullOrEmpty(levelDesc) || desc.Count > 0 || Gear.Sample.Bitmap != null || willDrawMedalTag)
            {
                //分割线4号
                if (hasPart2)
                {
                    g.DrawImage2(res["dotline"].Image, 0, picH);
                    picH += 8;
                }
                if (Gear.Sample.Bitmap != null)
                {
                    g.DrawImage2(Gear.Sample.Bitmap, (bitmap.Width - Gear.Sample.Bitmap.Width) / 2, picH);
                    picH += Gear.Sample.Bitmap.Height;
                    picH += 4;
                }
                if (medalResNode != null)
                {
                    //GearGraphics.DrawNameTag(g, medalResNode, sr.Name, bitmap.Width, ref picH);2 juni
                    GearGraphics.DrawNameTag(g, medalResNode, sr.Name.Replace("의 훈장", ""), bitmap.Width, ref picH);
                    picH += 4;
                }
                if (!string.IsNullOrEmpty(sr.Desc))
                {
                    //GearGraphics.DrawString(g, sr.Desc, GearGraphics.EquipDetailFont2, 13, 223, ref picH, 15, ((SolidBrush)GearGraphics.OrangeBrush2).Color);
                    GearGraphics.DrawString(g, sr.Desc, GearGraphics.EquipDetailFont2, 10, 225, ref picH, 15, ((SolidBrush)GearGraphics.OrangeBrush2).Color);
                }
                if (!string.IsNullOrEmpty(levelDesc))
                {
                    //GearGraphics.DrawString(g, " " + levelDesc, GearGraphics.EquipDetailFont2, 11, 245, ref picH, 16, orangeColor: ((SolidBrush)GearGraphics.OrangeBrush2).Color);
                    GearGraphics.DrawString(g, " " + levelDesc, GearGraphics.EquipDetailFont2, 10, 225, ref picH, 16, orangeColor: ((SolidBrush)GearGraphics.OrangeBrush2).Color);
                }
                foreach (string str in desc)
                {
                    //GearGraphics.DrawString(g, str, GearGraphics.EquipDetailFont, 13, 222, ref picH, 15, ((SolidBrush)GearGraphics.OrangeBrush2).Color);
                    GearGraphics.DrawString(g, str, GearGraphics.EquipDetailFont, 10, 225, ref picH, 15, ((SolidBrush)GearGraphics.OrangeBrush2).Color);
                }
                picH += 5;
            }

            foreach (KeyValuePair<int, ExclusiveEquip> kv in CharaSimLoader.LoadedExclusiveEquips)
            {
                if (kv.Value.Items.Contains(Gear.ItemID))
                {
                    /*if (hasPart2)
                    {
                        g.DrawImage(res["dotline"].Image, 0, picH);
                        picH += 8;
                    }*/ //pr - Suppress ExclusiveEquip line for same gear name

                    string exclusiveEquip;
                    if (!string.IsNullOrEmpty(kv.Value.Info))
                    {
                        exclusiveEquip = "#cCannot equip multiple " + kv.Value.Info + " items.#";
                    }
                    else
                    {
                        List<string> itemNames = new List<string>();
                        foreach (int itemID in kv.Value.Items)
                        {
                            StringResult sr2;
                            if (this.StringLinker == null || !this.StringLinker.StringEqp.TryGetValue(itemID, out sr2))
                            {
                                sr2 = new StringResult();
                                sr2.Name = "(null)";
                            }
                            if (!itemNames.Contains(sr2.Name))
                            {
                                itemNames.Add(sr2.Name);
                            }
                        }
                        if (itemNames.Count == 1)
                        {
                            break;
                        }
                        //exclusiveEquip = "#c" + string.Join(", ", itemNames.ToArray()); //pr - Suppress ExclusiveEquip line for same gear name


                        /*char lastCharacter = itemNames.Last().Last();
                        if (lastCharacter >= 44032 && lastCharacter <= 55203 && (lastCharacter - 44032) % 28 == 0)
                            exclusiveEquip = "#cCannot equip multiple " + string.Join(", ", itemNames.ToArray()) + " items.#";
                        else*/ //Only for Korean branch
                        exclusiveEquip = "#cCannot equip multiple " + string.Join(", ", itemNames.ToArray()) + " items.#";
                    }

                    if (hasPart2)
                    {
                        g.DrawImage2(res["dotline"].Image, 0, picH);
                        picH += 8;
                    }
                    GearGraphics.DrawString(g, exclusiveEquip, GearGraphics.EquipDetailFont2, 12, 244, ref picH, 15, orangeColor: ((SolidBrush)GearGraphics.OrangeBrush2).Color);
                    picH += 5;
                    break;
                }
            }

            picH += 2;
            format.Dispose();
            g.Dispose();
            return bitmap;
        }

        private Bitmap RenderAddition(out int picHeight)
        {
            Bitmap addBitmap = null;
            picHeight = 0;
            if (Gear.Additions.Count > 0)
            {
                addBitmap = new Bitmap(261, DefaultPicHeight);
                Graphics g = Graphics.FromImage(addBitmap);
                StringBuilder sb = new StringBuilder();
                foreach (Addition addition in Gear.Additions)
                {
                    string conString = addition.GetConString(), propString = addition.GetPropString();
                    if (!string.IsNullOrEmpty(conString) || !string.IsNullOrEmpty(propString))
                    {
                        sb.Append("- ");
                        if (!string.IsNullOrEmpty(conString))
                            sb.AppendLine(conString);
                        if (!string.IsNullOrEmpty(propString))
                            sb.AppendLine(propString);
                        sb.AppendLine();
                    }
                }
                if (sb.Length > 0)
                {
                    picHeight = 10;
                    GearGraphics.DrawString(g, sb.ToString(), GearGraphics.EquipDetailFont, 12, 250, ref picHeight, 15);
                }
                g.Dispose();
            }
            return addBitmap;
        }

        private Bitmap RenderSetItem(out int picHeight)
        {
            Bitmap setBitmap = null;
            int setID;
            picHeight = 0;
            if (Gear.Props.TryGetValue(GearPropType.setItemID, out setID))
            {
                SetItem setItem;
                if (!CharaSimLoader.LoadedSetItems.TryGetValue(setID, out setItem))
                    return null;

                TooltipRender renderer = this.SetItemRender;
                if (renderer == null)
                {
                    var defaultRenderer = new SetItemTooltipRender();
                    defaultRenderer.StringLinker = this.StringLinker;
                    defaultRenderer.ShowObjectID = false;
                    renderer = defaultRenderer;
                }

                renderer.TargetItem = setItem;
                setBitmap = renderer.Render();
                if (setBitmap != null)
                    picHeight = setBitmap.Height;
            }
            return setBitmap;
        }

        private Bitmap RenderLevelOrSealed(out int picHeight)
        {
            Bitmap levelOrSealed = null;
            Graphics g = null;
            StringFormat format = new StringFormat();
            format.Alignment = StringAlignment.Center;
            picHeight = 0;
            if (Gear.Levels != null)
            {
                if (levelOrSealed == null)
                {
                    levelOrSealed = new Bitmap(261, DefaultPicHeight);
                    g = Graphics.FromImage(levelOrSealed);
                }
                picHeight += 13;
                TextRenderer.DrawText(g, "Growth Stats", GearGraphics.EquipDetailFont, new Point(261, picHeight), ((SolidBrush)GearGraphics.GreenBrush2).Color, TextFormatFlags.HorizontalCenter);
                picHeight += 15;
                if (Gear.FixLevel)
                {
                    TextRenderer.DrawText(g, "[Fixed level at acquisition]", GearGraphics.EquipDetailFont, new Point(261, picHeight), ((SolidBrush)GearGraphics.OrangeBrush).Color, TextFormatFlags.HorizontalCenter);
                    picHeight += 16;
                }

                for (int i = 0; i < Gear.Levels.Count; i++)
                {
                    var info = Gear.Levels[i];
                    TextRenderer.DrawText(g, "Level " + info.Level + (i >= Gear.Levels.Count - 1 ? " (MAX)" : null), GearGraphics.EquipDetailFont, new Point(12, picHeight), ((SolidBrush)GearGraphics.GreenBrush2).Color, TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix);
                    picHeight += 15;
                    foreach (var kv in info.BonusProps)
                    {
                        GearLevelInfo.Range range = kv.Value;

                        string propString = ItemStringHelper.GetGearPropString(kv.Key, kv.Value.Min);
                        if (propString != null)
                        {
                            if (range.Max != range.Min)
                            {
                                propString += " ~ " + kv.Value.Max + (propString.EndsWith("%") ? "%" : null);
                            }
                            TextRenderer.DrawText(g, propString, GearGraphics.EquipDetailFont, new Point(12, picHeight), Color.White, TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix);
                            picHeight += 15;
                        }
                    }
                    if (info.Skills.Count > 0)
                    {
                        string title = string.Format("{2:P2} ({0}/{1}) chance to obtain a skill:", info.Prob, info.ProbTotal, info.Prob * 1.0 / info.ProbTotal);
                        TextRenderer.DrawText(g, title, GearGraphics.EquipDetailFont, new Point(12, picHeight), Color.White, TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix);
                        picHeight += 15;
                        foreach (var kv in info.Skills)
                        {
                            StringResult sr = null;
                            if (this.StringLinker != null)
                            {
                                this.StringLinker.StringSkill.TryGetValue(kv.Key, out sr);
                            }
                            string text = string.Format("+{2} {0}", sr == null ? null : sr.Name, kv.Key, kv.Value);
                            TextRenderer.DrawText(g, text, GearGraphics.EquipDetailFont, new Point(12, picHeight), ((SolidBrush)GearGraphics.OrangeBrush).Color, TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix);
                            picHeight += 15;
                        }
                    }
                    if (info.EquipmentSkills.Count > 0)
                    {
                        string title;
                        if (info.Prob < info.ProbTotal)
                        {
                            title = string.Format("Have {2:P2}({0}/{1}) chance to obtain skill:", info.Prob, info.ProbTotal, info.Prob * 1.0 / info.ProbTotal);
                        }
                        else
                        {
                            title = "Skill obtained when equipped:";
                        }
                        TextRenderer.DrawText(g, title, GearGraphics.EquipDetailFont, new Point(10, picHeight), Color.White, TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix);
                        picHeight += 15;
                        foreach (var kv in info.EquipmentSkills)
                        {
                            StringResult sr = null;
                            if (this.StringLinker != null)
                            {
                                this.StringLinker.StringSkill.TryGetValue(kv.Key, out sr);
                            }
                            string text = string.Format("Lv{2} {0}", sr == null ? null : sr.Name, kv.Key, kv.Value);
                            TextRenderer.DrawText(g, text, GearGraphics.EquipDetailFont, new Point(10, picHeight), ((SolidBrush)GearGraphics.OrangeBrush).Color, TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix);
                            picHeight += 15;
                        }
                    }
                    if (info.Exp > 0)
                    {
                        TextRenderer.DrawText(g, "Required EXP : " + info.Exp + "%", GearGraphics.EquipDetailFont, new Point(12, picHeight), Color.White, TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix);
                        picHeight += 15;
                    }
                    if (info.Point > 0 && info.DecPoint > 0)
                    {
                        TextRenderer.DrawText(g, "Required Anti-magic : " + info.Point + " (-" + info.DecPoint + " daily)", GearGraphics.EquipDetailFont, new Point(12, picHeight), Color.White, TextFormatFlags.NoPadding);
                        picHeight += 15;
                    }

                    picHeight += 2;
                }
            }

            if (Gear.Seals != null)
            {
                if (levelOrSealed == null)
                {
                    levelOrSealed = new Bitmap(261, DefaultPicHeight);
                    g = Graphics.FromImage(levelOrSealed);
                }
                picHeight += 13;
                TextRenderer.DrawText(g, "Unsealed Stats", GearGraphics.EquipDetailFont, new Point(261, picHeight), ((SolidBrush)GearGraphics.GreenBrush2).Color, TextFormatFlags.HorizontalCenter);
                picHeight += 16;
                for (int i = 0; i < Gear.Seals.Count; i++)
                {
                    var info = Gear.Seals[i];

                    TextRenderer.DrawText(g, "Level" + info.Level + (i >= Gear.Seals.Count - 1 ? "(MAX)" : null), GearGraphics.EquipDetailFont, new Point(10, picHeight), ((SolidBrush)GearGraphics.GreenBrush2).Color, TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix);
                    picHeight += 16;
                    var props = this.IsCombineProperties ? Gear.CombineProperties(info.BonusProps) : info.BonusProps;
                    foreach (var kv in props)
                    {
                        string propString = ItemStringHelper.GetGearPropString(kv.Key, kv.Value);
                        TextRenderer.DrawText(g, propString, GearGraphics.EquipDetailFont, new Point(10, picHeight), Color.White, TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix);
                        picHeight += 16;
                    }
                    if (info.HasIcon)
                    {
                        Bitmap icon = info.Icon.Bitmap ?? info.IconRaw.Bitmap;
                        if (icon != null)
                        {
                            TextRenderer.DrawText(g, "Icon : ", GearGraphics.EquipDetailFont, new Point(10, picHeight + icon.Height / 2 - 6), Color.White, TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix);
                            g.DrawImage2(icon, 52, picHeight);
                            picHeight += icon.Height;
                        }
                    }
                    if (info.Exp > 0)
                    {
                        TextRenderer.DrawText(g, "Required EXP : " + info.Exp + "%", GearGraphics.EquipDetailFont, new Point(10, picHeight), Color.White, TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix);
                        picHeight += 16;
                    }
                    picHeight += 2;
                }
            }


            format.Dispose();
            if (g != null)
            {
                g.Dispose();
                picHeight += 13;
            }
            return levelOrSealed;
        }

        private void FillRect(Graphics g, TextureBrush brush, int x, int y0, int y1)
        {
            brush.ResetTransform();
            brush.TranslateTransform(x, y0);
            g.FillRectangle(brush, x, y0, brush.Image.Width, y1 - y0);
        }

        private List<string> GetGearAttributeString()
        {
            int value;
            List<string> tags = new List<string>();

            if (Gear.Props.TryGetValue(GearPropType.only, out value) && value != 0)
            {
                tags.Add(ItemStringHelper.GetGearPropString(GearPropType.only, value));
            }
            if (Gear.Props.TryGetValue(GearPropType.tradeBlock, out value) && value != 0)
            {
                tags.Add(ItemStringHelper.GetGearPropString(GearPropType.tradeBlock, value));
            }
            if (Gear.Props.TryGetValue(GearPropType.onlyEquip, out value) && value != 0)
            {
                tags.Add(ItemStringHelper.GetGearPropString(GearPropType.onlyEquip, value));
            }
            if (Gear.Props.TryGetValue(GearPropType.abilityTimeLimited, out value) && value != 0)
            {
                tags.Add(ItemStringHelper.GetGearPropString(GearPropType.abilityTimeLimited, value));
                tags.Add(ItemStringHelper.GetGearPropString(GearPropType.notExtend, value));
            }
            if (Gear.Props.TryGetValue(GearPropType.equipTradeBlock, out value) && value != 0)
            {
                if (Gear.State == GearState.itemList)
                {
                    tags.Add(ItemStringHelper.GetGearPropString(GearPropType.equipTradeBlock, value));
                }
                else
                {
                    string tradeBlock = ItemStringHelper.GetGearPropString(GearPropType.tradeBlock, 1);
                    if (!tags.Contains(tradeBlock))
                        tags.Add(tradeBlock);
                }
            }
            if (Gear.Props.TryGetValue(GearPropType.accountSharable, out value) && value != 0)
            {
                int value2;
                if (Gear.Props.TryGetValue(GearPropType.sharableOnce, out value2) && value2 != 0)
                {
                    //tags.Add(ItemStringHelper.GetGearPropString(GearPropType.sharableOnce, value2));
                    tags.AddRange(ItemStringHelper.GetGearPropString(GearPropType.sharableOnce, value2).Split('\n'));
                }
                else
                {
                    tags.Add(ItemStringHelper.GetGearPropString(GearPropType.accountSharable, value));
                }
            }
            if (Gear.Props.TryGetValue(GearPropType.blockGoldHammer, out value) && value != 0)
            {
                tags.Add(ItemStringHelper.GetGearPropString(GearPropType.blockGoldHammer, value));
            }
            //if (Gear.Props.TryGetValue(GearPropType.noPotential, out value) && value != 0)
            //{
            //    tags.Add(ItemStringHelper.GetGearPropString(GearPropType.noPotential, value));
            //}
            if ((Gear.Props.TryGetValue(GearPropType.fixedPotential, out value) && value != 0) || (Gear.Props.TryGetValue(GearPropType.fixedGrade, out value) && value != 0))
            {
                tags.Add(ItemStringHelper.GetGearPropString(GearPropType.fixedPotential, value));
            }
            if (Gear.Props.TryGetValue(GearPropType.notExtend, out value) && value != 0)
            {
                tags.Add(ItemStringHelper.GetGearPropString(GearPropType.notExtend, value));
            }
            if (Gear.Props.TryGetValue(GearPropType.cantRepair, out value) && value != 0)
            {
                tags.Add(ItemStringHelper.GetGearPropString(GearPropType.cantRepair, value));
            }
            if (Gear.Props.TryGetValue(GearPropType.noLookChange, out value) && value != 0)
            {
                tags.Add(ItemStringHelper.GetGearPropString(GearPropType.noLookChange, value));
            }
            if ((Gear.ItemID / 10000 >= 161 && Gear.ItemID / 10000 <= 165) || (Gear.ItemID / 10000 >= 194 && Gear.ItemID / 10000 <= 197))
            {
                tags.Add("Cannot use Fusion Anvil");//Unable to use anvil > change when GMS adds this line to mechanic, dragon gears
            }

            return tags;
        }

        private Bitmap GetAlienStoneIcon()
        {
            if (Gear.AlienStoneSlot == null)
            {
                return Resource.ToolTip_Equip_AlienStone_Empty;
            }
            else
            {
                switch (Gear.AlienStoneSlot.Grade)
                {
                    case AlienStoneGrade.Normal:
                        return Resource.ToolTip_Equip_AlienStone_Normal;
                    case AlienStoneGrade.Rare:
                        return Resource.ToolTip_Equip_AlienStone_Rare;
                    case AlienStoneGrade.Epic:
                        return Resource.ToolTip_Equip_AlienStone_Epic;
                    case AlienStoneGrade.Unique:
                        return Resource.ToolTip_Equip_AlienStone_Unique;
                    case AlienStoneGrade.Legendary:
                        return Resource.ToolTip_Equip_AlienStone_Legendary;
                    default:
                        return null;
                }
            }
        }

        private void DrawGearReq(Graphics g, int x, int y)
        {
            int value;
            bool can;
            NumberType type;
            Size size;
            //需求等级
            this.Gear.Props.TryGetValue(GearPropType.reqLevel, out value);
            int reduceReq = 0;
            {
                this.Gear.Props.TryGetValue(GearPropType.reduceReq, out reduceReq);
            }
            int value2 = Math.Max(0, value - reduceReq);
            can = this.charStat == null || this.charStat.Level >= value2;
            type = GetReqType(can, value2);
            g.DrawImage2(FindReqImage(type, "reqLEV", out size), x, y);
            //DrawReqNum(g, value.ToString().PadLeft(3), (type == NumberType.Can ? NumberType.YellowNumber : type), x + 54, y, StringAlignment.Near);
            int levX = DrawReqNum(g, value2.ToString().PadLeft(3), (type == NumberType.Can ? NumberType.YellowNumber : type), x + 54, y, StringAlignment.Near);
            if (reduceReq != 0)
            {
                DrawReqNum(g, $"({value.ToString()}-{reduceReq.ToString()})", NumberType.Can, levX + 2, y, StringAlignment.Near);
                DrawReqNum(g, $"({value.ToString()}-{reduceReq.ToString()}", NumberType.YellowNumber, levX + 2, y, StringAlignment.Near);
                DrawReqNum(g, $"({value.ToString()}", NumberType.Can, levX + 2, y, StringAlignment.Near);
            }

            //需求人气
            this.Gear.Props.TryGetValue(GearPropType.reqPOP, out value);
            can = this.charStat == null || this.charStat.Pop >= value;
            type = GetReqType(can, value);
            if (value > 0)
            {
                g.DrawImage2(FindReqImage(type, "reqPOP", out size), x + 80, y);
                DrawReqNum(g, value.ToString("D3"), type, x + 80 + 54, y, StringAlignment.Near);
            }

            y += 15;

            //需求力量
            this.Gear.Props.TryGetValue(GearPropType.reqSTR, out value);
            can = this.charStat == null || this.charStat.Strength.GetSum() >= value;
            type = GetReqType(can, value);
            g.DrawImage2(FindReqImage(type, "reqSTR", out size), x, y);
            DrawReqNum(g, value.ToString("D3"), type, x + 54, y, StringAlignment.Near);


            //需求运气
            this.Gear.Props.TryGetValue(GearPropType.reqLUK, out value);
            can = this.charStat == null || this.charStat.Luck.GetSum() >= value;
            type = GetReqType(can, value);
            g.DrawImage2(FindReqImage(type, "reqLUK", out size), x + 80, y);
            DrawReqNum(g, value.ToString("D3"), type, x + 80 + 54, y, StringAlignment.Near);

            y += 9;

            //需求敏捷
            this.Gear.Props.TryGetValue(GearPropType.reqDEX, out value);
            can = this.charStat == null || this.charStat.Dexterity.GetSum() >= value;
            type = GetReqType(can, value);
            g.DrawImage2(FindReqImage(type, "reqDEX", out size), x, y);
            DrawReqNum(g, value.ToString("D3"), type, x + 54, y, StringAlignment.Near);

            //需求智力
            this.Gear.Props.TryGetValue(GearPropType.reqINT, out value);
            can = this.charStat == null || this.charStat.Intelligence.GetSum() >= value;
            type = GetReqType(can, value);
            g.DrawImage2(FindReqImage(type, "reqINT", out size), x + 80, y);
            DrawReqNum(g, value.ToString("D3"), type, x + 80 + 54, y, StringAlignment.Near);
        }

        private void DrawPropDiffEx(Graphics g, int x, int y)
        {
            int value;
            string numValue;
            //Defense tooltip icon
            g.DrawImage2(Resource.UIToolTip_img_Item_Equip_Summary_icon_pdd, x, y);
            x += 62;
            DrawReqNum(g, "0", NumberType.LookAhead, x - 5, y + 6, StringAlignment.Far);

            //Boss DMG tooltip icon
            g.DrawImage2(Resource.UIToolTip_img_Item_Equip_Summary_icon_bdr, x, y);
            x += 62;
            this.Gear.Props.TryGetValue(GearPropType.bdR, out value);
            numValue = (value > 0 ? "+ " : null) + value + " % ";
            DrawReqNum(g, numValue, NumberType.LookAhead, x - 5 + 3, y + 6, StringAlignment.Far);
            //DrawReqNum(g, numValue, NumberType.LookAhead, x - 1, y + 6, StringAlignment.Far);

            //Ignored Monster DEF tooltip icon
            g.DrawImage2(Resource.UIToolTip_img_Item_Equip_Summary_icon_igpddr, x, y);
            x += 62;
            this.Gear.Props.TryGetValue(GearPropType.imdR, out value);
            numValue = (value > 0 ? "+ " : null) + value + " % ";
            DrawReqNum(g, numValue, NumberType.LookAhead, x - 5 - 1, y + 6, StringAlignment.Far);
            //DrawReqNum(g, numValue, NumberType.LookAhead, x - 5, y + 6, StringAlignment.Far);
        }

        private void DrawJobReq(Graphics g, ref int picH)
        {
            int value;
            string extraReq = ItemStringHelper.GetExtraJobReqString(Gear.type) ??
                (Gear.Props.TryGetValue(GearPropType.reqSpecJob, out value) ? ItemStringHelper.GetExtraJobReqString(value) : null);
            Image jobImage = extraReq == null ? Resource.UIToolTip_img_Item_Equip_Job_normal : Resource.UIToolTip_img_Item_Equip_Job_expand;
            g.DrawImage2(jobImage, 10, picH);

            int reqJob;
            Gear.Props.TryGetValue(GearPropType.reqJob, out reqJob);
            int[] origin = new int[] { 14, 7, 56, 7, 95, 7, 135, 7, 166, 10, 198, 10 };//翻译改动
            int[] origin2 = new int[] { 10, 6, 44, 6, 79, 6, 126, 6, 166, 6, 201, 6 };
            for (int i = 0; i <= 5; i++)
            {
                bool enable;
                if (i == 0)
                {
                    enable = reqJob <= 0;
                    if (reqJob == 0) reqJob = 0x1f;//0001 1111
                    if (reqJob == -1) reqJob = 0; //0000 0000
                }
                else
                {
                    enable = (reqJob & (1 << (i - 1))) != 0;
                }
                if (enable)
                {
                    enable = this.charStat == null || Character.CheckJobReq(this.charStat.Job, i);
                    Image jobImage2 = Resource.ResourceManager.GetObject("UIToolTip_img_Item_Equip_Job_" + (enable ? "enable" : "disable") + "_" + i.ToString()) as Image;
                    if (jobImage != null)
                    {
                        if (enable)
                            g.DrawImage2(jobImage2, 10 + origin[i * 2], picH + origin[i * 2 + 1]);
                        else
                            g.DrawImage2(jobImage2, 10 + origin2[i * 2], picH + origin2[i * 2 + 1]);
                    }
                }
            }
            if (extraReq != null)
            {
                StringFormat format = new StringFormat();
                format.Alignment = StringAlignment.Center;
                TextRenderer.DrawText(g, extraReq, GearGraphics.EquipDetailFont, new Point(261, picH + 24), ((SolidBrush)GearGraphics.OrangeBrush3).Color, TextFormatFlags.HorizontalCenter);
                format.Dispose();
            }
            picH += jobImage.Height + 9;
        }

        private Image FindReqImage(NumberType type, string req, out Size size)
        {
            Image image = Resource.ResourceManager.GetObject("UIToolTip_img_Item_Equip_" + type.ToString() + "_" + req) as Image;
            if (image != null)
                size = image.Size;
            else
                size = Size.Empty;
            return image;
        }

        private void DrawStar(Graphics g, ref int picH)
        {
            if (Gear.Star > 0)
            {
                int totalWidth = Gear.Star * 10 + (Gear.Star / 5 - 1) * 6;
                int dx = 130 - totalWidth / 2;
                for (int i = 0; i < Gear.Star; i++)
                {
                    g.DrawImage2(Resource.UIToolTip_img_Item_Equip_Star_Star, dx, picH);
                    dx += 10;
                    if (i > 0 && i % 5 == 4)
                    {
                        dx += 6;
                    }
                }
                picH += 18;
            }
        }

        private void DrawStar2(Graphics g, ref int picH)
        {
            //int maxStar = Gear.GetMaxStar();
            int maxStar = Math.Max(Gear.GetMaxStar(), Gear.Star);
            if (maxStar > 0)
            {
                for (int i = 0; i < maxStar; i += 15)
                {
                    int starLine = Math.Min(maxStar - i, 15);
                    int totalWidth = starLine * 10 + (starLine / 5 - 1) * 6;
                    int dx = 130 - totalWidth / 2;
                    for (int j = 0; j < starLine; j++)
                    {
                        g.DrawImage2((i + j < Gear.Star) ?
                            Resource.UIToolTip_img_Item_Equip_Star_Star : Resource.UIToolTip_img_Item_Equip_Star_Star0,
                            dx, picH);
                        dx += 10;
                        if (j > 0 && j % 5 == 4)
                        {
                            dx += 6;
                        }
                    }
                    picH += 18;
                }
                picH -= 1;
            }
        }

        private NumberType GetReqType(bool can, int reqValue)
        {
            if (reqValue <= 0)
                return NumberType.Disabled;
            if (can)
                return NumberType.Can;
            else
                return NumberType.Cannot;
        }

        private int DrawReqNum(Graphics g, string numString, NumberType type, int x, int y, StringAlignment align)
        {
            if (g == null || numString == null || align == StringAlignment.Center)
                return x;
            int spaceWidth = type == NumberType.LookAhead ? 3 : 6;
            bool near = align == StringAlignment.Near;

            for (int i = 0; i < numString.Length; i++)
            {
                char c = near ? numString[i] : numString[numString.Length - i - 1];
                Image image = null;
                Point origin = Point.Empty;
                switch (c)
                {
                    case ' ':
                        break;
                    case '+':
                        image = Resource.ResourceManager.GetObject("UIToolTip_img_Item_Equip_" + type.ToString() + "_" + "plus") as Image;
                        break;
                    case '-':
                        image = Resource.ResourceManager.GetObject("UIToolTip_img_Item_Equip_" + type.ToString() + "_" + "minus") as Image;
                        origin.Y = 2;
                        break;
                    case '%':
                        image = Resource.ResourceManager.GetObject("UIToolTip_img_Item_Equip_" + type.ToString() + "_" + "percent") as Image;
                        break;
                    case '(':
                        image = Resource.ResourceManager.GetObject("UIToolTip_img_Item_Equip_" + type.ToString() + "_" + "leftParenthesis") as Image;
                        break;
                    case ')':
                        image = Resource.ResourceManager.GetObject("UIToolTip_img_Item_Equip_" + type.ToString() + "_" + "rightParenthesis") as Image;
                        break;
                    default:
                        if ('0' <= c && c <= '9')
                        {
                            image = Resource.ResourceManager.GetObject("UIToolTip_img_Item_Equip_" + type.ToString() + "_" + c) as Image;
                            if (c == '1' && type == NumberType.LookAhead)
                            {
                                origin.X = 1;
                            }
                        }
                        break;
                }

                if (image != null)
                {
                    if (near)
                    {
                        g.DrawImage2(image, x + origin.X, y + origin.Y);
                        x += image.Width + origin.X + 1;
                    }
                    else
                    {
                        x -= image.Width + origin.X;
                        g.DrawImage2(image, x + origin.X, y + origin.Y);
                        x -= 1;
                    }
                }
                else //空格补位
                {
                    x += spaceWidth * (near ? 1 : -1);
                }
            }
            return x;
        }

        private Image GetAdditionalOptionIcon(GearGrade grade)
        {
            switch (grade)
            {
                default:
                case GearGrade.B: return Resource.AdditionalOptionTooltip_rare;
                case GearGrade.A: return Resource.AdditionalOptionTooltip_epic;
                case GearGrade.S: return Resource.AdditionalOptionTooltip_unique;
                case GearGrade.SS: return Resource.AdditionalOptionTooltip_legendary;
            }
        }

        private bool TryGetMedalResource(int medalTag, out Wz_Node resNode)
        {
            resNode = PluginBase.PluginManager.FindWz("UI/NameTag.img/medal/" + medalTag);
            return resNode != null;
        }

        private enum NumberType
        {
            Can,
            Cannot,
            Disabled,
            LookAhead,
            YellowNumber,
        }
    }
}
```

`MapleNecrocer/CharaSimControl/HelpTooltipRender.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Text.RegularExpressions;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Linq;
using System.Windows.Forms;
using Resource = CharaSimResource.Resource;
using WzComparerR2.PluginBase;
using WzComparerR2.WzLib;
using WzComparerR2.Common;
using WzComparerR2.CharaSim;

namespace WzComparerR2.CharaSimControl
{
    public class HelpTooltipRender : TooltipRender
    {
        public HelpTooltipRender()
        {
        }

        public TooltipHelp Pair { get; set; }

        public override object TargetItem
        {
            get { return this.Pair; }
            set { this.Pair = value as TooltipHelp; }
        }

        public override Bitmap Render()
        {
            int picHeight;
            Bitmap originBmp = RenderHelp(out picHeight);
            Bitmap tooltip = new Bitmap(originBmp.Width, picHeight);
            Graphics g = Graphics.FromImage(tooltip);

            //绘制背景区域
            GearGraphics.DrawNewTooltipBack(g, 0, 0, tooltip.Width, tooltip.Height);

            //复制图像
            g.DrawImage(originBmp, 0, 0, new Rectangle(0, 0, tooltip.Width, picHeight), GraphicsUnit.Pixel);

            if (originBmp != null)
                originBmp.Dispose();

            g.Dispose();
            return tooltip;
        }

        private Bitmap RenderHelp(out int picH)
        {
            Bitmap helpBitmap = new Bitmap(270, DefaultPicHeight);
            Graphics g = Graphics.FromImage(helpBitmap);
            StringFormat format = new StringFormat();
            format.Alignment = StringAlignment.Center;

            picH = 10;
            TextRenderer.DrawText(g, Pair.Title, GearGraphics.ItemNameFont2, new Point(helpBitmap.Width, 10), Color.White, TextFormatFlags.HorizontalCenter);
            picH += 22;

            GearGraphics.DrawString(g, string.Format(Pair.Desc, 0), GearGraphics.ItemDetailFont2, 10, 252, ref picH, 16);

            picH += 4;
            format.Dispose();
            g.Dispose();
            return helpBitmap;
        }
    }
}

```

`MapleNecrocer/CharaSimControl/ItemMouseEventArgs.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Windows.Forms;
using WzComparerR2.CharaSim;

namespace WzComparerR2.CharaSimControl
{
    public class ItemMouseEventArgs : MouseEventArgs
    {
        public ItemMouseEventArgs(MouseEventArgs e, ItemBase item)
            : this(e.Button, e.Clicks, e.X, e.Y, e.Delta, item)
        {
        }

        public ItemMouseEventArgs(MouseButtons button, int clicks, int x, int y, int delta, ItemBase item) :
            base(button, clicks, x, y, delta)
        {
            this.item = item;
        }

        private ItemBase item;

        public ItemBase Item
        {
            get { return item; }
            set { item = value; }
        }
    }
}

```

`MapleNecrocer/CharaSimControl/ItemMouseEventHandler.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace WzComparerR2.CharaSimControl
{
    public delegate void ItemMouseEventHandler(object sender, ItemMouseEventArgs e);
}

```

`MapleNecrocer/CharaSimControl/ItemTooltipRender.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;
using System.Drawing.Drawing2D;
using CharaSimResource;
using WzComparerR2.Common;
using WzComparerR2.CharaSim;

namespace WzComparerR2.CharaSimControl
{
    public class ItemTooltipRender:TooltipRender
    {
        public ItemTooltipRender()
        {
        }

        private Item item;

        public Item Item
        {
            get { return item; }
            set { item = value; }
        }

        public override Bitmap Render()
        {
            if (this.item == null)
            {
                return null;
            }
            int picHeight, iconY;
            Bitmap originBmp = renderItem(out picHeight, out iconY);
            Bitmap tooltip = new Bitmap(290, picHeight);
            Graphics g = Graphics.FromImage(tooltip);

            //复制图像
            g.FillRectangle(GearGraphics.GearBackBrush, 2, 2, 286, picHeight - 4);
            g.CompositingMode = CompositingMode.SourceCopy;
            g.FillRectangle(GearGraphics.GearIconBackBrush, 14, iconY, 68, 68);
            g.CompositingMode = CompositingMode.SourceOver;
            g.DrawImage(originBmp, 0, 0, new Rectangle(0, 0, 290, picHeight - 2), GraphicsUnit.Pixel);
            //绘制外边框
            g.DrawLines(GearGraphics.GearBackPen, GearGraphics.GetBorderPath(0, 290, picHeight));

            //GearGraphics.DrawGearDetailNumber(g, 2, 2, item.ItemID.ToString("d8"), true);

            g.Dispose();
            return tooltip;
        }

        private Bitmap renderItem(out int picHeight, out int iconY)
        {
            Bitmap tooltip = new Bitmap(290, DefaultPicHeight);
            Graphics g = Graphics.FromImage(tooltip);
            StringFormat format = new StringFormat();
            int value;
            format.Alignment = StringAlignment.Center;
            picHeight = 10;
            iconY = 32;

            //物品标题
            StringResult sr;
            if (StringLinker == null || !StringLinker.StringItem.TryGetValue(item.ItemID, out sr))
            {
                sr = new StringResult();
                sr.Name = "(null)";
            }
            string gearName = sr.Name;
            g.DrawString(gearName, GearGraphics.ItemNameFont, Brushes.White, 145, picHeight, format);//绘制装备名称
            picHeight += 21;
            string attr = GetItemAttributeString();
            if (!string.IsNullOrEmpty(attr))
            {
                g.DrawString(attr, GearGraphics.ItemDetailFont, GearGraphics.OrangeBrush4, 145, picHeight, format);
                iconY += 19;
            }

            //绘制图标
            if (item.Icon.Bitmap != null)
            {
                g.DrawImage(GearGraphics.EnlargeBitmap(item.Icon.Bitmap),
                    14 + (1 - item.Icon.Origin.X) * 2,
                    iconY + (33 - item.Icon.Origin.Y) * 2);
            }
            if (item.Cash)
            {
                g.DrawImage(GearGraphics.EnlargeBitmap(Resource.CashItem_0),
                    14 + 68 - 26,
                    iconY + 68 - 26);
            }

            picHeight = iconY;
            if (item.Props.TryGetValue(ItemPropType.reqLevel, out value))
            {
                g.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAliasGridFit;
                g.PixelOffsetMode = PixelOffsetMode.HighQuality;
                g.DrawString("Required Level : " + value, GearGraphics.ItemReqLevelFont, Brushes.White, 92, picHeight);
                picHeight += 15;
                g.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SystemDefault;
            }
            else
            {
                picHeight += 3;
            }
            if (!string.IsNullOrEmpty(sr.Desc))
            {
                GearGraphics.DrawString(g, sr.Desc + sr.AutoDesc, GearGraphics.ItemDetailFont, 92, 272, ref picHeight, 16);
            }
            if (item.Props.TryGetValue(ItemPropType.tradeAvailable, out value) && value > 0)
            {
                attr = ItemStringHelper.GetItemPropString(ItemPropType.tradeAvailable, value);
                if (!string.IsNullOrEmpty(attr))
                    GearGraphics.DrawString(g, "#c" + attr + "#", GearGraphics.ItemDetailFont, 92, 272, ref picHeight, 16);
            }
            picHeight = Math.Max(iconY + 84, iconY + 16 * (int)Math.Ceiling((picHeight - iconY) / 16.0));
            return tooltip;
        }

        private string GetItemAttributeString()
        {
            int value;
            List<string> tags = new List<string>();

            if (item.Props.TryGetValue(ItemPropType.quest, out value) && value != 0)
            {
                tags.Add(ItemStringHelper.GetItemPropString(ItemPropType.quest, value));
            }
            if (item.Props.TryGetValue(ItemPropType.pquest, out value) && value != 0)
            {
                tags.Add(ItemStringHelper.GetItemPropString(ItemPropType.pquest, value));
            }
            if (item.Props.TryGetValue(ItemPropType.only, out value) && value != 0)
            {
                tags.Add(ItemStringHelper.GetItemPropString(ItemPropType.only, value));
            }
            if (item.Props.TryGetValue(ItemPropType.tradeBlock, out value) && value != 0)
            {
                tags.Add(ItemStringHelper.GetItemPropString(ItemPropType.tradeBlock, value));
            }
            if (item.Props.TryGetValue(ItemPropType.accountSharable, out value) && value != 0)
            {
                tags.Add(ItemStringHelper.GetItemPropString(ItemPropType.accountSharable, value));
            }

            return tags.Count > 0 ? string.Join(", ", tags.ToArray()) : null;
        }
    }
}

```

`MapleNecrocer/CharaSimControl/ItemTooltipRender2.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Windows.Forms;
using Resource = CharaSimResource.Resource;
using WzComparerR2.PluginBase;
using WzComparerR2.WzLib;
using WzComparerR2.Common;
using WzComparerR2.CharaSim;
using GraphicsExtension;
using DPIUtils;

namespace WzComparerR2.CharaSimControl
{
    public class ItemTooltipRender2 : TooltipRender
    {
        public ItemTooltipRender2()
        {
        }

        private Item item;

        public Item Item
        {
            get { return item; }
            set { item = value; }
        }

        public override object TargetItem
        {
            get
            {
                return this.item;
            }
            set
            {
                this.item = value as Item;
            }
        }


        public bool LinkRecipeInfo { get; set; }
        public bool LinkRecipeItem { get; set; }
        public bool ShowLevelOrSealed { get; set; }
        public bool ShowNickTag { get; set; }

        public TooltipRender LinkRecipeInfoRender { get; set; }
        public TooltipRender LinkRecipeGearRender { get; set; }
        public TooltipRender LinkRecipeItemRender { get; set; }
        public TooltipRender SetItemRender { get; set; }
        public TooltipRender CashPackageRender { get; set; }

        public override Bitmap Render()
        {
            if (this.item == null)
            {
                return null;
            }
            //绘制道具
            int picHeight;
            Bitmap itemBmp = RenderItem(out picHeight);
            Bitmap recipeInfoBmp = null;
            List<Bitmap> recipeItemBmps = new List<Bitmap>();
            Bitmap setItemBmp = null;
            Bitmap levelBmp = null;
            int levelHeight = 0;
            if (this.ShowLevelOrSealed)
            {
                levelBmp = RenderLevel(out levelHeight);
            }

            if (this.item.ItemID / 10000 == 910)
            {
                Wz_Node itemNode = PluginBase.PluginManager.FindWz(string.Format(@"Item\Special\{0:D4}.img\{1}", this.item.ItemID / 10000, this.item.ItemID));
                Wz_Node cashPackageNode = PluginBase.PluginManager.FindWz(string.Format(@"Etc\CashPackage.img\{0}", this.item.ItemID));
                CashPackage cashPackage = CashPackage.CreateFromNode(itemNode, cashPackageNode, PluginBase.PluginManager.FindWz);
                return RenderCashPackage(cashPackage);
            }

            Action<int> AppendGearOrItem = (int itemID) =>
            {
                int itemIDClass = itemID / 1000000;
                if (itemIDClass == 1) //通过ID寻找装备
                {
                    Wz_Node charaWz = PluginManager.FindWz(Wz_Type.Character);
                    if (charaWz != null)
                    {
                        string imgName = itemID.ToString("d8") + ".img";
                        foreach (Wz_Node node0 in charaWz.Nodes)
                        {
                            Wz_Node imgNode = node0.FindNodeByPath(imgName, true);
                            if (imgNode != null)
                            {
                                Gear gear = Gear.CreateFromNode(imgNode, path => PluginManager.FindWz(path));
                                if (gear != null)
                                {
                                    gear.Props[GearPropType.timeLimited] = 0;
                                    int tuc, tucCnt;
                                    if (Item.Props.TryGetValue(ItemPropType.addTooltip_tuc, out tuc) && Item.Props.TryGetValue(ItemPropType.addTooltip_tucCnt, out tucCnt))
                                    {
                                        Wz_Node itemWz = PluginManager.FindWz(Wz_Type.Item);
                                        if (itemWz != null)
                                        {
                                            string imgClass = (tuc / 10000).ToString("d4") + ".img\\" + tuc.ToString("d8") + "\\info";
                                            foreach (Wz_Node node1 in itemWz.Nodes)
                                            {
                                                Wz_Node infoNode = node1.FindNodeByPath(imgClass, true);
                                                if (infoNode != null)
                                                {
                                                    gear.Upgrade(infoNode, tucCnt);

                                                    break;
                                                }
                                            }
                                        }
                                    }
                                    recipeItemBmps.Add(RenderLinkRecipeGear(gear));
                                }

                                break;
                            }
                        }
                    }
                }
                else if (itemIDClass >= 2 && itemIDClass <= 5) //通过ID寻找道具
                {
                    Wz_Node itemWz = PluginManager.FindWz(Wz_Type.Item);
                    if (itemWz != null)
                    {
                        string imgClass = (itemID / 10000).ToString("d4") + ".img\\" + itemID.ToString("d8");
                        foreach (Wz_Node node0 in itemWz.Nodes)
                        {
                            Wz_Node imgNode = node0.FindNodeByPath(imgClass, true);
                            if (imgNode != null)
                            {
                                Item item = Item.CreateFromNode(imgNode, PluginManager.FindWz);
                                item.Props[ItemPropType.timeLimited] = 0;
                                if (item != null)
                                {
                                    recipeItemBmps.Add(RenderLinkRecipeItem(item));
                                }

                                break;
                            }
                        }
                    }
                }
            };

            //图纸相关
            int recipeID;
            if (this.item.Specs.TryGetValue(ItemSpecType.recipe, out recipeID))
            {
                int recipeSkillID = recipeID / 10000;
                Recipe recipe = null;
                //寻找配方
                Wz_Node recipeNode = PluginBase.PluginManager.FindWz(string.Format(@"Skill\Recipe_{0}.img\{1}", recipeSkillID, recipeID));
                if (recipeNode != null)
                {
                    recipe = Recipe.CreateFromNode(recipeNode);
                }
                //生成配方图像
                if (recipe != null)
                {
                    if (this.LinkRecipeInfo)
                    {
                        recipeInfoBmp = RenderLinkRecipeInfo(recipe);
                    }

                    if (this.LinkRecipeItem)
                    {
                        int itemID = recipe.MainTargetItemID;
                        AppendGearOrItem(itemID);
                    }
                }
            }

            int value;
            if (this.item.Props.TryGetValue(ItemPropType.dressUpgrade, out value))
            {
                int itemID = value;
                AppendGearOrItem(itemID);
            }
            if (this.item.Props.TryGetValue(ItemPropType.tamingMob, out value))
            {
                int itemID = value;
                AppendGearOrItem(itemID);
            }

            if (this.item.AddTooltips.Count > 0)
            {
                foreach (int itemID in item.AddTooltips)
                {
                    AppendGearOrItem(itemID);
                }
            }

            int setID;
            if (this.item.Props.TryGetValue(ItemPropType.setItemID, out setID))
            {
                SetItem setItem;
                if (CharaSimLoader.LoadedSetItems.TryGetValue(setID, out setItem))
                {
                    setItemBmp = RenderSetItem(setItem);
                }
            }

            //计算布局
            Size totalSize = new Size(itemBmp.Width, picHeight);
            Point recipeInfoOrigin = Point.Empty;
            List<Point> recipeItemOrigins = new List<Point>();
            Point setItemOrigin = Point.Empty;
            Point levelOrigin = Point.Empty;

            if (recipeItemBmps.Count > 0)
            {
                if (recipeInfoBmp != null)
                {
                    recipeItemOrigins.Add(new Point(totalSize.Width, 0));
                    recipeInfoOrigin.X = itemBmp.Width - recipeInfoBmp.Width;
                    recipeInfoOrigin.Y = picHeight;
                    totalSize.Width += recipeItemBmps[0].Width;
                    totalSize.Height = Math.Max(picHeight + recipeInfoBmp.Height, recipeItemBmps[0].Height);
                }
                else
                {
                    int itemCnt = recipeItemBmps.Count;
                    for (int i = 0; i < itemCnt; ++i)
                    {
                        recipeItemOrigins.Add(new Point(totalSize.Width, 0));
                        totalSize.Width += recipeItemBmps[i].Width;
                        totalSize.Height = Math.Max(picHeight, recipeItemBmps[i].Height);
                    }
                }
            }
            else if (recipeInfoBmp != null)
            {
                totalSize.Width += recipeInfoBmp.Width;
                totalSize.Height = Math.Max(picHeight, recipeInfoBmp.Height);
                recipeInfoOrigin.X = itemBmp.Width;
            }
            if (setItemBmp != null)
            {
                setItemOrigin = new Point(totalSize.Width, 0);
                totalSize.Width += setItemBmp.Width;
                totalSize.Height = Math.Max(totalSize.Height, setItemBmp.Height);
            }
            if (levelBmp != null)
            {
                levelOrigin = new Point(totalSize.Width, 0);
                totalSize.Width += levelBmp.Width;
                totalSize.Height = Math.Max(totalSize.Height, levelHeight);
            }

            //开始绘制
            Bitmap tooltip = new Bitmap(totalSize.Width, totalSize.Height);
            Graphics g = Graphics.FromImage(tooltip);

            if (itemBmp != null)
            {
                //绘制背景区域
                GearGraphics.DrawNewTooltipBack(g, 0, 0, itemBmp.Width, picHeight);
                //复制图像
                var itemBmp2=itemBmp;
                itemBmp2.SetResolution(DPIUtil.dpiX, DPIUtil.dpiY);
                g.DrawImage(itemBmp2, 0, 0, new Rectangle(0, 0, itemBmp.Width, picHeight), GraphicsUnit.Pixel);
                //左上角
                g.DrawImage2(Resource.UIToolTip_img_Item_Frame2_cover, 3, 3);

                if (this.ShowObjectID)
                {
                    GearGraphics.DrawGearDetailNumber(g, 3, 3, item.ItemID.ToString("d8"), true);
                }
            }

            //绘制配方
            if (recipeInfoBmp != null)
            {
                var recipeInfoBmp2= recipeInfoBmp;
                recipeInfoBmp2.SetResolution(DPIUtil.dpiX, DPIUtil.dpiY);
                g.DrawImage(recipeInfoBmp2, recipeInfoOrigin.X, recipeInfoOrigin.Y,
                    new Rectangle(Point.Empty, recipeInfoBmp.Size), GraphicsUnit.Pixel);
            }

            //绘制产出道具
            if (recipeItemBmps.Count > 0)
            {
                int itemCnt = recipeItemBmps.Count;
                for (int i = 0; i < itemCnt; ++i)
                {
                   
                    g.DrawImage2(recipeItemBmps[i], recipeItemOrigins[i].X, recipeItemOrigins[i].Y,
                        new Rectangle(Point.Empty, recipeItemBmps[i].Size), GraphicsUnit.Pixel);
                }
            }

            //绘制套装
            if (setItemBmp != null)
            {
                g.DrawImage2(setItemBmp, setItemOrigin.X, setItemOrigin.Y,
                    new Rectangle(Point.Empty, setItemBmp.Size), GraphicsUnit.Pixel);
            }

            if (levelBmp != null)
            {
                //绘制背景区域
                GearGraphics.DrawNewTooltipBack(g, levelOrigin.X, levelOrigin.Y, levelBmp.Width, levelHeight);
                //复制图像
                g.DrawImage2(levelBmp, levelOrigin.X, levelOrigin.Y, new Rectangle(0, 0, levelBmp.Width, levelHeight), GraphicsUnit.Pixel);
            }

            if (itemBmp != null)
                itemBmp.Dispose();
            if (recipeInfoBmp != null)
                recipeInfoBmp.Dispose();
            if (recipeItemBmps.Count > 0)
                foreach (Bitmap recipeItemBmp in recipeItemBmps)
                    recipeItemBmp.Dispose();
            if (setItemBmp != null)
                setItemBmp.Dispose();
            if (levelBmp != null)
                levelBmp.Dispose();

            g.Dispose();
            return tooltip;
        }


        private Bitmap RenderItem(out int picH)
        {
            Bitmap tooltip = new Bitmap(290, DefaultPicHeight);
            Graphics g = Graphics.FromImage(tooltip);
            StringFormat format = (StringFormat)StringFormat.GenericDefault.Clone();
            int value;

            picH = 10;
            //物品标题
            StringResult sr;
            if (StringLinker == null || !StringLinker.StringItem.TryGetValue(item.ItemID, out sr))
            {
                sr = new StringResult();
                sr.Name = "(null)";
            }
            string itemName = sr.Name.Replace(Environment.NewLine, "");
            string nameAdd = item.ItemID / 10000 == 313 || item.ItemID / 10000 == 501 ? "OFF" : null;
            if (!string.IsNullOrEmpty(nameAdd))
            {
                itemName += " (" + nameAdd + ")";
            }

            //SizeF titleSize = TextRenderer.MeasureText(g, sr.Name.Replace(Environment.NewLine, ""), GearGraphics.ItemNameFont2, new Size(int.MaxValue, int.MaxValue), TextFormatFlags.NoPrefix);
            SizeF titleSize = TextRenderer.MeasureText(g, itemName, GearGraphics.ItemNameFont2, new Size(int.MaxValue, int.MaxValue), TextFormatFlags.NoPrefix);
            titleSize.Width += 9 * 2;//9 was 12
            if (titleSize.Width > 290)
            {
                //重构大小
                g.Dispose();
                tooltip.Dispose();

                tooltip = new Bitmap((int)Math.Ceiling(titleSize.Width), DefaultPicHeight);
                g = Graphics.FromImage(tooltip);
                picH = 21;
            }
            if (sr["fixWidth"] != null)
            {
                //重构大小
                g.Dispose();
                tooltip.Dispose();

                tooltip = new Bitmap(Int32.Parse(sr["fixWidth"]), DefaultPicHeight);
                g = Graphics.FromImage(tooltip);
                picH = 10;
            }

            //绘制标题
            bool hasPart2 = false;
            g.DrawImage(Resource.ToolTip_Equip_Dot_0, 9, picH + 5);//GMS Version blue dot in ITEMS
            format.Alignment = StringAlignment.Near;
            TextRenderer.DrawText(g, itemName, GearGraphics.ItemNameFont2, new Point(tooltip.Width / 21, picH), Color.White, TextFormatFlags.Left | TextFormatFlags.NoPrefix);
            //TextRenderer.DrawText(g, sr.Name.Replace(Environment.NewLine, ""), GearGraphics.ItemNameFont2, new Point(tooltip.Width / 21, picH), Color.White, TextFormatFlags.Left | TextFormatFlags.NoPrefix);
            picH += 21;//default value is 21

            if (Item.Props.TryGetValue(ItemPropType.wonderGrade, out value) && value > 0)
            {
                switch (value)
                {
                    case 1:
                        TextRenderer.DrawText(g, "Wonder Black", GearGraphics.EquipDetailFont, new Point(tooltip.Width, picH), ((SolidBrush)GearGraphics.OrangeBrush3).Color, TextFormatFlags.HorizontalCenter);
                        break;
                    case 4:
                        TextRenderer.DrawText(g, "Sweet Luna", GearGraphics.EquipDetailFont, new Point(tooltip.Width, picH), GearGraphics.itemPinkColor, TextFormatFlags.HorizontalCenter);
                        break;
                    case 5:
                        TextRenderer.DrawText(g, "Dream Luna", GearGraphics.EquipDetailFont, new Point(tooltip.Width, picH), ((SolidBrush)GearGraphics.BlueBrush).Color, TextFormatFlags.HorizontalCenter);
                        break;
                    case 6:
                        TextRenderer.DrawText(g, "Petite Luna", GearGraphics.EquipDetailFont, new Point(tooltip.Width, picH), GearGraphics.itemPurpleColor, TextFormatFlags.HorizontalCenter);
                        break;
                    default:
                        picH -= 15;
                        break;
                }
                picH += 15;
            }
            else if (Item.Props.TryGetValue(ItemPropType.BTSLabel, out value) && value > 0)
            {
                TextRenderer.DrawText(g, "BTS Label", GearGraphics.EquipDetailFont, new Point(tooltip.Width, picH), Color.FromArgb(187, 102, 238), TextFormatFlags.HorizontalCenter);
                picH += 15;
            }
            else if (Item.Props.TryGetValue(ItemPropType.BLACKPINKLabel, out value) && value > 0)
            {
                TextRenderer.DrawText(g, "BLACKPINK Label", GearGraphics.EquipDetailFont, new Point(tooltip.Width, picH), Color.FromArgb(255, 136, 170), TextFormatFlags.HorizontalCenter);
                picH += 15;
            }

            //额外特性
            var attrList = GetItemAttributeString();
            if (attrList.Count > 0)
            {
                var font = GearGraphics.ItemDetailFont;
                string attrStr = null;
                for (int i = 0; i < attrList.Count; i++)
                {
                    var newStr = (attrStr != null ? (attrStr + ", ") : null) + attrList[i];
                    if (TextRenderer.MeasureText(g, newStr, font, new Size(int.MaxValue, int.MaxValue), TextFormatFlags.NoPadding).Width > tooltip.Width - 7 || (attrList[i].Contains('\n') && attrStr != null))
                    {
                        TextRenderer.DrawText(g, attrStr, GearGraphics.ItemDetailFont, new Point(tooltip.Width, picH), ((SolidBrush)GearGraphics.OrangeBrush4).Color, TextFormatFlags.HorizontalCenter | TextFormatFlags.NoPadding);
                        picH += 20;
                        attrStr = attrList[i];
                    }
                    else
                    {
                        attrStr = newStr;
                    }
                }
                if (!string.IsNullOrEmpty(attrStr))
                {
                    foreach (string attrLine in attrStr.Split('\n'))
                    {
                        TextRenderer.DrawText(g, attrLine, GearGraphics.ItemDetailFont, new Point(tooltip.Width, picH), ((SolidBrush)GearGraphics.OrangeBrush4).Color, TextFormatFlags.HorizontalCenter | TextFormatFlags.NoPadding);
                        picH += 20;
                    }
                    picH -= 3;
                }
                hasPart2 = true;
            }

            string expireTime = null;
            if (item.TimeLimited)
            {
                DateTime time = DateTime.Now.AddDays(7d);
                if (!item.Cash)
                {
                    expireTime = "Usable Until: " + time.ToString(@"M\/d\/yyyy HH\:mm") + " UTC";
                }
                else
                {
                    expireTime = "Usable Until: " + time.ToString(@"M\/d\/yyyy HH\:mm") + " UTC";
                }
            }
            else if (item.ConsumableFrom != null || item.EndUseDate != null)
            {
                expireTime = "";
                if (item.ConsumableFrom != null)
                {
                    expireTime += string.Format("\nUsable From: {1}/{2}/{0} {3:D2}:{4:D2} UTC", Convert.ToInt32(item.ConsumableFrom.Substring(0, 4)), Convert.ToInt32(item.ConsumableFrom.Substring(4, 2)), Convert.ToInt32(item.ConsumableFrom.Substring(6, 2)), Convert.ToInt32(item.ConsumableFrom.Substring(8, 2)), Convert.ToInt32(item.ConsumableFrom.Substring(10, 2)));
                }
                if (item.EndUseDate != null)
                {
                    expireTime += string.Format("\nUsable Until: {1}/{2}/{0} {3:D2}:{4:D2} UTC", Convert.ToInt32(item.EndUseDate.Substring(0, 4)), Convert.ToInt32(item.EndUseDate.Substring(4, 2)), Convert.ToInt32(item.EndUseDate.Substring(6, 2)), Convert.ToInt32(item.EndUseDate.Substring(8, 2)), Convert.ToInt32(item.EndUseDate.Substring(10, 2)));
                }
            }
            else if ((item.Props.TryGetValue(ItemPropType.permanent, out value) && value != 0) || (item.ItemID / 10000 == 500 && item.Props.TryGetValue(ItemPropType.life, out value) && value == 0))
            {
                picH -= 3;
                if (value == 0)
                {
                    value = 1;
                }
                expireTime = ItemStringHelper.GetItemPropString(ItemPropType.permanent, value);
            }
            else if (item.ItemID / 10000 == 500 && item.Props.TryGetValue(ItemPropType.limitedLife, out value) && value > 0)
            {
                picH -= 3;
                expireTime = string.Format("DAYS OF MAGIC: {0}hrs. {1}min.", value / 3600, (value % 3600) / 60);
            }
            else if (item.ItemID / 10000 == 500 && item.Props.TryGetValue(ItemPropType.life, out value) && value > 0)
            {
                picH -= 3;
                DateTime time = DateTime.Now.AddDays(value);
                expireTime = "Water of Life Dries Up: " + time.ToString(@"M\/d\/yyyy HH\:mm") + " UTC";
            }
            if (!string.IsNullOrEmpty(expireTime))
            {
                if (attrList.Count > 0)
                {
                    picH += 3;
                }
                //picH += 3;
                //TextRenderer.DrawText(g, expireTime, GearGraphics.EquipDetailFont, new Point(tooltip.Width / 25, picH), Color.White, TextFormatFlags.Left);
                //picH += 16;
                //hasPart2 = true;
                foreach (string expireTimeLine in expireTime.Split(new char[] { '\n' }, StringSplitOptions.RemoveEmptyEntries))
                {
                    g.DrawImage2(Resource.ToolTip_Equip_Dot_1, 9, picH + 6);//GMS Version, default value is 9, + X?
                    TextRenderer.DrawText(g, expireTimeLine, GearGraphics.EquipDetailFont, new Point(tooltip.Width / 25, picH), Color.White, TextFormatFlags.Left);
                    picH += 16;
                }
                if (expireTime.Contains('\n'))
                {
                    picH += 4;
                }
                hasPart2 = true;
            }

            if (hasPart2)
            {
                picH += 4;
            }

            //绘制图标
            int iconY = picH;
            int iconX = 10;
          
            g.DrawImage2(Resource.UIToolTip_img_Item_ItemIcon_base, iconX, picH);
            
            if (item.Icon.Bitmap != null)
            {
                
                g.DrawImage2(GearGraphics.EnlargeBitmap(item.Icon.Bitmap),
                iconX + 6 + (1 - item.Icon.Origin.X) * 2,
                picH + 6 + (33 - item.Icon.Origin.Y) * 2);
              
                //picH + 8 + (33 - item.Icon.Bitmap.Height) * 2);
            }
            if (item.Cash)
            {
                Bitmap cashImg = null;
                Point cashOrigin = new Point(12, 12);

                if (item.Props.TryGetValue(ItemPropType.wonderGrade, out value) && value > 0)
                {
                    string resKey = $"CashShop_img_CashItem_label_{value + 3}";
                    cashImg = Resource.ResourceManager.GetObject(resKey) as Bitmap;
                }
                else if (Item.Props.TryGetValue(ItemPropType.BTSLabel, out value) && value > 0)
                {
                    cashImg = Resource.CashShop_img_CashItem_label_10;
                    cashOrigin = new Point(cashImg.Width, cashImg.Height);
                }
                else if (Item.Props.TryGetValue(ItemPropType.BLACKPINKLabel, out value) && value > 0)
                {
                    cashImg = Resource.CashShop_img_CashItem_label_11;
                    cashOrigin = new Point(cashImg.Width, cashImg.Height);
                }
                if (cashImg == null) //default cashImg
                {
                    cashImg = Resource.CashItem_0;
                }

                g.DrawImage2(GearGraphics.EnlargeBitmap(cashImg),
                    iconX + 6 + 68 - cashOrigin.X * 2 - 2,
                    picH + 6 + 68 - cashOrigin.Y * 2 - 2);
            }
            g.DrawImage2(Resource.UIToolTip_img_Item_ItemIcon_new, iconX + 7, picH + 7);
            g.DrawImage2(Resource.UIToolTip_img_Item_ItemIcon_cover, iconX + 4, picH + 4); //绘制左上角cover

            value = 0;
            if (item.Props.TryGetValue(ItemPropType.reqLevel, out value) || item.ItemID / 10000 == 301 || item.ItemID / 1000 == 5204)
            {
                picH += 4;//default value is 4
                g.DrawImage2(Resource.ToolTip_Equip_Can_reqLEV, 100, picH);
                GearGraphics.DrawGearDetailNumber(g, 150, picH, value.ToString(), true);
                picH += 15;
            }
            else
            {
                picH += 3;
            }

            int right = tooltip.Width - 18;

            string desc = null;
            if (item.Level > 0)
            {
                desc += $"[LV.{item.Level}] ";
            }
            desc += sr.Desc;
            if (item.ItemID / 10000 == 500)
            {
                if (item.Props.TryGetValue(ItemPropType.wonderGrade, out value) && value > 0)
                {
                    int setID;
                    if (item.Props.TryGetValue(ItemPropType.setItemID, out setID))
                    {
                        SetItem setItem;
                        if (CharaSimLoader.LoadedSetItems.TryGetValue(setID, out setItem))
                        {
                            string wonderGradeString = null;
                            string setItemName = setItem.SetItemName;
                            string setSkillName = "";
                            switch (value)
                            {
                                case 1:
                                    wonderGradeString = "Wonder Black";
                                    foreach (KeyValuePair<GearPropType, object> prop in setItem.Effects.Values.SelectMany(f => f.PropsV5))
                                    {
                                        if (prop.Key == GearPropType.activeSkill)
                                        {
                                            SetItemActiveSkill p = ((List<SetItemActiveSkill>)prop.Value)[0];
                                            StringResult sr2;
                                            if (StringLinker == null || !StringLinker.StringSkill.TryGetValue(p.SkillID, out sr2))
                                            {
                                                sr2 = new StringResult();
                                                sr2.Name = p.SkillID.ToString();
                                            }
                                            setSkillName = Regex.Replace(sr2.Name, " Lv.\\d", "");
                                            break;
                                        }
                                    }
                                    break;
                                case 4:
                                    wonderGradeString = "Sweet Luna";
                                    setSkillName = "Sweet Luna";
                                    break;
                                case 5:
                                    wonderGradeString = "Dream Luna";
                                    setSkillName = "Dream Luna";
                                    break;
                            }
                            if (wonderGradeString != null)
                            {
                                desc += $"\nEquipping #c{wonderGradeString}# rank #c{setItemName}# pet gives the #c{setSkillName}# set effect. (Up to 3 levels.)\nSet effects can be enhanced up to 3 times depending on the type of #c{setItemName}# pet you have equipped.";
                            }
                        }
                    }
                }
                desc += "\n#cSkill: Meso Magnet";
                if (item.Props.TryGetValue(ItemPropType.pickupItem, out value) && value > 0)
                {
                    desc += ", Item Pouch";
                }
                if (item.Props.TryGetValue(ItemPropType.longRange, out value) && value > 0)
                {
                    desc += ", Expanded Auto Move";
                }
                if (item.Props.TryGetValue(ItemPropType.sweepForDrop, out value) && value > 0)
                {
                    desc += ", Auto Move";
                }
                if (item.Props.TryGetValue(ItemPropType.pickupAll, out value) && value > 0)
                {
                    desc += ", Expired Pickup Skill";
                }
                if (item.Props.TryGetValue(ItemPropType.consumeHP, out value) && value > 0)
                {
                    desc += ", Auto HP Potion Pouch";
                }
                if (item.Props.TryGetValue(ItemPropType.consumeMP, out value) && value > 0)
                {
                    desc += ", Auto MP Potion Pouch";
                }
                if (item.Props.TryGetValue(ItemPropType.autoBuff, out value) && value > 0)
                {
                    desc += ", Auto Buff";
                }
                if (item.Props.TryGetValue(ItemPropType.giantPet, out value) && value > 0)
                {
                    desc += ", Fatten Up";
                }
                if (item.Props.TryGetValue(ItemPropType.consumeCure, out value) && value > 0)
                {
                    desc += ", Take All Cure Potion";
                }
                desc += "#";
            }
            if (!string.IsNullOrEmpty(desc))
            {
                GearGraphics.DrawString(g, desc, GearGraphics.ItemDetailFont2, 100, right, ref picH, 16);
            }
            if (!string.IsNullOrEmpty(sr.AutoDesc))
            {
                GearGraphics.DrawString(g, sr.AutoDesc, GearGraphics.ItemDetailFont2, 100, right, ref picH, 16);
            }
            if (item.Props.TryGetValue(ItemPropType.tradeAvailable, out value) && value > 0)
            {
                string attr = ItemStringHelper.GetItemPropString(ItemPropType.tradeAvailable, value);
                if (!string.IsNullOrEmpty(attr))
                    GearGraphics.DrawString(g, "#c" + attr + "#", GearGraphics.ItemDetailFont2, 100, right, ref picH, 16);
            }
            if (item.Props.TryGetValue(ItemPropType.pointCost, out value) && value > 0)
            {
                picH += 16;
                GearGraphics.DrawString(g, "- " + value + " Point(s)", GearGraphics.ItemDetailFont, 100, right, ref picH, 16);
            }
            if (item.Specs.TryGetValue(ItemSpecType.recipeValidDay, out value) && value > 0)
            {
                GearGraphics.DrawString(g, "(Use within: " + value + " days )", GearGraphics.ItemDetailFont, 100, right, ref picH, 16);
            }
            if (item.Specs.TryGetValue(ItemSpecType.recipeUseCount, out value) && value > 0)
            {
                GearGraphics.DrawString(g, "(Craftable: " + value + " time(s))", GearGraphics.ItemDetailFont, 100, right, ref picH, 16);
            }
            if (item.ItemID / 1000 == 5533)
            {
                GearGraphics.DrawString(g, "\n#cBy double-clicking on it, you can preview the items inside the box, in order, every 3 seconds. Some random boxes can't be previewed.#", GearGraphics.ItemDetailFont, 100, right, ref picH, 16);
            }
            if (item.Cash)
            {
                if (item.Props.TryGetValue(ItemPropType.noMoveToLocker, out value) && value > 0)
                {
                    GearGraphics.DrawString(g, "\n#cThis item cannot be moved to the Cash inventory.#", GearGraphics.ItemDetailFont, 100, right, ref picH, 16);
                }
                else if (item.Props.TryGetValue(ItemPropType.onlyCash, out value) && value > 0)
                {
                    GearGraphics.DrawString(g, "\n#cCan only be purchased with NX.#", GearGraphics.ItemDetailFont, 100, right, ref picH, 16);
                }
                else if ((!item.Props.TryGetValue(ItemPropType.tradeBlock, out value) || value == 0) && item.ItemID / 10000 != 501 && item.ItemID / 10000 != 502 && item.ItemID / 10000 != 516)
                {
                    /*GearGraphics.DrawString(g, "\n#cThis item cannot be traded once it has been used.#", GearGraphics.ItemDetailFont, 100, right, ref picH, 16);*/ //GMS - Enable when GMS uses this line.
                }
            }
            if (item.Props.TryGetValue(ItemPropType.flatRate, out value) && value > 0)
            {
                GearGraphics.DrawString(g, "\n#c기간 정액제 아이템입니다.#", GearGraphics.ItemDetailFont, 100, right, ref picH, 16);
            }
            if (item.Props.TryGetValue(ItemPropType.noScroll, out value) && value > 0)
            {
                GearGraphics.DrawString(g, "#cYou cannot use the Pet Skill Scroll or Pet Name tag at this time.#", GearGraphics.ItemDetailFont, 100, right, ref picH, 16);
            }
            if (item.Props.TryGetValue(ItemPropType.noRevive, out value) && value > 0)
            {
                GearGraphics.DrawString(g, "#cYou cannot use the Water of Life.#", GearGraphics.ItemDetailFont, 100, right, ref picH, 16);
            }

            if (item.ItemID / 10000 == 500)
            {
                Wz_Node petDialog = PluginManager.FindWz("String\\PetDialog.img\\" + item.ItemID);
                Dictionary<string, int> commandLev = new Dictionary<string, int>();
                foreach (Wz_Node commandNode in PluginManager.FindWz("Item\\Pet\\" + item.ItemID + ".img\\interact").Nodes)
                {
                    foreach (string command in petDialog?.Nodes[commandNode.Nodes["command"].GetValue<string>()].GetValueEx<string>(null)?.Split('|') ?? Enumerable.Empty<string>())
                    {
                        int l0;
                        if (!commandLev.TryGetValue(command, out l0))
                        {
                            commandLev.Add(command, commandNode.Nodes["l0"].GetValue<int>());
                        }
                        else
                        {
                            commandLev[command] = Math.Min(l0, commandNode.Nodes["l0"].GetValue<int>());
                        }
                    }
                }

                GearGraphics.DrawString(g, "[Usable Command]", GearGraphics.ItemDetailFont, 100, right, ref picH, 16);
                foreach (int l0 in commandLev.Values.OrderBy(i => i).Distinct())
                {
                    GearGraphics.DrawString(g, "Lv. " + l0 + "+: " + string.Join(", ", commandLev.Where(i => i.Value == l0).Select(i => i.Key).OrderBy(s => s)), GearGraphics.ItemDetailFont, 100, right, ref picH, 16);
                }
                GearGraphics.DrawString(g, "Tip: You can control what your\n\r pet says once it reaches Lv. 15.", GearGraphics.ItemDetailFont, 100, right, ref picH, 16);
                GearGraphics.DrawString(g, "#cEx) /Pet [what to say]#", GearGraphics.ItemDetailFont, 100, right, ref picH, 16, ((SolidBrush)GearGraphics.OrangeBrush4).Color);
            }

            string incline = null;
            ItemPropType[] inclineTypes = new ItemPropType[]{
                    ItemPropType.charismaEXP,
                    ItemPropType.insightEXP,
                    ItemPropType.willEXP,
                    ItemPropType.craftEXP,
                    ItemPropType.senseEXP,
                    ItemPropType.charmEXP };

            string[] inclineString = new string[]{
                    " Ambition"," Insight"," Willpower"," Diligence"," Empathy"," Charm"};

            for (int i = 0; i < inclineTypes.Length; i++)
            {
                if (item.Props.TryGetValue(inclineTypes[i], out value) && value > 0)
                {
                    incline += ", " + value + inclineString[i];
                }
            }

            if (!string.IsNullOrEmpty(incline))
            {
                GearGraphics.DrawString(g, "#cGrants " + incline.Substring(2) + " EXP when first equipped (up to the daily maximum).", GearGraphics.ItemDetailFont, 100, right, ref picH, 16);
            }

            picH += 3;

            Wz_Node nickResNode = null;
            bool willDrawNickTag = this.ShowNickTag
                && this.Item.Props.TryGetValue(ItemPropType.nickTag, out value)
                && this.TryGetNickResource(value, out nickResNode);
            string descLeftAlign = sr["desc_leftalign"];
            int minLev = 0, maxLev = 0;
            bool willDrawExp = item.Props.TryGetValue(ItemPropType.exp_minLev, out minLev) && item.Props.TryGetValue(ItemPropType.exp_maxLev, out maxLev);

            if (!string.IsNullOrEmpty(descLeftAlign) || item.CoreSpecs.Count > 0 || item.Sample.Bitmap != null || item.SamplePath != null || willDrawNickTag || willDrawExp)
            {
                if (picH < iconY + 84)
                {
                    picH = iconY + 84;
                }
                if (!string.IsNullOrEmpty(descLeftAlign))
                {
                    picH += 12;
                    GearGraphics.DrawString(g, descLeftAlign, GearGraphics.ItemDetailFont, 14, right, ref picH, 16);
                }
                if (item.CoreSpecs.Count > 0)
                {
                    g.DrawLine(Pens.White, 6, picH - 1, tooltip.Width - 7, picH - 1);
                    picH += 9;
                    foreach (KeyValuePair<ItemCoreSpecType, Wz_Node> p in item.CoreSpecs)
                    {
                        string coreSpec;
                        switch (p.Key)
                        {
                            case ItemCoreSpecType.Ctrl_addMob:
                                StringResult srMob;
                                if (StringLinker == null || !StringLinker.StringMob.TryGetValue(Convert.ToInt32(p.Value.Nodes["mobID"].Value), out srMob))
                                {
                                    srMob = new StringResult();
                                    srMob.Name = "(null)";
                                }
                                foreach (Wz_Node addMobNode in p.Value.Nodes)
                                {
                                    if (int.TryParse(addMobNode.Text, out value))
                                    {
                                        break;
                                    }
                                }
                                coreSpec = ItemStringHelper.GetItemCoreSpecString(ItemCoreSpecType.Ctrl_addMob, value, srMob.Name);
                                break;

                            default:
                                try
                                {
                                    coreSpec = ItemStringHelper.GetItemCoreSpecString(p.Key, Convert.ToInt32(p.Value.Value), Convert.ToString(p.Value.Nodes["desc"]?.Value));
                                }
                                finally
                                {
                                }
                                break;
                        }
                        GearGraphics.DrawString(g, "* " + coreSpec, GearGraphics.ItemDetailFont, 14, right, ref picH, 16);
                    }
                }
                if (item.Sample.Bitmap != null)
                {
                    g.DrawImage2(item.Sample.Bitmap, (tooltip.Width - item.Sample.Bitmap.Width) / 2, picH);
                    picH += item.Sample.Bitmap.Height;
                    picH += 2;
                }
                if (item.SamplePath != null)
                {
                    Wz_Node sampleNode = PluginManager.FindWz(item.SamplePath);
                    int sampleW = 15;
                    for (int i = 1; ; i++)
                    {
                        Wz_Node effectNode = sampleNode.FindNodeByPath(string.Format("{0}{1:D4}\\effect\\0", sampleNode.Text, i));
                        if (effectNode == null)
                        {
                            break;
                        }

                        BitmapOrigin effect = BitmapOrigin.CreateFromNode(effectNode, PluginManager.FindWz);
                        if (sampleW + 87 >= tooltip.Width)
                        {
                            picH += 62;
                            sampleW = 15;
                        }
                        g.DrawImage(effect.Bitmap, sampleW + (85 - effect.Bitmap.Width - 1) / 2, picH + (62 - effect.Bitmap.Height - 1) / 2);
                        sampleW += 87;
                    }
                    picH += 62;
                }
                if (nickResNode != null)
                {
                    //获取称号名称
                    string nickName;
                    string nickWithQR = sr["nickWithQR"];
                    if (nickWithQR != null)
                    {
                        string qrDefault = sr["qrDefault"] ?? string.Empty;
                        nickName = Regex.Replace(nickWithQR, "#qr.*?#", qrDefault);
                    }
                    else
                    {
                        nickName = sr.Name;
                    }
                    GearGraphics.DrawNameTag(g, nickResNode, nickName, tooltip.Width, ref picH);
                    picH += 4; // value is either 4 or 14 (it was 14 in previous iteration)
                }
                if (minLev > 0 && maxLev > 0)
                {
                    long totalExp = 0;

                    for (int i = minLev; i < maxLev; i++)
                        totalExp += Character.ExpToNextLevel(i);

                    g.DrawLine(Pens.White, 6, picH, tooltip.Width - 7, picH);
                    picH += 8;

                    TextRenderer.DrawText(g, "Total EXP: " + totalExp, GearGraphics.ItemDetailFont2, new Point(10, picH), ((SolidBrush)GearGraphics.OrangeBrush4).Color, TextFormatFlags.NoPadding);
                    picH += 16;

                    TextRenderer.DrawText(g, "Remaining EXP: " + totalExp, GearGraphics.ItemDetailFont2, new Point(10, picH), Color.Red, TextFormatFlags.NoPadding);
                    picH += 16;

                    string cantAccountSharable = null;
                    Wz_Node itemWz = PluginManager.FindWz(Wz_Type.Item);
                    if (itemWz != null)
                    {
                        string imgClass = (item.ItemID / 10000).ToString("d4") + ".img\\" + item.ItemID.ToString("d8");
                        foreach (Wz_Node node0 in itemWz.Nodes)
                        {
                            Wz_Node imgNode = node0.FindNodeByPath(imgClass, true);
                            if (imgNode != null)
                            {
                                cantAccountSharable = imgNode.FindNodeByPath("info\\cantAccountSharable\\tooltip").GetValueEx<string>(null);
                                break;
                            }
                        }
                    }

                    if (cantAccountSharable != null)
                    {
                        TextRenderer.DrawText(g, cantAccountSharable, GearGraphics.ItemDetailFont2, new Point(10, picH), ((SolidBrush)GearGraphics.SetItemNameBrush).Color, TextFormatFlags.NoPadding);
                        picH += 16;
                        picH += 16;
                    }
                }
            }


            //绘制配方需求
            if (item.Specs.TryGetValue(ItemSpecType.recipe, out value))
            {
                int reqSkill, reqSkillLevel;
                if (!item.Specs.TryGetValue(ItemSpecType.reqSkill, out reqSkill))
                {
                    reqSkill = value / 10000 * 10000;
                }

                if (!item.Specs.TryGetValue(ItemSpecType.reqSkillLevel, out reqSkillLevel))
                {
                    reqSkillLevel = 1;
                }

                picH = Math.Max(picH, iconY + 107);
                g.DrawLine(Pens.White, 6, picH, 283, picH);//分割线
                picH += 10;
                TextRenderer.DrawText(g, "<Requirements>", GearGraphics.ItemDetailFont, new Point(8, picH), ((SolidBrush)GearGraphics.SetItemNameBrush).Color, TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix);
                picH += 17;

                //技能标题
                if (StringLinker == null || !StringLinker.StringSkill.TryGetValue(reqSkill, out sr))
                {
                    sr = new StringResult();
                    sr.Name = "- (null)";
                }
                TextRenderer.DrawText(g, string.Format("- {0} Lv {1}", sr.Name, reqSkillLevel), GearGraphics.ItemDetailFont, new Point(13, picH), ((SolidBrush)GearGraphics.SetItemNameBrush).Color, TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix);
                picH += 16;
                picH += 6;
            }

            picH = Math.Max(iconY + 94, picH + 6);
            return tooltip;
        }

        private List<string> GetItemAttributeString()
        {
            int value, value2;
            List<string> tags = new List<string>();

            if (item.Props.TryGetValue(ItemPropType.quest, out value) && value != 0)
            {
                tags.Add(ItemStringHelper.GetItemPropString(ItemPropType.quest, value));
            }
            if (item.Props.TryGetValue(ItemPropType.pquest, out value) && value != 0)
            {
                tags.Add(ItemStringHelper.GetItemPropString(ItemPropType.pquest, value));
            }
            if (item.Props.TryGetValue(ItemPropType.only, out value) && value != 0)
            {
                tags.Add(ItemStringHelper.GetItemPropString(ItemPropType.only, value));
            }
            if (item.Props.TryGetValue(ItemPropType.tradeBlock, out value) && value != 0)
            {
                tags.Add(ItemStringHelper.GetItemPropString(ItemPropType.tradeBlock, value));
            }
            if (item.Props.TryGetValue(ItemPropType.useTradeBlock, out value) && value != 0)
            {
                tags.Add(ItemStringHelper.GetItemPropString(ItemPropType.useTradeBlock, value));
            }
            else if (item.ItemID / 10000 == 501 || item.ItemID / 10000 == 502 || item.ItemID / 10000 == 516)
            {
                tags.Add(ItemStringHelper.GetItemPropString(ItemPropType.tradeBlock, 1));
            }
            if (item.Props.TryGetValue(ItemPropType.accountSharable, out value) && value != 0)
            {
                if (item.Props.TryGetValue(ItemPropType.exp_minLev, out value2) && value2 != 0)
                {
                    tags.Add(ItemStringHelper.GetItemPropString(ItemPropType.useTradeBlock, 1));
                }
                if (item.Props.TryGetValue(ItemPropType.sharableOnce, out value2) && value2 != 0)
                {
                    tags.Add(ItemStringHelper.GetItemPropString(ItemPropType.sharableOnce, value2));
                }
                else
                {
                    tags.Add(ItemStringHelper.GetItemPropString(ItemPropType.accountSharable, value));
                }
            }
            if (item.Props.TryGetValue(ItemPropType.exchangeableOnce, out value) && value != 0)
            {
                tags.Add(ItemStringHelper.GetItemPropString(ItemPropType.exchangeableOnce, value));
            }
            if (item.Props.TryGetValue(ItemPropType.multiPet, out value))
            {
                tags.Add(ItemStringHelper.GetItemPropString(ItemPropType.multiPet, value));
            }
            else if (item.ItemID / 10000 == 500)
            {
                tags.Add(ItemStringHelper.GetItemPropString(ItemPropType.multiPet, 0));
            }

            return tags;
        }

        private Bitmap RenderLinkRecipeInfo(Recipe recipe)
        {
            TooltipRender renderer = this.LinkRecipeInfoRender;
            if (renderer == null)
            {
                RecipeTooltipRender defaultRenderer = new RecipeTooltipRender();
                defaultRenderer.StringLinker = this.StringLinker;
                defaultRenderer.ShowObjectID = false;
                renderer = defaultRenderer;
            }

            renderer.TargetItem = recipe;
            return renderer.Render();
        }

        private Bitmap RenderLinkRecipeGear(Gear gear)
        {
            TooltipRender renderer = this.LinkRecipeGearRender;
            if (renderer == null)
            {
                GearTooltipRender2 defaultRenderer = new GearTooltipRender2();
                defaultRenderer.StringLinker = this.StringLinker;
                defaultRenderer.ShowObjectID = false;
                renderer = defaultRenderer;
            }

            renderer.TargetItem = gear;
            return renderer.Render();
        }

        private Bitmap RenderLinkRecipeItem(Item item)
        {
            TooltipRender renderer = this.LinkRecipeItemRender;
            if (renderer == null)
            {
                ItemTooltipRender2 defaultRenderer = new ItemTooltipRender2();
                defaultRenderer.StringLinker = this.StringLinker;
                defaultRenderer.ShowObjectID = false;
                renderer = defaultRenderer;
            }

            renderer.TargetItem = item;
            return renderer.Render();
        }

        private Bitmap RenderSetItem(SetItem setItem)
        {
            TooltipRender renderer = this.SetItemRender;
            if (renderer == null)
            {
                var defaultRenderer = new SetItemTooltipRender();
                defaultRenderer.StringLinker = this.StringLinker;
                defaultRenderer.ShowObjectID = false;
                renderer = defaultRenderer;
            }

            renderer.TargetItem = setItem;
            return renderer.Render();
        }

        private Bitmap RenderCashPackage(CashPackage cashPackage)
        {
            TooltipRender renderer = this.CashPackageRender;
            if (renderer == null)
            {
                var defaultRenderer = new CashPackageTooltipRender();
                defaultRenderer.StringLinker = this.StringLinker;
                defaultRenderer.ShowObjectID = this.ShowObjectID;
                renderer = defaultRenderer;
            }

            renderer.TargetItem = cashPackage;
            return renderer.Render();
        }

        private Bitmap RenderLevel(out int picHeight)
        {
            Bitmap level = null;
            Graphics g = null;
            StringFormat format = new StringFormat();
            format.Alignment = StringAlignment.Center;
            picHeight = 0;
            if (Item.Levels != null)
            {
                if (level == null)
                {
                    level = new Bitmap(261, DefaultPicHeight);
                    g = Graphics.FromImage(level);
                }
                picHeight += 13;
                TextRenderer.DrawText(g, "Growth Stats", GearGraphics.EquipDetailFont, new Point(261, picHeight), ((SolidBrush)GearGraphics.GreenBrush2).Color, TextFormatFlags.HorizontalCenter);
                picHeight += 15;

                for (int i = 0; i < Item.Levels.Count; i++)
                {
                    var info = Item.Levels[i];
                    TextRenderer.DrawText(g, "Level " + info.Level + (i >= Item.Levels.Count - 1 ? " (MAX)" : null), GearGraphics.EquipDetailFont, new Point(10, picHeight), ((SolidBrush)GearGraphics.GreenBrush2).Color, TextFormatFlags.NoPadding);
                    picHeight += 15;
                    foreach (var kv in info.BonusProps)
                    {
                        GearLevelInfo.Range range = kv.Value;

                        string propString = ItemStringHelper.GetGearPropString(kv.Key, kv.Value.Min);
                        if (propString != null)
                        {
                            if (range.Max != range.Min)
                            {
                                propString += " ~ " + kv.Value.Max + (propString.EndsWith("%") ? "%" : null);
                            }
                            TextRenderer.DrawText(g, propString, GearGraphics.EquipDetailFont, new Point(10, picHeight), Color.White, TextFormatFlags.NoPadding);
                            picHeight += 15;
                        }
                    }
                    if (info.Skills.Count > 0)
                    {
                        string title = string.Format("{2:P2}({0}/{1}) 확률로 스킬 강화 옵션 추가 :", info.Prob, info.ProbTotal, info.Prob * 1.0 / info.ProbTotal);
                        TextRenderer.DrawText(g, title, GearGraphics.EquipDetailFont, new Point(10, picHeight), Color.White, TextFormatFlags.NoPadding);
                        picHeight += 15;
                        foreach (var kv in info.Skills)
                        {
                            StringResult sr = null;
                            if (this.StringLinker != null)
                            {
                                this.StringLinker.StringSkill.TryGetValue(kv.Key, out sr);
                            }
                            string text = string.Format(" +{2} {0}", sr == null ? null : sr.Name, kv.Key, kv.Value);
                            TextRenderer.DrawText(g, text, GearGraphics.EquipDetailFont, new Point(10, picHeight), ((SolidBrush)GearGraphics.OrangeBrush).Color, TextFormatFlags.NoPadding);
                            picHeight += 15;
                        }
                    }
                    if (info.EquipmentSkills.Count > 0)
                    {
                        string title;
                        if (info.Prob < info.ProbTotal)
                        {
                            title = string.Format("{2:P2}({0}/{1}) 확률로 스킬 사용 가능 :", info.Prob, info.ProbTotal, info.Prob * 1.0 / info.ProbTotal);
                        }
                        else
                        {
                            title = "스킬 사용 가능 :";
                        }
                        TextRenderer.DrawText(g, title, GearGraphics.EquipDetailFont, new Point(10, picHeight), Color.White, TextFormatFlags.NoPadding);
                        picHeight += 15;
                        foreach (var kv in info.EquipmentSkills)
                        {
                            StringResult sr = null;
                            if (this.StringLinker != null)
                            {
                                this.StringLinker.StringSkill.TryGetValue(kv.Key, out sr);
                            }
                            string text = string.Format(" {0} {2}레벨", sr == null ? null : sr.Name, kv.Key, kv.Value);
                            TextRenderer.DrawText(g, text, GearGraphics.EquipDetailFont, new Point(10, picHeight), ((SolidBrush)GearGraphics.OrangeBrush).Color, TextFormatFlags.NoPadding);
                            picHeight += 15;
                        }
                    }
                    if (info.Exp > 0)
                    {
                        TextRenderer.DrawText(g, "EXP : " + info.Exp + "%", GearGraphics.EquipDetailFont, new Point(10, picHeight), Color.White, TextFormatFlags.NoPadding);
                        picHeight += 15;
                    }

                    picHeight += 2;
                }
            }


            format.Dispose();
            if (g != null)
            {
                g.Dispose();
                picHeight += 13;
            }
            return level;
        }

        private bool TryGetNickResource(int nickTag, out Wz_Node resNode)
        {
            resNode = PluginBase.PluginManager.FindWz("UI/NameTag.img/nick/" + nickTag);
            return resNode != null;
        }
    }
}
```

`MapleNecrocer/CharaSimControl/MobTooltipRenderer.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Drawing;
using System.Drawing.Imaging;
using System.Text.RegularExpressions;
using WzComparerR2.CharaSim;
using WzComparerR2.Common;
using static WzComparerR2.CharaSimControl.RenderHelper;

namespace WzComparerR2.CharaSimControl
{
    public class MobTooltipRenderer : TooltipRender
    {

        public MobTooltipRenderer()
        {
        }

        public override object TargetItem
        {
            get { return this.MobInfo; }
            set { this.MobInfo = value as Mob; }
        }

        public Mob MobInfo { get; set; }

        public override Bitmap Render()
        {
            if (MobInfo == null)
            {
                return null;
            }

            Bitmap bmp = new Bitmap(1, 1, PixelFormat.Format32bppArgb);
            Graphics g = Graphics.FromImage(bmp);

            //预绘制
            List<TextBlock> titleBlocks = new List<TextBlock>();

            if (MobInfo.ID > -1)
            {
                string mobName = GetMobName(MobInfo.ID);
                var block = PrepareText(g, mobName ?? "(null)", GearGraphics.ItemNameFont2, Brushes.White, 0, 0);
                titleBlocks.Add(block);
                block = PrepareText(g, "ID:" + MobInfo.ID, GearGraphics.ItemDetailFont, Brushes.White, block.Size.Width + 6, 0);
                titleBlocks.Add(block);
            }

            List<TextBlock> propBlocks = new List<TextBlock>();
            int picY = 0;

            StringBuilder sbExt = new StringBuilder();
            if (MobInfo.Boss && MobInfo.PartyBonusMob)
            {
                sbExt.Append("[Mini-Boss] ");
            }
            if (MobInfo.Boss && !MobInfo.PartyBonusMob)
            {
                sbExt.Append("[Boss] ");
            }
            if (MobInfo.Undead)
            {
                sbExt.Append("[Undead] ");
            }
            if (MobInfo.FirstAttack)
            {
                sbExt.Append("[Auto-Aggressive] ");
            }
            if (!MobInfo.BodyAttack)
            {
                sbExt.Append("[No Touch Damage] ");
            }
            if (MobInfo.DamagedByMob)
            {
                sbExt.Append("[Vulnerable to Monsters] ");
            }
            if (MobInfo.ChangeableMob)
            {
                sbExt.Append("[Level Scaled] ");
            }
            if (MobInfo.AllyMob)
            {
                sbExt.Append("[Friendly] ");
            }
            if (MobInfo.Invincible)
            {
                sbExt.Append("[Invincible] ");
            }
            if (MobInfo.NotAttack)
            {
                sbExt.Append("[Non-Aggressive] ");//Monster can not attack or damage you. But you can damage it.
            }
            if (MobInfo.FixedDamage > 0)
            {
                sbExt.Append("[Fixed Damage: " + MobInfo.FixedDamage.ToString("N0") + "] ");
            }
            if (MobInfo.FixedBodyAttackDamageR > 0)
            {
                sbExt.Append("[Fixed Touch Damage: " + MobInfo.FixedBodyAttackDamageR + "%] ");
            }
            if (MobInfo.IgnoreDamage)
            {
                sbExt.Append("[Ignores Damage] ");
            }
            if (MobInfo.IgnoreMoveImpact)
            {
                sbExt.Append("[Immune to Rush] ");
            }
            if (MobInfo.IgnoreMovable)
            {
                sbExt.Append("[Immune to Stun/Bind] ");
            }
            if (MobInfo.NoDebuff)
            {
                sbExt.Append("[Immune to Debuffs] ");
            }
            if (MobInfo.OnlyNormalAttack)
            {
                sbExt.Append("[Damaged by Basic Attacks only] ");
            }
            if (MobInfo.OnlyHittedByCommonAttack)
            {
                sbExt.Append("[Hit by Basic Attacks only] ");
            }

            if (sbExt.Length > 1)
            {
                sbExt.Remove(sbExt.Length - 1, 1);
                propBlocks.Add(PrepareText(g, sbExt.ToString(), GearGraphics.ItemDetailFont, Brushes.GreenYellow, 0, picY));
                picY += 16;
            }

            if (MobInfo.RemoveAfter > 0)
            {
                propBlocks.Add(PrepareText(g, "[Disappears after " + MobInfo.RemoveAfter + " seconds]", GearGraphics.ItemDetailFont, Brushes.GreenYellow, 0, picY));
                picY += 16;
            }

            propBlocks.Add(PrepareText(g, "Type: " + GetMobCategoryName(MobInfo.Category), GearGraphics.ItemDetailFont, Brushes.White, 0, picY));
            propBlocks.Add(PrepareText(g, "Level: " + MobInfo.Level, GearGraphics.ItemDetailFont, Brushes.White, 0, picY += 16));
            string hpNum = !string.IsNullOrEmpty(MobInfo.FinalMaxHP) ? this.AddCommaSeparators(MobInfo.FinalMaxHP) : MobInfo.MaxHP.ToString("N0", System.Globalization.CultureInfo.InvariantCulture);
            propBlocks.Add(PrepareText(g, "HP: " + hpNum, GearGraphics.ItemDetailFont, Brushes.White, 0, picY += 16));
            string mpNum = !string.IsNullOrEmpty(MobInfo.FinalMaxMP) ? this.AddCommaSeparators(MobInfo.FinalMaxMP) : MobInfo.MaxMP.ToString("N0", System.Globalization.CultureInfo.InvariantCulture);
            propBlocks.Add(PrepareText(g, "MP: " + mpNum, GearGraphics.ItemDetailFont, Brushes.White, 0, picY += 16));
            if (MobInfo.HPRecovery > 0)
            {
                propBlocks.Add(PrepareText(g, "HP Recovery: " + MobInfo.HPRecovery.ToString("N0", System.Globalization.CultureInfo.InvariantCulture), GearGraphics.ItemDetailFont, Brushes.White, 0, picY += 16));
            }
            if (MobInfo.MPRecovery > 0)
            {
                propBlocks.Add(PrepareText(g, "MP Recovery: " + MobInfo.MPRecovery.ToString("N0", System.Globalization.CultureInfo.InvariantCulture), GearGraphics.ItemDetailFont, Brushes.White, 0, picY += 16));
            }
            propBlocks.Add(PrepareText(g, "Physical Damage: " + MobInfo.PADamage.ToString("N0", System.Globalization.CultureInfo.InvariantCulture), GearGraphics.ItemDetailFont, Brushes.White, 0, picY += 16));
            propBlocks.Add(PrepareText(g, "Magic Damage: " + MobInfo.MADamage.ToString("N0", System.Globalization.CultureInfo.InvariantCulture), GearGraphics.ItemDetailFont, Brushes.White, 0, picY += 16));
            //propBlocks.Add(PrepareText(g, "Physical Defense: " + MobInfo.PDDamage.ToString("N0", System.Globalization.CultureInfo.InvariantCulture), GearGraphics.ItemDetailFont, Brushes.White, 0, picY += 16));
            //propBlocks.Add(PrepareText(g, "Magic Defense: " + MobInfo.MDDamage.ToString("N0", System.Globalization.CultureInfo.InvariantCulture), GearGraphics.ItemDetailFont, Brushes.White, 0, picY += 16));
            propBlocks.Add(PrepareText(g, "Physical DEF Rate: " + MobInfo.PDRate + "%", GearGraphics.ItemDetailFont, Brushes.White, 0, picY += 16));
            propBlocks.Add(PrepareText(g, "Magic DEF Rate: " + MobInfo.MDRate + "%", GearGraphics.ItemDetailFont, Brushes.White, 0, picY += 16));
            //propBlocks.Add(PrepareText(g, "Accuracy: " + MobInfo.Acc, GearGraphics.ItemDetailFont, Brushes.White, 0, picY += 16)); //no longer used
            //propBlocks.Add(PrepareText(g, "Avoidability: " + MobInfo.Eva, GearGraphics.ItemDetailFont, Brushes.White, 0, picY += 16)); //no longer used
            propBlocks.Add(PrepareText(g, "Knockback: " + MobInfo.Pushed.ToString("N0", System.Globalization.CultureInfo.InvariantCulture), GearGraphics.ItemDetailFont, Brushes.White, 0, picY += 16));
            propBlocks.Add(PrepareText(g, "EXP: " + MobInfo.Exp.ToString("N0", System.Globalization.CultureInfo.InvariantCulture), GearGraphics.ItemDetailFont, Brushes.White, 0, picY += 16));
            if (MobInfo.CharismaEXP > 0)
            {
                propBlocks.Add(PrepareText(g, "Ambition EXP: " + MobInfo.CharismaEXP, GearGraphics.ItemDetailFont, Brushes.White, 0, picY += 16));
            }
            if (MobInfo.SenseEXP > 0)
            {
                propBlocks.Add(PrepareText(g, "Empathy EXP: " + MobInfo.SenseEXP, GearGraphics.ItemDetailFont, Brushes.White, 0, picY += 16));
            }
            if (MobInfo.InsightEXP > 0)
            {
                propBlocks.Add(PrepareText(g, "Insight EXP: " + MobInfo.InsightEXP, GearGraphics.ItemDetailFont, Brushes.White, 0, picY += 16));
            }
            if (MobInfo.WillEXP > 0)
            {
                propBlocks.Add(PrepareText(g, "Willpower EXP: " + MobInfo.WillEXP, GearGraphics.ItemDetailFont, Brushes.White, 0, picY += 16));
            }
            if (MobInfo.CraftEXP > 0)
            {
                propBlocks.Add(PrepareText(g, "Diligence EXP: " + MobInfo.CraftEXP, GearGraphics.ItemDetailFont, Brushes.White, 0, picY += 16));
            }
            if (MobInfo.CharmEXP > 0)
            {
                propBlocks.Add(PrepareText(g, "Charm EXP: " + MobInfo.CharmEXP, GearGraphics.ItemDetailFont, Brushes.White, 0, picY += 16));
            }
            if (MobInfo.WP > 0)
            {
                propBlocks.Add(PrepareText(g, "Weapon Points (for Zero): " + MobInfo.WP, GearGraphics.ItemDetailFont, Brushes.White, 0, picY += 16));
            }
            //propBlocks.Add(PrepareText(g, GetElemAttrString(MobInfo.ElemAttr), GearGraphics.ItemDetailFont, Brushes.White, 0, picY += 16));
            if (GetElemAttrString(MobInfo.ElemAttr) != "")
            {
                propBlocks.Add(PrepareText(g, "Elements: " + GetElemAttrString(MobInfo.ElemAttr), GearGraphics.ItemDetailFont, Brushes.White, 0, picY += 16));
            }

            picY += 28;

            if (MobInfo.Revive.Count > 0)
            {
                Dictionary<int, int> reviveCounts = new Dictionary<int, int>();
                foreach (var reviveID in MobInfo.Revive)
                {
                    int count = 0;
                    reviveCounts.TryGetValue(reviveID, out count);
                    reviveCounts[reviveID] = count + 1;
                }

                StringBuilder sb = new StringBuilder();
                //sb.Append("Summons after death: ");
                sb.Append("Revives into: ");
                int rowCount = 0;
                foreach (var kv in reviveCounts)
                {
                    if (rowCount++ > 0)
                    {
                        sb.AppendLine().Append("       ");
                    }
                    string mobName = GetMobName(kv.Key);
                    sb.AppendFormat("{0} ({1:D7})", mobName, kv.Key);
                    if (kv.Value > 1)
                    {
                        sb.Append(" * " + kv.Value);
                    }
                }

                propBlocks.Add(PrepareText(g, sb.ToString(), GearGraphics.ItemDetailFont, Brushes.GreenYellow, 0, picY));
            }
            g.Dispose();
            bmp.Dispose();

            //计算大小
            Rectangle titleRect = Measure(titleBlocks);
            Rectangle imgRect = Rectangle.Empty;
            Rectangle textRect = Measure(propBlocks);
            Bitmap mobImg = MobInfo.Default.Bitmap;
            if (mobImg != null)
            {
                if (mobImg.Width > 250 || mobImg.Height > 300) //进行缩放
                {
                    double scale = Math.Min((double)250 / mobImg.Width, (double)300 / mobImg.Height);
                    imgRect = new Rectangle(0, 0, (int)(mobImg.Width * scale), (int)(mobImg.Height * scale));
                }
                else
                {
                    imgRect = new Rectangle(0, 0, mobImg.Width, mobImg.Height);
                }
            }


            //布局 
            //水平排列
            int width = 0;
            if (!imgRect.IsEmpty)
            {
                textRect.X = imgRect.Width + 4;
            }
            width = Math.Max(titleRect.Width, Math.Max(imgRect.Right, textRect.Right));
            titleRect.X = (width - titleRect.Width) / 2;

            //垂直居中
            int height = Math.Max(imgRect.Height, textRect.Height);
            imgRect.Y = (height - imgRect.Height) / 2;
            textRect.Y = (height - textRect.Height) / 2;
            if (!titleRect.IsEmpty)
            {
                height += titleRect.Height + 4;
                imgRect.Y += titleRect.Bottom + 4;
                textRect.Y += titleRect.Bottom + 4;
            }

            //绘制
            bmp = new Bitmap(width + 20, height + 20);
            titleRect.Offset(10, 10);
            imgRect.Offset(10, 10);
            textRect.Offset(10, 10);
            g = Graphics.FromImage(bmp);
            //绘制背景
            GearGraphics.DrawNewTooltipBack(g, 0, 0, bmp.Width, bmp.Height);
            //绘制标题
            foreach (var item in titleBlocks)
            {
                DrawText(g, item, titleRect.Location);
            }
            //绘制图像
            if (mobImg != null && !imgRect.IsEmpty)
            {
                g.DrawImage(mobImg, imgRect);
            }
            //绘制文本
            foreach (var item in propBlocks)
            {
                DrawText(g, item, textRect.Location);
            }
            g.Dispose();
            return bmp;
        }

        private string GetMobName(int mobID)
        {
            StringResult sr;
            if (this.StringLinker == null || !this.StringLinker.StringMob.TryGetValue(mobID, out sr))
            {
                return null;
            }
            return sr.Name;
        }

        private string GetElemAttrString(MobElemAttr elemAttr)
        {
            StringBuilder sb1 = new StringBuilder();
            var elems = new[]
            {
                new {name = "Physical", attr = elemAttr.P },
                new {name = "Holy", attr = elemAttr.H },
                new {name = "Fire", attr = elemAttr.F },
                new {name = "Ice", attr = elemAttr.I },
                new {name = "Poison", attr = elemAttr.S },
                new {name = "Lightning", attr = elemAttr.L },
                new {name = "Dark", attr = elemAttr.D },
            };
            foreach (var item in elems)
            {
                if (item.attr != ElemResistance.Normal)
                {
                    sb1.Append($"{item.name} {GetElemAttrResistString(item.attr)}, ");
                }
            }
            return sb1.ToString().TrimEnd().TrimEnd(',');
        }

        public static string GetMobCategoryName(int category)
        {
            switch (category)
            {
                case 1: return "Mammal";
                case 2: return "Plant";
                case 3: return "Fish";
                case 4: return "Reptile";
                case 5: return "Spirit";
                case 6: return "Devil";
                case 7: return "Undead";
                case 8: return "Enchanted";
                default: return "None";
            }
        }

        private string GetElemAttrResistString(ElemResistance resist)
        {
            string e = null;
            switch (resist)
            {
                case ElemResistance.Immune: e = "immune"; break;
                case ElemResistance.Resist: e = "strong"; break;
                case ElemResistance.Normal: e = "neutral"; break;
                case ElemResistance.Weak: e = "weak"; break;
            }
            return e ?? "  ";
        }

        private string AddCommaSeparators(string number)
        {
            return Regex.Replace(number, @"^(\d+?)(\d{3})+$", m =>
            {
                var sb = new StringBuilder();
                sb.Append(m.Result("$1"));
                foreach (Capture cap in m.Groups[2].Captures)
                {
                    sb.Append(",");
                    sb.Append(cap.ToString());
                }
                return sb.ToString();
            });
        }
    }
}

```

`MapleNecrocer/CharaSimControl/NpcTooltipRenderer.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Drawing;
using System.Drawing.Imaging;
using WzComparerR2.CharaSim;
using WzComparerR2.Common;
using static WzComparerR2.CharaSimControl.RenderHelper;

namespace WzComparerR2.CharaSimControl
{
    public class NpcTooltipRenderer : TooltipRender
    {
        public NpcTooltipRenderer()
        {

        }


        public override object TargetItem
        {
            get { return this.NpcInfo; }
            set { this.NpcInfo = value as Npc; }
        }

        public Npc NpcInfo { get; set; }

        public override Bitmap Render()
        {
            if (NpcInfo == null)
            {
                return null;
            }
            Bitmap bmp = new Bitmap(1, 1, PixelFormat.Format32bppArgb);
            Graphics g = Graphics.FromImage(bmp);

            //预绘制
            List<TextBlock> titleBlocks = new List<TextBlock>();
            List<TextBlock> propBlocks = new List<TextBlock>();
            int picY = 0;

            if (NpcInfo.ID > -1)
            {
                string mobName = GetNpcName(NpcInfo.ID);
                var block = PrepareText(g, mobName ?? "(null)", GearGraphics.ItemNameFont2, Brushes.White, 0, 0);
                titleBlocks.Add(block);
                block = PrepareText(g, "ID:" + NpcInfo.ID, GearGraphics.ItemDetailFont, Brushes.White, block.Size.Width + 6, 0);
                titleBlocks.Add(block);
            }

            propBlocks.Add(PrepareText(g, "Location:", GearGraphics.ItemDetailFont, GearGraphics.GearNameBrushG, 0, 0));
            if (NpcInfo?.ID != null)
            {
                var locNode = PluginBase.PluginManager.FindWz("Etc\\NpcLocation.img\\" + NpcInfo.ID.ToString());
                if (locNode != null)
                {
                    foreach (var locMapNode in locNode.Nodes)
                    {
                        int mapID;
                        string mapName = null;
                        if (int.TryParse(locMapNode.Text, out mapID))
                        {
                            mapName = GetMapName(mapID);
                        }
                        string npcLoc = string.Format("{0}({1})", mapName ?? "null", locMapNode.Text);//{0}  ({1}) in the quotations for both location and mapID

                        propBlocks.Add(PrepareText(g, npcLoc, GearGraphics.ItemDetailFont, Brushes.White, 0, picY += 16));
                    }
                }
            }

            if (propBlocks.Count == 1) //获取地区失败
            {
                propBlocks.Add(PrepareText(g, "Unknown", GearGraphics.ItemDetailFont, Brushes.White, 0, picY += 16));
            }

            //计算大小
            Rectangle titleRect = Measure(titleBlocks);
            Rectangle imgRect = Rectangle.Empty;
            Rectangle textRect = Measure(propBlocks);
            Bitmap npcImg = NpcInfo.Default.Bitmap;
            if (npcImg != null)
            {
                if (npcImg.Width > 250 || npcImg.Height > 300) //进行缩放
                {
                    double scale = Math.Min((double)250 / npcImg.Width, (double)300 / npcImg.Height);
                    imgRect = new Rectangle(0, 0, (int)(npcImg.Width * scale), (int)(npcImg.Height * scale));
                }
                else
                {
                    imgRect = new Rectangle(0, 0, npcImg.Width, npcImg.Height);
                }
            }

            //布局 
            //水平排列
            int width = 0;
            if (!imgRect.IsEmpty)
            {
                textRect.X = imgRect.Width + 4;
            }
            width = Math.Max(titleRect.Width, Math.Max(imgRect.Right, textRect.Right));
            titleRect.X = (width - titleRect.Width) / 2;

            //垂直居中
            int height = Math.Max(imgRect.Height, textRect.Height);
            imgRect.Y = (height - imgRect.Height) / 2;
            textRect.Y = (height - textRect.Height) / 2;
            if (!titleRect.IsEmpty)
            {
                height += titleRect.Height + 4;
                imgRect.Y += titleRect.Bottom + 4;
                textRect.Y += titleRect.Bottom + 4;
            }

            //绘制
            bmp = new Bitmap(width + 20, height + 20);
            titleRect.Offset(10, 10);
            imgRect.Offset(10, 10);
            textRect.Offset(10, 10);
            g = Graphics.FromImage(bmp);
            //绘制背景
            GearGraphics.DrawNewTooltipBack(g, 0, 0, bmp.Width, bmp.Height);
            //绘制标题
            foreach (var item in titleBlocks)
            {
                DrawText(g, item, titleRect.Location);
            }
            //绘制图像
            if (npcImg != null && !imgRect.IsEmpty)
            {
                g.DrawImage(npcImg, imgRect);
            }
            //绘制文本
            foreach (var item in propBlocks)
            {
                DrawText(g, item, textRect.Location);
            }
            g.Dispose();
            return bmp;
        }

        private string GetNpcName(int npcID)
        {
            StringResult sr;
            if (this.StringLinker == null || !this.StringLinker.StringNpc.TryGetValue(npcID, out sr))
            {
                return null;
            }
            return sr.Name;
        }

        private string GetMapName(int mapID)
        {
            StringResult sr;
            if (this.StringLinker == null || !this.StringLinker.StringMap.TryGetValue(mapID, out sr))
            {
                return null;
            }
            return sr.Name;
        }
    }
}

```

`MapleNecrocer/CharaSimControl/ObjectMouseEventArgs.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Windows.Forms;
using WzComparerR2.CharaSim;

namespace WzComparerR2.CharaSimControl
{
    public class ObjectMouseEventArgs : MouseEventArgs
    {
        public ObjectMouseEventArgs(MouseEventArgs e, object obj)
            : this(e.Button, e.Clicks, e.X, e.Y, e.Delta, obj)
        {
        }

        public ObjectMouseEventArgs(MouseButtons button, int clicks, int x, int y, int delta, object obj) :
            base(button, clicks, x, y, delta)
        {
            this.obj = obj;
        }

        private object obj;

        public object Obj
        {
            get { return obj; }
            set { obj = value; }
        }
    }
}

```

`MapleNecrocer/CharaSimControl/ObjectMouseEventHandler.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace WzComparerR2.CharaSimControl
{
    public delegate void ObjectMouseEventHandler(object sender, ObjectMouseEventArgs e);
}

```

`MapleNecrocer/CharaSimControl/RecipeTooltipRender.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;
using System.Drawing.Drawing2D;
using Resource = CharaSimResource.Resource;
using WzComparerR2.Common;
using WzComparerR2.CharaSim;

namespace WzComparerR2.CharaSimControl
{
    public class RecipeTooltipRender : TooltipRender
    {
        public RecipeTooltipRender()
        {
        }

        public Recipe Recipe { get; set; }

        public override object TargetItem
        {
            get
            {
                return this.Recipe;
            }
            set
            {
                this.Recipe = value as Recipe;
            }
        }

        public override Bitmap Render()
        {
            if (this.Recipe == null)
            {
                return null;
            }
            int picHeight;
            Bitmap originBmp = RenderRecipe(out picHeight);
            Bitmap tooltip = new Bitmap(originBmp.Width, picHeight);
            Graphics g = Graphics.FromImage(tooltip);

            //绘制背景区域
            GearGraphics.DrawNewTooltipBack(g, 0, 0, tooltip.Width, tooltip.Height);

            //复制图像
            g.DrawImage(originBmp, 0, 0, new Rectangle(0, 0, originBmp.Width, picHeight), GraphicsUnit.Pixel);

            //左上角
            g.DrawImage(Resource.UIToolTip_img_Item_Frame2_cover, 3, 3);

            if (this.ShowObjectID)
            {
                GearGraphics.DrawGearDetailNumber(g, 3, 3, Recipe.RecipeID.ToString("d8"), true);
            }

            if (originBmp != null)
                originBmp.Dispose();

            g.Dispose();
            return tooltip;
        }

        private Bitmap RenderRecipe(out int picH)
        {
            Bitmap tooltip = new Bitmap(290, DefaultPicHeight);
            Graphics g = Graphics.FromImage(tooltip);
            StringFormat fmt = (StringFormat)StringFormat.GenericTypographic.Clone();
            fmt.Alignment = StringAlignment.Center;

            picH = 10;
            StringResult sr;
            string title = "Crafting Recipe";
            if (this.Recipe.MainTargetItemID != 0)
            {
                sr = GetSRByItemID(this.Recipe.MainTargetItemID);
                if (sr == null)
                {
                    title += " - " + this.Recipe.MainTargetItemID;
                }
                else
                {
                    title += " - " + sr.Name;
                }
            }
            g.DrawString(title, GearGraphics.ItemDetailFont, GearGraphics.GreenBrush2, 145, picH, fmt);
            picH += 16;

            g.DrawString("Item", GearGraphics.ItemDetailFont, GearGraphics.GreenBrush2, 13, picH);
            picH += 16;

            fmt.Alignment = StringAlignment.Far;
            foreach (RecipeItemInfo itemInfo in this.Recipe.TargetItems)
            {
                sr = GetSRByItemID(itemInfo.ItemID);
                string text = sr != null ? sr.Name : itemInfo.ItemID.ToString();
                text += " x " + itemInfo.Count;
                g.DrawString(text, GearGraphics.ItemDetailFont2, Brushes.White, 13, picH, StringFormat.GenericTypographic);
                g.DrawString(itemInfo.ProbWeight + "%", GearGraphics.ItemDetailFont2, Brushes.White, 278, picH, fmt);
                picH += 16;
            }

            picH += 4;

            g.DrawString("Material", GearGraphics.ItemDetailFont, GearGraphics.GreenBrush2, 13, picH);
            picH += 16;
            foreach (RecipeItemInfo itemInfo in this.Recipe.RecipeItems)
            {
                sr = GetSRByItemID(itemInfo.ItemID);
                string text = sr != null ? sr.Name : itemInfo.ItemID.ToString();
                text += " x " + itemInfo.Count;
                g.DrawString(text, GearGraphics.ItemDetailFont2, Brushes.White, 13, picH, StringFormat.GenericTypographic);
                picH += 16;
            }

            picH += 4;
            fmt.Dispose();
            g.Dispose();
            return tooltip;
        }

        private StringResult GetSRByItemID(int itemID)
        {
            if (StringLinker == null)
            {
                return null;
            }

            StringResult sr = null;

            int itemIDClass = itemID / 1000000;
            if (itemIDClass == 1)
            {
                StringLinker.StringEqp.TryGetValue(itemID, out sr);
            }
            else if (itemIDClass >= 2 && itemIDClass <= 5)
            {
                StringLinker.StringItem.TryGetValue(itemID, out sr);
            }

            return sr;
        }
    }
}

```

`MapleNecrocer/CharaSimControl/RenderHelper.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;

namespace WzComparerR2.CharaSimControl
{
    class RenderHelper
    {
        private RenderHelper()
        {
        }

        public static TextBlock PrepareText(Graphics g, string text, Font font, Brush brush, int x, int y)
        {
            SizeF size = g.MeasureString(text, font, Int32.MaxValue, StringFormat.GenericTypographic);
            TextBlock block = new TextBlock()
            {
                Text = text,
                Font = font,
                Brush = brush,
                Position = new Point(x, y),
                Size = new Size((int)Math.Round(size.Width, MidpointRounding.AwayFromZero),
                    (int)Math.Round(size.Height, MidpointRounding.AwayFromZero))
            };
            return block;
        }

        public static void DrawText(Graphics g, TextBlock block, Point offset)
        {
            g.DrawString(block.Text, block.Font, block.Brush,
                block.Position.X + offset.X, block.Position.Y + offset.Y,
                StringFormat.GenericTypographic);
        }

        public static Rectangle Measure(IEnumerable<TextBlock> blocks)
        {
            Rectangle rect = Rectangle.Empty;

            foreach (var block in blocks)
            {
                var blockRect = block.Rectangle;
                if (!blockRect.IsEmpty)
                {
                    rect = Rectangle.Union(rect, blockRect);
                }
            }
            return rect;
        }
    }
}

```

`MapleNecrocer/CharaSimControl/SetItemTooltipRender.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Linq;
using System.Windows.Forms;
using Resource = CharaSimResource.Resource;
using WzComparerR2.PluginBase;
using WzComparerR2.WzLib;
using WzComparerR2.Common;
using System.Text.RegularExpressions;
using WzComparerR2.CharaSim;

namespace WzComparerR2.CharaSimControl
{
    public class SetItemTooltipRender : TooltipRender
    {
        public SetItemTooltipRender()
        {
        }

        public SetItem SetItem { get; set; }

        public override object TargetItem
        {
            get { return this.SetItem; }
            set { this.SetItem = value as SetItem; }
        }

        public bool IsCombineProperties { get; set; } = true;

        public override Bitmap Render()
        {
            if (this.SetItem == null)
            {
                return null;
            }

            bool specialPetSetEffectName = this.SetItem.ItemIDs.Parts.Any(p => p.Value.ItemIDs.Any(i => isSpecialPet(i.Key)));

            int width = 261;
            int picHeight1;
            Bitmap originBmp = RenderSetItem(specialPetSetEffectName, out picHeight1);
            int picHeight2 = 0;
            Bitmap effectBmp = null;

            if (this.SetItem.ExpandToolTip)
            {
                effectBmp = RenderEffectPart(specialPetSetEffectName, out picHeight2);
                width += 261;
            }

            Bitmap tooltip = new Bitmap(width, Math.Max(picHeight1, picHeight2));
            Graphics g = Graphics.FromImage(tooltip);

            //绘制左侧
            GearGraphics.DrawNewTooltipBack(g, 0, 0, originBmp.Width, picHeight1);
            g.DrawImage(originBmp, 0, 0, new Rectangle(0, 0, originBmp.Width, picHeight1), GraphicsUnit.Pixel);

            //绘制右侧
            if (effectBmp != null)
            {
                GearGraphics.DrawNewTooltipBack(g, originBmp.Width, 0, effectBmp.Width, picHeight2);
                g.DrawImage(effectBmp, originBmp.Width, 0, new Rectangle(0, 0, effectBmp.Width, picHeight2), GraphicsUnit.Pixel);
            }

            originBmp?.Dispose();
            effectBmp?.Dispose();
            g.Dispose();
            return tooltip;
        }

        private bool isSpecialPet(int itemID)
        {
            if (itemID / 1000000 != 5)
            {
                return false;
            }
            Wz_Node itemNode = PluginBase.PluginManager.FindWz(string.Format(@"Item\Pet\{0:D7}.img", itemID));
            if (itemNode != null)
            {
                var item = Item.CreateFromNode(itemNode, PluginManager.FindWz);
                int value;
                return item.Props.TryGetValue(ItemPropType.wonderGrade, out value) && (value == 1 || value == 4 || value == 5 || value == 6);
            }
            return false;
        }

        private Bitmap RenderSetItem(bool specialPetSetEffectName, out int picHeight)
        {
            var MAX_WIDTH = 261;//default value was 261
            Bitmap setBitmap = new Bitmap(MAX_WIDTH, DefaultPicHeight);
            Graphics g = Graphics.FromImage(setBitmap);
            StringFormat format = new StringFormat();
            format.Alignment = StringAlignment.Center;

            var fmtItemName = new StringFormat()
            {
                Trimming = StringTrimming.EllipsisCharacter,
                FormatFlags = StringFormatFlags.NoWrap
            };
            var fmtItemType = new StringFormat() { Alignment = StringAlignment.Far };

            picHeight = 10;
            TextRenderer.DrawText(g, this.SetItem.SetItemName, GearGraphics.EquipDetailFont2, new Point(261, 10), ((SolidBrush)GearGraphics.GreenBrush2).Color, TextFormatFlags.HorizontalCenter);//default value is '261' - Used for set name centered in set effect tooltip window
            picHeight += 25;

            format.Alignment = StringAlignment.Far;
            Wz_Node characterWz = PluginManager.FindWz(Wz_Type.Character);

            if (this.SetItem.SetItemID > 0)
            {
                HashSet<string> partNames = new HashSet<string>();

                foreach (var setItemPart in this.SetItem.ItemIDs.Parts)
                {
                    string itemName = setItemPart.Value.RepresentName;
                    string typeName = setItemPart.Value.TypeName;

                    if (string.IsNullOrEmpty(typeName) && SetItem.Parts)
                    {
                        typeName = "Equip";
                    }

                    ItemBase itemBase = null;
                    bool cash = false;

                    if (setItemPart.Value.ItemIDs.Count > 0)
                    {
                        var itemID = setItemPart.Value.ItemIDs.First().Key;

                        switch (itemID / 1000000)
                        {
                            case 0: //avatar
                            case 1: //gear
                                if (characterWz != null)
                                {
                                    foreach (Wz_Node typeNode in characterWz.Nodes)
                                    {
                                        Wz_Node itemNode = typeNode.FindNodeByPath(string.Format("{0:D8}.img", itemID), true);
                                        if (itemNode != null)
                                        {
                                            var gear = Gear.CreateFromNode(itemNode, PluginManager.FindWz);
                                            cash = gear.Cash;
                                            itemBase = gear;
                                            break;
                                        }
                                    }
                                }
                                break;

                            case 5: //Pet
                                {
                                    Wz_Node itemNode = PluginBase.PluginManager.FindWz(string.Format(@"Item\Pet\{0:D7}.img", itemID));
                                    if (itemNode != null)
                                    {
                                        var item = Item.CreateFromNode(itemNode, PluginManager.FindWz);
                                        cash = item.Cash;
                                        itemBase = item;
                                    }
                                }
                                break;
                        }
                    }

                    if (string.IsNullOrEmpty(itemName) || string.IsNullOrEmpty(typeName))
                    {
                        if (setItemPart.Value.ItemIDs.Count > 0)
                        {
                            var itemID = setItemPart.Value.ItemIDs.First().Key;
                            StringResult sr = null; ;
                            if (this.StringLinker != null)
                            {
                                if (this.StringLinker.StringEqp.TryGetValue(itemID, out sr))
                                {
                                    itemName = sr.Name;
                                    if (typeName == null)
                                    {
                                        typeName = ItemStringHelper.GetSetItemGearTypeString(Gear.GetGearType(itemID));
                                    }
                                    switch (Gear.GetGender(itemID))
                                    {
                                        case 0: itemName += " (Male)"; break;
                                        case 1: itemName += " (Female)"; break;
                                    }
                                }
                                else if (this.StringLinker.StringItem.TryGetValue(itemID, out sr)) //兼容宠物
                                {
                                    itemName = sr.Name;
                                    //if (typeName == null)
                                    {
                                        if (itemID / 10000 == 500)
                                        {
                                            typeName = "Pet";
                                        }
                                        else
                                        {
                                            typeName = "";
                                        }
                                    }
                                }
                            }
                            if (sr == null)
                            {
                                itemName = "(null)";
                            }
                        }
                    }

                    itemName = itemName ?? string.Empty;
                    typeName = typeName ?? "Equip";

                    if (!Regex.IsMatch(typeName, @"^(\(.*\)|（.*）|\[.*\])$"))
                    {
                        typeName = "(" + typeName + ")";
                    }

                    if (this.SetItem.Effects.Count > 1 && this.SetItem.ItemIDs.Parts.Count == 1)
                    {
                        typeName += "  [0/3]";
                    }

                    if (!partNames.Contains(itemName + typeName))
                    {
                        partNames.Add(itemName + typeName);
                        Brush brush = setItemPart.Value.Enabled ? Brushes.White : GearGraphics.GrayBrush2;
                        //measure itemType's text width
                        var layoutSize = g.MeasureString(typeName, GearGraphics.EquipDetailFont2, MAX_WIDTH, fmtItemType);//remove: + "..." after typeName to fix ellipsis issue
                        if (!cash)
                        {
                            //TextRenderer.DrawText(g, itemName, GearGraphics.EquipDetailFont2, new Rectangle(10, picHeight, MAX_WIDTH - (int)layoutSize.Width, 18), ((SolidBrush)brush).Color, TextFormatFlags.EndEllipsis | TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix);
                            //TextRenderer.DrawText(g, typeName, GearGraphics.EquipDetailFont2, new Point(250 - TextRenderer.MeasureText(g, typeName, GearGraphics.EquipDetailFont2, new Size(int.MaxValue, int.MaxValue), TextFormatFlags.NoPadding).Width, picHeight), ((SolidBrush)brush).Color, TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix);
                            //picHeight += 18;
                            int typeWidth = TextRenderer.MeasureText(g, typeName, GearGraphics.EquipDetailFont2, new Size(int.MaxValue, int.MaxValue), TextFormatFlags.NoPadding).Width;
                            TextRenderer.DrawText(g, typeName, GearGraphics.EquipDetailFont2, new Point(261 - 10 - typeWidth, picHeight), ((SolidBrush)brush).Color, TextFormatFlags.NoPadding);
                            TextRenderer.DrawText(g, Compact(g, itemName, 261 - 12 - typeWidth - 10), GearGraphics.EquipDetailFont2, new Point(10, picHeight), ((SolidBrush)brush).Color, TextFormatFlags.NoPadding);
                            picHeight += 18;
                        }
                        else
                        {
                            g.FillRectangle(GearGraphics.GearIconBackBrush2, 10, picHeight, 36, 36);
                            g.DrawImage(Resource.Item_shadow, 10 + 2 + 3, picHeight + 2 + 32 - 6);
                            if (itemBase?.IconRaw.Bitmap != null)
                            {
                                var icon = itemBase.IconRaw;
                                g.DrawImage(icon.Bitmap, 10 + 2 - icon.Origin.X, picHeight + 2 + 32 - icon.Origin.Y);
                            }
                            g.DrawImage(Resource.CashItem_0, 10 + 2 + 20, picHeight + 2 + 32 - 12);
                            //TextRenderer.DrawText(g, itemName, GearGraphics.EquipDetailFont2, new Point(52, picHeight), ((SolidBrush)brush).Color, TextFormatFlags.NoPadding);
                            //TextRenderer.DrawText(g, typeName, GearGraphics.EquipDetailFont2, new Point(261 - 10 - TextRenderer.MeasureText(g, typeName, GearGraphics.EquipDetailFont2, new Size(int.MaxValue, int.MaxValue), TextFormatFlags.NoPadding).Width, picHeight), ((SolidBrush)brush).Color, TextFormatFlags.NoPadding);
                            int typeWidth = TextRenderer.MeasureText(g, typeName, GearGraphics.EquipDetailFont2, new Size(int.MaxValue, int.MaxValue), TextFormatFlags.NoPadding).Width;
                            TextRenderer.DrawText(g, typeName, GearGraphics.EquipDetailFont2, new Point(261 - 10 - typeWidth, picHeight), ((SolidBrush)brush).Color, TextFormatFlags.NoPadding);
                            TextRenderer.DrawText(g, Compact(g, itemName, 261 - 10 - typeWidth - 52), GearGraphics.EquipDetailFont2, new Point(52, picHeight), ((SolidBrush)brush).Color, TextFormatFlags.NoPadding);
                            if (setItemPart.Value.ByGender)
                            {
                                picHeight += 18;
                                foreach (var itemID in setItemPart.Value.ItemIDs.Keys)
                                {
                                    StringResult sr = null; ;
                                    if (this.StringLinker != null)
                                    {
                                        if (this.StringLinker.StringEqp.TryGetValue(itemID, out sr))
                                        {
                                            itemName = sr.Name;
                                            switch (Gear.GetGender(itemID))
                                            {
                                                case 0: itemName += " (Male)"; break;
                                                case 1: itemName += " (Female)"; break;
                                            }
                                        }
                                        else if (this.StringLinker.StringItem.TryGetValue(itemID, out sr)) //兼容宠物
                                        {
                                            itemName = sr.Name;
                                        }
                                    }
                                    if (sr == null)
                                    {
                                        itemName = "(null)";
                                    }
                                    TextRenderer.DrawText(g, "- " + itemName, GearGraphics.EquipDetailFont2, new Point(61, picHeight), ((SolidBrush)brush).Color, TextFormatFlags.NoPadding);
                                    picHeight += 18;
                                }
                            }
                            else
                            {
                                picHeight += 40;
                            }
                        }
                    }
                }
            }
            else
            {
                for (int i = 0; i < this.SetItem.CompleteCount; ++i)
                {
                    TextRenderer.DrawText(g, "(None)", GearGraphics.EquipDetailFont2, new Point(10, picHeight), ((SolidBrush)GearGraphics.GrayBrush2).Color, TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix);
                    TextRenderer.DrawText(g, "Not Equipped", GearGraphics.EquipDetailFont2, new Point(252 - TextRenderer.MeasureText(g, "Not Equipped", GearGraphics.EquipDetailFont2, new Size(int.MaxValue, int.MaxValue), TextFormatFlags.NoPadding).Width, picHeight), ((SolidBrush)GearGraphics.GrayBrush2).Color, TextFormatFlags.NoPadding);
                    picHeight += 18;
                }
            }

            if (!this.SetItem.ExpandToolTip)
            {
                picHeight += 5;
                g.DrawLine(Pens.White, 6, picHeight, 254, picHeight);//分割线
                picHeight += 9;
                RenderEffect(g, specialPetSetEffectName, ref picHeight);
            }
            picHeight += 11;

            format.Dispose();
            g.Dispose();
            return setBitmap;
        }

        private static string Compact(Graphics g, string text, int width) // https://www.codeproject.com/Articles/37503/Auto-Ellipsis
        {
            Size s = TextRenderer.MeasureText(g, text, GearGraphics.EquipDetailFont2, new Size(int.MaxValue, int.MaxValue), TextFormatFlags.NoPadding);

            // control is large enough to display the whole text 
            if (s.Width <= width)
                return text;

            int len = 0;
            int seg = text.Length;
            string fit = "";

            // find the longest string that fits into
            // the control boundaries using bisection method 
            while (seg > 1)
            {
                seg -= seg / 2;

                int left = len + seg;

                if (left > text.Length)
                    continue;

                // build and measure a candidate string with ellipsis
                string tst = text.Substring(0, left) + "..";

                s = TextRenderer.MeasureText(g, tst, GearGraphics.EquipDetailFont2, new Size(int.MaxValue, int.MaxValue), TextFormatFlags.NoPadding);

                // candidate string fits into control boundaries, 
                // try a longer string
                // stop when seg <= 1 
                if (s.Width <= width)
                {
                    len += seg;
                    fit = tst;
                }
            }

            return fit;
        }

        private Bitmap RenderEffectPart(bool specialPetSetEffectName, out int picHeight)
        {
            Bitmap effBitmap = new Bitmap(261, DefaultPicHeight);
            Graphics g = Graphics.FromImage(effBitmap);
            picHeight = 9;
            RenderEffect(g, specialPetSetEffectName, ref picHeight);
            picHeight += 11;
            g.Dispose();
            return effBitmap;
        }

        /// <summary>
        /// 绘制套装属性。
        /// </summary>
        private void RenderEffect(Graphics g, bool specialPetSetEffectName, ref int picHeight)
        {
            foreach (KeyValuePair<int, SetItemEffect> effect in this.SetItem.Effects)
            {
                string effTitle;
                if (this.SetItem.SetItemID < 0)
                {
                    effTitle = $"Active Within World({effect.Key} / {this.SetItem.CompleteCount})";
                }
                else if (specialPetSetEffectName && this.SetItem.SetItemName.EndsWith(" Set"))
                {
                    effTitle = $"{Regex.Replace(this.SetItem.SetItemName, " Set$", "")} {effect.Key} set effect";
                }
                else
                {
                    effTitle = effect.Key + " Set Items Equipped";
                }
                TextRenderer.DrawText(g, effTitle, GearGraphics.EquipDetailFont, new Point(10, picHeight), ((SolidBrush)GearGraphics.GreenBrush2).Color, TextFormatFlags.NoPadding);
                picHeight += 15;
                //Brush brush = effect.Value.Enabled ? Brushes.White : GearGraphics.GrayBrush2;
                var color = effect.Value.Enabled ? Color.White : GearGraphics.GrayColor2;

                //T116 合并套装
                var props = IsCombineProperties ? Gear.CombineProperties(effect.Value.PropsV5) : effect.Value.PropsV5;
                foreach (KeyValuePair<GearPropType, object> prop in props)
                {
                    if (prop.Key == GearPropType.Option)
                    {
                        List<Potential> ops = (List<Potential>)prop.Value;
                        foreach (Potential p in ops)
                        {
                            GearGraphics.DrawString(g, p.ConvertSummary(), GearGraphics.EquipDetailFont2, 10, 244, ref picHeight, 15, textColor: color);
                        }
                    }
                    else if (prop.Key == GearPropType.OptionToMob)
                    {
                        List<SetItemOptionToMob> ops = (List<SetItemOptionToMob>)prop.Value;
                        foreach (SetItemOptionToMob p in ops)
                        {
                            GearGraphics.DrawPlainText(g, p.ConvertSummary(), GearGraphics.EquipDetailFont2, color, 10, 244, ref picHeight, 15);
                        }
                    }
                    else if (prop.Key == GearPropType.activeSkill)
                    {
                        List<SetItemActiveSkill> ops = (List<SetItemActiveSkill>)prop.Value;
                        foreach (SetItemActiveSkill p in ops)
                        {
                            StringResult sr;
                            if (StringLinker == null || !StringLinker.StringSkill.TryGetValue(p.SkillID, out sr))
                            {
                                sr = new StringResult();
                                sr.Name = p.SkillID.ToString();
                            }
                            //string summary = "<" + sr.Name.Replace(Environment.NewLine, "") + "> Skill Available";
                            string summary = $"<{sr.Name.Replace(Environment.NewLine, "")}> Skill Available";
                            GearGraphics.DrawPlainText(g, summary, GearGraphics.EquipDetailFont2, color, 10, 244, ref picHeight, 15);
                        }
                    }
                    else if (prop.Key == GearPropType.bonusByTime)
                    {
                        var ops = (List<SetItemBonusByTime>)prop.Value;
                        foreach (SetItemBonusByTime p in ops)
                        {
                            GearGraphics.DrawPlainText(g, $"{p.TermStart} Hr Effect", GearGraphics.EquipDetailFont2, color, 10, 244, ref picHeight, 15);
                            foreach (var bonusProp in p.Props)
                            {
                                var summary = ItemStringHelper.GetGearPropString(bonusProp.Key, Convert.ToInt32(bonusProp.Value));
                                GearGraphics.DrawPlainText(g, summary, GearGraphics.EquipDetailFont2, color, 10, 244, ref picHeight, 15);
                            }
                        }
                    }
                    else
                    {
                        var summary = ItemStringHelper.GetGearPropString(prop.Key, Convert.ToInt32(prop.Value));
                        GearGraphics.DrawPlainText(g, summary, GearGraphics.EquipDetailFont2, color, 10, 244, ref picHeight, 15);
                    }
                }
            }
        }
    }
}
```

`MapleNecrocer/CharaSimControl/SkillTooltipRender.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;
using System.Drawing.Drawing2D;
using WzComparerR2.Common;
using WzComparerR2.CharaSim;

namespace WzComparerR2.CharaSimControl
{
    public class SkillTooltipRender : TooltipRender
    {
        public SkillTooltipRender()
        {
        }

        Skill skill;

        public Skill Skill
        {
            get { return skill; }
            set { skill = value; }
        }

        public override Bitmap Render()
        {
            if (this.skill == null)
            {
                return null;
            }

            int picHeight;
            Bitmap originBmp = RenderSkill(out picHeight);
            Bitmap tooltip = new Bitmap(290, picHeight);
            Graphics g = Graphics.FromImage(tooltip);

            int iconY = 33;
            //复制图像
            g.FillRectangle(GearGraphics.GearBackBrush, 2, 2, 286, picHeight - 4);
            g.CompositingMode = CompositingMode.SourceCopy;
            g.FillRectangle(GearGraphics.GearIconBackBrush, 14, iconY, 68, 68);
            g.CompositingMode = CompositingMode.SourceOver;
            g.DrawImage(originBmp, 0, 0, new Rectangle(0, 0, 290, picHeight - 2), GraphicsUnit.Pixel);

            //边框
            g.DrawLines(GearGraphics.GearBackPen, GearGraphics.GetBorderPath(0, 290, picHeight));

            g.Dispose();
            return tooltip;
        }

        private Bitmap RenderSkill(out int picH)
        {
            //int h = 128;
            Bitmap bitmap = new Bitmap(290, DefaultPicHeight);
            Graphics g = Graphics.FromImage(bitmap);

            picH = 33; //iconY

            StringResult sr;
            if (!StringLinker.StringSkill.TryGetValue(skill.SkillID, out sr))
            {
                sr = new StringResultSkill();
                sr.Name = "(null)";
            }

            StringFormat format = new StringFormat();
            format.Alignment = StringAlignment.Center;

            g.DrawString(sr.Name, GearGraphics.ItemNameFont, Brushes.White, 143, 10, format);//绘制标题
            if (skill.Icon.Bitmap != null)
            {
                g.DrawImage(GearGraphics.EnlargeBitmap(skill.Icon.Bitmap),
                14 + (1 - skill.Icon.Origin.X) * 2,
                picH + (33 - skill.Icon.Bitmap.Height) * 2);//绘制图标
            }

            //绘制desc
            picH = 35;
            GearGraphics.DrawString(g, "[Master Level: " + skill.MaxLevel + "]", GearGraphics.ItemDetailFont, 90, 270, ref picH, 16);
            if (sr.Desc != null)
            {
                GearGraphics.DrawString(g, sr.Desc, GearGraphics.ItemDetailFont, 90, 270, ref picH, 16);
            }

            picH = Math.Max(picH, 114);
            g.DrawLine(Pens.White, 6, picH, 283, picH); //分割线
            picH += 5;

            if (skill.Level > 0)
            {
                string hStr = null;
                if (skill.PreBBSkill)
                {
                    if (sr.SkillH.Count >= skill.Level)
                    {
                        hStr = sr.SkillH[skill.Level - 1];
                    }
                }
                else
                {
                    if (sr.SkillH.Count > 0)
                    {
                        hStr = SummaryParser.GetSkillSummary(skill,skill.Level, sr, SummaryParams.Default);
                    }
                }

                picH += 4;
                GearGraphics.DrawString(g, "[Current Level " + skill.Level + "]", GearGraphics.ItemDetailFont, 8, 272, ref picH, 16);
                GearGraphics.DrawString(g, hStr, GearGraphics.ItemDetailFont, 8, 272, ref picH, 16);
            }

            if (skill.Level < skill.MaxLevel)
            {
                string hStr = null;
                if (skill.PreBBSkill)
                {
                    if (sr.SkillH.Count >= skill.Level + 1)
                    {
                        hStr = sr.SkillH[skill.Level];
                    }
                }
                else
                {
                    if (sr.SkillH.Count > 0)
                    {
                        hStr = SummaryParser.GetSkillSummary(skill, skill.Level+1, sr, SummaryParams.Default); 
                    }
                }

                picH += 4;
                GearGraphics.DrawString(g, "[Next Level " + (skill.Level + 1) + "]", GearGraphics.ItemDetailFont, 8, 272, ref picH, 16);
                GearGraphics.DrawString(g, hStr, GearGraphics.ItemDetailFont, 8, 272, ref picH, 16);
            }
            picH += 9;
            g.Dispose();
            return bitmap;
        }
    }
}

```

`MapleNecrocer/CharaSimControl/SkillTooltipRender2.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;
using System.Windows.Forms;
using Resource = CharaSimResource.Resource;
using WzComparerR2.Common;
using WzComparerR2.CharaSim;
using WzComparerR2.WzLib;

namespace WzComparerR2.CharaSimControl
{
    public class SkillTooltipRender2 : TooltipRender
    {
        public SkillTooltipRender2()
        {
        }

        public Skill Skill { get; set; }

        public override object TargetItem
        {
            get { return this.Skill; }
            set { this.Skill = value as Skill; }
        }

        public bool ShowProperties { get; set; } = true;
        public bool ShowDelay { get; set; }
        public bool ShowReqSkill { get; set; } = true;
        public bool DisplayCooltimeMSAsSec { get; set; } = true;
        public bool DisplayPermyriadAsPercent { get; set; } = true;
        public bool IsWideMode { get; set; } = true;

        public TooltipRender LinkRidingGearRender { get; set; }

        public override Bitmap Render()
        {
            if (this.Skill == null)
            {
                return null;
            }

            CanvasRegion region = this.IsWideMode ? CanvasRegion.Wide : CanvasRegion.Original;

            int picHeight;
            Bitmap originBmp = RenderSkill(region, out picHeight);
            //Bitmap tooltip = new Bitmap(500, picHeight);//original value is 320, however the width in GMS is 500
            Bitmap ridingGearBmp = null;

            int vehicleID = Skill.VehicleID;
            if (vehicleID == 0)
            {
                vehicleID = PluginBase.PluginManager.FindWz(string.Format(@"Skill\RidingSkillInfo.img\{0:D7}\vehicleID", Skill.SkillID)).GetValueEx<int>(0);
            }
            if (vehicleID != 0)
            {
                Wz_Node imgNode = PluginBase.PluginManager.FindWz(string.Format(@"Character\TamingMob\{0:D8}.img", vehicleID));
                if (imgNode != null)
                {
                    Gear gear = Gear.CreateFromNode(imgNode, path => PluginBase.PluginManager.FindWz(path));
                    if (gear != null)
                    {
                        ridingGearBmp = RenderLinkRidingGear(gear);
                    }
                }
            }

            Size totalSize = new Size(originBmp.Width, picHeight);
            Point ridingGearOrigin = Point.Empty;

            if (ridingGearBmp != null)
            {
                totalSize.Width += ridingGearBmp.Width;
                totalSize.Height = Math.Max(picHeight, ridingGearBmp.Height);
                ridingGearOrigin.X = originBmp.Width;
            }

            Bitmap tooltip = new Bitmap(totalSize.Width, totalSize.Height);
            Graphics g = Graphics.FromImage(tooltip);

            //绘制背景区域
            GearGraphics.DrawNewTooltipBack(g, 0, 0, originBmp.Width, picHeight);

            //复制图像
            //g.DrawImage(originBmp, 0, 0, new Rectangle(0, 0, 500, picHeight), GraphicsUnit.Pixel);
            g.DrawImage(originBmp, 0, 0, new Rectangle(0, 0, originBmp.Width, picHeight), GraphicsUnit.Pixel);

            //左上角
            g.DrawImage(Resource.UIToolTip_img_Item_Frame2_cover, 3, 3);

            if (this.ShowObjectID)
            {
                GearGraphics.DrawGearDetailNumber(g, 3, 3, Skill.SkillID.ToString("d7"), true);
            }

            if (ridingGearBmp != null)
            {
                totalSize.Width += ridingGearBmp.Width;
                totalSize.Height = Math.Max(picHeight, ridingGearBmp.Height);
                ridingGearOrigin.X = originBmp.Width;
            }

            if (originBmp != null)
                originBmp.Dispose();
            if (ridingGearBmp != null)
                ridingGearBmp.Dispose();

            g.Dispose();
            return tooltip;
        }

        private Bitmap RenderSkill(CanvasRegion region, out int picH)
        {
            //Bitmap bitmap = new Bitmap(500, DefaultPicHeight);
            Bitmap bitmap = new Bitmap(region.Width, DefaultPicHeight);
            Graphics g = Graphics.FromImage(bitmap);
            StringFormat format = (StringFormat)StringFormat.GenericDefault.Clone();
            picH = 0;

            //获取文字 (acquiring text)
            StringResult sr;
            if (StringLinker == null || !StringLinker.StringSkill.TryGetValue(Skill.SkillID, out sr))
            {
                sr = new StringResultSkill();
                sr.Name = "(null)";
            }

            //绘制技能名称 (drawing skill name)
            g.DrawImage(Resource.ToolTip_Equip_Dot_0, 9, picH + 15);//GMS Version blue dot in SKILLS
            format.Alignment = StringAlignment.Near;
            TextRenderer.DrawText(g, sr.Name, GearGraphics.ItemNameFont2, new Point(13, 10), Color.White, TextFormatFlags.Left | TextFormatFlags.NoPrefix);

            //绘制图标 (drawing skill icon)
            if (Skill.Icon.Bitmap != null)
            {
                picH = 40;//original value: 33
                g.FillRectangle(GearGraphics.GearIconBackBrush2, 10, picH, 68, 68);//original value after GearIconBackBrush2: 14
                g.DrawImage(GearGraphics.EnlargeBitmap(Skill.Icon.Bitmap),
                10 + (1 - Skill.Icon.Origin.X) * 2,//original first value: 14
                picH + (33 - Skill.Icon.Bitmap.Height) * 2);
            }

            //绘制desc (drawing skill description)
            picH = 40;//original value: 35
            if (Skill.HyperStat)
                //GearGraphics.DrawString(g, "[Master Level : " + Skill.MaxLevel + "]", GearGraphics.ItemDetailFont2, 10, 485, ref picH, 16);
                GearGraphics.DrawString(g, "[Master Level : " + Skill.MaxLevel + "]", GearGraphics.ItemDetailFont2, region.LevelDescLeft, region.TextRight, ref picH, 16);
            else if (!Skill.PreBBSkill)
                //GearGraphics.DrawString(g, "[Master Level : " + Skill.MaxLevel + "]", GearGraphics.ItemDetailFont2, 86, 485, ref picH, 16);//original values: 90, 272
                GearGraphics.DrawString(g, "[Master Level : " + Skill.MaxLevel + "]", GearGraphics.ItemDetailFont2, region.SkillDescLeft, region.TextRight, ref picH, 16);

            if (sr.Desc != null)
            {
                string hdesc = SummaryParser.GetSkillSummary(sr.Desc, Skill.Level, Skill.Common, SummaryParams.Default);
                //string hStr = SummaryParser.GetSkillSummary(skill, skill.Level, sr, SummaryParams.Default);
                //GearGraphics.DrawString(g, hdesc, GearGraphics.ItemDetailFont2, 86, 485, ref picH, 16);//original values: 90, 272
                GearGraphics.DrawString(g, hdesc, GearGraphics.ItemDetailFont2, Skill.Icon.Bitmap == null ? region.LevelDescLeft : region.SkillDescLeft, region.TextRight, ref picH, 16);
            }
            if (Skill.TimeLimited)
            {
                DateTime time = DateTime.Now.AddDays(7d);
                string expireStr = "Expiration Date: " + time.ToString("M\\/d\\/yyyy HH:mm");
                //GearGraphics.DrawString(g, "#c" + expireStr + "#", GearGraphics.ItemDetailFont2, 86, 485, ref picH, 26);//original values, 92, 274, 16. '400' is GMS sync
                GearGraphics.DrawString(g, "#c" + expireStr + "#", GearGraphics.ItemDetailFont2, Skill.Icon.Bitmap == null ? region.LevelDescLeft : region.SkillDescLeft, region.TextRight, ref picH, 16);
            }
            if (Skill.RelationSkill != null)
            {
                StringResult sr2 = null;
                if (StringLinker == null || !StringLinker.StringSkill.TryGetValue(Skill.RelationSkill.Item1, out sr2))
                {
                    sr2 = new StringResultSkill();
                    sr2.Name = "(null)";
                }
                DateTime time = DateTime.Now.AddMinutes(Skill.RelationSkill.Item2);
                string expireStr = " Expiration Date: " + time.ToString(@"M\/d\/yyyy HH\:mm") + " UTC"; ;//Change when Permanent Thunder Horse is given to players.
                //GearGraphics.DrawString(g, "#c" + sr2.Name + expireStr + "#", GearGraphics.ItemDetailFont2, Skill.Icon.Bitmap == null ? 10 : 86, 485, ref picH, 16);
                GearGraphics.DrawString(g, "#c" + sr2.Name + expireStr + "#", GearGraphics.ItemDetailFont2, Skill.Icon.Bitmap == null ? region.LevelDescLeft : region.SkillDescLeft, region.TextRight, ref picH, 16);
            }
            if (Skill.IsPetAutoBuff)
            {
                GearGraphics.DrawString(g, "#cCan add Auto Buff Skill#", GearGraphics.ItemDetailFont2, Skill.Icon.Bitmap == null ? 10 : 92, 414, ref picH, 16);
            }
            if (Skill.SkillID / 10000 / 1000 == 10 && Skill.ReqLevel > 0)
            {
                GearGraphics.DrawString(g, "#c[Level Required: " + Skill.ReqLevel.ToString() + " or above]#", GearGraphics.ItemDetailFont2, 86, 272, ref picH, 40);
            }
            if (Skill.ReqAmount > 0)
            {
                GearGraphics.DrawString(g, "#c" + ItemStringHelper.GetSkillReqAmount(Skill.SkillID, Skill.ReqAmount) + "#", GearGraphics.ItemDetailFont2, 92, 300, ref picH, 16);
            }

            //分割线 (dividing the line(s))
            picH = Math.Max(picH, 128);//original value: 114 - changes the space between skill desc and white line
            //g.DrawLine(Pens.White, 6, picH, 493, picH);//original values: 6, 283
            g.DrawLine(Pens.White, region.SplitterX1, picH, region.SplitterX2, picH);
            picH += 6;//original value: 9

            if (Skill.Level > 0)
            {
                string hStr = SummaryParser.GetSkillSummary(Skill, Skill.Level, sr, SummaryParams.Default, new SkillSummaryOptions
                {
                    ConvertCooltimeMS = this.DisplayCooltimeMSAsSec,
                    ConvertPerM = this.DisplayPermyriadAsPercent
                });
                //GearGraphics.DrawString(g, "[Current Level " + Skill.Level + "]", GearGraphics.ItemDetailFont, 9, 485, ref picH, 16);//original values: 10, 274
                GearGraphics.DrawString(g, "[Current Level " + Skill.Level + "]", GearGraphics.ItemDetailFont, region.LevelDescLeft, region.TextRight, ref picH, 16);
                if (Skill.SkillID / 10000 / 1000 == 10 && Skill.Level == 1 && Skill.ReqLevel > 0)
                {
                    //GearGraphics.DrawPlainText(g, "(Level Required: " + Skill.ReqLevel.ToString() + " or above)", GearGraphics.ItemDetailFont2, GearGraphics.skillYellowColor, 10, 485, ref picH, 16); *Related to Zero skills
                    //GearGraphics.DrawPlainText(g, "[필요 레벨: " + Skill.ReqLevel.ToString() + "레벨 이상]", GearGraphics.ItemDetailFont2, GearGraphics.skillYellowColor, region.LevelDescLeft, region.TextRight, ref picH, 16);
                }
                if (hStr != null)
                {
                    //GearGraphics.DrawString(g, hStr, GearGraphics.ItemDetailFont2, 10, 485, ref picH, 16);//original values: 10, 274
                    GearGraphics.DrawString(g, hStr, GearGraphics.ItemDetailFont2, region.LevelDescLeft, region.TextRight, ref picH, 16);
                }
            }

            if (Skill.Level < Skill.MaxLevel && !Skill.DisableNextLevelInfo)
            {
                string hStr = SummaryParser.GetSkillSummary(Skill, Skill.Level + 1, sr, SummaryParams.Default, new SkillSummaryOptions
                {
                    ConvertCooltimeMS = this.DisplayCooltimeMSAsSec,
                    ConvertPerM = this.DisplayPermyriadAsPercent
                });
                //GearGraphics.DrawString(g, "[Next Level " + (Skill.Level + 1) + "]", GearGraphics.ItemDetailFont, 9, 485, ref picH, 16);//original values: 10, 274
                GearGraphics.DrawString(g, "[Next Level " + (Skill.Level + 1) + "]", GearGraphics.ItemDetailFont, region.LevelDescLeft, region.TextRight, ref picH, 16);
                if (Skill.SkillID / 10000 / 1000 == 10 && (Skill.Level + 1) == 1 && Skill.ReqLevel > 0)
                {
                    //GearGraphics.DrawPlainText(g, "(Level Required: " + Skill.ReqLevel.ToString() + " or above]", GearGraphics.ItemDetailFont2, GearGraphics.skillYellowColor, 10, 485, ref picH, 16);
                    GearGraphics.DrawPlainText(g, "[Level Required: " + Skill.ReqLevel.ToString() + " or above]", GearGraphics.ItemDetailFont2, GearGraphics.skillYellowColor, region.LevelDescLeft, region.TextRight, ref picH, 16);
                }
                if (hStr != null)
                {
                    //GearGraphics.DrawString(g, hStr, GearGraphics.ItemDetailFont2, 8, 485, ref picH, 16);//original values: 10, 274
                    GearGraphics.DrawString(g, hStr, GearGraphics.ItemDetailFont2, region.LevelDescLeft, region.TextRight, ref picH, 16);
                }
            }
            picH += 3;//original value: 9

            if (Skill.AddAttackToolTipDescSkill != 0)
            {
                //g.DrawLine(Pens.White, 6, picH, 493, picH);//original values: 6, 283
                g.DrawLine(Pens.White, region.SplitterX1, picH, region.SplitterX2, picH);
                picH += 9;
                //GearGraphics.DrawPlainText(g, "[Combo Skill]", GearGraphics.ItemDetailFont, Color.FromArgb(119, 204, 255), 10, 485, ref picH, 16);
                GearGraphics.DrawPlainText(g, "[Combo Skill]", GearGraphics.ItemDetailFont, Color.FromArgb(119, 204, 255), region.LevelDescLeft, region.TextRight, ref picH, 16);
                SolidBrush drawBrush = new SolidBrush(Color.Black);
                BitmapOrigin icon = new BitmapOrigin();
                Wz_Node skillNode = PluginBase.PluginManager.FindWz(string.Format(@"Skill\{0}.img\skill\{1}", Skill.AddAttackToolTipDescSkill / 10000, Skill.AddAttackToolTipDescSkill));
                if (skillNode != null)
                {
                    Skill skill = Skill.CreateFromNode(skillNode, PluginBase.PluginManager.FindWz);
                    icon = skill.Icon;
                }
                if (icon.Bitmap != null)
                {
                    g.DrawImage(icon.Bitmap, 10 - icon.Origin.X, picH + 32 - icon.Origin.Y);
                }
                string skillName;
                if (this.StringLinker != null && this.StringLinker.StringSkill.TryGetValue(Skill.AddAttackToolTipDescSkill, out sr))
                {
                    skillName = sr.Name;
                }
                else
                {
                    skillName = Skill.AddAttackToolTipDescSkill.ToString();
                }
                picH += 10;
                //GearGraphics.DrawString(g, skillName, GearGraphics.ItemDetailFont, 46, 485, ref picH, 16);
                GearGraphics.DrawString(g, skillName, GearGraphics.ItemDetailFont, region.LinkedSkillNameLeft, region.TextRight, ref picH, 16);
                picH += 6;
                picH += 8;
            }

            if (Skill.AssistSkillLink != 0)
            {
                //g.DrawLine(Pens.White, 6, picH, 493, picH);//original values: 6, 283
                g.DrawLine(Pens.White, region.SplitterX1, picH, region.SplitterX2, picH);
                picH += 9;
                //GearGraphics.DrawPlainText(g, "[Assist Skill]", GearGraphics.ItemDetailFont, ((SolidBrush)GearGraphics.OrangeBrush).Color, 10, 485, ref picH, 16);
                GearGraphics.DrawPlainText(g, "[Assist Skill]", GearGraphics.ItemDetailFont, ((SolidBrush)GearGraphics.OrangeBrush).Color, region.LevelDescLeft, region.TextRight, ref picH, 16);
                BitmapOrigin icon = new BitmapOrigin();
                Wz_Node skillNode = PluginBase.PluginManager.FindWz(string.Format(@"Skill\{0}.img\skill\{1}", Skill.AssistSkillLink / 10000, Skill.AssistSkillLink));
                if (skillNode != null)
                {
                    Skill skill = Skill.CreateFromNode(skillNode, PluginBase.PluginManager.FindWz);
                    icon = skill.Icon;
                }
                if (icon.Bitmap != null)
                {
                    g.DrawImage(icon.Bitmap, 10 - icon.Origin.X, picH + 32 - icon.Origin.Y);
                }
                string skillName;
                if (this.StringLinker != null && this.StringLinker.StringSkill.TryGetValue(Skill.AssistSkillLink, out sr))
                {
                    skillName = sr.Name;
                }
                else
                {
                    skillName = Skill.AssistSkillLink.ToString();
                }
                picH += 10;
                //GearGraphics.DrawString(g, skillName, GearGraphics.ItemDetailFont, 46, 485, ref picH, 16);
                GearGraphics.DrawString(g, skillName, GearGraphics.ItemDetailFont, region.LinkedSkillNameLeft, region.TextRight, ref picH, 16);
                picH += 6;
                picH += 8;
            }

            List<string> skillDescEx = new List<string>();
            if (ShowProperties)
            {
                List<string> attr = new List<string>();
                if (Skill.ReqLevel > 0)
                {
                    attr.Add("[Lv. " + Skill.ReqLevel + " required]");
                }
                if (Skill.Invisible)
                {
                    attr.Add("[Hidden Skill]");
                }
                if (Skill.Hyper != HyperSkillType.None)
                {
                    attr.Add("[Hyper Skill: " + Skill.Hyper + "]");
                }
                if (Skill.CombatOrders)
                {
                    attr.Add("[Compatible with Combat Orders]");
                }
                if (Skill.NotRemoved)
                {
                    attr.Add("[Undispellable]");
                }
                //if (Skill.MasterLevel > 0 && Skill.MasterLevel < Skill.MaxLevel)
                //{
                //    attr.Add("[Mastery Book required to upgrade beyond Lv. " + Skill.MasterLevel + "]");
                //}
                if (Skill.NotIncBuffDuration)
                {
                    attr.Add("[Unaffected by buff duration increases]");
                }
                if (Skill.NotCooltimeReset)
                {
                    attr.Add("[Unaffected by cooldown reset effects]");
                }

                if (attr.Count > 0)
                {
                    //skillDescEx.Add("#c" + string.Join(", ", attr.ToArray()) + "#"); //comma after new attribute
                    skillDescEx.Add("#c" + string.Join("\n", attr.ToArray()) + "#");
                }
            }

            if (ShowDelay && Skill.Action.Count > 0)
            {
                foreach (string action in Skill.Action)
                {
                    skillDescEx.Add("#c[Delay] " + action + ": " + CharaSimLoader.GetActionDelay(action) + " ms#");
                }
            }

            if (ShowReqSkill && Skill.ReqSkill.Count > 0)
            {
                foreach (var kv in Skill.ReqSkill)
                {
                    string skillName;
                    if (this.StringLinker != null && this.StringLinker.StringSkill.TryGetValue(kv.Key, out sr))
                    {
                        skillName = sr.Name;
                    }
                    else
                    {
                        skillName = kv.Key.ToString();
                    }
                    skillDescEx.Add("#c[Lv. " + kv.Value + " " + skillName + " required]#");
                }
            }

            if (Skill.LT.X != 0)
            {
                skillDescEx.Add("#c[Coordinate] LT: (" + Skill.LT.X + "," + Skill.LT.Y + ")" + " / " +
                                            "RB: (" + Skill.RB.X + "," + Skill.RB.Y + ")");
                int LT = Math.Abs(Skill.LT.X) + Skill.RB.X;
                int RB = Math.Abs(Skill.LT.Y) + Skill.RB.Y;
                skillDescEx.Add("#c[Range] " + LT + " X " + RB);
            }


            if (skillDescEx.Count > 0)
            {
                //g.DrawLine(Pens.White, 6, picH, 493, picH);//original values: 6, 283
                g.DrawLine(Pens.White, region.SplitterX1, picH, region.SplitterX2, picH);
                picH += 9;
                foreach (var descEx in skillDescEx)
                {
                    //GearGraphics.DrawString(g, descEx, GearGraphics.ItemDetailFont, 10, 485, ref picH, 16);//original values 8, 266
                    GearGraphics.DrawString(g, descEx, GearGraphics.ItemDetailFont, region.LevelDescLeft, region.TextRight, ref picH, 16);
                }
                picH += 3;//original value: 9
            }



            picH += 6;

            format.Dispose();
            g.Dispose();
            return bitmap;
        }

        private Bitmap RenderLinkRidingGear(Gear gear)
        {
            TooltipRender renderer = this.LinkRidingGearRender;
            if (renderer == null)
            {
                GearTooltipRender2 defaultRenderer = new GearTooltipRender2();
                defaultRenderer.StringLinker = this.StringLinker;
                defaultRenderer.ShowObjectID = false;
                renderer = defaultRenderer;
            }

            renderer.TargetItem = gear;
            return renderer.Render();
        }

        private class CanvasRegion
        {
            public int Width { get; private set; }
            public int TitleCenterX { get; private set; }
            public int SplitterX1 { get; private set; }
            public int SplitterX2 { get; private set; }
            public int SkillDescLeft { get; private set; }
            public int LinkedSkillNameLeft { get; private set; }
            public int LevelDescLeft { get; private set; }
            public int TextRight { get; private set; }

            public static CanvasRegion Original { get; } = new CanvasRegion()
            {
                Width = 290,
                TitleCenterX = 144,
                SplitterX1 = 6,
                SplitterX2 = 283,
                SkillDescLeft = 90,
                LinkedSkillNameLeft = 46,
                LevelDescLeft = 8,
                TextRight = 272,
            };

            public static CanvasRegion Wide { get; } = new CanvasRegion()
            {
                Width = 430,
                TitleCenterX = 215,
                SplitterX1 = 6,
                SplitterX2 = 423,
                SkillDescLeft = 92,
                LinkedSkillNameLeft = 46,
                LevelDescLeft = 10,
                TextRight = 411,
            };
        }
    }
}
```

`MapleNecrocer/CharaSimControl/TextBlock.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;

namespace WzComparerR2.CharaSimControl
{
    public class TextBlock
    {
        public string Text { get; set; }
        public Brush Brush { get; set; }
        public Font Font { get; set; }
        public Point Position { get; set; }
        public Size Size { get; set; }
        public Rectangle Rectangle
        {
            get
            {
                return new Rectangle(Position, Size);
            }
        }
    }
}

```

`MapleNecrocer/CharaSimControl/TooltipRender.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;
using WzComparerR2.Common;

namespace WzComparerR2.CharaSimControl
{
    public abstract class TooltipRender
    {
        static TooltipRender()
        {
            Rectangle screenRect = System.Windows.Forms.Screen.PrimaryScreen.Bounds;
            DefaultPicHeight = screenRect.Height * 2;
        }

        public TooltipRender()
        {
        }

        public static readonly int DefaultPicHeight;

        public StringLinker StringLinker { get; set; }

        public bool ShowObjectID { get; set; }

        public abstract Bitmap Render();

        public virtual object TargetItem { get; set; }
    }
}

```

`MapleNecrocer/ChatRingForm.Designer.cs`:

```cs
namespace MapleNecrocer
{
    partial class ChatRingForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            panel1 = new Panel();
            richTextBox1 = new RichTextBox();
            label1 = new Label();
            textBox1 = new TextBox();
            button1 = new Button();
            SuspendLayout();
            // 
            // panel1
            // 
            panel1.Anchor = AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right;
            panel1.Location = new Point(14, 147);
            panel1.Margin = new Padding(5);
            panel1.Name = "panel1";
            panel1.Size = new Size(364, 614);
            panel1.TabIndex = 8;
            // 
            // richTextBox1
            // 
            richTextBox1.Font = new Font("Tahoma", 10F, FontStyle.Regular, GraphicsUnit.Point);
            richTextBox1.Location = new Point(14, 18);
            richTextBox1.Name = "richTextBox1";
            richTextBox1.Size = new Size(364, 86);
            richTextBox1.TabIndex = 9;
            richTextBox1.Text = "MapleStory";
            // 
            // label1
            // 
            label1.AutoSize = true;
            label1.Location = new Point(19, 119);
            label1.Name = "label1";
            label1.Size = new Size(52, 18);
            label1.TabIndex = 10;
            label1.Text = "Search";
            // 
            // textBox1
            // 
            textBox1.Location = new Point(77, 116);
            textBox1.Name = "textBox1";
            textBox1.Size = new Size(143, 24);
            textBox1.TabIndex = 11;
            textBox1.TextChanged += textBox1_TextChanged;
            // 
            // button1
            // 
            button1.Location = new Point(276, 115);
            button1.Name = "button1";
            button1.Size = new Size(92, 24);
            button1.TabIndex = 12;
            button1.Text = "Remove";
            button1.UseVisualStyleBackColor = true;
            button1.Click += button1_Click;
            // 
            // ChatRingForm
            // 
            AutoScaleMode = AutoScaleMode.None;
            ClientSize = new Size(392, 775);
            Controls.Add(button1);
            Controls.Add(textBox1);
            Controls.Add(label1);
            Controls.Add(richTextBox1);
            Controls.Add(panel1);
            Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            KeyPreview = true;
            Name = "ChatRingForm";
            Text = "ChatRingForm";
            TopMost = true;
            FormClosing += ChatRingForm_FormClosing;
            Shown += ChatRingForm_Shown;
            ResumeLayout(false);
            PerformLayout();
        }

        #endregion

        private Panel panel1;
        private RichTextBox richTextBox1;
        private Label label1;
        private TextBox textBox1;
        private Button button1;
    }
}
```

`MapleNecrocer/ChatRingForm.cs`:

```cs
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace MapleNecrocer;

public partial class ChatRingForm : Form
{
    public ChatRingForm()
    {
        InitializeComponent();
        Instance = this;
    }
    public static ChatRingForm Instance;
    public DataGridViewEx ChatRingListGrid;

    void CellClick(BaseDataGridView DataGrid, DataGridViewCellEventArgs e)
    {
        var ID = DataGrid.Rows[e.RowIndex].Cells[0].Value.ToString();
        if (ID == "01112243")
            return;
        ChatRingBalloon.Remove();
        var chatRingBalloon = new ChatRingBalloon(EngineFunc.SpriteEngine);
        //  chatRingBalloon.Msg = richTextBox1.Text;
        if (Wz.Region == "GMS")
        {
            chatRingBalloon.Msg = richTextBox1.Text;
            //Npc.Msgs.Add(Str1);
        }
        else
        {
            string Str1 = chatRingBalloon.Msg = richTextBox1.Text;
            Str1 = Str1.Replace(" ", "");
            chatRingBalloon.Msg = Npc.ReString(Str1);
        }

        int TagNum = Wz.GetInt("Character/Ring/" + ID + ".img" + "/info/chatBalloon");
        chatRingBalloon.SetStyle(TagNum);
        chatRingBalloon.ReDraw();

    }
    private void ChatRingForm_Shown(object sender, EventArgs e)
    {
        this.FormClosing += (s, e1) =>
        {
            this.Hide();
            e1.Cancel = true;
        };

        ChatRingListGrid = new(90, 179, 0, 0, 220, 400, true, panel1);
        ChatRingListGrid.Dock = DockStyle.Fill;
        ChatRingListGrid.SearchGrid.Dock = DockStyle.Fill;
        ChatRingListGrid.RowTemplate.Height = 40;

        var Graphic = ChatRingListGrid.CreateGraphics();
        var Font = new System.Drawing.Font(FontFamily.GenericSansSerif, 20, FontStyle.Bold);
        Graphic.DrawString("Loading...", Font, Brushes.Black, 10, 50);
        ChatRingListGrid.CellClick += (s, e) =>
        {
            CellClick(ChatRingListGrid, e);
        };

        ChatRingListGrid.SearchGrid.CellClick += (s, e) =>
        {
            CellClick(ChatRingListGrid.SearchGrid, e);
        };
        ChatRingListGrid.SetToolTipEvent(WzType.Character, this);

        foreach (var Img in Wz.GetNodes("Character/Ring"))
        {
            if (Img.Text.LeftStr(6) != "011122" && Img.Text.LeftStr(6) != "011150"  &&
                Img.Text.LeftStr(6) != "011152" && Img.Text.LeftStr(6) != "011154")
                continue;

            if (!Wz.HasNode("Character/Ring/" + Img.Text + "/info/chatBalloon"))
                continue;
            int TagNum = Wz.GetInt("Character/Ring/" + Img.Text + "/info/chatBalloon");

            if (!Wz.HasNode("UI/ChatBalloon.img/" + TagNum))
                continue;

            string ID = Img.ImgID();
            string ChatRingName = "";

            if (Wz.HasNode("String/Eqp.img/Eqp/Ring/" + ID.ToInt()))
                ChatRingName = Wz.GetStr("String/Eqp.img/Eqp/Ring/" + ID.ToInt() + "/name");

            Bitmap Icon = null;
            if (Wz.HasNode("Character/Ring/" + ID + ".img/info/icon"))
                Icon = Wz.GetBmp("Character/Ring/" + ID + ".img/info/icon");
            ChatRingListGrid.Rows.Add(ID, Icon, ChatRingName);

        }


    }

    private void button1_Click(object sender, EventArgs e)
    {
        ChatRingBalloon.Remove();
    }

    private void ChatRingForm_FormClosing(object sender, FormClosingEventArgs e)
    {
        MainForm.Instance.ToolTipView.Visible = false;
    }

    private void textBox1_TextChanged(object sender, EventArgs e)
    {
        ChatRingListGrid.Search(textBox1.Text);
    }
}

```

`MapleNecrocer/ChatRingForm.resx`:

```resx
<root>
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`MapleNecrocer/Client/AfterImage.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Xml.Linq;
using Microsoft.Xna.Framework;
using MonoGame.SpriteEngine;
using WzComparerR2.WzLib;
namespace MapleNecrocer;

public class AfterImage : SpriteEx
{
    public AfterImage(Sprite Parent) : base(Parent)
    {
        CollideMode = CollideMode.Rect;
        CanCollision = true;
    }

    int FTime;
    int Frame;
    string ImagePath;
    string Path;
    Wz_Vector LT, RB;
    int Left, Top, Right, Bottom;
    public static int ColorInt;
    public static void Load(string AfterImageStr, string ColorType)
    {
        var Entry = Wz.GetNodeA("Character/Afterimage/" + AfterImageStr + ".img/" + ColorType);
        if (!Wz.EquipData.ContainsKey(Entry.FullPathToFile2()))
            Wz.DumpData(Entry, Wz.EquipData, Wz.EquipImageLib);
    }
    public static void Create(string PathName)
    {
        var AfterImage = new AfterImage(EngineFunc.SpriteEngine);
        AfterImage.ImageLib = Wz.EquipImageLib;
        AfterImage.ImageNode = Wz.EquipData[PathName];
        AfterImage.Visible = true;
        AfterImage.Path = PathName.LeftStr(PathName.Length - 1);
    }

    public override void DoMove(float Delta)
    {
        base.DoMove(Delta);
        Visible = true;
        X = Game.Player.X - 10;
        Y = Game.Player.Y;
        Z = 150 + Game.Player.Z;
        ImagePath = Path + Frame;
        ImageNode = Wz.EquipData[ImagePath];
        int Delay = ImageNode.GetInt("delay", 100);
        int a1 = ImageNode.GetInt("a1", -1);
        FlipX = Game.Player.FlipX;
        string c = "Character/Afterimage/";
        if (Wz.EquipData.ContainsKey(c + Game.Player.AfterImageStr + ".img/0/" + Game.Player.Action + "/lt"))
        {
            LT = Wz.EquipData[c + Game.Player.AfterImageStr + ".img/0/" + Game.Player.Action + "/lt"].ToVector();
            RB = Wz.EquipData[c + Game.Player.AfterImageStr + ".img/0/" + Game.Player.Action + "/rb"].ToVector();
            switch (Game.Player.FlipX)
            {
                case true:
                    Right = (int)X - LT.X + 18;
                    Left = (int)X - RB.X;
                    break;
                case false:
                    Left = (int)X + LT.X;
                    Right = (int)X + RB.X;
                    break;
            }
            Top = (int)Y + LT.Y;
            Bottom = (int)Y + RB.Y;
        }
        CollideRect = CollideRect = SpriteUtils.Rect(Left, Top, Right, Bottom);
        Collision();

        FTime += 17;
        if (FTime > Delay)
        {
            Frame += 1;
            if (!Wz.EquipData.ContainsKey(Path + Frame))
                Dead();
            FTime = 0;
        }

        if (a1 != -1)
        {
            float AniAlpha = 255 - (255 - a1) * FTime / Delay;
            if ((AniAlpha < 255) && (AniAlpha > 0))
                Alpha = (byte)AniAlpha;
            if (Alpha <= 20)
                Dead();
        }
        switch (FlipX)
        {
            case true:
                Offset.X = ImageNode.GetVector("origin").X - ImageWidth + 18;
                break;
            case false:
                Offset.X = -ImageNode.GetVector("origin").X;
                break;
        }
        Offset.Y = -ImageNode.GetVector("origin").Y;
    }

    public override void OnCollision(Sprite sprite)
    {
        if ((FTime == 0) && (Frame == 0))
        {
            if (sprite is Mob)
            {
                var Mob = (Mob)sprite;
                if (Mob.HP > 0)
                {
                    Mob.Hit = true;
                    Random Random = new Random();
                    Game.Damage = 50000 + Random.Next(700000);
                    Mob.HP -= Game.Damage;

                    if (Wz.GetNode("Sound/Mob.img/" + Mob.ID + "/Damage") != null)
                        Sound.Play("Sound/Mob.img/" + Mob.ID + "/Damage");
                    else if (Wz.GetNode("Sound/Mob.img/" + Mob.ID + "/Hit1") != null)
                        Sound.Play("Sound/Mob.img/" + Mob.ID + "/Hit1");
                   
                    if (Wz.Data.ContainsKey("Mob/" + Mob.ID + ".img/hit1"))
                    {
                        Mob.GetHit1 = true;
                    }
                }
                if ((Mob.HP <= 0) && (!Mob.Die))
                {
                    Sound.Play("Sound/Mob.img/" + Mob.ID + "/Die");
                    Mob.Die = true;
                    Mob.CanCollision = false;
                    // Dead;
                }
                CanCollision = false;
            }

        }
    }
}
```

`MapleNecrocer/Client/Android.cs`:

```cs
using Spine;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using static System.Windows.Forms.AxHost;
using Vector2 = Microsoft.Xna.Framework.Vector2;

namespace MapleNecrocer;

public class AndroidPlayer : PlayerEx
{
    public AndroidPlayer(Sprite Parent) : base(Parent)
    {

    }
    Foothold WallFH;
    Foothold BelowFH;

    int FallEdge;
    int JumpEdge;
    int FollowDistance;
    Vector2 Distance;
    public static AndroidPlayer Instance;
    static List<string> List = new List<string>();
    public static void SpawnNew()
    {
        Player._NewZ += 1;
        Instance = new AndroidPlayer(EngineFunc.SpriteEngine);
        Instance.ImageLib = Wz.EquipImageLib;
        Instance.NewZ = Player._NewZ;
        Instance.OtherPlayer = true;
        Instance.X = Game.Player.X;
        Instance.Y = Game.Player.Y - 80;
        Foothold BelowFH = null;
        Vector2 Below = FootholdTree.Instance.FindBelow(new Vector2(Game.Player.X, Game.Player.Y - 2), ref BelowFH);
        Instance.FH = BelowFH;
        Instance.JumpSpeed = 0.6f;
        Instance.JumpHeight = 9.5f;
        Instance.MaxFallSpeed = 8;
        Instance.JumpState = JumpState.jsFalling;
        Instance.moveType = MoveType.Jump;
        Instance.FollowDistance = 100;
        Instance.MoveSpeed = 2.1f;
    }

    public void Spawn(string IDList)
    {
        RemoveSprites();
        ShowHair = false;
        DressCap = false;
        var Split = IDList.Split('-');
        List.Clear();
        for (int i = 0; i < Split.Length - 1; i++)
            List.Add(Split[i]);
        List.Sort();
        for (int i = 0; i < List.Count; i++)
            CreateEquip(List[i], EngineFunc.SpriteEngine);
    }

    public override void DoMove(float Delta)
    {
        //base.DoMove(Delta);
        UpdateJump();
        int X1 = FH.X1;
        int Y1 = FH.Y1;
        int X2 = FH.X2;
        int Y2 = FH.Y2;
        Distance.X = Math.Abs(Game.Player.X - X);
        Distance.Y = Math.Abs(Game.Player.Y - Y);

        if (Distance.X > FollowDistance)
        {
            Action = WalkType;
            if (Game.Player.X > X)
            {
                FlipX = true;
                moveDirection = MoveDirection.Right;
            }
            if (Game.Player.X < X)
            {
                FlipX = false;
                moveDirection = MoveDirection.Left;
            }
        }
        else
        {
            Action = StandType;
            moveDirection = MoveDirection.None;
        }

        if (Game.Player.Y < Y && !Game.Player.InLadder)
        {
            switch (Distance.Y)
            {
                case float i when i >= 100 && i <= 150:
                    if (JumpState == JumpState.jsNone && Game.Player.JumpState == JumpState.jsNone)
                    {
                        Vector2 Below = FootholdTree.Instance.FindBelow(new Vector2(X, Y - 80), ref BelowFH);
                        if (Y - Below.Y != 0)
                            DoJump = true;
                    }
                    break;
                case float i when i >= 151 && i <= 2000:
                    if (Game.Player.JumpState == JumpState.jsNone)
                    {
                        X = Game.Player.X;
                        Y = Game.Player.Y;
                        DoJump = true;
                    }
                    break;
            }
        }


        if (Game.Player.Y > Y)
        {
            if (Distance.Y >= 200 && Distance.Y <= 2000)
            {

                Y += 5;
                JumpState = JumpState.jsFalling;
            }
        }

        if (JumpState == JumpState.jsFalling)
        {
            Vector2 Below = FootholdTree.Instance.FindBelow(new Vector2(X, Y - VelocityY - 2), ref BelowFH);
            if (Y >= Below.Y - 3)
            {
                Y = Below.Y;
                // MaxFallSpeed :=10;
                JumpState = JumpState.jsNone;
                FH = BelowFH;
                Z = FH.Z * 100000 + 50000;
            }
        }

        int FallEdge;
        int Direction;
        if (moveDirection == MoveDirection.Left)
        {
            Direction = GetAngle256(X2, Y2, X1, Y1);
            if (!FH.IsWall())
            {
                X += (float)(Sin256(Direction) * MoveSpeed);
                Y -= (float)(Cos256(Direction) * MoveSpeed);
            }
            FallEdge = -999999;
            JumpEdge = -999999;
            if (moveType == MoveType.Move)
            {
                // no fh
                if (FH.Prev == null)
                    FallEdge = FH.X1;
                // Wall's edge down
                if ((FH.Prev != null) && (FH.Prev.IsWall()))
                    FallEdge = FH.X1;

                if (X < FallEdge)
                {
                    X = FallEdge;
                    FlipX = true;
                    moveDirection = MoveDirection.Right;
                }
            }

            if (moveType == MoveType.Jump)
            {
                // .--------.
                if (FH.Prev == null)
                    JumpEdge = FH.X1;
                // ┌--- <--
                if ((FH.Prev != null) && (FH.Prev.IsWall()) && (FH.Prev.Y1 > Y))
                    FallEdge = FH.X1;

                if (X < FallEdge)
                {
                    if (Game.Player.Y <= Y)
                        DoJump = true;
                    if (Game.Player.Y > Y && JumpState == JumpState.jsNone)
                        JumpState = JumpState.jsFalling;
                }
                if (X < JumpEdge)
                    DoJump = true;
                // -->  ---┐  <--
                WallFH = FootholdTree.Instance.FindWallR(new Vector2(X + 4, Y - 4));
                if ((WallFH != null) && (FH.Z == WallFH.Z))
                {
                    if (X < WallFH.X1 + 30 && Game.Player.Y <= Y)
                        DoJump = true;
                    if (X <= WallFH.X1)
                    {
                        X = WallFH.X1 + MoveSpeed;
                        if (JumpState == JumpState.jsNone)
                        {
                            FlipX = true;
                            moveDirection = MoveDirection.Right;
                        }
                    }
                }
            }
            // walk left
            if ((X <= FH.X1) && (FH.PrevID != 0) && (!FH.IsWall()) && (!FH.Prev.IsWall()))
            {
                if (JumpState == JumpState.jsNone)
                {
                    FH = FH.Prev;
                    X = FH.X2;
                    Y = FH.Y2;
                    Z = FH.Z * 100000 + 50000;
                }
            }
        }

        // walk right
        if (moveDirection == MoveDirection.Right)
        {
            Direction = GetAngle256(X1, Y1, X2, Y2);
            if (!FH.IsWall())
            {
                X += (float)(Sin256(Direction) * MoveSpeed);
                Y -= (float)(Cos256(Direction) * MoveSpeed);
            }
            FallEdge = 999999;
            JumpEdge = 999999;
            if (moveType == MoveType.Move)
            {
                if (FH.Next == null)
                    FallEdge = FH.X2 + 5;
                // Wall down
                if ((FH.Next != null) && (FH.Next.IsWall()))

                    FallEdge = FH.X2;
                if (X > FallEdge)
                {
                    X = FallEdge;
                    FlipX = false;
                    moveDirection = MoveDirection.Left;
                }
            }

            if (moveType == MoveType.Jump)
            {
                if (FH.Next == null) // .--------.
                    JumpEdge = FH.X2;
                // -->  ----┐
                if ((FH.Next != null) && (FH.Next.IsWall()) && (FH.Next.Y2 > Y))
                    FallEdge = FH.X2;

                if (X > FallEdge)
                {
                    if (Game.Player.Y <= Y)
                        DoJump = true;
                    if (Game.Player.Y > Y && JumpState == JumpState.jsNone)
                        JumpState = JumpState.jsFalling;
                }
                if (X > JumpEdge)
                    DoJump = true;
                // -->  ┌.....
                WallFH = FootholdTree.Instance.FindWallL(new Vector2(X - 4, Y - 4));
                if ((WallFH != null) && (FH.Z == WallFH.Z))
                {
                    if (X > WallFH.X1 - 30 && Game.Player.Y <= Y)
                        DoJump = true;
                    if (X >= WallFH.X1)
                    {
                        X = WallFH.X2 - MoveSpeed;
                        if (JumpState == JumpState.jsNone)
                        {
                            FlipX = false;
                            moveDirection = MoveDirection.Left;
                        }
                    }
                }
            }
            // walk right
            if ((X >= FH.X2) && (FH.NextID != 0) && (!FH.IsWall()) && (!FH.Next.IsWall()))
            {
                if (JumpState == JumpState.jsNone)
                {
                    FH = FH.Next;
                    X = FH.X1;
                    Y = FH.Y1;
                    Z = FH.Z * 100000 + 50000;
                }
            }
        }
        if (JumpState != JumpState.jsNone)
            Action = "jump";

    }
}


public class AndroidNameTag : MedalTag
{
    public AndroidNameTag(Sprite Parent) : base(Parent)
    {
    }
    public static AndroidNameTag Instance;

    static void ReDraw()
    {
        if (Instance != null)
            Instance.IsReDraw = true;
    }

    public static void Remove()
    {
        if (Instance != null)
        {
            Instance.Dead();
            EngineFunc.SpriteEngine.Dead();
        }
    }

    public override void DoMove(float Delta)
    {
        base.DoMove(Delta);
        if (IsReDraw)
        {
            Engine.Canvas.DrawTarget(ref TargetTexture, 300, 100, () => { RenderTargetFunc(); });
        }
        X = AndroidPlayer.Instance.X;
        Y = AndroidPlayer.Instance.Y;
        Z = AndroidPlayer.Instance.Z;
    }

    public override void DoDraw()
    {
        if (Map.ShowPlayer)
        {
            int WX = (int)(AndroidPlayer.Instance.X) - (int)(Engine.Camera.X);
            int WY = (int)(AndroidPlayer.Instance.Y) - (int)(Engine.Camera.Y);
            Engine.Canvas.Draw(TargetTexture, WX - 150, WY - 28, MonoGame.SpriteEngine.BlendMode.NonPremultiplied);
        }
        if (IsReDraw)
            IsReDraw = false;
    }

    public static void Create(string ItemID)
    {
        Instance = new AndroidNameTag(EngineFunc.SpriteEngine);
        Instance.IntMove = true;
        Instance.Tag = 1;
        int TagNum = Wz.GetInt("Etc/Android/" + ItemID + "/info/nameTag", 38);
        Instance.Entry = Wz.GetNode("UI/NameTag.img/pet/" + TagNum);
        if (Instance.Entry == null)
            Instance.Entry = Wz.GetNode("UI/NameTag.img/pet/38");
        if (Instance.Entry.HasNode("c/_inlink"))
        {
            string Data = Instance.Entry.GetStr("c/_inlink");
            Data = Data.Replace("/c", "");
            Data = Data.Replace("pet/", "");
            Instance.Entry = Wz.GetNode("UI/NameTag.img/pet/" + Data);
        }
        Wz.DumpData(Instance.Entry, Wz.EquipData, Wz.EquipImageLib);

    }


}
```

`MapleNecrocer/Client/ChatBalloon.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WzComparerR2.WzLib;
using WzComparerR2.PluginBase;
using Spine;
using WzComparerR2.Animation;
using Microsoft.Xna.Framework;
using Color = Microsoft.Xna.Framework.Color;
using DevComponents.DotNetBar;
using SharpDX;
using System.Xml.Linq;
using Microsoft.Xna.Framework.Graphics;
using System.Reflection.PortableExecutable;
using static System.Net.Mime.MediaTypeNames;
using MonoGame.SpriteEngine;
using System.Security.Cryptography;
using DevComponents.DotNetBar.Controls;
using System.ComponentModel.Design;

namespace MapleNecrocer;

public struct BalloonInfo
{
    public Wz_Node ImageNode;
    public int Width, Height;
    public Vector2 Origin;
}
public class ChatBalloon : SpriteEx
{
    public ChatBalloon(Sprite Parent) : base(Parent)
    {
        Part1 = new BalloonInfo[30];
        Part2 = new BalloonInfo[30];
        Part3 = new BalloonInfo[30];

    }
    private int Col, Row, OffH, BWidth;
    private int MaxChars;
    private BalloonInfo[] Part1, Part2, Part3;
    BalloonInfo Arrow, C, E, N, NE, NW, S, SE, SW, W;
    int Style;
    string Directory;
    Wz_Node WzNode;
    public string Msg;
    int Counter;
    Microsoft.Xna.Framework.Color Color = new Color(0);
    int R, G, B;
    int FontColor;
    public RenderTarget2D RenderTarget;
    BalloonInfo GetData(string TileName)
    {
        BalloonInfo Result = new BalloonInfo();
        if (WzNode.ParentNode.Text == "ChatBalloon.img")
        {
            if (Wz.HasNode("UI/ChatBalloon.img/" + Style + "/c"))
                Result.ImageNode = Wz.GetNode("UI/ChatBalloon.img/" + Style + "/" + TileName);
            else
                Result.ImageNode = Wz.GetNode("UI/ChatBalloon.img/" + Style + "/0/" + TileName);

        }
        else
            Result.ImageNode = Wz.GetNodeA("UI/ChatBalloon.img/" + Directory + "/" + Style + "/" + TileName);
        Result.Width = WzNode.GetNode(TileName).ExtractPng().Width;
        Result.Height = WzNode.GetNode(TileName).ExtractPng().Height;
        Result.Origin.X = WzNode.Get(TileName + "/origin").ToVector().X;
        Result.Origin.Y = WzNode.Get(TileName + "/origin").ToVector().Y;
        return Result;
    }

    public void SetStyle(int BalloonStyle, string Dir = "")
    {
        Directory = Dir;
        Style = BalloonStyle;
        if (Directory == "")
        {
            if (Wz.HasNode("UI/ChatBalloon.img/" + Style + "/c"))
                WzNode = Wz.GetNode("UI/ChatBalloon.img/" + Style);
            else

                WzNode = Wz.GetNode("UI/ChatBalloon.img/" + Style + "/0");
        }
        else
            WzNode = Wz.GetNodeA("UI/ChatBalloon.img/" + Directory + "/" + Style);
        Wz.DumpData(WzNode, Wz.Data, Wz.EquipImageLib);

        Engine.Canvas.DrawTarget(ref RenderTarget, 150, 512, () => { });
        if (WzNode.Get("clr") != null)
            FontColor = 16777216 + WzNode.Get("clr").ToInt();
        else
            FontColor = 16777215;
        string Hex = FontColor.ToString("X").PadLeft(6, '0');
        R = (byte)Convert.ToInt32(Hex.LeftStr(2), 16);
        G = (byte)Convert.ToInt32(Hex.Substring(2, 2), 16);
        B = (byte)Convert.ToInt32(Hex.RightStr(2), 16);
        if (WzNode.Get("arrow") != null)
            Arrow = GetData("arrow");
        C = GetData("c");
        E = GetData("e");
        N = GetData("n");
        NE = GetData("ne");
        NW = GetData("nw");
        S = GetData("s");
        SE = GetData("se");
        SW = GetData("sw");
        W = GetData("w");
        BWidth = 90;
        Col = (BWidth / N.Width) + 1;
        MaxChars = (N.Width * Col) / 8;
        Part1[0] = C;
        Part1[1] = NW;
        Part2[0] = C;
        Part2[1] = W;
        Part3[0] = C;
        Part3[1] = SW;
        for (int i = 2; i <= Col; i++)
        {
            Part1[i] = N;
            Part2[i] = C;
            Part3[i] = S;
        }
        Part1[Col + 1] = NE;
        Part2[Col + 1] = E;
        Part3[Col + 1] = SE;
    }

    private static String ParseText(String Text, int Width)
    {
        String Line = String.Empty;
        String ReturnString = String.Empty;
        String[] WordArray = null;
        if (Wz.Region == "GMS")
            WordArray = Text.Split(' ');
        else
            WordArray = Text.Split('=');

        foreach (String Word in WordArray)
        {
            if (Map.MeasureStringX(Map.NpcBalloonFont, Line + Word) > Width)
            {
                ReturnString = ReturnString + Line + '\n';
                Line = String.Empty;
            }
            Line = Line + Word + ' ';
        }
        return ReturnString + Line;
    }

    public override void DoMove(float Delta)
    {
        Counter += 1;
        if (Counter % 100 == 0)
        {
            if (Msg != "")
            {
                Engine.Canvas.DrawTarget(ref RenderTarget, 150, 512, () => { RenderTargetFunc(); });
            }
        }
    }

    public override void DoDraw()
    {
        if (!Map.ShowNpcChat)
            return;
        if (!Map.ShowNpc)
            return;
        if (Msg != "")
            Engine.Canvas.Draw(RenderTarget, (int)X - 70 - (int)Engine.Camera.X, (int)Y - 500 - (int)Engine.Camera.Y);
        //Engine.Canvas.Draw(RenderTarget, X - 70 - Engine.Camera.X, Y - 500 - Engine.Camera.Y);
    }
    static bool Loaded;
    public void RenderTargetFunc()
    {
        if (Msg == null) return;
        String Line = String.Empty;
        String[] WordArray = null;
        if (Wz.Region == "GMS")
            WordArray = Msg.Split(' ');
        else
            WordArray = Msg.Split('=');

        int SplitWidth = 90;
        int RowCount = 0;
        foreach (String Word in WordArray)
        {
            if (Map.MeasureStringX(Map.NpcBalloonFont, Line + Word) > SplitWidth)
            {
                RowCount += 1;
                Line = String.Empty;
            }
            Line = Line + Word + ' ';
        }

        int Row = RowCount + 1;
        int OffH = Row * C.Height + (int)C.Origin.Y + S.Height;
        int Cx1 = 0;
        int Cx2 = 0;
        int Cx3 = 0;
        int Mid = (Col * N.Width / 2);


        for (int I = 1; I <= Col + 1; I++)
        {

            Cx1 += Part1[I - 1].Width;

            if (!Loaded)
            {
                Wz.EquipImageLib[Part1[I].ImageNode] = MedalTag.FixAlpha(Part1[I].ImageNode.ExtractPng());
                Wz.EquipImageLib[Part2[I].ImageNode] = MedalTag.FixAlpha(Part2[I].ImageNode.ExtractPng());
                Wz.EquipImageLib[Part3[I].ImageNode] = MedalTag.FixAlpha(Part3[I].ImageNode.ExtractPng());
            }
            if (Style > 0)
            {
                Wz.EquipImageLib[Part1[I].ImageNode] = MedalTag.FixAlpha(Part1[I].ImageNode.ExtractPng());
                Wz.EquipImageLib[Part2[I].ImageNode] = MedalTag.FixAlpha(Part2[I].ImageNode.ExtractPng());
                Wz.EquipImageLib[Part3[I].ImageNode] = MedalTag.FixAlpha(Part3[I].ImageNode.ExtractPng());
            }

            Engine.Canvas.Draw(Wz.EquipImageLib[Part1[I].ImageNode], Cx1 - NW.Origin.X - Mid + 70, -Part1[I].Origin.Y - OffH + 500);
            Cx2 += Part2[I - 1].Width;
            for (int J = 0; J <= Row - 1; J++)
                Engine.Canvas.Draw(Wz.EquipImageLib[Part2[I].ImageNode], Cx2 - W.Origin.X - Mid + 70, -Part2[I].Origin.Y + (J * C.Height) - OffH + 500);
            Cx3 += Part3[I - 1].Width;
            Engine.Canvas.Draw(Wz.EquipImageLib[Part3[I].ImageNode], Cx3 - SW.Origin.X - Mid + 70, -Part3[I].Origin.Y + (Row * C.Height) - OffH + 500);
        }
       

        if (Arrow.ImageNode != null)
        {
            if (!Loaded)
                Wz.EquipImageLib[Arrow.ImageNode] = MedalTag.FixAlpha(Arrow.ImageNode.ExtractPng());
            if (Style > 0)
                Wz.EquipImageLib[Arrow.ImageNode] = MedalTag.FixAlpha(Arrow.ImageNode.ExtractPng());
        }
        Loaded = true;

        if (WzNode.Get("arrow") != null)
            Engine.Canvas.Draw(Wz.EquipImageLib[Arrow.ImageNode], 70, Arrow.Origin.Y + (Row * C.Height) - OffH + 500);
        if (Style == 0)
            Engine.Canvas.DrawString(Map.NpcBalloonFont, ParseText(Msg, SplitWidth), -Mid + 82, -OffH + 500, new Color(155, 0, 0, 255));
        else
            Engine.Canvas.DrawString(Map.NpcBalloonFont, ParseText(Msg, SplitWidth), -Mid + 82, -OffH + 500, new Color(R, G, B, 255));

    }

}

public class ChatRingBalloon : ChatBalloon
{
    public ChatRingBalloon(Sprite Parent) : base(Parent)
    {

    }
    public void ReDraw()
    {

        Engine.Canvas.DrawTarget(ref RenderTarget, 150, 512, () => { RenderTargetFunc(); });
    }

    public override void DoDraw()
    {

        Engine.Canvas.Draw(RenderTarget, (int)X - 70 - (int)Engine.Camera.X - Game.Player.BrowPos.X + MapleChair.BodyRelMove.X,
            (int)Y - 500 - (int)Engine.Camera.Y - Game.Player.BrowPos.Y + MapleChair.BodyRelMove.Y);
    }

    public override void DoMove(float Delta)
    {
        X = Game.Player.X - 10;
        Y = Game.Player.Y - 60;
        Z = Game.Player.Z + 100;
    }

    public static void Remove()
    {
        MapleChair.IsUse = false;
        foreach (var Iter in EngineFunc.SpriteEngine.SpriteList)
        {
            if (Iter is ChatRingBalloon)
            {
                Iter.Dead();
                var s = Iter;
                s = null;
            }
        }
        EngineFunc.SpriteEngine.Dead();
    }

}
```

`MapleNecrocer/Client/DamageNumber.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WzComparerR2.CharaSim;

namespace MapleNecrocer;

public class DamageNumber : SpriteEx
{
    public DamageNumber(Sprite Parent) : base(Parent)
    {

    }
    int Number;
    int Counter;
    byte Alpha;
    string LargeNumber, SmallNumber;
    public static string Style;
    public static bool UseNewDamage;
    public static void Load(string Num)
    {
        string[] StyleList = { "NoBlue0", "NoBlue1", "NoCri0", "NoCri1", "NoRed0", "NoRed1", "NoViolet0", "NoViolet1" };
        var Entry = Wz.GetNode("Effect/BasicEff.img");
        if (UseNewDamage)
        {
            //num=1/NoRed1
            if (Wz.GetNode("Effect/DamageSkin.img/" + Num) != null)
            {
                var Split = Num.Split("/");
                Wz.DumpData(Wz.GetNode("Effect/DamageSkin.img/" + Split[0]), Wz.EquipData, Wz.EquipImageLib);
            }
            else
            {
                Wz.DumpData(Entry.GetNode("damageSkin/" + Num), Wz.EquipData, Wz.EquipImageLib);
            }
        }
        else
        {
            for (int I = 0; I <= 7; I++)
            {
                if (Wz.HasNode("Effect/BasicEff.img/" + StyleList[I]))
                    Wz.DumpData(Entry.Nodes[StyleList[I]], Wz.EquipData, Wz.EquipImageLib);
            }
        }
    }

    public static void Create(int ANumber, int AX, int AY)
    {
        int Len = ANumber.ToString().Length;
        int Mid = (Len * 28) / 2;
        var DamageNumber = new DamageNumber(EngineFunc.SpriteEngine);

        if (UseNewDamage)
        {
            var Len2 = Style.Length - 1;
            DamageNumber.LargeNumber = Style.LeftStr(Len2) + "1";
            DamageNumber.SmallNumber = Style.LeftStr(Len2) + "0";
        }
        else
        {
            DamageNumber.LargeNumber = Style.LeftStr(5) + "1";
            DamageNumber.SmallNumber = Style.LeftStr(5) + "0";
        }
        DamageNumber.Number = ANumber;
        DamageNumber.X = AX - Mid / 2;
        DamageNumber.Y = AY;
        DamageNumber.Z = Game.Player.Z;
        DamageNumber.Alpha = 255;
    }

    public override void DoMove(float Delta)
    {
        base.DoMove(Delta);
        Y -= 0.5f;
        Counter += 1;
        if (Counter > 50)
            Alpha -= 6;
        if (Alpha < 10)
            Dead();
    }

    public override void DoDraw()
    {
        int W, OffY;
        for (int I = 0; I < Number.ToString().Length; I++)
        {
            var Char = Number.ToString().Substring(I, 1);
            if (UseNewDamage)
            {
                //style='1/NoRed1'
                W = 29;
                if (Wz.EquipData.ContainsKey("Effect/DamageSkin.img/" + Style + "/" + Char))
                {
                    if (I == 0)
                        ImageNode = Wz.EquipData["Effect/DamageSkin.img/" + LargeNumber + "/" + Char];
                    else
                        ImageNode = Wz.EquipData["Effect/DamageSkin.img/" + SmallNumber + "/" + Char];
                }
                else
                {
                    if (I == 0)
                        ImageNode = Wz.EquipData["Effect/BasicEff.img/damageSkin/" + LargeNumber + "/" + Char];
                    else
                        ImageNode = Wz.EquipData["Effect/BasicEff.img/damageSkin/" + SmallNumber + "/" + Char];
                }
            }
            else
            {
                W = 20;
                if (I == 0)
                    ImageNode = Wz.EquipData["Effect/BasicEff.img/" + LargeNumber + "/" + Char];
                else
                    ImageNode = Wz.EquipData["Effect/BasicEff.img/" + SmallNumber + "/" + Char];
            }
            if ((I % 2) == 0)
                OffY = 0;
            else
                OffY = -5;
            EngineFunc.Canvas.DrawColor(Wz.EquipImageLib[ImageNode], (int)X + I * W - ImageNode.Nodes["origin"].ToVector().X
              - (int)Engine.Camera.X, (int)Y - ImageNode.Nodes["origin"].ToVector().Y - (int)Engine.Camera.Y + OffY, 255, 255, 255, Alpha);

        }
    }
}


```

`MapleNecrocer/Client/Familiar.cs`:

```cs
using Microsoft.Xna.Framework.Graphics;
using Spine;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WzComparerR2.WzLib;
using Vector2 = Microsoft.Xna.Framework.Vector2;

namespace MapleNecrocer;

public class Familiar : JumperSprite
{
    public Familiar(Sprite Parent) : base(Parent)
    {
        SpriteSheetMode = SpriteSheetMode.NoneSingle;
    }

    public int FTime;
    Foothold WallFH;
    Foothold BelowFH;
    MoveDirection MoveDirection;
    float MoveSpeed;
    string PetName;
    int NameWidth;
    int IDWidth;
    MoveType MoveType;
    int FallEdge;
    int JumpEdge;
    public Wz_Vector origin = new(0, 0);
    public string Path;
    public string UpPath;
    public string State;
    public int Frame;
    public int Delay;
    int FollowDistance;
    Vector2 Distance;
    bool OnLadder;
    Foothold FH;
    public static Familiar Instance;

    public static void Create(string ID)
    {
        Wz_Node Entry = null;
        if (Wz.HasNode("Mob/" + ID + ".img"))
            Entry = Wz.GetNode("Mob/" + ID + ".img");
        Wz.DumpData(Entry, Wz.EquipData, Wz.EquipImageLib);
        foreach (var Iter in Wz.EquipData[Entry.FullPathToFile2()].Nodes)
        {
            foreach (var Iter2 in Wz.EquipData[Iter.FullPathToFile2()].Nodes)
            {
                if (Char.IsNumber(Iter2.Text[0]))
                {
                    if ((Iter.Text == "stand" || Iter.Text == "fly") && (Iter2.Text == "0"))
                    {
                        Instance = new Familiar(EngineFunc.SpriteEngine);
                        Instance.ImageLib = Wz.EquipImageLib;
                        Instance.IntMove = true;
                        Instance.Tag = 1;
                        Instance.State = Iter.Text;
                        Instance.Frame = Iter2.Text.ToInt();
                        Instance.UpPath = Entry.FullPathToFile2();
                        Instance.ImageNode = Wz.EquipData[Iter2.FullPathToFile2()];
                        Instance.FollowDistance = 130;
                        int StartX = (int)Game.Player.X - Instance.FollowDistance;
                        if (StartX < Map.Left)
                            StartX = (int)Game.Player.X;
                        Vector2 Pos = FootholdTree.Instance.FindBelow(new Vector2(StartX, Game.Player.Y - 100), ref Instance.BelowFH);
                        Instance.MoveType = MoveType.Jump;
                        Instance.X = Pos.X;
                        Instance.Y = Pos.Y;
                        Instance.FH = Instance.BelowFH;
                        Instance.Z = Instance.FH.Z * 100000 + 50000;
                        Instance.JumpSpeed = 0.6f;
                        Instance.JumpHeight = 9;
                        Instance.MaxFallSpeed = 8;
                        Instance.MoveDirection = MoveDirection.None;
                        Instance.MoveSpeed = 2.5f;
                    }
                }
            }


        }

    }

    public override void DoMove(float Delta)
    {
        base.DoMove(Delta);
        int X1 = FH.X1;
        int Y1 = FH.Y1;
        int X2 = FH.X2;
        int Y2 = FH.Y2;

        if (Wz.HasDataE(UpPath + "/" + State + "/" + Frame))
        {
            Path = UpPath + "/" + State + "/" + Frame;
            ImageNode = Wz.EquipData[Path];
        }

        if (Wz.HasDataE(UpPath + "/" + State + "/" + Frame + "/delay"))
            Delay = Wz.EquipData[UpPath + "/" + State + "/" + Frame + "/delay"].ToInt();
        else
            Delay = 100;

        FTime += 17;
        if (FTime > Delay)
        {
            Frame += 1;
            if (!Wz.HasDataE(UpPath + "/" + State + "/" + Frame))
                Frame = 0;
            FTime = 0;
        }

        Distance.X = Math.Abs(Game.Player.X - X);
        Distance.Y = Math.Abs(Game.Player.Y - Y);

        if (Distance.X > FollowDistance)
        {
            State = "move";
            if (Game.Player.X > X)
            {
                FlipX = true;
                MoveDirection = MoveDirection.Right;
            }
            if (Game.Player.X < X)
            {
                FlipX = false;
                MoveDirection = MoveDirection.Left;
            }
        }
        else
        {
            State = "stand";
            MoveDirection = MoveDirection.None;
        }

        if (Game.Player.Y < Y && !Game.Player.InLadder)
        {
            switch (Distance.Y)
            {
                case float i when i >= 100 && i <= 150:
                    if (JumpState == JumpState.jsNone && Game.Player.JumpState == JumpState.jsNone)
                    {
                        Vector2 Below = FootholdTree.Instance.FindBelow(new Vector2(X, Y - 80), ref BelowFH);
                        if (Y - Below.Y != 0)
                            DoJump = true;
                    }
                    break;
                case float i when i >= 151 && i <= 2000:
                    if (Game.Player.JumpState == JumpState.jsNone)
                    {
                        X = Game.Player.X;
                        Y = Game.Player.Y;
                        DoJump = true;
                    }
                    break;
            }
        }

        if (Game.Player.Y > Y)
        {
            if (Distance.Y >= 200 && Distance.Y <= 2000)
            {

                Y += 5;
                JumpState = JumpState.jsFalling;
            }
        }
        if (JumpState == JumpState.jsFalling)
        {
          Vector2  Below = FootholdTree.Instance.FindBelow(new Vector2(X, Y - VelocityY - 2), ref BelowFH);
            if (Y >= Below.Y - 3)
            {
                Y = Below.Y;
                // MaxFallSpeed :=10;
                JumpState = JumpState.jsNone;
                FH = BelowFH;
                Z = FH.Z * 100000 + 50000;
            }
        }

        int FallEdge;
        int Direction;
        if (MoveDirection == MoveDirection.Left)
        {
            Direction = GetAngle256(X2, Y2, X1, Y1);
            if (!FH.IsWall())
            {
                X += (float)(Sin256(Direction) * MoveSpeed);
                Y -= (float)(Cos256(Direction) * MoveSpeed);
            }
            FallEdge = -999999;
            JumpEdge = -999999;
            if (MoveType == MoveType.Move)
            {
                // no fh
                if (FH.Prev == null)
                    FallEdge = FH.X1;
                // Wall's edge down
                if ((FH.Prev != null) && (FH.Prev.IsWall()))
                    FallEdge = FH.X1;

                if (X < FallEdge)
                {
                    X = FallEdge;
                    FlipX = true;
                    MoveDirection = MoveDirection.Right;
                }
            }

            if (MoveType == MoveType.Jump)
            {
                // .--------.
                if (FH.Prev == null)
                    JumpEdge = FH.X1;
                // ┌--- <--
                if ((FH.Prev != null) && (FH.Prev.IsWall()) && (FH.Prev.Y1 > Y))
                    FallEdge = FH.X1;

                if (X < FallEdge)
                {
                    if (Game.Player.Y <= Y)
                        DoJump = true;
                    if (Game.Player.Y > Y && JumpState == JumpState.jsNone)
                        JumpState = JumpState.jsFalling;
                }
                if (X < JumpEdge)
                    DoJump = true;
                // -->  ---┐  <--
                WallFH = FootholdTree.Instance.FindWallR(new Vector2(X + 4, Y - 4));
                if ((WallFH != null) && (FH.Z == WallFH.Z))
                {
                    if (X < WallFH.X1 + 30 && Game.Player.Y <= Y)
                        DoJump = true;
                    if (X <= WallFH.X1)
                    {
                        X = WallFH.X1 + MoveSpeed;
                        if (JumpState == JumpState.jsNone)
                        {
                            FlipX = true;
                            MoveDirection = MoveDirection.Right;
                        }
                    }
                }
            }
            // walk left
            if ((X <= FH.X1) && (FH.PrevID != 0) && (!FH.IsWall()) && (!FH.Prev.IsWall()))
            {
                if (JumpState == JumpState.jsNone)
                {
                    FH = FH.Prev;
                    X = FH.X2;
                    Y = FH.Y2;
                    Z = FH.Z * 100000 + 50000;
                }
            }
        }
        // walk right
        if (MoveDirection == MoveDirection.Right)
        {
            Direction = GetAngle256(X1, Y1, X2, Y2);
            if (!FH.IsWall())
            {
                X += (float)(Sin256(Direction) * MoveSpeed);
                Y -= (float)(Cos256(Direction) * MoveSpeed);
            }
            FallEdge = 999999;
            JumpEdge = 999999;
            if (MoveType == MoveType.Move)
            {
                if (FH.Next == null)
                    FallEdge = FH.X2 + 5;
                // Wall down
                if ((FH.Next != null) && (FH.Next.IsWall()))

                    FallEdge = FH.X2;
                if (X > FallEdge)
                {
                    X = FallEdge;
                    FlipX = false;
                    MoveDirection = MoveDirection.Left;
                }
            }

            if (MoveType == MoveType.Jump)
            {
                if (FH.Next == null) // .--------.
                    JumpEdge = FH.X2;
                // -->  ----┐
                if ((FH.Next != null) && (FH.Next.IsWall()) && (FH.Next.Y2 > Y))
                    FallEdge = FH.X2;

                if (X > FallEdge)
                {
                    if (Game.Player.Y <= Y)
                        DoJump = true;
                    if (Game.Player.Y > Y && JumpState == JumpState.jsNone)
                        JumpState = JumpState.jsFalling;
                }
                if (X > JumpEdge)
                    DoJump = true;
                // -->  ┌.....
                WallFH = FootholdTree.Instance.FindWallL(new Vector2(X - 4, Y - 4));
                if ((WallFH != null) && (FH.Z == WallFH.Z))
                {
                    if (X > WallFH.X1 - 30 && Game.Player.Y <= Y)
                        DoJump = true;
                    if (X >= WallFH.X1)
                    {
                        X = WallFH.X2 - MoveSpeed;
                        if (JumpState == JumpState.jsNone)
                        {
                            FlipX = false;
                            MoveDirection = MoveDirection.Left;
                        }
                    }
                }
            }
            // walk right
            if ((X >= FH.X2) && (FH.NextID != 0) && (!FH.IsWall()) && (!FH.Next.IsWall()))
            {
                if (JumpState == JumpState.jsNone)
                {
                    FH = FH.Next;
                    X = FH.X1;
                    Y = FH.Y1;
                    Z = FH.Z * 100000 + 50000;
                }
            }
        }

        if (ImageNode.GetNode("origin") != null)
            origin = ImageNode.GetNode("origin").ToVector();
        switch (FlipX)
        {
            case true:
                Offset.X = origin.X - ImageWidth;
                break;
            case false:
                Offset.X = -origin.X;
                break;
        }
        Offset.Y = -origin.Y;
    }

    public static void Remove()
    {
        if (Instance != null)
        {
            Instance.Dead();
            Instance = null;
            foreach (var Iter in Wz.EquipImageLib.Keys)
            {
                if (Iter.FullPathToFile2().LeftStr(3) == "Mob")
                {
                    Wz.EquipImageLib.Remove(Iter);
                    // EquipData.Remove(Iter.GetPath);
                }
            }
            EngineFunc.SpriteEngine.Dead();
        }
    }
}

public class FamiliarNameTag : SpriteEx
{
    public FamiliarNameTag(Sprite Parent) : base(Parent)
    {
    }
    public static bool ReDraw;
    static bool CanUse;
    public static string MobName;
    static int NameWidth;
    static RenderTarget2D TargetTexture = null;
    public static bool IsUse = true;
    public static FamiliarNameTag Instance;
    public static void Create(string Name)
    {
        MobName = Name;
        NameWidth = Map.MeasureStringX(Map.NpcNameTagFont, Name);
        EngineFunc.Canvas.DrawTarget(ref TargetTexture, NameWidth + 10, 25, () =>
        {
            int NamePos = NameWidth / 2;
            if (Map.ShowPlayer)
            {
                EngineFunc.Canvas.FillRoundRect(0, 2, NameWidth + 8, 15, new Microsoft.Xna.Framework.Color(0, 0, 0, 150));
                EngineFunc.Canvas.DrawString(Map.NpcNameTagFont, Name, 3, 2, Microsoft.Xna.Framework.Color.White);
            }
        });

        Instance = new FamiliarNameTag(EngineFunc.SpriteEngine);
        Instance.Tag = 1;
        Instance.IntMove = true;
        //NameTag.BlendMode=BlendMode.AddtiveColor;
    }

    public override void DoMove(float Delta)
    {
        base.DoMove(Delta);
        if (ReDraw)
        {
            NameWidth = Map.MeasureStringX(Map.NpcNameTagFont, MobName);
            EngineFunc.Canvas.DrawTarget(ref TargetTexture, NameWidth + 10, 25, () =>
            {
                int NamePos = NameWidth / 2;
                if (Map.ShowPlayer)
                {
                    Engine.Canvas.FillRoundRect(0, 2, NameWidth + 8, 15, new Microsoft.Xna.Framework.Color(0, 0, 0, 180));
                    Engine.Canvas.DrawString(Map.NpcNameTagFont, MobName, 3, 2, Microsoft.Xna.Framework.Color.White);
                }
            });
        }
        X = Familiar.Instance.X;
        Y = Familiar.Instance.Y;
        Z = Familiar.Instance.Z;
    }

    public override void DoDraw()
    {
        if (!NameTag.IsUse)
            return;
        if (Map.ShowPlayer)
        {
            int WX = (int)(Familiar.Instance.X) - (int)Engine.Camera.X;
            int WY = (int)(Familiar.Instance.Y) - (int)Engine.Camera.Y;
            int NamePos = NameWidth / 2;
            Engine.Canvas.Draw(TargetTexture, WX - NamePos - 8, WY,  MonoGame.SpriteEngine.BlendMode.NonPremultiplied);
        }
        if (ReDraw)
            ReDraw = false;
    }

    public static void Remove()
    {
        if (Instance != null)
            Instance.Dead();
        EngineFunc.SpriteEngine.Dead();

    }

}
```

`MapleNecrocer/Client/Footholds.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Text.RegularExpressions;
using System.Windows.Forms;
using Microsoft.Xna.Framework;
using Point = Microsoft.Xna.Framework.Point;
namespace MapleNecrocer;

public class Foothold
{
    public Foothold(Vector2 P1, Vector2 P2, int ID)
    {
        p1 = P1;
        p2 = P2;
        id = ID;
    }
    private Vector2 p1, p2;
    private int id;
    public int ID { get => id; set => id = value; }
    public int PlatformID;
    public int Z;
    public int NextID;
    public int PrevID;
    public int X1 { get => (int)p1.X; }
    public int X2 { get => (int)p2.X; }
    public int Y1 { get => (int)p1.Y; }
    public int Y2 { get => (int)p2.Y; }
    public bool IsWall()
    {
        if (p1.X == p2.X)
            return true;
        return false;
    }
    public Foothold Prev;
    public Foothold Next;
}

public class FootholdTree
{
    private List<Foothold> footholds = new();
    private Vector2 P1, P2;
    public static FootholdTree Instance;
    public static List<int> MinX1, MaxX2;
    public List<Foothold> Footholds { get => footholds; }
    public FootholdTree(Vector2 P1, Vector2 P2)
    {
        this.P1 = P1;
        this.P2 = P2;
    }
    public Foothold GetPrev(Foothold FH)
    {
        Foothold Result = null;
        foreach (var F in footholds)
        {
            if (F.ID == FH.PrevID)
                Result = F;
        }
        return Result;
    }
    public Foothold GetNext(Foothold FH)
    {
        Foothold Result = null;
        foreach (var F in footholds)
        {
            if (F.ID == FH.NextID)
                Result = F;
        }
        return Result;
    }

    public Vector2 FindBelow(Vector2 Pos, ref Foothold FH)
    {
        bool First = true;
        double MaxY = 0, CMax = 0;
        Vector2 Result = new Vector2(0, 0);
        int X = (int)Pos.X;
        int Y = (int)Pos.Y;

        foreach (var F in footholds)
        {
            if (X >= F.X1 && X <= F.X2 || X >= F.X2 && X <= F.X1)
            {

                if (First)
                {
                    if (F.X1 == F.X2)
                        continue;
                    MaxY = (float)(F.Y1 - F.Y2) / (F.X1 - F.X2) * (X - F.X1) + F.Y1;
                    FH = F;
                    if (MaxY >= Y)
                        First = false;
                }
                else
                {
                    if (F.X1 == F.X2)
                        continue;
                    CMax = (float)(F.Y1 - F.Y2) / (F.X1 - F.X2) * (X - F.X1) + F.Y1;
                    if (CMax < MaxY && CMax >= Y)
                    {
                        FH = F;
                        MaxY = CMax;
                    }
                }
            }
        }

        if (!First)
        {
            Result.X = X;
            Result.Y = (float)MaxY;

        }
        else
        {
            Result = new Vector2(99999, 99999);
        }
        return Result;
    }

    public Foothold FindWallR(Vector2 P)
    {
        Foothold Result = null;
        bool First = true;
        double MaxX = 0, CMax = 0;
        int X = (int)P.X;
        int Y = (int)P.Y;
        foreach (var F in footholds)
        {
            if (F.IsWall() && F.X1 <= P.X && F.Y1 <= P.Y && F.Y2 >= P.Y)
            {
                if (First)
                {
                    MaxX = F.X1;
                    Result = F;
                    if (MaxX <= X)
                        First = false;
                }
                else
                {
                    CMax = F.X1;
                    if (CMax > MaxX && CMax <= X)
                    {
                        MaxX = CMax;
                        Result = F;
                    }
                }
            }
        }
        return Result;
    }

    public Foothold FindWallL(Vector2 P)
    {
        Foothold Result = null;
        bool First = true;
        double MaxX = 0, CMax = 0;
        int X = (int)P.X;
        int Y = (int)P.Y;
        foreach (var F in footholds)
        {
            if (F.IsWall() && F.X1 >= P.X && F.Y1 >= P.Y && F.Y2 <= P.Y)
            {
                if (First)
                {
                    MaxX = F.X1;
                    Result = F;
                    if (MaxX >= X)
                        First = false;
                }
                else
                {
                    CMax = F.X1;
                    if (CMax < MaxX && CMax >= X)
                    {
                        MaxX = CMax;
                        Result = F;
                    }
                }
            }
        }
        return Result;
    }
    public bool ClosePlatform(Foothold FH)
    {
        int Count = 0;
        bool Result = false;
        foreach (var F in footholds)
        {
            if (F.PlatformID == FH.PlatformID && F.IsWall())
                Count += 1;
        }
        if (Count == 2)
            Result = true;
        return Result;
    }
    public void Insert(Foothold F)
    {
        footholds.Add(F);
    }

    public void DrawFootholds()
    {
        int WX = (int)EngineFunc.SpriteEngine.Camera.X;
        int WY = (int)EngineFunc.SpriteEngine.Camera.Y;
        foreach (var FH in Footholds)
        {
            EngineFunc.Canvas.DrawLine(new Point(FH.X1 - WX, FH.Y1 - WY), new Point(FH.X2 - WX, FH.Y2 - WY), 1, Microsoft.Xna.Framework.Color.Red);
            if (FH.X1 != FH.X2)
                EngineFunc.Canvas.DrawLine(new Point(FH.X1 - WX, FH.Y1 - WY + 1), new Point(FH.X2 - WX, FH.Y2 - WY + 1), 1, Microsoft.Xna.Framework.Color.Red);
            else
                EngineFunc.Canvas.DrawLine(new Point(FH.X1 - WX + 1, FH.Y1 - WY), new Point(FH.X2 - WX + 1, FH.Y2 - WY),1, Microsoft.Xna.Framework.Color.Red);
        }
    }
    public static void CreateFootholds()
    {
        if (Instance == null)
        {
            Instance = new FootholdTree(new Vector2(100, 10), new Vector2(-100, -100));
            MinX1 = new();
            MaxX2 = new();
        }
        else
        {
            Instance.Footholds.Clear();
            MinX1.Clear();
            MaxX2.Clear();
        }


        Foothold FH;
        foreach (var Iter in Map.Img.Nodes["foothold"].Nodes)
        {
            foreach (var Iter2 in Iter.Nodes)
            {
                foreach (var Iter3 in Iter2.Nodes)
                {
                    int X1 = Iter3.GetInt("x1");
                    int Y1 = Iter3.GetInt("y1");
                    int X2 = Iter3.GetInt("x2");
                    int Y2 = Iter3.GetInt("y2");
                    FH = new Foothold(new Vector2(X1, Y1), new Vector2(X2, Y2), 0);
                    FH.NextID = Iter3.GetInt("next");
                    FH.PrevID = Iter3.GetInt("prev");
                    FH.PlatformID = Iter2.Text.ToInt();
                    FH.ID = Iter3.Text.ToInt();
                    FH.Z = Iter.Text.ToInt();
                    Instance.Insert(FH);
                    MinX1.Add(X1);
                    MaxX2.Add(X2);
                }
            }
        }


        List<Foothold> FHs;
        MinX1.Sort();
        MaxX2.Sort();
        FHs = Instance.Footholds;
        for (int i = 0; i < FHs.Count; i++)
        {
            for (int j = 0; j < FHs.Count; j++)
            {
                if (i == j)
                    continue;
                if (FHs[j].ID == FHs[i].PrevID)
                    FHs[i].Prev = FHs[j];
                if (FHs[j].ID == FHs[i].NextID)
                    FHs[i].Next = FHs[j];
            }
        }
    }

}

```

`MapleNecrocer/Client/ItemDrop.cs`:

```cs
using Spine;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WzComparerR2.WzLib;
using Vector2 = Microsoft.Xna.Framework.Vector2;


namespace MapleNecrocer;

internal class ItemDrop : JumperSprite
{
    public ItemDrop(Sprite Parent) : base(Parent)
    {
        ImageLib = Wz.EquipImageLib;
        DoJump = true;
        JumpSpeed = 0.3f;
        JumpHeight = 9;
        MaxFallSpeed = 8;
        Random Random = new();
        CosY = Random.Next(100);
        SpriteSheetMode= SpriteSheetMode.NoneSingle;
        DoCenter = true;
    }
    static float Value;
    Foothold FH;
    int Number;
    string Style;
    int TimeCount;
    int Frame;
    int FTime;
    public float MoveX;
    public float CosY;
    public string ParentPath;
    public string ID;

    static string GetItemDir(string ID)
    {
        switch (ID.ToInt() / 1000000)
        {
            case 5: return "Cash";
            case 2: return "Consume";
            case 4: return "Etc";
            case 3: return "Install";
            case 9: return "Special";
        }
        return "";
    }
    static void AddItem(string ID)
    {
        if (ID.LeftStr(2) != "01")
        {
            Wz_Node Entry = Wz.GetNode("Item/" + GetItemDir(ID) + '/' + ID.LeftStr(4) + ".img/" + ID);
            Equip.DataS.Add(ID + "/drop", "0");
            Wz.DumpData(Entry, Wz.EquipData, Wz.EquipImageLib);
        }
    }
    public static void Drop(int AX, int AY, int Num, List<string> DropList)
    {
        Value = Num / 2 + 1;
        Random Random = new();
        for (int I = 0; I <= Num; I++)
        {
            if (I < 0)
                Value = Value + 1;
            else
                Value = Value - 1;
            var ItemDrop = new ItemDrop(EngineFunc.SpriteEngine);

            int Rand = Random.Next(DropList.Count);
            if (!Equip.DataS.ContainsKey(DropList[Rand] + "/drop"))
                AddItem(DropList[Rand]);
            ItemDrop.ID = DropList[Rand];
            string Dir = GetItemDir(ItemDrop.ID);
            string IconPath = "Item/" + Dir + '/' + ItemDrop.ID.LeftStr(4) + ".img/" + ItemDrop.ID + "/info/iconRaw";
            if (ItemDrop.ID.LeftStr(4) != "0900")
                ItemDrop.ImageNode = Wz.EquipData[IconPath];
            ItemDrop.Angle = Random.Next(100) * 0.0628f;
            if (ItemDrop.ID.LeftStr(4) == "0900")
            {
                ItemDrop.ParentPath = "Item/Special/0900.img/" + ItemDrop.ID + "/iconRaw";
                IconPath = ItemDrop.ParentPath + "/0";
                ItemDrop.ImageNode = Wz.EquipData[IconPath];
            }
            ItemDrop.X = AX;
            ItemDrop.Y = AY;
            ItemDrop.Z = Game.Player.Z;
            ItemDrop.MoveX = Value * 0.5f;
            ItemDrop.Offset.X = -ItemDrop.ImageNode.GetVector("origin").X;
            ItemDrop.Offset.Y = -ItemDrop.ImageNode.GetVector("origin").Y + 5;
        }
    }

    public static void Drop(int AX, int AY, int Num, string ID)
    {
        Value = Num / 2 + 1;
        Random Random = new();
        for (int I = 0; I <= Num; I++)
        {
            if (I < 0)
                Value = Value + 1;
            else
                Value = Value - 1;
            var ItemDrop = new ItemDrop(EngineFunc.SpriteEngine);
            if (!Equip.DataS.ContainsKey(ID + "/drop"))
                AddItem(ID);
            string Dir = GetItemDir(ID);
            string IconPath = "Item/" + Dir + '/' + ID.LeftStr(4) + ".img/" + ID + "/info/iconRaw";
            ItemDrop.ID=ID;             
            if (ItemDrop.ID.LeftStr(4) != "0900")
                ItemDrop.ImageNode = Wz.EquipData[IconPath];
            ItemDrop.Angle = Random.Next(100) * 0.0628f;
            if (ItemDrop.ID.LeftStr(4) == "0900")
            {
                ItemDrop.ParentPath = "Item/Special/0900.img/" + ID + "/iconRaw";
                IconPath = ItemDrop.ParentPath + "/0";
                ItemDrop.ImageNode = Wz.EquipData[IconPath];
            }
            ItemDrop.X = AX;
            ItemDrop.Y = AY;
            ItemDrop.Z = Game.Player.Z;
            ItemDrop.MoveX = Value * 0.5f;
            ItemDrop.Offset.X = -ItemDrop.ImageNode.GetVector("origin").X;
            ItemDrop.Offset.Y = -ItemDrop.ImageNode.GetVector("origin").Y + 15;
        }
    }
    public override void DoMove(float Delta)
    {  
        base.DoMove(Delta);
        X += MoveX;
        if (JumpState != JumpState.jsNone)
            Angle += 0.5f;
        if (JumpState == JumpState.jsFalling)
        {
            Foothold BelowFH = null;
            Vector2 Below = FootholdTree.Instance.FindBelow(new Vector2(X, Y - VelocityY - 2), ref BelowFH);
            if (Y >= Below.Y - 10)
            {
                Y = Below.Y;
                JumpState = JumpState.jsNone;
                Angle=0;
                Offset.X = -12;
                FH = BelowFH;
                Z = FH.Z * 100000 + 6000;
            }
        }

        if (ID.LeftStr(4) == "0900")
        {
            ImageNode = Wz.EquipData[ParentPath + '/' + Frame];
            FTime += 17;
            if (FTime > 100)
            {
                Frame += 1;
                if (Frame > 3)
                    Frame = 0;
                FTime = 0;
            }
            Offset.X = -ImageNode.GetVector("origin").X;
            Offset.Y = -ImageNode.GetVector("origin").Y + 3;
        }

        if (JumpState == JumpState.jsNone)
        {
            MoveX = 0;
            CosY += 0.055f;
            Y = Y - (float)Math.Cos(CosY) * 0.15f;
        }

        TimeCount += 1;
        if (TimeCount > 1000)
            Alpha -= 7;
        if (Alpha < 10)
            Dead();
    }


}


```

`MapleNecrocer/Client/LadderRopes.cs`:

```cs
using Microsoft.Xna.Framework;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading.Tasks;

namespace MapleNecrocer;

public struct LadderRope
{
    public int X, Y1, Y2, Page, uf, L;
    public static List<LadderRope> LadderRopeList;
    public static LadderRope Find(Vector2 P, ref bool OnLadder)
    {
        OnLadder = false;
        foreach (var L in LadderRopeList)
        {
            if ((P.X > L.X - 10) && (P.X < L.X + 10) && (P.Y < L.Y2 + 12) && (P.Y > L.Y1 - 12))
            {
                OnLadder = true;
                return L;
            }
        }
        return new LadderRope();
    }

    public static void Create()
    {
        if (LadderRopeList == null)
            LadderRopeList = new();
        else
            LadderRopeList.Clear();
        LadderRope LadderRope = new ();
        foreach (var Iter in Map.Img.Nodes["ladderRope"].Nodes)
        {
            LadderRope.X = Iter.GetInt("x");
            LadderRope.Y1 = Iter.GetInt("y1");
            LadderRope.Y2 = Iter.GetInt("y2");
            LadderRope.L = Iter.GetInt("l");
            LadderRope.Page = Iter.GetInt("page");
            LadderRope.uf = Iter.GetInt("uf");
            LadderRopeList.Add(LadderRope);
        }
    }

}


```

`MapleNecrocer/Client/MapBack.cs`:

```cs
using WzComparerR2.WzLib;
using WzComparerR2.PluginBase;
using Spine;
using WzComparerR2.Animation;
using Microsoft.Xna.Framework;
using System.Drawing;
using Microsoft.Xna.Framework.Graphics;

namespace MapleNecrocer;

public class Back : BackgroundSprite
{
    public Back(Sprite Parent) : base(Parent)
    {
        BlendMode = MonoGame.SpriteEngine.BlendMode.NonPremultiplied;
    }
    string Path;
    int Frame;
    int RX, RY;
    Vector2 Pos;
    int BackType;
    float Time;
    bool Flip;
    bool Front;
    float AX, AY;
    int FlowX, FlowY;
    int MoveType;
    int MoveW, MoveH;
    int MoveP;
    int MoveR;
    float DeltaTime;
    bool HasAnim;
    public static bool ResetPos;

    public static void Create()
    {
        foreach (var Iter in Map.Img.GetNode("back").Nodes)
        {
            string bS = Iter.GetStr("bS");
            if (bS == "") continue;
            string No = Iter.GetStr("no");
            int Ani = Iter.GetInt("ani");
            int PosX = Iter.GetInt("x");
            int PosY = Iter.GetInt("y");
            int RX = Iter.GetInt("rx");
            int RY = Iter.GetInt("ry");
            int CX = Iter.GetInt("cx");
            int CY = Iter.GetInt("cy");
            int FlowX = Iter.GetInt("flowX");
            int FlowY = Iter.GetInt("flowY");
            int ZLayer = int.Parse(Iter.Text);
            bool Front = Iter.GetBool("front");
            int BackType = Iter.GetInt("type");
            string Path = "";
            bool Tiled = false;
            TileMode TileMode = TileMode.Horizontal;
            if (!Wz.HasNode("UI/UIWindow4.img"))
            {
                if (bS == "dryRock" && No == "1")
                    BackType = 1;
            }

            switch (BackType)
            {
                case 0:
                    Tiled = false;
                    break;
                case 1:
                    Tiled = true;
                    TileMode = TileMode.Horizontal;
                    break;
                case 2:
                    Tiled = true;
                    TileMode = TileMode.Vertical;
                    break;
                case 3:
                    Tiled = true;
                    TileMode = TileMode.Full;
                    break;
                case 4:
                    Tiled = true;
                    TileMode = TileMode.Horizontal;
                    break;
                case 5:
                    Tiled = true;
                    TileMode = TileMode.Vertical;
                    break;
                case 6:
                    Tiled = true;
                    TileMode = TileMode.Full;
                    break;
                case 7:
                    Tiled = true;
                    TileMode = TileMode.Full;
                    break;
            }

            if (Ani == 2)
            {
                Path = "Map/Back/" + bS + ".img/spine/" + No;
                var SpineBack = new SpineBack(EngineFunc.SpriteEngine);
                var aniData = Map.ResLoader.LoadAnimationData(Wz.GetNodeA(Path));

                if (((ISpineAnimationData)aniData).SpineVersion == SpineVersion.V2)
                {
                    SpineBack.SpineAnimatorV2 = new SpineAnimatorV2((SpineAnimationDataV2)aniData);
                    SpineBack.Version = 2;
                }
                else
                {
                    SpineBack.SpineAnimatorV4 = new SpineAnimatorV4((SpineAnimationDataV4)aniData);
                    SpineBack.Version = 4;
                }

                string spineAni = Iter.GetStr("spineAni");
                if (SpineBack.Version == 2)
                {
                    if (spineAni != "")
                        SpineBack.SpineAnimatorV2.SelectedAnimationName = spineAni;
                    else
                        SpineBack.SpineAnimatorV2.SelectedAnimationIndex = 0;
                }

                if (SpineBack.Version == 4)
                {
                    if (spineAni != "")
                        SpineBack.SpineAnimatorV4.SelectedAnimationName = spineAni;
                    else
                        SpineBack.SpineAnimatorV4.SelectedAnimationIndex = 0;
                }


                SpineBack.Pos.X = PosX;
                SpineBack.Pos.Y = PosY;
                SpineBack.RX = RX;
                SpineBack.RY = RY;
                Bitmap Png = null;
                if (Wz.GetNodeA(Path + "/0") != null)
                {
                    Png = Wz.GetNode(Path + "/0").ExtractPng();
                }
                else
                {
                    foreach (var i in Wz.GetNodeA(Path).Nodes)
                    {
                        if (i.Text.RightStr(3) == "png")
                        {
                            Png = i.ExtractPng();
                            break;
                        }
                    }
                }
                if (CX == 0)
                    SpineBack.Width = Png.Width;
                else
                    SpineBack.Width = CX;
                if (CY == 0)
                    SpineBack.Height = Png.Height;
                else
                    SpineBack.Height = CY;
                if (bS == "downtown" && No == "3")
                    SpineBack.Width = 800;

                SpineBack.BackType = BackType;
                SpineBack.Tiled = Tiled;
                SpineBack.TileMode = TileMode;
                float WX = EngineFunc.SpriteEngine.Camera.X;
                float WY = EngineFunc.SpriteEngine.Camera.Y;
                SpineBack.X = -PosX - (100f + RX) / 100f * (WX + Map.DisplaySize.X / 2) + WX;
                SpineBack.Y = -PosY - (100f + RY) / 100f * (WY + Map.DisplaySize.Y / 2) + WY;
                if (Front)
                    SpineBack.Z = ZLayer + 1000000;
                else
                    SpineBack.Z = ZLayer - 1000;
                SpineBack.SkeletonRenderer = new Spine.SkeletonRenderer(RenderFormDraw.Instance.GraphicsDevice);
            }
            else
            {
                var Back = new Back(EngineFunc.SpriteEngine);
                Back.ImageLib = Wz.ImageLib;
                Wz_Vector origin = new Wz_Vector(0, 0);
                string ImagePath = "";

                if (Ani == 0)
                {
                    Path = "Map/Back/" + bS + ".img/back/" + No;
                    ImagePath = Path;
                    if (Wz.GetNodeA(Path) == null)
                        continue;
                    if (!Wz.Data.ContainsKey(Path))
                        Wz.DumpData(Wz.GetNodeA(Path), Wz.Data, Wz.ImageLib);
                    Back.Path = Path;
                    Back.ImageNode = Wz.Data[Path];
                    origin = WzDict.GetVector(Path + "/origin");
                    if (WzDict.GetBool(Path + "/blend"))
                        Back.BlendMode = MonoGame.SpriteEngine.BlendMode.AddtiveColor;
                }

                if (Ani == 1)
                {
                    Path = "Map/Back/" + bS + ".img/ani/" + No;
                    ImagePath = Path + "/0";
                    if (Wz.GetNodeA(Path) == null)
                        continue;
                    if (!Wz.Data.ContainsKey(Path))
                        Wz.DumpData(Wz.GetNodeA(Path), Wz.Data, Wz.ImageLib);
                    Back.Path = Path;
                    Back.ImageNode = Wz.Data[Path + "/0"];
                    origin = WzDict.GetVector(Path + "/0/origin");
                    Back.HasAnim = true;
                }
                Back.FlipX = Iter.GetBool("f");
                if (Back.FlipX)
                    Back.Origin.X = -origin.X + Back.ImageWidth;
                else
                    Back.Origin.X = origin.X;
                Back.Origin.Y = origin.Y;
                Back.Width = Back.ImageWidth;
                Back.Height = Back.ImageHeight;
                Back.Pos.X = PosX;
                Back.Pos.Y = PosY;
                Back.RX = RX;
                Back.RY = RY;
                Back.FlowX = FlowX;
                Back.FlowY = FlowY;

                Back.MoveType = WzDict.GetInt(ImagePath + "/moveType");
                Back.MoveP = WzDict.GetInt(ImagePath + "/moveP");
                Back.MoveW = WzDict.GetInt(ImagePath + "/moveW");
                Back.MoveH = WzDict.GetInt(ImagePath + "/moveH");
                Back.MoveR = WzDict.GetInt(ImagePath + "/moveR");

                if (CX == 0)
                    Back.Width = Back.ImageWidth;
                else
                    Back.Width = CX;
                if (CY == 0)
                    Back.Height = Back.ImageHeight;
                else
                    Back.Height = CY;

                float WX = EngineFunc.SpriteEngine.Camera.X;
                float WY = EngineFunc.SpriteEngine.Camera.Y;
                Back.X = -PosX - (100f + RX) / 100f * (WX + Map.DisplaySize.X / 2) + WX;
                Back.Y = -PosY - (100f + RY) / 100f * (WY + Map.DisplaySize.Y / 2) + WY;

                if (Front)
                    Back.Z = ZLayer + 1000000;
                else
                    Back.Z = ZLayer - 1000;
                Back.Front = Front;
                Back.AX = Back.X;
                Back.AY = Back.Y;
                Back.BackType = BackType;
                Back.Tiled = Tiled;
                Back.TileMode = TileMode;
            }
        }
        ResetPos = true;
    }

    public override void DoMove(float Delta)
    {
        switch (BackType)
        {
            case 0:
            case 1:
            case 2:
            case 3:
                if (Map.CameraSpeed.X != 0)
                    X -= RX * Map.CameraSpeed.X / 100f;
                if (Map.CameraSpeed.Y != 0)
                    Y -= RY * Map.CameraSpeed.Y / 100f;
                break;

            case 4:
            case 6:
                if (Map.CameraSpeed.X != 0)
                    X += Map.CameraSpeed.X;
                if (Map.CameraSpeed.Y != 0)
                    Y -= RY * Map.CameraSpeed.Y / 100f;
                X -= RX * 5f / 60;
                break;

            case 5:
            case 7:
                if (Map.CameraSpeed.X != 0)
                    X -= RX * Map.CameraSpeed.X / 100f;
                if (Map.CameraSpeed.Y != 0)
                    Y += Map.CameraSpeed.Y;
                Y -= RY * 5f / 60f;
                break;
        }

        if (FlowX.ToBool())
        {
            X -= FlowX * 5f / 60;
        }
        if (FlowY.ToBool())
        {
            Y -= FlowY * 5f / 60;
        }


        if (MoveType.ToBool())
        {
            DeltaTime += 0.017f;
            switch (MoveType)
            {
                case 1:
                    if (MoveP.ToBool())
                        X = AX + MoveW * (float)Math.Cos(DeltaTime * 1000 * 2 * 3.14159f / MoveP);
                    else
                        X = AX + MoveW * (float)Math.Cos(DeltaTime);
                    break;
                case 2:
                    if (MoveP.ToBool())
                        Y = AY + MoveH * (float)Math.Cos(DeltaTime * 2 * 3.14159f * 1000 / MoveP);
                    else
                        Y = AY + MoveH * (float)Math.Cos(DeltaTime);
                    break;
                    // case 3:
                    //Angle += (17f / MoveR) * 3.14159f * 2;
                    //  break;
            }
        }

        if (MoveR.ToBool())
        {
            Angle += (17f / MoveR) * 3.14159f * 2;
        }
        if (HasAnim)
        {
            string ImagePath = Path + "/" + Frame;
            ImageNode = Wz.Data[ImagePath];
            int Delay = WzDict.GetInt(ImagePath + "/delay", 100);
            int a0 = WzDict.GetInt(ImagePath + "/a0", -1);
            int a1 = WzDict.GetInt(ImagePath + "/a1", -1);
            Time += 16.66f * Delta;
            if (Time > Delay)
            {
                Frame += 1;
                if (!Wz.HasData(Path + '/' + Frame))
                    Frame = 0;
                Time = 0;
            }
            if ((a0 != -1) && (a1 == -1))
                Alpha = (byte)WzDict.GetInt(ImagePath + "/a0", 255);
            float AniAlpha = a0 - (a0 - a1) * Time / Delay;
            if (Time > 0)
                Alpha = (byte)AniAlpha;

            Wz_Vector origin = WzDict.GetVector(ImagePath + "/origin");
            if (FlipX)
                Origin.X = -origin.X + ImageWidth;
            else
                Origin.X = origin.X;
            Origin.Y = origin.Y;
        }

        if (ResetPos)
        {
            X = -Pos.X - (100f + RX) / 100f * (Engine.Camera.X + Map.DisplaySize.X / 2) + Engine.Camera.X;
            Y = -Pos.Y - (100f + RY) / 100f * (Engine.Camera.Y + Map.DisplaySize.Y / 2 + Map.OffsetY) + Engine.Camera.Y;
        }

        if (Map.SaveMap)
        {
            X = -Pos.X - (100 + RX) / 100 * (Engine.Camera.X + 1366 / 2) + Engine.Camera.X;
            if (Front)
            {
                if (Map.Info.ContainsKey("VRLeft"))
                    Y = -Pos.Y - (100f + RY) / 100f * (Map.Bottom - 600 + (600 / 2)) + Map.Top;
                else
                    Y = -Pos.Y - (100f + RY) / 100f * (Map.SaveMapBottom - 600 + (600 / 2) - 100) + Map.Top;
            }
            else
            {
                if (Map.Info.ContainsKey("VRLeft"))
                    Y = -Pos.Y - (100f + RY * (float)Convert.ToDouble(SaveMapForm.Instance.comboBox2.Text)) / 100f *
                      (Map.Bottom - 600 + (600 / 2)) + Map.Top - SaveMapForm.Instance.comboBox1.Text.ToInt();
                else
                    Y = -Pos.Y - (100f + RY * (float)Convert.ToDouble(SaveMapForm.Instance.comboBox2.Text)) / 100 *
                      (Map.SaveMapBottom - 600 + (600 / 2) - 100) + Map.Top - SaveMapForm.Instance.comboBox1.Text.ToInt();
            }
        }

        if (Front)
        {
            if (Map.ShowFront)
                Visible = true;
            else
                Visible = false;
        }
        else
        {
            if (Map.ShowBack)
                Visible = true;
            else
                Visible = false;
        }

    }
    public override void DoDraw()
    {
        base.DoDraw();

        if (ResetPos)
            ResetPos = false;
    }


}

public class SpineBack : SpriteEx
{
    public SpineBack(Sprite Parent) : base(Parent)
    {
    }
    public Vector2 Pos;
    public int RX, RY;
    public int BackType;
    public TileMode TileMode;
    public bool Tiled;
    public Spine.SkeletonRenderer SkeletonRenderer;
    public SpineAnimatorV2 SpineAnimatorV2;
    public SpineAnimatorV4 SpineAnimatorV4;
    public int Version;
    private Matrix? matrix;
    public override void DoMove(float Delta)
    {
        X = -Pos.X - (100f + RX) / 100f * (Engine.Camera.X + Map.DisplaySize.X / 2) + Engine.Camera.X;
        Y = -Pos.Y - (100f + RY) / 100f * (Engine.Camera.Y + Map.DisplaySize.Y / 2 + Map.OffsetY) + Engine.Camera.Y;
        if (Z > 0)
        {
            if (Map.ShowFront)
                Visible = true;
            else
                Visible = false;
        }
        else
        {
            if (Map.ShowBack)
                Visible = true;
            else
                Visible = false;
        }
    }
    public override void Draw()
    {
        if (Visible)
        {
            if (Engine != null)
            {
                DoDraw();
                Engine.DrawCount++;
            }

            if (DrawList != null)
            {
                for (int i = 0; i < DrawList.Count; i++)
                    ((SpineBack)DrawList[i]).Draw();
            }
        }
    }
    public override void DoDraw()
    {
        int ChipWidth = this.Width;
        int ChipHeight = this.Height;
        int dWidth = (Engine.VisibleWidth + ChipWidth) / ChipWidth + 1;
        int dHeight = (Engine.VisibleHeight + ChipHeight) / ChipHeight + 1;
        float _x;
        float _y;
        _x = -X;
        _y = -Y;

        float OfsX = _x % ChipWidth;
        float OfsY = _y % ChipHeight;
        int StartX = (int)_x / ChipWidth;
        int StartX_ = 0;
        if (StartX < 0)
        {
            StartX_ = -StartX;
            StartX = 0;
        }
        int StartY = (int)_y / ChipHeight;
        int StartY_ = 0;
        if (StartY < 0)
        {
            StartY_ = -StartY;
            StartY = 0;
        }

        int EndX = Math.Min(StartX + 1 - StartX_, dWidth);
        int EndY = Math.Min(StartY + 1 - StartY_, dHeight);

        switch (TileMode)
        {
            case TileMode.Horizontal:
                dWidth = (Engine.VisibleWidth + ChipWidth) / ChipWidth + 1;
                dHeight = -1;
                break;
            case TileMode.Vertical:
                dWidth = -1;
                dHeight = (Engine.VisibleHeight + ChipHeight) / ChipHeight + 1;
                break;
            case TileMode.Full:
                dWidth = (Engine.VisibleWidth + ChipWidth) / ChipWidth + 1;
                dHeight = (Engine.VisibleHeight + ChipHeight) / ChipHeight + 1;
                break;
        }



        if (Version == 2)
        {
            SpineAnimatorV2.Update(TimeSpan.FromMilliseconds(17));
        }
        else if (Version == 4)
        {
            SpineAnimatorV4.Update(TimeSpan.FromMilliseconds(17));
        }
        if (SkeletonRenderer.Effect is BasicEffect basicEff)
        {
            basicEff.World = matrix ?? Matrix.Identity;
            basicEff.Projection = Matrix.CreateOrthographicOffCenter(0, Map.DisplaySize.X, Map.DisplaySize.Y, 0, 1, 0);
        }

        SkeletonRenderer.Begin();
        if (Tiled)
        {
            for (int cy = -1; cy <= dHeight; cy++)
            {
                for (int cx = -1; cx <= dWidth; cx++)
                {
                    switch (TileMode)
                    {
                        case TileMode.Horizontal:
                            if (Version == 2)
                            {
                                SpineAnimatorV2.Skeleton.X = cx * ChipWidth + OfsX - Offset.X;
                                SpineAnimatorV2.Skeleton.Y = _y - Offset.Y;
                            }
                            else if (Version == 4)
                            {
                                SpineAnimatorV4.Skeleton.X = cx * ChipWidth + OfsX - Offset.X;
                                SpineAnimatorV4.Skeleton.Y = _y - Offset.Y;
                            }
                            break;

                        case TileMode.Vertical:
                            if (Version == 2)
                            {
                                SpineAnimatorV2.Skeleton.X = _x - Offset.X;
                                SpineAnimatorV2.Skeleton.Y = cy * ChipHeight + OfsY - Offset.Y;
                            }
                            else if (Version == 4)
                            {
                                SpineAnimatorV4.Skeleton.X = _x - Offset.X;
                                SpineAnimatorV4.Skeleton.Y = cy * ChipHeight + OfsY - Offset.Y;

                            }
                            break;

                        case TileMode.Full:
                            if (Version == 2)
                            {
                                SpineAnimatorV2.Skeleton.X = cx * ChipWidth + OfsX - Offset.X;
                                SpineAnimatorV2.Skeleton.Y = cy * ChipHeight + OfsY - Offset.Y;
                            }
                            if (Version == 4)
                            {
                                SpineAnimatorV4.Skeleton.X = cx * ChipWidth + OfsX - Offset.X;
                                SpineAnimatorV4.Skeleton.Y = cy * ChipHeight + OfsY - Offset.Y;
                            }
                            break;
                    }

                    if (Version == 2)
                    {
                        SkeletonRenderer.Draw(SpineAnimatorV2.Skeleton);
                    }
                    else if (Version == 4)
                    {
                        SkeletonRenderer.Draw(SpineAnimatorV4.Skeleton);
                    }

                }
            }
        }
        else
        {
            for (int cy = StartY; cy < EndY; cy++)
            {
                for (int cx = StartX; cx < EndX; cx++)
                {
                    if (Version == 2)
                    {
                        SpineAnimatorV2.Skeleton.X = cx * ChipWidth + OfsX - Offset.X;
                        SpineAnimatorV2.Skeleton.Y = cy * ChipHeight + OfsY - Offset.Y;
                        SkeletonRenderer.Draw(SpineAnimatorV2.Skeleton);
                    }
                    else if (Version == 4)
                    {
                        SpineAnimatorV4.Skeleton.X = cx * ChipWidth + OfsX - Offset.X;
                        SpineAnimatorV4.Skeleton.Y = cy * ChipHeight + OfsY - Offset.Y;
                        SkeletonRenderer.Draw(SpineAnimatorV4.Skeleton);
                    }
                }
            }
        }
        SkeletonRenderer.End();

    }
}





```

`MapleNecrocer/Client/MapObj.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Numerics;
using System.Text;
using System.Threading.Tasks;
using System.Xml.Linq;
using WzComparerR2.WzLib;
using WzComparerR2.PluginBase;
using Spine;
using WzComparerR2.Animation;
using System.IO;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework;

namespace MapleNecrocer;
public class Obj : SpriteEx
{
    public Obj(Sprite Parent) : base(Parent)
    {
        IntMove = true;
    }
    string Path;
    float DeltaTime;
    int Frame;
    float Time;
    // Vector2 origin;
    float AX, AY;
    int MoveType;
    int MoveW, MoveH;
    int MoveP;
    int MoveR;

    public static void Create()
    {
        for (int Layer = 0; Layer <= 7; Layer++)
        {
            foreach (var Iter in Map.Img.GetNode(Layer.ToString() + "/obj").Nodes)
            {
                string oS = Iter.GetStr("oS");
                if (Wz.GetNode("Map/Obj/" + oS + ".img") == null)
                    continue;
                string L0 = Iter.GetStr("l0");
                string L1 = Iter.GetStr("l1");
                string L2 = Iter.GetStr("l2");
                string Path = "Map/Obj/" + oS + ".img/" + L0 + "/" + L1 + "/" + L2;
                if (!Wz.Data.ContainsKey(Path))
                    Wz.DumpData(Wz.GetNodeA(Path), Wz.Data, Wz.ImageLib);
                int Flow = Iter.GetInt("flow");
                // if (!Wz.ImageLib.ContainsKey(Wz.Data[Path + "/0"]))
                //  continue;
                if (Iter.Nodes["spineAni"] != null)
                {
                    var SpineObj = new SpineObj(EngineFunc.SpriteEngine);
                    var aniData = Map.ResLoader.LoadAnimationData(Wz.GetNodeA(Path));
                    if (((ISpineAnimationData)aniData).SpineVersion == SpineVersion.V2)
                    {
                        SpineObj.SpineAnimatorV2 = new SpineAnimatorV2((SpineAnimationDataV2)aniData);
                        SpineObj.Version = 2;
                    }
                    else
                    {
                        SpineObj.SpineAnimatorV4 = new SpineAnimatorV4((SpineAnimationDataV4)aniData);
                        SpineObj.Version = 4;
                    }

                    string spineAni = Iter.GetStr("spineAni");
                    if (spineAni != null)
                    {
                        if (SpineObj.Version == 2)
                            SpineObj.SpineAnimatorV2.SelectedAnimationName = spineAni;
                        else
                            SpineObj.SpineAnimatorV4.SelectedAnimationName = spineAni;
                    }

                    SpineObj.X = Iter.GetInt("x");
                    SpineObj.Y = Iter.GetInt("y");
                    SpineObj.Z = Layer * 100000 + Iter.GetInt("z");
                    SpineObj.Width = 1024;
                    SpineObj.Height = 1024;
                    SpineObj.Origin.X = 512;
                    SpineObj.Origin.Y = 512;
                    SpineObj.SkeletonRenderer = new Spine.SkeletonRenderer(RenderFormDraw.Instance.GraphicsDevice);
                }
                else
                {
                    if (Flow == 0)
                    {
                        var Obj = new Obj(EngineFunc.SpriteEngine);
                        Obj.ImageLib = Wz.ImageLib;
                        Obj.Path = Path;
                        Obj.ImageNode = Wz.Data[Path + "/0"];
                        Obj.X = Iter.GetInt("x");
                        Obj.Y = Iter.GetInt("y");
                        Obj.Z = Layer * 100000 + Iter.GetInt("z");
                        Obj.AX = Obj.X;
                        Obj.AY = Obj.Y;
                        Obj.Width = Obj.ImageWidth;
                        Obj.Height = Obj.ImageHeight;
                        Obj.FlipX = Iter.GetBool("f");
                        Obj.MoveType = WzDict.GetInt(Path + "/0/moveType");
                        Obj.MoveP = WzDict.GetInt(Path + "/0/moveP");
                        Obj.MoveW = WzDict.GetInt(Path + "/0/moveW");
                        Obj.MoveH = WzDict.GetInt(Path + "/0/moveH");
                        Obj.MoveR = WzDict.GetInt(Path + "/0/moveR");
                        if (!Wz.HasData(Path + "/1"))
                            Obj.Moved = false;
                        if (Obj.MoveType > 0)
                            Obj.Moved = true;
                        if (Obj.MoveR > 0)
                            Obj.Moved = true;

                        Wz_Vector origin = WzDict.GetVector(Path + "/0/origin");
                        if (Obj.FlipX)
                            Obj.Origin.X = -origin.X + Obj.ImageWidth;
                        else
                            Obj.Origin.X = origin.X;
                        Obj.Origin.Y = origin.Y;
                        //Obj.IntMove=true;
                    }

                    if (Flow > 0)
                    {
                        var FlowObj = new FlowObj(EngineFunc.SpriteEngine);
                        FlowObj.ImageLib = Wz.ImageLib;
                        FlowObj.Path = Path;
                        FlowObj.ImageNode = Wz.Data[Path + "/0"];
                        FlowObj.MoveByEngine = true;
                        FlowObj.X = Iter.GetInt("x");
                        FlowObj.Y = Iter.GetInt("y");
                        FlowObj.Z = Layer * 1000 + Iter.GetInt("z");
                        FlowObj.Width = FlowObj.ImageWidth;
                        FlowObj.Height = FlowObj.ImageHeight;
                        FlowObj.FlipX = Iter.GetBool("f");
                        FlowObj.RX = Iter.GetInt("rx");
                        FlowObj.RY = Iter.GetInt("ry");
                        FlowObj.CX = Iter.GetInt("cx");
                        FlowObj.CY = Iter.GetInt("cy");

                        if (FlowObj.CX == 0)
                            FlowObj.Width = Map.Info["MapWidth"];
                        else
                            FlowObj.Width = FlowObj.CX;

                        if (FlowObj.CY == 0)
                            FlowObj.Height = Map.Info["MapHeight"];
                        else
                            FlowObj.Height = FlowObj.CY;

                        FlowObj.Flow = Flow;
                        FlowObj.Tiled = true;
                        if (Flow == 1)
                            FlowObj.TileMode = TileMode.Horizontal;
                        if (Flow == 2)
                            FlowObj.TileMode = TileMode.Vertical;
                        Wz_Vector origin = WzDict.GetVector(Path + "/0/origin");
                        if (FlowObj.FlipX)
                            FlowObj.Origin.X = -origin.X + FlowObj.ImageWidth;
                        else
                            FlowObj.Origin.X = origin.X;
                        FlowObj.Origin.Y = origin.Y;
                    }

                }
            }
        }
    }

    public override void DoMove(float Delta)
    {
        base.DoMove(Delta);
        string ImagePath = Path + "/" + Frame;
        ImageNode = Wz.Data[ImagePath];
        int Delay = WzDict.GetInt(ImagePath + "/delay", 100);
        int a0 = WzDict.GetInt(ImagePath + "/a0", -1);
        int a1 = WzDict.GetInt(ImagePath + "/a1", -1);


        Time += 16.66f * Delta;
        if (Time > Delay)
        {
            Frame += 1;
            if (!Wz.HasData(Path + '/' + Frame))
                Frame = 0;
            Time = 0;
        }
        if ((a0 != -1) && (a1 == -1))
            Alpha = (byte)WzDict.GetInt(ImagePath + "/a0", 255);
        float AniAlpha = a0 - (a0 - a1) * Time / Delay;
        if (Time > 0)
            Alpha = (byte)AniAlpha;


        if (MoveType.ToBool())
        {
            DeltaTime += 0.017f;
            switch (MoveType)
            {
                case 1:
                    if (MoveP.ToBool())
                        X = AX + MoveW * (float)Math.Cos(DeltaTime * 1000 * 2 * 3.14159f / MoveP);
                    else
                        X = AX + MoveW * (float)Math.Cos(DeltaTime);
                    break;
                case 2:
                    if (MoveP.ToBool())
                        Y = AY + MoveH * (float)Math.Cos(DeltaTime * 2 * 3.14159f * 1000 / MoveP);
                    else
                        Y = AY + MoveH * (float)Math.Cos(DeltaTime);
                    break;

                case 3:
                    if (MoveP.ToBool())
                    {
                        X = AX + MoveW * (float)Math.Cos(DeltaTime * 1000 * 2 * 3.14159f / MoveP);
                        Y = AY + MoveH * (float)Math.Cos(DeltaTime * 2 * 3.14159f * 1000 / MoveP);
                    }
                    else
                    {
                        X = AX + MoveW * (float)Math.Cos(DeltaTime);
                        Y = AY + MoveH * (float)Math.Cos(DeltaTime);
                    }
                    break;
            }
        }

        Wz_Vector origin = WzDict.GetVector(ImagePath + "/origin");
        if (FlipX)
            Origin.X = -origin.X + ImageWidth;
        else
            Origin.X = origin.X;
        Origin.Y = origin.Y;

        if (MoveR.ToBool())
        {
            Angle += (17f / MoveR) * 3.14159f * 2;
        }
    }
    public override void DoDraw()
    {
        if (Map.ShowObj)
            base.DoDraw();
    }

}

public class SpineObj : SpriteEx
{
    public SpineObj(Sprite Parent) : base(Parent)
    {
    }
    public Spine.SkeletonRenderer SkeletonRenderer;
    public SpineAnimatorV2 SpineAnimatorV2;
    public SpineAnimatorV4 SpineAnimatorV4;
    public int Version;
    private Matrix? matrix;
    public override void DoDraw()
    {
        if (!Map.ShowObj)
            return;
        
        if (Version == 2)
        {
            SpineAnimatorV2.Update(TimeSpan.FromMilliseconds(17));
        }
        else
        {
            SpineAnimatorV4.Update(TimeSpan.FromMilliseconds(17));
        }

        if (SkeletonRenderer.Effect is BasicEffect basicEff)
        {
            basicEff.World = matrix ?? Matrix.Identity;
            basicEff.Projection = Matrix.CreateOrthographicOffCenter(0, Map.DisplaySize.X, Map.DisplaySize.Y, 0, 1, 0);
        }

        SkeletonRenderer.Begin();

        if (Version == 2)
        {
            SpineAnimatorV2.Skeleton.X = -Engine.Camera.X + X;
            SpineAnimatorV2.Skeleton.Y = -Engine.Camera.Y + Y;
            SkeletonRenderer.Draw(SpineAnimatorV2.Skeleton);
        }
        else
        {
            SpineAnimatorV4.Skeleton.X = -Engine.Camera.X + X;
            SpineAnimatorV4.Skeleton.Y = -Engine.Camera.Y + Y;
            SkeletonRenderer.Draw(SpineAnimatorV4.Skeleton);
        }
        SkeletonRenderer.End();
    }
   
}

public class FlowObj : BackgroundSprite
{
    public FlowObj(Sprite Parent) : base(Parent)
    {
    }
    public string Path = "";
    public int Frame;
    public float Time;
    public int RX, RY;
    public int CX, CY;
    public int Flow;
    public override void DoMove(float Delta)
    {
        // base.DoMove(Delta);
        switch (Flow)
        {
            case 1:
                X -= RX * 5f / 60;
                break;
            case 2:
                Y -= RY * 5f / 60;
                break;
        }
        string ImagePath = Path + "/" + Frame;
        ImageNode = Wz.Data[ImagePath];
        int Delay = WzDict.GetInt(ImagePath + "/delay", 100);

        Time += 16.66f * Delta;
        if (Time > Delay)
        {
            Frame += 1;
            if (!Wz.HasData(Path + '/' + Frame))
                Frame = 0;
            Time = 0;
        }

        Wz_Vector origin = WzDict.GetVector(ImagePath + "/origin");
        if (FlipX)
            Origin.X = -origin.X + ImageWidth;
        else
            Origin.X = origin.X;
        Origin.Y = origin.Y;
    }

    public override void DoDraw()
    {
        if (Map.ShowObj)
            base.DoDraw();
    }
}

```

`MapleNecrocer/Client/MapParticle.cs`:

```cs
using WzComparerR2.WzLib;
using WzComparerR2.PluginBase;
using Spine;
using WzComparerR2.Animation;
using Microsoft.Xna.Framework;
using WzComparerR2.MapRender2;
namespace MapleNecrocer;

public class Particle : SpriteEx
{
    int RX, RY;
    Vector2 Pos;
    public static bool ResetPos;
    public ParticleRender ParticleRender;
    public Particle(Sprite Parent) : base(Parent)
    {
    }

    public static void Create()
    {
     
        if (Map.Img.Nodes["particle"] == null)
            return;
        foreach (var Iter in Map.Img.Nodes["particle"].Nodes)
        {
            var Particle = new Particle(EngineFunc.SpriteEngine);
            Particle.ParticleRender = new ParticleRender();
            Particle.ParticleRender.ParticleData = new ParticleData(RenderFormDraw.Instance.Editor.services.GetService<IRandom>());
            Particle.ParticleRender.batcher = new WzComparerR2.MapRender2.MeshBatcher(RenderFormDraw.Instance.GraphicsDevice) { CullingEnabled = true };
            Particle.ParticleRender.renderEnv = new RenderEnv(RenderFormDraw.Instance.GraphicsDevice);
            Particle.ParticleRender.ParticleData.LoadParticleData1(Iter, Map.ResLoader);
            int Z = 0;
            if (Iter.Nodes["rx"] != null)
            {
                Particle.RX = Iter.GetInt("rx");
                Particle.RY = Iter.GetInt("ry");
                Z = Iter.GetInt("z");
            }
            else if (Iter.GetNode("0/rx") != null)
            {
                Particle.RX = Iter.GetInt("0/rx");
                Particle.RY = Iter.GetInt("0/ry");
                if (Particle.RX == 0)
                    Particle.RX = -100;
                if (Particle.RY == 0)
                    Particle.RY = -100;
                Z = Iter.GetInt("0/z");
            }
            else
            {
                Particle.RX = -100;
                Particle.RY = -100;
            }
            // if (Z < 0)
            //  Z = 1000000 - 400000;
            // if (Z == 0)
            Z = 10000000;

            Particle.Z = Z;
        }
        ResetPos = true;
    }

    public override void DoMove(float Delta)
    {
        if (Map.CameraSpeed.X != 0)
            X += RX * Map.CameraSpeed.X / 100f;
        if (Map.CameraSpeed.Y != 0)
            Y += RY * Map.CameraSpeed.Y / 100f;

        if (ResetPos)
        {
            X = (100f + RX) / 100f * (Engine.Camera.X + Map.DisplaySize.X / 2) - Engine.Camera.X;
            Y = (100f + RY) / 100f * (Engine.Camera.Y + Map.DisplaySize.Y / 2 + Map.OffsetY) - Engine.Camera.Y;
        }
    }
    public override void DoDraw()
    {
        if (ParticleRender != null)
        {
            ParticleRender.Update1(TimeSpan.FromMilliseconds(17));
            ParticleRender.DrawParticle1(X, Y);
        }
        if (ResetPos) ResetPos = false;
    }

    public override void Draw()
    {
        if (Visible)
        {
            if (Engine != null)
            {
                DoDraw();
                Engine.DrawCount++;
            }

            if (DrawList != null)
            {
                for (int i = 0; i < DrawList.Count; i++)
                    ((Particle)DrawList[i]).Draw();
            }
        }
    }
    public override void Free()
    {
        base.Free();
        if (ParticleRender != null)
        {
            ParticleRender.ParticleData = null;
            ParticleRender.batcher.Dispose();
            ParticleRender.renderEnv.Dispose();
            ParticleRender = null;
        }
    }

}
```

`MapleNecrocer/Client/MapPortal.cs`:

```cs
using Microsoft.Xna.Framework;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Xml.Linq;
using WzComparerR2.Common;
using WzComparerR2.WzLib;

namespace MapleNecrocer;

public struct PortalInfo
{
    public string PortalName, ToName, ToMap;
    public int X, Y, PortalType;
}
public class MapPortal : SpriteEx
{
    public MapPortal(Sprite Parent) : base(Parent)
    {

    }
    float Time;
    int Frame;
    string InfoPath;
    string PortalName;
    int PortalType;
    string ToName;
    int ToMap;
    public static List<PortalInfo> PortalList = new();
    public static PortalInfo PortalInfo;
    public static void Create()
    {
        if (PortalList == null)
            PortalList = new();
        else
            PortalList.Clear();
        Wz_Node Node = null;
        if (Wz.GetNode("Map/MapHelper.img/portal/game/pv/default") == null)
            Node = Wz.GetNode("Map/MapHelper.img/portal/game/pv");
        else
            Node = Wz.GetNode("Map/MapHelper.img/portal/game/pv/default");
        Wz.DumpData(Node, Wz.Data, Wz.ImageLib);

        PortalInfo = new PortalInfo();
        int PType;
        foreach (var Iter in Map.Img.Nodes["portal"].Nodes)
        {
            PType = Iter.GetInt("pt");
            PortalInfo.X = Iter.GetInt("x");
            PortalInfo.Y = Iter.GetInt("y");
            PortalInfo.ToMap = Iter.GetInt("tm").ToString();
            PortalInfo.ToName = Iter.GetStr("tn");
            PortalInfo.PortalName = Iter.GetStr("pn");
            PortalInfo.PortalType = Iter.GetInt("pt");
            PortalList.Add(PortalInfo);
            if (PType == 2)
            {
                var MapPortal = new MapPortal(EngineFunc.SpriteEngine);
                MapPortal.ImageLib = Wz.ImageLib;
                MapPortal.InfoPath = Node.FullPathToFile2();
                MapPortal.ImageNode = Wz.Data[MapPortal.InfoPath + "/0"];
                MapPortal.X = Iter.GetInt("x");
                MapPortal.Y = Iter.GetInt("y");
                MapPortal.Z = 1000000;
                MapPortal.PortalName = Iter.GetStr("pn");
                MapPortal.ToMap = Iter.GetInt("tm");
                MapPortal.ToName = Iter.GetStr("tn");
                MapPortal.Width = MapPortal.ImageWidth;
                MapPortal.Height = MapPortal.ImageHeight + 100;
                //MapPortal.IntMove= false;
            }
        }
    }
    public static PortalInfo Find(Vector2 P, ref bool OnPortal)
    {
        OnPortal = false;
        foreach (var Portal in PortalList)
        {
            if ((P.X > Portal.X - 15) && (P.X < Portal.X + 15) && (P.Y < Portal.Y + 12) && (P.Y > Portal.Y - 12))
            {
                OnPortal = true;
                return Portal;
            }
        }
        return new PortalInfo();
    }
    public override void DoMove(float Delta)
    {

        base.DoMove(Delta);
        ImageNode = Wz.Data[InfoPath + "/" + Frame];
        string ImagePath = InfoPath + "/" + Frame;
        Time += 16.66f;
        if (Time > 100)
        {
            Frame += 1;
            if (!Wz.HasData(InfoPath + '/' + Frame))
                Frame = 0;
            Time = 0;
        }
        Wz_Vector origin = WzDict.GetVector(ImagePath + "/origin");
        Origin.X = origin.X;
        Origin.Y = origin.Y;
    }

    public override void DoDraw()
    {
        if (Map.ShowPortal)
            base.DoDraw();

        if (Map.ShowPortalInfo)
        {
            int WX = (int)X - (int)Engine.Camera.X;
            int WY = (int)Y - (int)Engine.Camera.Y;
                                      
            Engine.Canvas.DrawString(Map.ToolTipFont, "pn (Name)  : " + PortalName, WX - 50, WY - 170, Microsoft.Xna.Framework.Color.Red);
            Engine.Canvas.DrawString(Map.ToolTipFont, "tm (ToMap) : " + ToMap.ToString().PadLeft(9,'0'), WX - 50, WY - 150, Microsoft.Xna.Framework.Color.Red);
            Engine.Canvas.DrawString(Map.ToolTipFont, "tn (ToName): " + ToName, WX - 50, WY - 130, Microsoft.Xna.Framework.Color.Red);
        }
    }



}


```

`MapleNecrocer/Client/MapTile.cs`:

```cs
using System.IO;
using WzComparerR2.WzLib;

namespace MapleNecrocer;
public class MapTile : SpriteEx
{
    public MapTile(Sprite Parent) : base(Parent)
    {
        IntMove = true;
    }

    public static void Create()
    {
        for (int Layer = 0; Layer <= 7; Layer++)
        {
            string tS = Map.Img.GetNode(Layer.ToString() + "/info").GetValue2("tS", "");

            foreach (var Iter in Map.Img.GetNode(Layer.ToString() + "/tile").Nodes)
            {
                string u = Iter.GetValue2("u", "");
                string no = Iter.GetValue2("no", "");
                string Path = "Map/Tile/" + tS + ".img/" + u + "/" + no;
                if (!Wz.Data.ContainsKey(Path))
                {
                    Wz.DumpData(Wz.GetNodeA(Path), Wz.Data, Wz.ImageLib);
                }
                var MapTile = new MapTile(EngineFunc.SpriteEngine);
                MapTile.ImageLib = Wz.ImageLib;
                MapTile.ImageNode = Wz.Data[Path];
                MapTile.Moved = false;
                MapTile.X = Iter.GetValue2("x", 0);
                MapTile.Y = Iter.GetValue2("y", 0);
                MapTile.Z = (Layer * 100000) + WzDict.GetInt(Path + "/z") + 1000;
                MapTile.Width = MapTile.ImageWidth;
                MapTile.Height = MapTile.ImageHeight;
                MapTile.Origin = WzDict.GetVector(Path + "/origin");
               
            }
        }
    }
    public override void DoDraw()
    {
        if (Map.ShowTile)
            base.DoDraw();
    }

}

```

`MapleNecrocer/Client/MapleChair.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Xna.Framework;
using WzComparerR2.Text;
using WzComparerR2.WzLib;
namespace MapleNecrocer;

public class MapleChair : SpriteEx
{
    public MapleChair(Sprite Parent) : base(Parent)
    {
    }
    string Path;
    int Frame;
    int FTime;
    int Delay;
    Wz_Vector origin = new(0, 0);
    public static bool CanUse;
    public static bool IsUse;
    public static bool HasSitAction;
    public static bool UseTamingNavel;
    public static Wz_Vector BodyRelMove = new(0, 0);
    public static string CharacterAction;

    public static void Create(string ID)
    {
        // BodyRelMove.X = 0;
        // BodyRelMove.Y = 0;
        BodyRelMove = new(0, 0);
        HasSitAction = false;
        UseTamingNavel = false;

        Wz_Node Entry = null;
        if (Wz.GetNode("Item/Install/0301.img") != null)
        {
            Entry = Wz.GetNode("Item/Install/0301.img");
        }
        else
        {
            if (ID.LeftStr(4) == "0302")
            {
                Entry = Wz.GetNode("Item/Install/0302.img");
            }
            else
            {
                switch (ID[4])
                {
                    case '0':
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '6':
                    case '7':
                    case '8':
                    case '9':
                        Entry = Wz.GetNode("Item/Install/0301" + ID[4] + ".img");
                        break;
                    case '5':
                        if (Char.IsNumber(ID[5]))
                            Entry = Wz.GetNode("Item/Install/03015" + ID[5] + ".img");
                        break;
                }
            }
        }

        if (Wz.HasNode("Item/Cash/0520.img/" + ID))
        {
            Entry = Wz.GetNode("Item/Cash/0520.img");
        }

        CharacterAction = "sit";
        if (Entry.HasNode(ID + "/info/tamingMob"))
        {
            string TamingMobID = null;
            if (Entry.HasNode(ID + "/info/tamingMob/0"))
                TamingMobID = Entry.GetInt(ID + "/info/tamingMob/0").ToString();
            else
                TamingMobID = Entry.GetInt(ID + "/info/tamingMob").ToString();


            if (Wz.GetNode("Character/TamingMob/" + "0" + TamingMobID + ".img/sit/0") != null)
            {

                if (Wz.GetNode("Character/TamingMob/" + "0" + TamingMobID + ".img/sit/0/0") != null)
                    if (Wz.GetNode("Character/TamingMob/" + "0" + TamingMobID + ".img/sit/0/0").ExtractPng().Width == 4)
                        UseTamingNavel = true;
                TamingMob.IsChairTaming = true;

                TamingMob.Create("0" + TamingMobID);
                if (Wz.GetNode("Character/TamingMob/" + "0" + TamingMobID + ".img/characterAction/sit") != null)
                {
                    HasSitAction = true;
                    CharacterAction = Wz.GetNode("Character/TamingMob/" + "0" + TamingMobID + ".img/characterAction/sit").ToStr();
                }
                else
                {
                    CharacterAction = "sit";
                }
            }
        }

        if ((Entry.GetNode(ID + "/effect") == null) && (Entry.GetNode(ID + "/effect2") == null))
            return;

        if (Entry.GetNode(ID + "/effect/0") != null)
            if (Entry.GetNode(ID + "/info/customChair/randomChairInfo/0") == null)
                if ((Entry.GetNode(ID + "/effect/0").ExtractPng().Width == 1) && (Entry.GetNode(ID + "/effect/0/_inlink") == null) &&
                  (Entry.GetNode(ID + "/effect/0/_outlink") == null))
                    if ((Entry.GetNode(ID + "/effect/1") == null) && (Entry.GetNode(ID + "/effect2") == null))
                        return;

        Wz.DumpData(Entry.GetNode(ID), Wz.EquipData, Wz.EquipImageLib);

        if (Entry.HasNode(ID + "/info/bodyRelMove"))
        {
            BodyRelMove = Entry.GetNode(ID + "/info/bodyRelMove").ToVector();
        }

        if (Entry.HasNode(ID + "/info/sitAction"))
        {
            HasSitAction = true;
            CharacterAction = Entry.GetNode(ID + "/info/sitAction").ToStr();
        }
        else
        {
            CharacterAction = "sit";
        }
        bool HasSitEmotion;
        if (Entry.HasNode(ID + "/info/SitEmotion"))
            HasSitEmotion = true;

        Wz_Node Entry2;
        if (Entry.HasNode(ID + "/info/customChair/randomChairInfo/0"))
            Entry2 = Entry.GetNode(ID + "/info/customChair/randomChairInfo/0");
        else
            Entry2 = Entry.GetNode(ID);


        foreach (var Iter in Entry2.Nodes)
        {
            if (Iter.Text.Length < 6) continue;
            if (Iter.Text.LeftStr(6) == "effect" || Iter.Text.RightStr(6) == "effect")
            {
                if (Iter.GetNode("0") == null)
                    continue;

                var MapleChair = new MapleChair(EngineFunc.SpriteEngine);
                MapleChair.ImageLib = Wz.EquipImageLib;
                MapleChair.Path = Iter.FullPathToFile2();
                MapleChair.ImageNode = Wz.EquipData[MapleChair.Path + "/0"];
                Foothold BelowFH = null;
                Vector2 Below = FootholdTree.Instance.FindBelow(new Vector2(Game.Player.X, Game.Player.Y - 50), ref BelowFH);
                MapleChair.FlipX = Game.Player.FlipX;
                MapleChair.IntMove = true;

                int BodyRelMoveX;
                if (MapleChair.FlipX)
                    BodyRelMoveX = -(int)BodyRelMove.X;
                else
                    BodyRelMoveX = (int)BodyRelMove.X;

                int Pos = Iter.GetInt("pos", -1);
                switch (Pos)
                {
                    case -1: //no pos data
                        if (HasSitAction)
                        {
                            MapleChair.X = Game.Player.X;
                            MapleChair.Y = Below.Y;
                        }
                        else
                        {
                            MapleChair.X = Game.Player.X + BodyRelMoveX;
                            MapleChair.Y = Below.Y + BodyRelMove.Y;
                        }
                        break;
                    case 0:
                        UseTamingNavel = true;
                        if (HasSitAction)
                        {
                            MapleChair.X = Game.Player.X;
                            MapleChair.Y = Below.Y;
                        }
                        else
                        {
                            MapleChair.X = Game.Player.X + BodyRelMoveX;
                            MapleChair.Y = Below.Y + BodyRelMove.Y;
                        }
                        break;
                    case 1:
                        if (HasSitAction)
                        {

                            UseTamingNavel = false;
                            MapleChair.X = Game.Player.X;
                            MapleChair.Y = Below.Y;
                        }
                        else
                        {
                            MapleChair.X = Game.Player.X + BodyRelMoveX;
                            MapleChair.Y = Below.Y - 50 + BodyRelMove.Y;
                        }
                        break;
                    case 2:
                    case 3:
                        UseTamingNavel = false;
                        MapleChair.X = Game.Player.X;
                        MapleChair.Y = Below.Y;
                        break;
                }

                if (Entry.HasNode(ID + "/info/customChair/randomChairInfo/0"))
                {
                    MapleChair.X = Game.Player.X;
                    MapleChair.Y = Below.Y;
                }

                if (Iter.HasNode("z"))
                {
                    if (Iter.GetNode("z").Value is int)
                        MapleChair.Z = Game.Player.Z + Iter.Get("z").ToInt();
                    else
                    {
                        if (AvatarParts.ZMap.Contains(Iter.Get("z").ToStr()))
                            MapleChair.Z = Game.Player.Z + AvatarParts.ZMap.IndexOf(Iter.Get("z").ToStr());
                        else
                            MapleChair.Z = Game.Player.Z - 1;
                    }
                }
                else
                    MapleChair.Z = Game.Player.Z - 1;

            }
        }
    }

    public static void Remove()
    {
        MapleChair.IsUse = false;
        foreach (var Iter in EngineFunc.SpriteEngine.SpriteList)
        {
            if (Iter is MapleChair)
            {
                Iter.Dead();
                var s = Iter;
                s = null;
            }
        }
        EngineFunc.SpriteEngine.Dead();
        foreach (var Iter in Wz.EquipImageLib.Keys)
        {
            if (Iter.FullPathToFile2().LeftStr(17) == "Item/Install/0301")
            {
                Wz.EquipImageLib.Remove(Iter);
                Wz.EquipData.Remove(Iter.FullPathToFile2());
            }
        }

        foreach (var Iter in Wz.EquipImageLib.Keys)
        {
            if (Iter.FullPathToFile2().LeftStr(24) == "Character/TamingMob/0198")
            {
                Wz.EquipImageLib.Remove(Iter);
                Wz.EquipData.Remove(Iter.FullPathToFile2());
            }
        }
        //  BodyRelMove.X = 0;
        //  BodyRelMove.Y = 0;
    }

    public override void DoMove(float Delta)
    {
        base.DoMove(Delta);
        ImageNode = Wz.EquipData[Path + "/" + Frame];
        Delay = ImageNode.GetInt("delay", 100);
        FTime += 17;
        if (FTime > Delay)
        {
            Frame += 1;
            if (!Wz.EquipData.ContainsKey(Path + "/" + Frame))
                Frame = 0;
            FTime = 0;
        }
        if (ImageNode.HasNode("origin"))
            origin = ImageNode.GetVector("origin");


        if (UseTamingNavel)
        {
            switch (FlipX)
            {
                case true:
                    Offset.X = origin.X - ImageWidth - TamingMob.Navel.X;
                    break;
                case false:
                    Offset.X = -origin.X - TamingMob.Navel.X;
                    break;
            }
            Offset.Y = -origin.Y - TamingMob.Navel.Y;
        }
        else
        {
            switch (FlipX)
            {
                case true:
                    Offset.X = origin.X - ImageWidth;
                    break;
                case false:
                    Offset.X = -origin.X;
                    break;
            }
            Offset.Y = -origin.Y;
        }

    }
}


```

`MapleNecrocer/Client/MapleCharacter.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Reflection.Metadata.Ecma335;
using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using MonoGame.SpriteEngine;
using WzComparerR2.Common;
using WzComparerR2.WzLib;
using static System.Windows.Forms.VisualStyles.VisualStyleElement.Tab;
using Keyboard = SpriteEngine.Keyboard;
using Input = Microsoft.Xna.Framework.Input.Keys;
using Microsoft.Xna.Framework.Input;
using Spine;
using static MapleNecrocer.Map;
using WzComparerR2.CharaSim;
using WzComparerR2.Animation;
using DevComponents.DotNetBar;
using WzComparerR2.Text;
using System.ComponentModel;

namespace MapleNecrocer;

public enum FaceDir { Left, Right, None }
public enum LadderType { Ladder, Rope }
public enum PartName { Head, Body, Cap, Face, Hair, Glove, FaceAcc, Glass, EarRing, Cape, Coat, Longcoat, Pants, Shield, Shoes, Weapon, CashWeapon, Chairs, SitTamingMob, WalkTamingMob, TamingMob }


public class Game
{
    public static Player Player;
    public static int Damage;

}
public class Equip
{
    public static string GetDir(string ID)
    {
        switch (Int32.Parse(ID) / 10000)
        {
            case 0: case 1: return ""; break;
            case 2: case 5: return "Face/"; break;
            case 3: case 4: case 6: return "Hair/";
            case 101: case 102: case 103: return "Accessory/";
            case 100: return "Cap/";
            case 110: return "Cape/";
            case 104: return "Coat/";
            case 105: return "Longcoat/";
            case 106: return "Pants/";
            case 107: return "Shoes/";
            case 108: return "Glove/";
            case 109: return "Shield/";
            case 170: case int i when i >= 121 && i <= 160: return "Weapon/";
            case int i when i >= 190 && i <= 199: return "TamingMob/";
        }
        return "";
    }
    public static PartName GetPart(string ID)
    {
        switch (Int32.Parse(ID) / 10000)
        {
            case 0: return PartName.Body;
            case 1: return PartName.Head;
            case 2: case 5: return PartName.Face;
            case 3: case 4: case 6: return PartName.Hair;
            case 101: return PartName.FaceAcc;
            case 102: return PartName.Glass;
            case 103: return PartName.EarRing;
            case 100: return PartName.Cap;
            case 110: return PartName.Cape;
            case 104: return PartName.Coat;
            case 105: return PartName.Longcoat;
            case 106: return PartName.Pants;
            case 107: return PartName.Shoes;
            case 108: return PartName.Glove;
            case 109: return PartName.Shield;
            case int i when i >= 121 && i <= 160: return PartName.Weapon;
            case 170: return PartName.CashWeapon;
            case int i when i >= 190 && i <= 197: case 199: return PartName.WalkTamingMob;
            case 198: return PartName.SitTamingMob;
        }
        return PartName.Body;
    }
    public static string GetAfterImageStr(string ID)
    {
        int AID = ID.ToInt();
        int Num = (AID / 10000) - 100;
        switch (Num)
        {
            case 22: case 23: case 26: case 28: case 30: case 31: case 33: case 34: case 47: return "swordOL";
            case 36: return "cane";
            case 21: case 25: case 32: case 37: case 38: case 55: case 69: return "mace";
            case 24: case 27: return "swordOS";
            case 39: case 40: return "swordTS";
            case 41: case 42: return "axe";
            case 43: return "spear";
            case 44: return "poleArm";
            case 45: return "bow";
            case 46: return "crossBow";
            case 48: case 58: return "knuckle";
            case 49: return "gun";
            case 52: return "dualBow";
            case 53: return "cannon";
            case 54: return "swordTK";
            case 56: return "swordZB";
            case 57: return "swordZL";
            case 59: return "ancientBow";
        }
        return "";
    }
    public static string GetWeaponNum(string ID)
    {
        int AID = ID.ToInt();
        return ((AID / 10000) - 100).ToString();
    }
    public static Dictionary<string, int> Data = new();
    public static Dictionary<string, string> DataS = new();
}


public class Player : JumperSprite
{
    public Player(Sprite Parent) : base(Parent)
    {
        SpriteSheetMode = SpriteSheetMode.NoneSingle;
        Z = 20000;
        Offset.Y = -79;
        Offset.X = -40;
        JumpSpeed = 0.6f;
        JumpHeight = 9.5f;
        MaxFallSpeed = 8;
        Alpha = 0;
        Tag = 1;
        JumpState = JumpState.jsFalling;
        StandType = "stand1";
        WalkType = "walk1";

        // IntMove = true;
    }
    static bool Loaded;
    public static void SpawnNew()
    {

        AvatarTargetTexture = new RenderTarget2D(EngineFunc.Canvas.GraphicsDevice, 1024, 1024, false, SurfaceFormat.Color, DepthFormat.None);
        EngineFunc.Canvas.GraphicsDevice.SetRenderTarget(AvatarTargetTexture);
        EngineFunc.Canvas.GraphicsDevice.Clear(Microsoft.Xna.Framework.Color.Transparent);
        EngineFunc.Canvas.GraphicsDevice.SetRenderTarget(null);

        Game.Player = new Player(EngineFunc.SpriteEngine);
        Game.Player.AvatarEngine = new MonoSpriteEngine(null);
        Game.Player.AvatarEngine.Canvas = EngineFunc.Canvas;
        Game.Player.AvatarEngine.Camera.X = 21 - 400;
        Game.Player.AvatarEngine.Camera.Y = 20 - 400;

        int PX = 0, PY = 0;
        foreach (var Portals in MapPortal.PortalList)
        {
            if (Portals.PortalType == 0)
            {
                PX = Portals.X;
                PY = Portals.Y;
                break;
            }
        }
        Game.Player.X = PX;
        Game.Player.Y = PY;
        Foothold BelowFH = null;
        Vector2 Below = FootholdTree.Instance.FindBelow(new Vector2(PX, PY - 2), ref BelowFH);
        Game.Player.FH = BelowFH;
        Game.Player.FaceDir = FaceDir.None;
        Game.Player.JumpState = JumpState.jsFalling;

        foreach (var Iter in Wz.GetNodeA("Base/zmap.img").Nodes)
            AvatarParts.ZMap.Add(Iter.Text);
        for (int I = 2000; I <= 2011; I++)
        {
            Equip.DataS.Add("0000" + I.ToString() + "/swingTF/0/arm", "swingTF");
            Equip.DataS.Add("0000" + I.ToString() + "/swingT2/0/arm", "swingT2");
            Equip.DataS.Add("0000" + I.ToString() + "/swingOF/0/arm", "swingOF/0");
            Equip.DataS.Add("0000" + I.ToString() + "/swingOF/1/arm", "swingOF/1");
            Equip.DataS.Add("0000" + I.ToString() + "/swingOF/2/arm", "swingOF/2");
        }


        string[] DefaultEqps = { "01302000", "00002000", "01060002", "01070000", "01040005", "00020000", "00030020", "00012000" };
        for (int I = 0; I <= 7; I++)
        {
            Game.Player.CreateEquip(DefaultEqps[I], Game.Player.AvatarEngine);
            Player.EqpList.Add(DefaultEqps[I]);
        }
        Wz.DumpData(Wz.GetNodeA("Character/00002001.img"), Wz.EquipData, Wz.EquipImageLib);

        Game.Player.AttackAction = Game.Player.AttackActions[0];
        AfterImage.Load(Game.Player.AfterImageStr, "0");
        DamageNumber.Style = "NoRed1";
        DamageNumber.Load("");

        Loaded = true;
    }


    public static List<string> EqpList = new();
    MonoSpriteEngine AvatarEngine;
    public Foothold FH;
    public bool InLadder;
    bool OnLadder;
    bool FallFlag;
    int FallCounter, OffY;
    bool OnPortal;
    public FaceDir FaceDir;
    float SpeedL, SpeedR;
    float CurrentX;
    public string Action;
    string PlayerName;
    int NameWidth;
    public bool Attack;
    bool SkillDone;
    int NameTagTargetIndex;
    PortalInfo CurrentPortal;
    PortalInfo Portal;
    public LadderType LadderType;
    public string StandType, WalkType;
    List<AvatarParts> PartSpriteList = new();
    public bool ShowHair;
    public bool DressCap;
    public int CapType;
    public string EarType = "humanEar";
    public string WeaponNum;
    public bool ResetAction;
    public string NewAction;
    public string AfterImageStr;
    public string AttackAction, Str;
    List<string> AttackActions = new();
    List<string> AttackOFs = new();
    bool Flip;
    public bool OtherPlayer = false;

    public float MoveX, MoveY;

    public int NewZ;
    static RenderTarget2D AvatarTargetTexture;
    //static Texture2D AvatarTargetTexture;
    static int AvatarPanelIndex;
    static List<string> EquipDumpList = new();
    public static int _NewZ;
    private static float DestX, DestY;

    private static List<string> SameNames = new();
    public Vector2 Neck, Navel, Hand, Brow, HandMove;
    public Vector2 ArmHand, ArmNavel, BodyNeck, BodyNavel, BodyHand, lHandMove, HeadBrow, HeadNeck;
    public Vector2 BrowPos, TamingNavel;


    public void Spawn(string EquipID)
    {
        CreateEquip(EquipID, AvatarEngine);
    }

    public void CreateEquip(string EquipID, MonoSpriteEngine UseEngine)
    {
        string Dir = Equip.GetDir(EquipID);
        PartName Part = Equip.GetPart(EquipID);
        Wz_Node Img = Wz.GetNodeA("Character/" + Dir + EquipID + ".img");
        string Path;
       
        if (!EquipDumpList.Contains(EquipID))
        {
            Wz.DumpData(Img, Wz.EquipData, Wz.EquipImageLib);
            EquipDumpList.Add(EquipID);
        }

        string LPath = "Character/Weapon/";
        switch (Part)
        {

            case PartName.Weapon:
                AfterImageStr = Equip.GetAfterImageStr(EquipID);
                AfterImage.Load(AfterImageStr, "0");
                WeaponNum = Equip.GetWeaponNum(EquipID);
                AttackActions.Clear();
                AttackOFs.Clear();
                if (Wz.HasDataE(LPath + EquipID + ".img/stand1"))
                    StandType = "stand1";
                else if (Wz.HasDataE(LPath + EquipID + ".img/stand2"))
                    StandType = "stand2";
                if (Wz.HasDataE(LPath + EquipID + ".img/walk1"))
                    WalkType = "walk1";
                else if (Wz.HasDataE(LPath + EquipID + ".img/walk2"))
                    WalkType = "walk2";
                break;

            case PartName.Cap:
                DressCap = true;
                string VSlot = Wz.GetNodeA("Character/Cap/" + EquipID + ".img/info/vslot").ToStr();
                //no Cover
                if ((VSlot == "Cp") || (VSlot == "CpH5"))
                    CapType = 0;
                //stand cover
                if (VSlot == "CpH1H5")
                    CapType = 1;
                //cover all
                if (VSlot.Length > 12)
                {
                    if (VSlot.LeftStr(6) == "CpH1H3")
                        CapType = 2;
                    else
                        CapType = 3;
                }
                break;

            case PartName.Hair:
                ShowHair = true;
                break;

            case PartName.CashWeapon:
                for (int i = 69; i >= 30; i--)
                {
                    if (Wz.HasDataE(LPath + EquipID + ".img/" + i.ToString() + "/stand1"))
                        StandType = "stand1";
                    else if (Wz.HasDataE(LPath + EquipID + ".img/" + i.ToString() + "/stand2"))
                        StandType = "stand2";
                    if (Wz.HasDataE(LPath + EquipID + ".img/" + i.ToString() + "/walk1"))
                        WalkType = "walk1";
                    else if (Wz.HasDataE(LPath + EquipID + ".img/" + i.ToString() + "/walk2"))
                        WalkType = "walk2";
                    if (Wz.HasDataE(LPath + EquipID + ".img/" + i.ToString()))
                        WeaponNum = i.ToString();
                }
                AttackActions.Clear();
                AttackOFs.Clear();
                AfterImageStr = Equip.GetAfterImageStr("01" + WeaponNum + "1234");
                foreach (var Iter in Wz.GetNode("Character/Afterimage/" + AfterImageStr + ".img/0").Nodes)
                {
                    if ((Iter.Text.LeftStr(4) == "stab") || (Iter.Text.LeftStr(5) == "swing"))
                    {
                        if ((Iter.Text.RightStr(2) != "D1") && (Iter.Text.RightStr(2) != "D2"))
                        {
                            if (Iter.Text.RightStr(1) != "F")
                                AttackActions.Add(Iter.Text);
                            else
                                AttackOFs.Add(Iter.Text);
                        }
                    }
                }
                AfterImage.Load(AfterImageStr, "0");
                Img = Wz.GetNodeA("Character/" + Dir + EquipID + ".img/" + WeaponNum);
                break;
        }

        AvatarParts Sprite;
        SameNames.Clear();
        if (Loaded)
        {
            if (Img == Wz.GetNodeA("Character/00002000.img"))
                Img = Wz.GetNodeA("Character/00002001.img");
        }

        foreach (var Iter in Img.Nodes)
        {

            switch (Part)
            {
                case PartName.Weapon:
                    if (Iter.Text != "info")
                    {
                        if ((Iter.Text.LeftStr(4) == "stab") || (Iter.Text.LeftStr(5) == "swing"))
                        {
                            if (Iter.Text.RightStr(1) != "F")
                                AttackActions.Add(Iter.Text);
                            else
                                AttackOFs.Add(Iter.Text);
                        }
                    }
                    break;
                case PartName.Body:

                    Equip.Data.AddOrReplace("body/" + Iter.Text + "/FrameCount", Iter.Nodes.Count - 1);
                    break;
                case PartName.Face:
                    Equip.Data.AddOrReplace("face/" + Iter.Text + "/FrameCount", Iter.Nodes.Count - 1);
                    break;
            }
            foreach (var Iter2 in Iter.Nodes)
            {
                if (Part == PartName.Body)
                    Equip.Data.AddOrReplace("body/" + Iter.Text + "/" + Iter2.Text + "/delay", Math.Abs(Iter2.GetInt("delay")));
                if (Part == PartName.Face)
                    Equip.Data.AddOrReplace("face/" + Iter.Text + "/" + Iter2.Text + "/delay", Iter2.GetInt("delay"));
                if ((Iter2.Nodes["action"] != null) && (Iter2.Nodes["frame"] != null))
                    Equip.DataS.AddOrReplace(Iter.Text + "/" + Iter2.Text, Iter2.GetStr("action") + "/" + Iter2.GetInt("frame"));
                if (Iter2.Text == "hairShade")
                    continue;

                foreach (var Iter3 in Iter2.Nodes)
                {
                    if ((Iter3.Text == "hairShade") || (Iter3.Text == "006"))
                        continue;
                    if (Iter3.Value is Wz_Png || Iter3.Value is Wz_Uol)
                    {
                        if (!SameNames.Contains(Iter3.Text))
                        {
                            SameNames.Add(Iter3.Text);
                            if (OtherPlayer)
                                Sprite = new AvatarPartEx(UseEngine);
                            else
                                Sprite = new AvatarParts(UseEngine);

                            if (OtherPlayer)
                            {
                                Sprite.Visible = true;
                            }
                            else
                            {
                                if ((MapleChair.IsUse) || (TamingMob.IsUse))
                                {
                                    if ((Part == PartName.CashWeapon) || (Part == PartName.Weapon))
                                        Sprite.Visible = false;
                                    else
                                        Sprite.Visible = true;

                                }
                                else
                                {
                                    Sprite.Visible = false;
                                }
                            }

                            Sprite.Owner = this;
                            Sprite.ImageLib = Wz.EquipImageLib;
                            Path = Iter3.FullPathToFile2();

                            if (EquipID.LeftStr(4) == "0000")
                            {
                                for (int i = 0; i < 9; i++)
                                    Path = Path.Replace("0000200" + i, EquipID);
                            }
                            if (Wz.EquipData.ContainsKey(Path))
                                Sprite.ImageNode = Wz.EquipData[Path];
                            //Sprite.IntMove= true;
                            Sprite.Tag = 1;
                            Sprite.Value = 1;
                            Sprite.State = "stand1";
                            Sprite.FlipX = this.FlipX;
                            Sprite.Expression = "blink";
                            Sprite.Animate = true;
                            Sprite.AnimRepeat = true;

                            string[] S = Path.Split('/');

                            if (Part != PartName.CashWeapon)
                            {
                                // Body,head
                                if (S[1].LeftStr(1) == "0")
                                {
                                    Sprite.ID = S[1].LeftStr(8);
                                    Sprite.Image = S[4];
                                }
                                else
                                {
                                    Sprite.ID = S[2].LeftStr(8);
                                    Sprite.Image = S[5];
                                }
                            }
                            else
                            {
                                Sprite.ID = S[2].LeftStr(8);
                                Sprite.Image = S[6];
                            }

                            PartSpriteList.Add(Sprite);

                        }
                    }
                }
            }
        }
        ResetAction = true;
        if (OtherPlayer)
            NewAction = StandType;
        else
        {
            if ((MapleChair.IsUse) || (TamingMob.IsUse))
                NewAction = "sit";
            else
                NewAction = StandType;
        }
        if (InLadder)
        {
            switch (LadderType)
            {
                case LadderType.Ladder:
                    NewAction = "ladder"; break;
                case LadderType.Rope:
                    NewAction = "rope"; break;
            }
        }

    }

    public void RemoveSprites()
    {
        foreach (var Iter in PartSpriteList)
        {
            Iter.Dead();
        }
        EngineFunc.SpriteEngine.Dead();
        PartSpriteList.Clear();
    }
    public override void DoMove(float Delta)
    {
        base.DoMove(Delta);
        Keyboard.GetState();
        if (Map.GameMode == GameMode.Viewer)
            return;
        EngineFunc.Canvas.GraphicsDevice.SetRenderTarget(AvatarTargetTexture);
        EngineFunc.Canvas.GraphicsDevice.Clear(Microsoft.Xna.Framework.Color.Transparent);
        RenderTargetFunc();
        EngineFunc.Canvas.GraphicsDevice.SetRenderTarget(null);
        int X1 = FH.X1;
        int Y1 = FH.Y1;
        int X2 = FH.X2;
        int Y2 = FH.Y2;
        if (Keyboard.KeyDown(Input.LeftAlt) && !InLadder && !Attack)
        {
            DoJump = true;
        }

        LadderRope LadderRope = LadderRope.Find(new Vector2(X, Y + OffY), ref OnLadder);
        Vector2 Below = new();
        Foothold BelowFH = null, WallFH = null;
        if (Keyboard.KeyDown(Input.Up))
        {
            OffY = -3;
            if (OnLadder)
            {
                FaceDir = FaceDir.None;
                InLadder = true;
                JumpState = JumpState.jsNone;
                X = LadderRope.X;
                Y -= 1.5f;
            }
            if ((InLadder) && (Y < LadderRope.Y1))
            {
                if (LadderRope.uf == 0)
                    Y = LadderRope.Y1;
                if (LadderRope.uf == 1)
                {
                    Below = FootholdTree.Instance.FindBelow(new Vector2(X, Y - 5), ref BelowFH);
                    Y = Below.Y;
                    FH = BelowFH;
                    Z = FH.Z * 100000 + 60000;
                    InLadder = false;
                    FaceDir = FaceDir.None;
                }
            }
        }

        if (Keyboard.KeyDown(Input.Down) && JumpState == JumpState.jsNone)
        {
            OffY = 0;
            if (OnLadder)
            {
                FaceDir = FaceDir.None;
                InLadder = true;
                JumpState = JumpState.jsNone;
                X = LadderRope.X;
                Y += 1.5f;
            }
            if ((Y > LadderRope.Y2) && (InLadder))
            {
                InLadder = false;
                JumpState = JumpState.jsFalling;

            }
        }
        if (InLadder)
            Z = LadderRope.Page * 100000 + 60000;

        switch (LadderRope.L)
        {
            case 0: LadderType = LadderType.Rope; break;
            case 1: LadderType = LadderType.Ladder; break;
        }

        Portal = MapPortal.Find(new Vector2(X, Y), ref OnPortal);
        if (Keyboard.KeyDown(Input.Up) && (JumpState == JumpState.jsNone) && (OnPortal) && (!Map.FadeScreen.DoFade))
        {
            if (Portal.ToMap != "999999999")
            {
                if ((Portal.PortalType == 2) || (Portal.PortalType == 1))
                {
                    Sound.Play("Sound/Game.img/Portal");
                    CurrentX = X;
                    CurrentPortal = Portal;
                    Map.FadeScreen.DoFade = true;
                    Map.FadeScreen.AlphaCounter = 5;
                    Map.FadeScreen.AValue = 5;
                }
            }
        }

        if (Map.FadeScreen.DoFade)
        {
            JumpState = JumpState.jsNone;
            Map.FadeScreen.AlphaCounter += Map.FadeScreen.AValue;
            if (Map.FadeScreen.AValue == 5)
                X = CurrentX;
            if (Map.FadeScreen.AlphaCounter == 255)
            {

                Map.ID = Portal.ToMap.PadLeft(9, '0');
                if (Map.ID != "")
                    Map.ReLoad = true;
                Map.FadeScreen.AValue = -6;
            }

            if (Map.FadeScreen.AlphaCounter == 249)
            {
                foreach (var NextPortal in MapPortal.PortalList)
                {
                    if (NextPortal.ToMap + CurrentPortal.ToName == NextPortal.ToMap + NextPortal.PortalName)
                    {
                        int PX = NextPortal.X;
                        int PY = NextPortal.Y;
                        Below = FootholdTree.Instance.FindBelow(new Vector2(PX, PY - 5), ref BelowFH);
                        FH = BelowFH;
                        X = PX;
                        Y = PY - 2;
                        if (Pet.Instance != null)
                        {
                            Pet.Instance.X = Game.Player.X;
                            Pet.Instance.Y = Game.Player.Y;
                            Pet.Instance.JumpState = JumpState.jsFalling;
                        }

                        if (Familiar.Instance != null)
                        {
                            Familiar.Instance.X = X;
                            Familiar.Instance.Y = Y - 50;
                            Familiar.Instance.JumpState = JumpState.jsFalling;
                        }

                        if (AndroidPlayer.Instance != null)
                        {
                            AndroidPlayer.Instance.X = Game.Player.X;
                            AndroidPlayer.Instance.Y = Game.Player.Y;
                            AndroidPlayer.Instance.JumpState = JumpState.jsFalling;
                        }


                        Z = FH.Z * 100000 + 60000;
                        EngineFunc.SpriteEngine.Camera.X = PX - DisplaySize.X / 2;
                        EngineFunc.SpriteEngine.Camera.Y = PY - (DisplaySize.Y / 2) - 100;
                        if (EngineFunc.SpriteEngine.Camera.X > Map.Right)
                            EngineFunc.SpriteEngine.Camera.X = Map.Right;
                        if (EngineFunc.SpriteEngine.Camera.X < Map.Left)
                            EngineFunc.SpriteEngine.Camera.X = Map.Left;
                        if (EngineFunc.SpriteEngine.Camera.Y > Map.Bottom)
                            EngineFunc.SpriteEngine.Camera.Y = Map.Bottom;
                        if (EngineFunc.SpriteEngine.Camera.Y < Map.Top)
                            EngineFunc.SpriteEngine.Camera.Y = Map.Top;

                        // Reset := True;
                        break;
                    }
                }
            }
        }

        if (Map.FadeScreen.AlphaCounter <= 2)
            Map.FadeScreen.DoFade = false;
        // Alt + left
        if ((Keyboard.KeyDown(Input.LeftAlt)) && (Keyboard.KeyDown(Input.Left)) && (InLadder))
            DoJump = true;
        // Alt +right
        if ((Keyboard.KeyDown(Input.LeftAlt)) && (Keyboard.KeyDown(Input.Right)) && (InLadder))
            DoJump = true;
        if (JumpState == JumpState.jsJumping)
            InLadder = false;
        // left
        if ((Keyboard.KeyDown(Input.Left)) && (SpeedR == 0))
        {
            FaceDir = FaceDir.Left;
            if (JumpState != JumpState.jsFalling)
            {
                SpeedL += +1.5f;
                if (SpeedL > 2.5f)
                    SpeedL = 2.5f;
            }
        }
        else
        {
            SpeedL -= 0.25f;
            if (SpeedL < 0)
                SpeedL = 0;
        }
        // right
        if ((Keyboard.KeyDown(Input.Right)) && (SpeedL == 0))
        {
            FaceDir = FaceDir.Right;
            if (JumpState != JumpState.jsFalling)
            {
                SpeedR += 1.5f;
                if (SpeedR > 2.5f)
                    SpeedR = 2.5f;
            }
        }
        else
        {
            SpeedR -= 0.25f;
            if (SpeedR < 0)
                SpeedR = 0;
        }

        DestX = DisplaySize.X / 2 - X + Engine.Camera.X;
        if (Math.Abs(DestX) > 1)
            Engine.Camera.X -= DestX * (12f / 800f);

        DestY = (DisplaySize.Y / 2) + (Map.OffsetY + 60) - Y;
        if (Math.Abs(DestY + Engine.Camera.Y) > 1)
            Engine.Camera.Y -= 0.01f * (DestY + Engine.Camera.Y);

        if (Engine.Camera.X < Map.Left)
            Engine.Camera.X = Map.Left;
        if (Engine.Camera.X > Map.Right - DisplaySize.X)
            Engine.Camera.X = Map.Right - DisplaySize.X;
        if (Engine.Camera.Y < Map.Top)
            Engine.Camera.Y = Map.Top;
        if (Engine.Camera.Y > Map.Bottom - DisplaySize.Y)
            Engine.Camera.Y = Map.Bottom - DisplaySize.Y;

        if (Map.Right - Map.Left < DisplaySize.X)
            Engine.Camera.X = Map.Left - ((DisplaySize.X - Map.Info["MapWidth"]) / 2);

        int FallEdge;
        int Direction;
        if ((FaceDir == FaceDir.Left) && (SpeedR == 0) && (!InLadder))
        {
            if ((OnPortal) && (Map.FadeScreen.AValue == 5))
                return;
            if ((Keyboard.KeyDown(Input.LeftAlt)) && (!Attack))
                DoJump = true;
            if ((X < Map.Left + 20) || (Attack) && (JumpState == JumpState.jsNone))
                SpeedL = 0;

            if (!TamingMob.IsUse)
            {
                if ((Action == "prone") || (Action == "proneStab") || (!Skill.PlayEnded))
                    SpeedL = 0;
            }


            Direction = GetAngle256(X2, Y2, X1, Y1);
            if (!FH.IsWall())
            {
                X += (float)(Sin256(Direction) * SpeedL);
                Y -= (float)(Cos256(Direction) * SpeedL);
            }
            FallEdge = -999999;
            if (FH.Prev == null)
                FallEdge = FH.X1 - 10;

            // Wall down
            if ((FH.Prev != null) && (FH.Prev.IsWall()) && (FH.Prev.Y1 > Y))
                FallEdge = FH.X1;
            if ((JumpState == JumpState.jsNone) && (X < FallEdge))
                JumpState = JumpState.jsFalling;
            Below = FootholdTree.Instance.FindBelow(new Vector2(X + 10, Y - 5), ref BelowFH);
            WallFH = FootholdTree.Instance.FindWallR(new Vector2(X + 4, Y - 4));
            if ((WallFH != null) && (X <= WallFH.X1) && (BelowFH.Z == WallFH.Z))
            {
                X = WallFH.X1 + 1;
                SpeedL = 0;
            }
            // walk left
            if ((X <= FH.X1) && (FH.PrevID != 0) && (!FH.IsWall()) && (!FH.Prev.IsWall()))
            {
                if (JumpState == JumpState.jsNone)
                {
                    FH = FH.Prev;
                    X = FH.X2;
                    Y = FH.Y2;
                    Z = FH.Z * 100000 + 60000;
                }
            }
        }

        // walk right
        if ((FaceDir == FaceDir.Right) && (SpeedL == 0) && (!InLadder))
        {
            if ((OnPortal) && (Map.FadeScreen.AValue == 5))
                return;
            if (Keyboard.KeyDown(Input.LeftAlt) && (!Attack))
                DoJump = true;
            if ((X > Map.Right - 20) || (Attack) && (JumpState == JumpState.jsNone))
                SpeedR = 0;

            if (!TamingMob.IsUse)
            {
                if ((Action == "prone") || (Action == "proneStab") || (!Skill.PlayEnded))
                    SpeedR = 0;
            }

            Direction = GetAngle256(X1, Y1, X2, Y2);
            if (!FH.IsWall())
            {
                X += (float)(Sin256(Direction) * SpeedR);
                Y -= (float)(Cos256(Direction) * SpeedR);
            }

            FallEdge = 999999;
            if (FH.Next == null)
                FallEdge = FH.X2 + 5;
            // Wall down
            if ((FH.Next != null) && (FH.Next.IsWall()) && (FH.Next.Y2 > Y))
                FallEdge = FH.X2;

            if ((JumpState == JumpState.jsNone) && (X > FallEdge))
                JumpState = JumpState.jsFalling;
            Below = FootholdTree.Instance.FindBelow(new Vector2(X - 10, Y - 5), ref BelowFH);
            WallFH = FootholdTree.Instance.FindWallL(new Vector2(X - 4, Y - 4));
            if ((WallFH != null) && (X >= WallFH.X1) && (BelowFH.Z == WallFH.Z))
            {
                X = WallFH.X1 - 1;
                SpeedR = 0;
            }
            // walk right
            if ((X >= FH.X2) && (FH.NextID != 0) && (!FH.IsWall()) && (!FH.Next.IsWall()))
            {
                if (JumpState == JumpState.jsNone)
                {
                    FH = FH.Next;
                    X = FH.X1;
                    Y = FH.Y1;
                    Z = FH.Z * 100000 + 60000;
                }
            }
        }

        if ((JumpState == JumpState.jsFalling) && (FallFlag))
        {
            Below = FootholdTree.Instance.FindBelow(new Vector2(X, Y - VelocityY - 6), ref BelowFH);
            if (Y >= Below.Y - 3)
            {
                Y = Below.Y;
                MaxFallSpeed = 10;
                JumpState = JumpState.jsNone;
                FH = BelowFH;
                Z = FH.Z * 100000 + 60000;
            }
        }

        if (Keyboard.KeyDown(Input.LeftAlt))
        {
            if ((Keyboard.KeyDown(Input.Down)) && (JumpState == JumpState.jsNone) && (!InLadder))
            {
                FallFlag = false;
                Below = FootholdTree.Instance.FindBelow(new Vector2(X, Y + 4), ref BelowFH);
                if (BelowFH.X2 > BelowFH.X1)
                {
                    if (Below.Y != 99999)
                    {
                        // Y := Y + 6;
                        JumpState = JumpState.jsFalling;
                    }
                }
            }
        }

        if (!FallFlag)
            FallCounter += 1;
        if (FallCounter > VelocityY + 3)
        {
            FallFlag = true;
            FallCounter = 0;
        }
        if (JumpState == JumpState.jsJumping)
        {
            Below = FootholdTree.Instance.FindBelow(new Vector2(X, Y - 10), ref BelowFH);
            if (BelowFH.X2 < BelowFH.X1)
                JumpState = JumpState.jsFalling;
        }

    }

    public override void DoDraw()
    {
        if (!OtherPlayer)
        {
            if (Keyboard.KeyDown(Input.LeftControl))
            {
                Random Random = new();
                switch (Random.Next(10))
                {
                    case int i when i >= 0 && i <= 8:
                        AttackAction = AttackActions[Random.Next(AttackActions.Count)];
                        break;
                    case 9:
                        if (AttackOFs.Count > 0)
                            AttackAction = AttackOFs[Random.Next(AttackOFs.Count)];
                        else
                            AttackAction = AttackActions[Random.Next(AttackActions.Count)];
                        break;
                }
            }

            int WX = (int)MoveX - (int)Engine.Camera.X;
            int WY = (int)MoveY - (int)Engine.Camera.Y;
            Engine.Canvas.Draw(AvatarTargetTexture, WX - 180 - 400, WY - 180 - 400,MonoGame.SpriteEngine.BlendMode.NonPremultiplied2);
        }
    }

    void RenderTargetFunc()
    {
        if (!OtherPlayer)
        {
            AvatarEngine.Draw();
            AvatarEngine.Move(1);
            AvatarEngine.Dead();
        }

    }

}

public class AvatarParts : SpriteEx
{
    public AvatarParts(Sprite Parent) : base(Parent)
    {
        SpriteSheetMode = SpriteSheetMode.NoneSingle;


    }
    int Time;
    int FaceTime;
    float AnimDelay;
    public int Value;
    public string State;
    public string Expression;
    public bool Animate;
    public bool AnimRepeat;
    public string ID;
    public string Image;
    public Player Owner;
    string WpNum;
    int Frame;
    bool DoFaceAnim;
    int FaceCount;
    int AlertCount;
    public int FaceFrame;
    int BlinkCount;
    int BlinkTime;
    int FrameCount;
    int NewFrame = 1;
    bool AnimEnd;
    bool AnimZigzag;
    public bool ChangeFrame;
    Vector2 origin;
    int Flip;
    Vector2 MoveOffset;
    int Counter;
    public static List<string> ZMap = new();
    static int ChangeExpressionCounter;
    bool IsAttack()
    {
        if ((State.LeftStr(4) == "stab") || (State.LeftStr(5) == "swing") || (State.LeftStr(5) == "shoot"))
            return true;
        else
            return false;

    }
    public void UpdateFrame()
    {
        string C = "Character/";
        float BodyDelay, FaceDelay;
        PartName Part = Equip.GetPart(ID);

        if ((State == "stand1") || (State == "stand2") || (State == "alert"))
            AnimZigzag = true;
        else
            AnimZigzag = false;

        if (/*(!AvatarForm.SaveSingleFrame) && */((Part == PartName.Weapon) || (Part == PartName.CashWeapon)) && (Time == 0))
        {
            string AfterImagePath = "Character/Afterimage/" + Owner.AfterImageStr + ".img/0/" + State + "/" + Frame + "/0";
            if (Wz.HasDataE(AfterImagePath))
            {
                Sound.Play("Sound/Weapon.img/" + "swordL/Attack");
                AfterImage.Create(AfterImagePath);
            }
        }

        if ((Image == "head") && (Time == 0))
            ChangeFrame = true;

        if (Wz.HasDataE("Character/00002000.img/" + State + "/" + Frame + "/move"))
        {
            MoveOffset = WzDict.GetVectorE("Character/00002000.img/" + State + "/" + Frame + "/move");
        }
        else
        {
            if ((MapleChair.IsUse) && (!Owner.OtherPlayer))
            {
                MoveOffset.X = MapleChair.BodyRelMove.X;
                MoveOffset.Y = MapleChair.BodyRelMove.Y;
            }
            else
            {
                MoveOffset.X = 0;
                MoveOffset.Y = 0;
            }
        }

        if (FlipX)
            Owner.MoveX = Owner.X - 1 - MoveOffset.X;
        else
            Owner.MoveX = Owner.X - 1 + MoveOffset.X;
        Owner.MoveY = Owner.Y + MoveOffset.Y;
        if (!Animate)
        {
            if (NewFrame <= FrameCount)
                Frame = NewFrame;
        }
        /*
        if (AvatarForm.SaveAllFrames && (!Owner.OtherPlayer))
        {
            float WX = (Player.X - SpriteEngine.WorldX - 155) + AvatarForm.TrackBarX.Position;
            float WY = (Player.Y - SpriteEngine.WorldY - 160) + AvatarForm.TrackBarY.Position;
            Animate = false;
            Time = 0;
            BodyDelay = 0;
            Animend = false;
            TTimers.DoTick(50, 'aaa',
              procedure
                  begin
    
                Inc(AvatarForm.Frame);
            ForceDirectories(ExtractFilePath(ParamStr(0)) + 'Export');
            var FileName := ExtractFilePath(ParamStr(0)) + 'Export\' + AvatarForm.AllFrames[AvatarForm.Frame - 1] + '.png';
        AvatarForm.Label2.Caption := 'Save to:  ' + FileName;
            AvatarPanelTexture.SaveToFile(FileName, nil, 0, IntRectBDS(WX, WY, WX + AvatarForm.TrackBarW.Position, WY + AvatarForm.TrackBarH.Position));
            end);
            var S = AvatarForm.AllFrames[AvatarForm.Frame].Split(["."]);
            State = S[0];
            Frame = S[1].ToInt();
        }
        */

        if (AvatarForm.SelectedFrame && !Owner.OtherPlayer)
        {
            Animate = false;
            Time = 0;
            BodyDelay = 0;
            AnimEnd = false;
            State = AvatarForm.SelectedAction;
            Frame = AvatarForm.SelectedFrameNum;
        }
        /*
        if PlayActionForm.DoPlay then
        begin
    Animend= false;
    Time= 0;
    Frame= 0;
    State= PlayActionForm.ListBox1.Items[PlayActionForm.ListBox1.ItemIndex];
        Inc(PlayActionCounter);
        end;
        */
        if (AvatarForm.ChangeExpressionListBox)
        {
            FaceFrame = 0;
            Expression = AvatarForm.Instance.comboBox1.Text;
            ChangeExpressionCounter += 1;
        }


        if (Owner.ResetAction)
        {
            Frame = 1;
            State = Owner.NewAction;
            Counter += 1; ;
        }

        if (!Wz.HasDataE(C + Equip.GetDir(ID) + ID + ".img/" + WpNum + State + "/" + Frame + "/" + Image) && (!IsAttack()) && (!Equip.DataS.ContainsKey(State + "/" + Frame)))
            Frame = 0;
        FrameCount = Equip.Data["body/" + State + "/FrameCount"];
        BodyDelay = Equip.Data["body/" + State + "/" + Frame + "/delay"];

        int FaceFrameCount = Equip.Data["face/" + Expression + "/FrameCount"];
        FaceDelay = Equip.Data["face/" + Expression + "/" + FaceFrame + "/delay"];

        string Directory = Equip.GetDir(ID);
        string Path;
        if ((Image != "face") && (Equip.GetPart(ID) != PartName.FaceAcc))
        {
            if (Part == PartName.CashWeapon)
                WpNum = Owner.WeaponNum + "/";
            else
                WpNum = "";
            if (Equip.DataS.ContainsKey(State + "/" + Frame))
                Path = C + Directory + ID + ".img/" + WpNum + Equip.DataS[State + "/" + Frame] + "/" + Image;
            else
                Path = C + Directory + ID + ".img/" + WpNum + State + "/" + Frame + "/" + Image;
        }
        else
        {
            Path = C + Directory + ID + ".img/" + Expression + "/" + FaceFrame + "/" + Image;
        }


        if ((Image != "face") && (Equip.GetPart(ID) != PartName.FaceAcc))
        {
            if (Wz.HasDataE(Path))
            {
                ImageNode = Wz.EquipData[Path];
                Alpha = 255;
            }
            else
                Alpha = 0;
        }
        else if ((Image == "face") || (Part == PartName.FaceAcc))
        {
            if (Wz.HasDataE(Path))
            {
                ImageNode = Wz.EquipData[Path];
                // Visible := True;
                Alpha = 255;
            }
            else
                Alpha = 0;
        }

        if ((Image == "face") || (Part == PartName.Glass) || (Part == PartName.FaceAcc))
        {
            if ((State == "ladder") || (State == "rope") || ((State == "swingOF") && (Frame == 1)) || ((State == "swingTF") && (Frame == 0)))
                Alpha = 0;
            else
                Alpha = 255;
        }

        if (!Owner.DressCap)
        {
            if (Part == PartName.Cap)
                Visible = false;

            if (Owner.ShowHair)
            {
                //   if (Image = 'hairOverHead') or (Image = 'backHair') then
                //   Visible := True;
                if (Part == PartName.Hair)
                    Visible = true;
            }
        }

        if ((Owner.DressCap) && (Owner.ShowHair))
        {

            if (Part == PartName.Hair)
            {
                switch (Owner.CapType)
                {
                    case 0:
                        Visible = true;
                        break;
                    case 1:
                        if ((Image == "hairOverHead") || (Image == "backHair"))
                            Visible = false;
                        break;
                    case 2:
                        if ((Image == "hairOverHead") || (Image == "backHair") || (Image == "hairBelowBody") || (Image == "backHairBelowCap"))
                            Visible = false;
                        break;
                    case 3:
                        Visible = false;
                        break;
                }
            }
        }


        // if ((Image == "ear") || (Image == "lefEar") || (Image == "highlefEar"))
        //  Alpha = 0;

        if (Part == PartName.Head)
        {
            if (Image == "head")
            {
                Visible = true;
            }
            else
            {
                if (Image == Owner.EarType)
                    Visible = true;
                else
                    Visible = false;
            }
        }

        if (Wz.HasDataE(Path + "/z"))
        {
            if (!Owner.OtherPlayer)
                Z = 100 + Owner.Z - ZMap.IndexOf(Wz.EquipData[Path + "/z"].ToStr());
            else
                Z = 100 + (200 * Owner.NewZ) + Owner.Z - ZMap.IndexOf(Wz.EquipData[Path + "/z"].ToStr());
        }
        if (Animate)
            Time += 17;
        if (Time > BodyDelay)
        {
            if (Counter > 50)
            {
                Owner.ResetAction = false;
                Counter = 0;
            }
            Time = 0;
            if (AnimZigzag)
            {
                Frame += Value;
                if ((Frame >= FrameCount) || (Frame <= 0))
                    Value = -Value;
            }
            else
            {
                Frame += 1;
                AnimEnd = false;
                if (Frame > FrameCount)
                {
                    if (AnimRepeat)
                    {
                        Frame = 0;
                    }
                    else
                    {
                        Frame -= 1;
                        AnimEnd = true;
                    }
                }
            }
        }

        if (Expression != "blink")
        {
            FaceCount += 1;
            if (FaceCount >= 550)
            {
                Expression = "blink";
                FaceCount = 0;
                AvatarForm.Instance.comboBox1.Text = "";
            }
        }


        BlinkCount += 1;
        if (BlinkCount >= 220)
        {
            DoFaceAnim = true;
            BlinkCount = 0;
        }

        Random Random = new Random();
        int BlinkNum = -1;
        switch (Random.Next(1500))
        {
            case 100: BlinkNum = 1; break;
            case 500: BlinkNum = 2; break;
        }
        if ((DoFaceAnim) && (Expression != "oops"))
            FaceTime += 17;
        if (FaceTime > FaceDelay)
        {
            FaceFrame += 1;
            if (FaceFrame > FaceFrameCount)
            {
                FaceFrame = 0;
                BlinkTime += 1;
                if (BlinkTime >= BlinkNum)
                {
                    DoFaceAnim = false;
                    BlinkTime = 0;
                }
            }
            FaceTime = 0;
        }
        string SkillAction;
        if (Equip.DataS.ContainsKey(State + "/" + Frame))
        {
            SkillAction = Equip.DataS[State + "/" + Frame];
            if ((SkillAction == "hide/0") || (SkillAction == "blink/0"))
                Alpha = 0;
            if ((Image == "face") || (Part == PartName.Glass) || (Part == PartName.FaceAcc))
            {
                if ((SkillAction == "swingOF/1") || (SkillAction == "swingTF/0"))
                    Alpha = 0;
            }
        }

        if ((Part == PartName.Weapon) && (ID.LeftStr(5) == "01212"))
        {
            if ((Image == "weapon") || (Image == "weapon1") || (Image == "weapon2"))
                Visible = false;
        }

        int AdjX;
        if (Wz.HasDataE(Path + "/origin"))
        {
            switch (FlipX)
            {
                case true:
                    this.Flip = -1;
                    if (Owner.InLadder)
                        AdjX = 3;
                    else
                        AdjX = 0;
                    origin.X = Wz.EquipData[Path + "/origin"].ToVector().X - this.ImageWidth + AdjX;
                    break;
                case false:
                    this.Flip = 1;
                    origin.X = -Wz.EquipData[Path + "/origin"].ToVector().X;
                    break;
            }
            origin.Y = -Wz.EquipData[Path + "/origin"].ToVector().Y;
        }

        if (Owner.OtherPlayer)
        {
            Owner.TamingNavel.X = 0;
            Owner.TamingNavel.Y = 0;
        }
        else
        {
            Owner.TamingNavel.X = TamingMob.Navel.X;
            Owner.TamingNavel.Y = TamingMob.Navel.Y;
        }

        if (Wz.HasDataE(Path + "/map/brow"))
        {
            Owner.Brow.X = -Wz.EquipData[Path + "/map/brow"].ToVector().X * this.Flip;
            Owner.Brow.Y = -Wz.EquipData[Path + "/map/brow"].ToVector().Y;
            if (Image == "head")
                Owner.HeadBrow = Owner.Brow;
            this.Offset.X = origin.X + Owner.HeadNeck.X - Owner.BodyNeck.X - Owner.HeadBrow.X + Owner.Brow.X - Owner.TamingNavel.X;
            this.Offset.Y = origin.Y + Owner.HeadNeck.Y - Owner.BodyNeck.Y - Owner.HeadBrow.Y + Owner.Brow.Y - Owner.TamingNavel.Y;
        }

        if (Wz.HasDataE(Path + "/map/neck"))
        {
            Owner.Neck.X = -Wz.EquipData[Path + "/map/neck"].ToVector().X * this.Flip;
            Owner.Neck.Y = -Wz.EquipData[Path + "/map/neck"].ToVector().Y;
            if (Image == "body")
                Owner.BodyNeck = Owner.Neck;
            if (Image == "head")
                Owner.HeadNeck = Owner.Neck;
        }

        if (Image == "body")
            Owner.BrowPos = Owner.BodyNeck + TamingMob.Navel;
        if (Wz.HasDataE(Path + "/map/hand"))
        {
            Owner.Hand.X = -Wz.EquipData[Path + "/map/hand"].ToVector().X * this.Flip;
            Owner.Hand.Y = -Wz.EquipData[Path + "/map/hand"].ToVector().Y;
            if (Image == "arm")
                Owner.ArmHand = Owner.Hand;
            if (Image == "body")
                Owner.BodyHand = Owner.Hand;
            this.Offset.X = origin.X + Owner.Hand.X + Owner.ArmNavel.X - Owner.ArmHand.X - Owner.BodyNavel.X;
            this.Offset.Y = origin.Y + Owner.Hand.Y + Owner.ArmNavel.Y - Owner.ArmHand.Y - Owner.BodyNavel.Y;
        }

        if (Wz.HasDataE(Path + "/map/handMove"))
        {
            Owner.HandMove.X = -Wz.EquipData[Path + "/map/handMove"].ToVector().X * this.Flip;
            Owner.HandMove.Y = -Wz.EquipData[Path + "/map/handMove"].ToVector().Y;
            if (Image == "lHand")
                Owner.lHandMove = Owner.HandMove;
            this.Offset.X = origin.X + Owner.HandMove.X - Owner.lHandMove.X;
            this.Offset.Y = origin.Y + Owner.HandMove.Y - Owner.lHandMove.Y;
        }

        if (Wz.HasDataE(Path + "/map/navel"))
        {
            Owner.Navel.X = -Wz.EquipData[Path + "/map/navel"].ToVector().X * this.Flip;
            Owner.Navel.Y = -Wz.EquipData[Path + "/map/navel"].ToVector().Y;
            if (Image == "arm")
                Owner.ArmNavel = Owner.Navel;
            if (Image == "body")
                Owner.BodyNavel = Owner.Navel;
            this.Offset.X = origin.X + Owner.Navel.X - Owner.BodyNavel.X - Owner.TamingNavel.X;
            this.Offset.Y = origin.Y + Owner.Navel.Y - Owner.BodyNavel.Y - Owner.TamingNavel.Y;
        }
    }

    bool IsSkillAttack()
    {
        if (Equip.DataS.ContainsKey(Skill.ID + "/action") && (Owner.Action == Equip.DataS[Skill.ID + "/action"]))
            return true;
        else
            return false;
    }

    bool ArrowKeyDown()
    {
        if ((!Keyboard.KeyDown(Input.Left)) && (!Keyboard.KeyDown(Input.Right)) && (!Keyboard.KeyDown(Input.Up)) && (!Keyboard.KeyDown(Input.Down)))
            return false;
        else
            return true;
    }

    public override void DoMove(float Delta)
    {
        if (Map.GameMode == GameMode.Viewer)
            return;

        if (Morph.IsUse)
        {
            Owner.MoveX = -99999;
            return;
        }

        Owner.Attack = IsAttack();
        Owner.Action = State;
        PartName Part = Equip.GetPart(ID);

        if (TamingMob.IsUse)
        {
            Owner.Attack = false;
            if (State != "fly")
                Frame = 0;
            if (TamingMob.CharacterAction == "StabT2")
                TamingMob.CharacterAction = "stabT2";
            if (TamingMob.CharacterAction != "hideBody")
                State = TamingMob.CharacterAction;
            // if (Part = Weapon) or (Part = CashWeapon) then
            // Exit;
        }

        if (((Keyboard.KeyDown(Input.Left)) || (Keyboard.KeyDown(Input.Right))) && (!TamingMob.IsUse))
        {
            if ((State.LeftStr(4) != "walk") && (Owner.JumpState == JumpState.jsNone) && (!Owner.InLadder) && (!IsAttack()) && (Skill.PlayEnded))
            {
                Time = 0;
                Frame = 0;
                State = Owner.WalkType;
            }
        }

        if ((Keyboard.KeyUp(Input.Left)) || (Keyboard.KeyUp(Input.Right)))
        {
            if ((!Owner.InLadder) && (Owner.JumpState == JumpState.jsNone) && (!IsAttack()) && (Skill.PlayEnded))
            {
                Frame = 0;
                State = Owner.StandType;
            }
        }

        if ((Owner.JumpState != JumpState.jsNone) && (!IsAttack()) && (!TamingMob.IsUse))
        {
            Frame = 0;
            State = "jump";
        }
        // jump ->re stand
        if ((Owner.JumpState == JumpState.jsNone) && (State == "jump") && (!Keyboard.KeyDown(Input.LeftAlt)))
            State = Owner.StandType;
        // press jump+ left(right) key
        if ((Keyboard.KeyDown(Input.LeftAlt)) && (!IsAttack()) && (!TamingMob.IsUse))
        {
            if ((Keyboard.KeyDown(Input.Left)) || (Keyboard.KeyDown(Input.Right)))
            {
                Frame = 0;
                State = "jump";
            }
        }

        if ((!Owner.InLadder) && (Owner.JumpState == JumpState.jsNone) && (!TamingMob.IsUse))
        {
            if ((!IsAttack()) && (Skill.PlayEnded))
            {
                if ((Keyboard.KeyDown(Input.Down)) && (!Keyboard.KeyDown(Input.LeftControl)) && (State != "proneStab"))
                    State = "prone";
                if ((Keyboard.KeyDown(Input.LeftControl)) && (State != "proneStab") && (Skill.PlayEnded))
                {
                    Skill.Attacking = false;
                    AnimEnd = false;
                    Frame = 0;
                    Time = 0;
                    State = "proneStab";
                }
            }
            if ((Keyboard.KeyUp(Input.Down)) && (Skill.PlayEnded))
                State = Owner.StandType;
        }

        if (!Owner.InLadder)
        {
            if ((State == "rope") || (State == "ladder"))
            {
                Frame = 0;
                State = Owner.StandType;
            }
        }

        if (Owner.InLadder)
        {
            switch (Owner.LadderType)
            {
                case LadderType.Ladder:
                    State = "ladder";
                    break;
                case LadderType.Rope:
                    State = "rope";
                    break;
            }
        }


        if ((IsAttack()) || (State == "proneStab") || (IsSkillAttack()) /*|| (PlayActionForm.Playing)*/)
            AnimRepeat = false;
        else
            AnimRepeat = true;

        if (AnimEnd)
        {
            if ((IsSkillAttack()) || (IsAttack()) /*||(PlayActionForm.Playing) */)
            {
                Value = 1;
                Time = 0;
                Frame = 0;
                State = "alert";
                AlertCount = 0;
                Skill.Start = false;
            }
            if (State == "proneStab")
            {
                Time = 0;
                Frame = 0;
                State = "prone";
            }
        }

        AlertCount += 1;
        if ((AlertCount > 300) && (State == "alert"))
        {
            // FTime := 0;
            Frame = 1;
            State = Owner.StandType;
            AlertCount = 0;
        }

        if ((Keyboard.KeyDown(Input.LeftControl)) && (!Keyboard.KeyDown(Input.Down)) && (!IsAttack()) && (!Owner.InLadder) && (Skill.PlayEnded) && (!TamingMob.IsUse))
        {
            Skill.Attacking = false;
            AnimEnd = false;
            Frame = 0;
            Time = 0;
            State = Owner.AttackAction;
        }

        if ((Skill.Start) && (!Skill.PlayEnded))
        {
            if (Equip.DataS.ContainsKey(Skill.ID + "/action"))
            {
                if (State != Equip.DataS[Skill.ID + "/action"])
                {
                    AnimEnd = false;
                    Frame = 0;
                    Time = 0;
                    State = Equip.DataS[Skill.ID + "/action"];
                }
            }
        }

        if (Keyboard.KeyDown(Input.F1))
        {
            FaceFrame = 0;
            Expression = "hit";
        }
        if (Keyboard.KeyDown(Input.F2))
        {
            FaceFrame = 0;
            Expression = "smile";
        }
        if (Keyboard.KeyDown(Input.F3))
        {
            FaceFrame = 0;
            Expression = "troubled";
        }
        if (Keyboard.KeyDown(Input.F4))
        {
            FaceFrame = 0;
            Expression = "cry";
        }
        if (Keyboard.KeyDown(Input.F5))
        {
            FaceFrame = 0;
            Expression = "angry";
        }
        if (Keyboard.KeyDown(Input.F6))
        {
            FaceFrame = 0;
            Expression = "bewildered";
        }
        if (Keyboard.KeyDown(Input.F7))
        {
            FaceFrame = 0;
            Expression = "stunned";
        }

        // MirrorX := NewFlip;
        if ((!Owner.InLadder) && (!IsAttack()) && (Skill.PlayEnded))
        {
            if (Keyboard.KeyDown(Input.Left))
            {
                FlipX = false;
                Owner.FlipX = false;
            }
            if (Keyboard.KeyDown(Input.Right))
            {
                FlipX = true;
                Owner.FlipX = true;
            }
        }

        if (Owner.InLadder)
        {
            if ((Keyboard.KeyUp(Input.Up)) || (Keyboard.KeyUp(Input.Down)))
                Animate = false;
            if ((Keyboard.KeyDown(Input.Up)) || (Keyboard.KeyDown(Input.Down)))
                Animate = true;
        }
        else
        {
            Animate = true;
        }

        if ((TamingMob.IsUse) || (MapleChair.IsUse))
        {
            if ((Part == PartName.Weapon) || (Part == PartName.CashWeapon))
                Visible = false;
        }
        else
        {
            Visible = true;
        }

        //Game.Player.FlipX = FlipX;
        if ((State == "ladder") || (State == "rope"))
            MapleChair.CanUse = false;
        else
            MapleChair.CanUse = true;

        if (MapleChair.IsUse)
        {
            State = MapleChair.CharacterAction;
        }
        UpdateFrame();

    }


    public override void DoDraw()
    {
        if (ImageNode == null)
            return;
        /*
        if ((AvatarForm.SaveAllFrames) && (AvatarForm.Frame = 96))
            AvatarForm.SaveAllFrames = false;
        */
        if (AvatarForm.ChangeExpressionListBox)
        {
            if (ChangeExpressionCounter > 5)
            {
                ChangeExpressionCounter = 0;
                AvatarForm.ChangeExpressionListBox = false;
            }
        }
        /*
        if (PlayActionForm.DoPlay)
        {
            if (PlayActionCounter > 2)
            {
                PlayActionCounter = 0;
                PlayActionForm.DoPlay = false;
            }
        }
        */

        if (Map.GameMode == GameMode.Viewer)
            return;

        if (ChangeFrame)
            ChangeFrame = false;
        if (Map.ShowPlayer)
            base.DoDraw();
        if (Visible)
            Moved = true;
    }


}



```

`MapleNecrocer/Client/MapleCharacterEx.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Xna.Framework;
using Spine;

namespace MapleNecrocer;


public class PlayerEx : Player
{
   public enum MoveDirection { Left, Right, None, None2 }
   public enum MoveType { Stand, Move, Jump, Fly }

    public PlayerEx(Sprite Parent) : base(Parent)
    {
     
    }
  
    public static void Spawn(string IDList)
    {

        Player._NewZ += 1;
        var PlayerEx = new PlayerEx(EngineFunc.SpriteEngine);

        PlayerEx.NewZ = Player._NewZ;
        PlayerEx.OtherPlayer = true;

        PlayerEx.X = Game.Player.X;
        PlayerEx.Y = Game.Player.Y - 100;
        Foothold BelowFH = null;
        var Below = FootholdTree.Instance.FindBelow(new Vector2(Game.Player.X, Game.Player.Y - 2), ref BelowFH);
        PlayerEx.FH = BelowFH;
        PlayerEx.JumpSpeed = 0.6f;
        PlayerEx.JumpHeight = 9.5f;
        PlayerEx.MaxFallSpeed = 8;
        PlayerEx.JumpState = JumpState.jsFalling;
        PlayerEx.MoveSpeed = 1.8f;
        PlayerEx.moveType = MoveType.Jump;
        PlayerEx.moveDirection = MoveDirection.None;

        PlayerExList.Add(PlayerEx);
        string[] Split = IDList.Split("-");
        List.Clear();
        for (int i = 0; i < Split.Length - 1; i++)
            List.Add(Split[i]);
        List.Sort();
        for (int i = 0; i < List.Count; i++)
            PlayerEx.CreateEquip(List[i], EngineFunc.SpriteEngine);
    }
    static List<string> List = new List<string>();
    public static List<PlayerEx> PlayerExList = new();
    public MoveDirection moveDirection;
    public MoveType moveType;
    public float MoveSpeed;
    int JumpEdge;
    float VelocityY;
    public int JumpCount;
    public float JumpSpeed;
    public float JumpHeight;
    public float MaxFallSpeed;
    public bool DoJump;
    private JumpState jumpState;
    public JumpState JumpState
    {
        get => jumpState;
        set
        {
            if (jumpState != value)
            {
                jumpState = value;
                switch (value)
                {
                    case JumpState.jsNone:
                    case JumpState.jsFalling:
                        VelocityY = 0;
                        break;
                }
            }
        }
    }

    public void UpdateJump()
    {

        switch (jumpState)
        {
            case JumpState.jsNone:
                if (DoJump)
                {
                    jumpState = JumpState.jsJumping;
                    VelocityY = -JumpHeight;
                }
                break;

            case JumpState.jsJumping:

                Y += VelocityY * 1;
                VelocityY += JumpSpeed;
                if (VelocityY > 0)
                    jumpState = JumpState.jsFalling;
                break;

            case JumpState.jsFalling:
                Y = Y + VelocityY * 1;
                VelocityY = VelocityY + JumpSpeed;
                if (VelocityY > MaxFallSpeed)
                    VelocityY = MaxFallSpeed;
                break;
        }
        DoJump = false;

    }

    public override void DoMove(float Delta)
    {
        //base.DoMove(Delta);
        UpdateJump();
        int X1 = FH.X1;
        int Y1 = FH.Y1;
        int X2 = FH.X2;
        int Y2 = FH.Y2;
        Random Random = new Random();

        switch (Random.Next(300))
        {
            case 100:
                FlipX = false;
                moveDirection = MoveDirection.Left;
                break;
            case 150:
                FlipX = true;
                moveDirection = MoveDirection.Right;
                break;
            case 200:
                moveDirection = MoveDirection.None;
                break;
            case 290:
                DoJump = true;
                break;
        }

        if (JumpState != JumpState.jsNone)
        {
            Action = "jump";
        }
        else
        {
            switch (moveDirection)
            {
                case MoveDirection.Left:
                case MoveDirection.Right:
                    Action = WalkType;
                    break;
                case MoveDirection.None:
                    Action = StandType;
                    break;
                case MoveDirection.None2:
                    Action = "prone";
                    break;
            }
        }

        Vector2 Below = new();
        Foothold BelowFH = null, WallFH = null;
        if ((JumpState == JumpState.jsFalling))
        {
            Below = FootholdTree.Instance.FindBelow(new Vector2(X, Y - VelocityY - 6), ref BelowFH);
            if (Y >= Below.Y - 3)
            {
                Y = Below.Y;
                MaxFallSpeed = 10;
                JumpState = JumpState.jsNone;
                FH = BelowFH;
                Z = FH.Z * 100000 + 60000;
            }
        }

        int FallEdge;
        int Direction;
        if (moveDirection == MoveDirection.Left)
        {
            Direction = GetAngle256(X2, Y2, X1, Y1);
            if (!FH.IsWall())
            {
                X += (float)(Sin256(Direction) * MoveSpeed);
                Y -= (float)(Cos256(Direction) * MoveSpeed);
            }
            FallEdge = -999999;
            JumpEdge = -999999;
            if (moveType == MoveType.Move)
            {
                // no fh
                if (FH.Prev == null)
                    FallEdge = FH.X1;
                // Wall's edge down
                if ((FH.Prev != null) && (FH.Prev.IsWall()))
                    FallEdge = FH.X1;

                if (X < FallEdge)
                {
                    X = FallEdge;
                    FlipX = true;
                    moveDirection = MoveDirection.Right;
                }
            }

            if (moveType == MoveType.Jump)
            {
                if (X < Map.Left + 20)
                {
                    X = Map.Left + 20;
                    FlipX = true;
                    moveDirection = MoveDirection.Right;
                }
                // .--------.
                if (FH.Prev == null)
                    JumpEdge = FH.X1;
                // ┌--- <--
                if ((FH.Prev != null) && (FH.Prev.IsWall()) && (FH.Prev.Y1 > Y))
                    FallEdge = FH.X1;

                if (X < FallEdge)
                    JumpState = JumpState.jsFalling;
                if (X < JumpEdge)
                    DoJump = true;
                // -->  ---┐  <--
                WallFH = FootholdTree.Instance.FindWallR(new Vector2(X + 4, Y - 4));
                if ((WallFH != null) && (FH.Z == WallFH.Z))
                {
                    if (X < WallFH.X1 + 30)
                        DoJump = true;
                    if (X <= WallFH.X1)
                    {
                        X = WallFH.X1 + MoveSpeed;
                        if (JumpState == JumpState.jsNone)
                        {
                            FlipX = true;
                            moveDirection = MoveDirection.Right;
                        }
                    }
                }
            }
            // walk left
            if ((X <= FH.X1) && (FH.PrevID != 0) && (!FH.IsWall()) && (!FH.Prev.IsWall()))
            {
                if (JumpState == JumpState.jsNone)
                {
                    FH = FH.Prev;
                    X = FH.X2;
                    Y = FH.Y2;
                    Z = FH.Z * 100000 + 6000;
                }
            }
        }

        // walk right
        if (moveDirection == MoveDirection.Right)
        {

            Direction = GetAngle256(X1, Y1, X2, Y2);
            if (!FH.IsWall())
            {
                X += (float)(Sin256(Direction) * MoveSpeed);
                Y -= (float)(Cos256(Direction) * MoveSpeed);
            }

            FallEdge = 999999;
            JumpEdge = 999999;
            if (moveType == MoveType.Move)
            {
                if (FH.Next == null)
                    FallEdge = FH.X2 + 5;
                // Wall down
                if ((FH.Next != null) && (FH.Next.IsWall()))

                    FallEdge = FH.X2;
                if (X > FallEdge)
                {
                    X = FallEdge;
                    FlipX = false;
                    moveDirection = MoveDirection.Left;
                }
            }

            if (moveType == MoveType.Jump)
            {
                if (X > Map.Right - 20)
                {
                    X = Map.Right - 20;
                    FlipX = false;
                    moveDirection = MoveDirection.Left;
                }
                if (FH.Next == null) // .--------.
                    JumpEdge = FH.X2;
                // -->  ----┐
                if ((FH.Next != null) && (FH.Next.IsWall()) && (FH.Next.Y2 > Y))
                    FallEdge = FH.X2;

                if (X > FallEdge)
                    JumpState = JumpState.jsFalling;
                if (X > JumpEdge)
                    DoJump = true;
                // -->  ┌.....
                WallFH = FootholdTree.Instance.FindWallL(new Vector2(X - 4, Y - 4));
                if ((WallFH != null) && (FH.Z == WallFH.Z))
                {
                    if (X > WallFH.X1 - 30)
                        DoJump = true;
                    if (X >= WallFH.X1)
                    {
                        X = WallFH.X2 - MoveSpeed;
                        if (JumpState == JumpState.jsNone)
                        {
                            FlipX = false;
                            moveDirection = MoveDirection.Left;
                        }
                    }
                }
            }

            // walk right
            if ((X >= FH.X2) && (FH.NextID != 0) && (!FH.IsWall()) && (!FH.Next.IsWall()))
            {
                if (JumpState == JumpState.jsNone)
                {
                    FH = FH.Next;
                    X = FH.X1;
                    Y = FH.Y1;
                    Z = FH.Z * 100000 + 6000;
                }
            }
        }


    }


}

public class AvatarPartEx : AvatarParts
{
    public AvatarPartEx(Sprite Parent) : base(Parent)
    {
        IntMove=true;
    }

    public override void DoMove(float Delta)
    {
        if (Image != "hand")
        {
            //  if ((Alpha == 0) || (Visible = false))
            //   return;
        }

        X = Owner.X;
        Y = Owner.Y;
        FlipX = Owner.FlipX;
        State = Owner.Action;
        Random Random = new Random();
        switch (Random.Next(500))
        {
            case 250:
                FaceFrame = 0;
                Expression = "smile";
                break;
            case 400:
                Expression = "blink";
                break;
        }
        UpdateFrame();

    }

    public override void DoDraw()
    {
        //   if ((Alpha == 0) || (Visible == false))
        //    return;
        base.DoDraw();
        if (ChangeFrame)
            ChangeFrame = false;
        if (Visible)
            Moved = true;
    }
}



```

`MapleNecrocer/Client/MapleEffect.cs`:

```cs
using System;
using System.Collections.Generic;
using System.DirectoryServices;
using System.Drawing;
using System.Linq;
using System.Net.NetworkInformation;
using System.Numerics;
using System.Security.Claims;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using WzComparerR2.CharaSim;
using WzComparerR2.WzLib;
using Vector2 = Microsoft.Xna.Framework.Vector2;
namespace MapleNecrocer;

public enum EffectType { Cash, Chair, Equip, Consume, Totem, Soul, Ring }
public class SetEffect : SpriteEx
{
    public SetEffect(Sprite Parent) : base(Parent)
    {
    }
    string Path;
    int Frame;
    int FTime;
    int Delay;
    int Default;
    bool DoWalk;
    public static Dictionary<string, string> AllList = new();
    public static Dictionary<string, SetEffect> UseList = new();
    public static void LoadList()
    {
        foreach (var Iter in Wz.GetNodeA("Effect/SetEff.img").Nodes)
        {
            foreach (var Iter2 in Iter.Nodes)
            {
                if (Iter2.Text == "info")
                {
                    foreach (var Iter3 in Iter2.Nodes)
                    {
                        foreach (var Iter4 in Iter3.Nodes)
                        {
                            SetEffect.AllList.AddOrReplace("0" + Iter4.ToInt(), Iter.Text);
                        }
                    }
                }
            }
        }
    }

    public static void Remove(string ID)
    {
        if (SetEffect.UseList.ContainsKey(ID))
        {
            SetEffect.UseList[ID].Dead();
            SetEffect.UseList.Remove(ID);
        }
        EngineFunc.SpriteEngine.Dead();
    }

    public static void Create(string ID)
    {
        var Entry = Wz.GetNodeA("Effect/SetEff.img/" + AllList[ID].IntID());
        Wz.DumpData(Entry, Wz.EquipData, Wz.EquipImageLib);
        var SetEffect = new SetEffect(EngineFunc.SpriteEngine);
        SetEffect.ImageLib = Wz.EquipImageLib;
        SetEffect.IntMove = true;
        SetEffect.Tag = 1;
        foreach (var Iter in Entry.Nodes)
        {
            foreach (var Iter2 in Iter.Nodes)
            {
                if (Iter2.Text == "walk1")
                    SetEffect.DoWalk = true;
                if ((Char.IsNumber(Iter2.Text[0])) && (Iter2.Value is Wz_Png))
                {
                    SetEffect.Path = Iter2.ParentNode.FullPathToFile2();
                    SetEffect.ImageNode = Wz.EquipData[Iter2.FullPathToFile2()];
                }
                foreach (var Iter3 in Iter2.Nodes)
                {
                    if ((Char.IsNumber(Iter3.Text[0])) && (Iter3.Value is Wz_Png))
                    {
                        SetEffect.Path = Iter3.ParentNode.FullPathToFile2();
                        SetEffect.ImageNode = Wz.EquipData[Iter3.FullPathToFile2()];
                    }
                }
            }
        }
        UseList.AddOrReplace(ID, SetEffect);
    }

    public override void DoMove(float Delta)
    {
        base.DoMove(Delta);
        if (Wz.HasDataE(Path + "/" + Game.Player.Action + "/" + Frame))
        {
            ImageNode = Wz.EquipData[Path + "/" + Game.Player.Action + "/" + Frame];
            Default = 1;
            Visible = true;
        }
        else if (Wz.HasDataE(Path + "/" + Frame))
        {
            ImageNode = Wz.EquipData[Path + "/" + Frame];
            Default = 0;
            Visible = true;
        }
        else
            Visible = false;

        if (DoWalk)
        {
            if ((Game.Player.Action == "walk1") || (Game.Player.Action == "walk2"))
                Visible = true;
            else
                Visible = false;
        }

        Delay = ImageNode.GetInt("delay", 100);
        FTime += 17;
        if (FTime > Delay)
        {
            Frame += 1;
            switch (Default)
            {
                case 1:
                    if (!Wz.HasDataE(Path + "/" + Game.Player.Action + "/" + Frame))
                        Frame = 0;
                    break;
                case 0:
                    if (!Wz.HasDataE(Path + "/" + Frame))
                        Frame = 0;
                    break;
            }
            FTime = 0;
        }
        X = Game.Player.X - 10;
        int Pos = ImageNode.ParentNode.GetInt("pos", -1);

        if (Pos == 1)
            Y = Game.Player.Y - 50;
        else
            Y = Game.Player.Y;
        Z = Game.Player.Z + ImageNode.ParentNode.GetInt("z", -1);

        FlipX = Game.Player.FlipX;

        Wz_Vector origin = ImageNode.GetVector("origin");
        Vector2 BrowPos = Game.Player.BrowPos;
        Wz_Vector BodyRelMove = MapleChair.BodyRelMove;
        int OffY = 30;
        switch (FlipX)
        {
            case true:
                Origin.X = (int)(-origin.X + ImageWidth + BrowPos.X - BodyRelMove.X + 3);
                break;
            case false:
                Origin.X = (int)(origin.X + BrowPos.X - 12 - BodyRelMove.X);
                break;
        }
        Origin.Y = (int)(origin.Y + BrowPos.Y - OffY - BodyRelMove.Y);

    }

}

public class ItemEffect : SpriteEx
{
    public ItemEffect(Sprite Parent) : base(Parent)
    {
    }
    string Path;
    int Frame;
    int FTime;
    int Delay;
    int Default;
    bool IsCash;
    EffectType EffType;
    public static List<string> AllList = new();
    static Wz_Node Entry;
    public static Dictionary<string, ItemEffect> UseList = new();
    public static void LoadList()
    {
        if (Wz.HasNode("Effect/ItemEff.img"))
        {
            foreach (var Iter in Wz.GetNodeA("Effect/ItemEff.img").Nodes)
                ItemEffect.AllList.Add("0" + Iter.Text);
        }
    }
    public static void Remove(string ID)
    {
        if (ItemEffect.UseList.ContainsKey(ID))
        {
            ItemEffect.UseList[ID].Dead();
            ItemEffect.UseList.Remove(ID);
        }
    }

    public static void Remove(EffectType EffType)
    {
        foreach (var Iter in EngineFunc.SpriteEngine.SpriteList)
        {
            if ((Iter is ItemEffect) && ((ItemEffect)Iter).EffType == EffType)
            {
                Iter.Dead();
                var s = Iter;
                s = null;
            }
        }
        EngineFunc.SpriteEngine.Dead();
    }
    public static void Create(string ID, EffectType EffectType)
    {
        if (ID == "01048000") return;
        if (ID == "01049000") return;
        switch (EffectType)
        {
            case EffectType.Cash:
                Entry = Wz.GetNodeA("Item/Cash/0501.img/" + ID);
                break;
            case EffectType.Chair:
            case EffectType.Equip:
            case EffectType.Consume:
            case EffectType.Totem:
            case EffectType.Ring:
                Entry = Wz.GetNodeA("Effect/ItemEff.img/" + ID.IntID());
                break;
            case EffectType.Soul:
                Entry = Wz.GetNodeA("Effect/BasicEff.img/SoulSkillReadied/Repeat/" + ID);
                break;
        }

        Wz.DumpData(Entry, Wz.EquipData, Wz.EquipImageLib);

        if (ID.LeftStr(4) == "0111" || ID.LeftStr(4) == "0301")
        {
            if (ID.LeftStr(6) == "011129" || ID.LeftStr(6) == "011132")
            {
                var ItemEffect = new ItemEffect(EngineFunc.SpriteEngine);
                ItemEffect.EffType = EffectType.Ring;
                ItemEffect.ImageLib = Wz.EquipImageLib;
                ItemEffect.IntMove = true;
                ItemEffect.Tag = 1;
                ItemEffect.Path = Entry.FullPathToFile2() + "/effect";
                foreach (var Iter in Entry.GetNode("effect").Nodes)
                {
                    if (Iter.GetNode("effect/0") != null)
                    {
                        ItemEffect.ImageNode = Wz.EquipData[Iter.GetPath + "/0"];
                        break;
                    }
                }
            }

            foreach (var Iter in Entry.Nodes)
            {
                if (Char.IsNumber(Iter.Text[0]))
                {
                    var ItemEffect = new ItemEffect(EngineFunc.SpriteEngine);
                    if (ID.LeftStr(4) == "0111")
                        ItemEffect.EffType = EffectType.Ring;
                    else
                        ItemEffect.EffType = EffectType.Chair;
                    ItemEffect.ImageLib = Wz.EquipImageLib;
                    ItemEffect.IntMove = true;
                    ItemEffect.Tag = 1;

                    foreach (var Iter2 in Iter.Nodes)
                    {
                        if (Iter2.Value is Wz_Png)
                        {
                            ItemEffect.Path = Iter2.ParentNode.FullPathToFile2();
                            ItemEffect.ImageNode = Wz.EquipData[Iter2.FullPathToFile2()];
                        }
                        foreach (var Iter3 in Iter2.Nodes)
                        {
                            if (Iter3.Value is Wz_Png)
                            {
                                ItemEffect.Path = Iter3.ParentNode.FullPathToFile2();
                                ItemEffect.ImageNode = Wz.EquipData[Iter3.FullPathToFile2()];
                            }
                        }
                    }
                }
            }
        }
        else if (ID.LeftStr(3) == "010" || ID.LeftStr(4) == "0110" || ID.LeftStr(4) == "0501")
        {

            var ItemEffect = new ItemEffect(EngineFunc.SpriteEngine);
            if (ID.LeftStr(4) == "0501")
                ItemEffect.EffType = EffectType.Cash;
            else
                ItemEffect.EffType = EffectType.Equip;
            ItemEffect.ImageLib = Wz.EquipImageLib;
            ItemEffect.Path = Entry.FullPathToFile2() + "/effect";
            foreach (var Iter in Entry.GetNode("effect").Nodes)
            {
                if (Iter.GetNode("0") != null)
                {
                    ItemEffect.ImageNode = Wz.EquipData[Iter.FullPathToFile2() + "/0"];
                    break;
                }
            }
            ItemEffect.IntMove = true;
            ItemEffect.Tag = 1;
            if (EffectType == EffectType.Equip)
                UseList.Add(ID, ItemEffect);
        }
        else
        {
            var ItemEffect = new ItemEffect(EngineFunc.SpriteEngine);
            ItemEffect.ImageLib = Wz.EquipImageLib;
            ItemEffect.IntMove = true;
            ItemEffect.Tag = 1;
            if (ID.LeftStr(3) == "012")
            {
                ItemEffect.EffType = EffectType.Totem;
                switch (ID.ToInt())
                {
                    case 1202215:
                    case 1202216:
                    case 1202217:
                    case 1202160:
                        ItemEffect.Path = Entry.FullPathToFile2() + "/effect/default";
                        break;
                    default:
                        ItemEffect.Path = Entry.FullPathToFile2();
                        break;
                }
            }
            else if (ID.LeftStr(1) == "8")
            {
                ItemEffect.EffType = EffectType.Soul;

                ItemEffect.Path = Entry.FullPathToFile2();
            }
            else
            {
                ItemEffect.EffType = EffectType.Consume;
                ItemEffect.Path = Entry.FullPathToFile2();
            }

        }
    }

    public override void DoMove(float Delta)
    {
        base.DoMove(Delta);
        if (Wz.HasDataE(Path + "/" + Game.Player.Action + "/" + Frame))
        {
            ImageNode = Wz.EquipData[Path + "/" + Game.Player.Action + "/" + Frame];
            Default = 1;
            Visible = true;
        }
        else if (Wz.HasDataE(Path + "/default/" + Frame))
        {
            ImageNode = Wz.EquipData[Path + "/default/" + Frame];
            Default = 0;
            Visible = true;

        }
        else if (Wz.HasDataE(Path + "/0/" + Frame))
        {
            ImageNode = Wz.EquipData[Path + "/0/" + Frame];
            Default = 2;
            Visible = true;
        }
        else if (Wz.HasDataE(Path + "/" + Frame))
        {
            ImageNode = Wz.EquipData[Path + "/" + Frame];
            Default = 3;
            Visible = true;
        }
        else
        {
            Visible = false;
        }

        if (ImageNode == null)
            return;

        Delay = ImageNode.GetInt("delay", 100);

        FTime += 17;
        if (FTime > Delay)
        {
            Frame += 1;
            switch (Default)
            {
                case 1:
                    if (!Wz.HasDataE(Path + "/" + Game.Player.Action + "/" + Frame))
                        Frame = 0;
                    break;
                case 0:
                    if (!Wz.HasDataE(Path + "/default/" + Frame))
                        Frame = 0;
                    break;
                case 2:
                    if (!Wz.HasDataE(Path + "/0/" + Frame))
                        Frame = 0;
                    break;
                case 3:
                    if (!Wz.HasDataE(Path + "/" + Frame))
                        Frame = 0;
                    break;
            }
            FTime = 0;
        }

        FlipX = Game.Player.FlipX;
        X = Game.Player.X - 10;
        int Pos = ImageNode.ParentNode.GetInt("pos", -1);

        if (Pos == 0 || Pos == 1)
        {
            X = Game.Player.X - 10;
        }
        else
        {
            if (FlipX)
            {
                if (Game.Player.InLadder)
                    X = Game.Player.X - 12;
                else
                    X = Game.Player.X - 19;
            }
            else
            {
                if (Game.Player.InLadder)
                    X = Game.Player.X + 5;
                else
                    X = Game.Player.X;
            }
        }

        if (EffType != EffectType.Totem)
        {
            if (Pos == 1)
                Y = Game.Player.Y - 50;
            else
                Y = Game.Player.Y;
        }
        else
        {
            Y = Game.Player.Y - 60;
        }

        Z = Game.Player.Z + ImageNode.ParentNode.GetInt("z", 0);
        if (EffType == EffectType.Chair)
            Z = Game.Player.Z + ImageNode.GetInt("z", 0) - 1;

        Wz_Vector origin = ImageNode.GetVector("origin");

        Vector2 BrowPos;
        Wz_Vector BodyRelMove = new(0, 0);
        int OffY = 0;
        if (EffType == EffectType.Chair)
        {
            BrowPos.X = 0;
            BrowPos.Y = 0;
            BodyRelMove.X = 0;
            BodyRelMove.Y = 0;
            OffY = 0;
        }
        else
        {
            BrowPos = Game.Player.BrowPos;
            BodyRelMove = MapleChair.BodyRelMove;
            OffY = 30;
        }

        switch (FlipX)
        {
            case true:
                Origin.X = (int)(-origin.X + ImageWidth - 12 + BrowPos.X - BodyRelMove.X);
                break;
            case false:
                Origin.X = (int)(origin.X + BrowPos.X - 2 - BodyRelMove.X);
                break;
        }
        Origin.Y = (int)(origin.Y + BrowPos.Y - OffY + BodyRelMove.Y);

    }

    public override void DoDraw()
    {
        if (ImageNode == null)
            return;
        base.DoDraw();
    }
}



```

`MapleNecrocer/Client/MapleMap.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WzComparerR2.WzLib;
using WzComparerR2.MapRender2;
using Microsoft.Xna.Framework;
using WzComparerR2.Rendering;
using MonoGame.SpriteEngine;
using GameUI;
using MonoGame.UI.Forms;

namespace MapleNecrocer;

public enum GameMode { Play, Viewer };

public struct MapNameRec
{
    public string ID;
    public string MapName;
    public string StreetName;

    public MapNameRec(string id, string mapName, string streetName)
    {
        ID = id;
        MapName = mapName;
        StreetName = streetName;
    }
}

public class Map
{
    public class FadeScreen
    {
        public static int AlphaCounter, AValue;
        public static bool DoFade;
    }
    public static Dictionary<string, MapNameRec> MapNameList = new();
    public static string ID;
    public static Wz_Node Img;
    public static Microsoft.Xna.Framework.Point DisplaySize = new(1024, 768);
    public static Dictionary<string, int> Info = new();
    public static int Left, Top, Right, Bottom, SaveMapBottom;
    public static bool ShowTile = true;
    public static bool ShowObj = true;
    public static bool ShowBack = true;
    public static bool ShowFront = true;
    public static bool ShowNpc = true;
    public static bool ShowNpcName = true;
    public static bool ShowNpcChat = true;
    public static bool ShowMob = true;
    public static bool ShowMobName = false;
    public static bool ShowID = false;
    public static bool ShowPortal = true;
    public static bool ShowPortalInfo = false;
    public static bool ShowBgmName;
    public static bool ShowFootholds;
    public static bool ShowPlayer = true;
    public static bool ShowMiniMap=true;

    public static Vector2 Center;
    public static Vector2 CameraSpeed;
    public static int OffsetY;
    public static ResourceLoader ResLoader;
    public static bool FirstLoaded;
    public static bool ReLoad;
    public static bool UseD2D = true;
    public static string NpcNameTagFont;
    public static string NpcBalloonFont;
    public static string MobLvFont;
    public static string ToolTipFont;
    public static GameMode GameMode = GameMode.Play;
    public static bool ResetPos;
    public static bool SaveMap;
    public static string BgmName;
    private static List<string> BgmList = new();
    static MiniMap MiniMap;

    public static int MeasureStringX(string FontNameKey, string Text)
    {
        if (UseD2D)
            return (int)EngineFunc.D2DFonts[FontNameKey].MeasureString(Text).X;
        else
            return (int)EngineFunc.Fonts[FontNameKey].MeasureString(Text).X;
    }

    public static void CreateResLoader()
    {
        if (ResLoader != null)
        {
            ResLoader.ClearAnimationCache();
            ResLoader.Dispose();
        }
        ResLoader = new ResourceLoader(RenderFormDraw.Instance.GraphicsDevice);
    }
    public static void LoadMap(string ID)
    {
        if (ID == null)
            return;
        if (EngineFunc.SpriteEngine.SpriteList != null)
        {
            foreach (var I in EngineFunc.SpriteEngine.SpriteList)
            {
                if (I.Tag != 1)
                    I.Dead();


                if (I is Mob)
                {
                    var Mob = I as Mob;
                    if (Mob.RenderTarget != null)
                    {
                        Mob.RenderTarget.Dispose();
                    }
                }
            }

            EngineFunc.SpriteEngine.Dead();
        }

        for(int i=0;i<PlayerEx.PlayerExList.Count;i++)
        {
            if (PlayerEx.PlayerExList[i]!=null)
                PlayerEx.PlayerExList[i].RemoveSprites();
        }
        PlayerEx.PlayerExList.Clear();


        Wz.Data.Clear();
        //  if(Wz.Data!=null)
        foreach (var i in Wz.ImageLib)
            i.Value.Dispose();
        Wz.ImageLib.Clear();


        if (EngineFunc.SpriteEngine.ImageLib != null)
        {
            foreach (var Iter in EngineFunc.SpriteEngine.ImageLib)
                Iter.Value.Dispose();
        }

        if (EngineFunc.SpriteEngine.ImageLib != null)
            EngineFunc.SpriteEngine.ImageLib.Clear();

        //
        string LeftNum = ID.LeftStr(1);
        Map.Img = Wz.GetNode("Map/Map/Map" + LeftNum + "/" + ID + ".img");


        Map.Info.Clear();
        foreach (var Iter in Map.Img.GetNode("info").Nodes)
            Map.Info.Add(Iter.Text, Iter.ToInt());

        Map.Info.Add("MapWidth", Map.Img.GetValue2("miniMap/width", 0));
        Map.Info.Add("MapHeight", Map.Img.GetValue2("miniMap/height", 0));
        Map.Info.Add("centerX", Map.Img.GetValue2("miniMap/centerX", DisplaySize.X / 2));
        Map.Info.Add("centerY", Map.Img.GetValue2("miniMap/centerY", DisplaySize.Y / 2));


        MapPortal.Create();
        FootholdTree.CreateFootholds();
        if (Map.Info.ContainsKey("VRLeft"))
        {
            EngineFunc.SpriteEngine.Camera.X = Map.Info["VRLeft"];
            EngineFunc.SpriteEngine.Camera.Y = Map.Info["VRBottom"]; // - DisplaySize.y;
            Map.Left = Map.Info["VRLeft"];
            Map.Bottom = Map.Info["VRBottom"] + 15;
            if (Map.Img.GetNode("miniMap") != null)
            {
                int Bottom2 = -Map.Info["centerY"] + Map.Info["MapHeight"] - 55;
                if (Map.Bottom < Bottom2 - 100)
                    Map.Bottom = Bottom2;
            }
            Map.Top = Map.Info["VRTop"];
            Map.Right = Map.Info["VRRight"];
            Map.Info.AddOrReplace("MapWidth", Map.Right - Map.Left);
            //Map.Info.AddOrReplace("MapHeight", Math.Abs(Map.Top) + Math.Abs(Map.Bottom));
        }
        else
        {
            Map.Left = FootholdTree.MinX1.First();
            Map.Bottom = -Map.Info["centerY"] + Map.Info["MapHeight"] - 55;
            Map.SaveMapBottom = Map.Bottom - 55;
            Map.Top = -Map.Info["centerY"] + 50;
            Map.Right = FootholdTree.MaxX2.Last();
            Map.Info.AddOrReplace("MapWidth", Map.Right - Map.Left);
            EngineFunc.SpriteEngine.Camera.X = Map.Left;
            EngineFunc.SpriteEngine.Camera.Y = Map.Bottom;

        }

        Map.CreateResLoader();

        LadderRope.Create();
        MapTile.Create();

        Obj.Create();

        //Map.OffsetY = (DisplaySize.Y - 600) / 2;
        Back.Create();

        Particle.Create();
      
        if (!FirstLoaded)
        {
            string Name = Wz.GetNode("String/Mob.img/100100/name").ToStr();
            switch (Name)
            {
                case "Snail":
                    Wz.Region = "GMS";
                    Map.NpcNameTagFont = "Arial13";
                    Map.NpcBalloonFont = "Arial12";
                    Map.MobLvFont = "Arial10";
                    Map.ToolTipFont = "Arial14";
                    UseD2D = true;
                    break;
                case "달팽이":
                    Wz.Region = "KMS";
                    Map.NpcNameTagFont = "Arial12";
                    Map.NpcBalloonFont = "Arial12";
                    Map.MobLvFont = "Arial10";
                    Map.ToolTipFont = "Arial14";
                    UseD2D = true;
                    break;
                case "デンデン":
                    Wz.Region = "JMS";
                    Map.NpcNameTagFont = "MSGothic12";
                    Map.NpcBalloonFont = "Verdana11";
                    Map.MobLvFont = "Verdana9";
                    Map.ToolTipFont = "MSGothic14";
                    UseD2D = false;
                    break;
                default:
                    Wz.Region = "TMS";
                    Map.NpcNameTagFont = "SimSun13";
                    Map.NpcBalloonFont = "Verdana11";
                    Map.MobLvFont = "Verdana9";
                    Map.ToolTipFont = "SimSun14";
                    UseD2D = false;
                    break;
                  
            }
            Player.SpawnNew();
            NameTag.Create("SuperGM");
            GameCursor.LoadRes("0");
            if (Wz.HasNode("UI/Basic.img/Cursor/12"))
                GameCursor.LoadRes("12");
            else
                GameCursor.IsDataWz = true;
            MiniMap = new MiniMap();
            UI.ControlManager.Controls.Add(MiniMap);
            if(Wz.HasNode("UI/UIWindow4.img"))
                MiniMap.Version=3;
            else
                MiniMap.Version=1;
            FirstLoaded = true;
        }

        MiniMap.ReDraw();
        Npc.Create();
        Mob.Create();
        ObjToolTip.Create();

        Skill.PlayEnded = true;

        Map.OffsetY = (Map.DisplaySize.Y - 600) / 2;
        Back.ResetPos = true;
        Particle.ResetPos = true;
        EngineFunc.SpriteEngine.Move(1);

        BgmName = Map.Img.GetStr("info/bgm");
        BgmList.Add(BgmName);
        if (BgmList.Count > 2)
            BgmList.RemoveAt(0);
        if (BgmList.Count > 1)
        {
            if (BgmName == BgmList[0])
                return;
        }

        if (BgmName.Contains(".img"))
        {
            Music.Play("Sound/" + BgmName);
        }
        else
        {
            var Split = BgmName.Split('/');
            string BgmPath = "Sound/" + Split[0] + ".img/" + Split[1];
            Music.Play(BgmPath);
        }
        // if( EngineFunc.SpriteEngine.SpriteList==null)
    }

}


```

`MapleNecrocer/Client/MapleTV.cs`:

```cs
using MonoGame.SpriteEngine;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.Intrinsics.X86;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using WzComparerR2.WzLib;
using Microsoft.Xna.Framework;
namespace MapleNecrocer;

public class MapleTV : SpriteEx
{
    public MapleTV(Sprite Parent) : base(Parent)
    {
    }
    float Time;
    int AD, ADCount, Frame;
    string ImagePath;
    public static void Create(int PosX, int PosY, int msgX, int msgY, int adX, int adY, int ZLayer)
    {
        if (Wz.GetNodeA("UI/MapleTV.img") == null)
            return;
        string Path = "UI/MapleTV.img/TVbasic/0";
        Wz.DumpData(Wz.GetNodeA(Path), Wz.Data, Wz.ImageLib);
        var Sprite = new SpriteEx(EngineFunc.SpriteEngine);
        Sprite.ImageLib = Wz.ImageLib;
        // Sprite.Path = Path;
        Sprite.ImageNode = Wz.Data[Path];
        if (msgX <= adX)
            Sprite.X = PosX + msgX;
        else
            Sprite.X = PosX + msgX + adX;
        Sprite.Y = PosY + msgY + Sprite.ImageHeight;
        Sprite.Z = ZLayer+1;
        Sprite.IntMove =true;
        Sprite.Width = Sprite.ImageWidth;
        Sprite.Height = Sprite.ImageHeight;
        Wz_Vector origin = WzDict.GetVector(Path + "/origin");
        Sprite.Origin.X = origin.X;
        Sprite.Origin.Y = origin.Y;

        int ACount = 0;
        Path = "UI/MapleTV.img/TVmedia";
        foreach (var Iter in Wz.GetNodeA(Path).Nodes)
            ACount += 1;
        Wz.DumpData(Wz.GetNodeA(Path), Wz.Data, Wz.ImageLib);
        var MapleTV = new MapleTV(EngineFunc.SpriteEngine);
        MapleTV.ImageLib = Wz.ImageLib;
        MapleTV.ImageNode = Wz.Data[Path + "/0/0"];
        MapleTV.X = PosX + adX;
        MapleTV.Y = PosY + adY + MapleTV.ImageHeight;
        MapleTV.Z = ZLayer + 50;
        MapleTV.IntMove = true;
        MapleTV.ADCount = ACount;
        MapleTV.Width = Sprite.ImageWidth;
        MapleTV.Height = Sprite.ImageHeight;
        origin = WzDict.GetVector(Path + "/0/0/origin");
        MapleTV.Origin.X = origin.X;
        MapleTV.Origin.Y = origin.Y;
    }

    public override void DoMove(float Delta)
    {
        string S1 = "UI/MapleTV.img/TVmedia/";
        string ImagePath = S1 + AD + "/" + Frame;
        ImageNode = Wz.Data[ImagePath];
        int Delay = WzDict.GetInt(ImagePath + "/delay", 100);
        Time += 16.66f * Delta;
        Random Random = new();
        if (Time > Delay)
        {
            Frame += 1;
            if (!Wz.HasData(S1 + AD + "/" + Frame))
            {
                Frame = 0;
                AD = Random.Next(ADCount);
            }
            Time = 0;
        }
        Wz_Vector origin = WzDict.GetVector(ImagePath + "/origin");
        Origin.X = origin.X;
        Origin.Y = origin.Y;
    }
}


```

`MapleNecrocer/Client/Mob.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WzComparerR2.WzLib;
using WzComparerR2.PluginBase;
using Spine;
using WzComparerR2.Animation;
using Microsoft.Xna.Framework;
using System.Security.Cryptography;
using System.Numerics;
using System.Threading;
using Vector2 = Microsoft.Xna.Framework.Vector2;
using System.Xml.Linq;
using System.Drawing;
using static System.Net.Mime.MediaTypeNames;
using WzComparerR2.CharaSim;
using WzComparerR2.Text;
using static System.Windows.Forms.VisualStyles.VisualStyleElement.StartPanel;
using System.Reflection.Metadata;
using static MapleNecrocer.Skill;
using Microsoft.Xna.Framework.Graphics;

namespace MapleNecrocer;
enum MoveDirection { Left, Right, None }
enum MoveType { Stand, Move, Jump, Fly }

public class Mob : JumperSprite
{
    public Mob(Sprite Parent) : base(Parent)
    {
        SpriteSheetMode = SpriteSheetMode.NoneSingle;
        CollideMode = CollideMode.Rect;
        IntMove = true;
       
    }
    int Frame;
    float Time;
    public string ID;
    string Action;
    Foothold FH, WallFH;
    Foothold BelowFH;
    int RX0, RX1;
    MoveDirection MoveDirection;
    float MoveSpeed, FlySpeed;
    string MobName;
    int Level;
    int NameWidth, IDWidth, LevelWidth;
    int FrameCount;
    bool NoFlip;
    MoveType MoveType;
    int FallEdge, JumpEdge;
    int CosY, SrcY;
    public bool GetHit1;
    public bool Hit;
    bool AnimEnd;
    int Value;
    bool AnimRepeat;
    bool AnimZigzag;
    Wz_Vector LT, RB;
    public int Left, Top, Right, Bottom;
    //Vector2 Head;
    //Vector2 Origin;
    public Int64 HP;
    public bool Die;
    string DieActionName;
    // int HeadX;
    public Vector2 Head;
    public int HitIndex;
    public int HeadX;
    public string LocalID;
    static Dictionary<string, int> FrameData = new();
    public static List<string> MobList = new();
    public static List<string> SummonedList = new();
    public MobCollision[] MobCollision = new MobCollision[7];
    int NameTagWidth;
    public RenderTarget2D RenderTarget;
    public RenderTarget2D IDRenderTarget;
    public static void Create()
    {
        Mob.MobList.Clear();
        Mob.FrameData.Clear();
        foreach (var Iter in Map.Img.Nodes["life"].Nodes)
        {
            if (Iter.Nodes["type"] != null)
            {
                if (Iter.GetStr("type") == "m")
                    Mob.Spawn(Iter.GetStr("id"), Iter.GetInt("x"), Iter.GetInt("cy"), Iter.GetInt("rx0"), Iter.GetInt("rx1"));
            }
            else
            {
                foreach (var Iter2 in Iter.Nodes)
                {
                    if (Iter2.GetStr("type") == "n")
                        Mob.Spawn(Iter2.GetStr("id"), Iter2.GetInt("x"), Iter2.GetInt("cy"), Iter2.GetInt("rx0"), Iter2.GetInt("rx1"));
                }
            }
        }
    }

    public static void Spawn(string ID, int PosX, int PosY, int RX0 = 0, int RX1 = 0)
    {
        if (!MobList.Contains(ID))
        {
            Wz.DumpData(Wz.GetNode("Mob/" + ID + ".img"), Wz.Data, Wz.ImageLib);
       
            MobList.Add(ID);
        }
        var Link = Wz.GetNode("Mob/" + ID + ".img/info/link");
        string TestID;
        if (Link != null)
        {
            var LinkID = Link.ToStr();
            TestID = LinkID;
            if (!Wz.Data.ContainsKey("'Mob/" + LinkID + ".img"))
                Wz.DumpData(Wz.GetNode("Mob/" + LinkID + ".img"), Wz.Data, Wz.ImageLib);
        }
        else
        {
            TestID = ID;
        }
        if ((Wz.GetNodeA("Mob/" + TestID + ".img/stand/0") == null) && (Wz.GetNodeA("Mob/" + TestID + ".img/fly/0") == null))
            return;
        //Create Mob
        var Mob = new Mob(EngineFunc.SpriteEngine);

        Mob.LocalID = ID;

        if (Link != null)
            Mob.ID = Link.ToStr();
        else
            Mob.ID = ID;
        Mob.Value = 1;

        foreach (var Iter in Wz.GetNode("Mob/" + Mob.ID + ".img").Nodes)
        {
            int c = 0;
            foreach (var Iter2 in Iter.Nodes)
            {
                if (Char.IsNumber(Iter2.Text[0]))
                    c += 1;
            }
            FrameData.AddOrReplace(Mob.ID + Iter.Text + "/FrameCount", c - 1);
        }

        var InfoNode = Wz.GetNode("Mob/" + Mob.LocalID + ".img/info");
        if (InfoNode.Get("speed") != null)
            Mob.MoveSpeed = (1 + (float)InfoNode.GetInt("speed") / 100) * 2;
        else
            Mob.MoveSpeed = 2;
        if (InfoNode.Get("flySpeed") != null)
            Mob.FlySpeed = (1 + InfoNode.GetInt("flySpeed") / 100) * 2;
        else
            Mob.FlySpeed = 2;

        // int Hp=InfoNode.GetInt("maxHP");
        Mob.HP = 2000000;
        Mob.Level = InfoNode.GetInt("level", 1);

        Mob.MoveType = MoveType.Move;
        Mob.Action = "stand";

        Random Random = new Random();
        var ImgNode = Wz.GetNode("Mob/" + Mob.ID + ".img");
        if (ImgNode.Nodes["move"] == null)
        {
            Mob.MoveSpeed = 0;
            Mob.MoveType = MoveType.Stand;
        }
        if (ImgNode.Nodes["jump"] != null)
            Mob.MoveType = MoveType.Jump;
        if (ImgNode.Nodes["fly"] != null)
        {
            Mob.MoveType = MoveType.Fly;
            Mob.Action = "fly";
            Mob.CosY = Random.Next(256);
        }
        if (ImgNode.Nodes["die1"] != null)
            Mob.DieActionName = "die1";
        else
            Mob.DieActionName = "die";

        Mob.ImageLib = Wz.ImageLib;
        Mob.ImageNode = Wz.Data["Mob/" + Mob.ID + ".img/" + Mob.Action + "/0"];
        Vector2 Pos = FootholdTree.Instance.FindBelow(new Vector2(PosX, PosY - 3), ref Mob.BelowFH);
        Mob.X = Pos.X;
        Mob.Y = Pos.Y;
        Mob.SrcY = (int)Mob.Y;
        Mob.FH = Mob.BelowFH;
        Mob.Z = Mob.FH.Z * 100000 + 6000;
        Mob.JumpSpeed = 0.6f;
        Mob.JumpHeight = 9;
        Mob.MaxFallSpeed = 8;
        Mob.RX0 = RX0;
        Mob.RX1 = RX1;
        Mob.Width = Mob.ImageWidth;
        Mob.Height = Mob.ImageHeight;
        Mob.FlipX = Random.Next(2).ToBool();
        Mob.MoveDirection = MoveDirection.None;
        Mob.CanCollision = true;
        Mob.AnimRepeat = true;
        Mob.DoAnimate = false;
        if (ImgNode.GetInt("info/noFlip").ToBool())
            Mob.FlipX = false;
        Mob.LevelWidth = Map.MeasureStringX(Map.MobLvFont, "Lv." + Mob.Level);
        Mob.MobName = Wz.GetNodeA("String/Mob.img/" + Mob.LocalID.IntID()).GetStr("name");
        Mob.NameWidth = Map.MeasureStringX(Map.NpcNameTagFont, Mob.MobName);
        Mob.IDWidth = Map.MeasureStringX(Map.NpcNameTagFont, "ID:" + Mob.LocalID);
        Mob.NameTagWidth = 10 + Mob.LevelWidth + Mob.NameWidth;
        Mob.Engine.Canvas.DrawTarget(ref Mob.RenderTarget, Mob.NameTagWidth, 25, () =>
        {
            Mob.RenderTargetFunc();
        });

        Mob.Engine.Canvas.DrawTarget(ref Mob.IDRenderTarget, Mob.IDWidth+10, 25, () =>
        {
            Mob.IDRenderTargetFunc();
        });

        Wz_Vector origin = WzDict.GetVector("Mob/" + Mob.ID + ".img/" + Mob.Action + "/0/origin");
        if (Mob.FlipX)
            Mob.Origin.X = -origin.X + Mob.ImageWidth;
        else
            Mob.Origin.X = origin.X;
        Mob.Origin.Y = origin.Y;
    }

    void RenderTargetFunc()
    {
        float LvPosX = LevelWidth - (NameWidth / 2) + 4;
        Engine.Canvas.FillRoundRect(0, 5, LevelWidth + 5, 11, new Microsoft.Xna.Framework.Color(0, 0, 0, 150));
        Engine.Canvas.DrawString(Map.MobLvFont, "Lv." + Level, 2, 5, Microsoft.Xna.Framework.Color.White);

        float NamePosX = LevelWidth + 6;
        Engine.Canvas.FillRoundRect((int)NamePosX, 3, NameWidth + 4, 15, new Microsoft.Xna.Framework.Color(0, 0, 0, 150));
        Engine.Canvas.DrawString(Map.NpcNameTagFont, MobName, NamePosX + 2, 4, Microsoft.Xna.Framework.Color.White);
    }

    void IDRenderTargetFunc()
    {
        
        Engine.Canvas.FillRoundRect(0, 1, IDWidth + 5, 15, new Microsoft.Xna.Framework.Color(0, 0, 0, 150));
        Engine.Canvas.DrawString(Map.NpcNameTagFont, "ID:" + ID, 2, 2, Microsoft.Xna.Framework.Color.Cyan);
    }

    public override void DoMove(float Delta)
    {
        base.DoMove(Delta);

        int X1 = FH.X1;
        int Y1 = FH.Y1;
        int X2 = FH.X2;
        int Y2 = FH.Y2;
        string NewAction = "";
        if (FrameData.ContainsKey(ID + Action + "/FrameCount"))
            FrameCount = FrameData[ID + Action + "/FrameCount"];
        string ImagePath = "Mob/" + ID + ".img/" + Action + "/" + Frame;
        ImageNode = Wz.Data[ImagePath];
        int AnimDelay = WzDict.GetInt(ImagePath + "/delay", 100);
        int a1 = WzDict.GetInt(ImagePath + "/a1", 255);

        if (Wz.HasData(ImagePath + "/lt"))
        {
            LT = WzDict.GetVector(ImagePath + "/lt");
            RB = WzDict.GetVector(ImagePath + "/rb");
            switch (FlipX)
            {
                case true:
                    Right = (int)X - LT.X;
                    Left = (int)X - RB.X;
                    break;
                case false:
                    Left = (int)X + LT.X;
                    Right = (int)X + RB.X;
                    break;
            }
            Top = (int)Y + LT.Y;
            Bottom = (int)Y + RB.Y;
        }
        CollideRect = SpriteUtils.Rect(Left, Top, Right, Bottom);

        if (Wz.HasData(ImagePath + "/head"))
        {
            Wz_Vector head = WzDict.GetVector(ImagePath + "/head");
            if ((FlipX != Game.Player.FlipX) || (!GetHit1))
            {
                if (FlipX)
                    Head.X = (int)X - head.X - 20;
                else
                    Head.X = (int)X + head.X - 20;
            }
            else
            {
                if (FlipX)
                    Head.X = (int)X - head.X - 20;
                else
                    Head.X = (int)X + head.X - 20;
            }
            Head.Y = (int)Y + head.Y;
        }

        if ((Action == "hit1") || (Action == DieActionName))
            AnimRepeat = false;
        else
            AnimRepeat = true;
        if (Wz.HasData("Mob/" + ID + ".img/" + Action + "/zigzag"))
            AnimZigzag = true;
        else
            AnimZigzag = false;

        Time += 17;
        if (Time > AnimDelay)
        {
            Time = 0;
            if (AnimZigzag)
            {
                Frame += Value;
                if ((Frame >= FrameCount) || (Frame <= 0))
                    Value = -Value;
            }
            else
            {
                Frame += 1;
                AnimEnd = false;
                if (Frame > FrameCount)
                {
                    if (AnimRepeat)
                        Frame = 0;
                    else
                    {
                        Frame -= 1;
                        AnimEnd = true;
                    }
                }
            }
        }

        if (!Die)
        {
            Random Random = new Random();
            if ((MoveType != MoveType.Stand) && (MoveType != MoveType.Fly))
            {
                switch (Random.Next(200))
                {
                    case 50:
                        FlipX = false;
                        MoveDirection = MoveDirection.Left;
                        break;
                    case 100:
                        FlipX = true;
                        MoveDirection = MoveDirection.Right;
                        break;
                    case 150:
                        MoveDirection = MoveDirection.None;
                        break;
                    case 199:
                        if (!GetHit1)
                        {
                            if (MoveType == MoveType.Jump)
                            {
                                DoJump = true;
                            }
                        }
                        break;
                }
            }
        }


        if ((!GetHit1) && (!Die))
        {
            if (JumpState != JumpState.jsNone)
            {
                NewAction = "jump";
                Frame = 0;
            }
            else
            {
                switch (MoveDirection)
                {
                    case MoveDirection.Left:
                    case MoveDirection.Right:
                        NewAction = "move";
                        break;
                    case MoveDirection.None:
                        NewAction = "stand";
                        break;
                }
            }
        }

        if ((AnimEnd) && (Action == "hit1"))
        {
            Time = 0;
            Frame = 0;
            GetHit1 = false;
        }

        if (Hit)
        {
            if (GetHit1)
            {
                if ((Action == "hit1") || (Action == DieActionName))
                {
                    if (Frame == 0)
                    {

                        if (Skill.Attacking)
                        {
                            if (Skill.MultiStrike)
                                DamageNumber.Create(Game.Damage, (int)HeadX, (int)Head.Y + HitIndex * (-30));
                            else
                                DamageNumber.Create(Game.Damage, (int)Head.X, (int)Head.Y);
                            SkillHitEffect.Create(this);
                        }
                        else
                        {
                            DamageNumber.Create(Game.Damage, (int)Head.X, (int)Head.Y);
                        }
                    }
                    Hit = false;
                }
            }

            // no push
            if (!GetHit1)
            {
                DamageNumber.Create(Game.Damage, (int)Head.X, (int)Head.Y);
                Hit = false;
            }
        }

        if ((GetHit1) && (!Die))
        {
            if (!Wz.HasData("Mob/" + ID + ".img/hit1/0"))
            {
                GetHit1 = false;
            }
            if (Action != "hit1")
            {
                AnimEnd = false;
                Frame = 0;
                Time = 0;
                NewAction = "hit1";
            }
            // -->player   -->mob
            if ((FlipX == Game.Player.FlipX) && (Time == 0))
            {
                FlipX = !FlipX;
                switch (MoveDirection)
                {
                    case MoveDirection.Left:
                        MoveDirection = MoveDirection.Right;
                        break;
                    case MoveDirection.Right:
                        MoveDirection = MoveDirection.Left;
                        break;
                    case MoveDirection.None:
                        if (FlipX)
                            MoveDirection = MoveDirection.Right;
                        else
                            MoveDirection = MoveDirection.Left;
                        break;
                }
            }
            // player-->  <--Mob
            if ((FlipX != Game.Player.FlipX) && (Time == 0))
            {
                if (MoveDirection == MoveDirection.None)
                {
                    if (FlipX)
                        MoveDirection = MoveDirection.Right;
                    else
                        MoveDirection = MoveDirection.Left;
                }
            }
        }

        if (Die)
        {
            if (Action != "die1")
            {
                AnimEnd = false;
                Frame = 0;
                if (!Wz.HasData("Mob/" + ID + ".img/" + DieActionName + "/0"))
                    Frame = 1;
                if ((FrameCount > 3) && (!Wz.HasData("Mob/" + ID + ".img/" + DieActionName + "/3")))
                    Frame = 4;
                Time = 0;
                NewAction = DieActionName;
            }

            if (!Wz.HasData("Mob/" + ID + ".img/" + DieActionName + "/" + Frame))
                Dead();
        }

        if (a1 != -1)
        {
            float AniAlpha = 255 - (255 - a1) * Time / AnimDelay;
            if ((AniAlpha < 255) && (AniAlpha > 0))
                Alpha = (byte)AniAlpha;
            // if Alpha <=10 then Dead;
        }

        if ((AnimEnd) && (Action == DieActionName))
        {
            //TMobDrop.Drop(Trunc(X), Trunc(Y), Random(1), DropList);
            Dead();
        }

        if (Wz.HasData("Mob/" + ID + ".img/" + NewAction + "/" + Frame))
        {
            Action = NewAction;
        }
        else
        {
            if (Action != DieActionName)
            {
                if (Wz.HasData("Mob/" + ID + ".img/" + NewAction + "/" + Frame + 1))
                    Action = "Mob/" + ID + ".img/" + NewAction + "/" + Frame + 1;
                else
                    Frame = 0;
            }
            if (AnimZigzag)
                Frame = 0;
        }

        if (JumpState == JumpState.jsFalling)
        {
            Vector2 Below = FootholdTree.Instance.FindBelow(new Vector2(X, Y - VelocityY - 2), ref BelowFH);
            if (Y >= Below.Y - 3)
            {
                Y = Below.Y;
                // MaxFallSpeed :=10;
                JumpState = JumpState.jsNone;
                FH = BelowFH;
                Z = FH.Z * 100000 + 6000;
            }
        }
        int Direction;
        switch (MoveDirection)
        {
            case MoveDirection.Left:
                Direction = GetAngle256(X2, Y2, X1, Y1);
                if ((!FH.IsWall()) && (!GetHit1) && (!Die))
                {
                    X += (float)(Sin256(Direction) * MoveSpeed);
                    Y -= (float)(Cos256(Direction) * MoveSpeed);
                }
                if ((GetHit1) && (!Die) && (Time < 300))
                {
                    X += (float)(Sin256(Direction) * -1.3f);
                    Y -= (float)(Cos256(Direction) * -1.3f);
                }
                FallEdge = -999999;
                JumpEdge = -999999;
                if (MoveType == MoveType.Move)
                {
                    // no fh
                    if (FH.Prev == null)
                        FallEdge = FH.X1;
                    // Wall's edge down
                    if ((FH.Prev != null) && (FH.Prev.IsWall()))
                        FallEdge = FH.X1;
                    if (X < FallEdge)
                    {
                        X = FallEdge;
                        FlipX = true;
                        MoveDirection = MoveDirection.Right;
                    }
                }

                if (MoveType == MoveType.Jump)
                {
                    if (X <= RX0)
                    {
                        X = RX0;
                        FlipX = true;
                        MoveDirection = MoveDirection.Right;
                    }
                    // .--------.
                    if (FH.Prev == null)
                        JumpEdge = FH.X1;
                    // ┌--- <--
                    if ((FH.Prev != null) && (FH.Prev.IsWall()) && (FH.Prev.Y1 > Y))
                        FallEdge = FH.X1;
                    if (X < FallEdge)
                        JumpState = JumpState.jsFalling;
                    if (X < JumpEdge)
                        DoJump = true;
                    // -->  ---┐  <--
                    WallFH = FootholdTree.Instance.FindWallR(new Vector2(X + 4, Y - 4));
                    if ((WallFH != null) && (FH.Z == WallFH.Z))
                    {
                        if (X < WallFH.X1 + 30)
                            DoJump = true;
                        if (X <= WallFH.X1)
                        {
                            X = WallFH.X1 + MoveSpeed;
                            if (JumpState == JumpState.jsNone)
                            {
                                FlipX = true;
                                MoveDirection = MoveDirection.Right;
                            }
                        }
                    }
                }

                // walk left
                if ((X <= FH.X1) && (FH.PrevID != 0) && (!FH.IsWall()) && (!FH.Prev.IsWall()))
                {
                    if (JumpState == JumpState.jsNone)
                    {
                        FH = FH.Prev;
                        X = FH.X2;
                        Y = FH.Y2;
                        Z = FH.Z * 100000 + 6000;
                    }
                }
                break;

            case MoveDirection.Right:
                Direction = GetAngle256(X1, Y1, X2, Y2);
                if ((!FH.IsWall()) && (!GetHit1) && (!Die))
                {
                    X += (float)(Sin256(Direction) * MoveSpeed);
                    Y -= (float)(Cos256(Direction) * MoveSpeed);
                }
                if ((GetHit1) && (!Die) && (Time < 300))
                {
                    X += (float)(Sin256(Direction) * -1.3f);
                    Y -= (float)(Cos256(Direction) * -1.3f);
                }
                FallEdge = 999999;
                JumpEdge = 999999;
                if (MoveType == MoveType.Move)
                {
                    if (FH.Next == null)
                        FallEdge = FH.X2 + 5;
                    // Wall down
                    if ((FH.Next != null) && (FH.Next.IsWall()))
                        FallEdge = FH.X2;
                    if (X > FallEdge)
                    {
                        X = FallEdge;
                        FlipX = false;
                        MoveDirection = MoveDirection.Left;
                    }
                }

                if (MoveType == MoveType.Jump)
                {
                    if (X >= RX1)
                    {
                        X = RX1;
                        FlipX = false;
                        MoveDirection = MoveDirection.Left;
                    }
                    if (FH.Next == null) // .--------.
                        JumpEdge = FH.X2;
                    // -->  ----┐
                    if ((FH.Next != null) && (FH.Next.IsWall()) && (FH.Next.Y2 > Y))
                        FallEdge = FH.X2;

                    if (X > FallEdge)
                        JumpState = JumpState.jsFalling;
                    if (X > JumpEdge)
                        DoJump = true;
                    // -->  ┌.....
                    WallFH = FootholdTree.Instance.FindWallL(new Vector2(X - 4, Y - 4));
                    if ((WallFH != null) && (FH.Z == WallFH.Z))
                    {
                        if (X > WallFH.X1 - 30)
                            DoJump = true;
                        if (X >= WallFH.X1)
                        {
                            X = WallFH.X2 - MoveSpeed;
                            if (JumpState == JumpState.jsNone)
                            {
                                FlipX = false;
                                MoveDirection = MoveDirection.Left;
                            }
                        }
                    }
                }
                // walk right
                if ((X >= FH.X2) && (FH.NextID != 0) && (!FH.IsWall()) && (!FH.Next.IsWall()))
                {
                    if (JumpState == JumpState.jsNone)
                    {
                        FH = FH.Next;
                        X = FH.X1;
                        Y = FH.Y1;
                        Z = FH.Z * 100000 + 6000;
                    }
                }
                break;
        }

        if (MoveType == MoveType.Fly)
        {
            Random Random = new();
            switch (Random.Next(250))
            {
                case 50:
                    FlipX = true;
                    break;
                case 200:
                    FlipX = false;
                    break;
            }
            if (X <= RX0)
                FlipX = true;
            if (X >= RX1)
                FlipX = false;

            switch (FlipX)
            {
                case true:
                    X += 1.5f * FlySpeed;
                    break;
                case false:
                    X -= 1.5f * FlySpeed;
                    break;
            }
            CosY += 7;
            Y = SrcY - (float)(Cos256(CosY) * 16);
        }

        Wz_Vector origin = WzDict.GetVector(ImagePath + "/origin");
        if (FlipX)
            Origin.X = -origin.X + ImageWidth;
        else
            Origin.X = origin.X;
        Origin.Y = origin.Y;
    }

    public override void DoDraw()
    {
        if (!Map.ShowMob)
            return;
        base.DoDraw();
        if (Map.ShowMobName)
        {
            int WX = (int)X - (int)Engine.Camera.X;
            int WY = (int)Y - (int)Engine.Camera.Y;
            Engine.Canvas.Draw(RenderTarget, WX - NameTagWidth / 2, WY, MonoGame.SpriteEngine.BlendMode.NonPremultiplied2);
        }

        if(Map.ShowID)
        {
            int WX = (int)X - (int)Engine.Camera.X;
            int WY = (int)Y - (int)Engine.Camera.Y;
            Engine.Canvas.Draw(IDRenderTarget, WX - IDWidth / 2, WY+20, MonoGame.SpriteEngine.BlendMode.NonPremultiplied2);
        }
    }
}

public class MobCollision : SpriteEx
{
    public MobCollision(Sprite Parent) : base(Parent)
    {
        CollideMode = CollideMode.Rect;
        CanCollision = true;
    }

    public Mob Owner;
    // int Left, Top, Right, Bottom;
    int Counter;
    public int Index;
    public int StartTime;
    public override void DoMove(float Delta)
    {
        base.DoMove(Delta);
        CollideRect = SpriteUtils.Rect(Owner.Left, Owner.Top, Owner.Right, Owner.Bottom);
        Counter += 1;
        if (Counter >= StartTime)
        {
            Collision();
            Dead();
        }
    }

    public override void OnCollision(Sprite sprite)
    {
        if (sprite is SkillCollision)
        {
            if (Owner.HP > 0)
            {
                Owner.HitIndex = this.Index;
                if (this.Index == 0)
                    Owner.HeadX = (int)Owner.Head.X;
                Owner.Hit = true;
                Random Random = new Random();
                Game.Damage = 50000 + Random.Next(550000);
                Owner.HP -= Game.Damage;
               
                if (Wz.GetNode("Sound/Mob.img/" + Owner.ID + "/Damage") != null)
                    Sound.Play("Sound/Mob.img/" + Owner.ID + "/Damage");
                else if (Wz.GetNode("Sound/Mob.img/" + Owner.ID + "/Hit1") != null)
                    Sound.Play("Sound/Mob.img/" + Owner.ID + "/Hit1");
                if (Wz.Data.ContainsKey("Mob/" + Owner.ID + ".img/hit1"))
                {
                    Owner.GetHit1 = true;
                }
            }

            if (Owner.HP <= 0 && !Owner.Die)
            {
                Sound.Play("Sound/Mob.img/"+ Owner.ID + "/Die");
                Owner.Die = true;
                //  Collisioned := False;
                // Dead;
            }
        }
    }

    public override void DoDraw()
    {
        if (ImageNode == null) return;
    }

}



```

`MapleNecrocer/Client/Morph.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WzComparerR2.WzLib;
using Keyboard = SpriteEngine.Keyboard;
using Input = Microsoft.Xna.Framework.Input.Keys;
using Spine;

namespace MapleNecrocer;

public class Morph : SpriteEx
{
    public Morph(Sprite Parent) : base(Parent)
    {

    }
    string UpPath;
    string Path;
    string State;
    int Frame;
    string MorphNum;
    int FTime;
    int Delay;
    int Flip;
    static Wz_Node Entry;
    Wz_Vector origin = new(0, 0);
    public static bool IsUse;
    public static void Create(string MorphNum)
    {
        Entry = Wz.GetNode("Morph/" + MorphNum);
        Wz.DumpData(Entry, Wz.EquipData, Wz.EquipImageLib);
        foreach (var Iter in Wz.EquipData[Entry.FullPathToFile2()].Nodes)
        {
            foreach (var Iter2 in Wz.EquipData[Iter.FullPathToFile2()].Nodes)
            {
                if (Char.IsNumber(Iter2.Text[0]))
                {
                    if (Iter.Text == "walk" && Iter2.Text == "0")
                    {
                        var Morph = new Morph(EngineFunc.SpriteEngine);
                        Morph.ImageLib = Wz.EquipImageLib;
                        Morph.IntMove = true;
                        Morph.Tag = 1;
                        Morph.State = Iter.Text;
                        Morph.Frame = Iter2.Text.ToInt();
                        Morph.MorphNum = Entry.Text.LeftStr(4);
                        Morph.UpPath = Entry.FullPathToFile2();
                        Morph.ImageNode = Wz.EquipData[Iter2.FullPathToFile2()];
                    }
                }
            }
        }
    }

    public static void Delete()
    {
        foreach (var Iter in EngineFunc.SpriteEngine.SpriteList)
        {
            if (Iter is Morph)
            {
                Iter.Dead();
            }
        }
        EngineFunc.SpriteEngine.Dead();
        foreach (var Iter in Wz.EquipImageLib.Keys)
        {
            if (Iter.FullPathToFile2().LeftStr(5) == "Morph")
            {
                Wz.EquipImageLib.Remove(Iter);
                Wz.EquipData.Remove(Iter.FullPathToFile2());
            }
        }
    }

    public override void DoMove(float Delta)
    {
        base.DoMove(Delta);
        if (Wz.HasDataE(UpPath + "/" + State + "/" + Frame))
        {
            Path = UpPath + "/" + State + "/" + Frame;
            ImageNode = Wz.EquipData[Path];
            //Visible := True;
        }

        if (Wz.HasDataE(UpPath + "/" + State + "/" + Frame + "/delay"))
            Delay = Wz.EquipData[UpPath + "/" + State + "/" + Frame + "/delay"].ToInt();
        else
            Delay = 100;

        FTime += 17;
        if (FTime > Delay)
        {
            Frame += 1;
            if (!Wz.EquipData.ContainsKey(UpPath + "/" + State + "/" + Frame))
                Frame = 0;
            FTime = 0;
        }

        if (Wz.HasDataE(Path + "/z"))
            Z = Game.Player.Z - Wz.EquipData[Path + "/z"].ToInt();
        else
            Z = Game.Player.Z;

        if (Keyboard.KeyDown(Input.Left))
            FlipX = false;
        if (Keyboard.KeyDown(Input.Right))
            FlipX = true;

        if (Game.Player.JumpState != JumpState.jsNone)
        {
            Frame = 0;
            State = "jump";
        }

        if (Game.Player.JumpState == JumpState.jsNone)
        {
            State = "stand";
            if (Keyboard.KeyDown(Input.Left) || Keyboard.KeyDown(Input.Right))
                State = "walk";
            if (Keyboard.KeyDown(Input.Down))

                State = "prone";
            if (State == "prone" && Keyboard.KeyUp(Input.Down))
                State = "stand";
            if (Keyboard.KeyUp(Input.Left) || Keyboard.KeyUp(Input.Right))
                State = "stand";
        }

        if (Game.Player.InLadder)
        {
            switch (Game.Player.LadderType)
            {
                case LadderType.Ladder:
                    if (Keyboard.KeyDown(Input.Up) || Keyboard.KeyDown(Input.Down))
                    {
                        State = "ladder";
                    }
                    else
                    {
                        State = "ladder";
                        Frame = 0;
                    }
                    break;

                case LadderType.Rope:
                    if (Keyboard.KeyDown(Input.Up) || Keyboard.KeyDown(Input.Down))
                    {
                        State = "rope";
                    }
                    else
                    {
                        State = "rope";
                        Frame = 0;
                    }
                    break;
            }
        }

        if (ImageNode.GetNode("origin") != null)
            origin = ImageNode.GetNode("origin").ToVector();

        Y = Game.Player.Y;
        switch (FlipX)
        {
            case true:
                X = Game.Player.X + 1;
                Offset.X = origin.X - ImageWidth;
                Flip = -1;
                break;
            case false:
                X = Game.Player.X;
                Offset.X = -origin.X;
                Flip = 1;
                break;
        }
        Offset.Y = -origin.Y;
    }

}
```

`MapleNecrocer/Client/MouseEx.cs`:

```cs
using System.Runtime.InteropServices;
using MouseState=Microsoft.Xna.Framework.Input.MouseState;
using ButtonState = Microsoft.Xna.Framework.Input.ButtonState;
namespace MouseExt;
public  class MouseEx
{
    [DllImportAttribute("user32.dll", EntryPoint = "SetCursorPos")]
    [return: MarshalAsAttribute(System.Runtime.InteropServices.UnmanagedType.Bool)]
    private static extern bool SetCursorPos(int X, int Y);

    private static Control _window;
    private static MouseInputWnd _mouseInputWnd = new MouseInputWnd();
    private static IntPtr PlatformGetWindowHandle()
    {
        return (_window == null) ? IntPtr.Zero : _window.Handle;
    }

    public static void PlatformSetWindowHandle(IntPtr windowHandle)
    {
        // Unregister old window
        if (_mouseInputWnd.Handle != IntPtr.Zero)
            _mouseInputWnd.ReleaseHandle();

        _window = Control.FromHandle(windowHandle);
        _mouseInputWnd.AssignHandle(windowHandle);
    }
  
    public static MouseState GetState()
    {
        if (_window != null)
        {
            var pos = Control.MousePosition;
            var clientPos = _window.PointToClient(pos);
            var buttons = Control.MouseButtons;

            return new MouseState(
                clientPos.X,
                clientPos.Y,
                _mouseInputWnd.ScrollWheelValue,
                (buttons & MouseButtons.Left) == MouseButtons.Left ? ButtonState.Pressed : ButtonState.Released,
                (buttons & MouseButtons.Middle) == MouseButtons.Middle ? ButtonState.Pressed : ButtonState.Released,
                (buttons & MouseButtons.Right) == MouseButtons.Right ? ButtonState.Pressed : ButtonState.Released,
                (buttons & MouseButtons.XButton1) == MouseButtons.XButton1 ? ButtonState.Pressed : ButtonState.Released,
                (buttons & MouseButtons.XButton2) == MouseButtons.XButton2 ? ButtonState.Pressed : ButtonState.Released,
                _mouseInputWnd.HorizontalScrollWheelValue
                );
        }
        return new MouseState();//_defaultState;
    }

    public static void PlatformSetPosition(int x, int y)
    {
        //  PrimaryWindow.MouseState.X = x;
        // PrimaryWindow.MouseState.Y = y;
        var pt = _window.PointToScreen(new System.Drawing.Point(x, y));
        SetCursorPos(pt.X, pt.Y);
    }

    class MouseInputWnd : System.Windows.Forms.NativeWindow
    {
        const int WM_MOUSEMOVE = 0x0200;
        const int WM_LBUTTONDOWN = 0x0201;
        const int WM_LBUTTONUP = 0x0202;
        const int WM_RBUTTONDOWN = 0x0204;
        const int WM_RBUTTONUP = 0x0205;
        const int WM_MBUTTONDOWN = 0x0207;
        const int WM_MBUTTONUP = 0x0208;
        const int WM_MOUSEWHEEL = 0x020A;
        const int WM_MOUSEHWHEEL = 0x020E;
        public int ScrollWheelValue = 0;
        public int HorizontalScrollWheelValue = 0;
        protected override void WndProc(ref Message m)
        {
            switch (m.Msg)
            {
                case WM_MOUSEWHEEL:
                    var delta = (short)(((ulong)m.WParam >> 16) & 0xffff);
                    ScrollWheelValue += delta;
                    break;
                case WM_MOUSEHWHEEL:
                    var deltaH = (short)(((ulong)m.WParam >> 16) & 0xffff);
                    HorizontalScrollWheelValue += deltaH;
                    break;
            }

            base.WndProc(ref m);
        }
    }

}

```

`MapleNecrocer/Client/NameTag.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WzComparerR2.WzLib;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework;
using Color = Microsoft.Xna.Framework.Color;
using System.Drawing.Imaging;
using System.Drawing;
using System.Runtime.InteropServices;

namespace MapleNecrocer;

public class NameTag : SpriteEx
{
    public NameTag(Sprite Parent) : base(Parent)
    {
    }
    public static bool ReDraw;
    static bool CanUse;
    public static string PlayerName;
    static int NameWidth;
    static RenderTarget2D TargetTexture = null;
    public static bool IsUse = true;
    private static int OffY;
    public static void Create(string Name)
    {
        Game.Player.Name = Name;
        NameWidth = Map.MeasureStringX(Map.NpcNameTagFont, Name);
        switch (Wz.Region)
        {
            case "GMS":
            case "KMS":
                OffY = 0;
                break;
            case "TMS":
                OffY = 1;
                break;
            case "JMS":
                OffY = 2;
                break;
        }
        EngineFunc.Canvas.DrawTarget(ref TargetTexture, NameWidth + 10, 25, () =>
        {
            int NamePos = NameWidth / 2;
            if (Map.ShowPlayer)
            {
                EngineFunc.Canvas.FillRoundRect(0, 2, NameWidth + 8, 15, new Microsoft.Xna.Framework.Color(0, 0, 0, 150));
                EngineFunc.Canvas.DrawString(Map.NpcNameTagFont, Game.Player.Name, 3, 2 + OffY, Microsoft.Xna.Framework.Color.White);
            }
        });

        var NameTag = new NameTag(EngineFunc.SpriteEngine);
        NameTag.Tag = 1;
        NameTag.IntMove = true;
        //NameTag.BlendMode=BlendMode.AddtiveColor;
    }

    public override void DoMove(float Delta)
    {
        base.DoMove(Delta);
        if (ReDraw)
        {
            NameWidth = Map.MeasureStringX(Map.NpcNameTagFont, Game.Player.Name);
            EngineFunc.Canvas.DrawTarget(ref TargetTexture, NameWidth + 10, 25, () =>
            {
                int NamePos = NameWidth / 2;
                if (Map.ShowPlayer)
                {
                    Engine.Canvas.FillRoundRect(0, 2, NameWidth + 8, 15, new Microsoft.Xna.Framework.Color(0, 0, 0, 150));
                    Engine.Canvas.DrawString(Map.NpcNameTagFont, Game.Player.Name, 3, 2 + OffY, Microsoft.Xna.Framework.Color.White);
                }
            });
        }
        X = Game.Player.X;
        Y = Game.Player.Y;
        Z = Game.Player.Z;
    }

    public override void DoDraw()
    {
        if (!NameTag.IsUse)
            return;
        if (Map.ShowPlayer)
        {
            int WX = (int)(Game.Player.X) - (int)Engine.Camera.X;
            int WY = (int)(Game.Player.Y) - (int)Engine.Camera.Y;
            int NamePos = NameWidth / 2;
            Engine.Canvas.Draw(TargetTexture, WX - NamePos - 8, WY, BlendMode.NonPremultiplied2);
        }
        if (ReDraw)
            ReDraw = false;
    }

}


public class MedalTag : SpriteEx
{
    public MedalTag(Sprite Parent) : base(Parent)
    {
        Tag=1;
    }
    int EastWidth;
    int WestWidth;
    int CenterWidth;
    int CenterLength;
    int TagWidth;
    int FontColor;
    int R, G, B;
    public string MedalName;
    public int TargetIndex;
    public bool IsReDraw;
    public Wz_Node Entry;
    public RenderTarget2D TargetTexture;
    public static MedalTag Instance;

    private static void ChangeAlpha(ref Bitmap bmp)
    {
        BitmapData bmpData = bmp.LockBits(new System.Drawing.Rectangle(0, 0, bmp.Width, bmp.Height), ImageLockMode.ReadWrite, bmp.PixelFormat);
        IntPtr ptr = bmpData.Scan0;
        int numBytes = bmp.Width * bmp.Height * 4;
        byte[] argbValues = new byte[numBytes];
        System.Runtime.InteropServices.Marshal.Copy(ptr, argbValues, 0, numBytes);
        for (int counter = 0; counter < argbValues.Length; counter += 4)
        {
            if (argbValues[counter + 4 - 1] >= 150)
                argbValues[counter + 4 - 1] = 255;
        }
        System.Runtime.InteropServices.Marshal.Copy(argbValues, 0, ptr, numBytes);
        bmp.UnlockBits(bmpData);

    }

    public static Texture2D FixAlpha(Bitmap Bmp)
    {

        ChangeAlpha(ref Bmp);
        /*
        int[] imgData = new int[Bmp.Width * Bmp.Height];
        
        Texture2D Texture = new Texture2D(RenderFormDraw.Instance.GraphicsDevice, Bmp.Width, Bmp.Height);
        unsafe
        {
            System.Drawing.Imaging.BitmapData origdata =
                Bmp.LockBits(new System.Drawing.Rectangle(0, 0, Bmp.Width, Bmp.Height), System.Drawing.Imaging.ImageLockMode.ReadOnly, PixelFormat.Format32bppArgb);
            uint* byteData = (uint*)origdata.Scan0;
            // Switch bgra -> rgba
            for (int i = 0; i < imgData.Length; i++)
            {
                byteData[i] = (byteData[i] & 0x000000ff) << 16 | (byteData[i] & 0x0000FF00) | (byteData[i] & 0x00FF0000) >> 16 | (byteData[i] & 0xFF000000);
            }
            System.Runtime.InteropServices.Marshal.Copy(origdata.Scan0, imgData, 0, Bmp.Width * Bmp.Height);
            byteData = null;
            Bmp.UnlockBits(origdata);
        }
        Texture.SetData(imgData);
        */

        Texture2D Texture = null;
        using (MemoryStream Stream = new MemoryStream())
        {
            Bmp.Save(Stream, System.Drawing.Imaging.ImageFormat.Bmp);
            Stream.Seek(0, SeekOrigin.Begin);
            Texture = Texture2D.FromStream(RenderFormDraw.Instance.GraphicsDevice, Stream);
            Microsoft.Xna.Framework.Color[] Buffer = new Microsoft.Xna.Framework.Color[Texture.Width * Texture.Height];
            Texture.GetData(Buffer);
            for (int i = 0; i < Buffer.Length; i++)
                Buffer[i] = Microsoft.Xna.Framework.Color.FromNonPremultiplied(Buffer[i].R, Buffer[i].G, Buffer[i].B, Buffer[i].A);
            Texture.SetData(Buffer);
        }
        return Texture;
    }

    public void RenderTargetFunc()
    {
        if (Map.ShowPlayer)
        {
            CenterLength = Map.MeasureStringX(Map.NpcNameTagFont, MedalName) + 10;
            var WestImage = Wz.EquipData[Entry.FullPathToFile2() + "/w"];
            var WestX = 150 - (CenterLength + EastWidth + WestWidth) / 2;
            Wz.EquipImageLib[WestImage] = FixAlpha(Entry.GetBmp("w"));
            Engine.Canvas.Draw(Wz.EquipImageLib[WestImage], WestX, -WestImage.GetNode("origin").ToVector().Y + 38);

            var CenterImage = Wz.EquipData[Entry.FullPathToFile2() + "/c"];
            int Count = CenterLength / CenterWidth;
            Wz.EquipImageLib[CenterImage] = FixAlpha(Entry.GetBmp("c"));
            for (int i = 1; i <= Count; i++)
            {
                Engine.Canvas.Draw(Wz.EquipImageLib[CenterImage], WestX + ((i - 1) * CenterWidth) + WestWidth, -
                    CenterImage.GetNode("origin").ToVector().Y + 38);
            }
            int OffX = 0;
            switch (CenterWidth)
            {
                case 1:
                    OffX = 0;
                    break;
                case 2:
                    OffX = 1;
                    break;
                case 3:
                case 4:
                case 5:
                    OffX = 4; break;
                case int i when i >= 6 && i <= 13:
                    OffX = 5;
                    break;
                case 14:
                    OffX = 12;
                    break;
                case 20:
                    OffX = 18;
                    break;
            }

            var EastImage = Wz.EquipData[Entry.FullPathToFile2() + "/e"];
            Wz.EquipImageLib[EastImage] = FixAlpha(Entry.GetBmp("e"));
            Engine.Canvas.Draw(Wz.EquipImageLib[EastImage], WestX + CenterLength + WestWidth - OffX,
                -EastImage.GetNode("origin").ToVector().Y + 38);

            int OffY = 0;
            switch (Wz.Region)
            {
                case "GMS": OffY = 0; break;
                case "JMS": OffY = 2; break;
                case "TMS": OffY = 1; break;
                case "KMS": OffY = 1; break;
            }
            Engine.Canvas.DrawString(Map.NpcNameTagFont, MedalName, WestX + WestWidth + 2, 36 + OffY, new Color(R, G, B, 255));

        }
    }
    public void InitData()
    {
        EastWidth = Entry.GetNode("e").ExtractPng().Width;
        WestWidth = Entry.GetNode("w").ExtractPng().Width;
        CenterWidth = Entry.GetNode("c").ExtractPng().Width;

        TagWidth = CenterLength + EastWidth + WestWidth + 30;

        var TagHeight = Entry.GetNode("w").ExtractPng().Height + 30;
        if (Entry.GetNode("clr") != null)
            FontColor = 16777216 + Entry.GetNode("clr").ToInt();
        else
            FontColor = 16777215;
        string Hex = FontColor.ToString("X").PadLeft(6, '0');
        R = (byte)Convert.ToInt32(Hex.LeftStr(2), 16);
        G = (byte)Convert.ToInt32(Hex.Substring(2, 2), 16);
        B = (byte)Convert.ToInt32(Hex.RightStr(2), 16);
        Engine.Canvas.DrawTarget(ref TargetTexture, 300, 100, () => { RenderTargetFunc(); });
    }

    public static void Create(string ItemID)
    {
        Instance = new MedalTag(EngineFunc.SpriteEngine);
        Instance.IntMove = true;
        int TagNum = Wz.GetNode("Character/Accessory/" + ItemID + ".img/info/medalTag").ToInt();
        Instance.Entry = Wz.GetNode("UI/NameTag.img/medal/" + TagNum);
        Wz.DumpData(Instance.Entry, Wz.EquipData, Wz.EquipImageLib);
        Instance.MedalName = Wz.GetNode("String/Eqp.img/Eqp/Accessory/" + ItemID.RightStr(7)).GetStr("name");
        Instance.InitData();
    }

    public override void DoMove(float Delta)
    {
        base.DoMove(Delta);
        if (IsReDraw)
        {
            Engine.Canvas.DrawTarget(ref TargetTexture, 300, 100, () => { RenderTargetFunc(); });
        }
        X = Game.Player.X;
        Y = Game.Player.Y;
        Z = Game.Player.Z;
    }

    public override void DoDraw()
    {
        if (Map.ShowPlayer)
        {
            int WX = (int)(Game.Player.X) - (int)(Engine.Camera.X);
            int WY = (int)(Game.Player.Y) - (int)(Engine.Camera.Y);
            Engine.Canvas.Draw(TargetTexture, WX - 150, WY - 8, BlendMode.NonPremultiplied2);
        }
        if (IsReDraw)
            IsReDraw = false;
    }

    public static void ReDraw()
    {
        if (Instance != null)
            Instance.IsReDraw = true;
    }
    public static void Delete()
    {
        if (Instance != null)
            Instance.Dead();
        EngineFunc.SpriteEngine.Dead();

    }
}


public class NickNameTag : MedalTag
{
    public NickNameTag(Sprite Parent) : base(Parent)
    {
    }
    public static NickNameTag Instance;

    static void ReDraw()
    {
        if (Instance != null)
            Instance.IsReDraw = true;
    }

    public override void DoDraw()
    {
        if (Map.ShowPlayer)
        {
            int WX = (int)Game.Player.X - (int)Engine.Camera.X;
            int WY = (int)Game.Player.Y - (int)Engine.Camera.Y;
            Engine.Canvas.Draw(TargetTexture, WX - 150 - Game.Player.BrowPos.X + MapleChair.BodyRelMove.X, WY - 110
                - Game.Player.BrowPos.Y + MapleChair.BodyRelMove.Y);
        }
        if (IsReDraw)
            IsReDraw = false;
    }

    public static void Delete()
    {
        if (Instance != null)
        {
            Instance.Dead();
            EngineFunc.SpriteEngine.Dead();
        }
    }

    public static void Create(string ItemID)
    {
        Instance = new NickNameTag(EngineFunc.SpriteEngine);
        Instance.IntMove = true;
        int TagNum = Wz.GetNode("Item/Install/0370.img/" + ItemID + "/info/nickTag").ToInt();
        Instance.Entry = Wz.GetNode("UI/NameTag.img/nick/" + TagNum);
        Wz.DumpData(Instance.Entry, Wz.EquipData, Wz.EquipImageLib);
        Instance.MedalName = Wz.GetNode("String/Ins.img/" + ItemID.RightStr(7)).GetStr("name");
        Instance.InitData();
    }

}

public class LabelRingTag : MedalTag
{
    public LabelRingTag(Sprite Parent) : base(Parent)
    {
    }
    public static LabelRingTag Instance;

    public static void Create(string ItemID)
    {
        Instance = new LabelRingTag(EngineFunc.SpriteEngine);
        Instance.IntMove = true;
        int TagNum = Wz.GetNode("Character/Ring/" + ItemID + ".img/info/nameTag").ToInt();
        Instance.Entry = Wz.GetNode("UI/NameTag.img/" + TagNum);
        Wz.DumpData(Instance.Entry, Wz.EquipData, Wz.EquipImageLib);
        Instance.MedalName = "SuperGM";
        Instance.InitData();
    }

    public override void DoDraw()
    {
        if (Map.ShowPlayer)
        {
            int WX = (int)(Game.Player.X) - (int)(Engine.Camera.X);
            int WY = (int)(Game.Player.Y) - (int)(Engine.Camera.Y);
            Engine.Canvas.Draw(TargetTexture, WX - 150, WY - 31, BlendMode.NonPremultiplied);
        }
        if (IsReDraw)
            IsReDraw = false;
    }
    public static void ReDraw()
    {
        if (Instance != null)
            Instance.IsReDraw = true;
    }

    public static void Delete()
    {
        if (Instance != null)
        {
            Instance.Dead();
            EngineFunc.SpriteEngine.Dead();
        }
    }


}
```

`MapleNecrocer/Client/Npc.cs`:

```cs
using WzComparerR2.WzLib;
using WzComparerR2.PluginBase;
using Spine;
using WzComparerR2.Animation;
using Microsoft.Xna.Framework;
using System.Linq;
using System.Xml.Linq;
using WzComparerR2.CharaSim;
using System.Drawing;
using SharpDX.Direct3D11;
using System.ComponentModel.Design;

namespace MapleNecrocer;

public class Npc : SpriteEx
{
    public Npc(Sprite Parent) : base(Parent)
    {
        IntMove = true;
    }
    string SpriteID;
    string Action;
    float Time;
    int Frame;
    int RandMsg;
    int Counter;
    string ImagePath;
    Foothold FH;
    List<string> Actions = new();
    List<string> Msgs = new();
    public static List<string> SummonedList = new();
    public string LocalID;
    public ChatBalloon Balloon;

    public static void Create()
    {
        foreach (var Iter in Map.Img.Nodes["life"].Nodes)
        {
            if (Iter.GetBool("hide"))
                continue;
            if (Iter.Nodes["type"] != null)
            {
                if (Iter.GetStr("type") == "n")
                    Npc.Spawn(Iter.GetStr("id"), Iter.GetInt("x"), Iter.GetInt("cy"), Iter.GetInt("f"));
            }
            else
            {
                foreach (var Iter2 in Iter.Nodes)
                {
                    if (Iter2.GetStr("type") == "n")
                        Npc.Spawn(Iter2.GetStr("id"), Iter2.GetInt("x"), Iter2.GetInt("cy"), Iter2.GetInt("f"));
                }
            }
        }
       
    }

    public static string ReString(string Str)
    {
        for (int i = 0; i <= Str.Length / 8; i++)
            Str = Str.Insert(i * 8, "=");
        Str = Str.Remove(0, 1);
        return Str;
    }
    public static void Spawn(string ID, int PosX, int PosY, int FlipX)
    {
        if (Wz.GetNodeA("String/Npc.img/" + ID.IntID()) == null)
            return;
        switch (ID.ToInt())
        {
            case 9062010:
            case 9050000:
            case 9050009:
            case 9300018:
            case 9010088:
                return;
        }
        var Link = Wz.GetNodeA("Npc/" + ID + ".img/info/link");
        var NpcImg = Wz.GetNodeA("Npc/" + ID + ".img");
        if (!Wz.Data.ContainsKey("Npc/" + ID + ".img"))
        {
            Wz.DumpData(NpcImg, Wz.Data, Wz.ImageLib);
            if (Link != null)
                Wz.DumpData(Wz.GetNodeA("Npc/" + Link.ToStr() + ".img"), Wz.Data, Wz.ImageLib);
        }

        var Npc = new Npc(EngineFunc.SpriteEngine);
        Npc.ImageLib = Wz.ImageLib;
        Npc.LocalID = ID;
        if (Link != null)
            Npc.SpriteID = Link.ToStr();
        else
            Npc.SpriteID = ID;
        Npc.Frame = 0;
        foreach (var Iter in Wz.GetNodeA("Npc/" + Npc.SpriteID + ".img").Nodes)
        {
            if ((Iter.Text != "info") && (Iter.Text.LeftStr(9) != "condition") && (Iter.Nodes["0"] != null))
            {
                Npc.Actions.Add(Iter.Text);
            }
        }

        if (Npc.Actions.Count == 0)
            return;
        Npc.Action = Npc.Actions[0];
        if (FlipX.ToBool())
            Npc.FlipX = true;

        string Path = "Npc/" + Npc.SpriteID + ".img/" + Npc.Action;
        Npc.ImageNode = Wz.Data[Path + "/0"];
        Foothold BelowFH = null;
        Vector2 Pos = FootholdTree.Instance.FindBelow(new Vector2(PosX, PosY - 3), ref BelowFH);
        Npc.X = Pos.X;
        Npc.Y = Pos.Y;
        Npc.FH = BelowFH;
        Npc.Z = BelowFH.Z * 100000 + 7000;
        Npc.Width = Npc.ImageWidth;
        Npc.Height = Npc.ImageHeight;

        foreach (var Iter2 in Wz.GetNode("String/Npc.img/" + Npc.SpriteID.IntID()).Nodes)
        {
            if (Iter2.Text.Length == 2)
            {
                string Str1 = Iter2.ToStr();

                if (Wz.Region == "GMS")
                {
                    Npc.Msgs.Add(Str1);
                }
                else
                {
                    Str1 = Str1.Replace(" ", "");
                    Npc.Msgs.Add(ReString(Str1));
                }
            }
        }

        if (Npc.Msgs.Count > 0)
        {
            Npc.Balloon = new ChatBalloon(EngineFunc.SpriteEngine);
            Npc.Balloon.SetStyle(0);
            Npc.Balloon.X = Npc.X;
            Npc.Balloon.Y = Npc.Y - Npc.Height - 20;
            Npc.Balloon.Z = Npc.Z + 100000000;
        }

        
        Random Random = new();
        Npc.Counter = Random.Next(1000);

        Wz_Vector origin = WzDict.GetVector(Path + "/0/origin");
        if (Npc.FlipX)
            Npc.Origin.X = -origin.X + Npc.ImageWidth;
        else
            Npc.Origin.X = origin.X;
        Npc.Origin.Y = origin.Y;

        //
        if (Wz.GetNodeA("Npc/" + Npc.SpriteID + ".img/info/MapleTV").ToBool())
        {
            string Path2 = "Npc/" + Npc.SpriteID + ".img/info";
            int msgX = WzDict.GetInt(Path2 + "/MapleTVmsgX");
            int msgY = WzDict.GetInt(Path2 + "/MapleTVmsgY");
            int adX = WzDict.GetInt(Path2 + "/MapleTVadX");
            int adY = WzDict.GetInt(Path2 + "/MapleTVadY");
            MapleTV.Create((int)Npc.X, (int)Npc.Y, msgX, msgY, adX, adY, Npc.Z);
        }
        //
        var NpcText = new NpcText(EngineFunc.SpriteEngine);
        NpcText.NpcName = Wz.GetNodeA("String/Npc.img/" + Npc.LocalID.IntID()).GetStr("name");
        NpcText.NpcFunc = Wz.GetNodeA("String/Npc.img/" + Npc.LocalID.IntID()).GetStr("func");
        if (NpcText.NpcFunc != "")
            NpcText.HasFunc = true;
        NpcText.X = Pos.X;
        NpcText.Y = Pos.Y;
        NpcText.Z = 1000000 + 100000;
        NpcText.Width = Npc.ImageWidth;
        NpcText.Height = Npc.ImageHeight;
        NpcText.NameWidth = Map.MeasureStringX(Map.NpcNameTagFont, NpcText.NpcName);
        NpcText.FuncWidth = Map.MeasureStringX(Map.NpcNameTagFont, NpcText.NpcFunc);
        NpcText.ID = "ID:" + ID;
        NpcText.IDWidth = Map.MeasureStringX(Map.NpcNameTagFont, NpcText.ID);
        NpcText.HideName = WzDict.GetBool("Npc/" + ID + ".img/info/hideName");
        NpcText.Moved = false;


    }

    public override void DoMove(float Delta)
    {
        ImagePath = "Npc/" + SpriteID + ".img/" + Action + "/" + Frame;
        ImageNode = Wz.Data[ImagePath];
        int Delay = WzDict.GetInt(ImagePath + "/delay", 100);
        Random random = new Random();
        Time += 16.66f * Delta;
        if (Time > Delay)
        {
            Frame += 1;
            if (!Wz.HasData("Npc/" + SpriteID + ".img/" + Action + "/" + Frame))
            {
                Frame = 0;
                if (Actions.Count > 1)
                {
                    if (random.Next(2) == 0)
                        Action = Actions[random.Next(Actions.Count)];
                }
            }
            Time = 0;
        }

        Wz_Vector origin = WzDict.GetVector(ImagePath + "/origin");
        if (FlipX)
            Origin.X = -origin.X + ImageWidth;
        else
            Origin.X = origin.X;
        Origin.Y = origin.Y;
    }

    public override void DoDraw()
    {
        if (Map.ShowNpc)
            base.DoDraw();
        Random Random = new();
        Counter += 1;

        if (Counter > 1000)
        {
            Counter = 0;
            RandMsg = Random.Next(Msgs.Count);
        }
        if (Msgs.Count > 0)
        {
            if ((Counter > 0) && (Counter < 500))
                Balloon.Msg = Msgs[RandMsg];
            else
                Balloon.Msg = "";

        }

      
    }

}

public class NpcText : SpriteEx
{
    public NpcText(Sprite Parent) : base(Parent)
    {

    }
    public string NpcName;
    public string NpcFunc;
    public bool HasFunc;
    public int NameWidth;
    public int FuncWidth;
    public int IDWidth;
    public string ID;
    public bool HideName;

    public override void DoDraw()
    {

        if(!Map.ShowNpc)
            return;
        int WX = (int)X - (int)Engine.Camera.X;
        int WY = (int)Y - (int)Engine.Camera.Y;


        if (Map.ShowID)
        {
            float IDPos = WX - IDWidth / 2;
            Engine.Canvas.FillRoundRect((int)IDPos - 2, (int)WY + 36, IDWidth + 5, 15, new Microsoft.Xna.Framework.Color(0, 0, 0, 150));
            Engine.Canvas.DrawString(Map.NpcNameTagFont, ID, IDPos, WY + 37, Microsoft.Xna.Framework.Color.Cyan);
        }

        if (Map.ShowNpcName)
        {
            if (HideName)
                return;
            int OffsetY = 0;
            switch (Wz.Region)
            {
                case "GMS": OffsetY = 0; break;
                case "KMS": case "TMS": OffsetY = 1; break;
                case "JMS": OffsetY = 2; break;
            }
            int NamePos = WX - NameWidth / 2;
            Engine.Canvas.FillRoundRect((int)NamePos - 2, (int)WY + 3, NameWidth + 5, 16, new Microsoft.Xna.Framework.Color(0, 0, 0, 150));
            Engine.Canvas.DrawString(Map.NpcNameTagFont, NpcName, NamePos, WY + 4 + OffsetY, Microsoft.Xna.Framework.Color.Yellow);

            if (HasFunc)
            {
                float FuncPos = WX - FuncWidth / 2;
                Engine.Canvas.FillRoundRect((int)FuncPos - 2, (int)WY + 21, FuncWidth + 5, 16, new Microsoft.Xna.Framework.Color(0, 0, 0, 150));
                Engine.Canvas.DrawString(Map.NpcNameTagFont, NpcFunc, FuncPos, WY + 22 + OffsetY, Microsoft.Xna.Framework.Color.Yellow);
            }
        }

      

    }

}



```

`MapleNecrocer/Client/Particle/Camera.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Rectangle=Microsoft.Xna.Framework.Rectangle;
namespace WzComparerR2.MapRender2
{
    public class Camera
    {
        public Camera(GraphicsDevice graphics)
        {
            this.graphics = graphics;
            this.AdjustRectEnabled = true;
        }

        GraphicsDevice graphics;
        Rectangle worldRect;
        Vector2 center;
        int displayMode;
        bool useWorldRect;

        public GraphicsDevice Graphics
        {
            get { return graphics; }
            set { graphics = value; }
        }

        /// <summary>
        /// 获取或设置摄像机中心对应的世界坐标。
        /// </summary>
        public Vector2 Center
        {
            get { return center; }
            set { center = value; }
        }

        /// <summary>
        /// 获取摄像机宽度。
        /// </summary>
        public int Width
        {
            get { return graphics.PresentationParameters.BackBufferWidth; }
        }

        /// <summary>
        /// 获取摄像机高度。
        /// </summary>
        public int Height
        {
            get { return graphics.PresentationParameters.BackBufferHeight; }
        }

        /// <summary>
        /// 获取摄像机矩形的世界坐标。
        /// </summary>
        public Rectangle ClipRect
        {
            get
            {
                if (useWorldRect)
                    return worldRect;
                else
                    return new Rectangle((int)center.X - Width / 2, (int)center.Y - Height / 2, Width, Height);
            }
        }

        /// <summary>
        /// 获取摄像机左上角对应的世界坐标。
        /// </summary>
        public Vector2 Origin
        {
            get
            {
                Rectangle rect = ClipRect;
                return new Vector2(rect.X, rect.Y);
            }
        }

        public Rectangle WorldRect
        {
            get { return worldRect; }
            set { worldRect = value; }
        }

        public int DisplayMode
        {
            get { return displayMode; }
            set
            {
                displayMode = value;
               // ChangeDisplayMode();
            }
        }

        public bool UseWorldRect
        {
            get { return useWorldRect; }
            set { useWorldRect = value; }
        }

        public bool AdjustRectEnabled { get; set; }
        /*
        private void ChangeDisplayMode()
        {
            switch (this.displayMode)
            {
                case 0:
                    graphics.PreferredBackBufferWidth = 800;
                    graphics.PreferredBackBufferHeight = 600;
                    break;
                case 1:
                    graphics.PreferredBackBufferWidth = 1024;
                    graphics.PreferredBackBufferHeight = 768;
                    break;
                case 2:
                    graphics.PreferredBackBufferWidth = 1366;
                    graphics.PreferredBackBufferHeight = 768;
                    break;
                case 3:
                    graphics.PreferredBackBufferWidth = graphics.GraphicsDevice.DisplayMode.Width;
                    graphics.PreferredBackBufferHeight = graphics.GraphicsDevice.DisplayMode.Height;
                    break;
                default:
                    goto case 0;
            }
            graphics.ApplyChanges();
        }
        */
        public void AdjustToWorldRect()
        {
          //  if (this.useWorldRect)
            //    return;

           // if (!this.AdjustRectEnabled)
            //    return;

            if (this.Width > worldRect.Width)
            {
                this.center.X = worldRect.Center.X;
            }
            else
            {
                this.center.X = MathHelper.Clamp(this.center.X,
                    worldRect.Left + this.Width / 2,
                    worldRect.Right - this.Width / 2);
            }

            if (this.Height > worldRect.Height)
            {
                this.center.Y = worldRect.Center.Y;
            }
            else
            {
                this.center.Y = MathHelper.Clamp(this.center.Y,
                    worldRect.Top + this.Height / 2,
                    worldRect.Bottom - this.Height / 2);
            }
        }

        public Rectangle MeasureDrawingRect(int width, int height, Vector2 position, Vector2 origin, bool flipX)
        {
            Rectangle drawingRect;
            drawingRect.Width = width;
            drawingRect.Height = height;
            if (flipX)
            {
                drawingRect.X = (int)(position.X + origin.X - width);
                drawingRect.Y = (int)(position.Y - origin.Y);
            }
            else
            {
                drawingRect.X = (int)(position.X - origin.X);
                drawingRect.Y = (int)(position.Y - origin.Y);
            }
            return drawingRect;
        }

#if MapRenderV1
        public bool CheckSpriteVisible(RenderFrame frame, Vector2 position, bool flip)
        {
            Rectangle drawingRect;
            return CheckSpriteVisible(frame, position, flip, out drawingRect);
        }

        public bool CheckSpriteVisible(RenderFrame frame, Vector2 position, bool flip, out Rectangle drawingRect)
        {
            if (frame == null || frame.Texture == null)
            {
                drawingRect = Rectangle.Empty;
                return false;
            }
            drawingRect = MeasureDrawingRect(
                frame.Texture.Width,
                frame.Texture.Height,
                position,
                frame.Origin,
                flip);
            return this.ClipRect.Intersects(drawingRect);
        }
#endif

        public Microsoft.Xna.Framework.Point CameraToWorld(Microsoft.Xna.Framework.Point cameraPoint)
        {
            cameraPoint.X += this.ClipRect.X;
            cameraPoint.Y += this.ClipRect.Y;
            return cameraPoint;
        }
    }
}

```

`MapleNecrocer/Client/Particle/IRandom.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Xna.Framework;
using Color = Microsoft.Xna.Framework.Color;

namespace WzComparerR2.MapRender2
{
    public interface IRandom
    {
        float NextVar(float baseValue, float varRange, bool nonNegative = false);
        int NextVar(int baseValue, int varRange, bool nonNegative = false);
        Vector2 NextVar(Vector2 baseValue, Vector2 varRange);
        Color NextVar(Color baseValue, Color varRange);
        int Next(int maxValue);
        bool NextPercent(float percent);
    }
}

```

`MapleNecrocer/Client/Particle/MapScene.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Linq;
using WzComparerR2.MapRender.Patches3;

namespace WzComparerR2.MapRender2
{
    public class MapScene : SceneNode
    {
        public MapScene()
        {
            this.Nodes.AddRange(new SceneNode[] {
            
                Effect = new ContainerNode()
            });

            for (int i = 0; i <= 7; i++)
            {
              //  this.Layers.Nodes.Add(new LayerNode());
            }
        }

        public ContainerNode Back { get; private set; }
        public SceneNode Layers { get; private set; }
        public FlyLayerNode Fly { get; private set; }
        public ContainerNode Front { get; private set; }
        public ContainerNode Effect { get; private set; }

       // public IEnumerable<PortalItem> Portals => this.Fly.Portal.Slots.OfType<PortalItem>();
      //  public IEnumerable<IlluminantClusterItem> IlluminantClusters => this.Fly.IlluminantCluster.Slots.OfType<IlluminantClusterItem>();
       
    }

    public class LayerNode : SceneNode
    {
        public LayerNode()
        {
            this.Nodes.AddRange(new SceneNode[]
            {
                Obj = new ContainerNode(),
                Reactor = new ContainerNode(),
                Tile = new ContainerNode(),
                Foothold = new SceneNode()
            });
        }

        public ContainerNode Obj { get; private set; }
        public ContainerNode Reactor { get; private set; }
        public ContainerNode Tile { get; private set; }
        public SceneNode Foothold { get; private set; }
    }

    public class FlyLayerNode : SceneNode
    {
        public FlyLayerNode()
        {
            this.Nodes.AddRange(new SceneNode[]
            {
                Portal = new ContainerNode(),
                LadderRope = new ContainerNode(),
                Sky = new ContainerNode(),
                SkyWhale = new ContainerNode(),
                IlluminantCluster = new ContainerNode(),
            });
        }


        public ContainerNode Portal { get; private set; }
        public ContainerNode LadderRope { get; private set; }
        /// <summary>
        /// 表示不属于任何Foothold的虚拟节点。
        /// </summary>
        public ContainerNode Sky { get; private set; }
        public ContainerNode SkyWhale { get; private set; }
        public ContainerNode IlluminantCluster { get; private set; }
    }

    public class ContainerNode : SceneNode
    {
        public ContainerNode()
        {
            this.Slots = new List<SceneItem>();
        }

        public List<SceneItem> Slots { get; private set; }
    }

    public class ContainerNode<T> : ContainerNode
    {
        public T Item { get; set; }
    }
}

```

`MapleNecrocer/Client/Particle/MeshBatcher.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using WzComparerR2.Animation;
using WzComparerR2.Rendering;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Spine;
using Rectangle=Microsoft.Xna.Framework.Rectangle;
using Point= Microsoft.Xna.Framework.Point;
using Color= Microsoft.Xna.Framework.Color;

namespace WzComparerR2.MapRender2
{
    public class MeshBatcher : IDisposable
    {
       

        public MeshBatcher(GraphicsDevice graphicsDevice)
        {
            this.GraphicsDevice = graphicsDevice;
            this.alphaBlendState = StateEx.NonPremultipled_Hidef();
            this.maskState = StateEx.SrcAlphaMask();
            this.meshPool = new Stack<MeshItem>();
        }

        public GraphicsDevice GraphicsDevice { get; private set; }
        public bool D2DEnabled { get; set; }
        public bool CullingEnabled { get; set; }

        //内部batcher
        SpriteBatchEx sprite;
        SkeletonMeshRenderer spineRender;
        D2DRenderer d2dRender;
        ItemType lastItem;
        Stack<MeshItem> meshPool;

      
        //innerState
        private readonly BlendState alphaBlendState;
        private readonly BlendState maskState;

        //start参数
        private Matrix? matrix;
        private bool isInBeginEndPair;

        //culling参数
        private bool matrixNoRot;
        private Rectangle viewport;


        public void Begin(Matrix? matrix = null)
        {
            this.matrix = matrix;
            this.lastItem = ItemType.Unknown;
            this.isInBeginEndPair = true;
            this.PrepareCullingParameters();
        }
        public void DrawParticle(MeshItem mesh)
        {
            if (mesh.RenderObject is ParticleSystem)
            {
                this.DrawItem(mesh, (ParticleSystem)mesh.RenderObject);
            }


        }

        public void Draw(MeshItem mesh)
        {   

            if (mesh.RenderObject is ParticleSystem)
            {
                this.DrawItem(mesh, (ParticleSystem)mesh.RenderObject);
            }
        }

        public Rectangle[] Measure(MeshItem mesh)
        {
            Rectangle[] region = null;
            int count;
            Measure(mesh, ref region, out count);
            return region;
        }

        public MeshItem MeshPop()
        {
            if (this.meshPool.Count > 0)
            {
                var mesh = this.meshPool.Pop();
                mesh.RenderObject = null;
                mesh.Position = Vector2.Zero;
                mesh.Z0 = 0;
                mesh.Z1 = 0;
                mesh.FlipX = false;
                mesh.TileRegion = null;
                mesh.TileOffset = Vector2.Zero;
                return mesh;
            }
            else
            {
                return new MeshItem();
            }
        }

        public void MeshPush(MeshItem mesh)
        {
            mesh.RenderObject = null;
            this.meshPool.Push(mesh);
        }

        public void PrepareCullingParameters()
        {
            if (this.matrix == null)
            {
                matrixNoRot = true;
            }
            else
            { 
                var mt = this.matrix.Value;
                if (mt.M12 == 0 && mt.M21 == 0)
                {
                    matrixNoRot = true;
                }
                else
                {
                    matrixNoRot = false;
                }
            }
            
            //重新计算viewport
            this.viewport = this.GraphicsDevice.Viewport.Bounds;
            if (matrixNoRot)
            {
                var invmt = Matrix.Invert(this.matrix.Value);
                var lt = Vector2.Transform(this.viewport.Location.ToVector2(), invmt);
                var rb = Vector2.Transform(new Vector2(this.viewport.Right, this.viewport.Bottom), invmt);
                int l = (int)Math.Floor(lt.X);
                int t = (int)Math.Floor(lt.Y);
                int r = (int)Math.Ceiling(rb.X);
                int b = (int)Math.Ceiling(rb.Y);
                this.viewport = new Rectangle(l, t, r - l, b - t);
            }
        }
        

        public void DrawItem(MeshItem mesh, Skeleton skeleton)
        {
            skeleton.FlipX = mesh.FlipX;

            //兼容平铺
            if (mesh.TileRegion != null)
            {
                var region = mesh.TileRegion.Value;
                for (int y = region.Top; y < region.Bottom; y++)
                {
                    for (int x = region.Left; x < region.Right; x++)
                    {
                        Vector2 pos = mesh.Position + mesh.TileOffset * new Vector2(x, y);
                        skeleton.X = pos.X;
                        skeleton.Y = pos.Y;
                        skeleton.UpdateWorldTransform();
                        Prepare(ItemType.Skeleton);
                        this.spineRender.Draw(skeleton);
                    }
                }
            }
            else
            {
                skeleton.X = mesh.Position.X;
                skeleton.Y = mesh.Position.Y;
                skeleton.UpdateWorldTransform();
                Prepare(ItemType.Skeleton);
                this.spineRender.Draw(skeleton);
            }
        }

     

      

        public void DrawItem(MeshItem mesh, ParticleSystem particleSystem)
        {
            if (particleSystem.Texture?.Texture != null)
            {
                ItemType itemType = ItemType.Unknown;
                if (particleSystem.BlendFuncSrc == ParticleBlendFunc.SRC_ALPHA
                    || (int)particleSystem.BlendFuncSrc == 12) //TODO: what's this? KMS v.293, esfera_temple_big
                {
                    switch (particleSystem.BlendFuncDst)
                    {
                        case ParticleBlendFunc.ONE: //5,2
                        case ParticleBlendFunc.DEST_ALPHA: //5,7
                            itemType = ItemType.Sprite_BlendAdditive;
                            break;
                        case ParticleBlendFunc.SRC_COLOR: //12,3
                        case ParticleBlendFunc.INV_SRC_ALPHA: //5,6
                            itemType = ItemType.Sprite_BlendNonPremultiplied;
                            break;
                    }
                }
                if (particleSystem.BlendFuncSrc == ParticleBlendFunc.ZERO && particleSystem.BlendFuncDst == ParticleBlendFunc.INV_SRC_ALPHA) //1,6
                {
                    itemType = ItemType.Sprite_BlendMask;
                }

                if (itemType == ItemType.Unknown)
                {
                    throw new Exception($"Unknown particle blendfunc: {particleSystem.BlendFuncSrc}, {particleSystem.BlendFuncDst}");
                }
                Prepare(itemType);
                particleSystem.Draw(this.sprite, mesh.Position);
            }
        }

       
        public void Measure(MeshItem mesh, ref Rectangle[] region, out int count)
        {
            Rectangle rect = Rectangle.Empty;

            if (mesh.RenderObject is TextMesh)
            {
                var textItem = (TextMesh)mesh.RenderObject;
              //  var size = textItem.Font.MeasureString(textItem.Text);
                var pos = mesh.Position;

                switch (textItem.Align)
                {
                    case Alignment.Near: break;
                  //  case Alignment.Center: pos.X -= size.X / 2; break;
                   // case Alignment.Far: pos.X -= size.X; break;
                }

                var padding = textItem.Padding;
               // var rectBg = new Rectangle((int)(pos.X - padding.Left),
                //    (int)(pos.Y - padding.Top),
                   // (int)(size.X + padding.Left + padding.Right),
                   // (int)(size.Y + padding.Top + padding.Bottom)
                   // );
              //  var rectText = new Rectangle((int)pos.X, (int)pos.Y, (int)size.X, (int)size.Y);

                count = 1;
                EnsureArraySize(ref region, count);
             //   Rectangle.Union(ref rectBg, ref rectText, out region[0]);
                return;
            }

            if (mesh.RenderObject is Frame)
            {
                var frame = (Frame)mesh.RenderObject;
                rect = frame.Rectangle;
                if (mesh.FlipX)
                {
                    rect.X = -rect.Right;
                }
            }
            else
            {
                count = 0;
                return;
            }

            rect.X += (int)mesh.Position.X;
            rect.Y += (int)mesh.Position.Y;

            if (mesh.TileRegion != null)
            {
                var tileRegion = mesh.TileRegion.Value;
                count = tileRegion.Width * tileRegion.Height;
                EnsureArraySize(ref region, count);
                Point offset = mesh.TileOffset.ToPoint();
                int i = 0;

                for (int y = tileRegion.Top; y < tileRegion.Bottom; y++)
                {
                    for (int x = tileRegion.Left; x < tileRegion.Right; x++)
                    {
                        region[i++] = new Rectangle(rect.X + x * offset.X,
                            rect.Y + y * offset.Y,
                            rect.Width,
                            rect.Height);
                    }
                }
            }
            else
            {
                count = 1;
                EnsureArraySize(ref region, count);
                region[0] = rect;
            }
        }

        public void EnsureArraySize<T>(ref T[] array, int length)
        {
            if (array == null)
            {
                array = new T[length];
            }
            else if (array.Length < length)
            {
                Array.Resize(ref array, length);
            }
        }

        public void End()
        {
            InnerFlush();
            this.lastItem = ItemType.Unknown;
            this.isInBeginEndPair = false;
        }

        public void Prepare(ItemType itemType)
        {
            if (lastItem == itemType)
            {
                return;
            }

            switch (itemType)
            {
                case ItemType.Sprite:
                case ItemType.Skeleton:
                case ItemType.D2DObject:
                case ItemType.Sprite_BlendAdditive:
                case ItemType.Sprite_BlendNonPremultiplied:
                case ItemType.Sprite_BlendMask:
                    InnerFlush();
                    lastItem = itemType;
                    InnerBegin();
                    break;
            }
        }

        public void InnerBegin()
        {
            switch (lastItem)
            {
                case ItemType.Sprite:
                    if (this.sprite == null)
                    {
                        this.sprite = new SpriteBatchEx(this.GraphicsDevice);
                    }
                    this.sprite.Begin(SpriteSortMode.Deferred, this.alphaBlendState, transformMatrix: this.matrix);
                   
                    break;

                case ItemType.Skeleton:
                    if (this.spineRender == null)
                    {
                        this.spineRender = new SkeletonMeshRenderer(this.GraphicsDevice);
                    }
                    this.spineRender.Effect.World = matrix ?? Matrix.Identity;
                    this.spineRender.Begin();
                    break;

                case ItemType.D2DObject:
                    if (this.d2dRender == null)
                    {
                        this.d2dRender = new D2DRenderer(this.GraphicsDevice);
                    }
                    if (this.matrix == null)
                    {
                        this.d2dRender.Begin();
                    }
                    else
                    {
                        this.d2dRender.Begin(this.matrix.Value);
                    }
                    break;

                case ItemType.Sprite_BlendAdditive:
                    if (this.sprite == null)
                    {
                        this.sprite = new SpriteBatchEx(this.GraphicsDevice);
                    }
                    this.sprite.Begin(SpriteSortMode.Deferred, BlendState.Additive, transformMatrix: this.matrix);
                    
                    break;

                case ItemType.Sprite_BlendNonPremultiplied:
                    if (this.sprite == null)
                    {
                        this.sprite = new SpriteBatchEx(this.GraphicsDevice);
                    }
                    this.sprite.Begin(SpriteSortMode.Deferred, BlendState.NonPremultiplied, transformMatrix: this.matrix);
                   
                    break;
                case ItemType.Sprite_BlendMask:
                    if (this.sprite == null)
                    {
                        this.sprite = new SpriteBatchEx(this.GraphicsDevice);
                    }
                    this.sprite.Begin(SpriteSortMode.Deferred, this.maskState, transformMatrix: this.matrix);
                    break;
            }
        }

        public void InnerFlush()
        {
            switch (lastItem)
            {
                case ItemType.Sprite:
                case ItemType.Sprite_BlendAdditive:
                case ItemType.Sprite_BlendNonPremultiplied:
                case ItemType.Sprite_BlendMask:
                    this.sprite.End();
                    break;

                case ItemType.Skeleton:
                    this.spineRender.End();
                    break;

                case ItemType.D2DObject:
                    this.d2dRender.End();
                    break;
            }
        }

       

     

        public void Dispose()
        {
            this.sprite?.Dispose();
            this.spineRender?.Effect.Dispose();
            this.alphaBlendState.Dispose();
            this.maskState.Dispose();
            this.meshPool.Clear();
        }

        public enum ItemType
        {
            Unknown = 0,
            Sprite = 1,
            Skeleton = 2,
            D2DObject = 3,
            Sprite_AlphaBlend = Sprite,
            Sprite_BlendAdditive = 4,
            Sprite_BlendNonPremultiplied = 5,
            Sprite_BlendMask = 6,
        }

    }
}
```

`MapleNecrocer/Client/Particle/MeshItem.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.Xna.Framework;

namespace WzComparerR2.MapRender2
{
    public class MeshItem : IComparable<MeshItem>
    {
        public object RenderObject { get; set; }
        public Vector2 Position { get; set; }
        public int Z0 { get; set; }
        public int Z1 { get; set; }

        //附加信息
        public bool FlipX { get; set; }
        public Microsoft.Xna.Framework.Rectangle? TileRegion { get; set; }
        public Vector2 TileOffset { get; set; }

        public int CompareTo(MeshItem other)
        {
            int comp;
            if ((comp = this.Z0.CompareTo(other.Z0)) != 0
                || (comp = this.Z1.CompareTo(other.Z1)) != 0)
            {
                return comp;
            }
            return 0;
        }
    }
}

```

`MapleNecrocer/Client/Particle/Particle.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Xna.Framework;
using Color =Microsoft.Xna.Framework.Color;

namespace WzComparerR2.MapRender2
{
    public class Particle
    {
        public Vector2 Pos;
        public float Angle;
        public Color StartColor;
        public Color EndColor;
        public float StartSize;
        public float EndSize;
        public float StartSpin;
        public float EndSpin;
        public float Life;

        //gravity
        public Vector2 Dir;
        public float RadialAcc;
        public float TangentialAcc;

        //radius
        public float StartRadius;
        public float EndRadius;
        public float RotatePerSecond;

        //lifecycle
        public float Time;
        public float NormalizedTime;

        public void Reset()
        {
            this.Pos = Vector2.Zero;
            this.StartColor = new Color();
            this.EndColor = new Color();
            this.StartSize = 0;
            this.EndSize = 0;
            this.StartSpin = 0;
            this.EndSpin = 0;
            this.Life = 0;

            this.Dir = Vector2.Zero;
            this.RadialAcc = 0;
            this.TangentialAcc = 0;

            this.StartRadius = 0;
            this.EndRadius = 0;
            this.RotatePerSecond = 0;

            this.Time = 0;
            this.NormalizedTime = 0;
        }
    }
}

```

`MapleNecrocer/Client/Particle/ParticleData.cs`:

```cs
using WzComparerR2.WzLib;
using WzComparerR2.Common;
using WzComparerR2.MapRender.Patches3;
using WzComparerR2.PluginBase;
using Microsoft.Xna.Framework;

namespace WzComparerR2.MapRender2
{
    public class ParticleData
    {
        public ParticleData(IRandom random)
        {
            this.Scene = new MapScene();
            this.random = random;
        }

        public MapScene Scene { get; private set; }

        private readonly IRandom random;
        public ParticleItem ParticleItem1;

        public void LoadParticleData1(Wz_Node Node, ResourceLoader resLoader)
        {
            LoadParticle1(Node);
            PreloadResource(resLoader, ParticleItem1);
        }

        private void LoadParticle1(Wz_Node Node)
        {
            ParticleItem1 = ParticleItem.LoadFromNode(Node);
            ParticleItem1.Name = Node.Text;
        }

        private void PreloadResource(ResourceLoader resLoader, ParticleItem particle)
        {
            string path = $@"Effect\particle.img\{particle.ParticleName}";
            var particleNode = PluginManager.FindWz(path);

            if (particleNode == null)
            {
                return;
            }

            var desc = resLoader.LoadParticleDesc(particleNode);

            var pSystem = new ParticleSystem(this.random);

            pSystem.LoadDescription(desc);

            for (int i = 0; i < particle.SubItems.Length; i++)
            {
                var subItem = particle.SubItems[i];

                var pGroup = pSystem.CreateGroup(i.ToString());
                pGroup.Position = new Vector2(subItem.X, subItem.Y);
                pGroup.Active();
                pSystem.Groups.Add(pGroup);

            }

            if (pSystem.Groups.Count == 0)
            {
                pSystem = new ParticleSystem(this.random);
            }

            particle.View = new ParticleItem.ItemView()
            {
                ParticleSystem = pSystem
            };
        }

    }
}

```

`MapleNecrocer/Client/Particle/ParticleDesc.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using WzComparerR2.WzLib;
using WzComparerR2.Animation;
using Color = Microsoft.Xna.Framework.Color;

namespace WzComparerR2.MapRender2
{
    public class ParticleDesc
    {
        public string Name { get; set; }
        public int TotalParticle { get; set; }
        public float Angle { get; set; }
        public float AngleVar { get; set; }
        public float Duration { get; set; }
        public ParticleBlendFunc BlendFuncSrc { get; set; }
        public ParticleBlendFunc BlendFuncDst { get; set; }
        public Color StartColor { get; set; }
        public Color StartColorVar { get; set; }
        public Color EndColor { get; set; }
        public Color EndColorVar { get; set; }
        public int MiddlePoint0 { get; set; }
        public int MiddlePointAlpha0 { get; set; }
        public int MiddlePoint1 { get; set; }
        public int MiddlePointAlpha1 { get; set; }
        public float StartSize { get; set; }
        public float StartSizeVar { get; set; }
        public float EndSize { get; set; }
        public float EndSizeVar { get; set; }
        public float PosX { get; set; }
        public float PosY { get; set; }
        public float PosVarX { get; set; }
        public float PosVarY { get; set; }
        public float StartSpin { get; set; }
        public float StartSpinVar { get; set; }
        public float EndSpin { get; set; }
        public float EndSpinVar { get; set; }
        public ParticleGravityDesc Gravity { get; set; }
        public ParticleRadiusDesc Radius { get; set; }
        public float Life { get; set; }
        public float LifeVar { get; set; }
        public bool OpacityModifyRGB { get; set; }
        public int PositionType { get; set; }
        public Frame Texture { get; set; }
    }

    public class ParticleGravityDesc
    {
        public float X { get; set; }
        public float Y { get; set; }
        public float Speed { get; set; }
        public float SpeedVar { get; set; }
        public float RadialAccel { get; set; }
        public float RadialAccelVar { get; set; }
        public float TangentialAccel { get; set; }
        public float TangentialAccelVar { get; set; }
        public bool RotationIsDir { get; set; }
    }

    public class ParticleRadiusDesc
    {
        public float StartRadius { get; set; }
        public float StartRadiusVar { get; set; }
        public float EndRadius { get; set; }
        public float EndRadiusVar { get; set; }
        public float RotatePerSecond { get; set; }
        public float RotatePerSecondVar { get; set; }
    }

    //same as d3d11blend
    public enum ParticleBlendFunc
    {
        ZERO = 1,
        ONE = 2,
        SRC_COLOR = 3,
        INV_SRC_COLOR = 4,
        SRC_ALPHA = 5,
        INV_SRC_ALPHA = 6,
        DEST_ALPHA = 7,
        INV_DEST_ALPHA = 8,
        DEST_COLOR = 9,
        INV_DEST_COLOR = 10,
    }
}

```

`MapleNecrocer/Client/Particle/ParticleEmitter.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.Xna.Framework;
using Color = Microsoft.Xna.Framework.Color;

namespace WzComparerR2.MapRender2
{
    public class ParticleEmitter
    {
        public ParticleEmitter(ParticleSystem particleSystem)
        {
            this.Owner = particleSystem;
        }

        public ParticleSystem Owner { get; private set; }

        //初始速度方向
        public float Angle { get; set; }
        public float AngleVar { get; set; }
        //颜色
        public Color StartColor { get; set; }
        public Color StartColorVar { get; set; }
        public Color EndColor { get; set; }
        public Color EndColorVar { get; set; }
        //大小
        public float StartSize { get; set; }
        public float StartSizeVar { get; set; }
        public float EndSize { get; set; }
        public float EndSizeVar { get; set; }
        //位置
        public Vector2 Pos { get; set; }
        public Vector2 PosVar { get; set; }
        //旋转
        public float StartSpin { get; set; }
        public float StartSpinVar { get; set; }
        public float EndSpin { get; set; }
        public float EndSpinVar { get; set; }

        //gravity相关
        public float Speed { get; set; }
        public float SpeedVar { get; set; }
        public float RadialAccel { get; set; }
        public float RadialAccelVar { get; set; }
        public float TangentialAccel { get; set; }
        public float TangentialAccelVar { get; set; }
        public bool RotationIsDir { get; set; }

        //radius相关
        public float StartRadius { get; set; }
        public float StartRadiusVar { get; set; }
        public float EndRadius { get; set; }
        public float EndRadiusVar { get; set; }
        public float RotatePerSecond { get; set; }
        public float RotatePerSecondVar { get; set; }

        //life
        public float Life { get; set; }
        public float LifeVar { get; set; }

        //发射频率
        public float EmissionRate { get; set; } = 200;

        public Particle Emit()
        {
            var particle = this.CreateParticle();
            this.InitParticle(particle);
            return particle;
        }

        private Particle CreateParticle()
        {
            Particle particle;
            if (this.Owner.ParticlePool.Count > 0)
            {
                particle = this.Owner.ParticlePool.Pop();
                particle.Reset();
            }
            else
            {
                particle = new Particle();
            }
            return particle;
        }

        private void InitParticle(Particle particle)
        {  
            
            var r = this.Owner.Rand;
            //计算位置 大小 颜色 自旋
            particle.Pos = r.NextVar(this.Pos, this.PosVar);
            particle.StartSize = r.NextVar(this.StartSize, this.StartSizeVar, true);
            particle.EndSize = r.NextVar(this.EndSize, this.EndSizeVar, true);
            particle.StartColor = r.NextVar(this.StartColor, this.StartColorVar);
            particle.EndColor = r.NextVar(this.EndColor, this.EndColorVar);
            particle.StartSpin = r.NextVar(this.StartSpin, this.StartSpinVar);
            particle.EndSpin = r.NextVar(this.EndSpin, this.EndSpinVar);
           
            //计算速度方向
            var speed = r.NextVar(this.Speed, this.SpeedVar);
            var rotAngle = r.NextVar(this.Angle, this.AngleVar);
            var rot = MathHelper.ToRadians(rotAngle);
            var dir = new Vector2((float)Math.Cos(rot), -(float)Math.Sin(rot));
            particle.Dir = dir * speed;
            if (this.RotationIsDir)
            {
                var deltaSpin = particle.EndSpin - particle.StartSpin;
                particle.StartSpin = rotAngle;
                particle.EndSize = rotAngle + deltaSpin;
            }

            //计算圆周运动
            particle.StartRadius = r.NextVar(this.StartRadius, this.StartRadiusVar, true);
            particle.EndRadius = r.NextVar(this.EndRadius, this.EndRadiusVar, true);
            particle.RotatePerSecond = r.NextVar(this.RotatePerSecond, this.RotatePerSecondVar, true);
            particle.Angle = rotAngle;

            //初始化加速度
            particle.RadialAcc = r.NextVar(this.RadialAccel, this.RadialAccelVar);
            particle.TangentialAcc = r.NextVar(this.TangentialAccel, this.TangentialAccelVar);

            //生命周期
            particle.Life = r.NextVar(this.Life, this.LifeVar, true);
        }
    }
}

```

`MapleNecrocer/Client/Particle/ParticleItem.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WzComparerR2.WzLib;
using WzComparerR2.MapRender2;

namespace WzComparerR2.MapRender.Patches3
{
    public class ParticleItem : SceneItem
    {
        public string ParticleName { get; set; }
        public int Rx { get; set; }
        public int Ry { get; set; }
        public int Z { get; set; }
        public SubParticleItem[] SubItems { get; set; }
        public List<Tuple<int, int>> Quest { get; set; }
        public ItemView View { get; set; }

        public static ParticleItem LoadFromNode(Wz_Node node)
        {
            var item = new ParticleItem()
            {
                ParticleName = node.Text,
                Rx = node.Nodes["rx"].GetValueEx(-100),
                Ry = node.Nodes["ry"].GetValueEx(-100),
                Z = node.Nodes["z"].GetValueEx(0)
            };

            item.Quest = new List<Tuple<int, int>>();
            if (node.Nodes["quest"] != null)
            {
                foreach (Wz_Node questNode in node.Nodes["quest"].Nodes)
                {
                    item.Quest.Add(Tuple.Create(int.Parse(questNode.Text), Convert.ToInt32(questNode.Value)));
                }
            }

            var subItems = new List<SubParticleItem>();
            for (int i = 0; ; i++)
            {
                var subNode = node.Nodes[i.ToString()];
                if (subNode == null)
                {
                    break;
                }
                var subitem = new SubParticleItem()
                {
                    X = subNode.Nodes["x"].GetValueEx(0),
                    Y = subNode.Nodes["y"].GetValueEx(0),
                };
                subitem.Quest = new List<Tuple<int, int>>();
                if (subNode.Nodes["quest"] != null)
                {
                    foreach (Wz_Node questNode in subNode.Nodes["quest"].Nodes)
                    {
                        subitem.Quest.Add(Tuple.Create(int.Parse(questNode.Text), Convert.ToInt32(questNode.Value)));
                    }
                }
                subItems.Add(subitem);
            }
            
            if (subItems.Count <= 0)
            {
                subItems.Add(new SubParticleItem()
                {
                    X = node.Nodes["x"].GetValueEx(0),
                    Y = node.Nodes["y"].GetValueEx(0),
                });
            }
            item.SubItems = subItems.ToArray();
            return item;
        }

        public class SubParticleItem
        {
            public int X { get; set; }
            public int Y { get; set; }
            public List<Tuple<int, int>> Quest { get; set; }
        }

        public class ItemView
        {
            public ParticleSystem ParticleSystem { get; set; }
        }
    }
}

```

`MapleNecrocer/Client/Particle/ParticleRandom.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Xna.Framework;
using Color = Microsoft.Xna.Framework.Color;

namespace WzComparerR2.MapRender2
{
    class ParticleRandom : IRandom
    {
        public ParticleRandom() : this(new Random())
        {

        }

        public ParticleRandom(Random random)
        {
            this.Random = random;
        }

        public Random Random { get; private set; }

        private double NextMinOneToOne()
        {
            return this.Random.NextDouble() * 2 - 1;
        }

        public float NextVar(float baseValue, float varRange, bool nonNegative = false)
        {
            if (varRange == 0)
            {
                return baseValue;
            }

            var val = baseValue + (float)this.NextMinOneToOne() * varRange;
            if (nonNegative && val < 0)
            {
                val = 0;
            }
            return val;
        }

        public int NextVar(int baseValue, int varRange, bool nonNegative = false)
        {
            if (varRange == 0)
            {
                return baseValue;
            }
            var val = this.Random.Next(baseValue - varRange, baseValue + varRange + 1);
            if (nonNegative && val < 0)
            {
                val = 0;
            }
            return val;
        }

        public Vector2 NextVar(Vector2 baseValue, Vector2 varRange)
        {
            var x = this.NextVar(baseValue.X, varRange.X, false);
            var y = this.NextVar(baseValue.Y, varRange.Y, false);
            return new Vector2(x, y);
        }

        public Color NextVar(Color baseValue, Color varRange)
        {
            var baseColorVec = baseValue.ToVector4();
            var varRangeVec = varRange.ToVector4();
            var r = this.NextVar(baseColorVec.X, varRangeVec.X, false);
            var g = this.NextVar(baseColorVec.Y, varRangeVec.Y, false);
            var b = this.NextVar(baseColorVec.Z, varRangeVec.Z, false);
            var a = this.NextVar(baseColorVec.W, varRangeVec.W, false);
            return new Color(r, g, b, a);
        }

        public int Next(int maxValue)
        {
            return this.Random.Next(maxValue);
        }

        public bool NextPercent(float percent)
        {
            return this.Random.NextDouble() < percent;
        }
    }
}

```

`MapleNecrocer/Client/Particle/ParticleRender.cs`:

```cs
namespace WzComparerR2.MapRender2;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WzComparerR2.MapRender.Patches3;
using WzComparerR2.MapRender2;
using MapleNecrocer;
using Microsoft.Xna.Framework;
public class ParticleRender
{
    public RenderEnv renderEnv;
    public MeshBatcher batcher;
    public ParticleData ParticleData;
    public void DrawParticle1(float X, float Y)
    {
        if (this.ParticleData == null)
        {
            return;
        }
        this.batcher.Begin(Matrix.CreateTranslation(X, Y, 0));
        var Item = GetMesh(ParticleData.ParticleItem1);
        this.batcher.Draw(Item);
        this.batcher.End();
    }

    public void Update1(TimeSpan elapsed)
    {
        ParticleData.ParticleItem1.View?.ParticleSystem.Update(elapsed);
    }
   
    private MeshItem GetMesh(SceneItem item)
    {
        if (item is ParticleItem)
        {
            return GetMeshParticle((ParticleItem)item);
        }
        return null;
    }

    private MeshItem GetMeshParticle(ParticleItem particle)
    {
        var pSystem = particle.View?.ParticleSystem;
        if (pSystem == null)
        {
            return null;
        }

        Vector2 position;
        position.X = renderEnv.Camera.Center.X * (100 + particle.Rx) / 100;
        position.Y = renderEnv.Camera.Center.Y * (100 + particle.Ry) / 100;

        var mesh = batcher.MeshPop();
        mesh.RenderObject = pSystem;
        mesh.Position = position;
        mesh.Z0 = particle.Z;

        return mesh;
    }


}


```

`MapleNecrocer/Client/Particle/ParticleSystem.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using WzComparerR2.Animation;
using Color=Microsoft.Xna.Framework.Color;
using MapleNecrocer;
namespace WzComparerR2.MapRender2
{
    public class ParticleSystem
    {
        public ParticleSystem(IRandom random)
        {
            this.Rand = random;
            this.ParticlePool = new Stack<Particle>();
            this.Groups = new List<ParticleGroup>();
        }

        public IRandom Rand { get; private set; }
        public Stack<Particle> ParticlePool { get; private set; }
        public ParticleEmitter Emitter { get; private set; }
        public List<ParticleGroup> Groups { get; private set; }

        public int ParticleCount { get; set; }
        public float Duration { get; set; }
        public Vector2 Gravity { get; set; }
        public Frame Texture { get; set; }
        public bool OpacityModifyRGB { get; set; }
        public ParticleBlendFunc BlendFuncSrc { get; set; }
        public ParticleBlendFunc BlendFuncDst { get; set; }

        private AlphaPoint[] alphaPoints;

        public void LoadDescription(ParticleDesc desc)
        {
            this.Texture = desc.Texture;
            this.ParticleCount = desc.TotalParticle;
            this.Duration = desc.Duration;
            this.OpacityModifyRGB = desc.OpacityModifyRGB;
            if (desc.Gravity != null)
            {
                this.Gravity = new Vector2(desc.Gravity.X, desc.Gravity.Y);
            }
            var alphaPointList = new List<AlphaPoint>();
            if (desc.MiddlePoint0 > 0)
            {
                alphaPointList.Add(new AlphaPoint(desc.MiddlePoint0 / 100f, desc.MiddlePointAlpha0));
            }
            if (desc.MiddlePoint1 > 0)
            {
                alphaPointList.Add(new AlphaPoint(desc.MiddlePoint1 / 100f, desc.MiddlePointAlpha1));
            }
            this.alphaPoints = alphaPointList.ToArray();
            this.BlendFuncSrc = desc.BlendFuncSrc;
            this.BlendFuncDst = desc.BlendFuncDst;
            this.CreateEmitter(desc);
        }

        private void CreateEmitter(ParticleDesc desc)
        {
            var emitter = new ParticleEmitter(this);
            emitter.Angle = desc.Angle;
            emitter.AngleVar = desc.AngleVar;
            emitter.StartColor = desc.StartColor;
            emitter.StartColorVar = desc.StartColorVar;
            emitter.EndColor = desc.EndColor;
            emitter.EndColorVar = desc.EndColorVar;
            emitter.StartSize = desc.StartSize;
            emitter.StartSizeVar = desc.StartSizeVar;
            emitter.EndSize = desc.EndSize;
            emitter.EndSizeVar = desc.EndSizeVar;
            emitter.Pos = new Vector2(desc.PosX, desc.PosY);
            emitter.PosVar = new Vector2(desc.PosVarX, desc.PosVarY);
            emitter.StartSpin = desc.StartSpin;
            emitter.StartSpinVar = desc.StartSpinVar;
            emitter.EndSpin = desc.EndSpin;
            emitter.EndSpinVar = desc.EndSpinVar;
            if (desc.Gravity != null)
            {
                emitter.Speed = desc.Gravity.Speed;
                emitter.SpeedVar = desc.Gravity.SpeedVar;
                emitter.RadialAccel = desc.Gravity.RadialAccel;
                emitter.RadialAccelVar = desc.Gravity.RadialAccelVar;
                emitter.TangentialAccel = desc.Gravity.TangentialAccel;
                emitter.TangentialAccelVar = desc.Gravity.TangentialAccelVar;
                emitter.RotationIsDir = desc.Gravity.RotationIsDir;
            }
            if (desc.Radius != null)
            {

            }
            emitter.Life = desc.Life;
            emitter.LifeVar = desc.LifeVar;

            //计算发射速率
            if (desc.Duration > 0)
            {
                emitter.EmissionRate = desc.TotalParticle / Math.Min(desc.Duration, 1);
            }
            else
            {
                float lifeMin = Math.Max(0, desc.Life - desc.LifeVar);
                float lifeMax = Math.Max(0, desc.Life + desc.LifeVar);
                var life = (lifeMin + lifeMax) / 2;
                if (life <= 0)
                {
                    life = 1;
                }
                emitter.EmissionRate = desc.TotalParticle / life;
            }

            this.Emitter = emitter;
        }

        public ParticleGroup CreateGroup(string name = null)
        {
            var pGroup = new ParticleGroup(this);
            pGroup.Name = name;
            pGroup.Particles.Capacity = this.ParticleCount;
            return pGroup;
        }

        public void Update(TimeSpan elapsed)
        {
            foreach (var pGroup in this.Groups)
            {
                this.UpdateGroup(pGroup, elapsed);
            }
        }

        public void UpdateGroup(ParticleGroup pGroup, TimeSpan elapsed)
        {
            var time = (float)elapsed.TotalSeconds;
            
            if (pGroup.IsActive)
            {
                if (pGroup.Particles.Count < this.ParticleCount) //生成粒子
                {
                   
                    float emitCount = this.Emitter.EmissionRate * time;
                    var count = (int)emitCount + (this.Rand.NextPercent(emitCount % 1) ? 1 : 0);
                    count = Math.Min(count, this.ParticleCount - pGroup.Particles.Count);
                    
                    for (int i = 0; i < count; i++)
                    {
                        

                        var p = this.Emitter.Emit();
                        if (p.Life <= 0) //fix bug
                        {
                            continue;
                        }
                        pGroup.Particles.Add(p);
                    }
                }

                //计算时间
                if (this.Duration > 0)
                {
                    pGroup.Time += time;
                    if (pGroup.Time > this.Duration)
                    {
                        pGroup.IsActive = false;
                    }
                }
            }
            
            //更新所有粒子
            if (pGroup.Particles.Count > 0)
            {
                pGroup.Particles.ForEach(p =>
                {
                    p.Time += time;
                    p.NormalizedTime = p.Life <= 0 ? 0 : (p.Time / p.Life);
                    if (p.NormalizedTime >= 1)
                    {
                        return;
                    }

                    //更新粒子
                    var accDir = p.Pos;
                    if (accDir != Vector2.Zero) //计算方向
                    {
                        accDir.Normalize();
                    }
                    var radial = accDir * p.RadialAcc; //法线加速度矢量
                    //var tangent = new Vector2(-accDir.Y, accDir.X) * p.TangentialAcc; //切线加速度矢量
                    var tangent = Vector2.Zero; //tangent not works in the game?
                    var acc = this.Gravity + radial + tangent; //总加速度矢量
                    p.Dir += acc * time; //计算加速度
                    p.Pos += p.Dir * time; //计算位置

                    //计算旋转
                    p.Angle += p.RotatePerSecond * time;
                    var rad = MathHelper.Lerp(p.StartRadius, p.EndRadius, p.NormalizedTime);
                    if (rad > 0)
                    {
                        var radian = MathHelper.ToRadians(p.Angle);
                        accDir = new Vector2((float)Math.Cos(radian), (float)Math.Sin(radian));
                        p.Pos += accDir * rad * time;
                    }
                });

                //回收粒子
                pGroup.Particles.RemoveAll(p =>
                {
                    if (p.NormalizedTime >= 1)
                    {
                        this.CollectParticle(p);
                        return true;
                    }
                    else
                    {
                        return false;
                    }
                });
            }
        }

        private void CollectParticle(Particle particle)
        {
            this.ParticlePool.Push(particle);
        }

        public void Draw(SpriteBatch sprite, Vector2 position)
        {
            foreach (var pGroup in this.Groups)
            {
                this.DrawGroup(sprite, pGroup, position);
               
            }

           
        }

        public void DrawGroup(SpriteBatch sprite, ParticleGroup pGroup, Vector2 position)
        {
            
            if (this.Texture?.Texture == null)
            {
                return;
            }
         
            var textureSize = this.Texture.AtlasRect?.Size.ToVector2() ?? new Vector2(this.Texture.Texture.Width, this.Texture.Texture.Height);
            var rad = textureSize.Length() / (float)Math.Sqrt(2);
            var origin = this.Texture.Origin.ToVector2();
            position += pGroup.Position;
             
            foreach (var p in pGroup.Particles)
            {
              
                var color = Lerp(p.StartColor, p.EndColor, p.NormalizedTime);
                var size = MathHelper.Lerp(p.StartSize, p.EndSize, p.NormalizedTime);
                var scale = size / rad;
                var rot = MathHelper.ToRadians(MathHelper.Lerp(p.StartSpin, p.EndSpin, p.NormalizedTime));
                //重新计算alpha
                if (this.alphaPoints.Length > 0)
                {
                    color.A = (byte)CalcAlphaFromPoints(p);
                }

                if (this.OpacityModifyRGB)
                {
                    if (color.R == 0 && color.G == 0 && color.B == 0)
                    {
                        color.R = color.G = color.B = color.A;
                    }
                    else
                    {
                        //float alpha = color.A / 255.0f; ;
                        //color.R = (byte)(color.R * alpha);
                        //color.G = (byte)(color.G * alpha);
                        //color.B = (byte)(color.B * alpha);
                    }
                }

                var pos = p.Pos + position;
                sprite.Draw(this.Texture.Texture, pos, this.Texture.AtlasRect, color, rot, origin, scale, SpriteEffects.None, 0);
               
            }

            
        }

        private int CalcAlphaFromPoints(Particle p)
        {
            int? alpha = null;
            var time = p.NormalizedTime;
            if (time < this.alphaPoints[0].Time)
            {
                alpha = Lerp(p.StartColor.A, this.alphaPoints[0].Alpha,
                    0, this.alphaPoints[0].Time,
                    time);
            }
            for (int i = 1; alpha == null && i < this.alphaPoints.Length; i++)
            {
                if (time < this.alphaPoints[i].Time)
                {
                    alpha = Lerp(this.alphaPoints[i - 1].Alpha, this.alphaPoints[i].Alpha,
                        this.alphaPoints[i - 1].Time, this.alphaPoints[i].Time,
                        time);
                    break;
                }
            }
            if (alpha == null)
            {
                alpha = Lerp(this.alphaPoints[this.alphaPoints.Length - 1].Alpha, p.EndColor.A,
                  this.alphaPoints[this.alphaPoints.Length - 1].Time, 1,
                  time);
            }
            return alpha.Value;
        }

        private Color Lerp(Color color1, Color color2, float amount)
        {
            return new Color(
                (byte)MathHelper.Lerp(color1.R, color2.R, amount),
                (byte)MathHelper.Lerp(color1.G, color2.G, amount),
                (byte)MathHelper.Lerp(color1.B, color2.B, amount),
                (byte)MathHelper.Lerp(color1.A, color2.A, amount)
                );
        }

        private int Lerp(int int1, int int2, float from, float to, float value)
        {
            if (from == to)
            {
                return int2;
            }

            var amount = (value - from) / (to - from);
            return (int)MathHelper.Lerp(int1, int2, amount);
        }

        private struct AlphaPoint
        {
            public AlphaPoint(float time, int alpha)
            {
                this.Time = time;
                this.Alpha = alpha;
            }

            public float Time;
            public int Alpha;
        }
    }

    public class ParticleGroup
    {
        public ParticleGroup(ParticleSystem owner)
        {
            this.Owner = owner;
            this.Particles = new List<Particle>();
        }

        public ParticleSystem Owner { get; private set; }
        public string Name { get; set; }
        public List<Particle> Particles { get; private set; }
        public Vector2 Position { get; set; }
        public float Time { get; set; }
        public bool IsActive { get; set; }

        public void Active()
        {
            this.IsActive = true;
            this.Time = 0;
        }
    }
}

```

`MapleNecrocer/Client/Particle/RenderEnv.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using WzComparerR2.Rendering;
namespace WzComparerR2.MapRender2;
public class RenderEnv : IDisposable
{
    public RenderEnv(GraphicsDevice graphics)
    {
        this.GraphicsDevice = graphics;
        this.Camera = new Camera(graphics);
        this.Camera.AdjustToWorldRect();
        this.Sprite = new SpriteBatchEx(this.GraphicsDevice);
        this.D2DRenderer = new D2DRenderer(this.GraphicsDevice);
    }
    public Camera Camera { get; private set; }
    public SpriteBatchEx Sprite { get; private set; }
    public D2DRenderer D2DRenderer { get; private set; }
    public GraphicsDevice GraphicsDevice { get; private set; }

    public void Dispose()
    {
        this.Dispose(true);
    }

    protected virtual void Dispose(bool disposing)
    {
        if (disposing)
        {
            this.Sprite.Dispose();
           // this.Fonts.Dispose();
        }
    }
}

```

`MapleNecrocer/Client/Particle/ResourceLoader.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using WzComparerR2.WzLib;
using WzComparerR2.PluginBase;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Content;
using WzComparerR2.Animation;
using WzComparerR2.Rendering;
using WzComparerR2.Common;
using Spine;
using Point = Microsoft.Xna.Framework.Point;

namespace WzComparerR2.MapRender2
{
    public class ResourceLoader : IDisposable
    {
        public ResourceLoader(GraphicsDevice gDevice)
        {
            this.graphicsDevice= gDevice;
            this.loadedItems = new Dictionary<string, ResourceHolder>();
            this.loadedAnimationData = new Dictionary<string, object>();
        }
       
        GraphicsDevice graphicsDevice;
        protected Dictionary<string, ResourceHolder> loadedItems;
        protected Dictionary<string, object> loadedAnimationData;
        private bool isCounting;
        /*
        private GraphicsDevice GraphicsDevice
        {
            get
            {
                return this.Services.GetService();
               // return this.Services.GetService(GraphicsDevice);
            }
        }
        */
        public virtual T Load<T>(string assetName)
        {
            return Load<T>(null, assetName);
        }

        public virtual T Load<T>(Wz_Node node)
        {
            return Load<T>(node, null);
        }

        private T Load<T>(Wz_Node node = null, string assetName = null)
        {
            if (node == null && assetName == null)
                throw new ArgumentNullException();

            assetName = assetName ?? node.FullPathToFile;

            ResourceHolder holder;
            if (!loadedItems.TryGetValue(assetName, out holder))
            {
                var res = InnerLoad(node ?? PluginManager.FindWz(assetName), typeof(T));
                if (res == null)
                {
                    return default(T);
                }

                holder = new ResourceHolder();
                holder.Resource = res;
                loadedItems[assetName] = holder;
            }

            //结算计数器
            if (isCounting)
            {
                holder.Count++;
            }

            //特殊处理
            return (T)holder.Resource;
        }

        public object LoadAnimationData(Wz_Node node)
        {
            object aniData;
            string assetName = node.FullPathToFile;
            if (!loadedAnimationData.TryGetValue(assetName, out aniData))
            {
                aniData = InnerLoadAnimationData(node);
                if (aniData == null)
                {
                    return null;
                }
                loadedAnimationData[assetName] = aniData;
            }
            return aniData;
        }

        public object LoadAnimationData(string assetName)
        {
            var node = PluginManager.FindWz(assetName);
            return node != null ? LoadAnimationData(node) : null;
        }

        public ParticleDesc LoadParticleDesc(Wz_Node node)
        {
            var desc = new ParticleDesc();
            desc.Name = node.Text;
            foreach (var pNode in node.Nodes)
            {
                switch (pNode.Text)
                {
                    case "totalParticle": desc.TotalParticle = pNode.GetValue<int>(); break;
                    case "angle": desc.Angle = pNode.GetValue<float>(); break;
                    case "angleVar": desc.AngleVar = pNode.GetValue<float>(); break;
                    case "duration": desc.Duration = pNode.GetValue<float>(); break;
                    case "blendFuncSrc": desc.BlendFuncSrc = (ParticleBlendFunc)pNode.GetValue<int>(); break;
                    case "blendFuncDst": desc.BlendFuncDst = (ParticleBlendFunc)pNode.GetValue<int>(); break;
                    case "startColor": desc.StartColor = System.Drawing.Color.FromArgb(pNode.GetValue<int>()).ToXnaColor(); break;
                    case "startColorVar": desc.StartColorVar = System.Drawing.Color.FromArgb(pNode.GetValue<int>()).ToXnaColor(); break;
                    case "endColor": desc.EndColor = System.Drawing.Color.FromArgb(pNode.GetValue<int>()).ToXnaColor(); break;
                    case "endColorVar": desc.EndColorVar = System.Drawing.Color.FromArgb(pNode.GetValue<int>()).ToXnaColor(); break;
                    case "MiddlePoint0": desc.MiddlePoint0 = pNode.GetValue<int>(); break;
                    case "MiddlePointAlpha0": desc.MiddlePointAlpha0 = pNode.GetValue<int>(); break;
                    case "MiddlePoint1": desc.MiddlePoint1 = pNode.GetValue<int>(); break;
                    case "MiddlePointAlpha1": desc.MiddlePointAlpha1 = pNode.GetValue<int>(); break;
                    case "startSize": desc.StartSize = pNode.GetValue<float>(); break;
                    case "startSizeVar": desc.StartSizeVar = pNode.GetValue<float>(); break;
                    case "endSize": desc.EndSize = pNode.GetValue<float>(); break;
                    case "endSizeVar": desc.EndSizeVar = pNode.GetValue<float>(); break;
                    case "posX": desc.PosX = pNode.GetValue<float>(); break;
                    case "posY": desc.PosY = pNode.GetValue<float>(); break;
                    case "posVarX": desc.PosVarX = pNode.GetValue<float>(); break;
                    case "posVarY": desc.PosVarY = pNode.GetValue<float>(); break;
                    case "startSpin": desc.StartSpin = pNode.GetValue<float>(); break;
                    case "startSpinVar": desc.StartSpinVar = pNode.GetValue<float>(); break;
                    case "endSpin": desc.EndSpin = pNode.GetValue<float>(); break;
                    case "endSpinVar": desc.EndSpinVar = pNode.GetValue<float>(); break;
                    case "GRAVITY":
                        {
                            var gravityDesc = new ParticleGravityDesc();
                            foreach (var pNode2 in pNode.Nodes)
                            {
                                switch (pNode2.Text)
                                {
                                    case "x": gravityDesc.X = pNode2.GetValue<float>(); break;
                                    case "y": gravityDesc.Y = pNode2.GetValue<float>(); break;
                                    case "speed": gravityDesc.Speed = pNode2.GetValue<float>(); break;
                                    case "speedVar": gravityDesc.SpeedVar = pNode2.GetValue<float>(); break;
                                    case "radialAccel": gravityDesc.RadialAccel = pNode2.GetValue<float>(); break;
                                    case "radialAccelVar": gravityDesc.RadialAccelVar = pNode2.GetValue<float>(); break;
                                    case "tangentialAccel": gravityDesc.TangentialAccel = pNode2.GetValue<float>(); break;
                                    case "tangentialAccelVar": gravityDesc.TangentialAccelVar = pNode2.GetValue<float>(); break;
                                    case "rotationIsDir": gravityDesc.RotationIsDir = pNode2.GetValue<int>() != 0; break;
                                }
                            }
                            desc.Gravity = gravityDesc;
                        }
                        break;
                    case "RADIUS":
                        {
                            var radiusDesc = new ParticleRadiusDesc();
                            foreach (var pNode2 in pNode.Nodes)
                            {
                                switch (pNode2.Text)
                                {
                                    case "startRadius": radiusDesc.StartRadius = pNode2.GetValue<float>(); break;
                                    case "startRadiusVar": radiusDesc.StartRadiusVar = pNode2.GetValue<float>(); break;
                                    case "endRadius": radiusDesc.EndRadius = pNode2.GetValue<float>(); break;
                                    case "endRadiusVar": radiusDesc.EndRadiusVar = pNode2.GetValue<float>(); break;
                                    case "rotatePerSecond": radiusDesc.RotatePerSecond = pNode2.GetValue<float>(); break;
                                    case "rotatePerSecondVar": radiusDesc.RotatePerSecondVar = pNode2.GetValue<float>(); break;
                                }
                            }
                            desc.Radius = radiusDesc;
                        }
                        break;
                    case "life": desc.Life = pNode.GetValue<float>(); break;
                    case "lifeVar": desc.LifeVar = pNode.GetValue<float>(); break;
                    case "opacityModifyRGB": desc.OpacityModifyRGB = pNode.GetValue<int>() != 0; break;
                    case "positionType": desc.PositionType = pNode.GetValue<int>(); break;
                    case "texture":
                        desc.Texture = this.LoadFrame(pNode);
                        break;
                }
            }
            return desc;
        }

        public void BeginCounting()
        {
            foreach (var kv in this.loadedItems)
            {
                kv.Value.Count = 0;
            }
            isCounting = true;
        }

        public void EndCounting()
        {
            isCounting = false;
        }

        public void ClearAnimationCache()
        {
            this.loadedAnimationData.Clear();
        }

        public void Recycle()
        {
            var preRemoved = this.loadedItems
                .Where(kv => kv.Value.Count <= 0)
                .ToList();

            foreach (var kv in preRemoved)
            {
                this.loadedItems.Remove(kv.Key);
                UnloadResource(kv.Value.Resource);
            }
        }

        public void Unload()
        {
            foreach (var kv in this.loadedItems)
            {
                UnloadResource(kv.Value.Resource);
            }

            this.loadedItems.Clear();
            this.loadedAnimationData.Clear();
        }

        public void Dispose()
        {
            this.Dispose(true);
            GC.SuppressFinalize(this);
        }

        private void UnloadResource(object resource)
        {
            if (resource is Texture2D)
            {
                ((Texture2D)resource).Dispose();
            }
           // else if (resource is TextureAtlas) //回头再考虑回收策略
           // {
            //    ((TextureAtlas)resource).Texture.Dispose();
           // }
           // else if (resource is Music)
           // {
               // ((Music)resource).Dispose();
           // }
            else
            {
                (resource as IDisposable)?.Dispose();
            }
        }

        private object InnerLoad(Wz_Node node, Type assetType)
        {
            if (assetType == typeof(TextureAtlas)) //回头再说
            {
                var png = node.GetValue<Wz_Png>();
                if (png != null)
                {
                    return new TextureAtlas(png.ToTexture(this.graphicsDevice));
                }
            }
            else if (assetType == typeof(Texture2D))
            {
                var png = node.GetValue<Wz_Png>();
                if (png != null)
                {
                    return png.ToTexture(this.graphicsDevice);
                }
            }
           
            return null;
        }

        private object InnerLoadAnimationData(Wz_Node node)
        {
            if (node != null)
            {
                while (node.Value is Wz_Uol)
                {
                    node = ((Wz_Uol)node.Value).HandleUol(node);
                }

                if (node.Value is Wz_Png) //单帧动画
                {
                    var aniData = new FrameAnimationData();
                 //   var frame = LoadFrame(node);
                  //  aniData.Frames.Add(frame);
                    return aniData;
                }
                else if (node.Value == null && node.Nodes.Count > 0) //分析目录
                {
                    string spine = node.Nodes["spine"].GetValueEx<string>(null);
                    if (spine != null) //读取spine动画
                    {
                        var loader = new SpineTextureLoader(this, node);
                        var atlasNode = node.Nodes[spine + ".atlas"];
                        var aniData = SpineAnimationData.CreateFromNode(atlasNode, null, loader);
                        return aniData;
                    }
                    else //读取序列帧动画
                    {
                        var frames = new List<Frame>();
                        Wz_Node frameNode;
                        for (int i = 0; (frameNode = node.Nodes[i.ToString()]) != null; i++)
                        {
                            var frame = LoadFrame(frameNode);
                            frames.Add(frame);
                        }
                        var repeat = node.Nodes["repeat"].GetValueEx<bool>();
                      //  return new RepeatableFrameAnimationData(frames) { Repeat = repeat };
                    }
                }
            }
            return null;
        }

        private Frame LoadFrame(Wz_Node node)
        {
            //处理uol
            while (node?.Value is Wz_Uol uol)
            {
                node = uol.HandleUol(node);
            }
            if (node == null)
            {
                return new Frame();
            }
            //寻找link
            var linkNode = node.GetLinkedSourceNode(PluginManager.FindWz);
            //加载资源
            var atlas = Load<TextureAtlas>(linkNode);
            //读取其他信息
            var frame = new Frame()
            {
                Texture = atlas.Texture,
                AtlasRect = atlas.SrcRect,
                Z = node.Nodes["z"].GetValueEx(0),
                Delay = node.Nodes["delay"].GetValueEx(100),
                Blend = node.Nodes["blend"].GetValueEx(0) != 0,
                Origin = (node.Nodes["origin"]?.Value as Wz_Vector)?.ToPoint() ?? Point.Zero
            };
            frame.A0 = node.Nodes["a0"].GetValueEx(255);
            frame.A1 = node.Nodes["a1"].GetValueEx(frame.A0);
            return frame;
        }


        protected virtual void Dispose(bool disposing)
        {
            if (disposing)
            {
                Unload();
            }
        }

        ~ResourceLoader()
        {
            this.Dispose(false);
        }

        protected class ResourceHolder
        {
            public object Resource { get; set; }
            public int Count { get; set; }
        }

        private class SpineTextureLoader : Spine.TextureLoader
        {
            public SpineTextureLoader(ResourceLoader resLoader, Wz_Node topNode)
            {
                this.BaseLoader = resLoader;
                this.TopNode = topNode;
            }

            public ResourceLoader BaseLoader { get; set; }
            public Wz_Node TopNode { get; set; }

            public void Load(AtlasPage page, string path)
            {
                var frameNode = this.TopNode.FindNodeByPath(path);

                if (frameNode == null || frameNode.Value == null)
                {
                    return;
                }

                //处理uol
                while (frameNode.Value is Wz_Uol)
                {
                    frameNode = ((Wz_Uol)frameNode.Value).HandleUol(frameNode);
                }
                //寻找link
                var linkNode = frameNode.GetLinkedSourceNode(PluginManager.FindWz);
                //加载资源
                var texture = BaseLoader.Load<Texture2D>(linkNode);

                page.rendererObject = texture;
                page.width = texture.Width;
                page.height = texture.Height;
            }

            public void Unload(object texture)
            {
                //什么都不做
            }
        }
    }
}

```

`MapleNecrocer/Client/Particle/SceneItem.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace WzComparerR2.MapRender.Patches3
{
    public class SceneItem
    {
        public string Name { get; set; }
        public int Index { get; set; }
        public string Tag { get; set; }

        public override string ToString()
        {
            return $"{Name} {GetType().Name}";
        }
    }
}

```

`MapleNecrocer/Client/Particle/SceneNode.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Collections.ObjectModel;

namespace WzComparerR2.MapRender2
{
    public class SceneNode
    {
        public SceneNode()
        {
            this.Nodes = new SceneNodeCollection(this);
        }

        public SceneNode Parent { get; private set; }
        public SceneNodeCollection Nodes { get; private set; }


        public IEnumerable<SceneNode> Descendants()
        {
            foreach (var node in this.Nodes)
            {
                yield return node;
                foreach (var subNode in node.Descendants())
                {
                    yield return subNode;
                }
            }
        }

        public class SceneNodeCollection : Collection<SceneNode>
        {
            public SceneNodeCollection(SceneNode owner)
            {
                this._owner = owner;
            }

            private SceneNode _owner;

            public void AddRange(IEnumerable<SceneNode> nodes)
            {
                foreach (var node in nodes)
                {
                    this.Add(node);
                }
            }

            protected override void InsertItem(int index, SceneNode item)
            {
                if (item.Parent != null)
                    throw new ArgumentException("Item already has parent.");
                item.Parent = _owner;
                base.InsertItem(index, item);
            }

            protected override void SetItem(int index, SceneNode item)
            {
                if (item.Parent != null)
                    throw new ArgumentException("Item already has parent.");
                this[index].Parent = null;
                item.Parent = _owner;
                base.SetItem(index, item);
            }

            protected override void RemoveItem(int index)
            {
                this[index].Parent = null;
                base.RemoveItem(index);
            }

            protected override void ClearItems()
            {
                foreach (var item in this)
                    item.Parent = null;
                base.ClearItems();
            }
        }
    }
}

```

`MapleNecrocer/Client/Particle/TextMesh.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WzComparerR2.Rendering;
using Microsoft.Xna.Framework;
using Color=Microsoft.Xna.Framework.Color;
namespace WzComparerR2.MapRender2
{
    class TextMesh
    {
        public string Text { get; set; }
        //public IWcR2Font Font { get; set; }
        public Color BackColor { get; set; }
        public Color ForeColor { get; set; }
        public Margins Padding { get; set; }
        public Alignment Align { get; set; }
    }

    struct Margins
    {
        public Margins(int left, int right, int top, int bottom)
        {
            this.Left = left;
            this.Right = right;
            this.Top = top;
            this.Bottom = bottom;
        }

        public int Left { get; set; }
        public int Right { get; set; }
        public int Top { get; set; }
        public int Bottom { get; set; }
    }

    enum Alignment
    {
        Near = 0,
        Center = 1,
        Far = 2
    }
}

```

`MapleNecrocer/Client/Particle/TextureAtlas.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Rectangle =Microsoft.Xna.Framework.Rectangle;
namespace WzComparerR2.MapRender2
{
    public struct TextureAtlas
    {
        public TextureAtlas(Texture2D texture)
        {
            this.Texture = texture;
            this.SrcRect = null;
        }

        public TextureAtlas(Texture2D texture, Rectangle rect)
        {
            this.Texture = texture;
            this.SrcRect = rect;
        }

        public Texture2D Texture { get; set; }
        public Rectangle? SrcRect { get; set; }
    }
}

```

`MapleNecrocer/Client/Pet.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Vector2 = Microsoft.Xna.Framework.Vector2;
using WzComparerR2.WzLib;
using System.Drawing;
using Spine;

namespace MapleNecrocer;

public class Pet : JumperSprite
{
    public Pet(Sprite Parent) : base(Parent)
    {
        SpriteSheetMode = SpriteSheetMode.NoneSingle;
    }

    public int FTime;
    Foothold WallFH;
    Foothold BelowFH;
    MoveDirection MoveDirection;
    float MoveSpeed;
    string PetName;
    int NameWidth;
    int IDWidth;
    MoveType MoveType;
    int FallEdge;
    int JumpEdge;
    public Wz_Vector origin = new(0, 0);
    public string Path;
    public string UpPath;
    public string State;
    public int Frame;
    public int Delay;
    Vector2 Distance;
    bool OnLadder;
    Foothold FH;
    public static Pet Instance;

    public static void Create(string ID)
    {
        Wz_Node Entry = Wz.GetNode("Item/Pet/" + ID + ".img");
        Wz.DumpData(Entry, Wz.EquipData, Wz.EquipImageLib);
        foreach (var Iter in Wz.EquipData[Entry.FullPathToFile2()].Nodes)
        {
            foreach (var Iter2 in Wz.EquipData[Iter.FullPathToFile2()].Nodes)
            {
                if (Char.IsNumber(Iter2.Text[0]))
                {
                    if (Iter.Text == "stand0" && Iter2.Text == "0")
                    {
                        Instance = new Pet(EngineFunc.SpriteEngine);
                        Instance.ImageLib = Wz.EquipImageLib;
                        Instance.IntMove = true;
                        Instance.Tag = 1;
                        Instance.State = Iter.Text;
                        Instance.Frame = Iter2.Text.ToInt();
                        Instance.UpPath = Entry.FullPathToFile2();
                        Instance.ImageNode = Wz.EquipData[Iter2.FullPathToFile2()];
                        var StartX = Game.Player.X - 60;
                        if (StartX < Map.Left)
                            StartX = Game.Player.X;
                        var Pos = FootholdTree.Instance.FindBelow(new Vector2(StartX, Game.Player.Y - 3), ref Instance.BelowFH);
                        Instance.MoveType = MoveType.Jump;
                        Instance.X = Pos.X;
                        Instance.Y = Pos.Y;
                        Instance.FH = Instance.BelowFH;
                        Instance.Z = Game.Player.Z;
                        Instance.JumpSpeed = 0.6f;
                        Instance.JumpHeight = 9;
                        Instance.MaxFallSpeed = 8;
                        Instance.MoveDirection = MoveDirection.None;
                        Instance.MoveSpeed = 2.5f;
                    }
                }
            }
        }
    }


    public override void DoMove(float Delta)
    {
        base.DoMove(Delta);
        int X1 = FH.X1;
        int Y1 = FH.Y1;
        int X2 = FH.X2;
        int Y2 = FH.Y2;

        if (Wz.HasDataE(UpPath + "/" + State + "/" + Frame))
        {
            Path = UpPath + "/" + State + "/" + Frame;
            ImageNode = Wz.EquipData[Path];
        }

        if (Wz.HasDataE(UpPath + "/" + State + "/" + Frame + "/delay"))
            Delay = Wz.EquipData[UpPath + "/" + State + "/" + Frame + "/delay"].ToInt();
        else
            Delay = 100;

        FTime += 17;
        if (FTime > Delay)
        {
            Frame += 1;
            if (!Wz.EquipData.ContainsKey(UpPath + "/" + State + "/" + Frame))
                Frame = 0;
            FTime = 0;
        }

        Distance.X = Math.Abs(Game.Player.X - X);
        Distance.Y = Math.Abs(Game.Player.Y - Y);

        if (Distance.X > 70)
        {
            State = "move";
            if (Game.Player.X > X)
            {
                FlipX = true;
                MoveDirection = MoveDirection.Right;
            }
            if (Game.Player.X < X)
            {
                FlipX = false;
                MoveDirection = MoveDirection.Left;
            }
        }
        else
        {
            State = "stand0";
            MoveDirection = MoveDirection.None;
        }

        if (Game.Player.Y < Y)
        {
            switch (Distance.Y)
            {
                case float i when i >= 100 && i <= 150:
                    if (JumpState == JumpState.jsNone)
                    {
                        //  Below := TFootholdTree.This.FindBelow(Point(Round(X), Round(Y - 70)), BelowFH);
                        //  if Y - Below.Y <> 0 then
                        DoJump = true;
                    }
                    break;

                case float i when i >= 151 && i <= 2000:
                    if (Game.Player.JumpState == JumpState.jsNone)
                    {
                        X = Game.Player.X;
                        Y = Game.Player.Y;
                    }
                    break;
            }
        }

        if (Game.Player.Y > Y)
        {
            if (Distance.Y >= 200 && Distance.Y <= 2000)
            {

                Y += 5;
                JumpState = JumpState.jsFalling;
            }
        }

        Vector2 Below;
        if (Game.Player.InLadder)
        {
            LadderRope ladderRope = LadderRope.Find(new Vector2(Game.Player.X, Game.Player.Y), ref OnLadder);
            State = "hang";
            X = Game.Player.X;
            Y = Game.Player.Y + 20;
            Z = 7 * 100000 + 60000;
            if (Y > ladderRope.Y2 - 10)
                JumpState = JumpState.jsFalling;
            if (Y < ladderRope.Y1 + 30)
            {
                Below = FootholdTree.Instance.FindBelow(new Vector2(Game.Player.X, Game.Player.Y - 100), ref BelowFH);
                Y = Below.Y;
                FH = BelowFH;
            }
        }

        if (JumpState == JumpState.jsFalling)
        {
            Below = FootholdTree.Instance.FindBelow(new Vector2(X, Y - VelocityY - 2), ref BelowFH);
            if (Y >= Below.Y - 3)
            {
                Y = Below.Y;
                // MaxFallSpeed :=10;
                JumpState = JumpState.jsNone;
                FH = BelowFH;
                Z = FH.Z * 100000 + 70000;
            };
        }

        int FallEdge;
        int Direction;
        if (MoveDirection == MoveDirection.Left)
        {
            Direction = GetAngle256(X2, Y2, X1, Y1);
            if (!FH.IsWall())
            {
                X += (float)(Sin256(Direction) * MoveSpeed);
                Y -= (float)(Cos256(Direction) * MoveSpeed);
            }
            FallEdge = -999999;
            JumpEdge = -999999;
            if (MoveType == MoveType.Move)
            {
                // no fh
                if (FH.Prev == null)
                    FallEdge = FH.X1;
                // Wall's edge down
                if ((FH.Prev != null) && (FH.Prev.IsWall()))
                    FallEdge = FH.X1;

                if (X < FallEdge)
                {
                    X = FallEdge;
                    FlipX = true;
                    MoveDirection = MoveDirection.Right;
                }
            }

            if (MoveType == MoveType.Jump)
            {
                if (X < Map.Left + 20)
                {
                    X = Map.Left + 20;
                    FlipX = true;
                    MoveDirection = MoveDirection.Right;
                }
                // .--------.
                if (FH.Prev == null)
                    JumpEdge = FH.X1;
                // ┌--- <--
                if ((FH.Prev != null) && (FH.Prev.IsWall()) && (FH.Prev.Y1 > Y))
                    FallEdge = FH.X1;

                if (X < FallEdge)
                {
                    if (Game.Player.Y <= Y)
                        DoJump = true;
                    if (Game.Player.Y > Y && JumpState == JumpState.jsNone)
                        JumpState = JumpState.jsFalling;
                }
                if (X < JumpEdge)
                    DoJump = true;
                // -->  ---┐  <--
                WallFH = FootholdTree.Instance.FindWallR(new Vector2(X + 4, Y - 4));
                if ((WallFH != null) && (FH.Z == WallFH.Z))
                {
                    if (X < WallFH.X1 + 30 && Game.Player.Y <= Y)
                        DoJump = true;
                    if (X <= WallFH.X1)
                    {
                        X = WallFH.X1 + MoveSpeed;
                        if (JumpState == JumpState.jsNone)
                        {
                            FlipX = true;
                            MoveDirection = MoveDirection.Right;
                        }
                    }
                }
            }
            // walk left
            if ((X <= FH.X1) && (FH.PrevID != 0) && (!FH.IsWall()) && (!FH.Prev.IsWall()))
            {
                if (JumpState == JumpState.jsNone)
                {
                    FH = FH.Prev;
                    X = FH.X2;
                    Y = FH.Y2;
                    Z = FH.Z * 100000 + 70000;
                }
            }
        }

        // walk right
        if (MoveDirection == MoveDirection.Right)
        {

            Direction = GetAngle256(X1, Y1, X2, Y2);
            if (!FH.IsWall())
            {
                X += (float)(Sin256(Direction) * MoveSpeed);
                Y -= (float)(Cos256(Direction) * MoveSpeed);
            }

            FallEdge = 999999;
            JumpEdge = 999999;
            if (MoveType == MoveType.Move)
            {
                if (FH.Next == null)
                    FallEdge = FH.X2 + 5;
                // Wall down
                if ((FH.Next != null) && (FH.Next.IsWall()))

                    FallEdge = FH.X2;
                if (X > FallEdge)
                {
                    X = FallEdge;
                    FlipX = false;
                    MoveDirection = MoveDirection.Left;
                }
            }

            if (MoveType == MoveType.Jump)
            {
                if (X > Map.Right - 20)
                {
                    X = Map.Right - 20;
                    FlipX = false;
                    MoveDirection = MoveDirection.Left;
                }
                if (FH.Next == null) // .--------.
                    JumpEdge = FH.X2;
                // -->  ----┐
                if ((FH.Next != null) && (FH.Next.IsWall()) && (FH.Next.Y2 > Y))
                    FallEdge = FH.X2;

                if (X > FallEdge)
                {
                    if (Game.Player.Y <= Y)
                        DoJump = true;
                    if (Game.Player.Y > Y && JumpState == JumpState.jsNone)
                        JumpState = JumpState.jsFalling;
                }
                if (X > JumpEdge)
                    DoJump = true;
                // -->  ┌.....
                WallFH = FootholdTree.Instance.FindWallL(new Vector2(X - 4, Y - 4));
                if ((WallFH != null) && (FH.Z == WallFH.Z))
                {
                    if (X > WallFH.X1 - 30 && Game.Player.Y <= Y)
                        DoJump = true;
                    if (X >= WallFH.X1)
                    {
                        X = WallFH.X2 - MoveSpeed;
                        if (JumpState == JumpState.jsNone)
                        {
                            FlipX = false;
                            MoveDirection = MoveDirection.Left;
                        }
                    }
                }
            }

            // walk right
            if ((X >= FH.X2) && (FH.NextID != 0) && (!FH.IsWall()) && (!FH.Next.IsWall()))
            {
                if (JumpState == JumpState.jsNone)
                {
                    FH = FH.Next;
                    X = FH.X1;
                    Y = FH.Y1;
                    Z = FH.Z * 100000 + 70000;
                }
            }
        }

        //if (MoveDirection ==  MoveDirection.None)
        // X = (X);

        if (ImageNode.GetNode("origin") != null)
            origin = ImageNode.GetNode("origin").ToVector();
        switch (FlipX)
        {
            case true:
                Offset.X = origin.X - ImageWidth;
                break;
            case false:
                Offset.X = -origin.X;
                break;
        }
        Offset.Y = -origin.Y;

    }

    public static void Remove()
    {
        if (Instance != null)
        {
            Instance.Dead();
            Instance = null;
            foreach (var Iter in Wz.EquipImageLib.Keys)
            {
                if (Iter.FullPathToFile2().LeftStr(8) == "Item/Pet")
                {
                    Wz.EquipImageLib.Remove(Iter);
                    // EquipData.Remove(Iter.GetPath);
                }
            }
            EngineFunc.SpriteEngine.Dead();
        }
    }
}

public class PetNameTag : MedalTag
{
    public PetNameTag(Sprite Parent) : base(Parent)
    {
    }
    public static PetNameTag Instance;

    static void ReDraw()
    {
        if (Instance != null)
            Instance.IsReDraw = true;
    }

    public static void Remove()
    {
        if (Instance != null)
        {
            Instance.Dead();
            EngineFunc.SpriteEngine.Dead();
        }
    }

    public override void DoMove(float Delta)
    {
        base.DoMove(Delta);
        if (IsReDraw)
        {
            Engine.Canvas.DrawTarget(ref TargetTexture, 300, 100, () => { RenderTargetFunc(); });
        }
        X = Pet.Instance.X;
        Y = Pet.Instance.Y;
        Z = Pet.Instance.Z;
    }

    public override void DoDraw()
    {
        if (Map.ShowPlayer)
        {
            int WX = (int)(Pet.Instance.X) - (int)(Engine.Camera.X);
            int WY = (int)(Pet.Instance.Y) - (int)(Engine.Camera.Y);
            Engine.Canvas.Draw(TargetTexture, WX - 150, WY - 28, MonoGame.SpriteEngine.BlendMode.NonPremultiplied);
        }
        if (IsReDraw)
            IsReDraw = false;
    }

    public static void Create(string ItemID)
    {
        Instance = new PetNameTag(EngineFunc.SpriteEngine); 
        Instance.IntMove = true;
        Instance.Tag = 1; 
        int TagNum = Wz.GetInt("Item/Pet/" + ItemID + ".img/info/nameTag", 3);
        Instance.Entry = Wz.GetNode("UI/NameTag.img/pet/" + TagNum);
        if (Instance.Entry == null)
            Instance.Entry = Wz.GetNode("UI/NameTag.img/pet/38");
        if (Instance.Entry.HasNode("c/_inlink"))
        {
            string Data = Instance.Entry.GetStr("c/_inlink");
            Data = Data.Replace("/c", "");
            Data = Data.Replace("pet/", "");
            Instance.Entry = Wz.GetNode("UI/NameTag.img/pet/" + Data);
        }
        Wz.DumpData(Instance.Entry, Wz.EquipData, Wz.EquipImageLib);
     
    }


}

public class PetEquip : Pet
{
    public PetEquip(Sprite Parent) : base(Parent)
    {

    }
    public static PetEquip Instance;

    public static void Create(string ID)
    {
        Wz_Node Entry = Wz.GetNode("Character/PetEquip/" + ID + ".img");
        Wz.DumpData(Entry, Wz.EquipData, Wz.EquipImageLib);
        Instance = new PetEquip(EngineFunc.SpriteEngine);
        Instance.ImageLib = Wz.EquipImageLib;
        Instance.IntMove = true;
        Instance.Tag = 1;
        Instance.State = Pet.Instance.State;
        Instance.Frame = Pet.Instance.Frame;
        Instance.UpPath = Entry.FullPathToFile2();
        Instance.ImageNode = Wz.EquipData[Instance.UpPath + "/" + PetForm.PetID + "/" + Instance.State + "/" + Instance.Frame];
        Instance.X = Pet.Instance.X;
        Instance.Y = Pet.Instance.Y;
        Instance.Z = Pet.Instance.Z + 100;
    }


    public override void DoMove(float Delta)
    {
        if (Wz.HasDataE(UpPath + "/" + PetForm.PetID + "/" + State + "/" + Frame))
        {
            Path = UpPath + "/" + PetForm.PetID + "/" + State + "/" + Frame;
            ImageNode = Wz.EquipData[Path];
        }

        if (Wz.HasDataE(UpPath + "/" + PetForm.PetID + "/" + State + "/" + Frame + "/delay"))
            Delay = Wz.EquipData[UpPath + "/" + PetForm.PetID + "/" + State + "/" + Frame + "/delay"].ToInt();
        else
            Delay = 100;


        FTime += 17;
        if (FTime > Delay)
        {
            Frame += 1;
            if (!Wz.EquipData.ContainsKey(UpPath + "/" + PetForm.PetID + "/" + State + "/" + Frame))
                Frame = 0;
            FTime = 0;
        }

        State = Pet.Instance.State;
        Frame = Pet.Instance.Frame;
        X = Pet.Instance.X;
        Y = Pet.Instance.Y;
        Z = Pet.Instance.Z + 100;
        FlipX = Pet.Instance.FlipX;

        if (ImageNode.GetNode("origin") != null)
            origin = ImageNode.GetNode("origin").ToVector();
        switch (FlipX)
        {
            case true:
                Offset.X = origin.X - ImageWidth;
                break;
            case false:
                Offset.X = -origin.X;
                break;
        }
        Offset.Y = -origin.Y;
    }

    public static void Remove()
    {
        if (Instance != null)
        {
            Instance.Dead();
            Instance = null;
            foreach (var Iter in Wz.EquipImageLib.Keys)
            {
                if (Iter.FullPathToFile2().LeftStr(18) == "Character/PetEquip")
                {
                    Wz.EquipImageLib.Remove(Iter);
                    // EquipData.Remove(Iter.GetPath);
                }
            }
            EngineFunc.SpriteEngine.Dead();
        }
    }
}
```

`MapleNecrocer/Client/Reactor.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WzComparerR2.WzLib;
using Microsoft.Xna.Framework;
using WzComparerR2.Animation;

namespace MapleNecrocer;

public class Reactor : SpriteEx
{
    public Reactor(Sprite Parent) : base(Parent)
    {
        IntMove = true;
    }

    string ID;
    Wz_Node Entry;
    Foothold BelowFH;
    Foothold FH;
    int Frame;
    int Delay;
    int FTime;
    Wz_Vector origin = new(0, 0);
    int OriginType;
    public static void Create(string ID)
    {
        var LEntry = Wz.GetNode("Reactor/" + ID + ".img");
        if (!LEntry.HasNode("0"))
            return;
        if (!Wz.EquipData.ContainsKey(LEntry.FullPathToFile2()))
            Wz.DumpData(LEntry, Wz.EquipData, Wz.EquipImageLib);
        var Reactor = new Reactor(EngineFunc.SpriteEngine);
        Reactor.ImageLib = Wz.EquipImageLib;
        Reactor.Entry = LEntry;
        Reactor.ImageNode = Wz.EquipData[Reactor.Entry.FullPathToFile2() + "/0/0"];
        Vector2 Pos = FootholdTree.Instance.FindBelow(new Vector2(Game.Player.X, Game.Player.Y - 50), ref Reactor.BelowFH);
        Reactor.X = Pos.X;
        Reactor.Y = Pos.Y;
        Reactor.Z = Reactor.BelowFH.Z * 100000 + 6000;
        Reactor.Width = Reactor.ImageWidth;
        Reactor.Height = Reactor.ImageHeight;
        if (Reactor.Entry.GetNode("0/1") == null)
            Reactor.OriginType = 0;
        else
            Reactor.OriginType = 1;

    }

    public override void DoMove(float Delta)
    {
        base.DoMove(Delta);
        ImageNode = Wz.EquipData[Entry.FullPathToFile2() + "/0/" + Frame];
        Delay = ImageNode.GetInt("delay", 100);
        FTime += +17;
        if (FTime > Delay)
        {
            Frame += 1;
            if (!Wz.HasDataE(Entry.FullPathToFile2() + "/0/" + Frame))
                Frame = 0;
            FTime = 0;
        }
        if (ImageNode.GetVector("origin") != null)
            origin = ImageNode.GetVector("origin");
        Offset.X = -origin.X;

        if (OriginType == 0)
            Offset.Y = -Height;
        else
            Offset.Y = -origin.Y;
    }

    public static void Remove()
    {
        foreach (var Iter in EngineFunc.SpriteEngine.SpriteList)
        {
            if (Iter is Reactor)
            {
                Iter.Dead();
                var s = Iter;
                s = null;
            }
        }
        EngineFunc.SpriteEngine.Dead();
    }
}

```

`MapleNecrocer/Client/Skill.cs`:

```cs
using Input = Microsoft.Xna.Framework.Input.Keys;
using WzComparerR2.WzLib;
using Microsoft.Xna.Framework;
using System.Numerics;
using WzComparerR2.CharaSim;
using Microsoft.VisualBasic.Devices;
using Keyboard = SpriteEngine.Keyboard;
using WzComparerR2.Animation;
using Vector2 = Microsoft.Xna.Framework.Vector2;

namespace MapleNecrocer;

public class Skill : Sprite
{
    public Skill(Sprite Parent) : base(Parent)
    {
       
    }
    public static Dictionary<Input, string> HotKeyList = new();
    public static bool PlayEnded;
    public static string ID;
    public static bool Attacking;
    public static bool Start;
    public static Dictionary<string, string> AllIDs = new();
    public static List<string> LoadedList = new();
    //  if(Keyboard.KeyDown((Input) Enum.Parse(typeof(Input), "X", true) )  )
    public static bool MultiStrike;
    public static int DamageWaitTime;
    public static int TotalTime;
    public static Wz_Node Entry;
    public static string GetJobImg(string ID)
    {
        if (ID.LeftStr(3) == "800" && ID.Length == 8)
            return (ID.ToInt() / 100).ToString();
        else
            return (ID.ToInt() / 10000).ToString();
    }
    public static void Load(string ID)
    {
        Wz_Node Entry = null;
        if (Wz.HasNode("Skill/" + GetJobImg(ID) + ".img"))
            Entry = Wz.GetNode("Skill/" + GetJobImg(ID) + ".img/skill/" + ID);
        Wz.DumpData(Entry, Wz.EquipData, Wz.EquipImageLib);
        foreach (var Iter in Entry.Nodes)
        {
            if (Iter.Text == "action")
                Equip.DataS.AddOrReplace(ID + "/action", Iter.GetStr("0","alert"));
            if (Iter.Text == "tile")
                Equip.Data.AddOrReplace(ID + "/tileCount", Iter.Nodes.Count - 1);
        }
    }

    static int GetDamageWaitTime(string ID)
    {
        switch (ID.ToInt())
        {
            case 1311012:
            case 4341052:
            case 5101004:
            case 65121008:
            case 400040006:
                return 5;
                break;
            case 61111101:
            case 142121031:
            case 400041024:
            case 5221026:
            case 101120202:
                return 10;
                break;
            case 1321012:
            case 2211010:
            case 2301005:
            case 15111022:
            case 25121005:
            case 101100100:
            case 101110202:
            case 101110203:
            case 155111211:
            case 400051042:
                return 15;
                break;
            case 3121015:
            case 11101008:
            case 31221002:
            case 41121017:
                return 20;
                break;
            case 15121002:
            case 1121008:
            case 1001005:
            case 1121015:
            case 2211002:
            case 5121017:
            case 61121104:
            case 61121105:
            case 65111100:
            case 41121018:
            case 65121100:
                return 25;
                break;
            case 5321000:
            case 25121007:
            case 400041021:
                return 30;
                break;
            case 2221007:
            case 65121002:
                return 35;

            case 5121016:
            case 5121052:
            case 15121052:
            case 101120102:
            case 36121011:
            case 400021002:
                return 40;
                break;
            case 5221052:
            case 27111101:
            case 32121004:
                return 45;

            case 27111303:
            case 27121202:
                return 50;
                break;
            case 31221052:
                return 55;

            case 2321008:
            case 2121007:
            case 41121052:
            case 400001014:
                return 70;

            case 61121052:
                return 85;

            case 5121013:
                return 95;

            case 4341011:
                return 120;

            case 36121052:
                return 160;
            default: return 15;
        }
    }

    public static void Create(string ID)
    {  
        string[] Effects = {"effect", "effect0", "effect1", "effect2","effect3",
                            "screen", "screen0", "ball", "keydown", "keydown0", "keydowned"};
        Skill.ID = ID;
        Skill.PlayEnded = false;
        Sound.Play("Sound/Skill.img/"+ ID + "/Use");
        Wz_Node Entry = null;
        if (Wz.HasNode("Skill/" + GetJobImg(ID) + ".img"))
        {
            Entry = Wz.GetNode("Skill/" + GetJobImg(ID) + ".img/skill/" + ID);

        }
        Skill.Entry = Entry;

        
        switch (ID)
        {
            case "1121008":
            case "1001005":
            case "1311012":
                Skill.MultiStrike = false;
                break;
            default:
                Skill.MultiStrike = true;
                break;
        }
        int Count = 0;
        DamageWaitTime = GetDamageWaitTime(ID);
        
        //連打6次
        var SpriteList = EngineFunc.SpriteEngine.SpriteList;
        if (Skill.MultiStrike)
        {
            Count = 1;
            TotalTime = DamageWaitTime + 6 * 7;
             

            for (int i = 0; i < SpriteList.Count; i++)
            {

                if (SpriteList[i] is Mob)
                {
                    for (int j = 1; j <= 6; j++)
                    {
                        ((Mob)SpriteList[i]).MobCollision[j] = new MobCollision(EngineFunc.SpriteEngine);
                        ((Mob)SpriteList[i]).MobCollision[j].Owner = (Mob)SpriteList[i];
                        ((Mob)SpriteList[i]).MobCollision[j].StartTime = DamageWaitTime + j * 7;
                        ((Mob)SpriteList[i]).MobCollision[j].Index = j - 1;
                        ((Mob)SpriteList[i]).MobCollision[j].CanCollision = true;
                    }
                }
            }
        }
        else
        {
            Count = 6;
        }
        
        //順序打
        for (int i = 1; i <= Count; i++)
        {
            var SkillCollision = new SkillCollision(EngineFunc.SpriteEngine);
            SkillCollision.CanCollision = true;
            //ID := ID;
            SkillCollision.IDEntry = Entry;
            SkillCollision.StartTime = DamageWaitTime + i * 6;
        }
      
        
        for (int i = 0; i < EngineFunc.SpriteEngine.SpriteList.Count; i++)
        {
            if (EngineFunc.SpriteEngine.SpriteList[i] is Mob)
                ((Mob)EngineFunc.SpriteEngine.SpriteList[i]).CanCollision = true;
        }
        
        for (int i = 0; i <= 10; i++)
        {

          //    if (!Entry.HasNode("Effect/0"))
            //  return;

            if (Entry.HasNode(Effects[i]))
            {
                var SkillSprite = new SkillSprite(EngineFunc.SpriteEngine);
                SkillSprite.ParentPath = Entry.GetNode(Effects[i]).FullPathToFile2();
                if (Entry.GetNode(Effects[i] + "/0/0") != null)
                    SkillSprite.ParentPath = Entry.GetNode(Effects[i] + "/0").FullPathToFile2();
                SkillSprite.ImageLib = Wz.EquipImageLib;
                SkillSprite.ImageNode = Wz.EquipData[SkillSprite.ParentPath + "/0"];
                SkillSprite.X = Game.Player.X;
                SkillSprite.Y = Game.Player.Y;
                if (Effects[i] == "ball")
                {
                    if (Entry.HasNode("common/bulletSpeed"))
                        SkillSprite.BallSpeed = 1000 / Entry.GetInt("common/bulletSpeed");

                    SkillSprite.Y = Game.Player.Y - 27;
                    if (Game.Player.FlipX)
                        SkillSprite.BallSpeed = SkillSprite.BallSpeed;
                    else
                        SkillSprite.BallSpeed = -SkillSprite.BallSpeed;
                    SkillSprite.AnimRepeat = true;
                }
                SkillSprite.Width = 800;
                SkillSprite.Height = 800;
                SkillSprite.Visible = false;
                SkillSprite.FID = ID;
                SkillSprite.EffectName = Effects[i];
                if (Entry.GetInt(Effects[i] + "/z", -999) == -999)
                    SkillSprite.Z = 150 + Game.Player.Z;
                else
                    SkillSprite.Z = Game.Player.Z + Entry.GetInt(Effects[i] + "/z", 0);
            }
        }

        int WX = (int)EngineFunc.SpriteEngine.Camera.X;
        int WY = (int)EngineFunc.SpriteEngine.Camera.Y;

        if (Entry.HasNode("tile")) // ' + '/0/0') then
        {
            if (!Entry.HasNode("tile/0"))
                return;
            if (!Entry.HasNode("tile/0/0"))
                return;
            for (int i = 0; i <= 6; i++)
            {
                int MoveY = 20;
                if ((i % 2) == 0)
                    MoveY = 300;
                Foothold BelowFH = null;
                Vector2 Below = FootholdTree.Instance.FindBelow(new Vector2(240 + WX + i * 120, WY + MoveY), ref BelowFH);
                if (BelowFH != null)
                {
                    var SkillSprite = new SkillSprite(EngineFunc.SpriteEngine);
                    SkillSprite.FID = ID;
                    SkillSprite.MoveWithPlayer = false;
                    Random Random = new Random();
                    int Rnd = Random.Next(0, Equip.Data[ID + "/tileCount"]);
                    SkillSprite.ImageLib = Wz.EquipImageLib;
                    SkillSprite.ParentPath = Entry.GetNode("tile/" + Rnd.ToString()).FullPathToFile2();
                    SkillSprite.ImageNode = Wz.EquipData[SkillSprite.ParentPath + "/0"];
                    SkillSprite.Width = 800;
                    SkillSprite.Height = 800;
                    SkillSprite.X = Below.X;
                    SkillSprite.Y = Below.Y;
                    SkillSprite.Z = Game.Player.Z;
                    SkillSprite.Visible = false;
                    SkillSprite.EffectName = "tile";
                }
            }
        }
    }

    public override void DoMove(float Delta)
    {
        if (Skill.PlayEnded && !Game.Player.InLadder)
        {

            foreach (var K in Skill.HotKeyList.Keys)
            {
                if (Keyboard.KeyDown(K))
                {
                    Skill.Attacking = true;
                    Skill.Create(Skill.HotKeyList[K]);
                }
               
            }

        }

    }

  

}

public class SkillSprite : SpriteEx
{
    public SkillSprite(Sprite Parent) : base(Parent)
    {
    }
    int FTime;
    int Frame;
    Wz_Vector origin = new(0, 0);
    public string FID;
    public float BallSpeed;
    public string EffectName;
    public string ParentPath;
    int Counter;
    public bool AnimRepeat, AnimEnd;
    int Left, Top, Right, Bottom;
    public bool MoveWithPlayer;

    public override void DoMove(float Delta)
    {
        base.DoMove(Delta);
        Visible = true;
        if ((FTime == 0) && (Frame == 0) && (!Skill.PlayEnded))
            Skill.Start = true;
        ImageNode = Wz.EquipData[ParentPath + "/" + Frame];
        int AnimDelay = ImageNode.GetInt("delay", 100);
        FlipX = Game.Player.FlipX;
        if ((MoveWithPlayer) && (EffectName != "ball"))
        {
            X = Game.Player.X;
            Y = Game.Player.Y;
        }
        FTime += 17;
        if (FTime > AnimDelay)
        {
            FTime = 0;
            Frame += 1;
            AnimEnd = false;
            if (!Wz.EquipData.ContainsKey(ParentPath + "/" + Frame))
            {
                // if Frame> FrameCount then
                // Frame := 0;
                if (AnimRepeat)
                {
                    Frame = 0;
                }
                else
                {
                    Frame -= 1;
                    AnimEnd = true;
                }
            }
        }

        if (ImageNode.GetNode("origin") != null)
            origin = ImageNode.GetNode("origin").ToVector();
        switch (FlipX)
        {
            case true:
                Offset.X = origin.X - ImageWidth;
                break;
            case false:
                Offset.X = -origin.X;
                break;
        }
        Offset.Y = -origin.Y;

        if (EffectName != "ball")
        {
            Skill.PlayEnded = AnimEnd;
            if (AnimEnd)
                Dead();
        }

        if (EffectName == "ball")
        {
            Counter += 1;
            if (Counter > 15)
                X += BallSpeed;
            if (Counter > 180)
                Dead();
        }
    }
}

public class SkillCollision : SpriteEx
{
    public SkillCollision(Sprite Parent) : base(Parent)
    {
        CollideMode = CollideMode.Rect;
        CanCollision = true;    
    }
    public int StartTime;
    int Counter;
    int Num;
    public Wz_Node IDEntry;
    Wz_Vector LT, RB;
    public override void DoMove(float Delta)
    {
        base.DoMove(Delta);
        FlipX = Game.Player.FlipX;
        if (Wz.EquipData.ContainsKey(IDEntry.FullPathToFile2() + "/common/lt"))
        {
            
            LT = Wz.EquipData[IDEntry.FullPathToFile2() + "/common/lt"].ToVector();
            RB = Wz.EquipData[IDEntry.FullPathToFile2() + "/common/rb"].ToVector();
            switch (Game.Player.FlipX)
            {
                case true:
                    Right = (int)Game.Player.X - LT.X + 18;
                    Left = (int)Game.Player.X - RB.X;
                    break;
                case false:
                    Left = (int)Game.Player.X + LT.X;
                    Right = (int)Game.Player.X + RB.X;
                    break;
            }
            Top = (int)Game.Player.Y + LT.Y;
            Bottom = (int)Game.Player.Y + RB.Y;
        }
        CollideRect  = SpriteUtils.Rect(Left, Top, Right, Bottom);
        Counter += 1;
        if (Skill.MultiStrike)
        {
            if (Counter > Skill.TotalTime + 1)
                Dead();
        }
        else
        {
            if (Counter > StartTime)
            {
                Collision();
                Dead();
            }
        }

    }

    public override void OnCollision(Sprite sprite)
    {
        if (Skill.MultiStrike)
         return;

        if (sprite is Mob)
        {
            var Mob = (Mob)sprite;
            Mob.CanCollision = false;
            if (Mob.HP > 0)
            {  
                Mob.Hit = true;
                Random Random = new Random();
                Game.Damage = 50000 + Random.Next(700000);
                Mob.HP -= Game.Damage;
               
                if (Wz.GetNode("Sound/Mob.img/" + Mob.ID + "/Damage") != null)
                    Sound.Play("Sound/Mob.img/" + Mob.ID + "/Damage");
                else if (Wz.GetNode("Sound/Mob.img/" + Mob.ID + "/Hit1") != null)
                    Sound.Play("Sound/Mob.img/" + Mob.ID + "/Hit1");
                if (Wz.Data.ContainsKey("Mob/" + Mob.ID + ".img/hit1"))
                {

                    Mob.GetHit1 = true;
                }
            }
            if ((Mob.HP <= 0) && (!Mob.Die))
            {
                //PlaySounds("Mob", Mob.ID + "/Die");
                Mob.Die = true;
            }
            CanCollision = false;
            Dead();
        }
    }

    public override void DoDraw()
    {
        if (ImageNode == null) return;
    }
}


public class SkillHitEffect : SpriteEx
{
    public SkillHitEffect(Sprite Parent) : base(Parent)
    {
    }
    Mob Owner;
    Wz_Node Entry;
    int FTime;
    int Frame;
    string EntryPath;
    int AnimDelay;
    bool AnimRepeat, AnimEnd;
    bool HitL1;
    string HitPath;
    public static void Create(Mob Owner)
    {
        if (Wz.HasDataE(Skill.Entry.FullPathToFile2() + "/hit/0"))
        {
            var SkillHieEffect = new SkillHitEffect(EngineFunc.SpriteEngine);
            SkillHieEffect.ImageLib = Wz.EquipImageLib;
            SkillHieEffect.EntryPath = Skill.Entry.FullPathToFile2();
            if (Wz.EquipData[Skill.Entry.FullPathToFile2() + "/hit/0"].Value is Wz_Png)
                SkillHieEffect.HitPath = "/hit/";
            else
                SkillHieEffect.HitPath = "/hit/0/";
            SkillHieEffect.ImageNode = Wz.EquipData[SkillHieEffect.EntryPath + SkillHieEffect.HitPath + "0"];
            SkillHieEffect.Owner = Owner;
        }
    }

    public override void DoMove(float Delta)
    {
        X = Owner.X - 70;
        Y = Owner.Y - 100;
        Z = Owner.Z;
        ImageNode = Wz.EquipData[EntryPath + HitPath + Frame];
        AnimDelay = ImageNode.GetInt("delay", 100);
        FTime += 17;
        if (FTime > AnimDelay)
        {
            FTime = 0;
            Frame += 1;
            AnimEnd = false;
            if (!Wz.EquipData.ContainsKey(EntryPath + HitPath + Frame))
            {
                if (AnimRepeat)
                { 
                    Frame = 0;
                }
                else
                {
                    Frame -= 1;
                    AnimEnd = true;
                }
            }
        }

        if (AnimEnd)
          Dead();
    }
}
```

`MapleNecrocer/Client/Sound.cs`:

```cs
using DevComponents.DotNetBar;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WzComparerR2.WzLib;
using WzComparerR2;
using ManagedBass;
using Microsoft.Xna.Framework.Audio;
using System.Windows.Forms;
using WzComparerR2.Rendering;

namespace MapleNecrocer;

public class Sound
{
    public static Dictionary<string, BassSoundPlayer> SoundDict = new Dictionary<string, BassSoundPlayer>();
    public static List<BassSoundPlayer> PlayendList=new();
    public static void Init()
    {
        Bass.Init(-1, 44100, DeviceInitFlags.Default, IntPtr.Zero);
    }
    public static void Load(string Name)
    {
        Wz_Sound Sound = null;
        if (Wz.GetNode("Sound/" + Name) != null)
            Sound = (Wz_Sound)Wz.GetNode("Sound/" + Name).Value;
        byte[] Data = Sound.ExtractSound();

        if (Data == null || Data.Length <= 0)
        {
            return;
        }
        BassSoundPlayer SoundPlayer = new BassSoundPlayer();
        SoundPlayer.AutoPlay = false;
        SoundPlayer.PreLoad(Data);
        SoundDict.Add(Name, SoundPlayer);
    }
    public static void Play(string Path)
    {
        Wz_Node Child;
        Wz_Node WzNode = Wz.GetNode(Path);
        if (WzNode.Value is Wz_Uol)
        {
            var Entry = WzNode.ParentNode;
            Child = Entry.Get(WzNode.ToStr());
            if (Child == null)
                return;
            if (Child.Value is Wz_Uol)
                Child = Child.ParentNode.Get(Child.ToStr());
        }
        else
        { 
            Child = WzNode;
        }

        if (Child.Value is Wz_Sound)
        {
            byte[] Data = ((Wz_Sound)Child.Value).ExtractSound();
            BassSoundPlayer SoundPlayer = new BassSoundPlayer();
            SoundPlayer.AutoPlay = false;
            SoundPlayer.PreLoad(Data);
            SoundPlayer.Resume();
            PlayendList.Add(SoundPlayer);
        }
    }

    public static void DumpSounds(Wz_Node WzNode)
    {
        Wz_Node Child;
        if (WzNode.Value is Wz_Uol)
        {
            var Entry = WzNode.ParentNode;
            Child = Entry.Get(WzNode.ToStr());
            if (Child == null)
                return;
            if (Child.Value is Wz_Uol)
                Child = Child.ParentNode.Get(Child.ToStr());
            //  if (Child == null)
            //  return;
        }
        else
            Child = WzNode;

        if (Child.Value is Wz_Sound)
        {
            if (!SoundDict.ContainsKey(WzNode.FullPathToFile2()))
            {
                byte[] Data = ((Wz_Sound)Child.Value).ExtractSound();
                BassSoundPlayer SoundPlayer = new BassSoundPlayer();
                SoundPlayer.AutoPlay = false;
                SoundPlayer.PreLoad(Data);
                SoundDict.AddOrReplace(WzNode.FullPathToFile2(), SoundPlayer);
            }
        }
        foreach (var E in WzNode.Nodes)
            DumpSounds(E);
    }

    public static void Play2(string Name)
    {
         
        SoundDict[Name].Play();

    }

}

public class Music
{
    private static BassSoundPlayer MusicPlayer = new BassSoundPlayer();
    public static void Play(string Path)
    {
        Wz_Node Child;
        Wz_Node WzNode = Wz.GetNode(Path);
        if (WzNode.Value is Wz_Uol)
        {
            var Entry = WzNode.ParentNode;
            Child = Entry.Get(WzNode.ToStr());
            if (Child == null)
                return;
            if (Child.Value is Wz_Uol)
                Child = Child.ParentNode.Get(Child.ToStr());
        }
        else
        {
            Child = WzNode;
        }

        if (Child.Value is Wz_Sound)
        {
            byte[] Data = ((Wz_Sound)Child.Value).ExtractSound();
            MusicPlayer.PreLoad(Data);
            MusicPlayer.Loop=true;
           // MusicPlayer.Resume();
        }
    }

    public static void Pause()
    {
        MusicPlayer.Pause();
    }

    public static void Resume()
    {
        MusicPlayer.Resume();
    }

}


```

`MapleNecrocer/Client/SpriteEngine/GameCanvas.cs`:

```cs
namespace MonoGame.SpriteEngine;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework;
using WzComparerR2.Rendering;
using Microsoft.Xna.Framework.Graphics.PackedVector;
using System.Windows.Forms;
using MapleNecrocer;
using Spine;

public enum BlendMode
{
    Normal,
    NonPremultiplied2,
    LightMap,
    Multiply,
    AddtiveColor,
    Lighten,
    Multiply2x,
    LinearDodge,
    LinearBurn,
    Difference,
    Subtractive,
    NonPremultiplied,
    Opaque
}
public class GameCanvas
{
    public GameCanvas(GraphicsDevice graphicGDevice)
    {
        blendState[0] = new BlendState
        {
            ColorSourceBlend = Blend.One,
            ColorDestinationBlend = Blend.InverseSourceAlpha,
            ColorBlendFunction = BlendFunction.Add,
            AlphaSourceBlend = Blend.One,
            AlphaDestinationBlend = Blend.InverseSourceAlpha,
            AlphaBlendFunction = BlendFunction.Add
        };
        //Light Map 
        blendState[1] = new BlendState
        {
            AlphaBlendFunction = BlendFunction.ReverseSubtract,
            AlphaSourceBlend = Blend.SourceAlpha,
            AlphaDestinationBlend = Blend.Zero,
            //deal with color
            ColorBlendFunction = BlendFunction.Add,
            ColorSourceBlend = Blend.DestinationColor,
            ColorDestinationBlend = Blend.Zero
        };
        // multiply 
        blendState[2] = new BlendState
        {
            ColorBlendFunction = BlendFunction.Add,
            ColorSourceBlend = Blend.DestinationColor,
            ColorDestinationBlend = Blend.Zero
        };

        //addtiveColor
        blendState[3] = new BlendState
        {
            ColorBlendFunction = BlendFunction.Add,
            ColorSourceBlend = Blend.One,
            ColorDestinationBlend = Blend.One,
            AlphaSourceBlend = Blend.One,
            AlphaDestinationBlend = Blend.Zero,
            AlphaBlendFunction = BlendFunction.Add
        };
        //lighten
        blendState[4] = new BlendState
        {
            ColorSourceBlend = Blend.One,
            ColorDestinationBlend = Blend.One,
            ColorBlendFunction = BlendFunction.Max,
            AlphaSourceBlend = Blend.One,
            AlphaDestinationBlend = Blend.One,
            AlphaBlendFunction = BlendFunction.Max
        };

        //Multiply2x
        blendState[5] = new BlendState
        {
            ColorSourceBlend = Blend.DestinationColor,
            ColorDestinationBlend = Blend.SourceColor,
            ColorBlendFunction = BlendFunction.Add
        };

        //LinearDodge
        blendState[6] = new BlendState
        {
            ColorSourceBlend = Blend.One,
            ColorDestinationBlend = Blend.One,
            ColorBlendFunction = BlendFunction.Add
        };
        //LinearBurn
        blendState[7] = new BlendState
        {
            ColorSourceBlend = Blend.One,
            ColorDestinationBlend = Blend.One,
            ColorBlendFunction = BlendFunction.ReverseSubtract
        };
        //Difference
        blendState[8] = new BlendState
        {
            ColorSourceBlend = Blend.InverseDestinationColor,
            ColorDestinationBlend = Blend.InverseSourceColor,
            ColorBlendFunction = BlendFunction.Add
        };
        //Subtractive
        blendState[9] = new BlendState
        {
            ColorSourceBlend = Blend.SourceAlpha,
            ColorDestinationBlend = Blend.One,
            ColorBlendFunction = BlendFunction.ReverseSubtract,
            AlphaSourceBlend = Blend.SourceAlpha,
            AlphaDestinationBlend = Blend.One,
            AlphaBlendFunction = BlendFunction.ReverseSubtract
        };

        //
        blendState[10] = new BlendState
        {
            ColorSourceBlend = Blend.SourceAlpha,
            ColorDestinationBlend = Blend.InverseSourceAlpha,
            AlphaSourceBlend = Blend.One,
            AlphaDestinationBlend = Blend.InverseSourceAlpha,
        };

        this.GraphicsDevice = graphicGDevice;
        SpriteBatch = new SpriteBatchEx(this.GraphicsDevice);
        D2DRenderer = new D2DRenderer(this.GraphicsDevice);

    }
    public GraphicsDevice GraphicsDevice;
    private BlendState[] blendState = new BlendState[15];
    public SpriteBatchEx SpriteBatch;
    public D2DRenderer D2DRenderer;

    public void Draw(Texture2D Texture, float X, float Y, BlendMode BlendMode = BlendMode.Normal)
    {
        DrawEx(Texture, X, Y, 0, 0, 1, 1, 0, false, false, 255, 255, 255, 255, false, BlendMode);
    }
    public void Draw(Texture2D Texture, float X, float Y, bool FlipX, bool FlipY, BlendMode BlendMode = BlendMode.Normal)
    {
        DrawEx(Texture, X, Y, 0, 0, 1, 1, 0, FlipX, FlipY, 255, 255, 255, 255, false, BlendMode);
    }
    public void DrawColor(Texture2D Texture, float X, float Y, byte Red, byte Green, byte Blue, byte Alpha = 255, BlendMode BlendMode = BlendMode.Normal)
    {
        DrawEx(Texture, X, Y, 0, 0, 1, 1, 0, false, false, Red, Green, Blue, Alpha, false, BlendMode);
    }
    public void DrawScale(Texture2D Texture, float X, float Y, float ScaleX, float ScaleY, BlendMode BlendMode = BlendMode.Normal)
    {
        DrawEx(Texture, X, Y, 0, 0, ScaleX, ScaleY, 0, false, false, 255, 255, 255, 255, false, BlendMode);
    }


    private void SetBlendMode(BlendMode BlendMode)
    {
        if (BlendMode == BlendMode.Normal)
        {
            //  SpriteBatch.Begin(SpriteSortMode.Deferred, BlendState.NonPremultiplied);
            SpriteBatch.Begin(SpriteSortMode.Deferred, blendState[10]);
        }
        else
        {
            switch (BlendMode)
            {
                case BlendMode.NonPremultiplied2:
                    SpriteBatch.Begin(SpriteSortMode.Deferred, blendState[0]);
                    break;
                case BlendMode.LightMap:
                    SpriteBatch.Begin(SpriteSortMode.Deferred, blendState[1]);
                    break;
                case BlendMode.Multiply:
                    SpriteBatch.Begin(SpriteSortMode.Deferred, blendState[2]);
                    break;
                case BlendMode.AddtiveColor:
                    //  SpriteBatch.Begin(SpriteSortMode.Deferred, blendState[3]);
                    SpriteBatch.Begin(SpriteSortMode.Deferred, BlendState.Additive);

                    break;
                case BlendMode.Lighten:
                    SpriteBatch.Begin(SpriteSortMode.Deferred, blendState[4]);
                    break;
                case BlendMode.Multiply2x:
                    SpriteBatch.Begin(SpriteSortMode.Deferred, blendState[5]);
                    break;
                case BlendMode.LinearDodge:
                    SpriteBatch.Begin(SpriteSortMode.Deferred, blendState[6]);
                    break;
                case BlendMode.LinearBurn:
                    SpriteBatch.Begin(SpriteSortMode.Deferred, blendState[7]);
                    break;
                case BlendMode.Difference:
                    SpriteBatch.Begin(SpriteSortMode.Deferred, blendState[8]);
                    break;

                case BlendMode.Subtractive:
                    SpriteBatch.Begin(SpriteSortMode.Deferred, blendState[9]);
                    break;
                case BlendMode.NonPremultiplied:
                    SpriteBatch.Begin(SpriteSortMode.Deferred, blendState[10]);
                    break;
                case BlendMode.Opaque:
                    SpriteBatch.Begin(SpriteSortMode.Deferred, BlendState.Opaque);
                    break;
            }
        }

    }
    private SpriteEffects SetFlip(bool FlipX, bool FlipY)
    {
        SpriteEffects Flip;
        Flip = SpriteEffects.None;
        if (FlipX)
            Flip = SpriteEffects.FlipHorizontally;
        if (FlipY)
            Flip = SpriteEffects.FlipVertically;
        if (FlipX && FlipY)
            Flip = SpriteEffects.FlipHorizontally | SpriteEffects.FlipVertically;
        return Flip;

    }
    public void DrawPattern(Texture2D Texture, float X, float Y, int PatternIndex, int PatternWidth, int PatternHeight,
      int OriginX, int OriginY, float ScaleX, float ScaleY, float Rotation, bool FlipX, bool FlipY,
      byte Red, byte Green, byte Blue, byte Alpha, bool DoCenter, BlendMode BlendMode = BlendMode.Normal)
    {
        int TexWidth = Texture.Width;
        int TexHeight = Texture.Height;

        int ColCount = TexWidth / PatternWidth;
        int RowCount = TexHeight / PatternHeight;
        int FPatternIndex = PatternIndex;
        if (FPatternIndex < 0)
            FPatternIndex = 0;
        if (FPatternIndex >= RowCount * ColCount)
            FPatternIndex = RowCount * ColCount - 1;
        int X1 = (FPatternIndex % ColCount) * PatternWidth;
        int Y1 = (FPatternIndex / ColCount) * PatternHeight;
        SpriteEffects Flip = SetFlip(FlipX, FlipY);
        if (DoCenter)
        {
            OriginX = PatternWidth / 2;
            OriginY = PatternHeight / 2;
        }
        SetBlendMode(BlendMode);

        SpriteBatch.Draw(Texture,
                        new Vector2(X, Y),
                        new Rectangle(X1, Y1, PatternWidth, PatternHeight),
                        new Microsoft.Xna.Framework.Color(Red, Green, Blue, Alpha),
                        0,
                        new Vector2(OriginX, OriginY),
                        new Vector2(ScaleX, ScaleY),
                        Flip,
                        1);

        SpriteBatch.End();
    }

    public void DrawCropArea(Texture2D Texture, float X, float Y, Rectangle CropArea, int OriginX, int OriginY,
                float ScaleX, float ScaleY, float Rotation, bool FlipX, bool FlipY, byte Red, byte Green, byte Blue, byte Alpha,
                bool DoCenter, BlendMode BlendMode = BlendMode.Normal)
    {
        SpriteEffects Flip = SetFlip(FlipX, FlipY);
        if (DoCenter)
        {
            OriginX = CropArea.Width / 2;
            OriginY = CropArea.Height / 2;
        }
        SetBlendMode(BlendMode);
        SpriteBatch.Draw(Texture,
                         new Vector2(X, Y),
                         CropArea,
                         new Microsoft.Xna.Framework.Color(Red, Green, Blue, Alpha),
                         Rotation,
                         new Vector2(OriginX, OriginY),
                         new Vector2(ScaleX, ScaleY),
                         Flip,
                         0);

        SpriteBatch.End();
    }
    public void DrawCropArea(Texture2D Texture, float X, float Y, Rectangle CropArea)
    {
        DrawCropArea(Texture, X, Y, CropArea, 0, 0, 1, 1, 0, false, false, 255, 255, 255, 255, false);
    }

    public void DrawEx(Texture2D Texture, float X, float Y, int OriginX, int OriginY, float ScaleX, float ScaleY, float Rotation,
        bool FlipX, bool FlipY, byte Red, byte Green, byte Blue, byte Alpha, bool DoCenter, BlendMode BlendMode = BlendMode.Normal)
    {

        SetBlendMode(BlendMode);
        SpriteEffects Flip = SetFlip(FlipX, FlipY);
        if (DoCenter)
        {
            OriginX = Texture.Width / 2;
            OriginY = Texture.Height / 2;
        }

        SpriteBatch.Draw(Texture,
                      new Vector2(X, Y),
                      null,
                      new Microsoft.Xna.Framework.Color(Red, Green, Blue, Alpha),
                      Rotation,
                      new Vector2(OriginX, OriginY),
                      new Vector2(ScaleX, ScaleY),
                      Flip,
                      0);

        SpriteBatch.End();
    }

    public void DrawRotate(Texture2D Texture, float X, float Y, float Rotation, BlendMode BlendMode = BlendMode.Normal)
    {
        DrawEx(Texture, X, Y, 0, 0, 1, 1, Rotation, false, false, 255, 255, 255, 255, true, BlendMode);
    }

    public void DrawStretch(Texture2D Texture,  int DestWidth, int DestHeight, int SrcWidth,int SrcHeight,BlendMode BlendMode = BlendMode.Normal)
    {
        SetBlendMode(BlendMode);
        SpriteBatch.Draw(Texture,
                      new Rectangle(0, 0, DestWidth, DestHeight),
                      new Rectangle(0, 0, SrcWidth, SrcHeight),
                      new Microsoft.Xna.Framework.Color(255, 255, 255, 255)
                      );
        SpriteBatch.End();
    }
    public void DrawStringEx(string KeyName, string Text, float X, float Y, Color Color)
    {
        SpriteBatch.Begin();
        SpriteBatch.DrawStringEx(EngineFunc.Fonts[KeyName], Text, new Vector2(X, Y), Color);
        SpriteBatch.End();
    }
    public void DrawStringD2D(string KeyName, string Text, float X, float Y, Color Color)
    {
        D2DRenderer.Begin();
        D2DRenderer.DrawString(EngineFunc.D2DFonts[KeyName], Text, new Vector2(X, Y), Color);
        D2DRenderer.End();
    }
    public void DrawString(string KeyName, string Text, float X, float Y, Color Color)
    {
        if (Map.UseD2D)
            DrawStringD2D(KeyName, Text, X, Y, Color);
        else
            DrawStringEx(KeyName, Text, X, Y, Color);
   
    }

    public void DrawRectangle(int X, int Y, int Width, int Height, Color Color)
    {
        SpriteBatch.Begin();
        SpriteBatch.DrawRectangle(new Microsoft.Xna.Framework.Rectangle(X, Y, Width, Height), Color);
        SpriteBatch.End();
    }
    public void FillRect(int X, int Y, int Width, int Height, Color Color)
    {
        SpriteBatch.Begin();
        SpriteBatch.FillRectangle(new Microsoft.Xna.Framework.Rectangle(X, Y, Width, Height), Color);
        SpriteBatch.End();
    }

    public void FillRoundRect(int X, int Y, int Width, int Height, Color Color)
    {
        SpriteBatch.Begin();
        SpriteBatch.FillRoundedRectangle(new Microsoft.Xna.Framework.Rectangle(X, Y, Width, Height), Color);
        SpriteBatch.End();
    }
    public void Pixel(int X, int Y, Color Color)
    {
        SpriteBatch.Begin();
        SpriteBatch.Pixel(X, Y, Color);
        SpriteBatch.End();
    }

    public void DrawLine(Point P1,Point P2, int Width, Color Color)
    {
        SpriteBatch.Begin();
        SpriteBatch.DrawLine(P1,P2,Width, Color);
        SpriteBatch.End();
    }
    public void DrawTarget(ref RenderTarget2D Target, int Width, int Height, Action Action)
    {
        if (Target != null)
        {
            Target.Dispose();
            Target = null;
        }
        Target = new RenderTarget2D(GraphicsDevice, Width, Height, false, SurfaceFormat.Color, DepthFormat.None);
        GraphicsDevice.SetRenderTarget(Target);
        GraphicsDevice.Clear(Color.Transparent);
        Action();
        GraphicsDevice.SetRenderTarget(null);
    }

}










```

`MapleNecrocer/Client/SpriteEngine/Global.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using WzComparerR2.Rendering;
using System.Drawing;
using MapleNecrocer;

namespace MonoGame.SpriteEngine;

public class EngineFunc
{
    public static MonoSpriteEngine SpriteEngine;
    public static MonoSpriteEngine BackgroundEngine;
    public static GameCanvas Canvas;

    public static Dictionary<string, XnaFont> Fonts = new();
    public static Dictionary<string, D2DFont> D2DFonts = new();
    private static float FixedUpdateDelta = 0.016666f;
    // helper variables for the fixed update
    private static float PreviousTime = 0;
    private static float Accumulator = 0.0f;
    private static float ALPHA = 0;



    public static void FixedUpdate(GameTime gameTime, params Action[] FuncArray)
    {
        if (PreviousTime == 0)
        {
            PreviousTime = (float)gameTime.TotalGameTime.TotalMilliseconds;
        }

        float Now = (float)gameTime.TotalGameTime.TotalMilliseconds;
        float FrameTime = Now - PreviousTime;
        if (FrameTime > 0.016666f)
        {
            FrameTime = 0.016666f;
        }

        PreviousTime = Now;
        Accumulator += FrameTime;
        while (Accumulator >= FixedUpdateDelta)
        {

            for (int i = 0; i < FuncArray.Length; i++)
                FuncArray[i]();
            Accumulator -= FixedUpdateDelta;
        }
    }

    static EngineFunc()
    {
        SpriteEngine = new MonoSpriteEngine(null);
        BackgroundEngine = new MonoSpriteEngine(null);
        Canvas = new GameCanvas(RenderFormDraw.Instance.GraphicsDevice);
        SpriteEngine.Canvas = Canvas;
        BackgroundEngine.Canvas = Canvas;

    }

    public static void AddFont(GraphicsDevice GraphicsDevice, string KeyName, string FontName, float Size)
    {
        var Font = new XnaFont(GraphicsDevice, new Font(FontName, Size, GraphicsUnit.Pixel));
       // var Font = new XnaFont(GraphicsDevice, new Font(FontName, Size));
        Fonts.Add(KeyName, Font);
    }

    public static void AddD2DFont(string KeyName, string FontName, float Size)
    {
        var Font = new D2DFont(FontName, Size);
        D2DFonts.Add(KeyName, Font);

    }
}

```

`MapleNecrocer/Client/SpriteEngine/Keyboard.cs`:

```cs
using Microsoft.Xna.Framework.Input;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using ButtonState=Microsoft.Xna.Framework.Input.ButtonState;

namespace SpriteEngine;

public class Keyboard
{
    static KeyboardState currentKeyState;
    static KeyboardState previousKeyState;

    public static KeyboardState GetState()
    {
        previousKeyState = currentKeyState;
        currentKeyState = Microsoft.Xna.Framework.Input.Keyboard.GetState();
        return currentKeyState;
    }

    public static bool KeyDown(Microsoft.Xna.Framework.Input.Keys key)
    {
        return currentKeyState.IsKeyDown(key);
    }
    public static bool KeyUp(Microsoft.Xna.Framework.Input.Keys key)
    {
        return !previousKeyState.IsKeyUp(key) && currentKeyState.IsKeyUp(key);
    }

    public static bool KeyPressed(Microsoft.Xna.Framework.Input.Keys key)
    {
        return currentKeyState.IsKeyDown(key) && !previousKeyState.IsKeyDown(key);
    }

}
public class Mouse
{ 
    static MouseState lastMouseState;
    static MouseState currentMouseState;
   
    public static MouseState GetState()
    {
        lastMouseState = currentMouseState;
        currentMouseState =  Microsoft.Xna.Framework.Input.Mouse.GetState();
        return currentMouseState;
       
    }
    public static MouseState State
    {
        get=> currentMouseState;
    }
    public static bool LeftClick
    {
        get=> currentMouseState.LeftButton == ButtonState.Pressed &&
            lastMouseState.LeftButton == ButtonState.Released;
      
    }

    public static bool RightClick()
    {
        return currentMouseState.RightButton == ButtonState.Pressed &&
            lastMouseState.RightButton == ButtonState.Released;
    }
    public static bool RightPressed()
    {
        return currentMouseState.RightButton == ButtonState.Pressed;
    }
}

```

`MapleNecrocer/Client/SpriteEngine/NURBSCurve.cs`:

```cs
using Microsoft.Xna.Framework;
using SharpDX;

using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Reflection;
using System.Reflection.Metadata;
using System.Reflection.Metadata.Ecma335;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Windows.Forms;
using Vector2 = Microsoft.Xna.Framework.Vector2;

namespace MonoGame.SpriteEngine;
public enum FittingCurveType { ConstantParameter, ConstantSpeed }
public enum NDrawMode { None, Curve, CurveCP, CurveCPHull }
public class NURBSCurve
{
    public NURBSCurve()
    {
        OrderOfCurve = 4;
        CPCount = 0;
        Array.Resize(ref ControlPoints, CPCount);
        Segments = 3000;
        FittingCurveType = FittingCurveType.ConstantSpeed;
        FittingCurveReady = false;
        UpdateKnots();
    }

    private int KnotsCount;
    private int OrderOfCurve;
    public float ParameterStart;
    public float ParameterEnd;
    private int segments;
    public FittingCurveType FittingCurveType;
    public bool FittingCurveReady;
    public Vector2[] ControlPoints;
    public float[] KnotsVector;
    public Vector2[] FittingCurve;
    public int CPCount;

    public int Segments
    {
        get => segments;
        set
        {
            segments = value;
            Array.Resize(ref FittingCurve, segments);
        }
    }
    private float BSFunction(int KnotIndex, int OrderOfCurve, float Parameter)
    {
        if ((Parameter >= KnotsVector[KnotIndex + OrderOfCurve]) || (Parameter < KnotsVector[KnotIndex]))
        {
            return 0;
        }
        else if (OrderOfCurve == 1)
        {
            if ((Parameter <= KnotsVector[KnotIndex + 1]) && (Parameter >= KnotsVector[KnotIndex]))
                return 1;
            else
                return 0;
        }
        else
        {
            float FirstItem, SecondItem, numerator;
            float denominator = KnotsVector[KnotIndex + OrderOfCurve - 1] - KnotsVector[KnotIndex];
            if (denominator == 0)
            {
                FirstItem = 0;
            }
            else
            {
                numerator = Parameter - KnotsVector[KnotIndex];
                if (numerator == 0)
                    FirstItem = 0;
                else
                    FirstItem = (numerator / denominator) * BSFunction(KnotIndex, (OrderOfCurve - 1), Parameter);

            }
            // { SecondItem}
            denominator = KnotsVector[KnotIndex + OrderOfCurve] - KnotsVector[KnotIndex + 1];
            if (denominator == 0)
            {
                SecondItem = 0;
            }
            else
            {
                numerator = KnotsVector[KnotIndex + OrderOfCurve] - Parameter;
                if (numerator == 0)
                    SecondItem = 0;
                else
                    SecondItem = (numerator / denominator) * BSFunction((KnotIndex + 1), (OrderOfCurve - 1), Parameter);

            }
            return FirstItem + SecondItem;
        }

    }

    private Vector2 CalcXY(float Parameter)
    {
        Vector2 Value = new Vector2(0, 0);
        float CheckSumm = 0;
        float N;
        for (int i = 0; i < CPCount; i++)
        {
            N = BSFunction(i, OrderOfCurve, Parameter);
            Value += ControlPoints[i] * N;
            CheckSumm += N;
        }
        Vector2 Result = new Vector2(Value.X / CheckSumm, Value.Y / CheckSumm);
        if (Parameter >= ParameterEnd)
        {
            Result.X = ControlPoints[CPCount - 1].X;
            Result.Y = ControlPoints[CPCount - 1].Y;
        }
        return Result;
    }
    static double Hypot(float x, float y)
    {
        return Math.Sqrt(Math.Pow(x, 2) + Math.Pow(y, 2));
    }
    float Length2(Vector2 v)
    {
        return (float)Hypot(v.X, v.Y);
    }
    private float GetSegmentLength(int Index1, int Index2)
    {
        if (!FittingCurveReady)
            SetFittingCurve();
        float Result = 0;
        for (int i = Index1; i < Index2 - 1; i++)
            Result += Length2(new Vector2(FittingCurve[i].X, FittingCurve[i].Y) -
                              new Vector2(FittingCurve[i + 1].X, FittingCurve[i + 1].Y));
        return Result;
    }
    private float GetCurveLength()
    {
        if (!FittingCurveReady)
            SetFittingCurve();
        return GetSegmentLength(1, Segments - 1);
    }

    public float CurveLength
    {
        get
        {
            if (!FittingCurveReady)
                SetFittingCurve();

            return GetSegmentLength(1, Segments - 1) * 3000;
        }
    }

    public void SetFittingCurve()
    {
        float Parameter2, SegmentLength, Parameter2Delta, temp;
        float[] Parameter = new float[0];
        switch (FittingCurveType)
        {
            case FittingCurveType.ConstantParameter:
                Array.Resize(ref Parameter, Segments);
                Parameter[0] = ParameterStart;
                for (int i = 1; i < Segments; i++)
                    Parameter[i] = Parameter[i - 1] + (ParameterEnd - ParameterStart) / (Segments - 1);
                for (int i = 0; i < Segments; i++)
                    FittingCurve[i] = CalcXY(Parameter[i]);
                FittingCurve[Segments - 1].X = ControlPoints[CPCount - 1].X;
                FittingCurve[Segments - 1].Y = ControlPoints[CPCount - 1].Y;
                break;
            case FittingCurveType.ConstantSpeed:
                Parameter2 = ParameterStart;
                // getting CurveLength
                FittingCurveType = FittingCurveType.ConstantParameter;
                SetFittingCurve();
                FittingCurveType = FittingCurveType.ConstantSpeed;
                SegmentLength = CurveLength / (Segments - 1);
                Parameter2Delta = SegmentLength / Segments / 100;
                FittingCurve[0].X = ControlPoints[0].X;
                FittingCurve[0].Y = ControlPoints[0].Y;

                for (int i = 0; i < Segments - 1; i++)
                {
                    temp = 0;
                    do
                    {
                        FittingCurve[i] = CalcXY(Parameter2);
                        Parameter2 = Parameter2 + Parameter2Delta;
                        if (Parameter2 >= ParameterEnd)
                            break;
                        temp = GetSegmentLength(i - 1, i);
                    } while (temp >= SegmentLength);
                }

                FittingCurve[Segments - 1].X = ControlPoints[CPCount - 1].X;
                FittingCurve[Segments - 1].Y = ControlPoints[CPCount - 1].Y;
                break;
        }
        FittingCurveReady = true;
        Parameter = null;
    }
    public void UpdateKnots()
    {
        KnotsCount = CPCount + OrderOfCurve;
        Array.Resize(ref KnotsVector, KnotsCount);
        for (int i = 0; i < CPCount; i++)
        {
            KnotsVector[i + OrderOfCurve - 1] = i;
        }
        for (int i = KnotsCount - OrderOfCurve; i < KnotsCount; i++)
        {
            KnotsVector[i] = KnotsVector[KnotsCount - OrderOfCurve];
        }
        ParameterStart = KnotsVector[0];
        ParameterEnd = KnotsVector[KnotsCount - 1];
    }

    static float Angle2(Vector2 v)
    {
        return (float)Math.Atan2(v.X, v.Y);
    }
    public float GetTangent(float Parameter)
    {
        int Index;
        float ParameterDetla = 1000, Result = 0;
        Vector2 p1, p2;
        switch (FittingCurveType)
        {
            case FittingCurveType.ConstantParameter:

                if (Parameter >= 1)
                    Parameter = Parameter - ParameterDetla;
                p1 = CalcXY(Parameter * ParameterEnd);
                p2 = CalcXY(Parameter * ParameterEnd + ParameterDetla);
                Result = Angle2(p2 - p1);
                break;
            case FittingCurveType.ConstantSpeed:
                Index = (int)(Parameter * Segments) * 3000;
                if (Index >= Segments - 1)
                    Index = Segments - 2;
                Result = Angle2(FittingCurve[Index + 1] - FittingCurve[Index]);
                break;
        }
        return Result;
    }

    public Vector2 GetXY(float Parameter)
    {
        int Index;
        float k, Residue, Span;
        Vector2 Result = new Vector2();

        switch (FittingCurveType)
        {
            case FittingCurveType.ConstantParameter:
                Result = CalcXY(Parameter * ParameterEnd);

                break;

            case FittingCurveType.ConstantSpeed:
                Index = (int)(Parameter * Segments);
                if (Index > Segments - 2)
                {
                    Result.X = FittingCurve[Segments - 1].X;
                    Result.Y = FittingCurve[Segments - 1].Y;
                    break;
                }
                Residue = Parameter * Segments - Index;
                k = FittingCurve[Index + 1].Y - FittingCurve[Index].Y;
                k = k / (FittingCurve[Index + 1].X - FittingCurve[Index].X);
                Span = GetSegmentLength(Index, Index + 1);
                Span = Span * Residue;
                Result.X = Span * (float)Math.Cos(Math.Atan2(k, 1));
                Result.Y = Span * (float)Math.Sin(Math.Atan2(k, 1));

                if (FittingCurve[Index + 1].X > FittingCurve[Index].X)
                {
                    Result.X = FittingCurve[Index].X + Result.X;
                    Result.Y = FittingCurve[Index].Y + Result.Y;
                }
                else
                {
                    Result.X = FittingCurve[Index].X - Result.X;
                    Result.Y = FittingCurve[Index].Y - Result.Y;
                }

                break;
        }
        return Result;

    }
}

public class NURBSCurveEx : NURBSCurve
{
    public NURBSCurveEx() : base()
    {
        CPRadius = 10;
    }
    public int CreateCP(int X, int Y)
    {
        CPCount += 1;
        Array.Resize(ref ControlPoints, CPCount);
        ControlPoints[CPCount - 1].X = X;
        ControlPoints[CPCount - 1].Y = Y;
        UpdateKnots();
        return CPCount - 1;
    }

    public int CPRadius;

    public void DeleteCp()
    {
        if (CPCount == 1)
            return;
        CPCount -= 1;
        Array.Resize(ref ControlPoints, CPCount);
        UpdateKnots();
    }
    public void Draw()
    {
    }

    public int GetCP(int X, int Y)
    {
        for (int i = 0; i < CPCount; i++)
        {
            if (CPRadius >= Math.Sqrt((ControlPoints[i].X - X) * (ControlPoints[i].X - X) + (ControlPoints
               [i].Y - Y) * (ControlPoints[i].Y - Y)))
            {
                return i;

            }
        }
        return -1;
    }
    public void LoadCurve(string FileName)
    {
        string AllText = System.IO.File.ReadAllText(FileName);
        string[] Section = AllText.Split('/');
        int Length = Section.Length;
        CPCount = Length;
        Array.Resize(ref ControlPoints, CPCount);
        int x = 0, y = 0;
        for (int i = 0; i < CPCount - 1; i++)
        {
            var Str = Section[i].Split(',');
            x = int.Parse(Regex.Replace(Str[0], @"\D", ""));
            y = int.Parse(Regex.Replace(Str[1], @"\D", ""));
            ControlPoints[i].X = x;
            ControlPoints[i].Y = y;
        }
        FittingCurveReady = false;
        UpdateKnots();
    }

    public void Updata()
    {
        Vector2[] Points = new Vector2[0];
        if (CPCount > 4)
        {
            Array.Resize(ref Points, CPCount);
            for (int i = 0; i < CPCount; i++)
            {
                Points[i].X = ControlPoints[i].X;
                Points[i].Y = ControlPoints[i].Y;
            }
            SetFittingCurve();
        }
        Points = null;
    }



}
```

`MapleNecrocer/Client/SpriteEngine/SpriteBatchEx.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using System.Drawing;
using System.Drawing.Imaging;
using System.Drawing.Drawing2D;
using GDIColor = System.Drawing.Color;
using GDIRect = System.Drawing.Rectangle;
using Rectangle = Microsoft.Xna.Framework.Rectangle;
using Color = Microsoft.Xna.Framework.Color;
using Point = Microsoft.Xna.Framework.Point;

namespace WzComparerR2.Rendering;
public class SpriteBatchEx : SpriteBatch
{
    public SpriteBatchEx(GraphicsDevice graphicsDevice)
        : base(graphicsDevice)
    {
        this.singlePixel = CreateSinglePixel();
    }

    Texture2D singlePixel;
    private Texture2D CreateSinglePixel()
    {
        Texture2D pixel = new Texture2D(this.GraphicsDevice, 1, 1, false, SurfaceFormat.Color);
        pixel.SetData(new Color[] { Color.White });
        return pixel;
    }

    public void DrawStringEx(XnaFont xnaFont, string text, Vector2 location, Color color)
    {
        DrawStringEx(xnaFont, text, 0, text == null ? 0 : text.Length, location, Vector2.Zero, color);
    }

    public void DrawStringEx(XnaFont xnaFont, string text, Vector2 location, Vector2 size, Color color)
    {
        DrawStringEx(xnaFont, text, 0, text == null ? 0 : text.Length, location, size, color);
    }

    private void DrawStringEx(XnaFont xnaFont, string text, int startIndex, int length, Vector2 location, Vector2 size, Color color)
    {
        IEnumerable<char> e = TextUtils.CreateCharEnumerator(text, startIndex, length);
        DrawStringEx(xnaFont, e, location, size, color, Vector2.Zero, 0);
    }

    public void DrawStringEx(XnaFont xnaFont, StringBuilder stringBuilder, Vector2 location, Color color)
    {
        DrawStringEx(xnaFont, stringBuilder, 0, stringBuilder == null ? 0 : stringBuilder.Length, location, color, Vector2.Zero);
    }

    public void DrawStringEx(XnaFont xnaFont, StringBuilder stringBuilder, Vector2 location, Color color, Vector2 origin)
    {
        DrawStringEx(xnaFont, stringBuilder, 0, stringBuilder == null ? 0 : stringBuilder.Length, location, color, origin);
    }

    public void DrawStringEx(XnaFont xnaFont, StringBuilder stringBuilder, int startIndex, int length, Vector2 location, Color color)
    {
        DrawStringEx(xnaFont, stringBuilder, startIndex, length, location, color, Vector2.Zero);
    }

    public void DrawStringEx(XnaFont xnaFont, StringBuilder stringBuilder, int startIndex, int length, Vector2 location, Color color, Vector2 origin)
    {
        IEnumerable<char> e = TextUtils.CreateCharEnumerator(stringBuilder, startIndex, length);
        DrawStringEx(xnaFont, e, location, Vector2.Zero, color, origin, 0);
    }

    private void DrawStringEx(XnaFont font, IEnumerable<char> text, Vector2 location, Vector2 size, Color color, Vector2 origin, float layerDepth)
    {
        if (font == null || text == null)
        {
            return;
        }

        float dx = location.X, dy = location.Y;

        foreach (char c in text)
        {
            if (c == '\r')
            {
                continue;
            }
            else if (c == '\n') //换行符
            {
                dy += font.Height;
                dx = location.X;
                continue;
            }
            else
            {
                Rectangle rect = font.TryGetRect(c);
                if (size.X > 0 && dx > location.X && dx + rect.Width > location.X + size.X) //强制换行
                {
                    dy += font.Height;
                    dx = location.X;
                }
                base.Draw(font.TextureBuffer, new Vector2(dx, dy), rect, color, 0f, origin, 1f, SpriteEffects.None, layerDepth);
                dx += rect.Width;
            }
        }
        location.X = dx;
        location.Y = dy;
    }

    public void DrawPath(Point[] path, Color color)
    {
        Rectangle[] rectPath = new Rectangle[path.Length];
        for (int i = 0; i < path.Length - 1; i++)
        {
            if (path[i].X == path[i + 1].X)
            {
                int dy = path[i + 1].Y - path[i].Y;
                if (dy > 0)
                {
                    rectPath[i] = new Rectangle(path[i].X, path[i].Y, 1, dy);
                }
                else if (dy < 0)
                {
                    rectPath[i] = new Rectangle(path[i].X, path[i + 1].Y + 1, 1, -dy);
                }
            }
            else if (path[i].Y == path[i + 1].Y)
            {
                int dx = path[i + 1].X - path[i].X;
                if (dx > 0)
                {
                    rectPath[i] = new Rectangle(path[i].X, path[i].Y, dx, 1);
                }
                else if (dx < 0)
                {
                    rectPath[i] = new Rectangle(path[i + 1].X + 1, path[i].Y, -dx, 1);
                }
            }
        }
        if (path[0] != path[path.Length - 1] || path.Length == 1)
        {
            rectPath[path.Length - 1] = new Rectangle(
                path[path.Length - 1].X,
                path[path.Length - 1].Y,
                1,
                1);
        }
        for (int i = 0; i < rectPath.Length; i++)
        {
            if (rectPath[i].Width > 0 && rectPath[i].Height > 0)
            {
                this.FillRectangle(rectPath[i], color);
            }
        }
    }

    public void FillRectangle(Rectangle rectangle, Color color)
    {
        base.Draw(singlePixel, rectangle, color);
    }

    public void FillRectangle(Rectangle rectangle, Color color, Vector2 origin)
    {
        rectangle.X -= (int)origin.X;
        rectangle.Y -= (int)origin.Y;
        base.Draw(singlePixel, rectangle, color);
    }

    public void Pixel(int X, int Y, Color color)
    {
        FillRectangle(new Rectangle(X, Y, 1, 1), color);
    }

    public void FillRoundedRectangle(Rectangle rectangle, Color color)
    {
        if (rectangle.Width > 2 && rectangle.Height > 2)
        {
            base.Draw(singlePixel, new Rectangle(rectangle.X + 1, rectangle.Y, rectangle.Width - 2, 1), color);
            base.Draw(singlePixel, new Rectangle(rectangle.X, rectangle.Y + 1, rectangle.Width, rectangle.Height - 2), color);
            base.Draw(singlePixel, new Rectangle(rectangle.X + 1, rectangle.Bottom - 1, rectangle.Width - 2, 1), color);
        }
        else
        {
            base.Draw(singlePixel, rectangle, color);
        }
    }

    public void DrawRectangle(Rectangle rectangle, Color color)
    {
        if (!rectangle.IsEmpty)
        {
            Point[] path = new Point[5];
            path[0] = new Point(rectangle.X, rectangle.Y);
            path[1] = new Point(path[0].X, rectangle.Y + rectangle.Height);
            path[2] = new Point(rectangle.X + rectangle.Width, path[1].Y);
            path[3] = new Point(path[2].X, path[0].Y);
            path[4] = path[0];
            this.DrawPath(path, color);
        }
    }

    public void DrawLine(Point point1, Point point2, int width, Color color)
    {
        if (point1 != point2)
        {
            float length = Vector2.Distance(new Vector2(point1.X, point1.Y), new Vector2(point2.X, point2.Y));
            Rectangle dest = new Rectangle(point1.X, point1.Y, (int)length, width);
            Vector2 origin = new Vector2(0, 0.5f);
            float rot = (float)Math.Atan2(point2.Y - point1.Y, point2.X - point1.X);
            this.Draw(this.singlePixel, dest, null, color, rot, origin, SpriteEffects.None, 0);
        }
    }

    public void Flush()
    {
        this.End();
        this.GetType().BaseType.GetField("_beginCalled", System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic)
            .SetValue(this, true);
    }

    protected override void Dispose(bool disposing)
    {
        if (disposing)
        {
            if (this.singlePixel != null)
            {
                this.singlePixel.Dispose();
            }
        }
        base.Dispose(disposing);
    }
}


```

`MapleNecrocer/Client/SpriteEngine/SpriteEngine.cs`:

```cs

using DevComponents.AdvTree;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Configuration;
using System.Drawing;
using System.Linq;
using System.Reflection.Metadata.Ecma335;
using WzComparerR2.WzLib;
using static System.Windows.Forms.VisualStyles.VisualStyleElement.TextBox;
using Vector2 = Microsoft.Xna.Framework.Vector2;
namespace MonoGame.SpriteEngine;

public enum CollideMode
{
    Circle,
    Rect,
    Quadrangle,
    Polygon
}

public enum AnimPlayMode
{
    Forward,
    Backward,
    PingPong
}

public enum JumpState
{
    jsNone,
    jsJumping,
    jsFalling

}

public enum SpriteSheetMode
{
    NoneSingle,
    FixedSize,
    VariableSize
}

public enum TileMode
{
    Horizontal,
    Vertical,
    Full
}

public struct FrameData
{
    public string AnimName, ImageName;
    public int OriginX, OriginY;
    public Microsoft.Xna.Framework.Rectangle CropArea;
    public int Delay;

}

public static class Extension
{

    public static Dictionary<TKey, TValue> AddOrReplace<TKey, TValue>(this Dictionary<TKey, TValue> dict, TKey key, TValue value)
    {
        dict[key] = value;
        return dict;
    }

}


public class MonoSpriteEngine : Sprite
{
    public MonoSpriteEngine(Sprite Parent) : base(Parent)
    {
        deadList = new();
        VisibleWidth = 1800;
        VisibleHeight = 1600;
    }
    protected int allCount;
    public int AllCount { get => allCount; set => allCount = value; }
    private List<Sprite> deadList;
    public List<Sprite> DeadList { get => deadList; }
    private int groupCount;
    private List<Sprite>[] groups;
    private int drawCount;
    private List<Sprite> currentSelected;
    public int DrawCount { get => drawCount; set => drawCount = value; }
    public Vector2 Camera;
    public bool ObjectsSelected { get; set; }
    public List<Sprite> CurrentSelected { get => currentSelected; }
    public int VisibleWidth { get; set; }
    public int VisibleHeight { get; set; }
    public GameCanvas Canvas;
    public List<Sprite> this[int index]
    {
        get
        {
            List<Sprite> Result;
            if ((index >= 0) || (index < groupCount))
                Result = groups[index];
            else
                Result = null;
            return Result;
        }
    }

    public void ClearCurrent()
    {
        while (CurrentSelected.Count != 0)
            ((SpriteEx)(CurrentSelected[CurrentSelected.Count - 1])).Selected = false;
        ObjectsSelected = false;
    }

    public void GroupSelect(Rect Area, bool Add = false, params Sprite[] Filter)
    {
        if (!Add)
            ClearCurrent();
        Sprite sprite;
        if (Filter.Length == 1)
        {
            for (int index = 0; index < Count; index++)
            {
                sprite = (SpriteEx)base[index];
                if (sprite.GetType().Equals(Filter[0]) && SpriteUtils.OverLapRect(((SpriteEx)(sprite)).GetBoundsRect(), Area))
                {
                    ((SpriteEx)(sprite)).Selected = true;
                }
            }
        }
        else
        {
            for (int index = 0; index < Count; index++)
            {
                sprite = base[index];
                for (int index2 = 0; index2 < Filter.Length; index2++)
                {
                    if (sprite.GetType().Equals(Filter[index2]) && SpriteUtils.OverLapRect(((SpriteEx)(sprite)).GetBoundsRect(), Area))
                    {
                        ((SpriteEx)(sprite)).Selected = true;
                        break;

                    }
                }
            }
        }
        ObjectsSelected = CurrentSelected.Count != 0;
    }

    public Sprite Select(Vector2 Point, bool Add = false, params Sprite[] Filter)
    {
        Sprite Result = null;
        if (!Add)
            ClearCurrent();
        if (Filter.Length == 1)
        {
            for (int index = DrawList.Count - 1; index >= 0; index--)
            {
                Result = DrawList[index];

                if (Result.GetType().Equals(Filter[0]) && SpriteUtils.PointInRect(Point, ((SpriteEx)(Result)).GetBoundsRect()))
                {
                    ((SpriteEx)(Result)).Selected = true;
                    ObjectsSelected = CurrentSelected.Count != 0;
                    goto End;
                }
                else
                {
                    Result = null;
                }
            }
        }
        else
        {
            for (int index = DrawList.Count - 1; index >= 0; index--)
            {
                Result = DrawList[index];

                for (int index2 = 0; index2 < Filter.Length; index2++)
                {
                    if (Result.GetType().Equals(Filter[index2]) && SpriteUtils.PointInRect(Point, ((SpriteEx)(Result)).GetBoundsRect()))
                    {
                        ((SpriteEx)(Result)).Selected = true;
                        ObjectsSelected = CurrentSelected.Count != 0;
                        goto End;
                    }
                    else
                    {
                        Result = null;
                    }
                }
            }
        }

    End:
        return Result;
    }

    public void ClearGroup(int GroupNumber)
    {
        var Group = this[GroupNumber];
        if (Group != null)
        {
            for (int Index = 0; Index <= Group.Count; Index++)
                ((SpriteEx)(Group[Index])).Selected = false;
        }
    }
    private void SetGroupCount(int GroupCount)
    {
        if (groupCount > GroupCount && GroupCount >= 0)
        {
            if (groupCount > GroupCount)
            {
                for (int Index = GroupCount; Index <= groupCount; Index++)
                {
                    ClearGroup(Index);
                    groups[Index] = null;
                }
                Array.Resize(ref groups, GroupCount);
            }
            else
            {
                Array.Resize(ref groups, GroupCount);
                for (int Index = groupCount; Index <= GroupCount; Index++)
                {
                    groups[Index] = new();
                }
            }
            groupCount = groups.Length;
        }
    }
    public int GroupCount
    {
        get => groupCount;
        set => SetGroupCount(value);
    }

    public void CurrentToGroup(int GroupNumber, bool Add = false)
    {
        List<Sprite> Group = groups[GroupNumber];
        if (Group == null)
            return;
        if (!Add)
            ClearGroup(GroupNumber);
        for (int index = 0; index < Group.Count; index++)
            ((SpriteEx)Group[index]).GroupNumber = GroupNumber;
    }

    public override void Draw()
    {
        drawCount = 0;
        base.Draw();
    }

    public void DrawEx(params string[] TypeList)
    {
        if (Visible)
        {
            if (Engine != null)
            {
                if ((X > Engine.Camera.X - Width) && (Y > Engine.Camera.Y - Height) && (X < Engine.Camera.X + Engine.VisibleWidth) && (Y < Engine.Camera.Y + Engine.VisibleHeight))
                {
                    DoDraw();
                    Engine.drawCount++;
                }
            }

            if (DrawList != null)
            {
                foreach (var I in DrawList)
                {
                    foreach (var i2 in TypeList)
                    {
                        if (((Sprite)I).GetType().Name == i2)
                            ((Sprite)I).Draw();
                    }
                }
            }
        }
    }
    public void Dead()
    {
        while (deadList.Count > 0)
        {
            ((Sprite)deadList[deadList.Count - 1]).Free();
        }
    }

}

public class Sprite
{
    public Sprite(Sprite Parent)
    {
        parent = Parent;
        if (parent != null)
        {
            parent.Add(this);
            if (parent is MonoSpriteEngine)
                Engine = (MonoSpriteEngine)parent;
            else
                Engine = parent.Engine;
            Engine.AllCount++;
        }
        X = 200;
        Y = 200;
        Z = 0;
        if (Z == 0)
            Z = 1;
        Width = 100;
        Height = 100;
        Moved = true;
        Visible = true;
        BlendMode = BlendMode.Normal;
    }
    public Sprite(Sprite Parent, Dictionary<Wz_Node, Microsoft.Xna.Framework.Graphics.Texture2D> ImageLib,
                  Wz_Node ImageNode, float X, float Y, int Z = 0, int Width = 100, int Height = 100)
    {
        parent = Parent;
        if (parent != null)
        {
            parent.Add(this);
            if (parent is MonoSpriteEngine)
                Engine = (MonoSpriteEngine)parent;
            else
                Engine = parent.Engine;
            Engine.AllCount++;
        }
        this.ImageLib = ImageLib;
        this.ImageNode = ImageNode;
        this.x = X;
        this.y = Y;
        this.z = Z;
        if (Z == 0)
            Z = 1;
        this.Width = Width;
        this.Height = Height;
        Moved = true;
        Visible = true;
        BlendMode = BlendMode.Normal;
    }
    public void Init(Dictionary<Wz_Node, Microsoft.Xna.Framework.Graphics.Texture2D> ImageLib,
                       Wz_Node ImageNode, float X, float Y, int Z = 0, int Width = 100, int Height = 100)
    {
        this.ImageLib = ImageLib;
        this.ImageNode = ImageNode;
        this.x = X;
        this.y = Y;
        this.z = Z;
        this.Width = Width;
        this.Height = Height;
    }
    public MonoSpriteEngine Engine { get; set; }
    private List<Sprite> List;
    public List<Sprite> DrawList;
    private bool Deaded;
    public int Width, Height;
    public int Left, Top, Right, Bottom;
    // private string imageName;
    private float x, y;
    private int z;
    public Vector2 Camera;
    public bool Visible;
    public bool CanCollision;
    int patternIndex;
    public int PatternIndex
    {
        get => patternIndex;
        set
        {
            patternIndex = value;
            // if (imageName == " ")
            //  return;
        }
    }
    public int PatternCount
    {
        get
        {
            int Result = 0;
            if (PatternWidth != 0 && PatternHeight != 0)
            {
                Result = (ImageWidth / PatternWidth) * (ImageHeight / PatternHeight);
            }
            return Result;
        }
    }

    int imageIndex;
    public bool Moved { get; set; }
    public bool IntMove { get; set; }
    public Vector2 CollidePos;
    public int CollideRadius;
    public Rect CollideRect;
    private Sprite parent;
    private int tag;
    public BlendMode BlendMode;
    public CollideMode CollideMode { get; set; }
    private bool ZSet;
    public Wz_Node ImageNode;

    // public Dictionary<string, Microsoft.Xna.Framework.Graphics.Texture2D> ImageLib;
    public Dictionary<Wz_Node, Microsoft.Xna.Framework.Graphics.Texture2D> ImageLib;
    public int ImageWidth
    {
        get
        {
            return ImageLib[ImageNode].Width;
        }
    }
    public int ImageHeight
    {
        get => ImageLib[ImageNode].Height;
    }
    public int PatternWidth;
    public int PatternHeight;
    public int Count
    {
        get
        {
            int Result;
            if (List != null)
                Result = List.Count;
            else
                Result = 0;
            return Result;
        }
    }

    public Sprite this[int index]
    {
        get
        {
            Sprite Result = null;
            if (List != null)
                Result = List[index];
            return Result;
        }
        set { }
    }
    private void Add(Sprite sprite)
    {
        if (List == null)
        {
            List = new List<Sprite>();
            DrawList = new List<Sprite>();
        }
        List.Add(sprite);
        // AddDrawList(sprite);
    }
    private void Remove(Sprite Sprite)
    {
        List.Remove(Sprite);
        DrawList.Remove(Sprite);
        if (List.Count == 0)
        {
            // List.Clear();
            List = null;
            // DrawList.Clear();
            DrawList = null;
        }
    }
    private void AddDrawList(Sprite sprite)
    {
        int L = 0;
        int H = DrawList.Count - 1;
        int I;
        while (L <= H)
        {
            I = (L + H) / 2;
            int C = (DrawList[I]).z - sprite.z - 1;
            if (C < 0)
                L = I + 1;
            else
                H = I - 1;
        }
        DrawList.Insert(L, sprite);
    }
    public void Clear()
    {
        while (Count > 0)
            this[Count - 1] = null;

    }
    public void Dead()
    {
        if ((Engine != null) && (!Deaded))
        {
            Deaded = true;
            Engine.DeadList.Add(this);
        }
    }
    public virtual void Free()
    {
        this.Clear();
        if (Parent != null)
        {
            Parent.Remove(this);
            Engine.DeadList.Remove(this);
            Engine.AllCount--;
        }

        List = null;
        DrawList = null;
    }
    public virtual void Draw()
    {
        if (Visible)
        {
            if (Engine != null)
            {
                if ((X > Engine.Camera.X - Width) && (Y > Engine.Camera.Y - Height) && (X < Engine.Camera.X + Engine.VisibleWidth) && (Y < Engine.Camera.Y + Engine.VisibleHeight))
                {
                    DoDraw();
                    Engine.DrawCount++;
                }
            }
            if (DrawList != null)
            {
                for (int i = 0; i < DrawList.Count; i++)
                    ((Sprite)DrawList[i]).Draw();
            }
        }

    }

    public void Move(float Delta)
    {
        if (Moved)
        {
            DoMove(Delta);
            for (int i = 0; i < Count; i++)
                this[i].Move(Delta);
        }
    }

    public virtual void DoMove(float Delta)
    {

    }
    public virtual void DoDraw()
    {
        if (!Visible || ImageLib == null)
            return;

        Engine.Canvas.DrawEx(ImageLib[ImageNode],
           X + Camera.X - Engine.Camera.X, Y + Camera.Y - Engine.Camera.Y, 0, 0, 1, 1, 0, false, false, 255, 255, 255, 255, false, BlendMode);
    }

    public string Name;
    /*
    public string ImageName
    {
        get => imageName;
        set
        {
            if (!string.Equals(imageName, value))
                imageName = value;
        }
    }
    */
    public void SetPos(float X, float Y)
    {
        this.x = X;
        this.y = Y;
    }
    public void SetPos(float X, float Y, int Z)
    {
        this.x = X;
        this.y = Y;
        this.z = Z;
    }
    public void SetSize(int AWidth, int AHeight)
    {
        this.Width = AWidth;
        this.Height = AHeight;
    }

    public float X
    {
        get => x;
        set => x = value;
    }
    public float Y
    {
        get => y;
        set => y = value;

    }
    public int Z
    {
        get => z;
        set
        {
            if (z != value)
            {
                z = value;
                if (parent != null)
                {
                    // optimize load time
                    if (ZSet)
                        parent.DrawList.Remove(this);
                    parent.AddDrawList(this);
                    ZSet = true;
                }
            }
        }
    }

    public void SetCollideRect(int Left, int Top, int Right, int Bottom)
    {
        this.Left = (int)(X + Left);
        this.Top = (int)(Y + Top);
        this.Right = (int)(X + Right);
        this.Bottom = (int)(Y + Bottom);
        CollideRect = SpriteUtils.Rect(this.Left, this.Top, this.Right, this.Bottom);
    }
    public virtual void Collision(Sprite Other)
    {
        double Delta;
        bool IsCollide = false;
        if (CanCollision && Other.CanCollision && (!Deaded) && (!Other.Deaded))
        {
            switch (CollideMode)
            {
                case CollideMode.Circle:
                    Delta = Math.Sqrt(Math.Pow(CollidePos.X - Other.CollidePos.X, 2) + Math.Pow(CollidePos.Y - Other.CollidePos.Y, 2));
                    IsCollide = (Delta < (CollideRadius + Other.CollideRadius));
                    break;
                case CollideMode.Rect:
                    IsCollide = SpriteUtils.OverLapRect(CollideRect, Other.CollideRect);
                    break;
            }

            if (IsCollide)
            {
                OnCollision(Other);
                Other.OnCollision(this);
            }
        }

    }
    public virtual void Collision()
    {
        if ((Engine != null) && (!Deaded) && (CanCollision))
        {
            for (int i = 0; i < Engine.Count; i++)
            {
                this.Collision(Engine.List[i]);
            }
        }
    }

    public virtual void OnCollision(Sprite sprite)
    {

    }
    public List<Sprite> SpriteList
    {
        get => List;
        set
        {
            List = value;
        }
    }
    public Sprite Parent { get => parent; }
    public int Tag
    {
        get => tag; set { tag = value; }
    }
}

//SpriteEx
public class SpriteEx : Sprite
{
    public SpriteEx(Sprite Parent) : base(Parent)
    {
        Init();
    }
    public SpriteEx(Sprite Parent, Dictionary<Wz_Node, Microsoft.Xna.Framework.Graphics.Texture2D> ImageLib,
                 Wz_Node ImageNode, float X, float Y, int Z = 0, int Width = 100, int Height = 100) : base(Parent)
    {
        Init();
        this.ImageLib = ImageLib;
        this.ImageNode = ImageNode;
        this.X = X;
        this.Y = Y;
        this.Z = Z;
        this.Width = Width;
        this.Height = Height;
    }

    private void Init()
    {
        GroupNumber = -1;

        ScaleX = 1;
        ScaleY = 1;
        Red = 255;
        Green = 255;
        Blue = 255;
        Alpha = 255;
        DrawMode = 1;
        FlipX = false;
        FlipY = false;
        PositionListX = new();
        PositionListY = new();
        CosTable256 = new double[256];
        for (int i = 0; i < 256; i++)
        {
            CosTable256[i] = Math.Cos(i * Math.PI / 128.0);
        }
    }


    public void Init(Dictionary<Wz_Node, Microsoft.Xna.Framework.Graphics.Texture2D> ImageLib,
                     Wz_Node ImageNode, float X, float Y, int Z, int PatternWidth, int PatternHeight, int Width = 100, int Height = 100)
    {
        this.ImageLib = ImageLib;
        this.ImageNode = ImageNode;
        this.X = X;
        this.Y = Y;
        this.Z = Z;
        this.PatternWidth = PatternWidth;
        this.PatternHeight = PatternHeight;
        this.Width = Width;
        this.Height = Height;
    }
    public Wz_Vector Origin = new Wz_Vector(0, 0);
    public Vector2 Offset;
    public float ScaleX { get; set; }
    public float ScaleY { get; set; }
    public bool FlipX;
    public bool FlipY;
    public byte Red, Green, Blue, Alpha;
    public float X1, Y1, X2, Y2;
    public int DrawMode;
    public bool DoCenter;
    public int GoDirection;
    private bool selected;
    private int groupNumber;
    private Sprite AttachTo;
    public float Angle;

    private float SrcAngle, DestAngle;
    private List<float> PositionListX, PositionListY;
    public Microsoft.Xna.Framework.Rectangle CropRect;
    public SpriteSheetMode SpriteSheetMode;
    private const float PIConv256 = -40.743665431f; //-128.0 / PI;
    double[] CosTable256;

    public override void DoMove(float Delta)
    {
        base.DoMove(Delta);

    }
    public int GetAngle256(int X, int Y)
    {
        return (int)(Math.Atan2(X, Y) * PIConv256) + 128;
    }
    public int GetAngle256(int SrcX, int SrcY, int DestX, int DestY)
    {
        /*
        if (SrcX == DestX)
        {
            return 128;
            if (SrcY < DestY)
                return 0;
        }
        */

        return (int)Math.Round(Math.Atan2(DestX - SrcX, DestY - SrcY) * PIConv256) + 128;
    }
    public double Cos256(int i)
    {
        return CosTable256[i & 255];
    }
    public double Sin256(int i)
    {
        return CosTable256[(i + 192) & 255];
    }
    public void LookAt(int TargetX, int TargetY)
    {
        Angle = GetAngle256((int)X, (int)Y, TargetX, TargetY) / -PIConv256;
    }
    public void TowardToAngle(int Direction256, float Speed, bool DoLookAt, float Delta)
    {
        // if (DoLookAt)
        //   Angle = Direction256 / -PIConv256;
        X += (float)(Sin256(Direction256) * Speed );
        Y -= (float)(Cos256(Direction256) * Speed );

    }
    bool SameValue(float A, float B, float Epsilon)
    {
        if (Epsilon == 0)
            Epsilon = Math.Max(Math.Min(Math.Abs(A), Math.Abs(B)) * 0.0001f, 0.0001f);
        if (A > B)
            return (A - B) <= Epsilon;
        else
            return (B - A) <= Epsilon;
    }
    public void TowardToPos(int TargetX, int TargetY, float Speed, bool DoLookAt, bool Stop, float Delta)
    {
        if (DoLookAt)
            LookAt(TargetX, TargetY);
        int Direction256 = GetAngle256((int)X, (int)Y, TargetX, TargetY);
        GoDirection = Direction256;
        if (Stop)
        {
            if ((!SameValue(X, TargetX, Speed + 1)) || (!SameValue(Y, TargetY, Speed + 1)))
            {
                X += (float)(Sin256(Direction256) * Speed);
                Y -= (float)(Cos256(Direction256) * Speed);
            }
            else
            {
                X = TargetX;
                Y = TargetY;
            }
        }
        else
        {
            X += (float)(Sin256(Direction256) * Speed);
            Y -= (float)(Cos256(Direction256) * Speed);
        }
    }

    // toward(rotate self angle automation)(straight) move direction
    // and move by rotation speed(to destination angle)
    public void RotateToAngle(int Direction, float RotateSpeed, float MoveSpeed, float Delta)
    {
        DestAngle = Direction;
        if (!SameValue(SrcAngle, DestAngle, RotateSpeed + 1))
        {
            if (SpriteUtils.AngleDiff(SrcAngle, DestAngle) > 0)
                SrcAngle = SrcAngle + RotateSpeed;
            if (SpriteUtils.AngleDiff(SrcAngle, DestAngle) < 0)
                SrcAngle = SrcAngle - RotateSpeed;
        }
        if (SrcAngle > 255)
            SrcAngle = SrcAngle - 255;
        if (SrcAngle < 0)
            SrcAngle = 255 + SrcAngle;
        Angle = SrcAngle / -PIConv256;
        X += (float)(Sin256((int)SrcAngle) * MoveSpeed);
        Y -= (float)(Cos256((int)SrcAngle) * MoveSpeed);
    }

    // toward(rotate self angle automation)(straight) move  direction
    // and move by rotation speed(to destination position)

    public void RotateToPos(int TargetX, int TargetY, float RotateSpeed, float MoveSpeed, float Delta)
    {
        DestAngle = GetAngle256((int)X, (int)Y, TargetX, TargetY);

        if (!SameValue(SrcAngle, DestAngle, RotateSpeed + 1))
        {
            if (SpriteUtils.AngleDiff(SrcAngle, DestAngle) > 0)
                SrcAngle = SrcAngle + RotateSpeed;
            if (SpriteUtils.AngleDiff(SrcAngle, DestAngle) < 0)
                SrcAngle = SrcAngle - RotateSpeed;
        }
        if (SrcAngle > 255)
            SrcAngle = SrcAngle - 255;
        if (SrcAngle < 0)
            SrcAngle = 255 + SrcAngle;
        Angle = SrcAngle / -PIConv256;
        X += (float)(Sin256((int)SrcAngle) * MoveSpeed * Delta);
        Y -= (float)(Cos256((int)SrcAngle) * MoveSpeed * Delta);
    }

    // move by rotation speed to destination angle,but not straight direction(no rotate self)
    // but can be custom angle
    public void CircleToAngle(int Direction, int LookAtX, int LookAtY, float RotateSpeed, float MoveSpeed, bool DoLookAt, float Delta)
    {
        if (DoLookAt)
            LookAt(LookAtX, LookAtY);
        DestAngle = Direction;
        if (!SameValue(SrcAngle, DestAngle, RotateSpeed + 1))
        {
            if (SpriteUtils.AngleDiff(SrcAngle, DestAngle) > 0)
                SrcAngle = SrcAngle + RotateSpeed;
            if (SpriteUtils.AngleDiff(SrcAngle, DestAngle) < 0)
                SrcAngle = SrcAngle - RotateSpeed;
        }
        if (SrcAngle > 255)
            SrcAngle = SrcAngle - 255;
        if (SrcAngle < 0)
            SrcAngle = 255 + SrcAngle;
        X += (float)(Sin256((int)SrcAngle) * MoveSpeed);
        Y -= (float)(Cos256((int)SrcAngle) * MoveSpeed);
    }

    // move by rotation speed to destination position,but not straight direction(no rotae self)
    // but can be custom angle
    public void CircleToPos(int TargetX, int TargetY, int LookAtX, int LookAtY, float RotateSpeed, float MoveSpeed, bool DoLookAt, float Delta)
    {
        if (DoLookAt)
            LookAt(LookAtX, LookAtY);
        DestAngle = GetAngle256((int)X, (int)Y, TargetX, TargetY);
        if (!SameValue(SrcAngle, DestAngle, RotateSpeed + 1))
        {
            if (SpriteUtils.AngleDiff(SrcAngle, DestAngle) > 0)
                SrcAngle = SrcAngle + RotateSpeed * Delta;
            if (SpriteUtils.AngleDiff(SrcAngle, DestAngle) < 0)
                SrcAngle = SrcAngle - RotateSpeed * Delta;
        }
        if (SrcAngle > 255)
            SrcAngle = SrcAngle - 255;
        if (SrcAngle < 0)
            SrcAngle = 255 + SrcAngle;
        X += (float)(Sin256((int)SrcAngle) * MoveSpeed * Delta);
        Y -= (float)(Cos256((int)SrcAngle) * MoveSpeed * Delta);
    }
    public void Attach(Sprite Sprite)
    {
        if (AttachTo == null)
            return;
        AttachTo = Sprite;
        float CurrentPositionX = AttachTo.X;
        float CurrentPositionY = AttachTo.Y;
        PositionListX.Add(CurrentPositionX);
        PositionListY.Add(CurrentPositionY);
        if (PositionListX.Count > 2)
        {
            float LastPositionX = PositionListX.Last();
            float LastPositionY = PositionListY.Last();
            float PredPositionX = PositionListX[1];
            float PredPositionY = PositionListY[1];
            X += (LastPositionX - PredPositionX);
            Y += (LastPositionY - PredPositionY);
            PositionListX.RemoveAt(0);
            PositionListY.RemoveAt(0);
        }
    }

    public static double Hypot(double x, double y)
    {
        return Math.Sqrt(Math.Pow(x, 2) + Math.Pow(y, 2));
    }

    public double GetDistance(Sprite Sprite1, Sprite Sprite2)
    {
        return Hypot(Sprite1.X - Sprite2.X, Sprite1.Y - Sprite2.Y);
    }

    public void Detach()
    {
        AttachTo = null;
    }

    private void SetSelected(bool Selected)
    {
        if ((Selected != selected) && (Engine != null))
        {
            selected = Selected;
            if (Selected)
                Engine.CurrentSelected.Add(this);
            else
                Engine.CurrentSelected.Remove(this);
            Engine.ObjectsSelected = Engine.CurrentSelected.Count != 0;
        }
    }
    public bool Selected { get => selected; set => SetSelected(value); }
    public Rect GetBoundsRect()
    {
        Rect Result = new Rect();
        Result.Left = (int)X;
        Result.Top = (int)Y;
        Result.Right = (int)X + Width;
        Result.Bottom = (int)Y + Height;
        return Result;
    }

    private void SetGroupNumber(int AGroupNumber)
    {
        if ((AGroupNumber != groupNumber) && (Engine != null))
        {
            if (AGroupNumber >= 0)
                Engine[AGroupNumber].Remove(this);
            if (AGroupNumber >= 0)
                Engine[AGroupNumber].Add(this);
        }
    }
    public int GroupNumber { get => groupNumber; set => SetGroupNumber(value); }
    private void Collision_GetSpriteAt(float x, float y, SpriteEx Sprite)
    {
        if ((Sprite.Parent != null) && (!Sprite.Parent.Visible))
            return;
        Sprite.CanCollision = false;
        bool IsCollision;
        if (Sprite.CanCollision)
        {
            int SWidth = (int)Math.Round(Sprite.PatternWidth * Sprite.ScaleX);
            int SHeight = (int)Math.Round(Sprite.PatternHeight * Sprite.ScaleY);
            if (Sprite.DrawMode == 1)
            {
                X1 = X - Sprite.X - Sprite.Parent.X;
                Y1 = Y - Sprite.Y - Sprite.Parent.Y;
            }
            else
            if (Sprite.DoCenter)
            {
                X1 = X - Sprite.X - Sprite.Parent.X - Sprite.PatternWidth / 2;
                Y1 = Y - Sprite.Y - Sprite.Parent.Y - Sprite.PatternHeight / 2;
            }
            else
            {
                X1 = X - Sprite.X - Sprite.Parent.X - SWidth / 2;
                Y1 = Y - Sprite.Y - Sprite.Parent.Y - SHeight / 2;
            }
            X2 = Y1 * (float)Math.Sin(Sprite.Angle) + X1 * (float)Math.Cos(Sprite.Angle);
            Y2 = Y1 * (float)Math.Cos(Sprite.Angle) - X1 * (float)Math.Sin(Sprite.Angle);
            IsCollision = Sprite.Visible && SpriteUtils.PointInRect(new Vector2(X2, Y2), SpriteUtils.Rect(-SWidth / 2, -SHeight / 2, SWidth, SHeight));
            if (IsCollision)
            {
                //if ((Result = null) ||(Sprite.Z > Result.Z)) 
                //  Result = Sprite;
            }
        }
    }
    public Sprite GetSpriteAt(int X, int Y)
    {
        return null;
    }
    public override void DoDraw()
    {
      //  if (ImageNode == null)
         //   return;
       
        switch (SpriteSheetMode)
        {
            case SpriteSheetMode.NoneSingle:
                Engine.Canvas.DrawEx(ImageLib[ImageNode],
                                     IntMove ? (int)X + Camera.X + Offset.X - (int)Engine.Camera.X : X + Camera.X + Offset.X - Engine.Camera.X,
                                     IntMove ? (int)Y + Camera.Y + Offset.Y - (int)Engine.Camera.Y : Y + Camera.Y + Offset.Y - Engine.Camera.Y,
                                     Origin.X, Origin.Y,
                                     ScaleX, ScaleY,
                                     Angle,
                                     FlipX, FlipY,
                                     Red, Green, Blue, Alpha,
                                     DoCenter,
                                     BlendMode);
                break;
            // 
            case SpriteSheetMode.FixedSize:

                Engine.Canvas.DrawPattern(ImageLib[ImageNode],
                                          IntMove ? (int)X + Camera.X + Offset.X - (int)Engine.Camera.X : X + Camera.X + Offset.X - Engine.Camera.X,
                                          IntMove ? (int)Y + Camera.Y + Offset.Y - (int)Engine.Camera.Y : Y + Camera.Y + Offset.Y - Engine.Camera.Y,
                                          PatternIndex,
                                          PatternWidth, PatternHeight,
                                          Origin.X, Origin.Y,
                                          ScaleX, ScaleY,
                                          Angle,
                                          FlipX, FlipY,
                                          Red, Green, Blue, Alpha,
                                          DoCenter,
                                          BlendMode);


                break;
            //
            case SpriteSheetMode.VariableSize:
                Engine.Canvas.DrawCropArea(ImageLib[ImageNode],
                                           IntMove ? (int)X + Camera.X + Offset.X - (int)Engine.Camera.X : X + Camera.X + Offset.X - Engine.Camera.X,
                                           IntMove ? (int)Y + Camera.Y + Offset.Y - (int)Engine.Camera.Y : Y + Camera.Y + Offset.Y - Engine.Camera.Y,
                                           CropRect,
                                           Origin.X, Origin.Y,
                                           ScaleX, ScaleY,
                                           Angle,
                                           FlipX, FlipY,
                                           Red, Green, Blue, Alpha,
                                           DoCenter,
                                           BlendMode);

                break;
        }
    }

    public override void Draw()
    {
        if (Visible)
        {
            if (Engine != null)
            {
                if ((X + Offset.X > Engine.Camera.X - Width)
                 && (Y + Offset.Y > Engine.Camera.Y - Height)
                 && (X < Engine.Camera.X + Engine.VisibleWidth + Origin.X)
                 && (Y < Engine.Camera.Y + Engine.VisibleHeight + Origin.Y))
                {
                    DoDraw();
                    Engine.DrawCount++;
                }
            }
            if (DrawList != null)
            {
                for (int I = 0; I < DrawList.Count; I++)
                    ((SpriteEx)DrawList[I]).Draw();
            }
        }
    }

    public void SetColor(byte Red, byte Green, byte Blue, byte Alpha = 255)
    {
        this.Red = Red;
        this.Green = Green;
        this.Blue = Blue;
        this.Alpha = Alpha;
    }

    public void SetPattern(int Width, int Height)
    {
        this.PatternWidth = Width;
        this.PatternHeight = Height;
    }
}



public class AnimatedSprite : SpriteEx
{
    public AnimatedSprite(Sprite Parent) : base(Parent)
    {
        SpriteSheetMode = SpriteSheetMode.FixedSize;
        DoAnimate = true;
        PatternWidth = 64;
        PatternHeight = 64;
        Width = 64;
        Height = 64;

    }

    public AnimatedSprite(Sprite Parent, Dictionary<Wz_Node, Microsoft.Xna.Framework.Graphics.Texture2D> ImageLib,
                string ImageName, float X, float Y, int Z = 0, int Width = 100, int Height = 100) : base(Parent)
    {
        DoAnimate = true;
        PatternWidth = 64;
        PatternHeight = 64;
        Width = 64;
        Height = 64;
        SpriteSheetMode = SpriteSheetMode.FixedSize;
        this.ImageLib = ImageLib;
        this.ImageNode = ImageNode;
        this.X = X;
        this.Y = Y;
        this.Z = Z;
        this.Width = Width;
        this.Height = Height;
    }


    public bool DoAnimate;
    public float AnimPos;
    private int animStart;
    public int AnimStart
    {
        get => animStart;
        set
        {
            if (animStart != value)
            {
                AnimPos = value;
                animStart = value;
            }
        }
    }
    public int AnimCount;
    public float AnimSpeed;
    public bool AnimLooped;
    // public bool AnimEnded;
    public AnimPlayMode AnimPlayMode;
    public int ImageIndex;
    private bool Flag1, Flag2;
    public bool FixedAnimSpeed;
    public string AnimName;

    private static Dictionary<string, string> EnumAnimNames = new();
    private static List<FrameData> FrameList = new();
    public static Dictionary<string, List<FrameData>> AnimationLib = new();
    private static void AddAnimation(string Name)
    {
        List<FrameData> List = new();
        foreach (var i in FrameList)
        {
            if (i.AnimName == Name)
            {
                List.Add(i);
            }
        }
        AnimationLib.Add(Name, List);
    }

    public static void AddFrame(string AnimName, string ImageName, int OriginX, int OriginY, Microsoft.Xna.Framework.Rectangle CropArea, int Delay)
    {
        var Frame = new FrameData();
        Frame.AnimName = AnimName;
        Frame.ImageName = ImageName;
        Frame.OriginX = OriginX;
        Frame.OriginY = OriginY;
        Frame.CropArea = CropArea;
        Frame.Delay = Delay;
        FrameList.Add(Frame);
        EnumAnimNames.AddOrReplace(AnimName, AnimName);
    }

    public static void FinishFrames()
    {
        foreach (var i in EnumAnimNames)
        {
            AddAnimation(i.Key);
        }
    }
    public static void ResetFrames()
    {
        EnumAnimNames.Clear();
        AnimationLib.Clear();
        FrameList.Clear();
    }

    public bool AnimEnded()
    {
        bool Result;
        if ((int)AnimPos == (animStart + AnimCount - 1))
            Result = true;
        else
            Result = false;
        return Result;
    }
    public virtual void OnAnimStart()
    {
    }
    public virtual void OnAnimEnd()
    {
    }
    public override void DoMove(float Delta)
    {
        if (!DoAnimate)
            return;
        switch (AnimPlayMode)
        {
            case AnimPlayMode.Forward:
                AnimPos = AnimPos + AnimSpeed;
                if (AnimPos >= animStart + AnimCount)
                {
                    if ((int)AnimPos == animStart)
                        OnAnimStart();
                    if (AnimEnded())
                        OnAnimEnd();
                    if (AnimLooped)
                    {
                        AnimPos = animStart;
                    }
                    else
                    {
                        AnimPos = animStart + AnimCount - 1;
                        DoAnimate = false;
                    }
                }
                PatternIndex = (int)AnimPos;
                ImageIndex = (int)(AnimPos);
                break;
            //
            case AnimPlayMode.Backward:
                AnimPos = AnimPos - AnimSpeed;
                if (AnimPos < animStart)
                {
                    if (AnimLooped)
                    {
                        AnimPos = animStart + AnimCount;
                    }
                    else
                    {
                        // FAnimPos := FAnimStart;
                        AnimPos = animStart + AnimCount;
                        DoAnimate = false;
                    }
                }
                PatternIndex = (int)(AnimPos);
                ImageIndex = (int)(AnimPos);
                break;
            //
            case AnimPlayMode.PingPong:
                AnimPos = AnimPos + AnimSpeed;
                if (AnimLooped)
                {
                    if ((AnimPos > animStart + AnimCount - 1) || (AnimPos < animStart))
                        AnimSpeed = -AnimSpeed;
                }
                else
                {
                    if ((AnimPos > animStart + AnimCount) || (AnimPos < animStart))
                        AnimSpeed = -AnimSpeed;
                    if ((int)AnimPos == (animStart + AnimCount))
                        Flag1 = true;
                    if (((int)AnimPos == animStart) && (Flag1 = true))
                        Flag2 = true;
                    if ((Flag1 = true) && (Flag2 == true))
                    {
                        // FAnimPos := FAnimStart;
                        DoAnimate = false;
                        Flag1 = false;
                        Flag2 = false;
                    }
                }
                PatternIndex = (int)(AnimPos);
                ImageIndex = (int)(AnimPos);
                break;
        }
    }

    public void SetAnim(Wz_Node AniImageNode, int AniStart, int AniCount, float AniSpeed, bool AniLooped, bool DoFlipX, bool DoAnim, AnimPlayMode PlayMode = AnimPlayMode.Forward)
    {
        ImageNode = AniImageNode;
        animStart = AniStart;
        AnimCount = AniCount;
        AnimSpeed = AniSpeed;
        AnimLooped = AniLooped;
        FlipX = DoFlipX;
        DoAnimate = DoAnim;
        AnimPlayMode = PlayMode;
        if ((PatternIndex < animStart) || (PatternIndex >= AnimCount + animStart))
        {
            //PatternIndex = animStart % AnimCount;
            AnimPos = animStart;
            PatternIndex = (int)AnimPos;
        }
    }

    public void SetAnim(Wz_Node AniImageNode, int AniStart, int AniCount, float AniSpeed, bool AniLooped, AnimPlayMode PlayMode = AnimPlayMode.Forward)
    {
        ImageNode = AniImageNode;
        animStart = AniStart;
        AnimCount = AniCount;
        AnimSpeed = AniSpeed;
        AnimLooped = AniLooped;
        AnimPlayMode = PlayMode;
        if ((PatternIndex < animStart) || (PatternIndex >= AnimCount + AnimStart))
        {
            //PatternIndex = animStart % AnimCount;
            AnimPos = animStart;
        }
    }

    public void PlayAnimation(string AniName, float AniSpeed, bool AniLooped, bool Flip, bool DoAnim, AnimPlayMode PlayMode = AnimPlayMode.Forward)
    {
        AnimName = AniName;
        animStart = 0;
        AnimSpeed = AniSpeed;
        AnimLooped = AniLooped;
        FlipX = Flip;
        DoAnimate = DoAnim;
        AnimPlayMode = PlayMode;
        if ((ImageIndex < animStart) || (ImageIndex >= AnimCount + AnimStart))
        {
            //PatternIndex = animStart % AnimCount;
            AnimPos = animStart;
            ImageIndex = (int)AnimPos;
        }

        AnimCount = AnimationLib[AnimName].Count;
        if (ImageIndex >= AnimCount)
            ImageIndex = 0;
        // ImageNode = AnimationLib[AnimName][ImageIndex].ImageNode;
        Origin.X = AnimationLib[AnimName][ImageIndex].OriginX;
        Origin.Y = AnimationLib[AnimName][ImageIndex].OriginY;
        if (FlipX)
        {
            Origin.X = (AnimationLib[AnimName][ImageIndex].OriginX * -1) + AnimationLib[AnimName][ImageIndex].CropArea.Width;
        }
        if (FlipY)
        {
            Origin.Y = (AnimationLib[AnimName][ImageIndex].OriginY * -1) + AnimationLib[AnimName][ImageIndex].CropArea.Height;
        }

        CropRect = AnimationLib[AnimName][ImageIndex].CropArea;
    }

}

public class ParticleSprite : AnimatedSprite
{
    public ParticleSprite(Sprite Parent) : base(Parent)
    {
        AccelX = 0;
        AccelY = 0;
        VelocityX = 0;
        VelocityY = 0;
        UpdateSpeed = 0;
        Decay = 0;
        LifeTime = 1;
    }
    public float AccelX;
    public float AccelY;
    public float VelocityX;
    public float VelocityY;
    public float UpdateSpeed;
    public float Decay;
    public float LifeTime;
    public override void DoMove(float Delta)
    {
        base.DoMove(Delta);
        X = X + VelocityX * UpdateSpeed;
        Y = Y + VelocityY * UpdateSpeed;
        VelocityX = VelocityX + AccelX * UpdateSpeed;
        VelocityY = VelocityY + AccelY * UpdateSpeed;
        LifeTime = LifeTime - Decay;
        if (LifeTime <= 0)
            Dead();
    }
}

public class PlayerSprite : AnimatedSprite
{
    public PlayerSprite(Sprite Parent) : base(Parent)
    {
    }
    private float speed;
    public float Acc;
    public float Dcc;
    public float MaxSpeed;
    public float MinSpeed;
    public float VelocityX;
    public float VelocityY;
    private int direction;
    public int Direction
    {
        get => direction;
        set
        {
            direction = value;
            VelocityX = (float)Cos256(direction + 192) * speed;
            VelocityY = (float)Sin256(direction + 192) * speed;
        }
    }
    public float Speed
    {
        get => speed;
        set
        {
            if (speed > MaxSpeed)
                speed = MaxSpeed;
            else if (speed < MinSpeed)
                speed = MinSpeed;
            speed = value;
            VelocityX = (float)Cos256(direction + 192) * speed;
            VelocityY = (float)Sin256(direction + 192) * speed;
        }
    }

    public void FlipXDirection()
    {
        if (direction >= 64)
            direction = 192 + (64 - direction);
        else if (direction > 0)
            direction = 256 - direction;
    }

    public void FlipYDirection()
    {
        if (direction > 128)
            direction = 128 + (256 - direction);
        else
            direction = 128 - direction;
    }

    public virtual void Accelerate()
    {
        if (speed != MaxSpeed)
        {
            speed = speed + Acc;
            if (speed > MaxSpeed)
                speed = MaxSpeed;
            VelocityX = (float)Cos256(direction + 192) * speed;
            VelocityY = (float)Sin256(direction + 192) * speed;
        }
    }

    public virtual void Deccelerate()
    {
        if (speed != MinSpeed)
        {
            speed = speed - Dcc;
            if (speed < MinSpeed)
                speed = MinSpeed;
            VelocityX = (float)Cos256(direction + 192) * speed;
            VelocityY = (float)Sin256(direction + 192) * speed;
        }
    }

    public float Acceleration
    {
        get => Acc; set => Acc = value;

    }
    public float Decceleration
    {
        get => Dcc; set => Dcc = value;

    }
    public void UpdatePos(float Delta)
    {
        base.DoMove(Delta);
        X += VelocityX;
        Y += VelocityY;
    }
}

public class JumperSprite : PlayerSprite
{
    public JumperSprite(Sprite Parent) : base(Parent)
    {
        VelocityX = 0;
        VelocityY = 0;
        //  MaxSpeed= MaxSpeed;
        Direction = 0;
        jumpState = JumpState.jsNone;
        JumpSpeed = 0.25f;
        JumpHeight = 8;
        Acceleration = 0.2f;
        Decceleration = 0.2f;
        MaxFallSpeed = 5;
        DoJump = false;
    }
    public int JumpCount;
    public float JumpSpeed;
    public float JumpHeight;
    public float MaxFallSpeed;
    public bool DoJump;
    private JumpState jumpState;
    public JumpState JumpState
    {
        get => jumpState;
        set
        {
            if (jumpState != value)
            {
                jumpState = value;
                switch (value)
                {
                    case JumpState.jsNone:
                    case JumpState.jsFalling:
                        VelocityY = 0;
                        break;
                }
            }
        }
    }

    public override void Accelerate()
    {
        if (Speed != MaxSpeed)
        {
            Speed += Acc;
            if (Speed > MaxSpeed)
                Speed = MaxSpeed;
            // VelocityX := Cos256(FDirection) * Speed;
        }
    }
    public override void Deccelerate()
    {
        if (Speed != MinSpeed)
        {
            Speed -= Dcc;
            if (Speed < MinSpeed)
                Speed = MinSpeed;
        }
    }
    public override void DoMove(float Delta)
    {
        base.DoMove(Delta);
        switch (jumpState)
        {
            case JumpState.jsNone:
                if (DoJump)
                {
                    jumpState = JumpState.jsJumping;
                    VelocityY = -JumpHeight;
                }
                break;

            case JumpState.jsJumping:

                Y += VelocityY;
                VelocityY += JumpSpeed;
                if (VelocityY > 0)
                    jumpState = JumpState.jsFalling;
                break;

            case JumpState.jsFalling:
                Y = Y + VelocityY;
                VelocityY = VelocityY + JumpSpeed;
                if (VelocityY > MaxFallSpeed)
                    VelocityY = MaxFallSpeed;
                break;
        }
        DoJump = false;
    }
}

public class JumperSpriteEx : PlayerSprite
{
    public JumperSpriteEx(Sprite Parent) : base(Parent)
    {
        Acceleration = 0.2f;
        Decceleration = 0.2f;
    }
    private JumpState jumpState = JumpState.jsNone;
    public int JumpCount;
    public float JumpSpeed = 0.25f;
    public float JumpStartSpeed;
    public float JumpHeight = 8;
    public float LowJumpSpeed = 0.185f;
    public float LowJumpGravity = 0.6f;
    public int HighJumpValue = 1000;
    public float HighJumpSpeed = 0.1f;
    public float FallingSpeed = 0.2f;
    public float MaxFallSpeed = 5;
    public bool DoJump;
    public bool HoldKey;
    public float Offset = 1;

    public override void Accelerate()
    {
        if (Speed != MaxSpeed)
        {
            Speed += Acc;
            if (Speed > MaxSpeed)
                Speed = MaxSpeed;
            // VelocityX := Cos256(FDirection) * Speed;
        }
    }
    public override void Deccelerate()
    {
        if (Speed != MinSpeed)
        {
            Speed -= Dcc;
            if (Speed < MinSpeed)
                Speed = MinSpeed;
        }
    }

    public JumpState JumpState
    {
        get => jumpState;
        set
        {
            if (jumpState != value)
            {
                jumpState = value;
                switch (value)
                {
                    case JumpState.jsNone:
                    case JumpState.jsFalling:
                        VelocityY = 0;
                        break;
                }
            }
        }
    }

    public override void DoMove(float Delta)
    {
        base.DoMove(Delta);
        switch (jumpState)
        {
            case JumpState.jsNone:

                if (DoJump)
                {
                    HoldKey = true;
                    JumpSpeed = JumpStartSpeed;
                    JumpState = JumpState.jsJumping;
                    VelocityY = -JumpHeight;
                }
                break;
            case JumpState.jsJumping:
                if (HoldKey)
                {
                    JumpCount++;
                }

                if (HoldKey == false)
                {
                    JumpSpeed = LowJumpSpeed; // 0.185;
                    Offset = VelocityY;
                    VelocityY = Offset * LowJumpGravity; // 0.6;  //range 0.0-->1.0
                    HoldKey = true;
                    JumpCount = 0;
                }
                if (JumpCount > HighJumpValue)
                    JumpSpeed = HighJumpSpeed;
                Y += VelocityY;
                VelocityY += JumpSpeed;
                if (VelocityY > 0)
                    JumpState = JumpState.jsFalling;
                break;
            case JumpState.jsFalling:
                JumpCount = 0;
                JumpSpeed = FallingSpeed;
                Y += VelocityY;
                VelocityY += JumpSpeed;
                if (VelocityY > MaxFallSpeed)
                    VelocityY = MaxFallSpeed;
                break;
        }
        DoJump = false;
    }
}

public class PathSprite : AnimatedSprite
{
    public PathSprite(Sprite Parent) : base(Parent)
    {
        Segment = 0;
        Distance = 0;
        Looped = false;
        MoveSpeed = 0.01f;
    }
    public bool Looped;
    public int Segment;
    public float Distance;
    public float MoveSpeed;
    public Vector2[] ControlPoints = new Vector2[10000];
    private int Calculate(int P0, int P1, int P2, int P3, float T)
    {
        return (int)((2 * P1 +
                   (-P0 + P2) * T +
                   (2 * P0 - 5 * P1 + 4 * P2 - P3) * T * T +
                   (-P0 + 3 * P1 - 3 * P2 + P3) * T * T * T) / 2);
    }
    private Vector2 CalculatePoint(Vector2 CP0, Vector2 CP1, Vector2 CP2, Vector2 CP3, float T)
    {
        Vector2 Result;
        Result.X = Calculate((int)CP0.X, (int)CP1.X, (int)CP2.X, (int)CP3.X, T);
        Result.Y = Calculate((int)CP0.Y, (int)CP1.Y, (int)CP2.Y, (int)CP3.Y, T);
        return Result;
    }

    public Vector2 GetPoint(int Index)
    {
        if (Index < 0)
        {
            return ControlPoints[ControlPoints.Length + Index];
        }
        else if (Index > ControlPoints.Length - 1)
        {
            return ControlPoints[Index - ControlPoints.Length];
        }
        else
        {
            return ControlPoints[Index];
        }
    }
    public Vector2 Position
    {
        get
        {
            if (Distance > 1.0)
            {
                Distance -= 1.0f;
                Segment++;
                if (Looped)
                {
                    if (Segment == (ControlPoints.Length))
                        Segment = 0;
                }
            }
            return CalculatePoint(GetPoint(Segment - 1), GetPoint(Segment),
                                GetPoint(Segment + 1), GetPoint(Segment + 2),
                                Distance);
        }
    }
    public void AddPoint(int X, int Y)
    {
        Vector2 Point;
        Point.X = X;
        Point.Y = Y;
        AddPoint(Point);
    }
    public void AddPoint(Vector2 Point)
    {
        Array.Resize(ref ControlPoints, ControlPoints.Length + 1);
        ControlPoints[ControlPoints.Length - 1] = Point;
    }

    public override void DoMove(float Delta)
    {
        base.DoMove(Delta);
        Distance = Distance + MoveSpeed;
        X = Position.X;
        Y = Position.Y;
    }
}

public class NPathSprite : PathSprite
{
    public NPathSprite(Sprite Parent) : base(Parent)
    {
        Distance = 0;
        MoveSpeed = 0;
        UpdateSpeed = 0.01f;
        MaxParameter = 100;

    }
    public NURBSCurveEx Path;
    public float Distance;
    public int MaxParameter;
    public float Accel;
    public float UpdateSpeed;
    Vector2 Position
    {
        get => Path.GetXY(Distance / MaxParameter);
    }
    public void LookAt(float anAngle)
    {
        Angle = Path.GetTangent(Distance / MaxParameter) + anAngle;

    }
    public override void DoMove(float Delta)
    {
        base.DoMove(Delta);
        Distance = Distance + MoveSpeed * UpdateSpeed;
        MoveSpeed = MoveSpeed + Accel * UpdateSpeed;
        if (Distance > MaxParameter)
            Distance = MaxParameter;
        if (Distance < 0)
            Distance = 0;
        Vector2 Point = Position;
        X = Point.X;
        Y = Point.Y;
    }
}


public class BackgroundSprite : AnimatedSprite
{
    public BackgroundSprite(Sprite Parent) : base(Parent)
    {
        SpriteSheetMode = SpriteSheetMode.NoneSingle;
        Tiled = true;
        TileMode = TileMode.Vertical;
    }
    public TileMode TileMode;
    public bool Tiled;
    public bool MoveByEngine;
    private int MapW, MapH;
    private int mapWidth, mapHeight;

    public int MapWidth
    {
        get => mapWidth;
        set => SetMapSize(value, mapHeight);
    }
    public int MapHeight
    {
        get => mapHeight;
        set => SetMapSize(mapWidth, value);
    }
    public void SetMapSize(int MapWidth, int MapHeight)
    {
        MapW = Width * MapWidth;
        MapH = Height * MapHeight;
        if ((mapWidth != MapWidth) || (mapHeight != MapHeight))
        {
            if ((MapWidth <= 0) || (MapHeight <= 0))
            {
                MapWidth = 0;
                MapHeight = 0;
            }
            mapWidth = MapWidth;
            mapHeight = MapHeight;
        }
    }

    public override void Draw()
    {
        if (Visible)
        {
            if (Engine != null)
            {
                DoDraw();
                Engine.DrawCount++;
            }

            if (DrawList != null)
            {
                for (int i = 0; i < DrawList.Count; i++)
                    ((BackgroundSprite)DrawList[i]).Draw();
            }
        }
    }

    public override void DoDraw()
    {
        if (ImageNode == null)
            return;
        int ChipWidth = this.Width;
        int ChipHeight = this.Height;
        int dWidth = (Engine.VisibleWidth + ChipWidth) / ChipWidth + 1;
        int dHeight = (Engine.VisibleHeight + ChipHeight) / ChipHeight + 1;

        float _x;
        float _y;
        if (MoveByEngine)
        {
            _x = (-Engine.Camera.X - X);
            _y = (-Engine.Camera.Y - Y);
        }
        else
        {
            _x = -X;
            _y = -Y;
        }

        float OfsX = _x % ChipWidth;
        float OfsY = _y % ChipHeight;
        int StartX = (int)_x / ChipWidth;
        int StartX_ = 0;
        if (StartX < 0)
        {
            StartX_ = -StartX;
            StartX = 0;
        }
        int StartY = (int)_y / ChipHeight;
        int StartY_ = 0;
        if (StartY < 0)
        {
            StartY_ = -StartY;
            StartY = 0;
        }

        int EndX = Math.Min(StartX + 1 - StartX_, dWidth);
        int EndY = Math.Min(StartY + 1 - StartY_, dHeight);

        switch (TileMode)
        {
            case TileMode.Horizontal:
                dWidth = (Engine.VisibleWidth + ChipWidth) / ChipWidth + 1;
                dHeight = -1;
                break;
            case TileMode.Vertical:
                dWidth = -1;
                dHeight = (Engine.VisibleHeight + ChipHeight) / ChipHeight + 1;
                break;
            case TileMode.Full:
                dWidth = (Engine.VisibleWidth + ChipWidth) / ChipWidth + 1;
                dHeight = (Engine.VisibleHeight + ChipHeight) / ChipHeight + 1;
                break;
        }
        if (Tiled)
        {
            for (int cy = -1; cy <= dHeight; cy++)
            {
                for (int cx = -1; cx <= dWidth; cx++)
                {
                    switch (TileMode)
                    {
                        case TileMode.Horizontal:
                            Engine.Canvas.DrawEx(ImageLib[ImageNode],
                                                 cx * ChipWidth + OfsX - Offset.X, _y - Offset.Y,
                                                 Origin.X, Origin.Y,
                                                 ScaleX, ScaleY,
                                                 Angle,
                                                 FlipX, FlipY,
                                                 Red, Green, Blue, Alpha,
                                                 DoCenter,
                                                 BlendMode);
                            break;

                        case TileMode.Vertical:
                            Engine.Canvas.DrawEx(ImageLib[ImageNode],
                                                 _x - Offset.X, cy * ChipHeight + OfsY - Offset.Y,
                                                 Origin.X, Origin.Y,
                                                 ScaleX, ScaleY,
                                                 Angle,
                                                 FlipX, FlipY,
                                                 Red, Green, Blue, Alpha,
                                                 DoCenter,
                                                 BlendMode);
                            break;

                        case TileMode.Full:
                            Engine.Canvas.DrawEx(ImageLib[ImageNode],
                                                cx * ChipWidth + OfsX - Offset.X, cy * ChipHeight + OfsY - Offset.Y,
                                                Origin.X, Origin.Y,
                                                ScaleX, ScaleY,
                                                Angle,
                                                FlipX, FlipY,
                                                Red, Green, Blue, Alpha,
                                                DoCenter,
                                                BlendMode);

                            break;
                    }
                }
            }
        }
        else
        {
            for (int cy = StartY; cy < EndY; cy++)
            {
                for (int cx = StartX; cx < EndX; cx++)
                {
                    Engine.Canvas.DrawEx(ImageLib[ImageNode],
                                               cx * ChipWidth + OfsX - Offset.X, cy * ChipHeight + OfsY - Offset.Y,
                                               Origin.X, Origin.Y,
                                               ScaleX, ScaleY,
                                               Angle,
                                               FlipX, FlipY,
                                               Red, Green, Blue, Alpha,
                                               DoCenter,
                                               BlendMode);


                }
            }
        }


    }

}



```

`MapleNecrocer/Client/SpriteEngine/SpriteUtils.cs`:

```cs
using Microsoft.Xna.Framework;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace MonoGame.SpriteEngine;
public struct Rect
{
    public int Left, Top, Right, Bottom;
}

public static class SpriteUtils
{   
   
    public static Rect Rect(int Left,int Top,int Right,int Bottom)
    {
        Rect Rect= new Rect();
        Rect.Left= Left;
        Rect.Top= Top;
        Rect.Right= Right;
        Rect.Bottom= Bottom;
        return Rect;
    }
    public static  float PIConv256 = -40.743665431f;
    public static bool OverLapRect(Rect Rect1, Rect Rect2)
    { 
        return (Rect1.Left < Rect2.Right) && (Rect1.Right > Rect2.Left) && (Rect1.Top < Rect2.Bottom) && (Rect1.Bottom > Rect2.Top);

    }
 
    public static bool PointInRect(Vector2 Point, Rect Rect)
    {
        return (Point.X >= Rect.Left) && (Point.X <= Rect.Right) && (Point.Y >= Rect.Top) && (Point.Y <= Rect.Bottom);

    }
    public static int GetAngle256(int X, int Y)
    {
        return (int)(Math.Atan2(X, Y) * PIConv256) + 128;
    }
    public static int GetAngle256(int SrcX, int SrcY, int DestX, int DestY)
    {
        return (int)(Math.Atan2(DestX - SrcX, DestY - SrcY) * PIConv256) + 128;
    }

    public static float Angle2(Vector2 v)
    {
        return (float)Math.Atan2(v.X, v.Y);
    }
    public static float AngleDiff(float SrcAngle, float DestAngle)
    {
        float Diff = DestAngle - SrcAngle;
        if (SrcAngle > DestAngle)
        {
            if ((SrcAngle > 128) && (DestAngle < 128))
            {
                if (Diff < 128.0)
                    Diff = Diff + 256;
            }
            if (Diff > 128.0)
                Diff = Diff - 256;
        }
        else
        {
            if (Diff > 128.0)
                Diff = Diff - 256;
        }
        return Diff;
    }



}

```

`MapleNecrocer/Client/SpriteEngine/TextUtils.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace WzComparerR2.Rendering
{
    internal static class TextUtils
    {
        public static IEnumerable<char> CreateCharEnumerator(string text, int startIndex, int length)
        {
            for (int i = 0; i < length; i++)
            {
                yield return text[startIndex + i];
            }
        }

        public static IEnumerable<char> CreateCharEnumerator(StringBuilder stringBuilder, int startIndex, int length)
        {
            for (int i = 0; i < length; i++)
            {
                yield return stringBuilder[startIndex + i];
            }
        }
    }
}

```

`MapleNecrocer/Client/SpriteEngine/TextureLoader.cs`:

```cs
using System;
using System.IO;
using System.Collections.Generic;
using System.Text;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework;
namespace MonoGame.SpriteEngine;
public static class TextureLoader
{

    public static Texture2D LoadTexture(String FilePath, GraphicsDevice device)
    {
        Texture2D Texture;
        FileStream titleStream = File.OpenRead(FilePath);
        Texture = Texture2D.FromStream(device, titleStream);
        titleStream.Close();
        Microsoft.Xna.Framework.Color[] Buffer = new Microsoft.Xna.Framework.Color[Texture.Width * Texture.Height];
        Texture.GetData(Buffer);
        for (int i = 0; i < Buffer.Length; i++)
            Buffer[i] = Microsoft.Xna.Framework.Color.FromNonPremultiplied(Buffer[i].R, Buffer[i].G, Buffer[i].B, Buffer[i].A);
        Texture.SetData(Buffer);
        return Texture;
    }
    public static void LoadTextures(this Dictionary<string, Texture2D> ImageLib, string Dir, GraphicsDevice device)
    {
        DirectoryInfo Folder = new DirectoryInfo(Dir);
        foreach (FileInfo File in Folder.GetFiles())
        {
            if (File.Extension == ".png" || File.Extension == ".jpg")
            {
                  ImageLib.Add(File.Name, LoadTexture(File.FullName, device));
            
            }
        }
    }

}



```

`MapleNecrocer/Client/SpriteEngine/XnaFont.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;
using System.Drawing.Imaging;
using System.Drawing.Drawing2D;
using System.Drawing.Text;
using System.Windows.Forms;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using GDIColor = System.Drawing.Color;
using GDIRect = System.Drawing.Rectangle;
using Rectangle = Microsoft.Xna.Framework.Rectangle;

namespace WzComparerR2.Rendering
{
    public class XnaFont : IDisposable
    {
        public XnaFont(GraphicsDevice graphicsDevice, FontFamily fontFamily, float size)
            : this(graphicsDevice, new Font(fontFamily, size, GraphicsUnit.Pixel))
        {
        }

        public XnaFont(GraphicsDevice graphicsDevice, string familyName, float size)
            : this(graphicsDevice, new Font(familyName, size, GraphicsUnit.Pixel))
        {
        }

        public XnaFont(GraphicsDevice graphicsDevice, Font baseFont)
        {
            if (graphicsDevice == null || baseFont == null)
            {
                throw new ArgumentNullException();
            }
            this.baseFont = baseFont;
            this.Height = baseFont.Height;
            this.textureBuffer = new Texture2D(graphicsDevice, 2048, 2048, false, SurfaceFormat.Bgra32);
            RebuildGdiBuffer(this.baseFont.Height);
            this.charLocation = new Dictionary<char, Rectangle>();
        }

        Font baseFont;
        Texture2D textureBuffer;
        Bitmap gdiBuffer;
        Graphics g;
        Dictionary<char, Rectangle> charLocation;
        int textureSpaceX;
        int textureSpaceY;
        int textureCurLineHeight;
        int gdiBufferX;

        public Texture2D TextureBuffer
        {
            get { return textureBuffer; }
        }

        public Font BaseFont
        {
            get { return baseFont; }
        }

        public int Height { get; set; }

        public Vector2 MeasureString(string text)
        {
            return MeasureString(text, Vector2.Zero);
        }

        public Vector2 MeasureString(StringBuilder stringBuilder)
        {
            return MeasureString(stringBuilder, Vector2.Zero);
        }

        public Vector2 MeasureString(string text, Vector2 size)
        {
            var ie = TextUtils.CreateCharEnumerator(text, 0, text.Length);
            return MeasureString(ie, size);
        }

        public Vector2 MeasureString(StringBuilder stringBuilder, Vector2 size)
        {
            var ie = TextUtils.CreateCharEnumerator(stringBuilder, 0, stringBuilder.Length);
            return MeasureString(ie, size);
        }

        public Vector2 MeasureString(string text, int startIndex, int length)
        {
            return MeasureString(TextUtils.CreateCharEnumerator(text, startIndex, length), Vector2.Zero);
        }

        public Vector2 MeasureString(StringBuilder stringBuilder, int startIndex, int length)
        {
            return MeasureString(TextUtils.CreateCharEnumerator(stringBuilder, startIndex, length), Vector2.Zero);
        }

        public Vector2 MeasureString(IEnumerable<char> text, Vector2 layoutSize)
        {
            if (text == null)
                return Vector2.Zero;

            Size size = new Size();
            int maxWidth = 0;
            int lineHeight = 0;
            foreach (char c in text)
            {
                if (c == '\r')
                {
                    continue;
                }
                if (c == '\n')
                {
                    if (lineHeight <= 0)
                    {
                        //lineHeight = this.baseFont.Height;
                    }
                    size.Height += this.baseFont.Height;
                    maxWidth = Math.Max(maxWidth, size.Width);
                    size.Width = 0;
                    lineHeight = 0;
                }
                else
                {
                    Rectangle rect = TryGetRect(c);
                    if (layoutSize.X > 0 && size.Width > 0 && size.Width + rect.Width > layoutSize.X) //强制换行
                    {
                        size.Height += this.baseFont.Height;
                        maxWidth = Math.Max(maxWidth, size.Width);
                        size.Width = 0;
                        lineHeight = 0;
                    }
                    size.Width += rect.Width;
                    lineHeight = Math.Max(rect.Height, lineHeight);
                }
            }
            size.Width = Math.Max(maxWidth, size.Width);
            size.Height += lineHeight;
            if (size.Width <= 0)
                return Vector2.Zero;
            return new Vector2(size.Width, size.Height);
        }

        public Rectangle TryGetRect(char c)
        {
            Rectangle rect;
            if (!this.charLocation.TryGetValue(c, out rect))
            {
                rect = this.CreateCharBuffer(c);
                this.charLocation[c] = rect;
            }
            return rect;
        }

        private Rectangle CreateCharBuffer(char c)
        {
            string text = c.ToString();
            SizeF size;

            //size = g.MeasureString(text, this.baseFont, byte.MaxValue, StringFormat.GenericTypographic);
            size = TextRenderer.MeasureText(g, text, this.baseFont, new Size(byte.MaxValue, byte.MaxValue), TextFormatFlags.NoPadding);
            GDIRect originRect = new GDIRect(gdiBufferX, 0, (int)Math.Ceiling(size.Width), (int)Math.Ceiling(size.Height));
            if (originRect.Width == 0)
            {
                originRect.Width = (int)(this.baseFont.Size / 2);
            }
            if (gdiBuffer.Height < originRect.Height)
            {
                RebuildGdiBuffer(originRect.Height);
                originRect.X = 0; //2012-10-3
            }
            if (gdiBufferX + originRect.Width > gdiBuffer.Width)
            {
                g.Clear(GDIColor.Transparent);
                gdiBufferX = 0;
                originRect.X = 0;
            }
            g.DrawString(text, baseFont, Brushes.White, originRect.Location, StringFormat.GenericTypographic);

            //计算范围并且复制图像数据到数组
            byte[] b = new byte[4 * originRect.Width * originRect.Height];
            BitmapData data = gdiBuffer.LockBits(originRect, ImageLockMode.ReadOnly, PixelFormat.Format32bppArgb);
            for (int i = 0; i < originRect.Height; i++)
            {
                IntPtr source = IntPtr.Add(data.Scan0, data.Stride * i);
                System.Runtime.InteropServices.Marshal.Copy(source, b, i * 4 * originRect.Width, 4 * originRect.Width);
            }
            gdiBuffer.UnlockBits(data);
            gdiBufferX += originRect.Width;

            //调整xnaTexture的大小并粘贴图像
            textureBuffer.GraphicsDevice.Textures[0] = null;

            if (textureSpaceX + originRect.Width > textureBuffer.Width)
            {
                textureSpaceX = 0;
                textureSpaceY += textureCurLineHeight;
                textureCurLineHeight = 0;
            }
            textureCurLineHeight = Math.Max(textureCurLineHeight, originRect.Height);
            if (textureSpaceY + textureCurLineHeight > textureBuffer.Height)
            {
                ClearTextureBuffer();
                textureSpaceX = 0;
                textureSpaceY = 0;
                charLocation.Clear();
            }

            Rectangle rect = new Rectangle(textureSpaceX, textureSpaceY, originRect.Width, originRect.Height);

            textureBuffer.SetData(0, rect, b, 0, b.Length);
            textureSpaceX += rect.Width;
            return rect;
        }

        private void RebuildGdiBuffer(int height)
        {
            if (gdiBuffer != null)
            {
                g.Dispose();
                gdiBuffer.Dispose();
            }
            gdiBuffer = new Bitmap(textureBuffer.Width, height, PixelFormat.Format32bppArgb);
            gdiBufferX = 0;
            g = Graphics.FromImage(gdiBuffer);
            g.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAliasGridFit;
            g.SmoothingMode = SmoothingMode.HighQuality;
            // g.CompositingMode = CompositingMode.SourceCopy; 乱用这句出事故...
        }

        private void ClearTextureBuffer()
        {
            int[] ary = new int[textureBuffer.Width * textureBuffer.Height];
            textureBuffer.SetData(ary);
            ary = null;
        }

        ~XnaFont()
        {
            this.Dispose(false);
        }

        public void Dispose()
        {
            this.Dispose(true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (disposing)
            {
                this.textureBuffer.Dispose();
                this.g.Dispose();
                this.baseFont.Dispose();
                this.gdiBuffer.Dispose();
            }
        }

        public static FontFamily GdiLoadFontFile(string fontFileName)
        {
            try
            {
                PrivateFontCollection font = new PrivateFontCollection();
                font.AddFontFile(fontFileName);
                gdiFontCache.Add(font);
                return font.Families[0];
            }
            catch
            {
                return null;
            }
        }

        private static List<PrivateFontCollection> gdiFontCache = new List<PrivateFontCollection>();
    }
}

```

`MapleNecrocer/Client/TamingMob.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Spine;
using WzComparerR2.WzLib;
using Keyboard = SpriteEngine.Keyboard;
using Input = Microsoft.Xna.Framework.Input.Keys;
using System.Security.Cryptography;
namespace MapleNecrocer;

public class TamingMob : SpriteEx
{
    public TamingMob(Sprite Parent) : base(Parent)
    {
    }

    string UpPath;
    string Path, ID;
    string State;
    int Frame;
    string ImageNum;
    int FTime;
    int Delay;
    int Flip;
    Wz_Vector origin = new(0, 0);
    bool FixedImageNum;
    bool IsSaddle;
    string PartIndex;
    public static Wz_Node Entry;
    public static bool IsUse;
    public static string CharacterAction;
    public static Vector2 Navel = new(0, 0);
    public static bool IsChairTaming;
    static Dictionary<string, string> SaddleList = new();
    static Dictionary<string, string> ImageNumList = new();
    static Dictionary<string, Wz_Node> Data = new();
    public static void LoadSaddleList()
    {
        if (Wz.HasNode("Character/TamingMob"))
        {
            foreach (var Img in Wz.GetNode("Character/TamingMob").Nodes)
            {
                if (Img.Text.LeftStr(4) == "0191")
                    foreach (var Iter in Wz.GetNode("Character/TamingMob/" + Img.Text).Nodes)
                        if (Char.IsNumber(Iter.Text[0]))
                            SaddleList.AddOrReplace("0" + Iter.Text, Img.Text.LeftStr(8));
            }
        }
    }

    public static void Remove()
    {
        TamingMob.IsUse = false;
        foreach (var Iter in EngineFunc.SpriteEngine.SpriteList)
        {
            if (Iter is TamingMob)
                Iter.Dead();
        }
        EngineFunc.SpriteEngine.Dead();
        foreach (var Iter in Wz.EquipImageLib.Keys)
        {
            if (Iter.FullPathToFile2().LeftStr(23) == "Character/TamingMob/019")
            {
                Wz.EquipImageLib.Remove(Iter);
                Wz.EquipData.Remove(Iter.FullPathToFile2());
            }
        }
        TamingMob.Navel.X = 0;
        TamingMob.Navel.Y = 0;
    }

    public static void CreateSprites()
    {
        Wz.DumpData(Entry, Wz.EquipData, Wz.EquipImageLib);
        string _State;
        string _Frame;

        if (IsChairTaming)
        {
            _State = "sit";
            _Frame = "0";
        }
        else
        {
            _State = "walk1";
            _Frame = "1";
        }


        foreach (var Iter in Wz.EquipData[Entry.FullPathToFile2()].Nodes)
        {
            foreach (var Iter2 in Wz.EquipData[Iter.FullPathToFile2()].Nodes)
            {
                if (Char.IsNumber(Iter2.Text[0]))
                {
                    int Index = -1;
                    foreach (var Iter3 in Wz.EquipData[Iter2.FullPathToFile2()].Nodes)
                    {
                        if (/*Char.IsNumber(Iter3.Text[0]) && */((Iter3.Value is Wz_Png) || (Iter3.Value is Wz_Uol)))
                        {
                            Index += 1;
                            ImageNumList.AddOrReplace(Entry.FullPathToFile2() + "/" + Iter.Text + "/" + Iter2.Text + "/" + Index.ToString(), Iter3.Text);
                            if ((Iter.Text == _State) && (Iter2.Text == _Frame))
                            {
                                var TamingMob = new TamingMob(EngineFunc.SpriteEngine);
                                TamingMob.ImageLib = Wz.EquipImageLib;
                                TamingMob.IntMove = true;
                                TamingMob.Tag = 1;
                                TamingMob.PartIndex = Index.ToString();
                                TamingMob.State = Iter.Text;
                                TamingMob.Frame = Iter2.Text.ToInt();
                                TamingMob.ImageNum = Iter3.Text;
                                TamingMob.ID = Entry.Text.LeftStr(8);
                                TamingMob.UpPath = Entry.FullPathToFile2();
                                TamingMob.ImageNode = Wz.EquipData[Iter3.FullPathToFile2()];

                                if (Entry.ParentNode != null)
                                {
                                    if (Entry.ParentNode.Text.LeftStr(4) == "0191")
                                        TamingMob.IsSaddle = true;
                                }
                                if ((Iter.Text == "walk1") && (Iter2.Text == "1") && (Iter2.GetNode("0") == null))
                                    TamingMob.FixedImageNum = true;
                                if (Iter3.Text.Length >= 3)
                                    TamingMob.FixedImageNum = true;
                            }
                        }
                    }
                }
            }
        }

    }

    public static void CreateSaddle(string ID)
    {
        Data.Clear();
        if (SaddleList.ContainsKey(ID))
            Entry = Wz.GetNode("Character/TamingMob/" + SaddleList[ID] + ".img/" + ID.IntID());
        else
            return;

        //add saddle delay
        foreach (var Iter in Wz.GetNode("Character/TamingMob/" + ID + ".img").Nodes)
        {
            if (Iter.Text != "info")
            {
                foreach (var Iter2 in Iter.Nodes)
                    Data.AddOrReplace(Entry.FullPathToFile2() + "/" + Iter.Text + "/" + Iter2.Text, Iter2.GetNode("delay"));
            }
        }
        CreateSprites();
    }

    public static void CreateTaming(string ID)
    {
        Entry = Wz.GetNode("Character/TamingMob/" + ID + ".img");
        CreateSprites();
    }

    public static void Create(string ID)
    {
        TamingMob.CharacterAction = "sit";
        ImageNumList.Clear();
        CreateSaddle(ID);
        CreateTaming(ID);
    }

    public override void DoMove(float Delta)
    {
        base.DoMove(Delta);
        if (FixedImageNum)
        {
            if (ImageNumList.ContainsKey(UpPath + "/" + State + "/" + Frame + "/" + PartIndex))
                ImageNum = ImageNumList[UpPath + "/" + State + "/" + Frame + "/" + PartIndex];
        }

        if (Wz.HasDataE(UpPath + "/" + State + "/" + Frame + "/" + ImageNum))
        {
            Path = UpPath + "/" + State + "/" + Frame + "/" + ImageNum;
            ImageNode = Wz.EquipData[Path];
            Visible = true;
        }
        else
        {
            if ((State == "rope") || (State == "ladder"))
                Visible = false;
        }

        if (Wz.HasDataE(UpPath + "/" + State + "/" + Frame + "/delay"))
            Delay = Wz.EquipData[UpPath + "/" + State + "/" + Frame + "/delay"].ToInt();
        else
            Delay = 100;

        if (IsSaddle)
        {
            if (Data.ContainsKey(UpPath + "/" + State + "/" + Frame))
                Delay = Data[UpPath + "/" + State + "/" + Frame].ToInt();
        }

        FTime += 17;
        if (FTime > Delay)
        {
            Frame += 1;
            if (!Wz.HasDataE(UpPath + "/" + State + "/" + Frame))
                Frame = 0;
            FTime = 0;
        }

        if (AvatarParts.ZMap.Contains(Wz.EquipData[Path + "/z"].ToStr()))
        {
            Z = 100 + Game.Player.Z - AvatarParts.ZMap.IndexOf(Wz.EquipData[Path + "/z"].ToStr());
        }
        else
        {
            string ZName = Wz.EquipData[Path + "/z"].ToStr();
            if (ZName == "tamingMobBack")
            {
                Z = Game.Player.Z - 100;
            }
            else
            {
                if (ImageNum == "0")
                    Z = Game.Player.Z - 1;
                else
                    Z = Game.Player.Z;
                string[] List = { "01932524", "01932422", "01932454" };
                foreach (var i in List)
                {
                    if (ID == i)
                        Z = Game.Player.Z;
                }
            }
        }

        if (Game.Player.JumpState != JumpState.jsNone)
        {
            Frame = 0;
            State = "jump";
        }

        if (Game.Player.JumpState == JumpState.jsNone)
        {
            State = "stand1";
            if (Keyboard.KeyDown(Input.Left) || Keyboard.KeyDown(Input.Right))
                State = "walk1";
            if (Keyboard.KeyDown(Input.Down))
                State = "prone";
            if (State == "prone" && Keyboard.KeyUp(Input.Down))
                State = "stand1";
            if (Keyboard.KeyUp(Input.Left) || Keyboard.KeyUp(Input.Right))
                State = "stand1";
        }

        if (Game.Player.InLadder)
        {
            switch (Game.Player.LadderType)
            {
                case LadderType.Ladder:
                    if (Keyboard.KeyDown(Input.Up) || Keyboard.KeyDown(Input.Down))
                    {
                        State = "ladder";
                    }
                    else
                    {
                        State = "ladder";
                        Frame = 0;
                    }
                    break;

                case LadderType.Rope:
                    if (Keyboard.KeyDown(Input.Up) || Keyboard.KeyDown(Input.Down))
                    {
                        State = "rope";
                    }
                    else
                    {
                        State = "rope";
                        Frame = 0;
                    }
                    break;
            }
        }

        if (Wz.HasDataE(UpPath + "/characterAction"))
        {
            if (Wz.HasDataE(UpPath + "/characterAction/" + State))
                CharacterAction = Wz.EquipData[UpPath + "/characterAction/" + State].ToStr();
            else if (Wz.HasDataE(UpPath + "/characterAction/walk1"))
                CharacterAction = Wz.EquipData[UpPath + "/characterAction/walk1"].ToStr();
        }
        else
        {
            CharacterAction = "sit";
        }
        if (IsChairTaming)
            State = "sit";

        FlipX = Game.Player.FlipX;
        if (ImageNode.GetNode("origin") != null)
            origin = ImageNode.GetNode("origin").ToVector();

        Y = Game.Player.Y;
        switch (FlipX)
        {
            case true:
                X = Game.Player.X + 1;
                Offset.X = origin.X - ImageWidth;
                Flip = -1;
                break;
            case false:
                X = Game.Player.X;
                Offset.X = -origin.X;
                Flip = 1;
                break;
        }
        Offset.Y = -origin.Y;

        if (Wz.HasDataE(Path + "/map/navel"))
        {
            Vector2 _Offset;
            if (CharacterAction == "prone")
            {
                if (FlipX)
                    _Offset.X = -3;
                else
                    _Offset.X = 3;
                _Offset.Y = 3;
            }
            else if (CharacterAction == "fly")
            {
                if (FlipX)
                    _Offset.X = -3;
                else
                    _Offset.X = 3;
                _Offset.Y = 27;
            }
            else
            {
                _Offset.X = 0;
                _Offset.Y = 17;
            }

            if (FlipX)
                Navel.X = -Wz.EquipData[Path + "/map/navel"].ToVector().X * Flip - _Offset.X;
            else
                Navel.X = -Wz.EquipData[Path + "/map/navel"].ToVector().X * Flip - 4 - _Offset.X;
            Navel.Y = -Wz.EquipData[Path + "/map/navel"].ToVector().Y - _Offset.Y;
        }

        string[] FixedIDs = { "01932377", "01902002", "1902002", "1902007", "01902007", "01932123", "01932181", "01932116", "01932081", "01992000", "01932418", "01932461", "01932507", "01932504", "01932505" };
        foreach (var I in FixedIDs)
        {
            if (ID == I)
            {
                switch (FlipX)
                {
                    case true:
                        Offset.X = origin.X - ImageWidth + Navel.X;
                        break;
                    case false:
                        Offset.X = -origin.X + Navel.X;
                        break;
                }
                Offset.Y = -origin.Y + Navel.Y - 50;
                Navel.X = 0;
                Navel.Y = 50;
            }
        }

    }

}

```

`MapleNecrocer/Client/ToolTip.cs`:

```cs
using Microsoft.Xna.Framework.Graphics;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;
using WzComparerR2.Animation;

namespace MapleNecrocer;

public class ObjToolTip : SpriteEx
{
    public ObjToolTip(Sprite Parent) : base(Parent)
    {
    }
    public string Text;
    RenderTarget2D RenderTarget;
    public void Init(string AText)
    {
        if (Wz.HasNode("UI/UIToolTip.img"))
        {
            if (!Wz.HasData("UI/UIToolTip.img/Item/Frame2/n"))
            Wz.DumpData(Wz.GetNode("UI/UIToolTip.img/Item/Frame2"), Wz.Data, Wz.ImageLib);
        }
        Text = AText;
        Engine.Canvas.DrawTarget(ref RenderTarget, 250, 80, () => RenderTargetFunc());
    }

    public override void DoDraw()
    {
        Engine.Canvas.Draw(RenderTarget, (int)X - (int)Engine.Camera.X, (int)Y - (int)Engine.Camera.Y);
    }
    int Width => Map.MeasureStringX(Map.ToolTipFont, Text);
    public void RenderTargetFunc()
    {
        if (Wz.HasNode("UI/UIToolTip.img"))
        {
            var nw = Wz.GetImgNodeA("UI/UIToolTip.img/Item/Frame2/nw");
            Engine.Canvas.Draw(Wz.ImageLib[nw], 15 - nw.GetVector("origin").X, 15 - nw.GetVector("origin").Y);

            var ne = Wz.GetImgNodeA("UI/UIToolTip.img/Item/Frame2/ne");
            Engine.Canvas.Draw(Wz.ImageLib[ne], 15 + Width - ne.GetVector("origin").X, 15 - ne.GetVector("origin").Y);

            var n = Wz.GetImgNodeA("UI/UIToolTip.img/Item/Frame2/n");
            var s = Wz.GetImgNodeA("UI/UIToolTip.img/Item/Frame2/s");
            for (int i = 0; i < Width; i++)
            {
                Engine.Canvas.Draw(Wz.ImageLib[n], 15 - n.GetVector("origin").X + i, 15 - n.GetVector("origin").Y);
                Engine.Canvas.Draw(Wz.ImageLib[s], 15 - n.GetVector("origin").X + i, 15 - s.GetVector("origin").Y);
            }

            var sw = Wz.GetImgNodeA("UI/UIToolTip.img/Item/Frame2/sw");
            Engine.Canvas.Draw(Wz.ImageLib[sw], 15 - sw.GetVector("origin").X, 15 - sw.GetVector("origin").Y);

            var se = Wz.GetImgNodeA("UI/UIToolTip.img/Item/Frame2/se");
            Engine.Canvas.Draw(Wz.ImageLib[se], 15 + Width - se.GetVector("origin").X, 15 - se.GetVector("origin").Y);
            Engine.Canvas.DrawString(Map.ToolTipFont, Text, 15, 8, Microsoft.Xna.Framework.Color.White);
        }
        else
        {
            Engine.Canvas.FillRoundRect(15,5,Width+10,20,new Microsoft.Xna.Framework.Color(0,50,150,180));
            Engine.Canvas.DrawString(Map.ToolTipFont, Text, 20, 8, Microsoft.Xna.Framework.Color.White);
        }

    }

    public static void Create()
    {
        if (!Map.Img.HasNode("ToolTip"))
            return;
        foreach (var Iter in Map.Img.GetNodes("ToolTip"))
        {
            if (Iter.Text.Length > 4)
                continue;
            var ToolTip = new ObjToolTip(EngineFunc.SpriteEngine);

            string Title = Wz.GetStr("String/ToolTipHelp.img/Mapobject/" + Map.Img.ImgID().ToInt() + "/" + Iter.Text + "/Title");
            ToolTip.Init(Title);
            int Mid = (Iter.GetInt("x1") + Iter.GetInt("x2")) / 2-20;

            ToolTip.X = Mid - (ToolTip.Width / 2);
            ToolTip.Y = Iter.GetInt("y1");
            ToolTip.Z = 10000000;
        }
    }

}




```

`MapleNecrocer/Client/UI/Framework/AlignmentHelper.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Xna.Framework;

namespace MonoGame.UI.Forms
{
    class AlignmentHelper
    {
        public static Vector2 Align(Vector2 container, Vector2 content, ContentAlignment alignment, bool round = true)
        {
            var ret = Vector2.Zero;

            switch (alignment)
            {
                case ContentAlignment.BottomCenter:
                    ret = new Vector2(container.X / 2 - content.X / 2, container.Y - content.Y);
                    break;
                case ContentAlignment.BottomRight:
                    ret = new Vector2(container.X - content.X, container.Y - content.Y);
                    break;
                case ContentAlignment.BottomLeft:
                    ret = new Vector2(0, container.Y - content.Y);
                    break;
                case ContentAlignment.MiddleCenter:
                    ret = new Vector2(container.X / 2 - content.X / 2, container.Y / 2 - content.Y / 2);
                    break;
                case ContentAlignment.MiddleLeft:
                    ret = new Vector2(0, container.Y / 2 - content.Y / 2);
                    break;
                case ContentAlignment.MiddleRight:
                    ret = new Vector2(container.X - content.X, container.Y / 2 - content.Y / 2);
                    break;
                case ContentAlignment.TopCenter:
                    ret = new Vector2(container.X / 2 - content.X / 2, 0);
                    break;
                case ContentAlignment.TopLeft:
                    ret = new Vector2(0, 0);
                    break;
                case ContentAlignment.TopRight:
                    ret = new Vector2(container.X - content.X, 0);
                    break;
            }

            if(round)
                ret = new Vector2((float)Math.Round(ret.X), (float)Math.Round(ret.Y));

            return ret;
        }
    }
}

```

`MapleNecrocer/Client/UI/Framework/Button.cs`:

```cs
using GameUI;
using MapleNecrocer;
using Microsoft.Xna.Framework;
using Color = Microsoft.Xna.Framework.Color;
using Microsoft.Xna.Framework.Graphics;
using WzComparerR2.WzLib;


namespace MonoGame.UI.Forms
{
    public class UIButton : Control
    {
        public enum MouseAction { Enter, Leave, Down, Up };
        public string Text { get; set; }
        public ContentAlignment TextAlign { get; set; }
        public Color TextColor { get; set; }
        public string BtnLeftTexture { get; set; }
        public string BtnRightTexture { get; set; }
        public string BtnMiddleTexture { get; set; }
        public MouseAction mouseAction;
        public UIButton()
        {
            BackgroundColor = Color.Aquamarine;
            TextColor = Color.White;
            TextAlign = ContentAlignment.MiddleCenter;
            mouseAction = MouseAction.Leave;
            this.MouseEnter += (s, e) => { mouseAction = MouseAction.Enter; };
            this.MouseLeave += (s, e) => { mouseAction = MouseAction.Leave; };
            this.MouseDown += (s, e) => { mouseAction = MouseAction.Down; };
            this.MouseUp += (s, e) => { mouseAction = MouseAction.Up; };
        }

        internal override void DoDraw(Vector2 offset)
        {
            switch (mouseAction)
            {
                case MouseAction.Enter:
                    ImagePath = UIPath + "/mouseOver/0";
                    break;
                case MouseAction.Leave:
                    ImagePath = UIPath + "/normal/0";
                    break;
                case MouseAction.Down:
                    ImagePath = UIPath + "/pressed/0";
                    break;
                case MouseAction.Up:
                    if (ImagePath == UIPath + "/pressed/0")
                        ImagePath = UIPath + "/mouseOver/0";
                    break;
            }
            SpriteBatch.Draw(Wz.UIImageLib[Wz.UIData[ImagePath]], Location + offset, Color.White);
        }

        internal override void LoadContent(DrawHelper helper)
        {
            base.LoadContent(helper);

            string[] assets =
            {
                BtnLeftTexture, BtnMiddleTexture, BtnRightTexture
            };

            foreach (var asset in assets)
            {
                if (!string.IsNullOrEmpty(asset))
                    helper.LoadTexture(asset);
            }
        }
    }
}

```

`MapleNecrocer/Client/UI/Framework/ContentAlignment.cs`:

```cs
namespace MonoGame.UI.Forms
{
    public enum ContentAlignment
    {
        TopLeft = 1,
        TopCenter = 2,
        TopRight = 4,
        MiddleLeft = 16,
        MiddleCenter = 32,
        MiddleRight = 64,
        BottomLeft = 256,
        BottomCenter = 512,
        BottomRight = 1024,
    }
}

```

`MapleNecrocer/Client/UI/Framework/Control.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Xna.Framework;
//using MonoGame.UI.Forms.Effects;
using MonoGame.SpriteEngine;
using WzComparerR2.WzLib;
using WzComparerR2.Rendering;

namespace MonoGame.UI.Forms
{
    public abstract class Control
    {
        public bool Enabled { get; set; }
        public bool IsVisible { get; set; }
        public SpriteBatchEx SpriteBatch => EngineFunc.SpriteEngine.Canvas.SpriteBatch;
        public string UIPath;
        public string ImagePath;

        public Vector2 Location { get; set; }
        public Vector2 Size { get; set; }
        public Microsoft.Xna.Framework.Color BackgroundColor { get; set; }
        public string FontName { get; set; }
        public Microsoft.Xna.Framework.Rectangle HitBox => new Microsoft.Xna.Framework.Rectangle((int)Location.X, (int)Location.Y, (int)Size.X, (int)Size.Y);
        public int ZIndex { get; set; }

        //public Effect HoverEffect { get; set; }

        public event EventHandler Clicked;
        public event EventHandler MouseDown;
        public event EventHandler MouseUp;
        public event EventHandler MouseLeave;
        public event EventHandler MouseEnter;

        protected bool IsPressed;
        protected bool IsHovering;
        protected float Zoom = 1.0f;

        private bool _wasHovering;

        protected Control()
        {
            FontName = "defaultFont";
            IsVisible = true;
        }

        public virtual bool Contains(Microsoft.Xna.Framework.Point point)
        {
            return HitBox.Contains(point);
        }

        internal abstract void DoDraw(Vector2 offset);

        internal virtual void Draw()
        {
            if (IsVisible)
            {
                DoDraw(Vector2.Zero);
            }
            else
            {
                ZIndex = -100000;
            }
          
        }

        internal virtual void Update()
        {
          
            Zoom = 1.0f;

            //  if (IsHovering)
            {
                // if(!_wasHovering)
                //   HoverEffect.Reset();
                // HoverEffect.Update(gameTime);
                //Zoom = HoverEffect.Zoom;
            }

            //  _wasHovering = IsHovering;
        }

        internal virtual void LoadContent(DrawHelper helper)
        {
            if (!string.IsNullOrEmpty(FontName))
                helper.LoadFont(FontName);
        }

        internal virtual void OnMouseDown()
        {
            IsPressed = true;
            MouseDown?.Invoke(this, new EventArgs());
        }

        internal virtual void OnMouseUp()
        {
            IsPressed = false;
            MouseUp?.Invoke(this, new EventArgs());
        }

        internal virtual void OnMouseEnter()
        {
            IsHovering = true;
            MouseEnter?.Invoke(this, new EventArgs());
        }

        internal virtual void OnMouseLeave()
        {
            IsHovering = false;
            MouseLeave?.Invoke(this, new EventArgs());
        }

        internal virtual void OnClicked()
        {
            Clicked?.Invoke(this, new EventArgs());
        }
    }
}

```

`MapleNecrocer/Client/UI/Framework/ControlManager.cs`:

```cs
using System.Collections.Generic;
using System.Linq;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using ButtonState = Microsoft.Xna.Framework.Input.ButtonState;
using MouseExt;

namespace MonoGame.UI.Forms
{
    public abstract class ControlManager
    {
        private SpriteBatch _spriteBatch;
        private DrawHelper _drawHelper;
        private Control _selectedControl;
        private Control _lastHoveredControl;
        private Vector2 _dragPositionOffset;
        private bool _isDragging;
        private MouseState _prevMouseState;
        private KeyboardState _prevKeyboardState;
        public List<Control> Controls { get; private set; }
        public ControlManager()
        {
            Controls = new List<Control>();
        }

        public void Update()
        {
           
            var mouseState = MouseEx.GetState();
            var hoverControl = FindControlAt(mouseState.Position, Controls);
            if (_lastHoveredControl != hoverControl)
            {
                _lastHoveredControl?.OnMouseLeave();
                hoverControl?.OnMouseEnter();
            }

            _lastHoveredControl = hoverControl;

            if (mouseState.LeftButton == ButtonState.Pressed && _prevMouseState.LeftButton == ButtonState.Released)
            {
                if (_lastHoveredControl != null)
                {
                    _selectedControl = _lastHoveredControl;
                    if (!_selectedControl.IsVisible) 
                        return;
                    _selectedControl.OnMouseDown();

                    if (_selectedControl is UIForm)
                    {
                        var form = _selectedControl as UIForm;
                        _selectedControl.ZIndex = Controls.Last().ZIndex + 1;
                        if (form.IsMovable)
                        {
                            _dragPositionOffset = mouseState.Position.ToVector2() - _selectedControl.Location;
                            _isDragging = true;
                        }
                    }
                }
            }

            if (mouseState.LeftButton == ButtonState.Released && _prevMouseState.LeftButton == ButtonState.Pressed)
            {
                _isDragging = false;
                if (_selectedControl != null)
                {
                    _selectedControl.OnMouseUp();

                    if (_selectedControl == FindControlAt(mouseState.Position, Controls))
                        _selectedControl.OnClicked();
                }
            }

            if (_isDragging)
            {
                _selectedControl.Location = mouseState.Position.ToVector2() - _dragPositionOffset;
            }

            Controls = Controls.OrderBy(c => c.ZIndex).ToList();
            _prevMouseState = mouseState;

            foreach (var control in Controls)
            { 
            
                control.Update();
            }
        }

        public void Draw()
        {
            EngineFunc.SpriteEngine.Canvas.SpriteBatch.Begin();
            foreach (var control in Controls)
            {
                control.Draw();
            }
            EngineFunc.SpriteEngine.Canvas.SpriteBatch.End();
        }

        private Control FindControlAt(Microsoft.Xna.Framework.Point position, IEnumerable<Control> controls)
        {
            var control = controls.LastOrDefault(c => c.Contains(position));
            if (control is IControls)
                return ((IControls)control).FindControlAt(position);
            else
                return control;

        }
    }
}
```

`MapleNecrocer/Client/UI/Framework/DrawHelper.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using Color=Microsoft.Xna.Framework.Color;
using Rectangle=Microsoft.Xna.Framework.Rectangle; 

namespace MonoGame.UI.Forms
{
    internal class DrawHelper
    {
        private readonly SpriteBatch _spriteBatch;
        private readonly ContentManager _manager;
        private Dictionary<string, Texture2D> _textureCache = new Dictionary<string, Texture2D>();
        private Dictionary<string, SpriteFont> _fontCache = new Dictionary<string, SpriteFont>();

        private Texture2D whiteTexture;
        private Texture2D circleTexture;

        public DrawHelper(SpriteBatch spriteBatch, ContentManager manager, GraphicsDevice device)
        {
            _spriteBatch = spriteBatch;
            _manager = manager;

            var size = 100;
            whiteTexture = new Texture2D(device, size, size);
            Color[] data = new Color[size * size];

            for (int i = 0; i < size*size; i++)
                data[i] = Color.White;

            whiteTexture.SetData(data);

            // create circle texture

            size = 512;
            circleTexture = new Texture2D(device, size, size);

            data = new Color[size * size];
            DrawFilledCircle(size / 2, size/2, size/2 - 1, Color.White, size, size, data);
            circleTexture.SetData<Color>(data);
        }

        public void ReloadResources(IEnumerable<Control> controls)
        {
            foreach (var control in controls)
            {
                control.LoadContent(this);
            }
        }

        #region Public Draw Methods

        public void DrawCircle(Vector2 center, float radius, Color color)
        {
            float scale = radius / 256.0f;
            _spriteBatch.Draw(circleTexture, center, null, color, 0f, new Vector2(256, 256), scale, SpriteEffects.None, 0f);
        }

        public void DrawLine(Vector2 pos1, Vector2 pos2, Color color, int width = 1)
        {
            Vector2 diff = (pos1 - pos2);
            float length = diff.Length();
            float angle = (float)Math.Atan2(diff.Y, diff.X) + MathHelper.Pi;

            _spriteBatch.Draw(whiteTexture, new Rectangle((int)(pos1.X), (int)(pos1.Y), (int)length, width),
                null, color, angle, new Vector2(0, whiteTexture.Width / 2.0f), SpriteEffects.None, 0f);
        }

        public void DrawString(Control control, Vector2 position, string text, Color color, float zoom = 1.0f)
        {
            var font = LoadFont(control.FontName);
            var size = font.MeasureString(text);
            _spriteBatch.DrawString(font, text, position, color, 0f, Vector2.Zero, zoom, SpriteEffects.None, 0);
        }

        public void DrawRectangle(Rectangle rectangle, Color color)
        {
            _spriteBatch.Draw(whiteTexture, rectangle, null, color, 0f, Vector2.Zero, SpriteEffects.None, 0);
        }

        public Vector2 DrawTextureWithOffset(Vector2 position, string asset, AlignOffset align = AlignOffset.TopLeft)
        {
            return DrawTextureWithOffset(position, asset, Color.White, align);
        }

        public Vector2 DrawTextureWithOffset(Vector2 position, string asset, Color blend, AlignOffset align = AlignOffset.TopLeft)
        {
            var texture = LoadTexture(asset);
            var offset = Vector2.Zero;

            switch (align)
            {
                case AlignOffset.TopRight: offset = new Vector2(-texture.Width, 0); break;
                case AlignOffset.BottomLeft: offset = new Vector2(0, -texture.Height); break;
                case AlignOffset.BottomRight: offset = new Vector2(-texture.Width, -texture.Height); break;
            }

            _spriteBatch.Draw(texture, position + offset, blend);
            return new Vector2(texture.Width, texture.Height);
        }

        public void DrawTextureRepeat(Vector2 start, Vector2 stop, string asset)
        {
            DrawTextureRepeat(start, stop, asset, Color.White);
        }

        public void DrawTextureRepeat(Vector2 start, Vector2 stop, string asset, Color blend)
        {
            var texture = LoadTexture(asset);

            int width = (int) (stop.X - start.X);
            int height = (int) (stop.Y - start.Y);

            while (height > 0)
            {
                var startX = start;
                while (width > 0)
                {
                    var srcRect = new Rectangle(0, 0,
                        width >= texture.Width ? texture.Width : width,
                        height >= texture.Height ? texture.Height : height);
                    _spriteBatch.Draw(texture, start, srcRect, blend);
                    width -= texture.Width;
                    start += new Vector2(texture.Width, 0);
                }
                start = startX;
                width = (int)(stop.X - start.X);

                height -= texture.Height;
                start += new Vector2(0, texture.Height);
            }
        }

        #endregion

        public Vector2 MeasureString(string asset, string text)
        {
            var font = LoadFont(asset);
            return font.MeasureString(text);
        }

        public SpriteFont LoadFont(string asset)
        {
            if (_fontCache.ContainsKey(asset))
                return _fontCache[asset];

            var font = _manager.Load<SpriteFont>(asset);
            _fontCache.Add(asset, font);
            return font;
        }

        public Texture2D LoadTexture(string asset)
        {
            if (_textureCache.ContainsKey(asset))
                return _textureCache[asset];

            var texture = _manager.Load<Texture2D>(asset);
            _textureCache.Add(asset, texture);
            return texture;
        }

        internal enum AlignOffset
        {
            TopLeft,
            TopRight,
            BottomLeft,
            BottomRight,
            Center
        }

        #region Private Methods

        private void DrawFilledCircle(int x, int y, int radius, Color color, int width, int height, Color[] data)
        {
            int sx = -radius;
            int sy = 0;
            int error = 2 - 2 * radius;

            while (sx <= 0)
            {
                for (int i = sy; i >= 0; i--)
                {
                    data[(x - sx) + (y - i) * width] = color;
                    data[(x - sx) + (y + i) * width] = color;
                    data[(x + sx) + (y + i) * width] = color;
                    data[(x + sx) + (y - i) * width] = color;
                }

                int r = error;
                if (r <= sy)
                    error += ++sy * 2 + 1;
                if (r > sx || error > y)
                    error += ++sx * 2 + 1;
            }
        }

        #endregion
    }
}

```

`MapleNecrocer/Client/UI/Framework/Extensions.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Xna.Framework;
using Color = Microsoft.Xna.Framework.Color;

namespace MonoGame.UI.Forms
{
    public static class Extensions
    {
        public static Color Blend(this Color color, Color blendColor)
        {
            return new Color(
                (byte)(color.R * blendColor.R / 255),
                (byte)(color.G * blendColor.G / 255),
                (byte)(color.B * blendColor.B / 255),
                (byte)(color.A * blendColor.A / 255));
        }
    }
}

```

`MapleNecrocer/Client/UI/Framework/Form.cs`:

```cs
using System;
using System.Collections.Generic;
using Microsoft.Xna.Framework;
using Point = Microsoft.Xna.Framework.Point;
using Color = Microsoft.Xna.Framework.Color;
using MapleNecrocer;


namespace MonoGame.UI.Forms
{
    public class UIForm : Control, IControls
    {
        public bool IsMovable { get; set; }
        public string Title { get; set; }
        public List<Control> Controls { get; private set; }

        public UIForm()
        {
            BackgroundColor = Color.Gray;
            Controls = new List<Control>();
            IsMovable=true;
        }
        internal override void DoDraw(Vector2 offset)
        {
            if (!IsVisible)
                return;
            ImagePath = UIPath;
            SpriteBatch.Draw(Wz.UIImageLib[Wz.UIData[ImagePath]], new Vector2(Location.X, Location.Y), Color.White);
            foreach (var control in Controls)
            {
                if (control.IsVisible)
                    control.DoDraw(Location);
            }
        }

        internal override void Update()
        {
            foreach (var control in Controls)
            {
                control.Update();
            }
        }

        Control IControls.FindControlAt(Point position)
        {
            var point = position - Location.ToPoint();
            var control = Controls.LastOrDefault(c => c.Contains(point));
            return control ?? this;
        }

        public void SetVisible()
        {
            IsVisible = !IsVisible;
            if (IsVisible)
                ZIndex = GameUI.UI.ControlManager.Controls.Last().ZIndex + 1;
        }
       
    }
}

```

`MapleNecrocer/Client/UI/Framework/IControls.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Xna.Framework;

namespace MonoGame.UI.Forms
{
    internal interface IControls
    {
        List<Control> Controls { get; }

        Control FindControlAt(Microsoft.Xna.Framework.Point position);
    }
}

```

`MapleNecrocer/Client/UI/Framework/Label.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Color = Microsoft.Xna.Framework.Color;
using Rectangle = Microsoft.Xna.Framework.Rectangle;

namespace MonoGame.UI.Forms
{
    public class Label : Control
    {
        public string Text { get; set; }
        public Color TextColor { get; set; }

        public Label()
        {
            BackgroundColor = Color.Transparent;
            TextColor = Color.Black;
        }

        internal override void DoDraw(Vector2 offset)
        {
           // var txtSize = helper.MeasureString(FontName, Text);
           // var rectangle = new Rectangle((int)Location.X, (int)Location.Y, (int)txtSize.X, (int)txtSize.Y);
           // rectangle.Offset(offset);

           // if(BackgroundColor != Color.Transparent)
              //  helper.DrawRectangle(rectangle, BackgroundColor);
          // helper.DrawString(this, Location + offset, Text, TextColor);
        }
    }
}

```

`MapleNecrocer/Client/UI/Framework/TextArea.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Xna.Framework;
using Color = Microsoft.Xna.Framework.Color;
using Rectangle = Microsoft.Xna.Framework.Rectangle;

namespace MonoGame.UI.Forms
{
    public class TextArea : Control
    {
        public string Text { get; set; }
        public Color TextColor { get; set; }
        public float LineSpacing { get; set; }

        public TextArea()
        {
            BackgroundColor = Color.Transparent;
            TextColor = Color.Black;
            LineSpacing = 0f;
        }

        internal override void DoDraw(Vector2 offset)
        {
            string[] lines = Text.Split(new[] { Environment.NewLine }, StringSplitOptions.None);

            float maxWidth = 0;
            float height = 0;

            foreach (var line in lines)
            {
              //  var txtSize = helper.MeasureString(FontName, line);
             //   maxWidth = txtSize.X > maxWidth ? txtSize.X : maxWidth;
              //  height += txtSize.Y;
            }

            var rectangle = new Rectangle((int)Location.X, (int)Location.Y, (int)maxWidth, (int)height);
          //  rectangle.Offset(offset);
          /*
            if (BackgroundColor != Color.Transparent)
                helper.DrawRectangle(rectangle, BackgroundColor);

            height = 0;
            foreach (var line in lines)
            {
                var txtSize = helper.MeasureString(FontName, line);
                helper.DrawString(this, Location + offset + new Vector2(0, height), line, TextColor);
                height += txtSize.Y + LineSpacing;
            }

            */
        }
    }
}

```

`MapleNecrocer/Client/UI/GameCursor.cs`:

```cs
using WzComparerR2.WzLib;
using MapleNecrocer;
using MouseExt;
using Microsoft.Xna.Framework.Input;
using System.Security.Cryptography.X509Certificates;
using ButtonState=Microsoft.Xna.Framework.Input.ButtonState;
namespace GameUI;

public class GameCursor
{
    public static bool IsDataWz;
    static int Frame;
    static string CursorNumber="0";
    static int FTime;
    static Wz_Node ImageNode;
    static bool HasAnim;
    //static Wz_Node ImagEntry;
    public static void LoadRes(string CursorNum)
    {
        Wz.DumpData(Wz.GetNode("UI/Basic.img/Cursor/" + CursorNum), Wz.UIData, Wz.UIImageLib);
    }

    public static void Draw()
    {
        var MouseState = MouseEx.GetState();
        if(MouseState.LeftButton== ButtonState.Pressed)
        { 
           if(!IsDataWz)
            Change("12");
        }
        
        if (MouseState.LeftButton == ButtonState.Released)
        { 
            Change("0");
        }

        if (Wz.UIData.ContainsKey("UI/Basic.img/Cursor/" + CursorNumber + "/1"))
        {
            ImageNode = Wz.UIData["UI/Basic.img/Cursor/" + CursorNumber + '/' + Frame];
            int Delay = ImageNode.GetInt("delay", 100);
            FTime += 17;
            if (FTime > Delay)
            {
                Frame += 1;
                if (!Wz.UIData.ContainsKey("UI/Basic.img/Cursor/" + CursorNumber + '/' + Frame))
                    Frame = 0;
                FTime = 0;
            }
            Wz_Vector Origin = ImageNode.GetVector("origin");
            int OffsetX = -Origin.X + 3;
            int OffsetY = -Origin.Y + 3;
            EngineFunc.Canvas.Draw(Wz.UIImageLib[ImageNode], MouseState.X + OffsetX, MouseState.Y + OffsetY);
        }
        else
        {
            ImageNode = Wz.UIData["UI/Basic.img/Cursor/" + CursorNumber + "/0"];
            Wz_Vector Origin = ImageNode.GetVector("origin");
            int OffsetX = -Origin.X + 3;
            int OffsetY = -Origin.Y + 3;
            EngineFunc.Canvas.Draw(Wz.UIImageLib[ImageNode], MouseState.X + OffsetX, MouseState.Y + OffsetY);
        }
    }

    public static void Change(string Number)
    {
        if (Frame != 0)
            Frame = 0;
        CursorNumber = Number;
    }

}

```

`MapleNecrocer/Client/UI/MiniMap.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Xna.Framework.Graphics;
using MonoGame.UI.Forms;
using MapleNecrocer;
using WzComparerR2.WzLib;
using Color = Microsoft.Xna.Framework.Color;
using Vector2 = Microsoft.Xna.Framework.Vector2;
namespace GameUI;
public class MiniMap : UIForm
{
    public static int Version;
    public static bool HasMiniMap;
    int PWidth;
    int cx, cy;
    int OffX, OffY;
    int AddHeight, AddWidth;
    bool HasMark;
    RenderTarget2D RenderTarget;
    Wz_Node PlayerMark;
    void DrawVersion1()
    {
        Wz_Node UIEntry = Wz.GetNode("UI/UIWindow.img/MiniMap/MaxMap");
        Wz.DumpData(UIEntry, Wz.UIData, Wz.UIImageLib);
        int PicWidth, PicHeight;
        var Canvas = EngineFunc.Canvas;
        if (Map.Img.HasNode("miniMap"))
        {
            HasMiniMap = true;
            cx = Map.Img.GetInt("miniMap/centerX");
            cy = Map.Img.GetInt("miniMap/centerY");
            var MiniMapNode = Map.Img.GetNode("miniMap");
            Wz.DumpData(MiniMapNode, Wz.UIData, Wz.UIImageLib);
            var MiniMapPng = Map.Img.GetBmp("miniMap/canvas");

            PicHeight = MiniMapPng.Height;
            PicWidth = PWidth;
            OffX = (PicWidth - MiniMapPng.Width) / 2;
            var Left = ((PicWidth + 13) - MiniMapPng.Width) / 2;
            Canvas.FillRect(7, 72, Left, PicHeight, new Color(128, 128, 128, 128));
            Canvas.FillRect(OffX + 13 + MiniMapPng.Width, 72, Left, PicHeight, new Color(128, 128, 128, 128));
            Canvas.FillRect(OffX + 13, 72, MiniMapPng.Width, PicHeight, new Color(0, 0, 0, 128));
            Canvas.Draw(Wz.UIImageLib[MiniMapNode.GetNode("canvas")], 9 + OffX + 3, 72);
        }
        else
        {
            cx = 0;
            cy = 0;
            OffX = 0;
            OffY = 0;
            PicWidth = 150;
            PicHeight = 100;
            Canvas.FillRect(9, 62, PicWidth, PicHeight, new Color(0, 0, 0, 180));
        }

        for (int X = 0; X <= PicWidth + 10; X++)
        {
            Canvas.Draw(Wz.UIImageLib[UIEntry.GetNode("n")], 4 + X + 3, 0);
            Canvas.Draw(Wz.UIImageLib[UIEntry.GetNode("s")], 4 + X + 3, PicHeight + 62 + 10);
        }

        for (int Y = 0; Y <= PicHeight - 1; Y++)
        {
            Canvas.Draw(Wz.UIImageLib[UIEntry.GetNode("w")], 1, 72 + Y);
            Canvas.Draw(Wz.UIImageLib[UIEntry.GetNode("e")], PicWidth + 18, 72 + Y);
        }
        Canvas.Draw(Wz.UIImageLib[UIEntry.GetNode("nw")], 1, 0); //left top
        Canvas.Draw(Wz.UIImageLib[UIEntry.GetNode("ne")], PicWidth + 18, 0); //right top
        Canvas.Draw(Wz.UIImageLib[UIEntry.GetNode("sw")], 1, PicHeight + 72); // right bottom
        Canvas.Draw(Wz.UIImageLib[UIEntry.GetNode("se")], PicWidth + 18, PicHeight + 72); // left botton

        if (Wz.HasNode("Map/MapHelper.img/minimap"))
            HasMark = true;

        if (HasMark)
        {
            Wz.DumpData(Wz.GetNode("Map/MapHelper.img/minimap"), Wz.UIData, Wz.UIImageLib);
            var NpcMark = Wz.GetNode("Map/MapHelper.img/minimap/npc");
            foreach (var Iter in Map.Img.GetNodes("life"))
            {
                if (Iter.GetStr("type") == "n" && Iter.GetInt("hide") != 1)
                    Canvas.Draw(Wz.UIImageLib[NpcMark], ((Iter.GetInt("x") + cx) / 16)
                      + OffX + 12, ((Iter.GetInt("y") + cy) / 16) + 65);
            }
            var PortalMark = Wz.GetNode("Map/MapHelper.img/minimap/portal");
            foreach (var Iter in Map.Img.GetNodes("portal"))
            {
                if (Iter.GetInt("pt") == 2 || Iter.GetInt("pt") == 7)
                    Canvas.Draw(Wz.UIImageLib[PortalMark], ((Iter.GetInt("x") + cx) /
                      16) + OffX + 10, ((Iter.GetInt("y") + cy) / 16) + 63);
            }
            PlayerMark = Wz.GetNode("Map/MapHelper.img/minimap/user");
        }
        else
        {
            foreach (var Iter in Map.Img.GetNodes("portal"))
            {
                if (Iter.GetInt("pt") == 2 || (Iter.GetInt("pt") == 7))
                {
                    var X = ((Iter.GetInt("x") + cx) / 16) + OffX + 10;
                    var Y = ((Iter.GetInt("y") + cy) / 16) + 67;
                    Canvas.FillRect(X, Y, 5, 5, new Color(132, 216, 243, 255));
                }
            }
        }

        var MapMarkName = Map.Img.GetStr("info/mapMark");
        if (MapMarkName != "None")
        {
            var MapMarkPic = Wz.GetNode("Map/MapHelper.img/mark/" + MapMarkName);
            Wz.DumpData(MapMarkPic, Wz.UIData, Wz.UIImageLib);
            Canvas.Draw(Wz.UIImageLib[MapMarkPic], 7, 22);
        }

        if (Map.MapNameList.ContainsKey(Map.ID))
        {
            Canvas.DrawString(Map.NpcNameTagFont, Map.MapNameList[Map.ID].StreetName, 49, 26, Color.White);
            Canvas.DrawString(Map.NpcNameTagFont, Map.MapNameList[Map.ID].MapName, 49, 43, Color.White);
        }
    }

    void DrawVersion3()
    {
        Wz_Node UIEntry = Wz.GetNodeA("UI/UIWindow2.img/MiniMap/MaxMap");
        // Wz.UIImageLib.Clear();
        if (!Wz.UIData.ContainsKey("UI/UIWindow2.img/MiniMap/MaxMap"))
            Wz.DumpData(UIEntry, Wz.UIData, Wz.UIImageLib);
        int PicWidth, PicHeight;
        var Canvas = EngineFunc.Canvas;
        if (Map.Img.HasNode("miniMap"))
        {
            HasMiniMap = true;
            cx = Map.Img.GetInt("miniMap/centerX");
            cy = Map.Img.GetInt("miniMap/centerY");
            var MiniMapNode = Map.Img.GetNode("miniMap");
            Wz.DumpData(MiniMapNode, Wz.UIData, Wz.UIImageLib);
            var MiniMapPng = Map.Img.GetBmp("miniMap/canvas");

            PicHeight = MiniMapPng.Height;
            PicWidth = PWidth;
            OffX = (PicWidth - MiniMapPng.Width) / 2;
            Canvas.FillRect(9, 62, PicWidth, PicHeight, new Color(0, 0, 0, 180));
            Canvas.Draw(Wz.UIImageLib[MiniMapNode.Get("canvas")], 9 + OffX, 62);
        }
        else
        {
            cx = 0;
            cy = 0;
            OffX = 0;
            OffY = 0;
            PicWidth = 150;
            PicHeight = 100;
            Canvas.FillRect(9, 62, PicWidth, PicHeight, new Color(0, 0, 0, 180));
        }

        for (int X = 0; X <= PicWidth - 111; X++)
        {
            Canvas.Draw(Wz.UIImageLib[UIEntry.Get("n")], 64 + X, 0);
            Canvas.Draw(Wz.UIImageLib[UIEntry.Get("s")], 64 + X, PicHeight + 62);
        }

        for (int Y = 0; Y <= PicHeight - 24; Y++)
        {
            Canvas.Draw(Wz.UIImageLib[UIEntry.Get("w")], 0, 67 + Y);
            Canvas.Draw(Wz.UIImageLib[UIEntry.Get("e")], PicWidth + 9, 67 + Y);
        }
        Canvas.Draw(Wz.UIImageLib[UIEntry.Get("nw")], 0, 0); //left top
        Canvas.Draw(Wz.UIImageLib[UIEntry.Get("ne")], PicWidth - 46, 0); //right top
        Canvas.Draw(Wz.UIImageLib[UIEntry.Get("sw")], 0, PicHeight + 44); // right bottom
        Canvas.Draw(Wz.UIImageLib[UIEntry.Get("se")], PicWidth - 46, PicHeight + 44); // left botton
        Wz.DumpData(Wz.GetNode("Map/MapHelper.img/minimap"), Wz.UIData, Wz.UIImageLib);

        var NpcMark = Wz.GetNodeA("Map/MapHelper.img/minimap/npc");
        foreach (var Iter in Map.Img.GetNodes("life"))
        {
            if (Iter.GetStr("type") == "n" && Iter.GetInt("hide") != 1)
                Canvas.Draw(Wz.UIImageLib[NpcMark], ((Iter.GetInt("x") + cx) / 16)
                  + OffX + 4, ((Iter.GetInt("y") + cy) / 16) + 50);
        }

        var PortalMark = Wz.GetNodeA("Map/MapHelper.img/minimap/portal");
        foreach (var Iter in Map.Img.GetNodes("portal"))
        {
            if (Iter.GetInt("pt") == 2 || Iter.GetInt("pt") == 7)
                Canvas.Draw(Wz.UIImageLib[PortalMark], ((Iter.GetInt("x") + cx) /
                  16) + OffX + 2, ((Iter.GetInt("y") + cy) / 16) + 48);
        }

        var MapMarkName = Map.Img.GetStr("info/mapMark");
        if (MapMarkName != "None")
        {
            var MapMarkPic = Wz.GetNodeA("Map/MapHelper.img/mark/" + MapMarkName);
            Wz.DumpData(MapMarkPic, Wz.UIData, Wz.UIImageLib);
            Canvas.Draw(Wz.UIImageLib[MapMarkPic], 7, 17);
        }
        PlayerMark = Wz.GetNodeA("Map/MapHelper.img/minimap/user");

        if (Map.MapNameList.ContainsKey(Map.ID))
        {
            Canvas.DrawString(Map.NpcNameTagFont, Map.MapNameList[Map.ID].StreetName, 50, 20, Color.White);
            Canvas.DrawString(Map.NpcNameTagFont, Map.MapNameList[Map.ID].MapName, 50, 37, Color.White);
        }
    }

    public void RenderTargetFunc()
    {
        switch (Version)
        {
            case 1:
                DrawVersion1();
                break;
            case 3:
                DrawVersion3();
                break;
        }
    }

    public void ReDraw()
    {
        float Length = 0;
        float Length1 = 0, Length2 = 0;

        if (Map.MapNameList.ContainsKey(Map.ID))
        {
            Length1 = Map.MeasureStringX(Map.NpcNameTagFont, Map.MapNameList[Map.ID].StreetName);
            Length2 = Map.MeasureStringX(Map.NpcNameTagFont, Map.MapNameList[Map.ID].MapName);
        }
        Length = Math.Max(Length1, Length2);

        if (Version == 1)
        {
            AddWidth = -50;
            AddHeight = 12;
        }
        else
        {
            AddWidth = 0;
            AddHeight = 0;
        }

        if (Map.Img.HasNode("miniMap"))
        {
            var MiniMapPng = Map.Img.GetBmp("miniMap/canvas");
            PWidth = Math.Max((int)Length, MiniMapPng.Width + AddWidth) + 40;
            EngineFunc.Canvas.DrawTarget(ref RenderTarget, PWidth + 50, MiniMapPng.Height + 80 + AddHeight, () => RenderTargetFunc());
            this.Size = new Microsoft.Xna.Framework.Vector2(PWidth + 20, MiniMapPng.Height + 40);
        }
        else
        {
            EngineFunc.Canvas.DrawTarget(ref RenderTarget, 1, 1, () => RenderTargetFunc());
            this.Size = new Microsoft.Xna.Framework.Vector2(1, 1);
        }
    }

    internal override void DoDraw(Vector2 offset)
    {
        if (!Map.ShowMiniMap)
            return;
        if (!IsVisible)
            return;

        if (HasMiniMap)
        {
            SpriteBatch.Draw(RenderTarget, new Vector2(Location.X, Location.Y), Color.White);
            int px = (int)(Game.Player.X + cx) / 16;
            int py = (int)(Game.Player.Y + cy) / 16;
            if (Version == 1)
            {
                if (HasMark)
                    SpriteBatch.Draw(Wz.UIImageLib[PlayerMark], new Vector2(Location.X + px + OffX + 2 + 8, Location.Y + py + OffY + 50 + 15), Color.White);
                else
                    SpriteBatch.FillRectangle(new Microsoft.Xna.Framework.Rectangle((int)Location.X + px + OffX + 2 + 8, (int)Location.Y + py + OffY +
                      50 + 17, 5, 5), new Color(0, 255, 255, 255));
            }
            else
            {
                SpriteBatch.Draw(Wz.UIImageLib[PlayerMark], new Vector2(Location.X + px + OffX + 2, Location.Y + py + OffY + 50), Color.White);
            }
        }

        foreach (var control in Controls)
        {
            if (control.IsVisible)
                control.DoDraw(Location);
        }
    }

}

```

`MapleNecrocer/Client/UI/UI.Utils.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WzComparerR2.WzLib;
using WzComparerR2.WzLib;
using WzComparerR2.Common;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework;
using MonoGame.UI.Forms;
using MapleNecrocer;
using System.Runtime.CompilerServices;
using System.Windows.Forms;

namespace GameUI;
public class UIControlManager : ControlManager
{
    public UIControlManager()
    {

    }
}

public class UI
{
    public static UIControlManager ControlManager = new();
    public static UIForm RefForm;

    public static Dictionary<string, UIForm> Form = new();
    public static Dictionary<string, UIButton> Button = new();
    public static void CreateDefault()
    {


    }

    public static void CrateForm(string UIPath, int X = 0, int Y = 0, bool IsMoveable = true, bool visible = true)
    {
        var _Form = new UIForm();
        // Form.HitBox=new Microsoft.Xna.Framework.Rectangle(0,0,500,500);
        var UINode = Wz.GetNode(UIPath);
        Wz.DumpData(UINode, Wz.UIData, Wz.UIImageLib);
        _Form.Location = new Vector2(X, Y);
        _Form.UIPath = UIPath;
        var UIPng = UINode.ExtractPng();
        _Form.Size = new Vector2(UIPng.Width, UIPng.Height);
        _Form.IsMovable = IsMoveable;
        _Form.IsVisible = visible;

        RefForm = _Form;
        ControlManager.Controls.Add(_Form);
        Form.Add(UIPath, _Form);
    }
    public static void CreateButton(string UIPath, int X = 0, int Y = 0, Action ClickEvent = null)
    {
        var Button = new UIButton();
        var UINode = Wz.GetNode(UIPath);
        if (!Wz.UIData.ContainsKey(UINode.FullPathToFile2()))
            Wz.DumpData(UINode, Wz.UIData, Wz.UIImageLib);
        Button.UIPath = UIPath;

        var Origin = UINode.GetVector("normal/0/ogigin");
        Button.Location = new Vector2(X + -Origin.X, Y + -Origin.Y);
        var UIPng = UINode.GetBmp("normal/0");
        Button.Size = new Vector2(UIPng.Width, UIPng.Height);
        Button.Clicked += (s, e) => { ClickEvent(); };
        RefForm.Controls.Add(Button);
    }

    public static void CreateButton(string ButtonName, string UIPath, int X = 0, int Y = 0, Action ClickEvent = null)
    {
        var _Button = new UIButton();
        var UINode = Wz.GetNode(UIPath);
        if (!Wz.UIData.ContainsKey(UINode.FullPathToFile2()))
            Wz.DumpData(UINode, Wz.UIData, Wz.UIImageLib);
        _Button.UIPath = UIPath;

        var Origin = UINode.GetVector("normal/0/ogigin");
        _Button.Location = new Vector2(X + -Origin.X, Y + -Origin.Y);
        var UIPng = UINode.GetBmp("normal/0");
        _Button.Size = new Vector2(UIPng.Width, UIPng.Height);
        _Button.Clicked += (s, e) => { ClickEvent(); };
        RefForm.Controls.Add(_Button);
        Button.Add(ButtonName, _Button);
    }

}

```

`MapleNecrocer/ConsumeForm.Designer.cs`:

```cs
namespace MapleNecrocer
{
    partial class ConsumeForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            tabControl1 = new TabControl();
            tabPage1 = new TabPage();
            tabPage2 = new TabPage();
            textBox1 = new TextBox();
            tabPage3 = new TabPage();
            button1 = new Button();
            panel1 = new Panel();
            UseButton = new Button();
            pictureBox1 = new PictureBox();
            label1 = new Label();
            label2 = new Label();
            tabControl1.SuspendLayout();
            tabPage2.SuspendLayout();
            tabPage3.SuspendLayout();
            panel1.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)pictureBox1).BeginInit();
            SuspendLayout();
            // 
            // tabControl1
            // 
            tabControl1.Anchor = AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right;
            tabControl1.Controls.Add(tabPage1);
            tabControl1.Controls.Add(tabPage2);
            tabControl1.Controls.Add(tabPage3);
            tabControl1.Location = new Point(6, 58);
            tabControl1.Name = "tabControl1";
            tabControl1.Padding = new Point(6, 0);
            tabControl1.SelectedIndex = 0;
            tabControl1.Size = new Size(420, 585);
            tabControl1.TabIndex = 7;
            tabControl1.SelectedIndexChanged += tabControl1_SelectedIndexChanged;
            // 
            // tabPage1
            // 
            tabPage1.Location = new Point(4, 24);
            tabPage1.Name = "tabPage1";
            tabPage1.Padding = new Padding(3);
            tabPage1.Size = new Size(412, 557);
            tabPage1.TabIndex = 0;
            tabPage1.Text = "Icons";
            tabPage1.UseVisualStyleBackColor = true;
            // 
            // tabPage2
            // 
            tabPage2.Controls.Add(textBox1);
            tabPage2.Location = new Point(4, 26);
            tabPage2.Name = "tabPage2";
            tabPage2.Padding = new Padding(3, 3, 3, 5);
            tabPage2.Size = new Size(412, 560);
            tabPage2.TabIndex = 1;
            tabPage2.Text = "Search";
            tabPage2.UseVisualStyleBackColor = true;
            // 
            // textBox1
            // 
            textBox1.Location = new Point(112, 6);
            textBox1.Name = "textBox1";
            textBox1.Size = new Size(162, 24);
            textBox1.TabIndex = 5;
            textBox1.TextChanged += textBox1_TextChanged;
            // 
            // tabPage3
            // 
            tabPage3.Controls.Add(button1);
            tabPage3.Location = new Point(4, 26);
            tabPage3.Name = "tabPage3";
            tabPage3.Size = new Size(412, 560);
            tabPage3.TabIndex = 2;
            tabPage3.Text = "Consume Effect";
            tabPage3.UseVisualStyleBackColor = true;
            // 
            // button1
            // 
            button1.Location = new Point(120, 3);
            button1.Name = "button1";
            button1.Size = new Size(116, 27);
            button1.TabIndex = 0;
            button1.Text = "Remove";
            button1.UseVisualStyleBackColor = true;
            button1.Click += button1_Click;
            // 
            // panel1
            // 
            panel1.BorderStyle = BorderStyle.FixedSingle;
            panel1.Controls.Add(UseButton);
            panel1.Controls.Add(pictureBox1);
            panel1.Controls.Add(label1);
            panel1.Controls.Add(label2);
            panel1.Location = new Point(56, 5);
            panel1.Name = "panel1";
            panel1.Size = new Size(320, 49);
            panel1.TabIndex = 8;
            // 
            // UseButton
            // 
            UseButton.Location = new Point(263, 6);
            UseButton.Name = "UseButton";
            UseButton.Size = new Size(52, 35);
            UseButton.TabIndex = 3;
            UseButton.Text = "Drop";
            UseButton.TextAlign = ContentAlignment.MiddleLeft;
            UseButton.UseVisualStyleBackColor = true;
            UseButton.Click += UseButton_Click;
            // 
            // pictureBox1
            // 
            pictureBox1.Location = new Point(74, 3);
            pictureBox1.Name = "pictureBox1";
            pictureBox1.Size = new Size(40, 40);
            pictureBox1.SizeMode = PictureBoxSizeMode.CenterImage;
            pictureBox1.TabIndex = 1;
            pictureBox1.TabStop = false;
            // 
            // label1
            // 
            label1.AutoSize = true;
            label1.Location = new Point(3, 16);
            label1.Name = "label1";
            label1.Size = new Size(0, 18);
            label1.TabIndex = 0;
            // 
            // label2
            // 
            label2.AutoSize = true;
            label2.Location = new Point(110, 16);
            label2.Name = "label2";
            label2.Size = new Size(0, 18);
            label2.TabIndex = 2;
            // 
            // ConsumeForm
            // 
            AutoScaleMode = AutoScaleMode.None;
            ClientSize = new Size(432, 650);
            Controls.Add(panel1);
            Controls.Add(tabControl1);
            Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            KeyPreview = true;
            Name = "ConsumeForm";
            Padding = new Padding(0, 0, 0, 5);
            StartPosition = FormStartPosition.CenterScreen;
            Text = "Consume";
            TopMost = true;
            FormClosing += ConsumeForm_FormClosing;
            Shown += ConsumeForm_Shown;
            KeyDown += ConsumeForm_KeyDown;
            tabControl1.ResumeLayout(false);
            tabPage2.ResumeLayout(false);
            tabPage2.PerformLayout();
            tabPage3.ResumeLayout(false);
            panel1.ResumeLayout(false);
            panel1.PerformLayout();
            ((System.ComponentModel.ISupportInitialize)pictureBox1).EndInit();
            ResumeLayout(false);
        }

        #endregion

        private TabControl tabControl1;
        private TabPage tabPage1;
        private TabPage tabPage2;
        private TextBox textBox1;
        private TabPage tabPage3;
        private Panel panel1;
        private Button UseButton;
        private PictureBox pictureBox1;
        private Label label1;
        private Label label2;
        private Button button1;
    }
}
```

`MapleNecrocer/ConsumeForm.cs`:

```cs
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Reflection.Emit;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using DevComponents.DotNetBar;
using Manina.Windows.Forms;
using WzComparerR2.CharaSim;
using WzComparerR2.WzLib;

namespace MapleNecrocer;

public partial class ConsumeForm : Form
{
    public ConsumeForm()
    {
        InitializeComponent();
        Instance = this;
    }
    ImageListView ImageGrid;
    public static ConsumeForm Instance;
    DataGridViewEx ConsumeListGrid;
    DataGridViewEx ConsumeEffectListGrid;
    bool HasLoaded1, HasLoaded2;
    protected override CreateParams CreateParams
    {
        get
        {
            CreateParams cp = base.CreateParams;
            cp.ExStyle |= 0x02000000;
            return cp;
        }
    }
    private void ConsumeForm_Shown(object sender, EventArgs e)
    {
        this.FormClosing += (s, e1) =>
        {
            this.Hide();
            e1.Cancel = true;
        };

        ImageGrid = new ImageListView();
        ImageGrid.Parent = tabControl1.TabPages[0];
        ImageGrid.Anchor = (AnchorStyles.Left | AnchorStyles.Right | AnchorStyles.Top | AnchorStyles.Bottom);
        ImageGrid.Dock = DockStyle.Fill;
        ImageGrid.BackColor = SystemColors.Window;
        ImageGrid.Colors.BackColor = SystemColors.ButtonFace;
        ImageGrid.Colors.SelectedBorderColor = Color.Red;
        ImageGrid.BorderStyle = BorderStyle.Fixed3D;
        ImageGrid.ThumbnailSize = new System.Drawing.Size(32, 32);
        ImageGrid.ItemClick += (o, e) =>
        {
            string ID = (e.Item.FileName);
            label1.Text = ID;
            pictureBox1.Image = Wz.GetBmp("Item/Consume/" + ID.LeftStr(4) + ".img/" + ID + "/info/icon");
            string Name = "";
            if (Wz.HasNode("String/Consume.img"))
                Name = Wz.GetStr("String/Consume.img/" + ID.IntID() + "/name");
            else if (Wz.HasNode("String/Item.img/Con"))
                Name = Wz.GetStr("String/Item.img/Con/" + ID.IntID() + "/name");
            label2.Text = Name;

        };

        ImageGrid.ItemHover += (o, e) =>
        {
            if (e.Item == null) return;
            Wz_Node Node = Wz.GetNodeByID(e.Item.FileName, WzType.Item);
            MainForm.Instance.QuickView(Node);
            MainForm.Instance.ToolTipView.Owner = this;
        };

        var Graphic = ImageGrid.CreateGraphics();
        var Font = new System.Drawing.Font(FontFamily.GenericSansSerif, 20, FontStyle.Bold);
        Graphic.DrawString("Loading...", Font, Brushes.Black, 10, 50);
        Win32.SendMessage(ImageGrid.Handle, false);
        Bitmap Bmp = null;
        foreach (var Img in Wz.GetNodes("Item/Consume"))
        {
            if (!Char.IsNumber(Img.Text[0]))
                continue;
            foreach (var Iter in Wz.GetNodes("Item/Consume/" + Img.Text))
            {
                if (Iter.HasNode("info/icon"))
                    Bmp = Iter.GetBmp("info/icon");
                ImageGrid.Items.Add(Iter.Text, Bmp);
            }
        }
        ImageGrid.Sort();
        Win32.SendMessage(ImageGrid.Handle, true);
        ImageGrid.Refresh();
    }

    private void tabControl1_SelectedIndexChanged(object sender, EventArgs e)
    {
        label1.Text = "";
        pictureBox1.Image = null;
        label2.Text = "";
        if (tabControl1.SelectedIndex == 1)
        {
            if (HasLoaded1)
                return;

            ConsumeListGrid = new(80, 185, 0, 20, 220, 530, true, tabControl1.TabPages[1]);
            ConsumeListGrid.Anchor = (AnchorStyles.Left | AnchorStyles.Right | AnchorStyles.Top | AnchorStyles.Bottom);
            ConsumeListGrid.Dock = DockStyle.Fill;
            tabControl1.TabPages[1].Padding = new System.Windows.Forms.Padding(0, 35, 0, 0);
            ConsumeListGrid.SearchGrid.Dock = DockStyle.Fill;
            ConsumeListGrid.RowTemplate.Height = 40;

            var Graphic = ConsumeListGrid.CreateGraphics();
            var Font = new System.Drawing.Font(FontFamily.GenericSansSerif, 20, FontStyle.Bold);
            Graphic.DrawString("Loading...", Font, Brushes.Black, 10, 50);
            void CellClick(BaseDataGridView DataGrid, DataGridViewCellEventArgs e)
            {
                string ID = DataGrid.Rows[e.RowIndex].Cells[0].Value.ToString();
                label1.Text = ID;
                pictureBox1.Image = (Bitmap)DataGrid.Rows[e.RowIndex].Cells[1].Value;
                label2.Text = DataGrid.Rows[e.RowIndex].Cells[2].Value.ToString();
            }

            ConsumeListGrid.CellClick += (s, e) =>
            {
                CellClick(ConsumeListGrid, e);
            };

            ConsumeListGrid.SearchGrid.CellClick += (s, e) =>
            {
                CellClick(ConsumeListGrid.SearchGrid, e);
            };

            ConsumeListGrid.SetToolTipEvent(WzType.Item, this);

            Win32.SendMessage(ConsumeListGrid.Handle, false);
            Bitmap Bmp = null;
            string ConsumeName = "";
            foreach (var Img in Wz.GetNodes("Item/Consume"))
            {
                if (!Char.IsNumber(Img.Text[0]))
                    continue;
                foreach (var Iter in Wz.GetNodes("Item/Consume/" + Img.Text))
                {
                    string ID = Iter.Text;
                    string IntID = ID.IntID();
                    if (Wz.HasNode("String/Consume.img/" + IntID))
                        ConsumeName = Wz.GetStr("String/Consume.img/" + IntID + "/name");
                    else if (Wz.HasNode("String/Item.img/Con/" + IntID))
                        ConsumeName = Wz.GetStr("String/Item.img/Con/" + IntID + "/name");

                    if (Iter.HasNode("info/icon"))
                        Bmp = Iter.GetBmp("info/icon");
                    ConsumeListGrid.Rows.Add(ID, Bmp, ConsumeName);
                }
            }

            Win32.SendMessage(ConsumeListGrid.Handle, true);
            ConsumeListGrid.Refresh();
            for (int i = 0; i < ConsumeListGrid.Rows.Count; i++)
            {
                ConsumeListGrid.Rows[i].Cells[1].Style.Alignment = DataGridViewContentAlignment.MiddleCenter;
                ConsumeListGrid.Rows[i].Cells[2].Style.Alignment = DataGridViewContentAlignment.TopLeft;
            }
            HasLoaded1 = true;
        }

        if (tabControl1.SelectedIndex == 2)
        {
            if (HasLoaded2)
                return;
            ConsumeEffectListGrid = new(80, 185, 0, 20, 220, 530, true, tabControl1.TabPages[2]);
            ConsumeEffectListGrid.Anchor = (AnchorStyles.Left | AnchorStyles.Right | AnchorStyles.Top | AnchorStyles.Bottom);
            ConsumeEffectListGrid.Dock = DockStyle.Fill;
            tabControl1.TabPages[2].Padding = new System.Windows.Forms.Padding(0, 35, 0, 0);
            ConsumeEffectListGrid.SearchGrid.Dock = DockStyle.Fill;
            ConsumeEffectListGrid.RowTemplate.Height = 40;
            var Graphic = ConsumeEffectListGrid.CreateGraphics();
            var Font = new System.Drawing.Font(FontFamily.GenericSansSerif, 20, FontStyle.Bold);
            Graphic.DrawString("Loading...", Font, Brushes.Black, 10, 50);
            void CellClick(BaseDataGridView DataGrid, DataGridViewCellEventArgs e)
            {
                string ID = DataGrid.Rows[e.RowIndex].Cells[0].Value.ToString();
                ItemEffect.Remove(EffectType.Consume);
                ItemEffect.Create(ID, EffectType.Consume);
            }

            ConsumeEffectListGrid.CellClick += (s, e) =>
            {
                CellClick(ConsumeEffectListGrid, e);
            };

            Win32.SendMessage(ConsumeEffectListGrid.Handle, false);
            Bitmap Bmp = null;
            string ConsumeEffectName = "";
            foreach (var Iter in Wz.GetNodes("Effect/ItemEff.img"))
            {
                if (Iter.Text[0] == '2')
                {
                    string ID = '0' + Iter.Text;
                    if (Wz.HasNode("Item/Consume/" + ID.LeftStr(4) + ".img/" + ID + "/info/icon"))
                    {
                        Bmp = Wz.GetBmp("Item/Consume/" + ID.LeftStr(4) + ".img/" + ID + "/info/icon");

                    }
                    ConsumeEffectName = Wz.GetStr("String/Consume.img/" + ID.IntID() + "/name");
                    ConsumeEffectListGrid.Rows.Add(ID, Bmp, ConsumeEffectName);
                }
            }
            Win32.SendMessage(ConsumeEffectListGrid.Handle, true);
            ConsumeEffectListGrid.Refresh();
            for (int i = 0; i < ConsumeEffectListGrid.Rows.Count; i++)
            {
                ConsumeEffectListGrid.Rows[i].Cells[1].Style.Alignment = DataGridViewContentAlignment.MiddleCenter;
                ConsumeEffectListGrid.Rows[i].Cells[2].Style.Alignment = DataGridViewContentAlignment.TopLeft;
            }
            HasLoaded2 = true;
        }
    }

    private void textBox1_TextChanged(object sender, EventArgs e)
    {
        ConsumeListGrid.Search(textBox1.Text);
    }

    private void button1_Click(object sender, EventArgs e)
    {
        ItemEffect.Remove(EffectType.Consume);
    }

    private void UseButton_Click(object sender, EventArgs e)
    {
        if (label1.Text.Trim(' ') != "")
            ItemDrop.Drop((int)Game.Player.X, (int)Game.Player.Y, 0, label1.Text.Trim(' '));
    }

    private void ConsumeForm_KeyDown(object sender, KeyEventArgs e)
    {
        if (e.Alt)
            e.Handled = true;
        if (!textBox1.Focused)
            ActiveControl = null;
    }

    private void ConsumeForm_FormClosing(object sender, FormClosingEventArgs e)
    {
        MainForm.Instance.ToolTipView.Visible = false;
    }
}

```

`MapleNecrocer/ConsumeForm.resx`:

```resx
<root>
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`MapleNecrocer/DPIUtil.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using System.Security;
using System.Text;
using System.Threading.Tasks;
namespace DPIUtils;

public static class DPIUtil
{
    public static float dpiX,dpiY;
    private const int MinOSVersionBuild = 14393;
    private const int MinOSVersionMajor = 10;
    private static bool _isSupportingDpiPerMonitor;
    private static bool _isOSVersionChecked;

    internal static bool IsSupportingDpiPerMonitor
    {
        get
        {
            if (_isOSVersionChecked)
            {
                return _isSupportingDpiPerMonitor;
            }

            _isOSVersionChecked = true;
            var osVersionInfo = new OSVERSIONINFOEXW
            {
                dwOSVersionInfoSize = Marshal.SizeOf(typeof(OSVERSIONINFOEXW))
            };

            if (RtlGetVersion(ref osVersionInfo) != 0)
            {
                _isSupportingDpiPerMonitor = Environment.OSVersion.Version.Major >= MinOSVersionMajor && Environment.OSVersion.Version.Build >= MinOSVersionBuild;

                return _isSupportingDpiPerMonitor;
            }

            _isSupportingDpiPerMonitor = osVersionInfo.dwMajorVersion >= MinOSVersionMajor && osVersionInfo.dwBuildNumber >= MinOSVersionBuild;

            return _isSupportingDpiPerMonitor;
        }
    }

    public static double ScaleFactor(Control control, Point monitorPoint)
    {
        var dpi = GetDpi(control, monitorPoint);

        return dpi / 96.0;
    }

    public static uint GetDpi(Control control, Point monitorPoint)
    {
        uint dpiX;

        if (IsSupportingDpiPerMonitor)
        {
            var monitorFromPoint = MonitorFromPoint(monitorPoint, 2);

            GetDpiForMonitor(monitorFromPoint, DpiType.Effective, out dpiX, out _);
        }
        else
        {
            // If using with System.Windows.Forms - can be used Control.DeviceDpi
            dpiX = control == null ? 96 : (uint)control.DeviceDpi;
        }

        return dpiX;
    }

    [DllImport("User32.dll")]
    internal static extern IntPtr MonitorFromPoint([In] Point pt, [In] uint dwFlags);

    [DllImport("Shcore.dll")]
    private static extern IntPtr GetDpiForMonitor([In] IntPtr hmonitor, [In] DpiType dpiType, [Out] out uint dpiX, [Out] out uint dpiY);

    [SecurityCritical]
    [DllImport("ntdll.dll", SetLastError = true)]
    private static extern int RtlGetVersion(ref OSVERSIONINFOEXW versionInfo);

    [StructLayout(LayoutKind.Sequential)]
    private struct OSVERSIONINFOEXW
    {
        internal int dwOSVersionInfoSize;
        internal int dwMajorVersion;
        internal int dwMinorVersion;
        internal int dwBuildNumber;
        internal int dwPlatformId;
        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]
        internal string szCSDVersion;
        internal ushort wServicePackMajor;
        internal ushort wServicePackMinor;
        internal short wSuiteMask;
        internal byte wProductType;
        internal byte wReserved;
    }

    private enum DpiType
    {
        Effective = 0,
        Angular = 1,
        Raw = 2,
    }
}

```

`MapleNecrocer/DamageSkinForm.Designer.cs`:

```cs
namespace MapleNecrocer
{
    partial class DamageSkinForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            tabControl1 = new TabControl();
            tabPage1 = new TabPage();
            tabPage2 = new TabPage();
            tabControl1.SuspendLayout();
            SuspendLayout();
            // 
            // tabControl1
            // 
            tabControl1.Anchor = AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right;
            tabControl1.Controls.Add(tabPage1);
            tabControl1.Controls.Add(tabPage2);
            tabControl1.Font = new Font("Tahoma", 13F, FontStyle.Regular, GraphicsUnit.Pixel);
            tabControl1.Location = new Point(5, 64);
            tabControl1.Name = "tabControl1";
            tabControl1.SelectedIndex = 0;
            tabControl1.Size = new Size(290, 487);
            tabControl1.TabIndex = 0;
            // 
            // tabPage1
            // 
            tabPage1.Location = new Point(4, 25);
            tabPage1.Name = "tabPage1";
            tabPage1.Padding = new Padding(3);
            tabPage1.Size = new Size(282, 458);
            tabPage1.TabIndex = 0;
            tabPage1.Text = "tabPage1";
            tabPage1.UseVisualStyleBackColor = true;
            // 
            // tabPage2
            // 
            tabPage2.Location = new Point(4, 25);
            tabPage2.Name = "tabPage2";
            tabPage2.Padding = new Padding(3);
            tabPage2.Size = new Size(282, 458);
            tabPage2.TabIndex = 1;
            tabPage2.Text = "tabPage2";
            tabPage2.UseVisualStyleBackColor = true;
            // 
            // DamageSkinForm
            // 
            AutoScaleMode = AutoScaleMode.None;
            ClientSize = new Size(302, 563);
            Controls.Add(tabControl1);
            Font = new Font("Tahoma", 13F, FontStyle.Regular, GraphicsUnit.Pixel);
            KeyPreview = true;
            MaximumSize = new Size(320, 1000);
            Name = "DamageSkinForm";
            StartPosition = FormStartPosition.CenterScreen;
            Text = "DamageSkin";
            TopMost = true;
            Shown += DamageSkinForm_Shown;
            KeyDown += DamageSkinForm_KeyDown;
            tabControl1.ResumeLayout(false);
            ResumeLayout(false);
        }

        #endregion

        private TabControl tabControl1;
        private TabPage tabPage1;
        private TabPage tabPage2;
    }
}
```

`MapleNecrocer/DamageSkinForm.cs`:

```cs
using DevComponents.DotNetBar;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using WzComparerR2.WzLib;
namespace MapleNecrocer;

public partial class DamageSkinForm : Form
{
    public DamageSkinForm()
    {
        InitializeComponent();
        Instance = this;
    }
    public static DamageSkinForm Instance;
    public DataGridViewEx DamageSkinListGrid;

    void CellClick(BaseDataGridView DataGrid, DataGridViewCellEventArgs e)
    {
        DamageNumber.UseNewDamage = true;
        var DamageStyle = DataGrid.Rows[e.RowIndex].Cells[0].Value.ToString();
        DamageNumber.Style = DamageStyle;
        DamageNumber.Load(DamageStyle);
    }
    private void DamageSkinForm_Shown(object sender, EventArgs e)
    {
        this.FormClosing += (s, e1) =>
        {
            this.Hide();
            e1.Cancel = true;
        };
        if(!Wz.HasNode("Effect/DamageSkin.img"))
            return;

        DamageSkinListGrid = new(120, 1, 0, 0, 210, 400, true, tabControl1.TabPages[0]);
        DamageSkinListGrid.Dock = DockStyle.Fill;
        DamageSkinListGrid.SearchGrid.Dock = DockStyle.Fill;
        DamageSkinListGrid.RowTemplate.Height = 70;
        DamageSkinListGrid.Columns[1].Width = 130;
        DamageSkinListGrid.Columns[2].Width = 0;
        var Graphic = DamageSkinListGrid.CreateGraphics();
        var Font = new System.Drawing.Font(FontFamily.GenericSansSerif, 20, FontStyle.Bold);
        Graphic.DrawString("Loading...", Font, Brushes.Black, 10, 50);

        DamageSkinListGrid.CellClick += (s, e) =>
        {
            CellClick(DamageSkinListGrid, e);
        };


        Wz_Node Entry = null;
        if (Wz.HasNode("Effect/DamageSkin.img"))
            Entry = Wz.GetNode("Effect/DamageSkin.img");
        else if (Wz.HasNode("Effect/BasicEff.img/damageSkin"))
            Entry = Wz.GetNode("Effect/BasicEff.img/damageSkin");

        if (Entry == null)
        {
            MessageBoxEx.Show("Older versions of .wz are not supported", "OK");
            return;
        }

        Bitmap Bmp = null;
        foreach (var Iter in Entry.Nodes)
        {
            foreach (var Iter2 in Iter.Nodes)
            {
                if (Iter2.Text == "NoCri1" || Iter2.Text == "NoRed1")
                {
                    if (Iter2.HasNode("5") && Iter2.Nodes["5"].Value is Wz_Png)
                        Bmp = Iter2.GetNode("5").ExtractPng();
                    DamageSkinListGrid.Rows.Add(Iter.Text + "/" + Iter2.Text, Bmp, "");
                }
            }
        }

        for (int i = 0; i < DamageSkinListGrid.Rows.Count; i++)
        {
            DamageSkinListGrid.Rows[i].Cells[0].Style.Alignment = DataGridViewContentAlignment.MiddleLeft;
            DamageSkinListGrid.Rows[i].Cells[1].Style.Alignment = DataGridViewContentAlignment.MiddleCenter;
        }
    }

    private void DamageSkinForm_KeyDown(object sender, KeyEventArgs e)
    {
        if (e.Alt)
            e.Handled = true;
        ActiveControl = null;
    }
}

```

`MapleNecrocer/DamageSkinForm.resx`:

```resx
<root>
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`MapleNecrocer/DataGridViewEx.cs`:

```cs
using System.Reflection;
using System.Windows.Forms;
using WzComparerR2.WzLib;

namespace MapleNecrocer;

public enum GridType
{
    Normal,
    Icon,
    Dye
}
public class BaseDataGridView : DataGridView
{
    public BaseDataGridView(int IDWidth, int NameWidth, bool IconGrid=false)
    {
        //  Dock = System.Windows.Forms.DockStyle.Fill;
        ColumnHeadersVisible = false;
        RowHeadersVisible = false;
        AllowUserToAddRows = false;
        SelectionMode = DataGridViewSelectionMode.FullRowSelect;
        this.ShowCellToolTips = false;
        DefaultCellStyle.WrapMode = DataGridViewTriState.True;
        this.MultiSelect = false;
        this.RowsDefaultCellStyle.Alignment = DataGridViewContentAlignment.MiddleLeft;
        
        this.AutoSizeRowsMode = DataGridViewAutoSizeRowsMode.None;
        this.AutoSizeColumnsMode = DataGridViewAutoSizeColumnsMode.None;
        this.ColumnHeadersHeightSizeMode = DataGridViewColumnHeadersHeightSizeMode.DisableResizing;
        this.AllowUserToResizeRows = false;
        this.AllowUserToResizeColumns = false;
        this.ScrollBars= ScrollBars.Vertical;
        this.BackgroundColor = Color.White;
        RowTemplate.Height = 35;
        //  DefaultCellStyle.Font = new System.Drawing.Font("Arial", 9);
        var ID = new DataGridViewTextBoxColumn();
        ID.DataPropertyName = "ID";
        ID.HeaderText = "ID";
        ID.Name = "propID";
        ID.ReadOnly = true;
        ID.Width = IDWidth;
        //
        var Icon = new DataGridViewImageColumn();
        Icon.DataPropertyName = "Icon";
        Icon.HeaderText = "圖示";
        Icon.Name = "propBitmap";
        Icon.ReadOnly = true;
        Icon.Width = 50;
        
        //
        var Name = new DataGridViewTextBoxColumn();
        Name.DataPropertyName = "NameProperty";
        Name.HeaderText = "名稱";
        Name.Name = "propName";
        Name.ReadOnly = true;
        Name.Width = NameWidth;
        if (IconGrid)
        {
            this.RowTemplate.Height = 35;
            DefaultCellStyle.Font = new Font("Tahoma", 16, GraphicsUnit.Pixel);
            Columns.AddRange(ID, Icon, Name);
            
        }
        else
        {
            this.RowTemplate.Height = 18;
            CellBorderStyle = DataGridViewCellBorderStyle.None;
            DefaultCellStyle.Font = new Font("Arial", 13, GraphicsUnit.Pixel);
            Columns.AddRange(ID, Name);
        }

        
    }
   
}

public class DataGridViewEx : BaseDataGridView
{
    public DataGridViewEx(int IDWidth, int NameWidth, int Left, int Top, int Width, int Height, bool IconGrid, Control Parent) : base(IDWidth, NameWidth, IconGrid)
    {
        this.Left = Left;
        this.Top = Top;
        this.Width = Width;
        this.Height = Height;
        this.Parent = Parent;
       

        SearchGrid = new(IDWidth, NameWidth, IconGrid);
        SearchGrid.Left = Left;
        SearchGrid.Top = Top;
        SearchGrid.Width = Width;
        SearchGrid.Height = Height;
        SearchGrid.Parent = Parent;
        SearchGrid.Visible = false;
    }
    public BaseDataGridView SearchGrid;

    string Trim(string s)
    {
        return s.Trim(' ');
    }
    public void Search(string Text)
    {
        foreach (DataGridViewRow i in SearchGrid.Rows)
        {
            if (i != null)
                i.Dispose();
        }

        var SearchStr = Trim(Text);
        if (SearchStr == "")
        {
            this.Visible = true;
            SearchGrid.Visible = false;
        }
        else
        {
            SearchGrid.Rows.Clear();
            var Row = new DataGridViewRow();

            for (int i = 0; i < this.RowCount; i++)
            {
                for (int j = 0; j < this.Columns.Count; j++)
                {
                    if (this.Rows[i].Cells[j].Value is string)
                    {
                        if (this.Rows[i].Cells[j].Value.ToString().IndexOf(SearchStr, StringComparison.OrdinalIgnoreCase) >= 0)
                        {
                            Row = (DataGridViewRow)this.Rows[i].Clone();
                            for (int j2 = 0; j2 < this.Columns.Count; j2++)
                                Row.Cells[j2].Value = this.Rows[i].Cells[j2].Value;
                            SearchGrid.Rows.Add(Row);
                            break;
                        }
                    }
                }
            }
            this.Visible = false;
            SearchGrid.Visible = true;
            SearchGrid.Refresh();
        }
    }

    public  void SetToolTipEvent(WzType WzType, Form Form)
    {  
        this.CellMouseEnter += (s, e) =>
        {
            if (e.RowIndex >= 0 && e.ColumnIndex >= 0)
            {
              this.Rows[e.RowIndex].DefaultCellStyle.BackColor = Color.LightCyan; 
            }
            this.Refresh();
            string ID = this.Rows[e.RowIndex].Cells[0].Value.ToString();
            Wz_Node Node = Wz.GetNodeByID(ID, WzType);
            MainForm.Instance.QuickView(Node);
            MainForm.Instance.ToolTipView.Owner = Form;
            
        };

        this.CellMouseLeave += (s, e) =>
        {
           if (e.RowIndex >= 0 && e.ColumnIndex >= 0)
            {
                this.Rows[e.RowIndex].DefaultCellStyle.BackColor = Color.White;
            }
           
        };

        this.SearchGrid.CellMouseEnter += (s, e) =>
        {
            if (e.RowIndex >= 0 && e.ColumnIndex >= 0)
            {
                this.SearchGrid.Rows[e.RowIndex].DefaultCellStyle.BackColor = Color.LightCyan;
            }
            this.Refresh();
            string ID = this.SearchGrid.Rows[e.RowIndex].Cells[0].Value.ToString();
            Wz_Node Node = Wz.GetNodeByID(ID, WzType);
            MainForm.Instance.QuickView(Node);
            MainForm.Instance.ToolTipView.Owner = Form;
        };

        this.SearchGrid.CellMouseLeave += (s, e) =>
        {
            if (e.RowIndex >= 0 && e.ColumnIndex >= 0)
            {
                this.SearchGrid.Rows[e.RowIndex].DefaultCellStyle.BackColor = Color.White;
            }
        };
    }

}
```

`MapleNecrocer/EffectRingForm.Designer.cs`:

```cs
namespace MapleNecrocer
{
    partial class EffectRingForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            button1 = new Button();
            textBox1 = new TextBox();
            label1 = new Label();
            panel1 = new Panel();
            SuspendLayout();
            // 
            // button1
            // 
            button1.Font = new Font("Tahoma", 13F, FontStyle.Regular, GraphicsUnit.Pixel);
            button1.Location = new Point(256, 19);
            button1.Margin = new Padding(5);
            button1.Name = "button1";
            button1.Size = new Size(98, 31);
            button1.TabIndex = 10;
            button1.Text = "Remove";
            button1.UseVisualStyleBackColor = true;
            button1.Click += button1_Click;
            // 
            // textBox1
            // 
            textBox1.Font = new Font("Tahoma", 13F, FontStyle.Regular, GraphicsUnit.Pixel);
            textBox1.Location = new Point(68, 23);
            textBox1.Margin = new Padding(5);
            textBox1.Name = "textBox1";
            textBox1.Size = new Size(143, 23);
            textBox1.TabIndex = 9;
            textBox1.TextChanged += textBox1_TextChanged;
            // 
            // label1
            // 
            label1.AutoSize = true;
            label1.Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            label1.Location = new Point(18, 25);
            label1.Margin = new Padding(5, 0, 5, 0);
            label1.Name = "label1";
            label1.Size = new Size(52, 18);
            label1.TabIndex = 8;
            label1.Text = "Search";
            // 
            // panel1
            // 
            panel1.Anchor = AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right;
            panel1.Location = new Point(18, 56);
            panel1.Margin = new Padding(5);
            panel1.Name = "panel1";
            panel1.Size = new Size(352, 775);
            panel1.TabIndex = 7;
            // 
            // EffectRingForm
            // 
            AutoScaleMode = AutoScaleMode.None;
            ClientSize = new Size(384, 845);
            Controls.Add(button1);
            Controls.Add(textBox1);
            Controls.Add(label1);
            Controls.Add(panel1);
            Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Point);
            KeyPreview = true;
            Margin = new Padding(5);
            Name = "EffectRingForm";
            StartPosition = FormStartPosition.CenterScreen;
            Text = "EffectRing";
            TopMost = true;
            FormClosing += EffectRingForm_FormClosing;
            Shown += EffectRingForm_Shown;
            KeyDown += EffectRingForm_KeyDown;
            ResumeLayout(false);
            PerformLayout();
        }

        #endregion

        private Button button1;
        private TextBox textBox1;
        private Label label1;
        private Panel panel1;
    }
}
```

`MapleNecrocer/EffectRingForm.cs`:

```cs
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace MapleNecrocer;

public partial class EffectRingForm : Form
{
    public EffectRingForm()
    {
        InitializeComponent();
        Instance = this;
    }
    public static EffectRingForm Instance;
    public DataGridViewEx EffectRingListGrid;

    void CellClick(BaseDataGridView DataGrid, DataGridViewCellEventArgs e)
    {
        var ID = DataGrid.Rows[e.RowIndex].Cells[0].Value.ToString();
        if (ID == "01112127" || ID == "01112804" || ID == "01113021" || ID == "01113228")
            return;
        foreach (var i in SetEffect.UseList)
            SetEffect.Remove(i.Key);
        ItemEffect.Remove(EffectType.Ring);
        if (ItemEffect.AllList.Contains(ID))
            ItemEffect.Create(ID, EffectType.Equip);
        if (SetEffect.AllList.ContainsKey(ID))
            SetEffect.Create(ID);
    }
    private void EffectRingForm_Shown(object sender, EventArgs e)
    {
        this.FormClosing += (s, e1) =>
        {
            this.Hide();
            e1.Cancel = true;
        };

        EffectRingListGrid = new(90, 179, 0, 0, 220, 400, true, panel1);
        EffectRingListGrid.Dock = DockStyle.Fill;
        EffectRingListGrid.SearchGrid.Dock = DockStyle.Fill;
        EffectRingListGrid.RowTemplate.Height = 40;

        var Graphic = EffectRingListGrid.CreateGraphics();
        var Font = new System.Drawing.Font(FontFamily.GenericSansSerif, 20, FontStyle.Bold);
        Graphic.DrawString("Loading...", Font, Brushes.Black, 10, 50);
        EffectRingListGrid.CellClick += (s, e) =>
        {
            CellClick(EffectRingListGrid, e);
        };

        EffectRingListGrid.SearchGrid.CellClick += (s, e) =>
        {
            CellClick(EffectRingListGrid.SearchGrid, e);
        };

        EffectRingListGrid.SetToolTipEvent(WzType.Character, this);

        foreach (var Iter in Wz.GetNodes("Effect/ItemEff.img"))
        {
            if (Iter.Text.LeftStr(3) != "111")
                continue;
            string ID = '0' + Iter.Text;
            if (!Wz.HasNode("Character/Ring/" + ID + ".img"))
                continue;
            string EffectRingName = Wz.GetStr("String/Eqp.img/Eqp/Ring/" + ID.IntID() + "/name");
            Bitmap Icon = null;
            if (Wz.HasNode("Character/Ring/" + ID + ".img/info/icon"))
                Icon = Wz.GetBmp("Character/Ring/" + ID + ".img/info/icon");
            EffectRingListGrid.Rows.Add(ID, Icon, EffectRingName);
        }

        foreach (var Iter in Wz.GetNodes("Effect/SetEff.img"))
        {
            foreach (var Iter2 in Iter.Nodes)
            {
                if (Iter2.Text == "info")
                {
                    foreach (var Iter3 in Iter2.Nodes)
                    {
                        foreach (var Iter4 in Iter3.Nodes)
                        {
                            if (Iter4.Value.ToString().LeftStr(3) == "111")
                            {
                                string ID = "0" + Iter4.Value.ToString();
                                if (!Wz.HasNode("Character/Ring/" + ID + ".img"))
                                    continue;
                                string EffectRingName = Wz.GetStr("String/Eqp.img/Eqp/Ring/" + ID.IntID() + "/name");
                                Bitmap Icon = null;
                                if (Wz.HasNode("Character/Ring/" + ID + ".img/info/icon"))
                                    Icon = Wz.GetBmp("Character/Ring/" + ID + ".img/info/icon");
                                EffectRingListGrid.Rows.Add(ID, Icon, EffectRingName);
                            }
                        }
                    }
                }
            }
        }

    }

    private void button1_Click(object sender, EventArgs e)
    {
        foreach (var i in SetEffect.UseList)
            SetEffect.Remove(i.Key);
        ItemEffect.Remove(EffectType.Ring);
    }

    private void EffectRingForm_KeyDown(object sender, KeyEventArgs e)
    {
        if (e.Alt)
            e.Handled = true;
        if (!textBox1.Focused)
            ActiveControl = null;
    }

    private void EffectRingForm_FormClosing(object sender, FormClosingEventArgs e)
    {
        MainForm.Instance.ToolTipView.Visible = false;
    }

    private void textBox1_TextChanged(object sender, EventArgs e)
    {
        EffectRingListGrid.Search(textBox1.Text);
    }
}

```

`MapleNecrocer/EffectRingForm.resx`:

```resx
<root>
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`MapleNecrocer/EtcForm.Designer.cs`:

```cs
namespace MapleNecrocer
{
    partial class EtcForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            panel1 = new Panel();
            UseButton = new Button();
            pictureBox1 = new PictureBox();
            label1 = new Label();
            label2 = new Label();
            tabControl1 = new TabControl();
            tabPage1 = new TabPage();
            tabPage2 = new TabPage();
            textBox1 = new TextBox();
            panel1.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)pictureBox1).BeginInit();
            tabControl1.SuspendLayout();
            tabPage2.SuspendLayout();
            SuspendLayout();
            // 
            // panel1
            // 
            panel1.BorderStyle = BorderStyle.FixedSingle;
            panel1.Controls.Add(UseButton);
            panel1.Controls.Add(pictureBox1);
            panel1.Controls.Add(label1);
            panel1.Controls.Add(label2);
            panel1.Location = new Point(48, 12);
            panel1.Name = "panel1";
            panel1.Size = new Size(320, 49);
            panel1.TabIndex = 10;
            // 
            // UseButton
            // 
            UseButton.Location = new Point(263, 6);
            UseButton.Name = "UseButton";
            UseButton.Size = new Size(52, 35);
            UseButton.TabIndex = 3;
            UseButton.Text = "Drop";
            UseButton.TextAlign = ContentAlignment.MiddleLeft;
            UseButton.UseVisualStyleBackColor = true;
            UseButton.Click += UseButton_Click;
            // 
            // pictureBox1
            // 
            pictureBox1.Location = new Point(74, 3);
            pictureBox1.Name = "pictureBox1";
            pictureBox1.Size = new Size(40, 40);
            pictureBox1.SizeMode = PictureBoxSizeMode.CenterImage;
            pictureBox1.TabIndex = 1;
            pictureBox1.TabStop = false;
            // 
            // label1
            // 
            label1.AutoSize = true;
            label1.Location = new Point(3, 16);
            label1.Name = "label1";
            label1.Size = new Size(0, 18);
            label1.TabIndex = 0;
            // 
            // label2
            // 
            label2.AutoSize = true;
            label2.Location = new Point(110, 16);
            label2.Name = "label2";
            label2.Size = new Size(0, 18);
            label2.TabIndex = 2;
            // 
            // tabControl1
            // 
            tabControl1.Anchor = AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right;
            tabControl1.Controls.Add(tabPage1);
            tabControl1.Controls.Add(tabPage2);
            tabControl1.Location = new Point(6, 62);
            tabControl1.Name = "tabControl1";
            tabControl1.Padding = new Point(6, 0);
            tabControl1.SelectedIndex = 0;
            tabControl1.Size = new Size(420, 538);
            tabControl1.TabIndex = 11;
            tabControl1.SelectedIndexChanged += tabControl1_SelectedIndexChanged;
            // 
            // tabPage1
            // 
            tabPage1.Location = new Point(4, 24);
            tabPage1.Name = "tabPage1";
            tabPage1.Padding = new Padding(3);
            tabPage1.Size = new Size(412, 510);
            tabPage1.TabIndex = 0;
            tabPage1.Text = "Icons";
            tabPage1.UseVisualStyleBackColor = true;
            // 
            // tabPage2
            // 
            tabPage2.Controls.Add(textBox1);
            tabPage2.Location = new Point(4, 26);
            tabPage2.Name = "tabPage2";
            tabPage2.Padding = new Padding(3, 3, 3, 5);
            tabPage2.Size = new Size(412, 508);
            tabPage2.TabIndex = 1;
            tabPage2.Text = "Search";
            tabPage2.UseVisualStyleBackColor = true;
            // 
            // textBox1
            // 
            textBox1.Location = new Point(112, 6);
            textBox1.Name = "textBox1";
            textBox1.Size = new Size(162, 24);
            textBox1.TabIndex = 5;
            textBox1.TextChanged += textBox1_TextChanged;
            // 
            // EtcForm
            // 
            AutoScaleMode = AutoScaleMode.None;
            ClientSize = new Size(432, 606);
            Controls.Add(tabControl1);
            Controls.Add(panel1);
            Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            KeyPreview = true;
            Name = "EtcForm";
            StartPosition = FormStartPosition.CenterScreen;
            Text = "Etc";
            TopMost = true;
            FormClosing += EtcForm_FormClosing;
            Shown += EtcForm_Shown;
            KeyDown += EtcForm_KeyDown;
            panel1.ResumeLayout(false);
            panel1.PerformLayout();
            ((System.ComponentModel.ISupportInitialize)pictureBox1).EndInit();
            tabControl1.ResumeLayout(false);
            tabPage2.ResumeLayout(false);
            tabPage2.PerformLayout();
            ResumeLayout(false);
        }

        #endregion

        private Panel panel1;
        private Button UseButton;
        private PictureBox pictureBox1;
        private Label label1;
        private Label label2;
        private TabControl tabControl1;
        private TabPage tabPage1;
        private TabPage tabPage2;
        private TextBox textBox1;
    }
}
```

`MapleNecrocer/EtcForm.cs`:

```cs
using Manina.Windows.Forms;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using WzComparerR2.WzLib;

namespace MapleNecrocer;

public partial class EtcForm : Form
{
    public EtcForm()
    {
        InitializeComponent();
        Instance = this;
    }
    public static EtcForm Instance;
    ImageListView ImageGrid;
    DataGridViewEx EtcListGrid;
    bool HasLoaded1;
   
    private void EtcForm_Shown(object sender, EventArgs e)
    {
        this.FormClosing += (s, e1) =>
        {
            this.Hide();
            e1.Cancel = true;
        };

        ImageGrid = new ImageListView();
        ImageGrid.Parent = tabControl1.TabPages[0];
        ImageGrid.Anchor = (AnchorStyles.Left | AnchorStyles.Right | AnchorStyles.Top | AnchorStyles.Bottom);
        ImageGrid.Dock = DockStyle.Fill;
        ImageGrid.BackColor = SystemColors.Window;
        ImageGrid.Colors.BackColor = SystemColors.ButtonFace;
        ImageGrid.Colors.SelectedBorderColor = Color.Red;
        ImageGrid.BorderStyle = BorderStyle.Fixed3D;
        ImageGrid.ThumbnailSize = new System.Drawing.Size(32, 32);
        ImageGrid.ItemClick += (o, e) =>
        {
            string ID = (e.Item.FileName);
            label1.Text = ID;
            pictureBox1.Image = Wz.GetBmp("Item/Etc/" + ID.LeftStr(4) + ".img/" + ID + "/info/icon");
            string Name = "";
            if (Wz.HasNode("String/Etc.img"))
                Name = Wz.GetStr("String/Etc.img/Etc" + ID.IntID() + "/name");
            else if (Wz.HasNode("String/Item.img/Etc"))
                Name = Wz.GetStr("String/Item.img/Etc/" + ID.IntID() + "/name");
            label2.Text = Name;
        };

        ImageGrid.ItemHover += (o, e) =>
        {
            if (e.Item == null) return;
            Wz_Node Node = Wz.GetNodeByID(e.Item.FileName, WzType.Item);
            MainForm.Instance.QuickView(Node);
            MainForm.Instance.ToolTipView.Owner = this;
        };

        var Graphic = ImageGrid.CreateGraphics();
        var Font = new System.Drawing.Font(FontFamily.GenericSansSerif, 20, FontStyle.Bold);
        Graphic.DrawString("Loading...", Font, Brushes.Black, 10, 50);
        Win32.SendMessage(ImageGrid.Handle, false);
        Bitmap Bmp = null;
        foreach (var Img in Wz.GetNodes("Item/Etc"))
        {
            if (!Char.IsNumber(Img.Text[0]))
                continue;
            foreach (var Iter in Wz.GetNodes("Item/Etc/" + Img.Text))
            {
                if (Iter.HasNode("info/icon"))
                    Bmp = Iter.GetBmp("info/icon");
                ImageGrid.Items.Add(Iter.Text, Bmp);
            }
        }
        ImageGrid.Sort();
        Win32.SendMessage(ImageGrid.Handle, true);
        ImageGrid.Refresh();

    }

    private void tabControl1_SelectedIndexChanged(object sender, EventArgs e)
    {
        label1.Text = "";
        pictureBox1.Image = null;
        label2.Text = "";
        if (tabControl1.SelectedIndex == 1)
        {
            if (HasLoaded1)
                return;

            EtcListGrid = new(80, 185, 0, 20, 220, 530, true, tabControl1.TabPages[1]);
            EtcListGrid.Anchor = (AnchorStyles.Left | AnchorStyles.Right | AnchorStyles.Top | AnchorStyles.Bottom);
            EtcListGrid.Dock = DockStyle.Fill;
            tabControl1.TabPages[1].Padding = new Padding(0, 35, 0, 0);
            EtcListGrid.SearchGrid.Dock = DockStyle.Fill;
            EtcListGrid.RowTemplate.Height = 40;

            var Graphic = EtcListGrid.CreateGraphics();
            var Font = new System.Drawing.Font(FontFamily.GenericSansSerif, 20, FontStyle.Bold);
            Graphic.DrawString("Loading...", Font, Brushes.Black, 10, 50);
            void CellClick(BaseDataGridView DataGrid, DataGridViewCellEventArgs e)
            {
                string ID = DataGrid.Rows[e.RowIndex].Cells[0].Value.ToString();
                label1.Text = ID;
                pictureBox1.Image = (Bitmap)DataGrid.Rows[e.RowIndex].Cells[1].Value;
                label2.Text = DataGrid.Rows[e.RowIndex].Cells[2].Value.ToString();
            }

            EtcListGrid.CellClick += (s, e) =>
            {
                CellClick(EtcListGrid, e);
            };

            EtcListGrid.SearchGrid.CellClick += (s, e) =>
            {
                CellClick(EtcListGrid.SearchGrid, e);
            };

            EtcListGrid.SetToolTipEvent(WzType.Item, this);

            Win32.SendMessage(EtcListGrid.Handle, false);
            Bitmap Bmp = null;

            foreach (var Img in Wz.GetNodes("Item/Etc"))
            {
                if (!Char.IsNumber(Img.Text[0]))
                    continue;
                foreach (var Iter in Wz.GetNodes("Item/Etc/" + Img.Text))
                {
                    string ID = Iter.Text;
                    string IntID = ID.IntID();
                    string EtcName = "";
                    if (Wz.HasNode("String/Etc.img/Etc/" + IntID))
                        EtcName = Wz.GetStr("String/Etc.img/Etc/" + IntID + "/name");
                    else if (Wz.HasNode("String/Item.img/Etc"))
                        EtcName = Wz.GetStr("String/Item.img/Etc/" + IntID + "/name");
                    if (Iter.HasNode("info/icon"))
                        Bmp = Iter.GetBmp("info/icon");
                    EtcListGrid.Rows.Add(ID, Bmp, EtcName);
                }
            }

            Win32.SendMessage(EtcListGrid.Handle, true);
            EtcListGrid.Refresh();
            for (int i = 0; i < EtcListGrid.Rows.Count; i++)
            {
                EtcListGrid.Rows[i].Cells[1].Style.Alignment = DataGridViewContentAlignment.MiddleCenter;
                EtcListGrid.Rows[i].Cells[2].Style.Alignment = DataGridViewContentAlignment.TopLeft;
            }
            HasLoaded1 = true;

        }
    }

    private void textBox1_TextChanged(object sender, EventArgs e)
    {
        EtcListGrid.Search(textBox1.Text);
    }

    private void UseButton_Click(object sender, EventArgs e)
    {
        if (label1.Text.Trim(' ') != "")
            ItemDrop.Drop((int)Game.Player.X, (int)Game.Player.Y, 0, label1.Text.Trim(' '));
    }

    private void EtcForm_KeyDown(object sender, KeyEventArgs e)
    {
        if (e.Alt)
            e.Handled = true;
        if (!textBox1.Focused)
            ActiveControl = null;
    }

    private void EtcForm_FormClosing(object sender, FormClosingEventArgs e)
    {
        MainForm.Instance.ToolTipView.Visible = false;
    }
}

```

`MapleNecrocer/EtcForm.resx`:

```resx
<root>
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`MapleNecrocer/Extension.cs`:

```cs
using DevComponents.AdvTree;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WzComparerR2.WzLib;

namespace MapleNecrocer;

internal static class Extension
{
    public static Wz_Node AsWzNode(this Node node)
    {
        return (node?.Tag as WeakReference)?.Target as Wz_Node;
    }

    public static Dictionary<TKey, TValue> AddOrReplace<TKey, TValue>(this Dictionary<TKey, TValue> dict, TKey key, TValue value)
    {
        dict[key] = value;
        return dict;
    }
    public static string LeftStr(this string s, int count)
    {
        if (count > s.Length)
            count = s.Length;
        return s.Substring(0, count);
    }

    public static string RightStr(this string param, int length)
    {
        return param.Substring(param.Length - length, length);
    }

    public static bool ToBool(this int Value)
    {
        return Convert.ToBoolean(Value);
    }

    public static Int32 ToInt(this String number)
    {
        return Int32.Parse(number);
        
    }

    public static string IntID(this String Number)
    {
        return Number.ToInt().ToString();
    }
}

```

`MapleNecrocer/FamiliarForm.Designer.cs`:

```cs
namespace MapleNecrocer
{
    partial class FamiliarForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            panel1 = new Panel();
            textBox1 = new TextBox();
            label1 = new Label();
            button1 = new Button();
            SuspendLayout();
            // 
            // panel1
            // 
            panel1.Anchor = AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right;
            panel1.Location = new Point(3, 42);
            panel1.Name = "panel1";
            panel1.Size = new Size(348, 503);
            panel1.TabIndex = 0;
            // 
            // textBox1
            // 
            textBox1.Location = new Point(77, 12);
            textBox1.Name = "textBox1";
            textBox1.Size = new Size(113, 23);
            textBox1.TabIndex = 1;
            textBox1.TextChanged += textBox1_TextChanged;
            // 
            // label1
            // 
            label1.AutoSize = true;
            label1.Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            label1.Location = new Point(14, 15);
            label1.Name = "label1";
            label1.Size = new Size(52, 18);
            label1.TabIndex = 2;
            label1.Text = "Search";
            // 
            // button1
            // 
            button1.Location = new Point(257, 8);
            button1.Name = "button1";
            button1.Size = new Size(79, 28);
            button1.TabIndex = 3;
            button1.Text = "Remove";
            button1.UseVisualStyleBackColor = true;
            button1.Click += button1_Click;
            // 
            // FamiliarForm
            // 
            AutoScaleMode = AutoScaleMode.None;
            ClientSize = new Size(359, 559);
            Controls.Add(button1);
            Controls.Add(label1);
            Controls.Add(textBox1);
            Controls.Add(panel1);
            Font = new Font("Tahoma", 13F, FontStyle.Regular, GraphicsUnit.Pixel);
            KeyPreview = true;
            MaximumSize = new Size(377, 1000);
            Name = "FamiliarForm";
            StartPosition = FormStartPosition.CenterScreen;
            Text = "Familiar";
            TopMost = true;
            Shown += FamiliarForm_Shown;
            KeyDown += FamiliarForm_KeyDown;
            ResumeLayout(false);
            PerformLayout();
        }

        #endregion

        private Panel panel1;
        private TextBox textBox1;
        private Label label1;
        private Button button1;
    }
}
```

`MapleNecrocer/FamiliarForm.cs`:

```cs

namespace MapleNecrocer;

public partial class FamiliarForm : Form
{
    public FamiliarForm()
    {
        InitializeComponent();
        Instance = this;
    }
    public static FamiliarForm Instance;
    public DataGridViewEx FamiliarListGrid;

    void CellClick(BaseDataGridView DataGrid, DataGridViewCellEventArgs e)
    {
        string ID = DataGrid.Rows[e.RowIndex].Cells[0].Value.ToString();
        if (Wz.HasNode("Etc/FamiliarInfo.img/" + ID + "/mob"))
            ID = Wz.GetStr("Etc/FamiliarInfo.img/" + ID + "/mob");
        else
            ID = Wz.GetStr("Character/Familiar/" + ID + ".img/" + "info/MobID");
        Familiar.Remove();
        ID = ID.PadLeft(7, '0');
        Familiar.Create(ID);
        FamiliarNameTag.Remove();
        FamiliarNameTag.Create("");
        FamiliarNameTag.MobName = Wz.GetStr("String/Mob.img/" + ID + "/name", ID);
        FamiliarNameTag.ReDraw = true;

    }
    private void FamiliarForm_Shown(object sender, EventArgs e)
    {
        this.FormClosing += (s, e1) =>
        {
            this.Hide();
            e1.Cancel = true;
        };
        FamiliarListGrid = new(80, 185, 0, 0, 220, 400, true, panel1);
        FamiliarListGrid.Dock = DockStyle.Fill;
        FamiliarListGrid.SearchGrid.Dock = DockStyle.Fill;
        FamiliarListGrid.RowTemplate.Height = 40;
     

        var Graphic = FamiliarListGrid.CreateGraphics();
        var Font = new System.Drawing.Font(FontFamily.GenericSansSerif, 20, FontStyle.Bold);
        Graphic.DrawString("Loading...", Font, Brushes.Black, 10, 50);
        FamiliarListGrid.CellClick += (s, e) =>
        {
            CellClick(FamiliarListGrid, e);
        };

        FamiliarListGrid.SearchGrid.CellClick += (s, e) =>
        {
            CellClick(FamiliarListGrid.SearchGrid, e);
        };


        string CardName = "";
        Bitmap Bmp = null;
        foreach (var Img in Wz.GetNodes("Character/Familiar"))
        {
           if(Img.Text.RightStr(4)!=".img")
                continue;
            string ID = Img.ImgID();
            string CardID = "";

            if (Wz.HasNode("Etc/FamiliarInfo.img/" + ID))
            {
                CardID = Wz.GetStr("Etc/FamiliarInfo.img/" + ID + "/consume");
            }
            else if (Wz.HasNode("Character/Familiar/" + Img.Text + "/info/monsterCardID"))
            {
                CardID = Wz.GetStr("Character/Familiar/" + Img.Text + "/info/monsterCardID");
            }
            else
                continue;

            if (Wz.HasNode("String/Consume.img/" + CardID))
                CardName = Wz.GetStr("String/Consume.img/" + CardID + "/name");
            if (Wz.HasNode("Item/Consume/0287.img/" + "0" + CardID + "/info/icon"))
                Bmp = Wz.GetBmp("Item/Consume/0287.img/" + "0" + CardID + "/info/icon");
            else if (Wz.HasNode("Item/Consume/0238.img/" + "0" + CardID + "/info/iconRaw"))
                Bmp = Wz.GetBmp("Item/Consume/0238.img/" + "0" + CardID + "/info/iconRaw");
            FamiliarListGrid.Rows.Add(ID, Bmp, CardName);
        }
        for (int i = 0; i < FamiliarListGrid.Rows.Count; i++)
        {
            FamiliarListGrid.Rows[i].Cells[1].Style.Alignment = DataGridViewContentAlignment.MiddleCenter;
            FamiliarListGrid.Rows[i].Cells[2].Style.Alignment = DataGridViewContentAlignment.TopLeft;
        }

    }

    private void FamiliarForm_KeyDown(object sender, KeyEventArgs e)
    {
        if (e.Alt)
            e.Handled = true;
        if (!textBox1.Focused)
            ActiveControl = null;
    }

    private void textBox1_TextChanged(object sender, EventArgs e)
    {
        FamiliarListGrid.Search(textBox1.Text);
    }

    private void button1_Click(object sender, EventArgs e)
    {
        FamiliarNameTag.Remove();
        Familiar.Remove();
    }
}

```

`MapleNecrocer/FamiliarForm.resx`:

```resx
<root>
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`MapleNecrocer/FrameListDraw.cs`:

```cs
using Microsoft.Xna.Framework;
using MonoGame.Forms.Controls;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using Microsoft.Xna.Framework;
using Color = Microsoft.Xna.Framework.Color;
using DevComponents.DotNetBar;

using Microsoft.Xna.Framework.Graphics;
using System.Drawing;
using WzComparerR2.CharaSim;

namespace MapleNecrocer;

public class FrameListDraw : MonoGameControl
{
    public FrameListDraw()
    {
        Instance = this;
    }
    public static FrameListDraw Instance;
    public static RenderTarget2D AvatarPanelTexture;
    private static RenderTarget2D CheckBoardTexture;

    protected override void Initialize()
    {

        base.Initialize();

        EngineFunc.Canvas.DrawTarget(ref CheckBoardTexture, 512, 512, () =>
        {
            for (int J = 0; J < 512; J++)
            {
                for (int I = 0; I < 512; I++)
                {
                    if ((I == 0) || (J == 0) || (I == 511) || (J == 511))
                        EngineFunc.Canvas.Pixel(I, J, new Color(0, 0, 0));
                    else if (((I / 8) + (J / 8)) % 2 == 0)  // put checkboard pattern
                        EngineFunc.Canvas.Pixel(I, J, new Color(205, 205, 205));
                    else
                        EngineFunc.Canvas.Pixel(I, J, new Color(255, 255, 255));
                }
            }
        });

        EngineFunc.Canvas.DrawTarget(ref AvatarPanelTexture, 4096, 4096, () => { });
        this.SetMultiSampleCount(0);
    }
    int xx;
    protected override void Update(GameTime gameTime)
    {
        EngineFunc.Canvas.GraphicsDevice.SetRenderTarget(AvatarPanelTexture);
        EngineFunc.Canvas.GraphicsDevice.Clear(Microsoft.Xna.Framework.Color.Transparent);
        EngineFunc.SpriteEngine.DrawEx("Player", "ItemEffect", "SetEffect");
        EngineFunc.Canvas.GraphicsDevice.SetRenderTarget(null);
       
    }

    protected override void Draw()
    {
        EngineFunc.Canvas.Draw(CheckBoardTexture, 0, 0);
        // Editor.graphics.Clear(Color.Aqua);
        int WX = (int)(Game.Player.X - EngineFunc.SpriteEngine.Camera.X - 155);
        int WY = (int)(Game.Player.Y - EngineFunc.SpriteEngine.Camera.Y - 160);
        EngineFunc.Canvas.DrawCropArea(AvatarPanelTexture, 100, 150, new Microsoft.Xna.Framework.Rectangle(WX, WY, WX + 250, WY + 230), 0, 0, 1, 1, 0, false, false, 255, 255, 255, 255, false, BlendMode.NonPremultiplied2);
        EngineFunc.Canvas.DrawRectangle(100 + AvatarForm.AdjustX, 150 + AvatarForm.AdjustY, AvatarForm.AdjustW, AvatarForm.AdjustH,
              new Color(255,0, 0));
    }

}


```

`MapleNecrocer/GraphicsExtension.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Drawing.Imaging;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security.Cryptography.Xml;
using System.Text;
using System.Threading.Tasks;
using DPIUtils;
using MapleNecrocer;
namespace GraphicsExtension;

public static class GraphicsExtension
{
    public static float DPIScale = 96 * (float)DPIUtil.ScaleFactor(MainForm.Instance, new Point(0, 0));

    public static void DrawImage2(this Graphics g, Image Image, int X, int Y)
    {
        Bitmap Bmp = Image as Bitmap;
        Bmp.SetResolution(DPIUtil.dpiX, DPIUtil.dpiY);
        g.DrawImage(Bmp, X, Y);
    }
    public static void DrawImage2(
       this Graphics g,
       Image Image,
       Rectangle destRect,
       int srcX,
       int srcY,
       int srcWidth,
       int srcHeight,
       GraphicsUnit srcUnit,
       ImageAttributes? imageAttr)
    {
        Bitmap Bmp = Image as Bitmap;
        Bmp.SetResolution(DPIUtil.dpiX, DPIUtil.dpiY);
        g.DrawImage(Bmp, destRect, srcX, srcY, srcWidth, srcHeight, srcUnit, imageAttr, null);
    }

    public static void DrawImage2(
      this Graphics g,
      Image Image,
      int X,
      int Y,
      Rectangle srcRect,
      GraphicsUnit srcUnit
      )
    {
        Bitmap Bmp = Image as Bitmap;
        Bmp.SetResolution(DPIUtil.dpiX, DPIUtil.dpiY);
        g.DrawImage(Bmp, new Rectangle(X, Y, srcRect.Width, srcRect.Height), srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height, srcUnit,  null);
    }

}

```

`MapleNecrocer/ImageFilter.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Drawing.Imaging;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Bitmap = System.Drawing.Bitmap;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using MonoGame.SpriteEngine;
using AForge;
using AForge.Imaging.Filters;
namespace MapleNecrocer;




internal  class ImageFilter
{
     public ImageFilter()
    {


    }

    private static HSLLinear DarkFilter = new HSLLinear();
    private static LevelsLinear BrightFilter = new LevelsLinear();


    public static void HSL(ref System.Drawing.Bitmap img, int Hue, int Saturation = 0, int Lightness = 0)
    {    
        const double c1o60 = 1 / (double)60;
        const double c1o255 = 1 / (double)255;
        Bitmap result = new Bitmap(img);
        result.SetResolution(img.HorizontalResolution, img.VerticalResolution);
        BitmapData bmpData = result.LockBits(new System.Drawing.Rectangle(0, 0, result.Width, result.Height), ImageLockMode.ReadWrite, img.PixelFormat);
        int pixelBytes = System.Drawing.Image.GetPixelFormatSize(img.PixelFormat) / 8;
        // Get the address of the first line.
        IntPtr ptr = bmpData.Scan0;
        int size = bmpData.Stride * result.Height;
        byte[] pixels = new byte[size - 1 + 1];
        int index;
        double R, G, B;
        double H, S, L, H1;
        double min, max, dif, sum;
        double f1, f2;
        double v1, v2, v3;
        double sat = 255 * Saturation / 100;//255 * Saturation / 100;
        double lum = 127 * 0 / 100;//127 * Lightness / 100;
        // Copy the RGB values into the array.
        System.Runtime.InteropServices.Marshal.Copy(ptr, pixels, 0, size);
        // Main loop.
        for (int row = 0; row <= result.Height - 1; row++)
        {
            for (int col = 0; col <= result.Width - 1; col++)
            {
                index = (row * bmpData.Stride) + (col * pixelBytes);
                R = pixels[index + 2];
                G = pixels[index + 1];
                B = pixels[index + 0];
                // Conversion to HSL space.
                min = R;
                if ((G < min))
                    min = G;
                if ((B < min))
                    min = B;
                max = R; f1 = 0.0; f2 = G - B;
                if ((G > max))
                {
                    max = G; f1 = 120.0; f2 = B - R;
                }
                if ((B > max))
                {
                    max = B; f1 = 240.0; f2 = R - G;
                }
                dif = max - min;
                sum = max + min;
                L = 0.5 * sum;
                if ((dif == 0))
                {
                    H = 0.0; S = 0.0;
                }
                else
                {
                      if ((L < 127.5))
                        S = 255.0 * dif / sum;
                    else
                        S = 255.0 * dif / (510.0 - sum);
                    H = (f1 + 60.0 * f2 / dif);
                    if (H < 0.0)
                        H += 360.0;
                    if (H >= 360.0)
                        H -= 360.0;
                }
                // Apply transformation.
                H = H + Hue;
                if (H >= 360.0)
                    H = H - 360.0;
                S = S + sat;
                if (S < 0.0)
                    S = 0.0;
                if (S > 255.0)
                    S = 255.0;
                L = L + lum;
                if (L < 0.0)
                    L = 0.0;
                if (L > 255.0)
                    L = 255.0;
                // Conversion back to RGB space.
                if ((S == 0))
                {
                    R = L; G = L; B = L;
                }
                else
                {
                     if ((L < 127.5))
                        v2 = c1o255 * L * (255 + S);
                    else
                        v2 = L + S - c1o255 * S * L;
                    v1 = 2 * L - v2;
                    v3 = v2 - v1;
                    H1 = H + 120.0;
                    if ((H1 >= 360.0))
                        H1 -= 360.0;
                    if ((H1 < 60.0))
                        R = v1 + v3 * H1 * c1o60;
                    else if ((H1 < 180.0))
                        R = v2;
                    else if ((H1 < 240.0))
                        R = v1 + v3 * (4 - H1 * c1o60);
                    else
                        R = v1;
                    H1 = H;
                    if ((H1 < 60.0))
                        G = v1 + v3 * H1 * c1o60;
                    else if ((H1 < 180.0))
                        G = v2;
                    else if ((H1 < 240.0))
                        G = v1 + v3 * (4 - H1 * c1o60);
                    else
                        G = v1;
                    H1 = H - 120.0;
                    if ((H1 < 0.0))
                        H1 += 360.0;
                    if ((H1 < 60.0))
                        B = v1 + v3 * H1 * c1o60;
                    else if ((H1 < 180.0))
                        B = v2;
                    else if ((H1 < 240.0))
                        B = v1 + v3 * (4 - H1 * c1o60);
                    else
                        B = v1;
                }
                // Save new values.
                pixels[index + 2] = System.Convert.ToByte(R);
                pixels[index + 1] = System.Convert.ToByte(G);
                pixels[index + 0] = System.Convert.ToByte(B);
            }
        }
        // Copy the RGB values back to the bitmap
        System.Runtime.InteropServices.Marshal.Copy(pixels, 0, ptr, size);
        // Unlock the bits.
        result.UnlockBits(bmpData);

        if (Lightness > 0)
        {
            BrightFilter.InBlue = new IntRange(0, 255);
            BrightFilter.InGreen = new IntRange(0, 255);
            BrightFilter.InRed = new IntRange(0, 255);
            BrightFilter.OutRed = new IntRange((int)(Lightness * 2.55f), 255);
            BrightFilter.OutGreen = new IntRange((int)(Lightness * 2.55f), 255);
            BrightFilter.OutBlue = new IntRange((int)(Lightness * 2.55f), 255);
            BrightFilter.Apply2(ref result);


        }
        if (Lightness < 0)
        {
            DarkFilter.InSaturation = new AForge.Range(0, 1);
            DarkFilter.OutSaturation = new AForge.Range(0, 1);
            DarkFilter.InLuminance = new AForge.Range(-Lightness * 0.01f * 0.6f, 1);
            DarkFilter.Apply2(ref result);
        }

        img = result;
        //  return result;

    }

   
    public static Texture2D GetHSL(GraphicsDevice dev,Bitmap Bmp, int Hue, int Saturation = 0, int Lightness = 0)
    {
        HSL(ref Bmp, Hue, Saturation, Lightness);
        int[] imgData = new int[Bmp.Width * Bmp.Height];
        Texture2D Texture = new Texture2D(dev, Bmp.Width, Bmp.Height);
        unsafe
        {
            // lock bitmap
            System.Drawing.Imaging.BitmapData origdata =
                Bmp.LockBits(new System.Drawing.Rectangle(0, 0, Bmp.Width, Bmp.Height), System.Drawing.Imaging.ImageLockMode.ReadOnly, Bmp.PixelFormat);
            uint* byteData = (uint*)origdata.Scan0;
            // Switch bgra -> rgba
            for (int i = 0; i < imgData.Length; i++)
            {
                byteData[i] = (byteData[i] & 0x000000ff) << 16 | (byteData[i] & 0x0000FF00) | (byteData[i] & 0x00FF0000) >> 16 | (byteData[i] & 0xFF000000);
            }
            // copy data
            System.Runtime.InteropServices.Marshal.Copy(origdata.Scan0, imgData, 0, Bmp.Width * Bmp.Height);
            byteData = null;
            // unlock bitmap
            Bmp.UnlockBits(origdata);
        }
        Texture.SetData(imgData);
        return Texture;

    }

}


public static class AForgeExtension
{
    public static void Apply2(this HSLLinear filter, ref Bitmap image)
    {
        BitmapData srcData = image.LockBits(
          new System.Drawing.Rectangle(0, 0, image.Width, image.Height),
          ImageLockMode.ReadOnly, image.PixelFormat);

        Bitmap dstImage = null;

        try
        {
            // apply the filter
            dstImage = filter.Apply(srcData);
            if ((image.HorizontalResolution > 0) && (image.VerticalResolution > 0))
            {
                dstImage.SetResolution(image.HorizontalResolution, image.VerticalResolution);
            }
        }
        finally
        {
            // unlock source image
            image.UnlockBits(srcData);
        }
        image = dstImage;
    }

    public static void Apply2(this LevelsLinear filter, ref Bitmap image)
    {
        BitmapData srcData = image.LockBits(
          new System.Drawing.Rectangle(0, 0, image.Width, image.Height),
          ImageLockMode.ReadOnly, image.PixelFormat);

        Bitmap dstImage = null;

        try
        {
            // apply the filter
            dstImage = filter.Apply(srcData);
            if ((image.HorizontalResolution > 0) && (image.VerticalResolution > 0))
            {
                dstImage.SetResolution(image.HorizontalResolution, image.VerticalResolution);
            }
        }
        finally
        {
            // unlock source image
            image.UnlockBits(srcData);
        }
        image = dstImage;
    }
}

```

`MapleNecrocer/MainForm.Designer.cs`:

```cs

namespace MapleNecrocer
{
    partial class MainForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(MainForm));
            OpenFolderButton = new Button();
            pictureBox1 = new PictureBox();
            SearchMapBox = new TextBox();
            tabControl1 = new TabControl();
            tabPage1 = new TabPage();
            tabPage2 = new TabPage();
            WorldMapListGrid = new DataGridView();
            LoadMapButton = new Button();
            comboBox2 = new ComboBox();
            comboBox1 = new ComboBox();
            label1 = new Label();
            label2 = new Label();
            label3 = new Label();
            panel1 = new Panel();
            ChatRingButton = new Button();
            EffectRingButton = new Button();
            ReactorButton = new Button();
            SoulEffectButton = new Button();
            TotemEffectButton = new Button();
            EtcButton = new Button();
            CashButton = new Button();
            ConsumeButton = new Button();
            OptionButton = new Button();
            AndroidButton = new Button();
            FamiliarButton = new Button();
            PetButton = new Button();
            RingButton = new Button();
            TitleButton = new Button();
            MedalButton = new Button();
            ObjInfoButton = new Button();
            DamageSkinButton = new Button();
            MorphButton = new Button();
            CashEffectButton = new Button();
            MountButton = new Button();
            NpcButton = new Button();
            ScaleButton = new Button();
            SkillButton = new Button();
            FullScreenButton = new Button();
            ChairButton = new Button();
            MobButton = new Button();
            AvatarButton = new Button();
            SaveMapButton = new Button();
            ViewButton = new Button();
            label4 = new Label();
            ((System.ComponentModel.ISupportInitialize)pictureBox1).BeginInit();
            tabControl1.SuspendLayout();
            tabPage2.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)WorldMapListGrid).BeginInit();
            panel1.SuspendLayout();
            SuspendLayout();
            // 
            // OpenFolderButton
            // 
            OpenFolderButton.Font = new Font("Verdana", 7F, FontStyle.Regular, GraphicsUnit.Point);
            OpenFolderButton.Location = new Point(204, 6);
            OpenFolderButton.Name = "OpenFolderButton";
            OpenFolderButton.Size = new Size(41, 23);
            OpenFolderButton.TabIndex = 0;
            OpenFolderButton.Text = "...";
            OpenFolderButton.TextAlign = ContentAlignment.TopCenter;
            OpenFolderButton.UseVisualStyleBackColor = true;
            OpenFolderButton.Click += OpenFolderButton_Click;
            // 
            // pictureBox1
            // 
            pictureBox1.BorderStyle = BorderStyle.FixedSingle;
            pictureBox1.Location = new Point(8, 33);
            pictureBox1.Name = "pictureBox1";
            pictureBox1.Size = new Size(236, 137);
            pictureBox1.TabIndex = 1;
            pictureBox1.TabStop = false;
            // 
            // SearchMapBox
            // 
            SearchMapBox.Location = new Point(61, 206);
            SearchMapBox.Name = "SearchMapBox";
            SearchMapBox.Size = new Size(183, 25);
            SearchMapBox.TabIndex = 2;
            SearchMapBox.TextChanged += SerachMapBox_TextChanged;
            // 
            // tabControl1
            // 
            tabControl1.Anchor = AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left;
            tabControl1.Controls.Add(tabPage1);
            tabControl1.Controls.Add(tabPage2);
            tabControl1.Enabled = false;
            tabControl1.Location = new Point(8, 241);
            tabControl1.Name = "tabControl1";
            tabControl1.Padding = new Point(6, 1);
            tabControl1.SelectedIndex = 0;
            tabControl1.Size = new Size(240, 415);
            tabControl1.TabIndex = 4;
            tabControl1.SelectedIndexChanged += tabControl1_SelectedIndexChanged;
            // 
            // tabPage1
            // 
            tabPage1.Location = new Point(4, 25);
            tabPage1.Name = "tabPage1";
            tabPage1.Padding = new Padding(0, 2, 2, 1);
            tabPage1.Size = new Size(232, 386);
            tabPage1.TabIndex = 0;
            tabPage1.Text = "Map";
            tabPage1.UseVisualStyleBackColor = true;
            // 
            // tabPage2
            // 
            tabPage2.Controls.Add(WorldMapListGrid);
            tabPage2.Location = new Point(4, 26);
            tabPage2.Name = "tabPage2";
            tabPage2.Padding = new Padding(3);
            tabPage2.Size = new Size(232, 385);
            tabPage2.TabIndex = 1;
            tabPage2.Text = "World Map";
            tabPage2.UseVisualStyleBackColor = true;
            // 
            // WorldMapListGrid
            // 
            WorldMapListGrid.AllowUserToAddRows = false;
            WorldMapListGrid.AllowUserToDeleteRows = false;
            WorldMapListGrid.AllowUserToResizeColumns = false;
            WorldMapListGrid.AllowUserToResizeRows = false;
            WorldMapListGrid.BackgroundColor = SystemColors.ButtonHighlight;
            WorldMapListGrid.CellBorderStyle = DataGridViewCellBorderStyle.None;
            WorldMapListGrid.ColumnHeadersHeightSizeMode = DataGridViewColumnHeadersHeightSizeMode.AutoSize;
            WorldMapListGrid.ColumnHeadersVisible = false;
            WorldMapListGrid.Dock = DockStyle.Fill;
            WorldMapListGrid.Location = new Point(3, 3);
            WorldMapListGrid.MultiSelect = false;
            WorldMapListGrid.Name = "WorldMapListGrid";
            WorldMapListGrid.RowHeadersVisible = false;
            WorldMapListGrid.RowHeadersWidth = 51;
            WorldMapListGrid.RowHeadersWidthSizeMode = DataGridViewRowHeadersWidthSizeMode.DisableResizing;
            WorldMapListGrid.RowTemplate.Height = 25;
            WorldMapListGrid.ScrollBars = ScrollBars.Vertical;
            WorldMapListGrid.ShowCellToolTips = false;
            WorldMapListGrid.ShowEditingIcon = false;
            WorldMapListGrid.ShowRowErrors = false;
            WorldMapListGrid.Size = new Size(226, 379);
            WorldMapListGrid.TabIndex = 2;
            WorldMapListGrid.CellClick += WorldMapListGrid_CellClick;
            // 
            // LoadMapButton
            // 
            LoadMapButton.Enabled = false;
            LoadMapButton.Location = new Point(8, 174);
            LoadMapButton.Name = "LoadMapButton";
            LoadMapButton.Size = new Size(236, 28);
            LoadMapButton.TabIndex = 5;
            LoadMapButton.Text = "Load Map";
            LoadMapButton.UseVisualStyleBackColor = true;
            LoadMapButton.Click += LoadMapButton_Click;
            // 
            // comboBox2
            // 
            comboBox2.Font = new Font("Arial", 13F, FontStyle.Regular, GraphicsUnit.Pixel);
            comboBox2.FormattingEnabled = true;
            comboBox2.Items.AddRange(new object[] { "800X600", "1024X768", "1280X720", "1280X800", "1280X1024", "1360X768", "1366X768", "1440X900", "1600X900", "1600X1200", "1680X1050", "1920X1080", "1920X1200", "2048X1152", "2048X1536", "2560X1080", "2560X1440", "2560X1600", "3440X1440", "3840X2160" });
            comboBox2.Location = new Point(306, 36);
            comboBox2.Name = "comboBox2";
            comboBox2.Size = new Size(99, 24);
            comboBox2.TabIndex = 6;
            comboBox2.SelectedIndexChanged += comboBox2_SelectedIndexChanged;
            comboBox2.Click += comboBox2_Click;
            // 
            // comboBox1
            // 
            comboBox1.Font = new Font("Arial", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            comboBox1.FormattingEnabled = true;
            comboBox1.Items.AddRange(new object[] { "Play Mode", "Viewer Mode" });
            comboBox1.Location = new Point(306, 7);
            comboBox1.Name = "comboBox1";
            comboBox1.Size = new Size(99, 24);
            comboBox1.TabIndex = 7;
            comboBox1.Text = "Play Mode";
            comboBox1.SelectedIndexChanged += comboBox1_SelectedIndexChanged;
            // 
            // label1
            // 
            label1.AutoSize = true;
            label1.Font = new Font("Arial", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            label1.Location = new Point(257, 8);
            label1.Name = "label1";
            label1.Size = new Size(43, 17);
            label1.TabIndex = 8;
            label1.Text = "Mode";
            // 
            // label2
            // 
            label2.AutoSize = true;
            label2.Font = new Font("Arial", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            label2.Location = new Point(257, 42);
            label2.Name = "label2";
            label2.Size = new Size(37, 17);
            label2.TabIndex = 9;
            label2.Text = "Size";
            // 
            // label3
            // 
            label3.AutoSize = true;
            label3.Font = new Font("Arial", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            label3.Location = new Point(8, 210);
            label3.Name = "label3";
            label3.Size = new Size(55, 17);
            label3.TabIndex = 10;
            label3.Text = "Search";
            label3.TextAlign = ContentAlignment.MiddleLeft;
            // 
            // panel1
            // 
            panel1.Anchor = AnchorStyles.Top | AnchorStyles.Left | AnchorStyles.Right;
            panel1.AutoScroll = true;
            panel1.BorderStyle = BorderStyle.FixedSingle;
            panel1.Controls.Add(ChatRingButton);
            panel1.Controls.Add(EffectRingButton);
            panel1.Controls.Add(ReactorButton);
            panel1.Controls.Add(SoulEffectButton);
            panel1.Controls.Add(TotemEffectButton);
            panel1.Controls.Add(EtcButton);
            panel1.Controls.Add(CashButton);
            panel1.Controls.Add(ConsumeButton);
            panel1.Controls.Add(OptionButton);
            panel1.Controls.Add(AndroidButton);
            panel1.Controls.Add(FamiliarButton);
            panel1.Controls.Add(PetButton);
            panel1.Controls.Add(RingButton);
            panel1.Controls.Add(TitleButton);
            panel1.Controls.Add(MedalButton);
            panel1.Controls.Add(ObjInfoButton);
            panel1.Controls.Add(DamageSkinButton);
            panel1.Controls.Add(MorphButton);
            panel1.Controls.Add(CashEffectButton);
            panel1.Controls.Add(MountButton);
            panel1.Controls.Add(NpcButton);
            panel1.Controls.Add(ScaleButton);
            panel1.Controls.Add(SkillButton);
            panel1.Controls.Add(FullScreenButton);
            panel1.Controls.Add(ChairButton);
            panel1.Controls.Add(MobButton);
            panel1.Controls.Add(AvatarButton);
            panel1.Controls.Add(SaveMapButton);
            panel1.Controls.Add(ViewButton);
            panel1.Location = new Point(442, 5);
            panel1.Name = "panel1";
            panel1.Size = new Size(723, 78);
            panel1.TabIndex = 11;
            // 
            // ChatRingButton
            // 
            ChatRingButton.AutoSize = true;
            ChatRingButton.Enabled = false;
            ChatRingButton.Font = new Font("Microsoft JhengHei UI", 12F, FontStyle.Regular, GraphicsUnit.Pixel);
            ChatRingButton.Image = (Image)resources.GetObject("ChatRingButton.Image");
            ChatRingButton.ImageAlign = ContentAlignment.TopCenter;
            ChatRingButton.Location = new Point(2120, 1);
            ChatRingButton.Name = "ChatRingButton";
            ChatRingButton.RightToLeft = RightToLeft.No;
            ChatRingButton.Size = new Size(78, 52);
            ChatRingButton.TabIndex = 28;
            ChatRingButton.Text = "ChatRing";
            ChatRingButton.TextAlign = ContentAlignment.BottomCenter;
            ChatRingButton.UseVisualStyleBackColor = true;
            ChatRingButton.Click += MobButton_Click;
            // 
            // EffectRingButton
            // 
            EffectRingButton.AutoSize = true;
            EffectRingButton.Enabled = false;
            EffectRingButton.Font = new Font("Microsoft JhengHei UI", 12F, FontStyle.Regular, GraphicsUnit.Pixel);
            EffectRingButton.Image = (Image)resources.GetObject("EffectRingButton.Image");
            EffectRingButton.ImageAlign = ContentAlignment.TopCenter;
            EffectRingButton.Location = new Point(2042, 1);
            EffectRingButton.Name = "EffectRingButton";
            EffectRingButton.RightToLeft = RightToLeft.No;
            EffectRingButton.Size = new Size(78, 52);
            EffectRingButton.TabIndex = 27;
            EffectRingButton.Text = "EffectRing";
            EffectRingButton.TextAlign = ContentAlignment.BottomCenter;
            EffectRingButton.UseVisualStyleBackColor = true;
            EffectRingButton.Click += MobButton_Click;
            // 
            // ReactorButton
            // 
            ReactorButton.AutoSize = true;
            ReactorButton.Enabled = false;
            ReactorButton.Font = new Font("Microsoft JhengHei UI", 12F, FontStyle.Regular, GraphicsUnit.Pixel);
            ReactorButton.Image = (Image)resources.GetObject("ReactorButton.Image");
            ReactorButton.ImageAlign = ContentAlignment.TopCenter;
            ReactorButton.Location = new Point(1965, 1);
            ReactorButton.Name = "ReactorButton";
            ReactorButton.RightToLeft = RightToLeft.No;
            ReactorButton.Size = new Size(76, 52);
            ReactorButton.TabIndex = 26;
            ReactorButton.Text = "Reactor";
            ReactorButton.TextAlign = ContentAlignment.BottomCenter;
            ReactorButton.UseVisualStyleBackColor = true;
            ReactorButton.Click += MobButton_Click;
            // 
            // SoulEffectButton
            // 
            SoulEffectButton.AutoSize = true;
            SoulEffectButton.Enabled = false;
            SoulEffectButton.Font = new Font("Microsoft JhengHei UI", 12F, FontStyle.Regular, GraphicsUnit.Pixel);
            SoulEffectButton.Image = (Image)resources.GetObject("SoulEffectButton.Image");
            SoulEffectButton.ImageAlign = ContentAlignment.TopCenter;
            SoulEffectButton.Location = new Point(1890, 1);
            SoulEffectButton.Name = "SoulEffectButton";
            SoulEffectButton.RightToLeft = RightToLeft.No;
            SoulEffectButton.Size = new Size(76, 52);
            SoulEffectButton.TabIndex = 25;
            SoulEffectButton.Text = "Soul Eff";
            SoulEffectButton.TextAlign = ContentAlignment.BottomCenter;
            SoulEffectButton.UseVisualStyleBackColor = true;
            SoulEffectButton.Click += MobButton_Click;
            // 
            // TotemEffectButton
            // 
            TotemEffectButton.AutoSize = true;
            TotemEffectButton.Enabled = false;
            TotemEffectButton.Font = new Font("Microsoft JhengHei UI", 12F, FontStyle.Regular, GraphicsUnit.Pixel);
            TotemEffectButton.Image = (Image)resources.GetObject("TotemEffectButton.Image");
            TotemEffectButton.ImageAlign = ContentAlignment.TopCenter;
            TotemEffectButton.Location = new Point(1815, 1);
            TotemEffectButton.Name = "TotemEffectButton";
            TotemEffectButton.RightToLeft = RightToLeft.No;
            TotemEffectButton.Size = new Size(76, 52);
            TotemEffectButton.TabIndex = 24;
            TotemEffectButton.Text = "Totem Eff";
            TotemEffectButton.TextAlign = ContentAlignment.BottomCenter;
            TotemEffectButton.UseVisualStyleBackColor = true;
            TotemEffectButton.Click += MobButton_Click;
            // 
            // EtcButton
            // 
            EtcButton.AutoSize = true;
            EtcButton.Enabled = false;
            EtcButton.Font = new Font("Microsoft JhengHei UI", 12F, FontStyle.Regular, GraphicsUnit.Pixel);
            EtcButton.Image = (Image)resources.GetObject("EtcButton.Image");
            EtcButton.ImageAlign = ContentAlignment.TopCenter;
            EtcButton.Location = new Point(1740, 1);
            EtcButton.Name = "EtcButton";
            EtcButton.RightToLeft = RightToLeft.No;
            EtcButton.Size = new Size(76, 52);
            EtcButton.TabIndex = 23;
            EtcButton.Text = "Etc";
            EtcButton.TextAlign = ContentAlignment.BottomCenter;
            EtcButton.UseVisualStyleBackColor = true;
            EtcButton.Click += MobButton_Click;
            // 
            // CashButton
            // 
            CashButton.AutoSize = true;
            CashButton.Enabled = false;
            CashButton.Font = new Font("Microsoft JhengHei UI", 12F, FontStyle.Regular, GraphicsUnit.Pixel);
            CashButton.Image = (Image)resources.GetObject("CashButton.Image");
            CashButton.ImageAlign = ContentAlignment.TopCenter;
            CashButton.Location = new Point(1665, 1);
            CashButton.Name = "CashButton";
            CashButton.RightToLeft = RightToLeft.No;
            CashButton.Size = new Size(76, 52);
            CashButton.TabIndex = 22;
            CashButton.Text = "Cash";
            CashButton.TextAlign = ContentAlignment.BottomCenter;
            CashButton.UseVisualStyleBackColor = true;
            CashButton.Click += MobButton_Click;
            // 
            // ConsumeButton
            // 
            ConsumeButton.AutoSize = true;
            ConsumeButton.Enabled = false;
            ConsumeButton.Font = new Font("Microsoft JhengHei UI", 12F, FontStyle.Regular, GraphicsUnit.Pixel);
            ConsumeButton.Image = (Image)resources.GetObject("ConsumeButton.Image");
            ConsumeButton.ImageAlign = ContentAlignment.TopCenter;
            ConsumeButton.Location = new Point(1589, 1);
            ConsumeButton.Name = "ConsumeButton";
            ConsumeButton.RightToLeft = RightToLeft.No;
            ConsumeButton.Size = new Size(76, 52);
            ConsumeButton.TabIndex = 21;
            ConsumeButton.Text = "Consume";
            ConsumeButton.TextAlign = ContentAlignment.BottomCenter;
            ConsumeButton.UseVisualStyleBackColor = true;
            ConsumeButton.Click += MobButton_Click;
            // 
            // OptionButton
            // 
            OptionButton.AutoSize = true;
            OptionButton.Enabled = false;
            OptionButton.Font = new Font("Microsoft JhengHei UI", 12F, FontStyle.Regular, GraphicsUnit.Pixel);
            OptionButton.ImageAlign = ContentAlignment.TopCenter;
            OptionButton.Location = new Point(1519, 1);
            OptionButton.Name = "OptionButton";
            OptionButton.RightToLeft = RightToLeft.No;
            OptionButton.Size = new Size(70, 52);
            OptionButton.TabIndex = 20;
            OptionButton.Text = "Options";
            OptionButton.TextAlign = ContentAlignment.BottomCenter;
            OptionButton.UseVisualStyleBackColor = true;
            OptionButton.Click += MobButton_Click;
            // 
            // AndroidButton
            // 
            AndroidButton.AutoSize = true;
            AndroidButton.Enabled = false;
            AndroidButton.Font = new Font("Microsoft JhengHei UI", 12F, FontStyle.Regular, GraphicsUnit.Pixel);
            AndroidButton.Image = (Image)resources.GetObject("AndroidButton.Image");
            AndroidButton.ImageAlign = ContentAlignment.TopCenter;
            AndroidButton.Location = new Point(1449, 1);
            AndroidButton.Name = "AndroidButton";
            AndroidButton.RightToLeft = RightToLeft.No;
            AndroidButton.Size = new Size(70, 52);
            AndroidButton.TabIndex = 19;
            AndroidButton.Text = "Android";
            AndroidButton.TextAlign = ContentAlignment.BottomCenter;
            AndroidButton.UseVisualStyleBackColor = true;
            AndroidButton.Click += MobButton_Click;
            // 
            // FamiliarButton
            // 
            FamiliarButton.AutoSize = true;
            FamiliarButton.Enabled = false;
            FamiliarButton.Font = new Font("Microsoft JhengHei UI", 12F, FontStyle.Regular, GraphicsUnit.Pixel);
            FamiliarButton.Image = (Image)resources.GetObject("FamiliarButton.Image");
            FamiliarButton.ImageAlign = ContentAlignment.TopCenter;
            FamiliarButton.Location = new Point(1309, 1);
            FamiliarButton.Name = "FamiliarButton";
            FamiliarButton.RightToLeft = RightToLeft.No;
            FamiliarButton.Size = new Size(70, 52);
            FamiliarButton.TabIndex = 17;
            FamiliarButton.Text = "Familiar";
            FamiliarButton.TextAlign = ContentAlignment.BottomCenter;
            FamiliarButton.UseVisualStyleBackColor = true;
            FamiliarButton.Click += MobButton_Click;
            // 
            // PetButton
            // 
            PetButton.AutoSize = true;
            PetButton.Enabled = false;
            PetButton.Font = new Font("Microsoft JhengHei UI", 12F, FontStyle.Regular, GraphicsUnit.Pixel);
            PetButton.Image = (Image)resources.GetObject("PetButton.Image");
            PetButton.ImageAlign = ContentAlignment.TopCenter;
            PetButton.Location = new Point(1239, 1);
            PetButton.Name = "PetButton";
            PetButton.RightToLeft = RightToLeft.No;
            PetButton.Size = new Size(70, 52);
            PetButton.TabIndex = 16;
            PetButton.Text = "Pet";
            PetButton.TextAlign = ContentAlignment.BottomCenter;
            PetButton.UseVisualStyleBackColor = true;
            PetButton.Click += MobButton_Click;
            // 
            // RingButton
            // 
            RingButton.AutoSize = true;
            RingButton.Enabled = false;
            RingButton.Font = new Font("Microsoft JhengHei UI", 12F, FontStyle.Regular, GraphicsUnit.Pixel);
            RingButton.Image = (Image)resources.GetObject("RingButton.Image");
            RingButton.ImageAlign = ContentAlignment.TopCenter;
            RingButton.Location = new Point(1169, 1);
            RingButton.Name = "RingButton";
            RingButton.RightToLeft = RightToLeft.No;
            RingButton.Size = new Size(70, 52);
            RingButton.TabIndex = 15;
            RingButton.Text = "Ring";
            RingButton.TextAlign = ContentAlignment.BottomCenter;
            RingButton.UseVisualStyleBackColor = true;
            RingButton.Click += MobButton_Click;
            // 
            // TitleButton
            // 
            TitleButton.AutoSize = true;
            TitleButton.Enabled = false;
            TitleButton.Font = new Font("Microsoft JhengHei UI", 12F, FontStyle.Regular, GraphicsUnit.Pixel);
            TitleButton.Image = (Image)resources.GetObject("TitleButton.Image");
            TitleButton.ImageAlign = ContentAlignment.TopCenter;
            TitleButton.Location = new Point(1099, 1);
            TitleButton.Name = "TitleButton";
            TitleButton.RightToLeft = RightToLeft.No;
            TitleButton.Size = new Size(70, 52);
            TitleButton.TabIndex = 14;
            TitleButton.Text = "Title";
            TitleButton.TextAlign = ContentAlignment.BottomCenter;
            TitleButton.UseVisualStyleBackColor = true;
            TitleButton.Click += MobButton_Click;
            // 
            // MedalButton
            // 
            MedalButton.AutoSize = true;
            MedalButton.Enabled = false;
            MedalButton.Font = new Font("Microsoft JhengHei UI", 12F, FontStyle.Regular, GraphicsUnit.Pixel);
            MedalButton.Image = (Image)resources.GetObject("MedalButton.Image");
            MedalButton.ImageAlign = ContentAlignment.TopCenter;
            MedalButton.Location = new Point(1029, 1);
            MedalButton.Name = "MedalButton";
            MedalButton.RightToLeft = RightToLeft.No;
            MedalButton.Size = new Size(70, 52);
            MedalButton.TabIndex = 13;
            MedalButton.Text = "Medal";
            MedalButton.TextAlign = ContentAlignment.BottomCenter;
            MedalButton.UseVisualStyleBackColor = true;
            MedalButton.Click += MobButton_Click;
            // 
            // ObjInfoButton
            // 
            ObjInfoButton.AutoSize = true;
            ObjInfoButton.Enabled = false;
            ObjInfoButton.Font = new Font("Microsoft JhengHei UI", 12F, FontStyle.Regular, GraphicsUnit.Pixel);
            ObjInfoButton.Image = (Image)resources.GetObject("ObjInfoButton.Image");
            ObjInfoButton.ImageAlign = ContentAlignment.TopCenter;
            ObjInfoButton.Location = new Point(959, 1);
            ObjInfoButton.Name = "ObjInfoButton";
            ObjInfoButton.RightToLeft = RightToLeft.No;
            ObjInfoButton.Size = new Size(70, 52);
            ObjInfoButton.TabIndex = 12;
            ObjInfoButton.Text = "Obj Info";
            ObjInfoButton.TextAlign = ContentAlignment.BottomCenter;
            ObjInfoButton.UseVisualStyleBackColor = true;
            ObjInfoButton.Click += MobButton_Click;
            // 
            // DamageSkinButton
            // 
            DamageSkinButton.AutoSize = true;
            DamageSkinButton.Enabled = false;
            DamageSkinButton.Font = new Font("Microsoft JhengHei UI", 12F, FontStyle.Regular, GraphicsUnit.Pixel);
            DamageSkinButton.Image = (Image)resources.GetObject("DamageSkinButton.Image");
            DamageSkinButton.ImageAlign = ContentAlignment.TopCenter;
            DamageSkinButton.Location = new Point(862, 1);
            DamageSkinButton.Name = "DamageSkinButton";
            DamageSkinButton.RightToLeft = RightToLeft.No;
            DamageSkinButton.Size = new Size(97, 52);
            DamageSkinButton.TabIndex = 11;
            DamageSkinButton.Text = "Damage Skin";
            DamageSkinButton.TextAlign = ContentAlignment.BottomCenter;
            DamageSkinButton.UseVisualStyleBackColor = true;
            DamageSkinButton.Click += MobButton_Click;
            // 
            // MorphButton
            // 
            MorphButton.AutoSize = true;
            MorphButton.Enabled = false;
            MorphButton.Font = new Font("Microsoft JhengHei UI", 12F, FontStyle.Regular, GraphicsUnit.Pixel);
            MorphButton.Image = (Image)resources.GetObject("MorphButton.Image");
            MorphButton.ImageAlign = ContentAlignment.TopCenter;
            MorphButton.Location = new Point(788, 1);
            MorphButton.Name = "MorphButton";
            MorphButton.RightToLeft = RightToLeft.No;
            MorphButton.Size = new Size(74, 52);
            MorphButton.TabIndex = 10;
            MorphButton.Text = "Morph";
            MorphButton.TextAlign = ContentAlignment.BottomCenter;
            MorphButton.UseVisualStyleBackColor = true;
            MorphButton.Click += MobButton_Click;
            // 
            // CashEffectButton
            // 
            CashEffectButton.AutoSize = true;
            CashEffectButton.Enabled = false;
            CashEffectButton.Font = new Font("Microsoft JhengHei UI", 12F, FontStyle.Regular, GraphicsUnit.Pixel);
            CashEffectButton.Image = (Image)resources.GetObject("CashEffectButton.Image");
            CashEffectButton.ImageAlign = ContentAlignment.TopCenter;
            CashEffectButton.Location = new Point(703, 1);
            CashEffectButton.Name = "CashEffectButton";
            CashEffectButton.RightToLeft = RightToLeft.No;
            CashEffectButton.Size = new Size(84, 52);
            CashEffectButton.TabIndex = 9;
            CashEffectButton.Text = "Cash Effect";
            CashEffectButton.TextAlign = ContentAlignment.BottomCenter;
            CashEffectButton.UseVisualStyleBackColor = true;
            CashEffectButton.Click += MobButton_Click;
            // 
            // MountButton
            // 
            MountButton.Enabled = false;
            MountButton.Font = new Font("Microsoft JhengHei UI", 12F, FontStyle.Regular, GraphicsUnit.Pixel);
            MountButton.Image = (Image)resources.GetObject("MountButton.Image");
            MountButton.ImageAlign = ContentAlignment.TopCenter;
            MountButton.Location = new Point(625, 1);
            MountButton.Name = "MountButton";
            MountButton.Size = new Size(77, 52);
            MountButton.TabIndex = 8;
            MountButton.Text = "Mount";
            MountButton.TextAlign = ContentAlignment.BottomCenter;
            MountButton.UseVisualStyleBackColor = true;
            MountButton.Click += MobButton_Click;
            // 
            // NpcButton
            // 
            NpcButton.Enabled = false;
            NpcButton.Font = new Font("Microsoft JhengHei UI", 12F, FontStyle.Regular, GraphicsUnit.Pixel);
            NpcButton.Image = (Image)resources.GetObject("NpcButton.Image");
            NpcButton.ImageAlign = ContentAlignment.TopCenter;
            NpcButton.Location = new Point(547, 1);
            NpcButton.Name = "NpcButton";
            NpcButton.Size = new Size(77, 52);
            NpcButton.TabIndex = 7;
            NpcButton.Text = "Npc";
            NpcButton.TextAlign = ContentAlignment.BottomCenter;
            NpcButton.UseVisualStyleBackColor = true;
            NpcButton.Click += MobButton_Click;
            // 
            // ScaleButton
            // 
            ScaleButton.Enabled = false;
            ScaleButton.Font = new Font("Microsoft JhengHei UI", 12F, FontStyle.Regular, GraphicsUnit.Pixel);
            ScaleButton.Image = (Image)resources.GetObject("ScaleButton.Image");
            ScaleButton.ImageAlign = ContentAlignment.TopCenter;
            ScaleButton.Location = new Point(235, 1);
            ScaleButton.Name = "ScaleButton";
            ScaleButton.Size = new Size(77, 52);
            ScaleButton.TabIndex = 6;
            ScaleButton.Text = "Scale";
            ScaleButton.TextAlign = ContentAlignment.BottomCenter;
            ScaleButton.UseVisualStyleBackColor = true;
            ScaleButton.Click += MobButton_Click;
            // 
            // SkillButton
            // 
            SkillButton.AutoSize = true;
            SkillButton.Enabled = false;
            SkillButton.Font = new Font("Microsoft JhengHei UI", 12F, FontStyle.Regular, GraphicsUnit.Pixel);
            SkillButton.Image = (Image)resources.GetObject("SkillButton.Image");
            SkillButton.ImageAlign = ContentAlignment.TopCenter;
            SkillButton.Location = new Point(1379, 1);
            SkillButton.Name = "SkillButton";
            SkillButton.RightToLeft = RightToLeft.No;
            SkillButton.Size = new Size(70, 52);
            SkillButton.TabIndex = 18;
            SkillButton.Text = "Skill";
            SkillButton.TextAlign = ContentAlignment.BottomCenter;
            SkillButton.UseVisualStyleBackColor = true;
            SkillButton.Click += MobButton_Click;
            // 
            // FullScreenButton
            // 
            FullScreenButton.Font = new Font("Microsoft JhengHei UI", 12F, FontStyle.Regular, GraphicsUnit.Pixel);
            FullScreenButton.Location = new Point(157, 1);
            FullScreenButton.Name = "FullScreenButton";
            FullScreenButton.Size = new Size(77, 52);
            FullScreenButton.TabIndex = 5;
            FullScreenButton.Text = "Full Screen";
            FullScreenButton.TextAlign = ContentAlignment.BottomCenter;
            FullScreenButton.UseVisualStyleBackColor = true;
            FullScreenButton.Click += FullScreenButton_Click;
            // 
            // ChairButton
            // 
            ChairButton.Enabled = false;
            ChairButton.Font = new Font("Microsoft JhengHei UI", 12F, FontStyle.Regular, GraphicsUnit.Pixel);
            ChairButton.Image = (Image)resources.GetObject("ChairButton.Image");
            ChairButton.ImageAlign = ContentAlignment.TopCenter;
            ChairButton.Location = new Point(391, 1);
            ChairButton.Name = "ChairButton";
            ChairButton.Size = new Size(77, 52);
            ChairButton.TabIndex = 4;
            ChairButton.Text = "Chair";
            ChairButton.TextAlign = ContentAlignment.BottomCenter;
            ChairButton.UseVisualStyleBackColor = true;
            ChairButton.Click += MobButton_Click;
            // 
            // MobButton
            // 
            MobButton.Enabled = false;
            MobButton.Font = new Font("Microsoft JhengHei UI", 12F, FontStyle.Regular, GraphicsUnit.Pixel);
            MobButton.Image = (Image)resources.GetObject("MobButton.Image");
            MobButton.ImageAlign = ContentAlignment.TopCenter;
            MobButton.Location = new Point(469, 1);
            MobButton.Name = "MobButton";
            MobButton.Size = new Size(77, 52);
            MobButton.TabIndex = 3;
            MobButton.Text = "Mob";
            MobButton.TextAlign = ContentAlignment.BottomCenter;
            MobButton.UseVisualStyleBackColor = true;
            MobButton.Click += MobButton_Click;
            // 
            // AvatarButton
            // 
            AvatarButton.Enabled = false;
            AvatarButton.Font = new Font("Microsoft JhengHei UI", 12F, FontStyle.Regular, GraphicsUnit.Pixel);
            AvatarButton.Image = Properties.Resources._01050088_img_info_iconRaw;
            AvatarButton.ImageAlign = ContentAlignment.TopCenter;
            AvatarButton.Location = new Point(313, 1);
            AvatarButton.Name = "AvatarButton";
            AvatarButton.Size = new Size(77, 52);
            AvatarButton.TabIndex = 2;
            AvatarButton.Text = "Avatar";
            AvatarButton.TextAlign = ContentAlignment.BottomCenter;
            AvatarButton.UseVisualStyleBackColor = true;
            AvatarButton.Click += MobButton_Click;
            // 
            // SaveMapButton
            // 
            SaveMapButton.Enabled = false;
            SaveMapButton.Font = new Font("Microsoft JhengHei UI", 12F, FontStyle.Regular, GraphicsUnit.Pixel);
            SaveMapButton.Image = (Image)resources.GetObject("SaveMapButton.Image");
            SaveMapButton.ImageAlign = ContentAlignment.TopCenter;
            SaveMapButton.Location = new Point(79, 1);
            SaveMapButton.Name = "SaveMapButton";
            SaveMapButton.Size = new Size(77, 52);
            SaveMapButton.TabIndex = 1;
            SaveMapButton.Text = "Save Map";
            SaveMapButton.TextAlign = ContentAlignment.BottomCenter;
            SaveMapButton.UseVisualStyleBackColor = true;
            SaveMapButton.Click += MobButton_Click;
            // 
            // ViewButton
            // 
            ViewButton.Enabled = false;
            ViewButton.Font = new Font("Microsoft JhengHei UI", 12F, FontStyle.Regular, GraphicsUnit.Pixel);
            ViewButton.Image = (Image)resources.GetObject("ViewButton.Image");
            ViewButton.ImageAlign = ContentAlignment.TopCenter;
            ViewButton.Location = new Point(1, 1);
            ViewButton.Name = "ViewButton";
            ViewButton.Size = new Size(77, 54);
            ViewButton.TabIndex = 0;
            ViewButton.Text = "View";
            ViewButton.TextAlign = ContentAlignment.BottomCenter;
            ViewButton.UseVisualStyleBackColor = true;
            ViewButton.Click += MobButton_Click;
            // 
            // label4
            // 
            label4.AutoSize = true;
            label4.Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            label4.Location = new Point(74, 9);
            label4.Name = "label4";
            label4.Size = new Size(124, 18);
            label4.TabIndex = 12;
            label4.Text = "MapleStory Folder";
            // 
            // MainForm
            // 
            AutoScaleMode = AutoScaleMode.None;
            ClientSize = new Size(1175, 664);
            Controls.Add(label4);
            Controls.Add(panel1);
            Controls.Add(SearchMapBox);
            Controls.Add(label3);
            Controls.Add(label2);
            Controls.Add(label1);
            Controls.Add(comboBox1);
            Controls.Add(comboBox2);
            Controls.Add(LoadMapButton);
            Controls.Add(tabControl1);
            Controls.Add(pictureBox1);
            Controls.Add(OpenFolderButton);
            DoubleBuffered = true;
            Font = new Font("Microsoft JhengHei UI", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            Icon = (Icon)resources.GetObject("$this.Icon");
            KeyPreview = true;
            MaximizeBox = false;
            MaximumSize = new Size(5000, 5000);
            Name = "MainForm";
            Text = "MapleNecrocer";
            Load += MainForm_Load;
            KeyDown += MainForm_KeyDown;
            ((System.ComponentModel.ISupportInitialize)pictureBox1).EndInit();
            tabControl1.ResumeLayout(false);
            tabPage2.ResumeLayout(false);
            ((System.ComponentModel.ISupportInitialize)WorldMapListGrid).EndInit();
            panel1.ResumeLayout(false);
            panel1.PerformLayout();
            ResumeLayout(false);
            PerformLayout();
        }

        #endregion

        private Button OpenFolderButton;
        private PictureBox pictureBox1;
        private TextBox SearchMapBox;
        private TabControl tabControl1;
        private TabPage tabPage1;
        private TabPage tabPage2;
        private Button LoadMapButton;
        private ComboBox comboBox2;
        private ComboBox comboBox1;
        private Label label1;
        private Label label2;
        private Label label3;
        private Panel panel1;
        private Button ViewButton;
        private Button ScaleButton;
        private Button FullScreenButton;
        private Button ChairButton;
        private Button MobButton;
        private Button AvatarButton;
        private Button SaveMapButton;
        private Button NpcButton;
        private Label label4;
        private Button MountButton;
        private Button CashEffectButton;
        private Button MorphButton;
        private Button DamageSkinButton;
        private Button ObjInfoButton;
        private Button MedalButton;
        private Button TitleButton;
        private Button RingButton;
        private Button PetButton;
        private Button FamiliarButton;
        private Button SkillButton;
        private Button AndroidButton;
        private Button OptionButton;
        private Button ConsumeButton;
        private Button CashButton;
        private Button EtcButton;
        private Button TotemEffectButton;
        private Button SoulEffectButton;
        private Button ReactorButton;
        public DataGridView WorldMapListGrid;
        private Button EffectRingButton;
        private Button ChatRingButton;
    }
}
```

`MapleNecrocer/MainForm.cs`:

```cs
using DevComponents.AdvTree;
using DevComponents.DotNetBar;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using WzComparerR2.PluginBase;
using WzComparerR2;
using WzComparerR2.WzLib;
using WzComparerR2.Common;
using System.Reflection;
using WzComparerR2.CharaSim;
using System.Runtime.InteropServices;
using DevComponents.DotNetBar.Controls;

using Microsoft.Xna.Framework;
using Spine;
using static System.Windows.Forms.VisualStyles.VisualStyleElement;
using System.Runtime.CompilerServices;
using WzComparerR2.CharaSimControl;
using System.Text.RegularExpressions;
using WzComparerR2.CharaSim;
using static System.Net.Mime.MediaTypeNames;
using System.Xml.Linq;
using DPIUtils;

namespace MapleNecrocer;


public partial class MainForm : Form
{
    public MainForm()
    {
        InitializeComponent();
        Instance = this;
        openedWz = new List<Wz_Structure>();
        PluginManager.WzFileFinding += new FindWzEventHandler(WzFileFinding);
        if (!System.Windows.Forms.SystemInformation.TerminalServerSession)
        {
            var dgvType = this.GetType();
            var pi = dgvType.GetProperty("DoubleBuffered", BindingFlags.Instance | BindingFlags.NonPublic);
            pi.SetValue(this, true, null);
        }
        RenderForm.TopLevel = false;
        RenderForm.Parent = this;
        RenderForm.Show();
        Sound.Init();
        ToolTipView = new AfrmTooltip();
        ToolTipView.Visible = true;
        stringLinker = new StringLinker();
        ToolTipView.StringLinker = this.stringLinker;
        //ToolTipView.KeyDown += new KeyEventHandler(afrm_KeyDown);
        ToolTipView.ShowID = true;
        ToolTipView.ShowMenu = true;
        ToolTipView.StartPosition = FormStartPosition.CenterParent;

        //  RenderForm.Show();
    }
    public static RenderForm RenderForm = new RenderForm();
    List<Wz_Structure> openedWz;
    public static Wz_Node TreeNode;
    public static MainForm Instance;
    public DataGridViewEx MapListBox;
    public Dictionary<string, string> MapNames = new();
    public StringLinker stringLinker;
    public AfrmTooltip ToolTipView;
    DefaultLevel skillDefaultLevel = DefaultLevel.Level0;
    int skillInterval = 32;
    public void CenterToScreen2()
    {
        this.CenterToScreen();
    }

    public static void OpenWZ(string wzFilePath)
    {
        MainForm.Instance.openWz(wzFilePath);
    }

    string LeftStr(string s, int count)
    {
        if (count > s.Length)
            count = s.Length;
        return s.Substring(0, count);
    }

    public void DumpMapIDs()
    {
        //  if(Wz.HasNode("Map/Map/Map0"))
        foreach (var Iter in Wz.GetNodes("String/Map.img"))
        {
            foreach (var Iter2 in Iter.Nodes)
            {
                string ID = Iter2.Text.PadLeft(9, '0');
                var MapName = Iter2.GetStr("mapName");
                var StreetName = Iter2.GetStr("streetName");
                Map.MapNameList.AddOrReplace(ID, new MapNameRec(ID, MapName, StreetName));
                if (!MapNames.ContainsKey(ID))
                {
                    MapNames.Add(ID, MapName);
                }
            }
        }

        Win32.SendMessage(MapListBox.Handle, false);
        foreach (var Dir in Wz.GetNodes("Map/Map"))
        {
            if (LeftStr(Dir.Text, 3) != "Map")
                continue;
            foreach (var img in Dir.Nodes)
            {
                if (!Char.IsNumber(img.Text[0]))
                    continue;
                var ID = img.ImgID();
                if (MapNames.ContainsKey(ID))
                    MapListBox.Rows.Add(ID, MapNames[ID]);
                else
                    MapListBox.Rows.Add(ID, "");
            }
        }

        // foreach(var i in TreeNode.Nodes["Map"].Nodes["Map"].Nodes)
        //   MapListBox.Items.Add(i.Text);
        Win32.SendMessage(MapListBox.Handle, true);

        MapListBox.Refresh();
        tabControl1.Enabled = true;
    }
    void WzFileFinding(object sender, FindWzEventArgs e)
    {
        string[] fullPath = null;
        if (!string.IsNullOrEmpty(e.FullPath)) //用fullpath作为输入参数
        {
            fullPath = e.FullPath.Split('/', '\\');
            e.WzType = Enum.TryParse<Wz_Type>(fullPath[0], true, out var wzType) ? wzType : Wz_Type.Unknown;
        }

        List<Wz_Node> preSearch = new List<Wz_Node>();
        if (e.WzType != Wz_Type.Unknown) //用wztype作为输入参数
        {
            IEnumerable<Wz_Structure> preSearchWz = e.WzFile?.WzStructure != null ?
                Enumerable.Repeat(e.WzFile.WzStructure, 1) :
                this.openedWz;
            foreach (var wzs in preSearchWz)
            {
                Wz_File baseWz = null;

                bool find = false;
                foreach (Wz_File wz_f in wzs.wz_files)
                {
                    if (wz_f.Header.FileName.RightStr(5) == "NL.wz") continue;
                    if (wz_f.Header.FileName.RightStr(5) == "ES.wz") continue;
                    if (wz_f.Header.FileName.RightStr(5) == "FR.wz") continue;
                    if (wz_f.Header.FileName.RightStr(5) == "DE.wz") continue;
                    if (wz_f.Type == e.WzType)
                    {
                        preSearch.Add(wz_f.Node);
                        find = true;
                        //e.WzFile = wz_f;
                    }
                    if (wz_f.Type == Wz_Type.Base)
                    {
                        baseWz = wz_f;
                    }
                }

                // detect data.wz
                if (baseWz != null && !find)
                {
                    string key = e.WzType.ToString();
                    foreach (Wz_Node node in baseWz.Node.Nodes)
                    {
                        if (node.Text == key && node.Nodes.Count > 0)
                        {
                            preSearch.Add(node);

                        }
                    }
                }
            }
        }

        if (fullPath == null || fullPath.Length <= 1)
        {
            if (e.WzType != Wz_Type.Unknown && preSearch.Count > 0) //返回wzFile
            {
                e.WzNode = preSearch[0];
                e.WzFile = preSearch[0].Value as Wz_File;
            }
            return;
        }

        if (preSearch.Count <= 0)
        {
            return;
        }

        foreach (var wzFileNode in preSearch)
        {
            var searchNode = wzFileNode;
            for (int i = 1; i < fullPath.Length && searchNode != null; i++)
            {
                searchNode = searchNode.Nodes[fullPath[i]];
                var img = searchNode.GetValueEx<Wz_Image>(null);
                if (img != null)
                {
                    searchNode = img.TryExtract() ? img.Node : null;
                }
            }

            if (searchNode != null)
            {
                e.WzNode = searchNode;
                e.WzFile = wzFileNode.Value as Wz_File;
                return;
            }
        }
        //寻找失败
        e.WzNode = null;
    }


    private Node createNode(Wz_Node wzNode)
    {
        if (wzNode == null)
            return null;

        Node parentNode = new Node(wzNode.Text) { Tag = new WeakReference(wzNode) };
        foreach (Wz_Node subNode in wzNode.Nodes)
        {
            Node subTreeNode = createNode(subNode);
            if (subTreeNode != null)
                parentNode.Nodes.Add(subTreeNode);
        }
        return parentNode;
    }

    private void sortWzNode(Wz_Node wzNode)
    {
        this.sortWzNode(wzNode, true);
    }

    private void sortWzNode(Wz_Node wzNode, bool sortByImgID)
    {
        if (wzNode.Nodes.Count > 1)
        {
            if (sortByImgID)
            {
                wzNode.Nodes.SortByImgID();
            }
            else
            {
                wzNode.Nodes.Sort();
            }
        }
        foreach (Wz_Node subNode in wzNode.Nodes)
        {
            sortWzNode(subNode, sortByImgID);
        }
    }

    private void btnItemOpenWz_Click(object sender, EventArgs e)
    {
        using (OpenFileDialog dlg = new OpenFileDialog())
        {
            dlg.Title = "Wz檔";
            dlg.Filter = "Base.wz|*.wz";
            if (dlg.ShowDialog() == DialogResult.OK)
            {
                openWz(dlg.FileName);

            }
        }
    }

    public void openWz(string wzFilePath)
    {
        foreach (Wz_Structure wzs in openedWz)
        {
            foreach (Wz_File wz_f in wzs.wz_files)
            {
                if (string.Compare(wz_f.Header.FileName, wzFilePath, true) == 0)
                {
                    MessageBoxEx.Show("已經開啟的wz", "OK");
                    return;
                }
            }
        }

        var Path = System.IO.Path.GetDirectoryName(wzFilePath);

        Wz_Structure wz = new Wz_Structure();

        try
        {
            if (wz.IsKMST1125WzFormat(wzFilePath))
            {
                wz.LoadKMST1125DataWz(wzFilePath);
            }
            else
            {
                wz.Load(wzFilePath, true);
            }
            sortWzNode(wz.WzNode);

            Node node = createNode(wz.WzNode);
            TreeNode = node.AsWzNode();
            // node.Expand();
            // advTree1.Nodes.Add(node);
            this.openedWz.Add(wz);
            // QueryPerformance.End();
        }
        catch (FileNotFoundException)
        {
            MessageBoxEx.Show("檔案沒找到", "OK");
        }
        catch (Exception ex)
        {
            MessageBoxEx.Show(ex.ToString(), "OK");
            wz.Clear();
        }
        finally
        {
            //  advTree1.EndUpdate();
        }

        Wz.IsDataWz = false;
        if (Wz.GetNode("Mob").FullPathToFile.LeftStr(4) == "Data")
            Wz.IsDataWz = true;

        Wz.HasStringWz = true;
        if (Wz.HasNode("Mob/0100100.img/info/name"))
        {
            Wz.HasStringWz = false;
        }

        Wz.HasMap9Dir = false;
        if (Wz.HasNode("Map/Map/Map1"))
        {
            Wz.HasMap9Dir = true;
        }
    }

    public void RemoveWz()
    {
        foreach (var Iter in this.openedWz)
            Iter.Clear();
    }

    enum DefaultLevel
    {
        Level0 = 0,
        Level1 = 1,
        LevelMax = 2,
        LevelMaxWithCO = 3,
    }

    public void QuickView(Wz_Node node)
    {
        Wz_Node selectedNode = node;
        if (selectedNode == null)
        {
            return;
        }
        if (!Wz.IsDataWz)
        {
            Wz_File findStringWz()
            {
                foreach (Wz_Structure wz in openedWz)
                {
                    foreach (Wz_File file in wz.wz_files)
                    {
                        if (file.Type == Wz_Type.String)
                        {
                            return file;
                        }
                    }
                }
                return null;
            }

            Wz_File findItemWz()
            {
                foreach (Wz_Structure wz in openedWz)
                {
                    foreach (Wz_File file in wz.wz_files)
                    {
                        if (file.Type == Wz_Type.Item)
                        {
                            return file;
                        }
                    }
                }
                return null;
            }

            Wz_File findEtcWz()
            {
                foreach (Wz_Structure wz in openedWz)
                {
                    foreach (Wz_File file in wz.wz_files)
                    {
                        if (file.Type == Wz_Type.Etc)
                        {
                            return file;
                        }
                    }
                }
                return null;
            }

            Wz_Image image;
            Wz_File wzf = selectedNode.GetNodeWzFile();
            if (wzf == null)
            {
                // labelItemStatus.Text = "The WZ file where the node belongs to has not been found.";
                return;
            }

            if (!this.stringLinker.HasValues)
            {
                this.stringLinker.Load(findStringWz(), findItemWz(), findEtcWz());
            }

            object obj = null;
            string fileName = null;
            switch (wzf.Type)
            {
                case Wz_Type.Character:
                    if ((image = selectedNode.GetValue<Wz_Image>()) == null || !image.TryExtract())
                        return;
                    CharaSimLoader.LoadSetItemsIfEmpty();
                    CharaSimLoader.LoadExclusiveEquipsIfEmpty();
                    CharaSimLoader.LoadCommoditiesIfEmpty();
                    var gear = Gear.CreateFromNode(image.Node, PluginManager.FindWz);
                    obj = gear;
                    if (gear != null)
                    {
                        fileName = gear.ItemID + ".png";
                    }
                    break;
                case Wz_Type.Item:
                    CharaSimLoader.LoadCommoditiesIfEmpty();
                    Wz_Node itemNode = selectedNode;
                    if (Regex.IsMatch(itemNode.FullPathToFile, @"^Item\\(Cash|Consume|Etc|Install|Cash)\\\d{4,6}.img\\\d+$") || Regex.IsMatch(itemNode.FullPathToFile, @"^Item\\Special\\0910.img\\\d+$"))
                    {
                        var item = Item.CreateFromNode(itemNode, PluginManager.FindWz);
                        obj = item;
                        if (item != null)
                        {
                            fileName = item.ItemID + ".png";
                        }
                    }
                    else if (Regex.IsMatch(itemNode.FullPathToFile, @"^Item\\Pet\\\d{7}.img"))
                    {
                        if (CharaSimLoader.LoadedSetItems.Count == 0) //宠物 预读套装
                        {
                            CharaSimLoader.LoadSetItemsIfEmpty();
                        }
                        if ((image = selectedNode.GetValue<Wz_Image>()) == null || !image.TryExtract())
                            return;
                        var item = Item.CreateFromNode(image.Node, PluginManager.FindWz);
                        obj = item;
                        if (item != null)
                        {
                            fileName = item.ItemID + ".png";
                        }
                    }

                    break;
                case Wz_Type.Skill:
                    Wz_Node skillNode = selectedNode;
                    //模式路径分析
                    if (Regex.IsMatch(skillNode.FullPathToFile, @"^Skill\d*\\Recipe_\d+.img\\\d+$"))
                    {
                        Recipe recipe = Recipe.CreateFromNode(skillNode);
                        obj = recipe;
                        if (recipe != null)
                        {
                            fileName = "recipe_" + recipe.RecipeID + ".png";
                        }
                    }
                    else if (Regex.IsMatch(skillNode.FullPathToFile, @"^Skill\d*\\\d+.img\\skill\\\d+$"))
                    {
                        WzComparerR2.CharaSim.Skill skill = WzComparerR2.CharaSim.Skill.CreateFromNode(skillNode, PluginManager.FindWz);
                        if (skill != null)
                        {
                            switch (this.skillDefaultLevel)
                            {
                                case DefaultLevel.Level0: skill.Level = 0; break;
                                case DefaultLevel.Level1: skill.Level = 1; break;
                                case DefaultLevel.LevelMax: skill.Level = skill.MaxLevel; break;
                                case DefaultLevel.LevelMaxWithCO: skill.Level = skill.MaxLevel + 2; break;
                            }
                            obj = skill;
                            fileName = "skill_" + skill.SkillID + ".png";
                        }
                    }
                    break;

                case Wz_Type.Mob:
                    if ((image = selectedNode.GetValue<Wz_Image>()) == null || !image.TryExtract())
                        return;
                    var mob = WzComparerR2.CharaSim.Mob.CreateFromNode(image.Node, PluginManager.FindWz);
                    obj = mob;
                    if (mob != null)
                    {
                        fileName = mob.ID + ".png";
                    }
                    break;

                case Wz_Type.Npc:
                    if ((image = selectedNode.GetValue<Wz_Image>()) == null || !image.TryExtract())
                        return;
                    var npc = WzComparerR2.CharaSim.Npc.CreateFromNode(image.Node, PluginManager.FindWz);
                    obj = npc;
                    if (npc != null)
                    {
                        fileName = npc.ID + ".png";
                    }
                    break;

                case Wz_Type.Etc:
                    CharaSimLoader.LoadSetItemsIfEmpty();
                    Wz_Node setItemNode = selectedNode;
                    if (Regex.IsMatch(setItemNode.FullPathToFile, @"^Etc\\SetItemInfo.img\\-?\d+$"))
                    {
                        SetItem setItem;
                        if (!CharaSimLoader.LoadedSetItems.TryGetValue(Convert.ToInt32(selectedNode.Text), out setItem))
                            return;
                        obj = setItem;
                        if (setItem != null)
                        {
                            fileName = setItem.SetItemID + ".png";
                        }
                    }
                    break;
            }

            if (obj != null)
            {
                ToolTipView.TargetItem = obj;
                ToolTipView.ImageFileName = fileName;
                ToolTipView.Refresh();
                ToolTipView.HideOnHover = false;
                ToolTipView.TopMost = true;
                ToolTipView.Show();
            }
        }
        else
        {
            if (!this.stringLinker.HasValues)
            {
                this.stringLinker.Load(Wz.GetNode("String"), Wz.GetNode("Item"), Wz.GetNode("Etc"));
            }

            string[] Split = selectedNode.FullPathToFileEx().Split('/');
            object obj = null;
            string fileName = null;
            Wz_Image image;
            switch (Split[1])
            {
                case "Character":
                    if ((image = selectedNode.GetValue<Wz_Image>()) == null || !image.TryExtract())
                        return;
                    CharaSimLoader.LoadSetItemsIfEmpty();
                    CharaSimLoader.LoadExclusiveEquipsIfEmpty();
                    CharaSimLoader.LoadCommoditiesIfEmpty();
                    var gear = Gear.CreateFromNode(image.Node, PluginManager.FindWz);
                    obj = gear;
                    if (gear != null)
                    {
                        fileName = gear.ItemID + ".png";
                    }
                    break;
                case "Item":
                    CharaSimLoader.LoadCommoditiesIfEmpty();

                    Wz_Node itemNode = selectedNode;
                    if (Regex.IsMatch(itemNode.FullPathToFile.Replace("Data\\", ""), @"^Item\\(Cash|Consume|Etc|Install|Cash)\\\d{4,6}.img\\\d+$") || Regex.IsMatch(itemNode.FullPathToFile, @"^Item\\Special\\0910.img\\\d+$"))
                    {
                        var item = Item.CreateFromNode(itemNode, PluginManager.FindWz);
                        obj = item;
                        if (item != null)
                        {
                            fileName = item.ItemID + ".png";
                        }
                    }
                    else if (Regex.IsMatch(itemNode.FullPathToFile.Replace("Data\\", ""), @"^Item\\Pet\\\d{7}.img"))
                    {
                        if (CharaSimLoader.LoadedSetItems.Count == 0) //宠物 预读套装
                        {
                            CharaSimLoader.LoadSetItemsIfEmpty();
                        }
                        if ((image = selectedNode.GetValue<Wz_Image>()) == null || !image.TryExtract())
                            return;
                        var item = Item.CreateFromNode(image.Node, PluginManager.FindWz);
                        obj = item;
                        if (item != null)
                        {
                            fileName = item.ItemID + ".png";
                        }
                    }

                    break;
                case "Skill":
                    Wz_Node skillNode = selectedNode;
                    //模式路径分析
                    if (Regex.IsMatch(skillNode.FullPathToFile, @"^Skill\d*\\Recipe_\d+.img\\\d+$"))
                    {
                        Recipe recipe = Recipe.CreateFromNode(skillNode);
                        obj = recipe;
                        if (recipe != null)
                        {
                            fileName = "recipe_" + recipe.RecipeID + ".png";
                        }
                    }
                    else if (Regex.IsMatch(skillNode.FullPathToFile, @"^Skill\d*\\\d+.img\\skill\\\d+$"))
                    {
                        WzComparerR2.CharaSim.Skill skill = WzComparerR2.CharaSim.Skill.CreateFromNode(skillNode, PluginManager.FindWz);
                        if (skill != null)
                        {
                            switch (this.skillDefaultLevel)
                            {
                                case DefaultLevel.Level0: skill.Level = 0; break;
                                case DefaultLevel.Level1: skill.Level = 1; break;
                                case DefaultLevel.LevelMax: skill.Level = skill.MaxLevel; break;
                                case DefaultLevel.LevelMaxWithCO: skill.Level = skill.MaxLevel + 2; break;
                            }
                            obj = skill;
                            fileName = "skill_" + skill.SkillID + ".png";
                        }
                    }
                    break;

                case "Mob":
                    if ((image = selectedNode.GetValue<Wz_Image>()) == null || !image.TryExtract())
                        return;
                    var mob = WzComparerR2.CharaSim.Mob.CreateFromNode(image.Node, PluginManager.FindWz);
                    obj = mob;
                    if (mob != null)
                    {
                        fileName = mob.ID + ".png";
                    }
                    break;

                case "Npc":
                    if ((image = selectedNode.GetValue<Wz_Image>()) == null || !image.TryExtract())
                        return;
                    var npc = WzComparerR2.CharaSim.Npc.CreateFromNode(image.Node, PluginManager.FindWz);
                    obj = npc;
                    if (npc != null)
                    {
                        fileName = npc.ID + ".png";
                    }
                    break;

                case "Etc":
                    CharaSimLoader.LoadSetItemsIfEmpty();
                    Wz_Node setItemNode = selectedNode;
                    if (Regex.IsMatch(setItemNode.FullPathToFile, @"^Etc\\SetItemInfo.img\\-?\d+$"))
                    {
                        SetItem setItem;
                        if (!CharaSimLoader.LoadedSetItems.TryGetValue(Convert.ToInt32(selectedNode.Text), out setItem))
                            return;
                        obj = setItem;
                        if (setItem != null)
                        {
                            fileName = setItem.SetItemID + ".png";
                        }
                    }
                    break;
            }

            if (obj != null)
            {
                ToolTipView.TargetItem = obj;
                ToolTipView.ImageFileName = fileName;
                ToolTipView.Refresh();
                ToolTipView.HideOnHover = false;
                ToolTipView.Show();
            }
        }

    }


    void CellClick(BaseDataGridView DataGrid, DataGridViewCellEventArgs e)
    {
        var ID = DataGrid.Rows[e.RowIndex].Cells[0].Value.ToString();
        var LeftNum = LeftStr(ID, 1);
        var Node = Wz.GetNode("Map/Map/Map" + LeftNum + '/' + ID + ".img/info/link");
        if (Node == null)
            Map.ID = ID;
        else
            Map.ID = Node.Value.ToString();

        LeftNum = LeftStr(Map.ID, 1);
        Node = Wz.GetNode("Map/Map/Map" + LeftNum + "/" + Map.ID + ".img/miniMap");

        if (Node != null)
        {
            pictureBox1.Image = Wz.GetBmp("Map/Map/Map" + LeftNum + "/" + Map.ID + ".img/miniMap/canvas");
            // Map.Img = GetWzNode("Map/Map/Map" + LeftNum + "/" + Map.ID + ".img");
        }
        else
            pictureBox1.Image = null;

        if (!LoadedEff)
            LoadMapButton.Enabled = true;
    }

    private void MainForm_Load(object sender, EventArgs e)
    {
        MapListBox = new(72 + 2, 135, 0, 0, 220, 400, false, tabControl1.TabPages[0]);
        MapListBox.Dock = DockStyle.Fill;
        MapListBox.SearchGrid.Dock = DockStyle.Fill;
        MapListBox.CellClick += (s, e) =>
        {
            CellClick(MapListBox, e);
        };

        MapListBox.SearchGrid.CellClick += (s, e) =>
        {
            CellClick(MapListBox.SearchGrid, e);
        };

        comboBox2.SelectedIndex = 1;
        Graphics graphics = this.CreateGraphics();
        float dpiX = graphics.DpiX;
        float dpiY = graphics.DpiY;
        DPIUtil.dpiX = dpiX;
        DPIUtil.dpiY = dpiY;
    }

    private void OpenFolderButton_Click(object sender, EventArgs e)
    {
        if (SelectFolderForm.Instance == null)
            new SelectFolderForm().Show();
        else
            SelectFolderForm.Instance.Show();
        OpenFolderButton.Enabled = false;
    }

    private void MapListBox_SelectedIndexChanged(object sender, EventArgs e)
    {


    }

    private void LoadMap()
    {
        Map.LoadMap(Map.ID);
        int PX = 0, PY = 0;
        foreach (var Portals in MapPortal.PortalList)
        {
            if (Portals.PortalType == 0)
            {
                PX = Portals.X;
                PY = Portals.Y;
                break;
            }
        }
        Game.Player.X = PX;
        Game.Player.Y = PY;
        Foothold BelowFH = null;
        Vector2 Below = FootholdTree.Instance.FindBelow(new Vector2(PX, PY - 2), ref BelowFH);
        Game.Player.FH = BelowFH;
        Game.Player.FaceDir = FaceDir.None;
        Game.Player.JumpState = JumpState.jsNone;

        if (Pet.Instance != null)
        {
            Pet.Instance.X = Game.Player.X;
            Pet.Instance.Y = Game.Player.Y;
            Pet.Instance.JumpState = JumpState.jsFalling;
        }

        if (Familiar.Instance != null)
        {
            Familiar.Instance.X = Game.Player.X;
            Familiar.Instance.Y = Game.Player.Y - 50;
            Familiar.Instance.JumpState = JumpState.jsFalling;
        }

        if (AndroidPlayer.Instance != null)
        {
            AndroidPlayer.Instance.X = Game.Player.X;
            AndroidPlayer.Instance.Y = Game.Player.Y;
            AndroidPlayer.Instance.JumpState = JumpState.jsFalling;
        }

        EngineFunc.SpriteEngine.Camera.X = PX - Map.DisplaySize.X / 2;
        EngineFunc.SpriteEngine.Camera.Y = PY - (Map.DisplaySize.Y / 2) - 100;
        if (EngineFunc.SpriteEngine.Camera.X > Map.Right)
            EngineFunc.SpriteEngine.Camera.X = Map.Right;
        if (EngineFunc.SpriteEngine.Camera.X < Map.Left)
            EngineFunc.SpriteEngine.Camera.X = Map.Left;
        if (EngineFunc.SpriteEngine.Camera.Y > Map.Bottom)
            EngineFunc.SpriteEngine.Camera.Y = Map.Bottom;
        if (EngineFunc.SpriteEngine.Camera.Y < Map.Top)
            EngineFunc.SpriteEngine.Camera.Y = Map.Top;

        Map.OffsetY = (Map.DisplaySize.Y - 600) / 2;
        Back.ResetPos = true;
        Particle.ResetPos = true;
        EngineFunc.SpriteEngine.Move(1);

        Game.Player.JumpState = JumpState.jsFalling;
        if (!LoadedEff)
        {
            SetEffect.LoadList();
            ItemEffect.LoadList();
            TamingMob.LoadSaddleList();

            foreach (var Iter in this.panel1.Controls)
            {
                if (Iter.GetType().Name == "Button")
                {
                    ((System.Windows.Forms.Button)Iter).Enabled = true;
                }
            }

            if (!Wz.HasNode("Character/TamingMob"))
                MountButton.Enabled = false;
            if (!Wz.HasNode("Item/Cash"))
            {
                CashButton.Enabled = false;
                CashEffectButton.Enabled = false;
            }
            if (!Wz.HasNode("Morph"))
                MorphButton.Enabled = false;
            if (!Wz.HasNode("Effect/DamageSkin.img"))
                DamageSkinButton.Enabled = false;
            if (!Wz.HasNode("Character/Accessory/01142000.img"))
                MedalButton.Enabled = false;
            if (!Wz.HasNode("Item/Install/0370.img"))
                TitleButton.Enabled = false;
            if (!Wz.HasNode("Character/Ring/01112100.img"))
                RingButton.Enabled = false;
            if (!Wz.HasNode("Character/Familiar"))
                FamiliarButton.Enabled = false;
            if (!Wz.HasNode("Character/Android"))
                AndroidButton.Enabled = false;
            if (!Wz.HasNode("Character/Totem"))
                TotemEffectButton.Enabled = false;
            if (!Wz.HasNode("Item/Consume/0259.img"))
                SoulEffectButton.Enabled = false;
            if (Wz.IsDataWz)
                ReactorButton.Enabled = false;

            LoadedEff = true;
        }

        if (ObjInfoForm.Instance != null)
        {
            ObjInfoForm.Instance.DumpObjs();
        }
    }

    static bool LoadedEff;
    private void LoadMapButton_Click(object sender, EventArgs e)
    {
        this.LoadMap();
    }

    [DllImport("User32.dll", CharSet = CharSet.Ansi, SetLastError = true, ExactSpelling = true)]
    public static extern bool MoveWindow(IntPtr hWnd, int x, int y, int w, int h, bool Repaint);
    private void comboBox2_SelectedIndexChanged(object sender, EventArgs e)
    {
        RenderFormDraw.ScreenMode = ScreenMode.Normal;
        var Split = comboBox2.Text.Split("X");
        Map.DisplaySize.X = Split[0].ToInt();
        Map.DisplaySize.Y = Split[1].ToInt();
        bool Result;
        Result = MoveWindow(this.Handle, this.Left, this.Top, Map.DisplaySize.X + 287, Map.DisplaySize.Y + 152, true);
        //this.Width = Map.DisplaySize.X + 283;
        //this.Height = Map.DisplaySize.Y + 124;

        Result = MoveWindow(RenderForm.Handle, RenderForm.Left, RenderForm.Top, Map.DisplaySize.X, Map.DisplaySize.Y, true);
        // RenderForm.Width = Map.DisplaySize.X;
        //RenderForm.Height = Map.DisplaySize.Y;
        RenderForm.RenderFormDraw.Width = Map.DisplaySize.X;
        RenderForm.RenderFormDraw.Height = Map.DisplaySize.Y;
        RenderForm.RenderFormDraw.Parent = RenderForm;
        EngineFunc.SpriteEngine.VisibleWidth = Map.DisplaySize.X + 200;
        EngineFunc.SpriteEngine.VisibleHeight = Map.DisplaySize.Y + 200;
        Map.ResetPos = true;
        this.CenterToScreen();
        Refresh();
    }

    private void comboBox2_Click(object sender, EventArgs e)
    {
    }

    private void SerachMapBox_TextChanged(object sender, EventArgs e)
    {
        MapListBox.Search(SearchMapBox.Text);
    }

    private void MobButton_Click(object sender, EventArgs e)
    {
        void ShowForm(Form Instance, Action NewForm)
        {
            if (Instance == null)
                NewForm();
            else
                Instance.Show();
        }
        switch (((System.Windows.Forms.Button)sender).Name)
        {
            case "ViewButton": ShowForm(ViewForm.Instance, () => new ViewForm().Show()); break;
            case "MobButton": ShowForm(MobForm.Instance, () => new MobForm().Show()); break;
            case "NpcButton": ShowForm(NpcForm.Instance, () => new NpcForm().Show()); break;
            case "AvatarButton": ShowForm(AvatarForm.Instance, () => new AvatarForm().Show()); break;
            case "ChairButton": ShowForm(ChairForm.Instance, () => new ChairForm().Show()); break;
            case "MountButton": ShowForm(MountForm.Instance, () => new MountForm().Show()); break;
            case "CashEffectButton": ShowForm(CashEffectForm.Instance, () => new CashEffectForm().Show()); break;
            case "MorphButton": ShowForm(MorphForm.Instance, () => new MorphForm().Show()); break;
            case "DamageSkinButton": ShowForm(DamageSkinForm.Instance, () => new DamageSkinForm().Show()); break;
            case "ObjInfoButton": new ObjInfoForm().Show(); break;
            case "MedalButton": ShowForm(MedalForm.Instance, () => new MedalForm().Show()); break;
            case "TitleButton": ShowForm(TitleForm.Instance, () => new TitleForm().Show()); break;
            case "RingButton": ShowForm(RingForm.Instance, () => new RingForm().Show()); break;
            case "PetButton": ShowForm(PetForm.Instance, () => new PetForm().Show()); break;
            case "FamiliarButton": ShowForm(FamiliarForm.Instance, () => new FamiliarForm().Show()); break;
            case "SkillButton": ShowForm(SkillForm.Instance, () => new SkillForm().Show()); break;
            case "AndroidButton": ShowForm(AndroidForm.Instance, () => new AndroidForm().Show()); break;
            case "ConsumeButton": ShowForm(ConsumeForm.Instance, () => new ConsumeForm().Show()); break;
            case "CashButton": ShowForm(CashForm.Instance, () => new CashForm().Show()); break;
            case "EtcButton": ShowForm(EtcForm.Instance, () => new EtcForm().Show()); break;
            case "TotemEffectButton": ShowForm(TotemEffectForm.Instance, () => new TotemEffectForm().Show()); break;
            case "SoulEffectButton": ShowForm(SoulEffectForm.Instance, () => new SoulEffectForm().Show()); break;
            case "ReactorButton": ShowForm(ReactorForm.Instance, () => new ReactorForm().Show()); break;
            case "SaveMapButton": ShowForm(SaveMapForm.Instance, () => new SaveMapForm().Show()); break;
            case "ScaleButton": ShowForm(ScaleForm.Instance, () => new ScaleForm().Show()); break;
            case "OptionButton": ShowForm(OptionForm.Instance, () => new OptionForm().Show()); break;
            case "EffectRingButton": ShowForm(EffectRingForm.Instance, () => new EffectRingForm().Show()); break;
            case "ChatRingButton": ShowForm(ChatRingForm.Instance, () => new ChatRingForm().Show()); break;
        }
    }

    private void MainForm_KeyDown(object sender, KeyEventArgs e)
    {
        if (e.Alt)
            e.Handled = true;
        if (!SearchMapBox.Focused)
            ActiveControl = null;
        //  if (Skill.PlayEnded)
        //  SearchMapBox.Clear();
    }

    private void comboBox1_SelectedIndexChanged(object sender, EventArgs e)
    {
        switch (comboBox1.SelectedIndex)
        {
            case 0: Map.GameMode = GameMode.Play; break;
            case 1: Map.GameMode = GameMode.Viewer; break;
        }
    }

    private void tabControl1_SelectedIndexChanged(object sender, EventArgs e)
    {
        if (tabControl1.SelectedIndex == 0)
        {
            WorldMapForm.Instance.Close();
        }
        else
        {
            if (WorldMapForm.Instance == null)
            {
                new WorldMapForm().Show();
                WorldMapForm.Instance.Hide();
            }
            else
            {
                WorldMapForm.Instance.Show();
            }
        }
    }

    private List<PictureBox> PictureBoxList = new();
    private System.Windows.Forms.ToolTip ToolTip = new();
    private void WorldMapListGrid_CellClick(object sender, DataGridViewCellEventArgs e)
    {
        WorldMapForm.Instance.Show();

        Wz_Node Img = Wz.GetNode("Map/WorldMap/" + WorldMapListGrid.Rows[e.RowIndex].Cells[1].Value.ToString().Trim(' '));
        if (!Img.HasNode("BaseImg/0"))
            return;
        ToolTip.AutoPopDelay = 5000;
        ToolTip.InitialDelay = 10;
        ToolTip.ReshowDelay = 10;
        // Force the ToolTip text to be displayed whether or not the form is active.
        ToolTip.ShowAlways = true;

        Bitmap Bmp = Img.GetBmp("BaseImg/0");
        int W = Bmp.Width;
        int H = Bmp.Height;
        WorldMapForm.Instance.ClientSize = new Size(W, H);
        WorldMapForm.Instance.pictureBox1.Image = Bmp;
        Wz_Vector Origin = Img.GetVector("BaseImg/0/origin");

        foreach (var Iter in PictureBoxList)
            Iter.Dispose();
        PictureBoxList.Clear();

        foreach (var Iter in Img.GetNodes("MapList"))
        {
            var SpotPos = Iter.GetVector("spot");
            string SpotType = Iter.GetInt("type").ToString();
            Bitmap SpotBmp = Wz.GetBmp("Map/MapHelper.img/worldMap/mapImage/" + SpotType);
            string SpotID = Iter.GetInt("mapNo/0").ToString().PadLeft(9, '0');
            var SpotPictureBox = new PictureBox();
            if (MapNames.ContainsKey(SpotID))
                SpotPictureBox.AccessibleDescription = SpotID + " - " + MapNames[SpotID];
            ToolTip.SetToolTip(SpotPictureBox, SpotPictureBox.AccessibleDescription);
            PictureBoxList.Add(SpotPictureBox);
            SpotPictureBox.Image = SpotBmp;
            SpotPictureBox.BackColor = System.Drawing.Color.Transparent;
            SpotPictureBox.Width = SpotBmp.Width;
            SpotPictureBox.Height = SpotBmp.Height;
            Wz_Vector SpotOrigin = Wz.GetVector("Map/MapHelper.img/worldMap/mapImage/" + SpotType + "/origin");
            SpotPictureBox.Left = W - Origin.X + SpotPos.X - SpotOrigin.X;
            SpotPictureBox.Top = H - Origin.Y + SpotPos.Y - SpotOrigin.Y;
            SpotPictureBox.Parent = WorldMapForm.Instance.pictureBox1;
            SpotPictureBox.BringToFront();

            SpotPictureBox.Click += (s, e) =>
            {
                string ID = ((PictureBox)s).AccessibleDescription.LeftStr(9).Trim(' ');
                if (Map.ID == ID)
                    return;
                if (!Wz.HasNode("Map/Map/Map" + ID.LeftStr(1) + "/" + ID + ".img"))
                    return;
                // Map.ReLoad = true;
                Map.ID = ID;
                this.LoadMap();
                if (LoadMapButton.Enabled == false)
                    LoadMapButton.Enabled = true;
            };
        }
    }

    private void FullScreenButton_Click(object sender, EventArgs e)
    {

    }

    Pen pen = new(System.Drawing.Color.FromArgb(153, 180, 209), 2);
    protected override void OnPaint(PaintEventArgs e)
    {
        base.OnPaint(e);
        e.Graphics.DrawRectangle(pen, new System.Drawing.Rectangle(256, 92, RenderForm.Width + 2, RenderForm.Height + 2));
    }
}


```

`MapleNecrocer/MainForm.resx`:

```resx
<root>
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <assembly alias="System.Drawing" name="System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
  <data name="ChatRingButton.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAABcAAAAYCAYAAAARfGZ1AAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAO
        vQAADr0BR/uQrQAAAd9JREFUSEutlQuRwzAMREOhFEKhFEKhFEKhFEIhFEohFEIhFEJBt0+2fG7r3qW9
        03TH+VhvHVmedh+GVfooakANsu00mQ2L2flWPz8UnrDMna3oJtiSxHOHTqvZspvNm9/nnF/DlqkN9mtW
        fBV4FVg/17gegiew5GCpBhf4RStn1YAxGXXfl/I0jQp4E8S2QZkXJfcFbpuugavODqQ0jNwLboOEcWMf
        Crg/JfHMDWx1g4Dv/ZxMNBZhQLnYA8bK4A48nO8+LZsoQUaA0dpdbcvaTxX8JjhfVMMLuE+KF1UkAz5d
        iQAxSCbpa7yLKBOjykOOJx6Gs7rc3xjsKo+XiusoD+9VHnI88Rhc9Vfd3YCNC/E1oVz3urRqrd5GPQDM
        eB2eDL43lRGI+rsoQ6n5qNwnOMAAN+CEg701dQaidedrEtAQc1NKimKApsvPBnHIWgaselQ+c1MKcB2c
        myYADr0yqAV0GjVX84GT9wgn3jGowxvCTXJOG75fCnweT64DBg6vwS04UQwC3jBombhBgF/BCT8wYRAr
        CoMHExdnJOCUJz9/GcWg3oOAx5kIAafbANM95CfM60hHPpv8JzjCJ7MPdFLAAYYAR7/n+W9HMuFPJCRo
        gOM9E/8SNahWI7ruC7KTJY6HzfblAAAAAElFTkSuQmCC
</value>
  </data>
  <data name="EffectRingButton.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAABcAAAAYCAYAAAARfGZ1AAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAO
        vgAADr4B6kKxwAAAAd9JREFUSEutlQuRwzAMREOhFEKhFEKhFEKhFEIhFEohFEIhFEJBt0+2fG7r3qW9
        03TH+VhvHVmedh+GVfooakANsu00mQ2L2flWPz8UnrDMna3oJtiSxHOHTqvZspvNm9/nnF/DlqkN9mtW
        fBV4FVg/17gegiew5GCpBhf4RStn1YAxGXXfl/I0jQp4E8S2QZkXJfcFbpuugavODqQ0jNwLboOEcWMf
        Crg/JfHMDWx1g4Dv/ZxMNBZhQLnYA8bK4A48nO8+LZsoQUaA0dpdbcvaTxX8JjhfVMMLuE+KF1UkAz5d
        iQAxSCbpa7yLKBOjykOOJx6Gs7rc3xjsKo+XiusoD+9VHnI88Rhc9Vfd3YCNC/E1oVz3urRqrd5GPQDM
        eB2eDL43lRGI+rsoQ6n5qNwnOMAAN+CEg701dQaidedrEtAQc1NKimKApsvPBnHIWgaselQ+c1MKcB2c
        myYADr0yqAV0GjVX84GT9wgn3jGowxvCTXJOG75fCnweT64DBg6vwS04UQwC3jBombhBgF/BCT8wYRAr
        CoMHExdnJOCUJz9/GcWg3oOAx5kIAafbANM95CfM60hHPpv8JzjCJ7MPdFLAAYYAR7/n+W9HMuFPJCRo
        gOM9E/8SNahWI7ruC7KTJY6HzfblAAAAAElFTkSuQmCC
</value>
  </data>
  <data name="ReactorButton.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAAB4AAAAcCAYAAAB2+A+pAAAABGdBTUEAALGOfPtRkwAAACBjSFJNAACH
        DwAAjA8AAP1SAACBQAAAfXkAAOmLAAA85QAAGcxzPIV3AAAKOWlDQ1BQaG90b3Nob3AgSUNDIHByb2Zp
        bGUAAEjHnZZ3VFTXFofPvXd6oc0w0hl6ky4wgPQuIB0EURhmBhjKAMMMTWyIqEBEEREBRZCggAGjoUis
        iGIhKKhgD0gQUGIwiqioZEbWSnx5ee/l5ffHvd/aZ+9z99l7n7UuACRPHy4vBZYCIJkn4Ad6ONNXhUfQ
        sf0ABniAAaYAMFnpqb5B7sFAJC83F3q6yAn8i94MAUj8vmXo6U+ng/9P0qxUvgAAyF/E5mxOOkvE+SJO
        yhSkiu0zIqbGJIoZRomZL0pQxHJijlvkpZ99FtlRzOxkHlvE4pxT2clsMfeIeHuGkCNixEfEBRlcTqaI
        b4tYM0mYzBXxW3FsMoeZDgCKJLYLOKx4EZuImMQPDnQR8XIAcKS4LzjmCxZwsgTiQ7mkpGbzuXHxArou
        S49uam3NoHtyMpM4AoGhP5OVyOSz6S4pyalMXjYAi2f+LBlxbemiIluaWltaGpoZmX5RqP+6+Dcl7u0i
        vQr43DOI1veH7a/8UuoAYMyKarPrD1vMfgA6tgIgd/8Pm+YhACRFfWu/8cV5aOJ5iRcIUm2MjTMzM424
        HJaRuKC/6386/A198T0j8Xa/l4fuyollCpMEdHHdWClJKUI+PT2VyeLQDf88xP848K/zWBrIieXwOTxR
        RKhoyri8OFG7eWyugJvCo3N5/6mJ/zDsT1qca5Eo9Z8ANcoISN2gAuTnPoCiEAESeVDc9d/75oMPBeKb
        F6Y6sTj3nwX9+65wifiRzo37HOcSGExnCfkZi2viawnQgAAkARXIAxWgAXSBITADVsAWOAI3sAL4gWAQ
        DtYCFogHyYAPMkEu2AwKQBHYBfaCSlAD6kEjaAEnQAc4DS6Ay+A6uAnugAdgBIyD52AGvAHzEARhITJE
        geQhVUgLMoDMIAZkD7lBPlAgFA5FQ3EQDxJCudAWqAgqhSqhWqgR+hY6BV2ArkID0D1oFJqCfoXewwhM
        gqmwMqwNG8MM2An2hoPhNXAcnAbnwPnwTrgCroOPwe3wBfg6fAcegZ/DswhAiAgNUUMMEQbigvghEUgs
        wkc2IIVIOVKHtCBdSC9yCxlBppF3KAyKgqKjDFG2KE9UCIqFSkNtQBWjKlFHUe2oHtQt1ChqBvUJTUYr
        oQ3QNmgv9Cp0HDoTXYAuRzeg29CX0HfQ4+g3GAyGhtHBWGE8MeGYBMw6TDHmAKYVcx4zgBnDzGKxWHms
        AdYO64dlYgXYAux+7DHsOewgdhz7FkfEqeLMcO64CBwPl4crxzXhzuIGcRO4ebwUXgtvg/fDs/HZ+BJ8
        Pb4LfwM/jp8nSBN0CHaEYEICYTOhgtBCuER4SHhFJBLVidbEACKXuIlYQTxOvEIcJb4jyZD0SS6kSJKQ
        tJN0hHSedI/0ikwma5MdyRFkAXknuZF8kfyY/FaCImEk4SXBltgoUSXRLjEo8UISL6kl6SS5VjJHslzy
        pOQNyWkpvJS2lIsUU2qDVJXUKalhqVlpirSptJ90snSxdJP0VelJGayMtoybDFsmX+awzEWZMQpC0aC4
        UFiULZR6yiXKOBVD1aF6UROoRdRvqP3UGVkZ2WWyobJZslWyZ2RHaAhNm+ZFS6KV0E7QhmjvlygvcVrC
        WbJjScuSwSVzcopyjnIcuUK5Vrk7cu/l6fJu8onyu+U75B8poBT0FQIUMhUOKlxSmFakKtoqshQLFU8o
        3leClfSVApXWKR1W6lOaVVZR9lBOVd6vfFF5WoWm4qiSoFKmclZlSpWiaq/KVS1TPaf6jC5Ld6In0Svo
        PfQZNSU1TzWhWq1av9q8uo56iHqeeqv6Iw2CBkMjVqNMo1tjRlNV01czV7NZ874WXouhFa+1T6tXa05b
        RztMe5t2h/akjpyOl06OTrPOQ12yroNumm6d7m09jB5DL1HvgN5NfVjfQj9ev0r/hgFsYGnANThgMLAU
        vdR6KW9p3dJhQ5Khk2GGYbPhqBHNyMcoz6jD6IWxpnGE8W7jXuNPJhYmSSb1Jg9MZUxXmOaZdpn+aqZv
        xjKrMrttTjZ3N99o3mn+cpnBMs6yg8vuWlAsfC22WXRbfLS0suRbtlhOWWlaRVtVWw0zqAx/RjHjijXa
        2tl6o/Vp63c2ljYCmxM2v9ga2ibaNtlOLtdZzllev3zMTt2OaVdrN2JPt4+2P2Q/4qDmwHSoc3jiqOHI
        dmxwnHDSc0pwOub0wtnEme/c5jznYuOy3uW8K+Lq4Vro2u8m4xbiVun22F3dPc692X3Gw8Jjncd5T7Sn
        t+duz2EvZS+WV6PXzAqrFetX9HiTvIO8K72f+Oj78H26fGHfFb57fB+u1FrJW9nhB/y8/Pb4PfLX8U/z
        /z4AE+AfUBXwNNA0MDewN4gSFBXUFPQm2Dm4JPhBiG6IMKQ7VDI0MrQxdC7MNaw0bGSV8ar1q66HK4Rz
        wzsjsBGhEQ0Rs6vdVu9dPR5pEVkQObRGZ03WmqtrFdYmrT0TJRnFjDoZjY4Oi26K/sD0Y9YxZ2O8Yqpj
        ZlgurH2s52xHdhl7imPHKeVMxNrFlsZOxtnF7YmbineIL4+f5rpwK7kvEzwTahLmEv0SjyQuJIUltSbj
        kqOTT/FkeIm8nhSVlKyUgVSD1ILUkTSbtL1pM3xvfkM6lL4mvVNAFf1M9Ql1hVuFoxn2GVUZbzNDM09m
        SWfxsvqy9bN3ZE/kuOd8vQ61jrWuO1ctd3Pu6Hqn9bUboA0xG7o3amzM3zi+yWPT0c2EzYmbf8gzySvN
        e70lbEtXvnL+pvyxrR5bmwskCvgFw9tst9VsR23nbu/fYb5j/45PhezCa0UmReVFH4pZxde+Mv2q4quF
        nbE7+0ssSw7uwuzi7Rra7bD7aKl0aU7p2B7fPe1l9LLCstd7o/ZeLV9WXrOPsE+4b6TCp6Jzv+b+Xfs/
        VMZX3qlyrmqtVqreUT13gH1g8KDjwZYa5ZqimveHuIfu1nrUttdp15UfxhzOOPy0PrS+92vG140NCg1F
        DR+P8I6MHA082tNo1djYpNRU0gw3C5unjkUeu/mN6zedLYYtta201qLj4Ljw+LNvo78dOuF9ovsk42TL
        d1rfVbdR2grbofbs9pmO+I6RzvDOgVMrTnV32Xa1fW/0/ZHTaqerzsieKTlLOJt/duFczrnZ86nnpy/E
        XRjrjup+cHHVxds9AT39l7wvXbnsfvlir1PvuSt2V05ftbl66hrjWsd1y+vtfRZ9bT9Y/NDWb9nffsPq
        RudN65tdA8sHzg46DF645Xrr8m2v29fvrLwzMBQydHc4cnjkLvvu5L2key/vZ9yff7DpIfph4SOpR+WP
        lR7X/aj3Y+uI5ciZUdfRvidBTx6Mscae/5T+04fx/Kfkp+UTqhONk2aTp6fcp24+W/1s/Hnq8/npgp+l
        f65+ofviu18cf+mbWTUz/pL/cuHX4lfyr468Xva6e9Z/9vGb5Dfzc4Vv5d8efcd41/s+7P3EfOYH7IeK
        j3ofuz55f3q4kLyw8Bv3hPP74uYdwgAAAAlwSFlzAAAOvAAADrwBlbxySQAACH9JREFUSEvFVllXk1kW
        vQQTIAkZSQhEKKWUKDNhJmSEDMyD4MCgAQqUSYQQkCHMgwKCVDnbWhJmUFS0Wtuhqmt1V61a3bVW9UO/
        9FO3D/XQv2L3ic880w8n3839vmTfc87e+3wMwP8l9t08iNh38yBi382DiH03DyL23TyI2HfzIIJFiJif
        VsUqLEd4LfpIvjMnguvUHWbOHDVzZkcyZ4qSOVPFzJkgZ85YCq2IOeMVzJmkZvXxEr9LyRRJUnY5QeLv
        TpT7uZLl/t1aud9AUijHo1VyBlMVHE+qkjOVovCbyVD6T6YrOPc1YlbHTko5lUMODRbqknGjOhHXTyfg
        22YdnruLsdnjwEa3HZu9djx1FeFZTwl2egqx47Lh4+gZPL5oxPlEEVoz+OjJFMOlp8iSoVsnhpvWg7oQ
        DJhCMGgWY8QSgjFrCPrNUqQp/R6xDPWh4dXWTAJNxmprFt70OfB+qAg/jJXhT55CvPPQ98EC/DhRiY/X
        S/FxpBS/ztdhtd2MjZ48dJgkmLDJMGkLw4hDhnGbBGN2GUbyQuDxgdG9UTM9kx+CtnQxGpOCoFf732V6
        Nde73qXHi24ztjrNlFUutt20vmLAdpcZL7sc2LlixmZLBl515WJvoAA/zJ7CnydO4evaNDRmCDBqEmPM
        QoCU0aiNwPJ8B1EQqBxDuVKM5coxQgcatsjRS5VICyPg/KOSLW9LFm7VxGCtOQdPewzYbDdgi2Lnsglr
        7TmfK7HWacK74XL8MldD1aikexY8vpSNLitlSkDjBDSSG4IhX4Z0HfZlbhETmAweRwhVRYH2DCF6TMHQ
        RfJusxRVwODNqhjcccbg7vlEPKxLxG1nHB7UJuB+fSIeNSTiSWs6lhu1eHIxC+st2XjUlImxiig8aMxG
        e7YCgyYRZSajXsoxaJVhmNYDlPmwTfX5IG6jFP126rlFio4cEVJknBWmEDC5WR3we5+eTmxXoc+kxIBR
        hV6LAr02WptCcSU7EL0mOa4axOjOEcJlEMJjksKVI0Z1XABFEM6nBKJeK4BTK8S5+ABUxvBRFs9Dq1aC
        puRgNKRJcClVBMdRIRKD2Tw7KWJME8QW56vTqG+VeNZrwwvq4+uBMqw2p2GpKhrLbdnYdjlw55wG85XH
        cL+Osm9KQVueCmdi/NFvEqI/U4rJojBcKwpFvzEEV7LEqDgRSCyXYKFUjVGHAhP2UBRH8/59XBggYCeF
        jCXK/BoW6c9eXbUSmazYpN4+bkjDWlMa9vqL8Xq4EN56Le6fT8Drvnw877VgsCACV41yfJXIRxNlMpuv
        gCdfibniUHxTfhhT+VRuswyV0UHoogpdKwzBDLG+KjroP0eETMjog8VIOB2Pm83469wZLF9Mx62zJ7Dd
        acTz4QJsX8zBnVoNNltzSFb5WDgbh7ZsKe7WpeFbZyyWKkMJWIwL8XxcL5BTa2SYLlZivkxFsgqh9khQ
        qQnEpEOJmxUqlMUGffpCwBGx6GDGYoNZ842aZDwl5j5pzsDL/jwquQEPa+JwrzEF7/sLidk56CQ5dGRw
        qfzH8OyyAXNlERghsJliBWpjuTgbE4yZAiJUnghTBUpcp9KPE7ku60Wojg3CDOm7Mpr/KVoYKGJkhyyW
        z24N5kdhz+dQbhu2WjKJ3UnY7jCSbu1YrDqB1sxgLFTF4/vJCrzxlGGnNxczRZQV6XSaMlsoUeCrFD7O
        xQkxRX2eIe2OWamvdJApuxxOIl8b9b0mQUDATMSigpjqTKriv7suO3Y7dVhtSMByUyq+GyjGWoueiCIj
        Fsup5yl47bGRXVrJZMhoqDo3TkdhgqQzSgDjdgXmipToJK2WR/E+y2uaDuCh309Tf33m0pQigFnN/RQj
        JmB1IDtUnSz519u+XDwlB3veY8UWWeG1UxqivwBz1Rq8pV6/GSjCbg8drjsPL7rysE0ON1ukprIKMVpA
        lmgnZyKjmC0JJZkFozxegCG7FDdLQzFB7J+xK4nZYjiiuJRxgIiFU48TpP6PxqxqfHMuhjw7CZ3pInTq
        +HhYH4vlS1R2Zzzu1MXjdm08HtTHEamS8bBBS89w4c4UYMBAetdL0GcMphATgBydtF92hO6Tcw1TRfrI
        ZAbIVm1HeZ80wdxgphEysSVK9I+JwmNYqkvAaPGXuF2jxd8WzuO3pQb8PF9DbK/Fz9dq8NONavx4vRp/
        maWYrMJP06fJaCJwWsPgjA/CBepjdQJFbCAak4NwJjYAJcc5OHcyABeSBGhI5MEcwf09WczkLE7q17FI
        gB/HS/DrDSe+GyzE7tU8/NFTjo80od4Pl+LDUCnejRTjgy+GS/D9WAneDhXi0UUD+kuOoC2NDzf19KpR
        gkHKeMiXHTmbhybXMPn4EJHPrRPATVOq6ITgn3EkYaZTBy3ed2pJNqlYp4Gw0a7HRkcGVkjP3tY0eC/p
        4G3LgLddh7VWIh/59irN6/VuCyYqjhPgl+gxK0lGys/snnKEYsRKfaXyTlvlZCQU1OtJYvdYYSiKjvN+
        SxAGMGZUcxd95r/VYcDeoAWvXL5RaMfLARv2fFcaia/cViJdHl1teEnke0m2uusyYak6DkOOaPSR+V8r
        kJJ2VRgvIEBysEkCmSlXYCY/HLOlKlKGb5BIUazh//2okM+YOZJ37/aFJDwk49h1GfGMMtkhkF0CeOry
        zWYalV0Gilxs0ZvHc9LvC2rFrtuOe1+lY64uhfQcjsViNb4uVWKxNPyza/muSxVhWKL9xdIIGo0KOlwo
        SjXCXzRCf8biZKzWouZ8MEZyN3JCAjayw/3XzId5m1kq5jWEHVoxRASt6MK4K4ZwtmIMY96scN6mUcVZ
        14VyvJYjgpX86OAVy9GAFX04z0tvFpvmw9w1/WHeMul106DmrusPc70mNXfFHhnotUdy99KUh/5wQsLk
        /wOUA+SNZLt5JgAAAABJRU5ErkJggg==
</value>
  </data>
  <data name="SoulEffectButton.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAAB8AAAAeCAYAAADU8sWcAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAO
        vAAADrwBlbxySQAAA6JJREFUSEu9lm3RtDoQRLGABSxgAQtYiAUsYAELWIiFWMDCWsjtM8mwgWWfrffP
        naouIIQ5PfkAuv8zcs4rqpffQ51yPT1jHud+6MZ8V98NpqGqdr9EBXt8GnhsrDH3a17nPW/rnpd5yWEK
        eRrmPI3SMOWxlxFkBoqp+qgFuQ1b4sqhobRfbwBF+7LnFI8c95Q3ncc95n0rZtZlk9a8hDWHOeRxwMin
        CXLf899dEdbBoGvMR3zl11HvKI7jyLvggOaqFJMpStu65XmazUTf9R+j8BHKeam8Bd/jSDlv25ZDWKxi
        hAFMuRgZzA19n7s6CgaqQZ56WkLXP8GMQNpfGmKBVSEA193AOAwysat9ejTwGMDTfuTXjc31S1WX+V2K
        gVr5U/UO5zhpGn7CAR87kCuZZMxzjNEgCwaqWHiIdubcwSklO9Jux18GTvjxhpOEIU6xwBy+a95pc93h
        MbITFjvvNVV21AKsqGsAXrqY17ArwRu+rjKUdhmKNukOtgVQ5QaUxgw4HAEmOpnjnXBWr7beThQnXPuW
        YfQ4tLxDCCf8LkAupfmo3tr1YuI4jQ28jbGb8zKWHcfqZagRq7Udwm/nBmngjFDbx/rZW/ALPEyLzR0O
        HT4O/ZnEIa7TxLaYOFcqg2PCDbh4LT/CaQy8tyvcBZw59wQMP2qvfQoCe7qBuwHXn3AdSqfGAG0kRS3I
        Tfg196neF97dAPknje4jnM+iDifcDdAGhMQAHNbKK27VwtHYTXkL8Tu8fo8v1XPd6smAV6ssue8nE8DW
        wBa0PRV8ktX3Gu8fgs/h53rUTiAp53c4I2N99M2nD325fsOjhjzkPaTnygmHj42BtvppSXa8wxHVA8WA
        9/Pqj3Tov0C7QXOu9uegeubGpabTgA/tt3lH3HOZGXaK4ETaDp/W78H7t8DN5QknEQlF+YC28l3gcH63
        +DzXYv4OhzNHnPN7BPxiQJC0Lvr6CaLjHRw3vmQFHEP5E/r6UXkIMzAP+kkYy6LzxUdS5CAXphyKeI4F
        xkABVpzfkcdQh/YHr4xAP1uiWW8nN9CauGvXSLCtUtlZXvFvcOl+GuABm3czoSHEgL/7EQvItygfjVCr
        5Y+n3DPwWDVI301UMB3oyAOTNEuWaNQentjHdTsyKuukD5AUV825oAVo0KVRkMhDzq8GHOxQfxhTK4k/
        VSpE6oOsb6N/grcV8xByE3/J+zrIRa7fw17Dq/ehf5InvMufc5HL1UTX/QfTKBoZNJCinAAAAABJRU5E
        rkJggg==
</value>
  </data>
  <data name="TotemEffectButton.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAAB8AAAAeCAYAAADU8sWcAAAABGdBTUEAALGOfPtRkwAAACBjSFJNAACH
        DwAAjA8AAP1SAACBQAAAfXkAAOmLAAA85QAAGcxzPIV3AAAKOWlDQ1BQaG90b3Nob3AgSUNDIHByb2Zp
        bGUAAEjHnZZ3VFTXFofPvXd6oc0w0hl6ky4wgPQuIB0EURhmBhjKAMMMTWyIqEBEEREBRZCggAGjoUis
        iGIhKKhgD0gQUGIwiqioZEbWSnx5ee/l5ffHvd/aZ+9z99l7n7UuACRPHy4vBZYCIJkn4Ad6ONNXhUfQ
        sf0ABniAAaYAMFnpqb5B7sFAJC83F3q6yAn8i94MAUj8vmXo6U+ng/9P0qxUvgAAyF/E5mxOOkvE+SJO
        yhSkiu0zIqbGJIoZRomZL0pQxHJijlvkpZ99FtlRzOxkHlvE4pxT2clsMfeIeHuGkCNixEfEBRlcTqaI
        b4tYM0mYzBXxW3FsMoeZDgCKJLYLOKx4EZuImMQPDnQR8XIAcKS4LzjmCxZwsgTiQ7mkpGbzuXHxArou
        S49uam3NoHtyMpM4AoGhP5OVyOSz6S4pyalMXjYAi2f+LBlxbemiIluaWltaGpoZmX5RqP+6+Dcl7u0i
        vQr43DOI1veH7a/8UuoAYMyKarPrD1vMfgA6tgIgd/8Pm+YhACRFfWu/8cV5aOJ5iRcIUm2MjTMzM424
        HJaRuKC/6386/A198T0j8Xa/l4fuyollCpMEdHHdWClJKUI+PT2VyeLQDf88xP848K/zWBrIieXwOTxR
        RKhoyri8OFG7eWyugJvCo3N5/6mJ/zDsT1qca5Eo9Z8ANcoISN2gAuTnPoCiEAESeVDc9d/75oMPBeKb
        F6Y6sTj3nwX9+65wifiRzo37HOcSGExnCfkZi2viawnQgAAkARXIAxWgAXSBITADVsAWOAI3sAL4gWAQ
        DtYCFogHyYAPMkEu2AwKQBHYBfaCSlAD6kEjaAEnQAc4DS6Ay+A6uAnugAdgBIyD52AGvAHzEARhITJE
        geQhVUgLMoDMIAZkD7lBPlAgFA5FQ3EQDxJCudAWqAgqhSqhWqgR+hY6BV2ArkID0D1oFJqCfoXewwhM
        gqmwMqwNG8MM2An2hoPhNXAcnAbnwPnwTrgCroOPwe3wBfg6fAcegZ/DswhAiAgNUUMMEQbigvghEUgs
        wkc2IIVIOVKHtCBdSC9yCxlBppF3KAyKgqKjDFG2KE9UCIqFSkNtQBWjKlFHUe2oHtQt1ChqBvUJTUYr
        oQ3QNmgv9Cp0HDoTXYAuRzeg29CX0HfQ4+g3GAyGhtHBWGE8MeGYBMw6TDHmAKYVcx4zgBnDzGKxWHms
        AdYO64dlYgXYAux+7DHsOewgdhz7FkfEqeLMcO64CBwPl4crxzXhzuIGcRO4ebwUXgtvg/fDs/HZ+BJ8
        Pb4LfwM/jp8nSBN0CHaEYEICYTOhgtBCuER4SHhFJBLVidbEACKXuIlYQTxOvEIcJb4jyZD0SS6kSJKQ
        tJN0hHSedI/0ikwma5MdyRFkAXknuZF8kfyY/FaCImEk4SXBltgoUSXRLjEo8UISL6kl6SS5VjJHslzy
        pOQNyWkpvJS2lIsUU2qDVJXUKalhqVlpirSptJ90snSxdJP0VelJGayMtoybDFsmX+awzEWZMQpC0aC4
        UFiULZR6yiXKOBVD1aF6UROoRdRvqP3UGVkZ2WWyobJZslWyZ2RHaAhNm+ZFS6KV0E7QhmjvlygvcVrC
        WbJjScuSwSVzcopyjnIcuUK5Vrk7cu/l6fJu8onyu+U75B8poBT0FQIUMhUOKlxSmFakKtoqshQLFU8o
        3leClfSVApXWKR1W6lOaVVZR9lBOVd6vfFF5WoWm4qiSoFKmclZlSpWiaq/KVS1TPaf6jC5Ld6In0Svo
        PfQZNSU1TzWhWq1av9q8uo56iHqeeqv6Iw2CBkMjVqNMo1tjRlNV01czV7NZ874WXouhFa+1T6tXa05b
        RztMe5t2h/akjpyOl06OTrPOQ12yroNumm6d7m09jB5DL1HvgN5NfVjfQj9ev0r/hgFsYGnANThgMLAU
        vdR6KW9p3dJhQ5Khk2GGYbPhqBHNyMcoz6jD6IWxpnGE8W7jXuNPJhYmSSb1Jg9MZUxXmOaZdpn+aqZv
        xjKrMrttTjZ3N99o3mn+cpnBMs6yg8vuWlAsfC22WXRbfLS0suRbtlhOWWlaRVtVWw0zqAx/RjHjijXa
        2tl6o/Vp63c2ljYCmxM2v9ga2ibaNtlOLtdZzllev3zMTt2OaVdrN2JPt4+2P2Q/4qDmwHSoc3jiqOHI
        dmxwnHDSc0pwOub0wtnEme/c5jznYuOy3uW8K+Lq4Vro2u8m4xbiVun22F3dPc692X3Gw8Jjncd5T7Sn
        t+duz2EvZS+WV6PXzAqrFetX9HiTvIO8K72f+Oj78H26fGHfFb57fB+u1FrJW9nhB/y8/Pb4PfLX8U/z
        /z4AE+AfUBXwNNA0MDewN4gSFBXUFPQm2Dm4JPhBiG6IMKQ7VDI0MrQxdC7MNaw0bGSV8ar1q66HK4Rz
        wzsjsBGhEQ0Rs6vdVu9dPR5pEVkQObRGZ03WmqtrFdYmrT0TJRnFjDoZjY4Oi26K/sD0Y9YxZ2O8Yqpj
        ZlgurH2s52xHdhl7imPHKeVMxNrFlsZOxtnF7YmbineIL4+f5rpwK7kvEzwTahLmEv0SjyQuJIUltSbj
        kqOTT/FkeIm8nhSVlKyUgVSD1ILUkTSbtL1pM3xvfkM6lL4mvVNAFf1M9Ql1hVuFoxn2GVUZbzNDM09m
        SWfxsvqy9bN3ZE/kuOd8vQ61jrWuO1ctd3Pu6Hqn9bUboA0xG7o3amzM3zi+yWPT0c2EzYmbf8gzySvN
        e70lbEtXvnL+pvyxrR5bmwskCvgFw9tst9VsR23nbu/fYb5j/45PhezCa0UmReVFH4pZxde+Mv2q4quF
        nbE7+0ssSw7uwuzi7Rra7bD7aKl0aU7p2B7fPe1l9LLCstd7o/ZeLV9WXrOPsE+4b6TCp6Jzv+b+Xfs/
        VMZX3qlyrmqtVqreUT13gH1g8KDjwZYa5ZqimveHuIfu1nrUttdp15UfxhzOOPy0PrS+92vG140NCg1F
        DR+P8I6MHA082tNo1djYpNRU0gw3C5unjkUeu/mN6zedLYYtta201qLj4Ljw+LNvo78dOuF9ovsk42TL
        d1rfVbdR2grbofbs9pmO+I6RzvDOgVMrTnV32Xa1fW/0/ZHTaqerzsieKTlLOJt/duFczrnZ86nnpy/E
        XRjrjup+cHHVxds9AT39l7wvXbnsfvlir1PvuSt2V05ftbl66hrjWsd1y+vtfRZ9bT9Y/NDWb9nffsPq
        RudN65tdA8sHzg46DF645Xrr8m2v29fvrLwzMBQydHc4cnjkLvvu5L2key/vZ9yff7DpIfph4SOpR+WP
        lR7X/aj3Y+uI5ciZUdfRvidBTx6Mscae/5T+04fx/Kfkp+UTqhONk2aTp6fcp24+W/1s/Hnq8/npgp+l
        f65+ofviu18cf+mbWTUz/pL/cuHX4lfyr468Xva6e9Z/9vGb5Dfzc4Vv5d8efcd41/s+7P3EfOYH7IeK
        j3ofuz55f3q4kLyw8Bv3hPP74uYdwgAAAAlwSFlzAAAOvAAADrwBlbxySQAABAZJREFUSEudlw2R4zAM
        hUshFEIhFEIhFEqhFEIhFEKhFEIhFEIh9z7Zz1Wy25ub88xbyX96kiw73Yfb9D47YRRmdc+uH45uGFf1
        +4rLnHTm3qn/FHpsudFnnHl1T+mzgJ2urKhNA4OwSD2H8Xki1Q+DAhti7jh3zwXxcbzdX4RJYD2BAGyG
        w8km6wbppanDhpfUvOgtQA5xzEG873PMR1/Ey2vK68nGS2AfjqCHk8s8n9M1qC6ne2XiRo6XpKpEKXLI
        um4IMPYNdX8jvpHjVA95O0svGIdRxvuADQBHCvphOqfXqry+iiNaOz6VFcnnvDQnMnEiJ6Dh0YnaBHdy
        Gwmjkibv+jGIgUm9ZttLTQyy8YU4jkc2Vu0tlQhYaOJmRJviKDTGeZvcYLxB6zO5kckNOfCUTOcseSdf
        tl0ZUGHUc3a6jXGSw0I/FBvOlonRDeynmpokS8RecE855JDiwPhcfhBDakQmtCef+fy6RgxEXM4cxYPb
        XjZB7jETE7GjvyAdgckNjmjQPnTxRG0JVDr3P64aSruPOADY+HiQgZJyJBjGUt1IHMpkgH3UBoA4Ry4O
        ri636/PCqRMOSA3i56pU9xju/kpssK+gC8l+UALg+S1SHDxCo/Rrqw7EE/qJvPs1ujuGet5OO8T5JRzG
        OTtQHpjcNMBLx7PXHpVCbAe6c1PxgderGGb8t3M+zvLeQwimecvkP6Ov5LzHQT6pspEFJf0mZ4z+Z77c
        CqSz4P3rfjRyMsCYOOLrJr00ddrHJRM/9XJBhPHcGKfpkWrrmmMi3zRX9BL9jZyq55aVhidCfFw+G2Xk
        RvqtXbKifXYA6egB8wmf82aAhnRa/4f8CQnHpHH6Ya9Gj87jVMevKach85n+iwMmHiZdVZEjY6/mwl4i
        B+Kjtn4nj0pODrhxtsxlh74Rgxy9AbFQzlxKVLonv8FF5uZiZA7CTJpS+2MM8jpWmgZ4ZLhqXAOewfYD
        cV0KSVwjyTtYY9zPFQn6vnwvbLOiNA0SPQ5Q9Tw28fMJaDp+QkFEtDhhRxxxeYicev3ISEQQ5/NOWbkQ
        T53+SkIc184g+mnUFaoORNS1iLLhTG54Dc82xH6QTEy0FFz8HkcyyTebNzp52jKAbqIUaTjMvc5VzpPr
        9INWhJWYyjsUHaSHCA8Rh66NIUUUkjXKQOiGCC79DJFlNOLg1B8i3kW4azJAH2iOr1zry4Gmg21fdzkT
        ujLSdF097mHoSvEuwgbGIBbibX+LMKDNFIjPnE8fkqy8RfxWei03jW1avykLP3Sj7r2PfX7JqBHdBfpY
        hGeAvqJa9IukSRVOyLp+VZ+zDlivJFxd7CCtx79TWtPut6+Y9ViA1BKO5V9BpCGrHWw0aDy1x+MPBf+y
        xF63tsAAAAAASUVORK5CYII=
</value>
  </data>
  <data name="EtcButton.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAABgAAAAVCAYAAABc6S4mAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAO
        vAAADrwBlbxySQAAAcJJREFUSEu1lA2VgzAQhLEQC1iIBSzEAhawgIVYiAUsxAIWYmFvZvNDmuN613vt
        8uYVmjDfZrNhejGk6CMhNhqZj89AZE+r+LSJPYyY/b0QCWmXQ7z+KiBMb4GowSFBkkQ5icAKZppTHtoa
        5CWQvsCS0LRGxP0S7QUoqyDErH8H6UYy04jMBbnX2M9S/x7AVXSQDnQb2iHb6bTeBKQCOPG0JYcVzDrn
        FkI9gYjBi8yQ2WdAhlB8ZsnciRLFPFf1wkp0EuvLFRAShJ2zo3M2NV/PRVegZRrNfwHkwQKggcNm0pAw
        is/NvDftNQLcBcmDA2TUQ3uOxlUdoF9FHiiAJpjRVI2H/2/FsQKx3qouAImEVNCdRvO60RA7qyYze4Ny
        rmLDMgB6VVgPrYBqiG6iLPbGYZ9WfEZWNIQ72W04M+FaASNvSlGDVONi3htnczSDdtyBs8Ir4S6iQbYH
        c4aYDqCQIfN7c7RxMeeR5MEkYE/+G4DRStQAMNe6spPYpkULWpjmPCk05KeQF+8JpFe2/B462GpfAMzW
        sb5Fud5e8nEMOIwENeMfzftokxWC8uTs0X74XKjwzFL1c6F/xWgy6klM0xcBF68YIO9XsAAAAABJRU5E
        rkJggg==
</value>
  </data>
  <data name="CashButton.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAABoAAAAbCAYAAABiFp9rAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAO
        vAAADrwBlbxySQAAAYZJREFUSEu1lAGRhDAMRbGABSychbWAhbWABSxgAQtYqAUsnIVef5p000JLy7F/
        5g+Q0DwSCl2DbOKvyJrdklfzS0ZM+RFZqB/n4GFc7Gveg3EP+7aoCw0RkHYCvCUaU/9yAO0M+D8wO7w3
        2/+8jzBtBbwL+4CKMJdLusNaX+JaBMETBlACRMF953wKc2tRw5cqKwJFnfE1csYYO01TBGvtigrNm9sM
        CUggOKLgOI4h19pVKAYQbXGMimEaIiO8DdIQ+mAVKAuBXUyPrwSjpIAgfEs0QgU7hQhIwzKgCCKAMCpA
        GEbng3s3YgHUgkoQMrrgYhI7dHMBqoJoU0EHiO5xBiQHssuyVEGipxZLR2y9DrU9wsuu63oLIjlt1FMO
        om7whbdAMkXFp6Ju8M8CrAQJ126XYR27WgECILpLAQKhcwfZto2MfxzW+zLX8u+HIbQp5tn/KBXoDNYK
        ggJIIDDOEUOeuuRxCgxxWt2oAwQxNvQsLHGqAwwxn3pen46+DIIEUAnpuj8szWsE0Bl/UgAAAABJRU5E
        rkJggg==
</value>
  </data>
  <data name="ConsumeButton.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAABsAAAAbCAYAAACN1PRVAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAO
        vAAADrwBlbxySQAAAVpJREFUSEu11QFtwzAQBdBQKIVRKIVRKIVQCAVTMAVTCIVQCIVQ8O6f+7er4y62
        k37pS17r3LMzTRuyRNOPJgb/0Lrp26KXw78QMZTB92nb+RQh1Huv2Lptl4E7aBq/PocRIcQCA4ROssbe
        Qpvzgmid087LovVhVpDhIfDss9VJw55ADlnQhiC+w4w06jg6iM0BrjG4lNOgrcVsbbpAdHRefz/Ewvx3
        UwtvF4DIC1jC2PzFdt0QD1jM47M3Xe73KNeMGw4gP7eCuhmQkzWh8E/n202utcYIUNZ6kEpQN+aQDjjo
        FoKiWE/4rALcYS1d5W90keJ5vFLMS2PLUQwnG6W1qH2tAL28TjxbfTuC6MOs8bkthvJQFtVDtmCoBYla
        DH0H1mDIIZijJbAWQ3YgsRqwBWK6b9iDIc1gL8RUg2chRgcRzUH+p8C+tP18dBhRAga5DLKxww+QYfgB
        eiyMBUvEAtAAAAAASUVORK5CYII=
</value>
  </data>
  <data name="AndroidButton.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAAB0AAAAdCAYAAABWk2cPAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAO
        vAAADrwBlbxySQAAAftJREFUSEu1lQGVgzAQRLFwFmqhFs4CFrCAhVrAAhawcBawgAUuf2HS7TZQeuXm
        vXkLm2Q+SWlbHdS849NlwdM8b1pzVn+kl7Bxmp6sdQS8KwuVIiwa2DAuDvDDsiAv3XtQNKBu+HmAk7VE
        7ssCjsjPExQYYA8nc4ne1lPY1kOorzlYu/VgMpfosopB6qHYj467LYCfHqIYEntyHOO+BMVk43qYzet9
        VQQQEHuyny/gHhSN7Lq97zyH+MoCD/Zj9Kky93LbDUXg0I+PUIUrjAWXus19P6bxeC8DxRHY3foMRDmE
        SkjddvPUXTIYEyQQ41qjMQHJw21zM5eAki0ShApUYMJUNa571vEQmBwEDAHkmr5RnGwCixQmoAfPQ51B
        mkPVOuV44O4uEQvx/JMWJYCAXFtv7WuefyCqcgCp1nWzD2VShq6AB2Ds+7F07XNU2fVLaHVNQWP6BnsI
        nlIQjv2xX+pfoLzW9oELCoCqa29A3g6qHH1NZMaMFGQTqRYSQVt2UH2uEUwPwJY0YT26wi69IzCdEu+E
        z1l9WLZggbujtCMXrMm7E1Df1dVvKwaY2+/0k9l8WVUPWAB+JAVY4PWS/v7SzmT1fWXyKQImYD7mdLz5
        aO8+R8AM4uVfov7+y5WmnwJewuNbKwu87vos8BK853+AIgUd9QFV1S9UFrM7LUFuYQAAAABJRU5ErkJg
        gg==
</value>
  </data>
  <data name="FamiliarButton.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAABYAAAAeCAYAAAAo5+5WAAAABGdBTUEAALGOfPtRkwAAACBjSFJNAACH
        DwAAjA8AAP1SAACBQAAAfXkAAOmLAAA85QAAGcxzPIV3AAAKOWlDQ1BQaG90b3Nob3AgSUNDIHByb2Zp
        bGUAAEjHnZZ3VFTXFofPvXd6oc0w0hl6ky4wgPQuIB0EURhmBhjKAMMMTWyIqEBEEREBRZCggAGjoUis
        iGIhKKhgD0gQUGIwiqioZEbWSnx5ee/l5ffHvd/aZ+9z99l7n7UuACRPHy4vBZYCIJkn4Ad6ONNXhUfQ
        sf0ABniAAaYAMFnpqb5B7sFAJC83F3q6yAn8i94MAUj8vmXo6U+ng/9P0qxUvgAAyF/E5mxOOkvE+SJO
        yhSkiu0zIqbGJIoZRomZL0pQxHJijlvkpZ99FtlRzOxkHlvE4pxT2clsMfeIeHuGkCNixEfEBRlcTqaI
        b4tYM0mYzBXxW3FsMoeZDgCKJLYLOKx4EZuImMQPDnQR8XIAcKS4LzjmCxZwsgTiQ7mkpGbzuXHxArou
        S49uam3NoHtyMpM4AoGhP5OVyOSz6S4pyalMXjYAi2f+LBlxbemiIluaWltaGpoZmX5RqP+6+Dcl7u0i
        vQr43DOI1veH7a/8UuoAYMyKarPrD1vMfgA6tgIgd/8Pm+YhACRFfWu/8cV5aOJ5iRcIUm2MjTMzM424
        HJaRuKC/6386/A198T0j8Xa/l4fuyollCpMEdHHdWClJKUI+PT2VyeLQDf88xP848K/zWBrIieXwOTxR
        RKhoyri8OFG7eWyugJvCo3N5/6mJ/zDsT1qca5Eo9Z8ANcoISN2gAuTnPoCiEAESeVDc9d/75oMPBeKb
        F6Y6sTj3nwX9+65wifiRzo37HOcSGExnCfkZi2viawnQgAAkARXIAxWgAXSBITADVsAWOAI3sAL4gWAQ
        DtYCFogHyYAPMkEu2AwKQBHYBfaCSlAD6kEjaAEnQAc4DS6Ay+A6uAnugAdgBIyD52AGvAHzEARhITJE
        geQhVUgLMoDMIAZkD7lBPlAgFA5FQ3EQDxJCudAWqAgqhSqhWqgR+hY6BV2ArkID0D1oFJqCfoXewwhM
        gqmwMqwNG8MM2An2hoPhNXAcnAbnwPnwTrgCroOPwe3wBfg6fAcegZ/DswhAiAgNUUMMEQbigvghEUgs
        wkc2IIVIOVKHtCBdSC9yCxlBppF3KAyKgqKjDFG2KE9UCIqFSkNtQBWjKlFHUe2oHtQt1ChqBvUJTUYr
        oQ3QNmgv9Cp0HDoTXYAuRzeg29CX0HfQ4+g3GAyGhtHBWGE8MeGYBMw6TDHmAKYVcx4zgBnDzGKxWHms
        AdYO64dlYgXYAux+7DHsOewgdhz7FkfEqeLMcO64CBwPl4crxzXhzuIGcRO4ebwUXgtvg/fDs/HZ+BJ8
        Pb4LfwM/jp8nSBN0CHaEYEICYTOhgtBCuER4SHhFJBLVidbEACKXuIlYQTxOvEIcJb4jyZD0SS6kSJKQ
        tJN0hHSedI/0ikwma5MdyRFkAXknuZF8kfyY/FaCImEk4SXBltgoUSXRLjEo8UISL6kl6SS5VjJHslzy
        pOQNyWkpvJS2lIsUU2qDVJXUKalhqVlpirSptJ90snSxdJP0VelJGayMtoybDFsmX+awzEWZMQpC0aC4
        UFiULZR6yiXKOBVD1aF6UROoRdRvqP3UGVkZ2WWyobJZslWyZ2RHaAhNm+ZFS6KV0E7QhmjvlygvcVrC
        WbJjScuSwSVzcopyjnIcuUK5Vrk7cu/l6fJu8onyu+U75B8poBT0FQIUMhUOKlxSmFakKtoqshQLFU8o
        3leClfSVApXWKR1W6lOaVVZR9lBOVd6vfFF5WoWm4qiSoFKmclZlSpWiaq/KVS1TPaf6jC5Ld6In0Svo
        PfQZNSU1TzWhWq1av9q8uo56iHqeeqv6Iw2CBkMjVqNMo1tjRlNV01czV7NZ874WXouhFa+1T6tXa05b
        RztMe5t2h/akjpyOl06OTrPOQ12yroNumm6d7m09jB5DL1HvgN5NfVjfQj9ev0r/hgFsYGnANThgMLAU
        vdR6KW9p3dJhQ5Khk2GGYbPhqBHNyMcoz6jD6IWxpnGE8W7jXuNPJhYmSSb1Jg9MZUxXmOaZdpn+aqZv
        xjKrMrttTjZ3N99o3mn+cpnBMs6yg8vuWlAsfC22WXRbfLS0suRbtlhOWWlaRVtVWw0zqAx/RjHjijXa
        2tl6o/Vp63c2ljYCmxM2v9ga2ibaNtlOLtdZzllev3zMTt2OaVdrN2JPt4+2P2Q/4qDmwHSoc3jiqOHI
        dmxwnHDSc0pwOub0wtnEme/c5jznYuOy3uW8K+Lq4Vro2u8m4xbiVun22F3dPc692X3Gw8Jjncd5T7Sn
        t+duz2EvZS+WV6PXzAqrFetX9HiTvIO8K72f+Oj78H26fGHfFb57fB+u1FrJW9nhB/y8/Pb4PfLX8U/z
        /z4AE+AfUBXwNNA0MDewN4gSFBXUFPQm2Dm4JPhBiG6IMKQ7VDI0MrQxdC7MNaw0bGSV8ar1q66HK4Rz
        wzsjsBGhEQ0Rs6vdVu9dPR5pEVkQObRGZ03WmqtrFdYmrT0TJRnFjDoZjY4Oi26K/sD0Y9YxZ2O8Yqpj
        ZlgurH2s52xHdhl7imPHKeVMxNrFlsZOxtnF7YmbineIL4+f5rpwK7kvEzwTahLmEv0SjyQuJIUltSbj
        kqOTT/FkeIm8nhSVlKyUgVSD1ILUkTSbtL1pM3xvfkM6lL4mvVNAFf1M9Ql1hVuFoxn2GVUZbzNDM09m
        SWfxsvqy9bN3ZE/kuOd8vQ61jrWuO1ctd3Pu6Hqn9bUboA0xG7o3amzM3zi+yWPT0c2EzYmbf8gzySvN
        e70lbEtXvnL+pvyxrR5bmwskCvgFw9tst9VsR23nbu/fYb5j/45PhezCa0UmReVFH4pZxde+Mv2q4quF
        nbE7+0ssSw7uwuzi7Rra7bD7aKl0aU7p2B7fPe1l9LLCstd7o/ZeLV9WXrOPsE+4b6TCp6Jzv+b+Xfs/
        VMZX3qlyrmqtVqreUT13gH1g8KDjwZYa5ZqimveHuIfu1nrUttdp15UfxhzOOPy0PrS+92vG140NCg1F
        DR+P8I6MHA082tNo1djYpNRU0gw3C5unjkUeu/mN6zedLYYtta201qLj4Ljw+LNvo78dOuF9ovsk42TL
        d1rfVbdR2grbofbs9pmO+I6RzvDOgVMrTnV32Xa1fW/0/ZHTaqerzsieKTlLOJt/duFczrnZ86nnpy/E
        XRjrjup+cHHVxds9AT39l7wvXbnsfvlir1PvuSt2V05ftbl66hrjWsd1y+vtfRZ9bT9Y/NDWb9nffsPq
        RudN65tdA8sHzg46DF645Xrr8m2v29fvrLwzMBQydHc4cnjkLvvu5L2key/vZ9yff7DpIfph4SOpR+WP
        lR7X/aj3Y+uI5ciZUdfRvidBTx6Mscae/5T+04fx/Kfkp+UTqhONk2aTp6fcp24+W/1s/Hnq8/npgp+l
        f65+ofviu18cf+mbWTUz/pL/cuHX4lfyr468Xva6e9Z/9vGb5Dfzc4Vv5d8efcd41/s+7P3EfOYH7IeK
        j3ofuz55f3q4kLyw8Bv3hPP74uYdwgAAAAlwSFlzAAAOvAAADrwBlbxySQAAAudJREFUSEu1lguR7CAQ
        RWMBC1jAAhawgIVYwAIWsBALYyEWxgLvniakMp99u7W1k6quABMOl9sNNcu+7/0TYWDvfQ8h/Nm7ljLA
        dHLOfxIGrp8Gs4V3H/0mPmxF/T24lNy3LffWHiOlixUxenXySzD5GVgvwHWNfXGuL57w9g4B1rRCAykG
        LTCCds6xb4eKE6rFGEMVIKexuG09tto9219XGz/BOeV+v3dB7ppUlMyoBWp3UgMY5RPKwm7VQrdbb5pU
        9U5b656EaXxBcTk8XrXSfNTV5HIGyoEDDbIMZZu+k46eBTRYSkfImqtilCX9QNAvlbEo6O1UXasmSk07
        oIHJwJT4JQpI0H8Ee/vce44lWb2fYGocMElJ8hKo+an+IlsMbAH4SfHVChaoRUp9EjSZ0lJSd4LgaVay
        TJ3BBOctmAV9A7/xmCQ6Ny4Uso+3lJXXN4AdmT+hiqw+Y0fiKL9T8YBE8zhoS24ZZQeU8CrHqKyvqgDz
        cVpQDqDss37Wb4BnVaQ0fERha1sv69a9VOcczkMQb6Nep49mByVmQMHNHqy4KB7nexZ/7GLokEiNgF6T
        grbqUAcAsMZNNWMswi7mTh6tGHfFOMpJKovBF1XLPAycslFSimkFNjAG/EjcA5hSArzqQyzh7lDydSJ1
        AFAtZbGpbYoFBA54qp3t04rD4+vthmoSt+93Ux2DbKC+BWABp98XfNeJNOUAUa125P3OiglmB/ORUCXz
        bsfbUzHAojwGjHJCcKC3nQN1uTanFROMz7TnI4vNmlK4sJrtAv9nOF1aKVWD7/qY8n2xYvo84EntZvcH
        D4eHhy42ERLZ19wOcJAILU49P1txhTep5zhT3xye6++cVt5AuAH5zuyQ4sJJfLbiGkzEGlvkm+DOHuDN
        5r1Y8ZMA8G4MtTcl40sr/hckZooBNmJ4C3hYcyoef41+GhNuCs+QUsuD1C7LAPMHg9qzmO2v3kcbOBAS
        RSJprwe01tL/AdaK3eBEzyxhAAAAAElFTkSuQmCC
</value>
  </data>
  <data name="PetButton.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAAB8AAAAdCAYAAABSZrcyAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAO
        vAAADrwBlbxySQAAActJREFUSEu9kwF1g0AQRGOhFrAQC1iIhVrAQi3EQi3UQixgIRYof8Nch81BmkI6
        780Lt3u3f/cChw0akl+uArv2X+H+cg5b7iUqQAd/ntuZ2Td5s0qx4XoJIL+KZfC5Ow7dexOe9vxZBcCE
        QAV2mLx3A8P76RgFHOzOoAzf0kAcHKkB1kv10bVD2zZh1hm0G9zBTEWs7/u4kVoDPANXA6f2LUx89K91
        BxZcUKy/RTCe/eqfhcfGGtgbcPukrB0uT3sXFRsCOoGX4NkOokaOeQ5Q1ggcxmu8TaVvmQPA+c1AuTa1
        4oLK5IFlBRg3zW2TGlib3MEqrrhDPQ8sK6Cy3wDmYAbXIJypxT0PrKYC7rquwDmUp88Tq7DnPYcfvfFK
        hjU1drgXzmdq4JVPLa/n0AxXYfZhh7Amv9KcK+rxe1v+KII1sHIOISeTy2B7lnK9qpQsFkRgYjQnqwGs
        4qkZ9BDsmn1yDlYcs1Y+gw1e9kzrhyoAQWTgsq+1T414A8+AJR3wQ3dwbxBYDT55s6JQbgDTANfrf4PB
        d1EUBwRYUztY8DT5Zs2KC+rxfwH7ldbiu4L9ih2cr35vMCovFwDW8lJ89K5aKrwUX9Hh8A0D2HOSMrob
        kwAAAABJRU5ErkJggg==
</value>
  </data>
  <data name="RingButton.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAABcAAAAcCAYAAACK7SRjAAAABGdBTUEAALGOfPtRkwAAACBjSFJNAACH
        DwAAjA8AAP1SAACBQAAAfXkAAOmLAAA85QAAGcxzPIV3AAAKOWlDQ1BQaG90b3Nob3AgSUNDIHByb2Zp
        bGUAAEjHnZZ3VFTXFofPvXd6oc0w0hl6ky4wgPQuIB0EURhmBhjKAMMMTWyIqEBEEREBRZCggAGjoUis
        iGIhKKhgD0gQUGIwiqioZEbWSnx5ee/l5ffHvd/aZ+9z99l7n7UuACRPHy4vBZYCIJkn4Ad6ONNXhUfQ
        sf0ABniAAaYAMFnpqb5B7sFAJC83F3q6yAn8i94MAUj8vmXo6U+ng/9P0qxUvgAAyF/E5mxOOkvE+SJO
        yhSkiu0zIqbGJIoZRomZL0pQxHJijlvkpZ99FtlRzOxkHlvE4pxT2clsMfeIeHuGkCNixEfEBRlcTqaI
        b4tYM0mYzBXxW3FsMoeZDgCKJLYLOKx4EZuImMQPDnQR8XIAcKS4LzjmCxZwsgTiQ7mkpGbzuXHxArou
        S49uam3NoHtyMpM4AoGhP5OVyOSz6S4pyalMXjYAi2f+LBlxbemiIluaWltaGpoZmX5RqP+6+Dcl7u0i
        vQr43DOI1veH7a/8UuoAYMyKarPrD1vMfgA6tgIgd/8Pm+YhACRFfWu/8cV5aOJ5iRcIUm2MjTMzM424
        HJaRuKC/6386/A198T0j8Xa/l4fuyollCpMEdHHdWClJKUI+PT2VyeLQDf88xP848K/zWBrIieXwOTxR
        RKhoyri8OFG7eWyugJvCo3N5/6mJ/zDsT1qca5Eo9Z8ANcoISN2gAuTnPoCiEAESeVDc9d/75oMPBeKb
        F6Y6sTj3nwX9+65wifiRzo37HOcSGExnCfkZi2viawnQgAAkARXIAxWgAXSBITADVsAWOAI3sAL4gWAQ
        DtYCFogHyYAPMkEu2AwKQBHYBfaCSlAD6kEjaAEnQAc4DS6Ay+A6uAnugAdgBIyD52AGvAHzEARhITJE
        geQhVUgLMoDMIAZkD7lBPlAgFA5FQ3EQDxJCudAWqAgqhSqhWqgR+hY6BV2ArkID0D1oFJqCfoXewwhM
        gqmwMqwNG8MM2An2hoPhNXAcnAbnwPnwTrgCroOPwe3wBfg6fAcegZ/DswhAiAgNUUMMEQbigvghEUgs
        wkc2IIVIOVKHtCBdSC9yCxlBppF3KAyKgqKjDFG2KE9UCIqFSkNtQBWjKlFHUe2oHtQt1ChqBvUJTUYr
        oQ3QNmgv9Cp0HDoTXYAuRzeg29CX0HfQ4+g3GAyGhtHBWGE8MeGYBMw6TDHmAKYVcx4zgBnDzGKxWHms
        AdYO64dlYgXYAux+7DHsOewgdhz7FkfEqeLMcO64CBwPl4crxzXhzuIGcRO4ebwUXgtvg/fDs/HZ+BJ8
        Pb4LfwM/jp8nSBN0CHaEYEICYTOhgtBCuER4SHhFJBLVidbEACKXuIlYQTxOvEIcJb4jyZD0SS6kSJKQ
        tJN0hHSedI/0ikwma5MdyRFkAXknuZF8kfyY/FaCImEk4SXBltgoUSXRLjEo8UISL6kl6SS5VjJHslzy
        pOQNyWkpvJS2lIsUU2qDVJXUKalhqVlpirSptJ90snSxdJP0VelJGayMtoybDFsmX+awzEWZMQpC0aC4
        UFiULZR6yiXKOBVD1aF6UROoRdRvqP3UGVkZ2WWyobJZslWyZ2RHaAhNm+ZFS6KV0E7QhmjvlygvcVrC
        WbJjScuSwSVzcopyjnIcuUK5Vrk7cu/l6fJu8onyu+U75B8poBT0FQIUMhUOKlxSmFakKtoqshQLFU8o
        3leClfSVApXWKR1W6lOaVVZR9lBOVd6vfFF5WoWm4qiSoFKmclZlSpWiaq/KVS1TPaf6jC5Ld6In0Svo
        PfQZNSU1TzWhWq1av9q8uo56iHqeeqv6Iw2CBkMjVqNMo1tjRlNV01czV7NZ874WXouhFa+1T6tXa05b
        RztMe5t2h/akjpyOl06OTrPOQ12yroNumm6d7m09jB5DL1HvgN5NfVjfQj9ev0r/hgFsYGnANThgMLAU
        vdR6KW9p3dJhQ5Khk2GGYbPhqBHNyMcoz6jD6IWxpnGE8W7jXuNPJhYmSSb1Jg9MZUxXmOaZdpn+aqZv
        xjKrMrttTjZ3N99o3mn+cpnBMs6yg8vuWlAsfC22WXRbfLS0suRbtlhOWWlaRVtVWw0zqAx/RjHjijXa
        2tl6o/Vp63c2ljYCmxM2v9ga2ibaNtlOLtdZzllev3zMTt2OaVdrN2JPt4+2P2Q/4qDmwHSoc3jiqOHI
        dmxwnHDSc0pwOub0wtnEme/c5jznYuOy3uW8K+Lq4Vro2u8m4xbiVun22F3dPc692X3Gw8Jjncd5T7Sn
        t+duz2EvZS+WV6PXzAqrFetX9HiTvIO8K72f+Oj78H26fGHfFb57fB+u1FrJW9nhB/y8/Pb4PfLX8U/z
        /z4AE+AfUBXwNNA0MDewN4gSFBXUFPQm2Dm4JPhBiG6IMKQ7VDI0MrQxdC7MNaw0bGSV8ar1q66HK4Rz
        wzsjsBGhEQ0Rs6vdVu9dPR5pEVkQObRGZ03WmqtrFdYmrT0TJRnFjDoZjY4Oi26K/sD0Y9YxZ2O8Yqpj
        ZlgurH2s52xHdhl7imPHKeVMxNrFlsZOxtnF7YmbineIL4+f5rpwK7kvEzwTahLmEv0SjyQuJIUltSbj
        kqOTT/FkeIm8nhSVlKyUgVSD1ILUkTSbtL1pM3xvfkM6lL4mvVNAFf1M9Ql1hVuFoxn2GVUZbzNDM09m
        SWfxsvqy9bN3ZE/kuOd8vQ61jrWuO1ctd3Pu6Hqn9bUboA0xG7o3amzM3zi+yWPT0c2EzYmbf8gzySvN
        e70lbEtXvnL+pvyxrR5bmwskCvgFw9tst9VsR23nbu/fYb5j/45PhezCa0UmReVFH4pZxde+Mv2q4quF
        nbE7+0ssSw7uwuzi7Rra7bD7aKl0aU7p2B7fPe1l9LLCstd7o/ZeLV9WXrOPsE+4b6TCp6Jzv+b+Xfs/
        VMZX3qlyrmqtVqreUT13gH1g8KDjwZYa5ZqimveHuIfu1nrUttdp15UfxhzOOPy0PrS+92vG140NCg1F
        DR+P8I6MHA082tNo1djYpNRU0gw3C5unjkUeu/mN6zedLYYtta201qLj4Ljw+LNvo78dOuF9ovsk42TL
        d1rfVbdR2grbofbs9pmO+I6RzvDOgVMrTnV32Xa1fW/0/ZHTaqerzsieKTlLOJt/duFczrnZ86nnpy/E
        XRjrjup+cHHVxds9AT39l7wvXbnsfvlir1PvuSt2V05ftbl66hrjWsd1y+vtfRZ9bT9Y/NDWb9nffsPq
        RudN65tdA8sHzg46DF645Xrr8m2v29fvrLwzMBQydHc4cnjkLvvu5L2key/vZ9yff7DpIfph4SOpR+WP
        lR7X/aj3Y+uI5ciZUdfRvidBTx6Mscae/5T+04fx/Kfkp+UTqhONk2aTp6fcp24+W/1s/Hnq8/npgp+l
        f65+ofviu18cf+mbWTUz/pL/cuHX4lfyr468Xva6e9Z/9vGb5Dfzc4Vv5d8efcd41/s+7P3EfOYH7IeK
        j3ofuz55f3q4kLyw8Bv3hPP74uYdwgAAAAlwSFlzAAAOvAAADrwBlbxySQAAAc9JREFUSEu1lQF1hDAQ
        RLFwFrBQC1jAAhawgAUsYAELWMBCLGxnNpkcTXMcbek85sEl2T8hCe8aM/s3VxvvcrXxLlcb73K18S6f
        ib2lpVqffCoftM6NbfTS2L5Gq4/tYdrNtuAO825h3CwM62mArVMdzGfb2wgGzMDNwnNYETJstr8IiGDY
        wXAJpjlDn3Ep5uFtCA/T9iUgg3cHdRjdA9I+4fx9Ae7Lg7cgM6ITnOD2Ec02B9r2hMNeXFuWBcvCvhTO
        +m/g7iOC2ZHuqEZBChLAAzBDOswRHJcE7bhS7QHcRqvjoBziewGIgxQkMO6+ZLhSzSU4FWevE5MDUgg2
        UeB5fDIuw7m5hPsmM4AbyKUhFEtRgimsW2sD1ppg3sfuegDNPSNU5rg4PMEJFPgETn0DH10cCFcOoKf+
        fYA8DY31GNsDSg94HlCf+l141c4WvBLB8psAyhbMlgEjxhPMuhJO/TqAB4JrrZo6PPQZPg8P94UAhx/B
        NTiVAwSvBNRCPEDgV3DKv0QFaEYKKELc/EYEL49iTTnguAeC65uQCedpI5jHkfUR81oeoJA7wZIP5j7w
        JAlOoEywPqA0/seKIfwTkQEVWP0c+BcdQUdX1DSfkL+WGjHheF0AAAAASUVORK5CYII=
</value>
  </data>
  <data name="TitleButton.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAACAAAAAeCAYAAABNChwpAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAO
        vAAADrwBlbxySQAAAr1JREFUWEetlgF1hDAQRM9CLZyFWjgLZ+EsYAELWMBCLGABC1hI52+yNAGuF3id
        13mEJdmdneQot0bEgo5Tsa/7vYydQozLEmMIcekHS3ZXsm3saN6b2CmsCRiT5FEUPxO7KmJNkG5vcXg8
        L8cuCyAZY7ryxO9i7PW7GGQNiVthSVBOomkYLUkVGxtjwxDnaY7Dq2sWEQGLSTJpIUkW7SvJiY16Frqu
        ioXnKwbNLWPkIOYCnvfvJhEmwBYpgQlRUqfHHB7z4g6fN4UpBjmIgHHs4zRV52MHW0zxsmiJWcnmro/L
        GHIkYZkXFQsrKQq8+6FPAsa+bxfgWJQMznTJOKQxsFieW4pGBODqAuj+01mwRZ7ExnQyTaokUYzVqbKa
        CyZCz1yMIwnQGoHrKfsBDjjWohKQiAAV1SFbxxsBE4KF0n6KN9kPzAGszkwCMvlj/9eYRJUitNYbKO2f
        Na/JfmDd0QUFdF3Yz1wcmADGLmIjIF3SNlA0BP10tQV/CbBFjkpALowIp4E6eoYYL16enUv2+2KuHLKo
        016KsGc4QlGJpLDTnhUC3H46n7WmyX5+y3Z1AVsXrLhE2STRnym+bkHGafutaD48lgyrCwFe+Gj/Va0S
        cO30k88F6OrWQvslFEVNjAtQpzYnWw8q+1tPvxdnG3wvrSvrsNgKcX0J8bIx1g6U9n8SkFaQ90BAJaIU
        kItxdTou2U/RmU7sJjNjFXCw10e4ZL8LQP2iRYm1C07uS/gcJwI6vg2wX6L/tN+69o7rvDtsCx3Ri7v9
        gz5aqJPK7ZG6Lsjh2bJ+/vv//h356sF+BCCGOqncHrHTF0uvSRVlmTGP7UBl+jO/Zz1F4Evjx9e3CcD+
        FgFAb9s0+RODXsstxH4EfLK/hPaPL6A96wOyofZ8S069nXyJaOneUdn8X2z9Anb45P/mG9xuPwPHkc6m
        3LRTAAAAAElFTkSuQmCC
</value>
  </data>
  <data name="MedalButton.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAAB8AAAAgCAYAAADqgqNBAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAO
        vAAADrwBlbxySQAAA4FJREFUWEe9lo2RozAMRmmBFmiBFmiBFmghLdBCWnALaSEt0AIt+L4nWcQ4yV72
        duc0o/hP1pNkA+kqyf9RnyTnPOa0dHkcx3y7pZxSsv40jWqnPKmfNL/2XVm/WrtqLy22bj9VPq7WX4be
        fMNx3Flyvnd5v/UGyXnP8zwfbSjjfSTQ/dB98nFrFy3BA759AUdi0bR1tFTjAEYgYRvr0W99Sj8W24CT
        KKtlUUodR0Aba9g10B9LHnRmwzCYMm411rArc78qOW993tYDWIut3S8v135FzHEDeTf3a3IAAmKqCkw6
        b9oYh03sYfNP5Aka4+ukVrd6Gt7bsN/dfF/eOnSwZJ2sIYCwb/cwj7PvyMNJKSdz6Ak8D65Zb78SwGnv
        PwZwOGg2P4PRyQNg3c3K/nPgH8k7MOLwGhyq7wLrbmbylZ+3YsbrKFWJKTNzNt+CyRjlFWuv2SMALff2
        MVnk52/wetGg2iGNj8eU70s56xo+aw7ngAXST7kTWkP3QR+qzoLAr7s/sUzynnxy0LMbj5GdbZxv5oNR
        +nXGQEu766sIcOOTW3S/ewXwi//t+gxHfKMuyQl+ylSaZXeUWna65btaMtzU3wQysPq0WfMcAZ9ULb4E
        Izkre8pFAImSIjUYKG0DNqhAB7go/w0Az7IH/irresIifcBV6hpalzrABnU9wOpf1cYreNW3fyvH6phH
        XxAvx77qds8eQFJ7DkB9so3zVRvQe5VxUt/AesTGnifGs75dZKNLa7ym/PYXSp6tBUrUBOA3X2fflloA
        ynwv0NAWTDKAKTnQpgKHlABkIMOkKCOAC1A9qwYW8JFxgapNggWYmz1KL4JbyQP85qaH+J9IPR6cO1nz
        ssmb5gUg81elRvk7BZw2Ml8Izt5wH4DJclsHKzubOCvLmmrUGRegqwJUG+BFY+4M2ZM5JU+cd1E4jnuI
        bQBiqnNZOW+d8wPuYGCUmccIOM93wBf5WZhLeqmoP8uuLjv6rgI2uWOol00Y2rtZ8DpbgJQ2SgwMKFkT
        AOv2plQCSU9QA30C12IGGHMMBleWURUyxvFWwckSIK9olLm+U2V0bz6FtuLnpXOfdN6MgXCROEtaAhjK
        mJZ17HqqQMkVPGOcfUeOUiUBGPu0X0J7/CwAbxmTJetu5oHzTOOHsU9/LrHpcGgBPV4Sp5LSb0DHmo1+
        KK+ctf12/Qvpuj+N/4wyHrrabAAAAABJRU5ErkJggg==
</value>
  </data>
  <data name="ObjInfoButton.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAO
        vAAADrwBlbxySQAAApRJREFUWEe9lg21ozAQhbGAhVqohVrAAhZqAQu1gAUsYAELWMjON+TmDSxdsu+c
        dnruCfm9XyahbXOI9CWdRprm5SvCa7P8Ce/4VgzjvIPYmXfd8FEpIkQBYEAzp6K7nl9P15xeO3VpcjV9
        V8bRzqdZbA5irtYxCaIKYFi3RVNadsZ8ZL6DMMPbms0z9E41AK0Nkrb4MZdxMTHt6hnCzXI/fcghrb0a
        4JGvxZJGN9dOj5KRCwAz6Vdrn6yOAojPuQJ4WdrPYjWMIwwLUyoDrRn248vH98uU2mUoGSgQVwB3e3Tl
        hcZsGiXTaF52bFnAnGeNieMuAUg9aST5hEz9XEnvPG6plmQcAHbPQQ5zBdCFm0/iZUy7joeSuo+VgRmu
        3SON91sxp963zW7sfwFwDJqMetNoPZQapyPBLFma02hZMlPqRwDXFQCLa9c8v5NnxYwBKOZShlAZ51UD
        xEnPYXA9Ortgue1099kcDbfWzfVaa94lwBPDKDPmO+lpQwRBuwA4V85dxgggAGIAwbxLABHHXROUqKM9
        A2AuUEHI3I8gB6sj1r0EIDBi1wQlu6eN3waXtQGgOgsTGKP12Z8C2AHVA2j3EpPPJHMCU8wFIGOZoyqA
        mHoMePXeKQKM9233EvVoXg0Qg5t7hKAuxcAwTbaGSVnAlLvyK4CtdQvMplyehXYqCAFgrrel6jV8F8rE
        u4gAOgJAqPer/dHJX8+/BojZOIuzDJQsmDkl+ggAfQI4QsyP+1Z/WUbmip/jo5EWl46hdoxJMRJAvAuY
        Vx0BF02L1krmftks3QD4HVjHrTQQh7O+SwAWAyLqaIiU7mheLluA4Agi3D8BCAZ8UooIQOwgPh1Hc4V3
        fEN4bZZ/hzo/rRxN8wdcOxlxzReN2wAAAABJRU5ErkJggg==
</value>
  </data>
  <data name="DamageSkinButton.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAO
        vAAADrwBlbxySQAAA6hJREFUWEe9lQGR6zgQRE0hFELBFExBFEzBFExBFERBFETBFERB955s78/mcnHu
        V+1Oba/j2NPdMxopw1O0X8LLaFutvwK1dsk/0R/8VsRcvpn4Jh7m9UdxxqOJLwO+sKTSwgOWmFtJuaUl
        tQWsc2x5TS1yXb0HcYkH9vssfD6bk9sc5SltlvMw8Z8GjK1sXXgiKa655RBbva9/jUJ+y1vnvjRQ+awB
        UTCheLuRdM+tzZAswGvwWvbPVyC/0o1a6rWBkLYWbJmVm0QFXRyev45bamWMfSkuDUwaAPNaWp6sPrXG
        n1EnXAzL56BBPeCQK0S4rwz0YUE8zrnVGwZsIY/rBJv39xd4JS466b4EkW6un3SAIehrv+G42vpT/JXA
        O5zVD7FzyWlcGshslX3tqexR3FeecYafI/8O8W7c4FqpPsEX6WphJ1wa2NdeAwifIl5D2c0IPu/3CCgy
        0mY1z+oNdkul+hQSnA72xrb+yABbcMSApAb3mqlMcRtIfkJ1SBWHvN35LIg6JHgwwCxZlOITXbo0kHh5
        swNWqjiTr6EYOA0hc3mK86H4uT1T7YJf4iOGWUKrzwyerU9c42dDyJ9JiG4IeFU8LoXjmHvF2Q1fS4QH
        xfs9UVfMYCRRxMxBFchbKeqMSwOZM2AlaSF5ZZ292pWkAUg3Wr7dDnGqrzd2zLDDsHo76OAF5qCvP7B6
        uS8NTFQQBMm6LyZiIDJwxRPtpmp/nQ4h5lqf4jPH+Ei3eHdDzN+RSZ5uorZR3isDI0McltrbtrF2nQjC
        TKVd3DUnNoa0IFzohti/cwcxdBxeiwfZxpniLyomJjg79ycGfNlkK00OH7OQB26OpSwjxIfwlzjVF8ST
        646BiXsH0HAA5b1/ZGDGAMkrrrPrTlVpYDewC40tQHiv32AUO9J3ym5ghmPh6vzMdoD7O9yXBnxJEyFg
        gi0YES+IGhu5r8T9Pt8x7AHFV+6YiXxFR3L7Fc7PDJAgpoljANJ045mPWXs/p8GO/IFRIE4MZKZ6IzF0
        Cj/i5L02gPAIAogMXYbceBY+YeSRdzG70LGFX78Apomq4ZDvROe9MjBCJgJYNYBr45V4dfcdnbFbgeE0
        1+4pdnI94v8ZcAkgrfsJ2+PRgEujicgOWZiH6ch9h2sDd14EE5BUAx1UeXbjMQpby0GdNXDkvsPHBvrL
        QBMriJoRDuITXKr5Ie8d3howfOEnccajAeObiZ+OZ/Ez+oPfgFq75L/jfPjTOGIY/gHvk/NmzgGzfQAA
        AABJRU5ErkJggg==
</value>
  </data>
  <data name="MorphButton.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAABGdBTUEAALGOfPtRkwAAACBjSFJNAACH
        DwAAjA8AAP1SAACBQAAAfXkAAOmLAAA85QAAGcxzPIV3AAAKOWlDQ1BQaG90b3Nob3AgSUNDIHByb2Zp
        bGUAAEjHnZZ3VFTXFofPvXd6oc0w0hl6ky4wgPQuIB0EURhmBhjKAMMMTWyIqEBEEREBRZCggAGjoUis
        iGIhKKhgD0gQUGIwiqioZEbWSnx5ee/l5ffHvd/aZ+9z99l7n7UuACRPHy4vBZYCIJkn4Ad6ONNXhUfQ
        sf0ABniAAaYAMFnpqb5B7sFAJC83F3q6yAn8i94MAUj8vmXo6U+ng/9P0qxUvgAAyF/E5mxOOkvE+SJO
        yhSkiu0zIqbGJIoZRomZL0pQxHJijlvkpZ99FtlRzOxkHlvE4pxT2clsMfeIeHuGkCNixEfEBRlcTqaI
        b4tYM0mYzBXxW3FsMoeZDgCKJLYLOKx4EZuImMQPDnQR8XIAcKS4LzjmCxZwsgTiQ7mkpGbzuXHxArou
        S49uam3NoHtyMpM4AoGhP5OVyOSz6S4pyalMXjYAi2f+LBlxbemiIluaWltaGpoZmX5RqP+6+Dcl7u0i
        vQr43DOI1veH7a/8UuoAYMyKarPrD1vMfgA6tgIgd/8Pm+YhACRFfWu/8cV5aOJ5iRcIUm2MjTMzM424
        HJaRuKC/6386/A198T0j8Xa/l4fuyollCpMEdHHdWClJKUI+PT2VyeLQDf88xP848K/zWBrIieXwOTxR
        RKhoyri8OFG7eWyugJvCo3N5/6mJ/zDsT1qca5Eo9Z8ANcoISN2gAuTnPoCiEAESeVDc9d/75oMPBeKb
        F6Y6sTj3nwX9+65wifiRzo37HOcSGExnCfkZi2viawnQgAAkARXIAxWgAXSBITADVsAWOAI3sAL4gWAQ
        DtYCFogHyYAPMkEu2AwKQBHYBfaCSlAD6kEjaAEnQAc4DS6Ay+A6uAnugAdgBIyD52AGvAHzEARhITJE
        geQhVUgLMoDMIAZkD7lBPlAgFA5FQ3EQDxJCudAWqAgqhSqhWqgR+hY6BV2ArkID0D1oFJqCfoXewwhM
        gqmwMqwNG8MM2An2hoPhNXAcnAbnwPnwTrgCroOPwe3wBfg6fAcegZ/DswhAiAgNUUMMEQbigvghEUgs
        wkc2IIVIOVKHtCBdSC9yCxlBppF3KAyKgqKjDFG2KE9UCIqFSkNtQBWjKlFHUe2oHtQt1ChqBvUJTUYr
        oQ3QNmgv9Cp0HDoTXYAuRzeg29CX0HfQ4+g3GAyGhtHBWGE8MeGYBMw6TDHmAKYVcx4zgBnDzGKxWHms
        AdYO64dlYgXYAux+7DHsOewgdhz7FkfEqeLMcO64CBwPl4crxzXhzuIGcRO4ebwUXgtvg/fDs/HZ+BJ8
        Pb4LfwM/jp8nSBN0CHaEYEICYTOhgtBCuER4SHhFJBLVidbEACKXuIlYQTxOvEIcJb4jyZD0SS6kSJKQ
        tJN0hHSedI/0ikwma5MdyRFkAXknuZF8kfyY/FaCImEk4SXBltgoUSXRLjEo8UISL6kl6SS5VjJHslzy
        pOQNyWkpvJS2lIsUU2qDVJXUKalhqVlpirSptJ90snSxdJP0VelJGayMtoybDFsmX+awzEWZMQpC0aC4
        UFiULZR6yiXKOBVD1aF6UROoRdRvqP3UGVkZ2WWyobJZslWyZ2RHaAhNm+ZFS6KV0E7QhmjvlygvcVrC
        WbJjScuSwSVzcopyjnIcuUK5Vrk7cu/l6fJu8onyu+U75B8poBT0FQIUMhUOKlxSmFakKtoqshQLFU8o
        3leClfSVApXWKR1W6lOaVVZR9lBOVd6vfFF5WoWm4qiSoFKmclZlSpWiaq/KVS1TPaf6jC5Ld6In0Svo
        PfQZNSU1TzWhWq1av9q8uo56iHqeeqv6Iw2CBkMjVqNMo1tjRlNV01czV7NZ874WXouhFa+1T6tXa05b
        RztMe5t2h/akjpyOl06OTrPOQ12yroNumm6d7m09jB5DL1HvgN5NfVjfQj9ev0r/hgFsYGnANThgMLAU
        vdR6KW9p3dJhQ5Khk2GGYbPhqBHNyMcoz6jD6IWxpnGE8W7jXuNPJhYmSSb1Jg9MZUxXmOaZdpn+aqZv
        xjKrMrttTjZ3N99o3mn+cpnBMs6yg8vuWlAsfC22WXRbfLS0suRbtlhOWWlaRVtVWw0zqAx/RjHjijXa
        2tl6o/Vp63c2ljYCmxM2v9ga2ibaNtlOLtdZzllev3zMTt2OaVdrN2JPt4+2P2Q/4qDmwHSoc3jiqOHI
        dmxwnHDSc0pwOub0wtnEme/c5jznYuOy3uW8K+Lq4Vro2u8m4xbiVun22F3dPc692X3Gw8Jjncd5T7Sn
        t+duz2EvZS+WV6PXzAqrFetX9HiTvIO8K72f+Oj78H26fGHfFb57fB+u1FrJW9nhB/y8/Pb4PfLX8U/z
        /z4AE+AfUBXwNNA0MDewN4gSFBXUFPQm2Dm4JPhBiG6IMKQ7VDI0MrQxdC7MNaw0bGSV8ar1q66HK4Rz
        wzsjsBGhEQ0Rs6vdVu9dPR5pEVkQObRGZ03WmqtrFdYmrT0TJRnFjDoZjY4Oi26K/sD0Y9YxZ2O8Yqpj
        ZlgurH2s52xHdhl7imPHKeVMxNrFlsZOxtnF7YmbineIL4+f5rpwK7kvEzwTahLmEv0SjyQuJIUltSbj
        kqOTT/FkeIm8nhSVlKyUgVSD1ILUkTSbtL1pM3xvfkM6lL4mvVNAFf1M9Ql1hVuFoxn2GVUZbzNDM09m
        SWfxsvqy9bN3ZE/kuOd8vQ61jrWuO1ctd3Pu6Hqn9bUboA0xG7o3amzM3zi+yWPT0c2EzYmbf8gzySvN
        e70lbEtXvnL+pvyxrR5bmwskCvgFw9tst9VsR23nbu/fYb5j/45PhezCa0UmReVFH4pZxde+Mv2q4quF
        nbE7+0ssSw7uwuzi7Rra7bD7aKl0aU7p2B7fPe1l9LLCstd7o/ZeLV9WXrOPsE+4b6TCp6Jzv+b+Xfs/
        VMZX3qlyrmqtVqreUT13gH1g8KDjwZYa5ZqimveHuIfu1nrUttdp15UfxhzOOPy0PrS+92vG140NCg1F
        DR+P8I6MHA082tNo1djYpNRU0gw3C5unjkUeu/mN6zedLYYtta201qLj4Ljw+LNvo78dOuF9ovsk42TL
        d1rfVbdR2grbofbs9pmO+I6RzvDOgVMrTnV32Xa1fW/0/ZHTaqerzsieKTlLOJt/duFczrnZ86nnpy/E
        XRjrjup+cHHVxds9AT39l7wvXbnsfvlir1PvuSt2V05ftbl66hrjWsd1y+vtfRZ9bT9Y/NDWb9nffsPq
        RudN65tdA8sHzg46DF645Xrr8m2v29fvrLwzMBQydHc4cnjkLvvu5L2key/vZ9yff7DpIfph4SOpR+WP
        lR7X/aj3Y+uI5ciZUdfRvidBTx6Mscae/5T+04fx/Kfkp+UTqhONk2aTp6fcp24+W/1s/Hnq8/npgp+l
        f65+ofviu18cf+mbWTUz/pL/cuHX4lfyr468Xva6e9Z/9vGb5Dfzc4Vv5d8efcd41/s+7P3EfOYH7IeK
        j3ofuz55f3q4kLyw8Bv3hPP74uYdwgAAAAlwSFlzAAAOvAAADrwBlbxySQAAAYtJREFUSEvFl4FxgkAU
        RK8FWqAFW7CFtEALtmALtEALtmALtmAL5u9xq8vx7yCQkDezwz/u2KcmZiYh8brdH4cErlGZpEdxHe6j
        XKUnG/eEnC6PGJKvo5xir0hzedbXSOwxQTjf3FA+E3tlvA9K+wjPqMSbwap3zELiyfVMOFupZT5DPM6L
        4lxKcF+jNJ2VWgCu3rxZXKPtnzH53Ni16a3UqIq3SEE7mMxSm4virdK1TMX28TPyldsNurQbrBJj1pQo
        ncPMTlfc2lcsRsS4Yq3RUlI7995L3cAXW7r0EH77sSa6p+Be6Rz3GFAWp1fmitOeUjvHPQZMxM0wHuIV
        cK3hnlI7l++BmZjRcsyaEqVzmLUbTMX9J518bHtBl3aDTIw/aZ982QPIVvh83gsm4nB9vkOhyjkvRc9y
        1m5QFqefBcDMLOGdxazdYJUY5Osa3rPaDVaL9/AjMfIb8lyKgJk4P7hH7kkRUH3HDAq2xOtCwCrx3uQv
        AkzEQA/8RUgU/9u/MIl444jAFUII34eCnrjW7VXMAAAAAElFTkSuQmCC
</value>
  </data>
  <data name="CashEffectButton.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAYAAAByDd+UAAAABGdBTUEAALGOfPtRkwAAACBjSFJNAACH
        DwAAjA8AAP1SAACBQAAAfXkAAOmLAAA85QAAGcxzPIV3AAAKOWlDQ1BQaG90b3Nob3AgSUNDIHByb2Zp
        bGUAAEjHnZZ3VFTXFofPvXd6oc0w0hl6ky4wgPQuIB0EURhmBhjKAMMMTWyIqEBEEREBRZCggAGjoUis
        iGIhKKhgD0gQUGIwiqioZEbWSnx5ee/l5ffHvd/aZ+9z99l7n7UuACRPHy4vBZYCIJkn4Ad6ONNXhUfQ
        sf0ABniAAaYAMFnpqb5B7sFAJC83F3q6yAn8i94MAUj8vmXo6U+ng/9P0qxUvgAAyF/E5mxOOkvE+SJO
        yhSkiu0zIqbGJIoZRomZL0pQxHJijlvkpZ99FtlRzOxkHlvE4pxT2clsMfeIeHuGkCNixEfEBRlcTqaI
        b4tYM0mYzBXxW3FsMoeZDgCKJLYLOKx4EZuImMQPDnQR8XIAcKS4LzjmCxZwsgTiQ7mkpGbzuXHxArou
        S49uam3NoHtyMpM4AoGhP5OVyOSz6S4pyalMXjYAi2f+LBlxbemiIluaWltaGpoZmX5RqP+6+Dcl7u0i
        vQr43DOI1veH7a/8UuoAYMyKarPrD1vMfgA6tgIgd/8Pm+YhACRFfWu/8cV5aOJ5iRcIUm2MjTMzM424
        HJaRuKC/6386/A198T0j8Xa/l4fuyollCpMEdHHdWClJKUI+PT2VyeLQDf88xP848K/zWBrIieXwOTxR
        RKhoyri8OFG7eWyugJvCo3N5/6mJ/zDsT1qca5Eo9Z8ANcoISN2gAuTnPoCiEAESeVDc9d/75oMPBeKb
        F6Y6sTj3nwX9+65wifiRzo37HOcSGExnCfkZi2viawnQgAAkARXIAxWgAXSBITADVsAWOAI3sAL4gWAQ
        DtYCFogHyYAPMkEu2AwKQBHYBfaCSlAD6kEjaAEnQAc4DS6Ay+A6uAnugAdgBIyD52AGvAHzEARhITJE
        geQhVUgLMoDMIAZkD7lBPlAgFA5FQ3EQDxJCudAWqAgqhSqhWqgR+hY6BV2ArkID0D1oFJqCfoXewwhM
        gqmwMqwNG8MM2An2hoPhNXAcnAbnwPnwTrgCroOPwe3wBfg6fAcegZ/DswhAiAgNUUMMEQbigvghEUgs
        wkc2IIVIOVKHtCBdSC9yCxlBppF3KAyKgqKjDFG2KE9UCIqFSkNtQBWjKlFHUe2oHtQt1ChqBvUJTUYr
        oQ3QNmgv9Cp0HDoTXYAuRzeg29CX0HfQ4+g3GAyGhtHBWGE8MeGYBMw6TDHmAKYVcx4zgBnDzGKxWHms
        AdYO64dlYgXYAux+7DHsOewgdhz7FkfEqeLMcO64CBwPl4crxzXhzuIGcRO4ebwUXgtvg/fDs/HZ+BJ8
        Pb4LfwM/jp8nSBN0CHaEYEICYTOhgtBCuER4SHhFJBLVidbEACKXuIlYQTxOvEIcJb4jyZD0SS6kSJKQ
        tJN0hHSedI/0ikwma5MdyRFkAXknuZF8kfyY/FaCImEk4SXBltgoUSXRLjEo8UISL6kl6SS5VjJHslzy
        pOQNyWkpvJS2lIsUU2qDVJXUKalhqVlpirSptJ90snSxdJP0VelJGayMtoybDFsmX+awzEWZMQpC0aC4
        UFiULZR6yiXKOBVD1aF6UROoRdRvqP3UGVkZ2WWyobJZslWyZ2RHaAhNm+ZFS6KV0E7QhmjvlygvcVrC
        WbJjScuSwSVzcopyjnIcuUK5Vrk7cu/l6fJu8onyu+U75B8poBT0FQIUMhUOKlxSmFakKtoqshQLFU8o
        3leClfSVApXWKR1W6lOaVVZR9lBOVd6vfFF5WoWm4qiSoFKmclZlSpWiaq/KVS1TPaf6jC5Ld6In0Svo
        PfQZNSU1TzWhWq1av9q8uo56iHqeeqv6Iw2CBkMjVqNMo1tjRlNV01czV7NZ874WXouhFa+1T6tXa05b
        RztMe5t2h/akjpyOl06OTrPOQ12yroNumm6d7m09jB5DL1HvgN5NfVjfQj9ev0r/hgFsYGnANThgMLAU
        vdR6KW9p3dJhQ5Khk2GGYbPhqBHNyMcoz6jD6IWxpnGE8W7jXuNPJhYmSSb1Jg9MZUxXmOaZdpn+aqZv
        xjKrMrttTjZ3N99o3mn+cpnBMs6yg8vuWlAsfC22WXRbfLS0suRbtlhOWWlaRVtVWw0zqAx/RjHjijXa
        2tl6o/Vp63c2ljYCmxM2v9ga2ibaNtlOLtdZzllev3zMTt2OaVdrN2JPt4+2P2Q/4qDmwHSoc3jiqOHI
        dmxwnHDSc0pwOub0wtnEme/c5jznYuOy3uW8K+Lq4Vro2u8m4xbiVun22F3dPc692X3Gw8Jjncd5T7Sn
        t+duz2EvZS+WV6PXzAqrFetX9HiTvIO8K72f+Oj78H26fGHfFb57fB+u1FrJW9nhB/y8/Pb4PfLX8U/z
        /z4AE+AfUBXwNNA0MDewN4gSFBXUFPQm2Dm4JPhBiG6IMKQ7VDI0MrQxdC7MNaw0bGSV8ar1q66HK4Rz
        wzsjsBGhEQ0Rs6vdVu9dPR5pEVkQObRGZ03WmqtrFdYmrT0TJRnFjDoZjY4Oi26K/sD0Y9YxZ2O8Yqpj
        ZlgurH2s52xHdhl7imPHKeVMxNrFlsZOxtnF7YmbineIL4+f5rpwK7kvEzwTahLmEv0SjyQuJIUltSbj
        kqOTT/FkeIm8nhSVlKyUgVSD1ILUkTSbtL1pM3xvfkM6lL4mvVNAFf1M9Ql1hVuFoxn2GVUZbzNDM09m
        SWfxsvqy9bN3ZE/kuOd8vQ61jrWuO1ctd3Pu6Hqn9bUboA0xG7o3amzM3zi+yWPT0c2EzYmbf8gzySvN
        e70lbEtXvnL+pvyxrR5bmwskCvgFw9tst9VsR23nbu/fYb5j/45PhezCa0UmReVFH4pZxde+Mv2q4quF
        nbE7+0ssSw7uwuzi7Rra7bD7aKl0aU7p2B7fPe1l9LLCstd7o/ZeLV9WXrOPsE+4b6TCp6Jzv+b+Xfs/
        VMZX3qlyrmqtVqreUT13gH1g8KDjwZYa5ZqimveHuIfu1nrUttdp15UfxhzOOPy0PrS+92vG140NCg1F
        DR+P8I6MHA082tNo1djYpNRU0gw3C5unjkUeu/mN6zedLYYtta201qLj4Ljw+LNvo78dOuF9ovsk42TL
        d1rfVbdR2grbofbs9pmO+I6RzvDOgVMrTnV32Xa1fW/0/ZHTaqerzsieKTlLOJt/duFczrnZ86nnpy/E
        XRjrjup+cHHVxds9AT39l7wvXbnsfvlir1PvuSt2V05ftbl66hrjWsd1y+vtfRZ9bT9Y/NDWb9nffsPq
        RudN65tdA8sHzg46DF645Xrr8m2v29fvrLwzMBQydHc4cnjkLvvu5L2key/vZ9yff7DpIfph4SOpR+WP
        lR7X/aj3Y+uI5ciZUdfRvidBTx6Mscae/5T+04fx/Kfkp+UTqhONk2aTp6fcp24+W/1s/Hnq8/npgp+l
        f65+ofviu18cf+mbWTUz/pL/cuHX4lfyr468Xva6e9Z/9vGb5Dfzc4Vv5d8efcd41/s+7P3EfOYH7IeK
        j3ofuz55f3q4kLyw8Bv3hPP74uYdwgAAAAlwSFlzAAAOvAAADrwBlbxySQAAAg5JREFUSEu9lgF1hDAQ
        RLFQT1jAAhbOAhawgAUsYAELWEhnNhnYhMDdvfZu+6aEZHd+NuS9tpmXNXwrhmkJTRqHrh8+KoUBOdGO
        YVc3XatPesx1aZ3KahN0B/ZMLiSTCafujTxgKOTXJHqdgCNMKZpnBQuMKMxTylPu3DdhaBsbUyNzUefh
        1m2tQ3+k6kRGywZzArwACws0Rug+j1zms46bpc8J2GFSu9KRcre4WPGJYgNThAuWgIKuWEOKPZkn8Bno
        uiIAeWaaCYU0KtcIkrhGMc/XVTvk96I8sOxAhneR1UJVIM9dZ2/CvC8qYfvuC/mw97ThE9DOHaIhnzx3
        FXjYYVzXsR7zWVsFcpFdmSlhGLBTwRgZaL2XgRCs5fiyQ7tVEIF8Z7BIsLlLptNPLn4rrqVPUEJPQAYX
        CCGwDAPKBE+ae+nod6DeEZdAhjr132I/ygKo0FwJ9Df7EsgwAApOwAHfum3jGoA2xpyAei+BjEugYFUg
        TE0XQL/ugbcdWjES/e4yoDZTAwokvXqkgv4XkFEF+svJxLeAHiQ9A96FQStAqgp0sA33/s9AiobPutvs
        5w1gPE4e9laFngTQ0V2Ese4FYALAxEOzrpK5177uYJyvAqMlhT+O/J2AlEyijktVKoaDpY2dgGt4mNAD
        NGI8ZgXafTSLhoIfG6HWsG1HZ1IGZHDik1J8+V/9JfwC/HhjgjbIIRsAAAAASUVORK5CYII=
</value>
  </data>
  <data name="MountButton.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAYAAAByDd+UAAAABGdBTUEAALGOfPtRkwAAACBjSFJNAACH
        DwAAjA8AAP1SAACBQAAAfXkAAOmLAAA85QAAGcxzPIV3AAAKOWlDQ1BQaG90b3Nob3AgSUNDIHByb2Zp
        bGUAAEjHnZZ3VFTXFofPvXd6oc0w0hl6ky4wgPQuIB0EURhmBhjKAMMMTWyIqEBEEREBRZCggAGjoUis
        iGIhKKhgD0gQUGIwiqioZEbWSnx5ee/l5ffHvd/aZ+9z99l7n7UuACRPHy4vBZYCIJkn4Ad6ONNXhUfQ
        sf0ABniAAaYAMFnpqb5B7sFAJC83F3q6yAn8i94MAUj8vmXo6U+ng/9P0qxUvgAAyF/E5mxOOkvE+SJO
        yhSkiu0zIqbGJIoZRomZL0pQxHJijlvkpZ99FtlRzOxkHlvE4pxT2clsMfeIeHuGkCNixEfEBRlcTqaI
        b4tYM0mYzBXxW3FsMoeZDgCKJLYLOKx4EZuImMQPDnQR8XIAcKS4LzjmCxZwsgTiQ7mkpGbzuXHxArou
        S49uam3NoHtyMpM4AoGhP5OVyOSz6S4pyalMXjYAi2f+LBlxbemiIluaWltaGpoZmX5RqP+6+Dcl7u0i
        vQr43DOI1veH7a/8UuoAYMyKarPrD1vMfgA6tgIgd/8Pm+YhACRFfWu/8cV5aOJ5iRcIUm2MjTMzM424
        HJaRuKC/6386/A198T0j8Xa/l4fuyollCpMEdHHdWClJKUI+PT2VyeLQDf88xP848K/zWBrIieXwOTxR
        RKhoyri8OFG7eWyugJvCo3N5/6mJ/zDsT1qca5Eo9Z8ANcoISN2gAuTnPoCiEAESeVDc9d/75oMPBeKb
        F6Y6sTj3nwX9+65wifiRzo37HOcSGExnCfkZi2viawnQgAAkARXIAxWgAXSBITADVsAWOAI3sAL4gWAQ
        DtYCFogHyYAPMkEu2AwKQBHYBfaCSlAD6kEjaAEnQAc4DS6Ay+A6uAnugAdgBIyD52AGvAHzEARhITJE
        geQhVUgLMoDMIAZkD7lBPlAgFA5FQ3EQDxJCudAWqAgqhSqhWqgR+hY6BV2ArkID0D1oFJqCfoXewwhM
        gqmwMqwNG8MM2An2hoPhNXAcnAbnwPnwTrgCroOPwe3wBfg6fAcegZ/DswhAiAgNUUMMEQbigvghEUgs
        wkc2IIVIOVKHtCBdSC9yCxlBppF3KAyKgqKjDFG2KE9UCIqFSkNtQBWjKlFHUe2oHtQt1ChqBvUJTUYr
        oQ3QNmgv9Cp0HDoTXYAuRzeg29CX0HfQ4+g3GAyGhtHBWGE8MeGYBMw6TDHmAKYVcx4zgBnDzGKxWHms
        AdYO64dlYgXYAux+7DHsOewgdhz7FkfEqeLMcO64CBwPl4crxzXhzuIGcRO4ebwUXgtvg/fDs/HZ+BJ8
        Pb4LfwM/jp8nSBN0CHaEYEICYTOhgtBCuER4SHhFJBLVidbEACKXuIlYQTxOvEIcJb4jyZD0SS6kSJKQ
        tJN0hHSedI/0ikwma5MdyRFkAXknuZF8kfyY/FaCImEk4SXBltgoUSXRLjEo8UISL6kl6SS5VjJHslzy
        pOQNyWkpvJS2lIsUU2qDVJXUKalhqVlpirSptJ90snSxdJP0VelJGayMtoybDFsmX+awzEWZMQpC0aC4
        UFiULZR6yiXKOBVD1aF6UROoRdRvqP3UGVkZ2WWyobJZslWyZ2RHaAhNm+ZFS6KV0E7QhmjvlygvcVrC
        WbJjScuSwSVzcopyjnIcuUK5Vrk7cu/l6fJu8onyu+U75B8poBT0FQIUMhUOKlxSmFakKtoqshQLFU8o
        3leClfSVApXWKR1W6lOaVVZR9lBOVd6vfFF5WoWm4qiSoFKmclZlSpWiaq/KVS1TPaf6jC5Ld6In0Svo
        PfQZNSU1TzWhWq1av9q8uo56iHqeeqv6Iw2CBkMjVqNMo1tjRlNV01czV7NZ874WXouhFa+1T6tXa05b
        RztMe5t2h/akjpyOl06OTrPOQ12yroNumm6d7m09jB5DL1HvgN5NfVjfQj9ev0r/hgFsYGnANThgMLAU
        vdR6KW9p3dJhQ5Khk2GGYbPhqBHNyMcoz6jD6IWxpnGE8W7jXuNPJhYmSSb1Jg9MZUxXmOaZdpn+aqZv
        xjKrMrttTjZ3N99o3mn+cpnBMs6yg8vuWlAsfC22WXRbfLS0suRbtlhOWWlaRVtVWw0zqAx/RjHjijXa
        2tl6o/Vp63c2ljYCmxM2v9ga2ibaNtlOLtdZzllev3zMTt2OaVdrN2JPt4+2P2Q/4qDmwHSoc3jiqOHI
        dmxwnHDSc0pwOub0wtnEme/c5jznYuOy3uW8K+Lq4Vro2u8m4xbiVun22F3dPc692X3Gw8Jjncd5T7Sn
        t+duz2EvZS+WV6PXzAqrFetX9HiTvIO8K72f+Oj78H26fGHfFb57fB+u1FrJW9nhB/y8/Pb4PfLX8U/z
        /z4AE+AfUBXwNNA0MDewN4gSFBXUFPQm2Dm4JPhBiG6IMKQ7VDI0MrQxdC7MNaw0bGSV8ar1q66HK4Rz
        wzsjsBGhEQ0Rs6vdVu9dPR5pEVkQObRGZ03WmqtrFdYmrT0TJRnFjDoZjY4Oi26K/sD0Y9YxZ2O8Yqpj
        ZlgurH2s52xHdhl7imPHKeVMxNrFlsZOxtnF7YmbineIL4+f5rpwK7kvEzwTahLmEv0SjyQuJIUltSbj
        kqOTT/FkeIm8nhSVlKyUgVSD1ILUkTSbtL1pM3xvfkM6lL4mvVNAFf1M9Ql1hVuFoxn2GVUZbzNDM09m
        SWfxsvqy9bN3ZE/kuOd8vQ61jrWuO1ctd3Pu6Hqn9bUboA0xG7o3amzM3zi+yWPT0c2EzYmbf8gzySvN
        e70lbEtXvnL+pvyxrR5bmwskCvgFw9tst9VsR23nbu/fYb5j/45PhezCa0UmReVFH4pZxde+Mv2q4quF
        nbE7+0ssSw7uwuzi7Rra7bD7aKl0aU7p2B7fPe1l9LLCstd7o/ZeLV9WXrOPsE+4b6TCp6Jzv+b+Xfs/
        VMZX3qlyrmqtVqreUT13gH1g8KDjwZYa5ZqimveHuIfu1nrUttdp15UfxhzOOPy0PrS+92vG140NCg1F
        DR+P8I6MHA082tNo1djYpNRU0gw3C5unjkUeu/mN6zedLYYtta201qLj4Ljw+LNvo78dOuF9ovsk42TL
        d1rfVbdR2grbofbs9pmO+I6RzvDOgVMrTnV32Xa1fW/0/ZHTaqerzsieKTlLOJt/duFczrnZ86nnpy/E
        XRjrjup+cHHVxds9AT39l7wvXbnsfvlir1PvuSt2V05ftbl66hrjWsd1y+vtfRZ9bT9Y/NDWb9nffsPq
        RudN65tdA8sHzg46DF645Xrr8m2v29fvrLwzMBQydHc4cnjkLvvu5L2key/vZ9yff7DpIfph4SOpR+WP
        lR7X/aj3Y+uI5ciZUdfRvidBTx6Mscae/5T+04fx/Kfkp+UTqhONk2aTp6fcp24+W/1s/Hnq8/npgp+l
        f65+ofviu18cf+mbWTUz/pL/cuHX4lfyr468Xva6e9Z/9vGb5Dfzc4Vv5d8efcd41/s+7P3EfOYH7IeK
        j3ofuz55f3q4kLyw8Bv3hPP74uYdwgAAAAlwSFlzAAAOvAAADrwBlbxySQAAAnZJREFUSEu1lgGVqzAQ
        ALGABSxgAQuxEAu1EAtYwAIWsIAFLOTvbFhYKNC7f3f73pSS0h02CSFVnkOGKVR/inlUSEMdC920Y22/
        0W7SapO9CmnesbZfaV+lXxZ+ivP1b3m8kLIPP7o/WYS2Vrqmzi3UVW6EuipY3OXB8VFIhK4RUZNfocvT
        kBRrG1PMQwp6A178X0KCxIhSDMoyDQptsWvzPCYFOZiYeBSex5BANo99XubxUgj87oWzVE/FvtKtiPOk
        8eFlKnytQjuX7wiXCWGv1ZrwLLU4CAkdlxUEg4zP2MeD1Au3GxBpDHRvqTbJ90gemWA2riY/CDu5gD9J
        FsWSg7WBb99YKzUpVVr3+2o3IQNKIAWqGfvXfgN5KdxJNXkRMnNT7A4Vau6rWao/yIXIwBLKx70M1mqs
        SoRgsttZSiC8TPqECbeuLd1qwttZauN4mfSJVbhXWYS+ylvhZcInJvim0E8an6xpmsP5JSdhXdNLIhS8
        8G3SaKMTIiMOya84CYlqlfpH4iDUBjd+HBF+rFBlcKwQIQsHQhYCk74JfTKT+jaQj5XpTcYsRWhvkW8J
        7xhf8owKQ4y5D/uCvj34shyaENmj0Lr0DiR5YcURZqlSQFrWXRYLJ+Ph/yT0q8uZTbaKFOnSPI45tm3u
        9Y1SVhgvexTqa0g4VzrJeeo6lQRm7zypqJXxWsYhd3I8yoqQnLYNITahHz+q5HXDEXEZF2mTKhB2CEWW
        RWRCjufKdIgGySFYlY9C2g7I9sG6EBAtQ4FkZ6jsUsjmlISjJOn7XuH8KsqOrSS72rH5oD0l2X7IpAK9
        znbeCExkR+7mJyAw0S4M+R8/YPuaD9uONgAAAABJRU5ErkJggg==
</value>
  </data>
  <data name="NpcButton.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAABkAAAAfCAYAAAASsGZ+AAAABGdBTUEAALGOfPtRkwAAACBjSFJNAACH
        DwAAjA8AAP1SAACBQAAAfXkAAOmLAAA85QAAGcxzPIV3AAAKOWlDQ1BQaG90b3Nob3AgSUNDIHByb2Zp
        bGUAAEjHnZZ3VFTXFofPvXd6oc0w0hl6ky4wgPQuIB0EURhmBhjKAMMMTWyIqEBEEREBRZCggAGjoUis
        iGIhKKhgD0gQUGIwiqioZEbWSnx5ee/l5ffHvd/aZ+9z99l7n7UuACRPHy4vBZYCIJkn4Ad6ONNXhUfQ
        sf0ABniAAaYAMFnpqb5B7sFAJC83F3q6yAn8i94MAUj8vmXo6U+ng/9P0qxUvgAAyF/E5mxOOkvE+SJO
        yhSkiu0zIqbGJIoZRomZL0pQxHJijlvkpZ99FtlRzOxkHlvE4pxT2clsMfeIeHuGkCNixEfEBRlcTqaI
        b4tYM0mYzBXxW3FsMoeZDgCKJLYLOKx4EZuImMQPDnQR8XIAcKS4LzjmCxZwsgTiQ7mkpGbzuXHxArou
        S49uam3NoHtyMpM4AoGhP5OVyOSz6S4pyalMXjYAi2f+LBlxbemiIluaWltaGpoZmX5RqP+6+Dcl7u0i
        vQr43DOI1veH7a/8UuoAYMyKarPrD1vMfgA6tgIgd/8Pm+YhACRFfWu/8cV5aOJ5iRcIUm2MjTMzM424
        HJaRuKC/6386/A198T0j8Xa/l4fuyollCpMEdHHdWClJKUI+PT2VyeLQDf88xP848K/zWBrIieXwOTxR
        RKhoyri8OFG7eWyugJvCo3N5/6mJ/zDsT1qca5Eo9Z8ANcoISN2gAuTnPoCiEAESeVDc9d/75oMPBeKb
        F6Y6sTj3nwX9+65wifiRzo37HOcSGExnCfkZi2viawnQgAAkARXIAxWgAXSBITADVsAWOAI3sAL4gWAQ
        DtYCFogHyYAPMkEu2AwKQBHYBfaCSlAD6kEjaAEnQAc4DS6Ay+A6uAnugAdgBIyD52AGvAHzEARhITJE
        geQhVUgLMoDMIAZkD7lBPlAgFA5FQ3EQDxJCudAWqAgqhSqhWqgR+hY6BV2ArkID0D1oFJqCfoXewwhM
        gqmwMqwNG8MM2An2hoPhNXAcnAbnwPnwTrgCroOPwe3wBfg6fAcegZ/DswhAiAgNUUMMEQbigvghEUgs
        wkc2IIVIOVKHtCBdSC9yCxlBppF3KAyKgqKjDFG2KE9UCIqFSkNtQBWjKlFHUe2oHtQt1ChqBvUJTUYr
        oQ3QNmgv9Cp0HDoTXYAuRzeg29CX0HfQ4+g3GAyGhtHBWGE8MeGYBMw6TDHmAKYVcx4zgBnDzGKxWHms
        AdYO64dlYgXYAux+7DHsOewgdhz7FkfEqeLMcO64CBwPl4crxzXhzuIGcRO4ebwUXgtvg/fDs/HZ+BJ8
        Pb4LfwM/jp8nSBN0CHaEYEICYTOhgtBCuER4SHhFJBLVidbEACKXuIlYQTxOvEIcJb4jyZD0SS6kSJKQ
        tJN0hHSedI/0ikwma5MdyRFkAXknuZF8kfyY/FaCImEk4SXBltgoUSXRLjEo8UISL6kl6SS5VjJHslzy
        pOQNyWkpvJS2lIsUU2qDVJXUKalhqVlpirSptJ90snSxdJP0VelJGayMtoybDFsmX+awzEWZMQpC0aC4
        UFiULZR6yiXKOBVD1aF6UROoRdRvqP3UGVkZ2WWyobJZslWyZ2RHaAhNm+ZFS6KV0E7QhmjvlygvcVrC
        WbJjScuSwSVzcopyjnIcuUK5Vrk7cu/l6fJu8onyu+U75B8poBT0FQIUMhUOKlxSmFakKtoqshQLFU8o
        3leClfSVApXWKR1W6lOaVVZR9lBOVd6vfFF5WoWm4qiSoFKmclZlSpWiaq/KVS1TPaf6jC5Ld6In0Svo
        PfQZNSU1TzWhWq1av9q8uo56iHqeeqv6Iw2CBkMjVqNMo1tjRlNV01czV7NZ874WXouhFa+1T6tXa05b
        RztMe5t2h/akjpyOl06OTrPOQ12yroNumm6d7m09jB5DL1HvgN5NfVjfQj9ev0r/hgFsYGnANThgMLAU
        vdR6KW9p3dJhQ5Khk2GGYbPhqBHNyMcoz6jD6IWxpnGE8W7jXuNPJhYmSSb1Jg9MZUxXmOaZdpn+aqZv
        xjKrMrttTjZ3N99o3mn+cpnBMs6yg8vuWlAsfC22WXRbfLS0suRbtlhOWWlaRVtVWw0zqAx/RjHjijXa
        2tl6o/Vp63c2ljYCmxM2v9ga2ibaNtlOLtdZzllev3zMTt2OaVdrN2JPt4+2P2Q/4qDmwHSoc3jiqOHI
        dmxwnHDSc0pwOub0wtnEme/c5jznYuOy3uW8K+Lq4Vro2u8m4xbiVun22F3dPc692X3Gw8Jjncd5T7Sn
        t+duz2EvZS+WV6PXzAqrFetX9HiTvIO8K72f+Oj78H26fGHfFb57fB+u1FrJW9nhB/y8/Pb4PfLX8U/z
        /z4AE+AfUBXwNNA0MDewN4gSFBXUFPQm2Dm4JPhBiG6IMKQ7VDI0MrQxdC7MNaw0bGSV8ar1q66HK4Rz
        wzsjsBGhEQ0Rs6vdVu9dPR5pEVkQObRGZ03WmqtrFdYmrT0TJRnFjDoZjY4Oi26K/sD0Y9YxZ2O8Yqpj
        ZlgurH2s52xHdhl7imPHKeVMxNrFlsZOxtnF7YmbineIL4+f5rpwK7kvEzwTahLmEv0SjyQuJIUltSbj
        kqOTT/FkeIm8nhSVlKyUgVSD1ILUkTSbtL1pM3xvfkM6lL4mvVNAFf1M9Ql1hVuFoxn2GVUZbzNDM09m
        SWfxsvqy9bN3ZE/kuOd8vQ61jrWuO1ctd3Pu6Hqn9bUboA0xG7o3amzM3zi+yWPT0c2EzYmbf8gzySvN
        e70lbEtXvnL+pvyxrR5bmwskCvgFw9tst9VsR23nbu/fYb5j/45PhezCa0UmReVFH4pZxde+Mv2q4quF
        nbE7+0ssSw7uwuzi7Rra7bD7aKl0aU7p2B7fPe1l9LLCstd7o/ZeLV9WXrOPsE+4b6TCp6Jzv+b+Xfs/
        VMZX3qlyrmqtVqreUT13gH1g8KDjwZYa5ZqimveHuIfu1nrUttdp15UfxhzOOPy0PrS+92vG140NCg1F
        DR+P8I6MHA082tNo1djYpNRU0gw3C5unjkUeu/mN6zedLYYtta201qLj4Ljw+LNvo78dOuF9ovsk42TL
        d1rfVbdR2grbofbs9pmO+I6RzvDOgVMrTnV32Xa1fW/0/ZHTaqerzsieKTlLOJt/duFczrnZ86nnpy/E
        XRjrjup+cHHVxds9AT39l7wvXbnsfvlir1PvuSt2V05ftbl66hrjWsd1y+vtfRZ9bT9Y/NDWb9nffsPq
        RudN65tdA8sHzg46DF645Xrr8m2v29fvrLwzMBQydHc4cnjkLvvu5L2key/vZ9yff7DpIfph4SOpR+WP
        lR7X/aj3Y+uI5ciZUdfRvidBTx6Mscae/5T+04fx/Kfkp+UTqhONk2aTp6fcp24+W/1s/Hnq8/npgp+l
        f65+ofviu18cf+mbWTUz/pL/cuHX4lfyr468Xva6e9Z/9vGb5Dfzc4Vv5d8efcd41/s+7P3EfOYH7IeK
        j3ofuz55f3q4kLyw8Bv3hPP74uYdwgAAAAlwSFlzAAAOvAAADrwBlbxySQAAAmJJREFUSEutlQ21ozAQ
        hWsBC1jAAhawUAtYwAIWsIAFLGABC9l8M7npQPt22+2bc+6Zyfzcm0Bob29aKsBi/GuWjmUQcUrHltI+
        1XXG12aEU9e4QI7Xu8cI71MXxcB/Wd31vXkISpQcIKb5U7NBSLVjiDkFuYgXJ3rLKgGkkCuOuSiI0EXs
        r1aHINLjkFDMxfwnQnZzaGSXNMfBVzmE4olUx8PntGezxjgk0bouiEKcRj2stRk8nE7tVofxhijAt1G+
        DwkIIlUtCsHr9G7WQGPE6VRlLWIRxrVynE5icJuACPA0ymuYtXpYi0SPKoqoTg6cRCiISF7NrONw9DpN
        hDZATxWhwE3BU8TToGsa1/i0+KauQsTqV72K0CSC2LSPZ3GRbyPPu6+bkGee3lcimCViMzGkQPm0L57P
        Ph17rQEJ6FSagdslcqACg6zBvRCLzIjX2fLqUU3kEiMHSt/jq8XbYLZublLTF+Kya/zct4966yTsGGKg
        OAi4CEmJbPuR2vFmBO2QxSUibMupTr+ImYdcm4Vc3pJS5/FM62AE+CeRjGtdIng48CKXVXUTKY/ln+Bd
        lfcFqQTgK3gyK2gX9faATLL3+dYUXAV0zcUBWfAni0UX4kSF7BjHlObZRQL5mPtAmcNekl/tJDbkHf4E
        9RTIYvyjXZvSvq1GJN+2+ddhnNMwjDnuLUdj8G9ZHRqnJTWNfxesJUC+6+4ldxL62B4iFwE/hf8pfS2C
        accyBJTDfy+SsTpBjfVuEPgdEb6J/IM4c6VLTH7leqejirAmb1MfmpGDa8yJcmBCnEynZejZbrc/Mq/o
        DNU8V1gAAAAASUVORK5CYII=
</value>
  </data>
  <data name="ScaleButton.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8
        YQUAAAAZdEVYdFNvZnR3YXJlAEFkb2JlIEltYWdlUmVhZHlxyWU8AAAF8klEQVRYR72XW1BVZRTHz+RD
        L/Xm2FO9qI3WKJUmoWI1zvTY5blppmacqYderJS7EoKRoSFa3ARRkYumIk2ljnJJAxIQ85ImcLiIqBzu
        YMglVuu3Dnt7wDPqE2vmP+djfet/2fuc852NR2tOfkHhjsKin8RF8ZGHof2DhcVPhEdpOMATbwI8Q2O2
        C0+8CTD3QH6RNb/YFy6vxnnktU0ee3XWyzd7ZGmMR9pbfXKj0SvXG5uCgj1mmIUzU4dXPCg88SbAPCcA
        Azdav5brLYku+Lv6erwJ3LrZJ83eNmls9gYFe8wwCyeYFh7UVIB5FmBv3kFrQmzwrpfMkx4XJy6ul9f1
        agZ9Ih0370pLa9sjwQyzcOAGaqGNB4Vn0AA1zZ9IZoUSplBSv84foFuk81aPtLZ3SEtbe1CwxwyzcOAG
        aqEdNEBOzn5rLtfN35vfl+w/PC5yqjxSVPuuEbmyO53d0tFxKyjYY4ZZOHADtdDGg8LTDZC9J8+apD7T
        skbSznkk94JH9tQpsdb/urc6zD5Y93pHpM/Xpbg9A122xwyzgVy00EQbDwpPN0BGZq41Q+M9kl61QML0
        NVQHc6/qHbjkx+G/F9r+WzEVsiaqVHF0Bkrl7egy4zLr8NBAiz7aaFB4ugF+SM+2pvN1GRsUwzL9O6/R
        D/p9OuOb8GNAMRwEYzqzUnn7p3hoOHpoON8CPN0AabszrDnQM2ro7hqUXt+wkUjMba26dEak4Q2R+hAp
        r82V6DqReAf1D7DlgkjyJZFVyuHK0UALTUefwtMNkJq225pdvm650+WTu11dtr43OCxvRlfYntQsU6z2
        o2qxJP4lkqLYflmvpmyD/Hhqna3pAYq3BA200ESbNYXnQwEYcuDr9snIUL+sjCiVcTbPLBKp1DsAyl+U
        7dfUWJFeWyUZx+crFkp6ZbL1Uq+YnIRHlpgGWoHa1LQAKTt2WpN0Drp7eoy8KuKYva+1NVkivy0wXDyf
        JRn/iOQ264epMlV2HVsiu0pC7C5YT/eoVRFHTAOtQG0KTzfAtpRUazLooKe3V+4PD5jIpO5lNolkefXr
        o8Akv0XXtSckpWi+bD8UYmCddf6k7NMZCi4aaAVqU3i6AZK3bbdmb1+fDQPW4/eHTIQqUNFDagoOt4oc
        vakfuj3PStKBBbK1YKkixNb0ituNYlw0ZupSeLoBkpK/s2Z//4ANgP6B/mkBMCxV/Nzhxy+3RfLqfpXo
        7Ockdv9CA2t6JZ1GcQOg5eqqB4WnG2BL0rfWHBgYtAEwNDQkk6MjKlJie6fuipzWY7YsABV6MWfv67H6
        0fMG1vSYo+CigZajiweFpxsgIXGrNYeH/zVA4FX0YFkTpd9/rZ3lKyStPGwadlWult01a2XHOy8YWNNj
        ljIuB1SApulq4ekGiE/4xpoMT+pHfnTkPxnTq6E4hDiMthwOlc3Fr0hswUsSU7DYRWzxyxJ7ZIkfumaG
        WecAo9BCE208KDwfCsCTDHBqSbQ+oHQckqbOo+6PyJMUs3DgouFUoP60AJs2J1oT4kXv93Zmc4bXNadL
        1mmPofJajO2HR5bZ4RS28dg00GOPGWYdHhpooYm2cyF4ugFi4xKsyS273PaVlF2Nk7JrCZJ1VkWmcLzh
        Y/eHxF/cy0D4ixlmA7looYm287bg6QaIjIq3Jg8L1S0fSpY+SIDsav1J/dMjBbXvSYhzK9VrfGwsKJwc
        zMKBi4ajh7bzQIJn0ACnm9ZKZr0+QimyGyCGy4opEkfi+NiEjI6OBQV7dmxqwYGLhqOHdtAAGyPirAmp
        1LtIsq+ouSJHHyZSz+qDyNRto8Yn9BsyPh4U7DkFBy4ajh7azsXg6QbYEBFrTT4she1PS65Xn2SmsK/N
        I0nnnnLfgkn1mJiYCAr2KGbhwA3UQhsPCs8HATbGWHNr6Qc2QMpQB3olIPDr+bhi1uE5OmiijQeFpxsg
        Isr/Fsxm4ekEmPvpZ5/n0yAVtyYodO/LDZFPhMfp4IUn3gTgH8RFinDF2lkCXnjaP6f8i8yCNNyS2QBe
        6umZ8z8vzOQ7BO9L8gAAAABJRU5ErkJggg==
</value>
  </data>
  <data name="SkillButton.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAO
        vAAADrwBlbxySQAAAcNJREFUWEfNUoFtwzAMyy27ti/khb3QF/xCX+gLmamKHi0rDrJ1wQgQlmVbpJQs
        AdtFTLGV8riE0HpJfsMOrsL6ee9MvMSfz2OWco5ZDaeaqHev654YDSQudyldPu/3U7R3tcZ7JyDmBkE5
        U5ybgHSsjGIztlqO8xMQQ6nAx9Ix5i2WGvMJHHSpQirAs+7O6mS+1sd6PAExNBTeElKQhGjp93hvNer9
        uQER7kTrOjXBbr1jrq0O9vUe4n0DoWs+6sTBKMy8k3dtDZ8TcW4gimcCKixn5XbbHus6CFrsdZW7P+Eg
        vkcIJ51HE81AQGrgWzwCuYQ0oazvUefIxGBgX5zAmTMTxh/P2KfBfTPjUwZPGEBOSBESOQoGYcSduExj
        /gmssAL7HbpQua32/UEaoXgzgfszA52JKKR0gdapm+APSJoZa2b8DKMBIJrwx02UMfdkMJFNQYlcbgAQ
        E/bYCzdToJhoeTER991b3+8bANxEZ0RjKcR8ExRhI2Nf+eZwAjM2Ix5HUZ7bWSIOzicwgxdQqqCKxLOW
        rxgNyKOB8vP8lqz18wm8CccTeGPXkf9uAsClJqI4YQdXEFovyRE8/Gs6luUL+4EgZ2q4A8kAAAAASUVO
        RK5CYII=
</value>
  </data>
  <data name="ChairButton.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAACEAAAAaCAYAAAA5WTUBAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAO
        vAAADrwBlbxySQAAAdNJREFUSEulVQuVhDAMxMJZwAIWsLAWsICFWsDCWsACFrCwFnKZlPRStvR38948
        ILTT2SHtDh0gw178S4PObaZ9GWmbu0WChuvQkIXVQKeJSGMe2zToJBe4HpFANXX+wVz2gaZXeFcFmbwR
        /xLm6+2poi3EfPfhH+E8oe2XyIMnEQ3HxfcpBpCGmqphpLHtTQaAWMDtnvpcwfmkP439Q8PKthbXn4IY
        wFVrFbynMKz1BoDwHUF8htYUls/x1QtNKVgD6IGeXggGmNgRzb3w2njSRd0RMFFLd4xe49oJSmj7JfKQ
        ydPyx3n9FiuS5wQNPhNwhbZfogyZYI9oI1BNq4Ejemw8nAARgIFlap98QTTMf0S7gd4z/kKUAp59+Rk6
        SDgiugTv43LEeJvC+PM9hhkQbcVWprofTYgEjnUKJvBJkSj6Qom6OGCIkG7BVkrnW2IBXth+BiwOEytT
        Uk2YAELklqg/vQP1/X0cDNxNwACecTVzkpBGBHHvS4Knegr3Zgx8x/Ukoh2BZ18WhHrBSG5HBBM5IyKQ
        WeTJoEW0I3wpQjaNXAqKUhq5FBTZNEopKHJGSykokmnUpKB4SkM0ahqPkUxDb0KhADvWocCwNbAEM3ag
        XwWG6JeIXMNYAAAAAElFTkSuQmCC
</value>
  </data>
  <data name="MobButton.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAYAAAByDd+UAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAO
        vAAADrwBlbxySQAAAtVJREFUSEvNlqGO20AQhvMUQUFhwUah4YHBYfsKeYPgokhmB6pKBSV5gqCCyviC
        gg6cFFXqBRds55udsddrJz21oB3pj+P17nw7M7trT/5ru91u8XK5xNVqFZfLpWqz2WgbZt3eZ03TxP1+
        35M9UgPm7T+ev8amqWNToxBDqAb9HxozbB2ZkzqEOJ1OxXGjjq7Xq7Z1oA5YC5BnRKwOH9nLy4vMMHeU
        YMlJpek7n89xsViMw1pg1UaKT3M/aurUVVVpoDtBRJrawqBv2X8i9+jp6eNdaCRdFP94PNKplUcKENF2
        Op30utvtdBwiqrYPwFDLtY7z+XwYLekkZVZ0HQQYI4rZbKbt1PJwOLSOa0lpbiyqqgodUCX1lzYmpTC3
        9XqtA3DoMOzTtzdNDVBSRx/uUWnN9xgrmTyRdUCTjCUow6UtgdO6iT0RvdZCZx40C6UxCSZGNloYVxvj
        bZbBvgHYbreae1YlddWONphJBUllkNl0qq12JSzVvoXKle1nqL75VgHm0rpJm9aUOrXyKKReCkyTS/dN
        gk5SXUejxKgjaVb7+SY/je5Blr88ziCu5DwBZav4vUYmYgz3gEsjum4FAjUJsIvQQchhCABR2zOfmAN5
        VhqLRKOzyEqoHl8PgVn0nl5N6R0gW2QUJvJDWwdmQPEfJ7KAktMciOTeJ1QCKbDaA+AwSnEkMIWqUyDi
        OH/+EHgHhhz45fOHNDhzCDDJoSbvI/97q5SVyTkJ0B3rtQRLO2llj6Z0dVBNq6e2lcOr/j6EzqmBUza/
        NOnp0YMZ0KWpLdPWk8PsxMoNoDt9fX3Wt0He5vLoXSlSoIUUhO68qsac31MO7aW3hfA/yV5nQ/tToIv0
        dmdn9w5FHBaYoZL5+w6H79EYlE8O6s5nB/9zEZChOtNtMeJ8oBLkGgEFidbfpYbpG9DRSHPHpUZARImv
        331QqZFeUvA34gVg7v6lTSa/ABOYBDZgMu2dAAAAAElFTkSuQmCC
</value>
  </data>
  <data name="SaveMapButton.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8
        YQUAAAK1SURBVFhHvZdZa1NBGIYjGNwirrj1Si8qIkasCEXEIiJFrKUqiCCCCCIIhSIIgogiiBoU/Afe
        +Xe8CtkXmn3f94Qx75gZ5sx8KrWnGXggHyfzvQ9zzslkHItrS47xcI2ZHTO3xSDDhUwBhssxs/DdcXKZ
        /Yn/HVSvcd6CKoExiwsz975KULvdbgnGaDRig8GA9Xo91ul0WKvVYo1Gg1WrVeZ0Oi0kEgk+R+8reqsS
        GHP8i3e/SCiB4XDI+v0+63a7rN1u8/BarcYqlQoPFd/F5/X1dT5H76v2FxJS4MQdj4QSUMObzSar1+s8
        vFQqGQLxeJzP0fuqTCTwTPwWOL7yWUIJqEuPcCw9wguFgiEQjUb5HL2vykQAD+ZEYPmjhBLQl75cLrNi
        schyuZwhEA6H+Ry9r4ohcOz2BwklIJZe3HeE5/N5lslkDIFQKMTn6H1VDIGjt95LKAFx38XSIzybzbJU
        KmUIBINBPkfvq2IIHLn5TkIJiFcOS4/7jqVPp9P8lUOoit/v53P0viqGwOHFNxJKQF16hGPpk8kkf+Vi
        sRiLRCJ86QOBAPP5fHyO3lfFEDh047WEX7QJta8Kv64KHLz+aqoYAgeuvZwqhsD+qy+miiGw78qahF/c
        AowMVWDv5VUJ6rfffvAn2Y6BXlSGRcA1/1yCGtuvnVAZFoE9l55JUGP3sxMqwyKw++JTCWrsfMDj8WwK
        0YfKsAjsuvBEgho/vXZCZVgEdp5/LEGNn107oTIsAjvOPZKgxoYDqGXdCKIPlWERcJ59KEGNzcZOqAyL
        wPYzDySosc3aCZVhFTh9X4IaWyyglnUjiD5UhkVA/UOBGnu7nVAZfxXAvxo7+aeAfnrxer22QmUIAX40
        23ZqRYJ6/tNPW6EyePZ4kIdTqslm0PvzTGRPDojTOp4LJsf0JccvFwi721csolAAAAAASUVORK5CYII=
</value>
  </data>
  <data name="ViewButton.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAABGdBTUEAALGOfPtRkwAAACBjSFJNAACH
        DwAAjA8AAP1SAACBQAAAfXkAAOmLAAA85QAAGcxzPIV3AAAKOWlDQ1BQaG90b3Nob3AgSUNDIHByb2Zp
        bGUAAEjHnZZ3VFTXFofPvXd6oc0w0hl6ky4wgPQuIB0EURhmBhjKAMMMTWyIqEBEEREBRZCggAGjoUis
        iGIhKKhgD0gQUGIwiqioZEbWSnx5ee/l5ffHvd/aZ+9z99l7n7UuACRPHy4vBZYCIJkn4Ad6ONNXhUfQ
        sf0ABniAAaYAMFnpqb5B7sFAJC83F3q6yAn8i94MAUj8vmXo6U+ng/9P0qxUvgAAyF/E5mxOOkvE+SJO
        yhSkiu0zIqbGJIoZRomZL0pQxHJijlvkpZ99FtlRzOxkHlvE4pxT2clsMfeIeHuGkCNixEfEBRlcTqaI
        b4tYM0mYzBXxW3FsMoeZDgCKJLYLOKx4EZuImMQPDnQR8XIAcKS4LzjmCxZwsgTiQ7mkpGbzuXHxArou
        S49uam3NoHtyMpM4AoGhP5OVyOSz6S4pyalMXjYAi2f+LBlxbemiIluaWltaGpoZmX5RqP+6+Dcl7u0i
        vQr43DOI1veH7a/8UuoAYMyKarPrD1vMfgA6tgIgd/8Pm+YhACRFfWu/8cV5aOJ5iRcIUm2MjTMzM424
        HJaRuKC/6386/A198T0j8Xa/l4fuyollCpMEdHHdWClJKUI+PT2VyeLQDf88xP848K/zWBrIieXwOTxR
        RKhoyri8OFG7eWyugJvCo3N5/6mJ/zDsT1qca5Eo9Z8ANcoISN2gAuTnPoCiEAESeVDc9d/75oMPBeKb
        F6Y6sTj3nwX9+65wifiRzo37HOcSGExnCfkZi2viawnQgAAkARXIAxWgAXSBITADVsAWOAI3sAL4gWAQ
        DtYCFogHyYAPMkEu2AwKQBHYBfaCSlAD6kEjaAEnQAc4DS6Ay+A6uAnugAdgBIyD52AGvAHzEARhITJE
        geQhVUgLMoDMIAZkD7lBPlAgFA5FQ3EQDxJCudAWqAgqhSqhWqgR+hY6BV2ArkID0D1oFJqCfoXewwhM
        gqmwMqwNG8MM2An2hoPhNXAcnAbnwPnwTrgCroOPwe3wBfg6fAcegZ/DswhAiAgNUUMMEQbigvghEUgs
        wkc2IIVIOVKHtCBdSC9yCxlBppF3KAyKgqKjDFG2KE9UCIqFSkNtQBWjKlFHUe2oHtQt1ChqBvUJTUYr
        oQ3QNmgv9Cp0HDoTXYAuRzeg29CX0HfQ4+g3GAyGhtHBWGE8MeGYBMw6TDHmAKYVcx4zgBnDzGKxWHms
        AdYO64dlYgXYAux+7DHsOewgdhz7FkfEqeLMcO64CBwPl4crxzXhzuIGcRO4ebwUXgtvg/fDs/HZ+BJ8
        Pb4LfwM/jp8nSBN0CHaEYEICYTOhgtBCuER4SHhFJBLVidbEACKXuIlYQTxOvEIcJb4jyZD0SS6kSJKQ
        tJN0hHSedI/0ikwma5MdyRFkAXknuZF8kfyY/FaCImEk4SXBltgoUSXRLjEo8UISL6kl6SS5VjJHslzy
        pOQNyWkpvJS2lIsUU2qDVJXUKalhqVlpirSptJ90snSxdJP0VelJGayMtoybDFsmX+awzEWZMQpC0aC4
        UFiULZR6yiXKOBVD1aF6UROoRdRvqP3UGVkZ2WWyobJZslWyZ2RHaAhNm+ZFS6KV0E7QhmjvlygvcVrC
        WbJjScuSwSVzcopyjnIcuUK5Vrk7cu/l6fJu8onyu+U75B8poBT0FQIUMhUOKlxSmFakKtoqshQLFU8o
        3leClfSVApXWKR1W6lOaVVZR9lBOVd6vfFF5WoWm4qiSoFKmclZlSpWiaq/KVS1TPaf6jC5Ld6In0Svo
        PfQZNSU1TzWhWq1av9q8uo56iHqeeqv6Iw2CBkMjVqNMo1tjRlNV01czV7NZ874WXouhFa+1T6tXa05b
        RztMe5t2h/akjpyOl06OTrPOQ12yroNumm6d7m09jB5DL1HvgN5NfVjfQj9ev0r/hgFsYGnANThgMLAU
        vdR6KW9p3dJhQ5Khk2GGYbPhqBHNyMcoz6jD6IWxpnGE8W7jXuNPJhYmSSb1Jg9MZUxXmOaZdpn+aqZv
        xjKrMrttTjZ3N99o3mn+cpnBMs6yg8vuWlAsfC22WXRbfLS0suRbtlhOWWlaRVtVWw0zqAx/RjHjijXa
        2tl6o/Vp63c2ljYCmxM2v9ga2ibaNtlOLtdZzllev3zMTt2OaVdrN2JPt4+2P2Q/4qDmwHSoc3jiqOHI
        dmxwnHDSc0pwOub0wtnEme/c5jznYuOy3uW8K+Lq4Vro2u8m4xbiVun22F3dPc692X3Gw8Jjncd5T7Sn
        t+duz2EvZS+WV6PXzAqrFetX9HiTvIO8K72f+Oj78H26fGHfFb57fB+u1FrJW9nhB/y8/Pb4PfLX8U/z
        /z4AE+AfUBXwNNA0MDewN4gSFBXUFPQm2Dm4JPhBiG6IMKQ7VDI0MrQxdC7MNaw0bGSV8ar1q66HK4Rz
        wzsjsBGhEQ0Rs6vdVu9dPR5pEVkQObRGZ03WmqtrFdYmrT0TJRnFjDoZjY4Oi26K/sD0Y9YxZ2O8Yqpj
        ZlgurH2s52xHdhl7imPHKeVMxNrFlsZOxtnF7YmbineIL4+f5rpwK7kvEzwTahLmEv0SjyQuJIUltSbj
        kqOTT/FkeIm8nhSVlKyUgVSD1ILUkTSbtL1pM3xvfkM6lL4mvVNAFf1M9Ql1hVuFoxn2GVUZbzNDM09m
        SWfxsvqy9bN3ZE/kuOd8vQ61jrWuO1ctd3Pu6Hqn9bUboA0xG7o3amzM3zi+yWPT0c2EzYmbf8gzySvN
        e70lbEtXvnL+pvyxrR5bmwskCvgFw9tst9VsR23nbu/fYb5j/45PhezCa0UmReVFH4pZxde+Mv2q4quF
        nbE7+0ssSw7uwuzi7Rra7bD7aKl0aU7p2B7fPe1l9LLCstd7o/ZeLV9WXrOPsE+4b6TCp6Jzv+b+Xfs/
        VMZX3qlyrmqtVqreUT13gH1g8KDjwZYa5ZqimveHuIfu1nrUttdp15UfxhzOOPy0PrS+92vG140NCg1F
        DR+P8I6MHA082tNo1djYpNRU0gw3C5unjkUeu/mN6zedLYYtta201qLj4Ljw+LNvo78dOuF9ovsk42TL
        d1rfVbdR2grbofbs9pmO+I6RzvDOgVMrTnV32Xa1fW/0/ZHTaqerzsieKTlLOJt/duFczrnZ86nnpy/E
        XRjrjup+cHHVxds9AT39l7wvXbnsfvlir1PvuSt2V05ftbl66hrjWsd1y+vtfRZ9bT9Y/NDWb9nffsPq
        RudN65tdA8sHzg46DF645Xrr8m2v29fvrLwzMBQydHc4cnjkLvvu5L2key/vZ9yff7DpIfph4SOpR+WP
        lR7X/aj3Y+uI5ciZUdfRvidBTx6Mscae/5T+04fx/Kfkp+UTqhONk2aTp6fcp24+W/1s/Hnq8/npgp+l
        f65+ofviu18cf+mbWTUz/pL/cuHX4lfyr468Xva6e9Z/9vGb5Dfzc4Vv5d8efcd41/s+7P3EfOYH7IeK
        j3ofuz55f3q4kLyw8Bv3hPP74uYdwgAAAAlwSFlzAAAOvAAADrwBlbxySQAABb1JREFUSEu1lXs01ncc
        x38hEaG1tsily0l4sugoFV3Io5LuMcUmkdbZRjlpFafbQoraKTyOS0WHIixS67Jz6myttjxWdLVa19W6
        kMfTYrV47/P9/h4P8eii0x/v8/t9L5/v6/t5f7+/z0+4U9sgWEmcMgRBqCUp37MUPQfY5Vy6r9QRbMdJ
        t1IHXGcEYk7EWniHrngvmr1kDcb7hoKx7BxcsugpPLd39cQJAEeeAweUr1dJHXD0P+A4xfzYpOqnvrbz
        WuvwM+AXmj/Cy5fBmxj4mZtfKIoVgEyuINV2qOQzNUj9XYn9j4EdF59hy/EbSJU/5u1Maif9Wq0xjqus
        FqVPAK+QSAZuYGDl6Gn+KHwIWrROc5BKDFpcA4TGp0Mw6s9tEwQTzPgqCvv+BnZerkcKbU5jbLmCb3DC
        vMUsjp33m4FTyiizWmBRQjYHDuguIDLECh7WDC7Aze8LFNO4TK5sF8vUaTCzMruqAYKWMQb2FIAyH6Am
        GLgdCJ+Rxhy+8YfLyL3J4O3jOw3OvQXEHbzEAYmBfYBHC9BQNBm4/hnOyVx5/8L43aqs28d3GryrqpEu
        SDUHTByiD9ybD1T5A4oQbAiw4v0rd/+EfDprTfGdBrMbzz6jcXPDOSTcqw9+zp2A7V/a8HbfQY4oIGha
        RYOG2He8XDuv1CP/ThNcZwZwWLP6Obog7ewD7LndyD85TfFvDGag5DOPkX8XyLkOJJ2uIVUj+2ojCh8A
        q/NOISg2CxHph/j43jvAdprTGtZabwRmUFmZAkXUF733JDYdu8rHGTz5N1ZEniDvL+B7+qYL7gPplQ28
        vy2stV4LZtAUgrLy+U3WYW6ljrYhVaWbvPS9KqtX6ZVgGQ2mnBGhK3cf4VA9Y23+1O1mQmO3eU1mmWta
        nG2aAXZdaUTauSc0n5xTjXUILqBzk5UrefFfW3iSwwRtAWtOhyMk81NxE917I6PyEf9W28L58cjr+FnL
        qH7n3KAjqPhHfdk0gkdNnYcCyphBo3KPqqFL9i9ATEUk4i+vgP/W6bzfwMiMFhThzbaLmdZxp8KSC2Fk
        YopZYet4O6PyKa/fmsHec3GWfllRucdEKIlBY88vR1jhfCwpDsbmP1Zh3hYRbmhshozzNSihP9q2Uwxe
        xzcdnpKnjmeau3Izjr1gmT/lf6d2YJ+IWKSV3xIDtAR8XTAfcReXI7woCEtLggm8gCvhWhR846bweca9
        LAlOmdNihxqAyB2lYjw5NTZRAsN+OrwdtD6F/7MzKutRVN0GbO3Eaq2Ryt4gxF1ogapFWbPn5qurMGeD
        F1/UwMgU++6/QEypnLe76BN0qwTTS0dAmjkU3c3EixkQvQVHKfOD9D9291vUAmaDTM32toOqxLJeekCE
        N2du9IEl3XgD6H5I0O8kmJTjiNGxNpDudIB0x1Do9enC5/lHJeICHadnIC+5IrhHbwMszg14yd6OxOH0
        TPyTbN/ozRdlGrVuMGYcdsboGBuMSbCDa7wth3ukD4W+qRafs3rvCXy+JqkF7OBth8Tr0TzjtiCN0mS7
        RTe4bbfHxGxHuGy0VcM9WeZku76ZCDcfJGkBD5EOxvryCESUhrSHdKBm2xOuEfzbyXxRXRNtuCXZw5PB
        Cdo6cwbv2kt0Rw2WeFhjvfztwExqONk+PVrKF9XpoQV32ScEd3gJ7rnLAe6p9jC00Ht3MBODszhm+7Qo
        Ea5LZZbDswiust1lky289zvBatJHavC/Dt4SbDi3jO9e0+KvUzOc2T67le3uqSKcZczgk/YMg6WUg+sZ
        uGngSAtsu7cW8VdWIKYysnOqWEafYiSyGhOptvuhq44uDPrqwYPOdmrxcEzOG4aZR5zx8XCqF+yc+zuP
        zGQvTrPoUoSNwbgQ505rbLAzxi8cBZ/YKbCwN+UAQ3N92ASYw9rXDJYevXlfX/shRUJV9UMdczu7fOpQ
        kJj371N1JlYWJfK7Nw3+B7qfhOKZvY1ZAAAAAElFTkSuQmCC
</value>
  </data>
  <data name="$this.Icon" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        AAABAAUAEBAAAAEAIABoBAAAVgAAABgYAAABACAAiAkAAL4EAAAgIAAAAQAgAKgQAABGDgAAMDAAAAEA
        IACoJQAA7h4AAAAAAAABACAA5FEAAJZEAAAoAAAAEAAAACAAAAABACAAAAAAAAAEAADDDgAAww4AAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwUvQE8SWW2AIGV7jihieYwoT2V4ISQ1RBQAAAEHAAAAAgAA
        AAMAAAABAAAAAAAAAAAoOk4AAAAAAX+UpTOpvs+Qu9HiwsLZ6tbE3Ozew9vs3r7X6da1zuHBo7vOk3iO
        oDoAAAAGAAAAAgAAAAAAAAAArMHTAJyzyDHI3e3W1u39/9jw///Y8P//2PD//9jw///Y8P//2PD//9Xt
        /f/G3e3cnbXJOr7V5wAAAAAAW3mVAPz//wC4zNx52e78/9jw///X7///2PD//9nx///Z8f//2PD//9fv
        ///Y8P//2O/9/7nO34f///8AWXmXACaDxQAAAAABkbjZfMDY+f+61Pz/0uv7/8zk9v+xyd3/sMjd/8rj
        9P/T6/v/utT8/7/Z+v+VvNyIAAAlAiqGxgAdleAGIH7TdSdtveihvOL/t9Dz/3KKpv+0zOD/udHl/7jQ
        5P+3z+P/coqm/7HL7/+iwOf/K3G/6iSC1Hsll98IKZTfQx941OwWU6L/aYOj/8Xd7/+nwNb/zub2/9vz
        ///b8///0On4/6fA1v/H4PH/b4yt/xhXo/80pOTwP7frTTOd4Wshgtr8FGrL/yFepP9WjK7/faS//5Cw
        yf+at8//mrbP/5Cuyf98nb7/Unqp/yBYov8ghNL/RtP2/krC7nk+r+hARMr36xGg9v8QjOn/M7/q/zm8
        3P83q8//JXG1/x5erv8aXrL/FWC7/xFrzP8MfuP/EqT3/0bW+/BEuetLAFrNBVrO8oQ7xf37A5///xe1
        /v8tzf7/Irr6/w2L6/8KhOj/EpHs/x+p8v8Vq/r/AZ3//xaq/fxAvfOPI4fVCDKj5AAnktwMVcfzjzG6
        /fsCnf//AZ7//wGd//8Anf//Caj//y7R//873///MNP//xWr/f0ysvOYMp3fDzSn5wAAAAAANabkACuX
        3Q1TxvOTOsX9/BW0//8CoP//AJz//xSz//863f//ONv//yK//f0iqPSdNaHfEDKn5wAAAAAAAAAAAAAA
        AAA5q+YALJjfD13S85xR4P39GLb//wCc//8Eov//FLT//xCt/f0GmPSgFo7gEhWV6AAAAAAAAAAAAAAA
        AAAAAAAAAAAAADyt6AAxnOERVczyhS+9+uMKof37Bp/9+wGY+uQAkPKHAIHiEgCH6QAFAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAHYPZABt20QMrougmI6TuThmd7k8HjegnAHHRAwB72QAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAPABAADAAQAAwAMAAMADAACAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAQAAwAMAAOAH
        AADwDwAA+B8AAP//AAAoAAAAGAAAADAAAAABACAAAAAAAAAJAADDDgAAww4AAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAACAAAAAgAAAAIAAAABAAAAAQAA
        AAEAAAACAAAAAgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAHEx0oFk5j
        dTRyiJxThJuubIyjtnqPp7uDjqa6g4agtXt7lapsaIGWVEZcbzYTHSgZAAAACwAAAAkAAAAGAAAAAwAA
        AAEAAAAAAAAAAAAAAAAAAAAA1P//ABguRAd8kqZUqr/QtsDW5ufK4fH50Ob2/tLp+f/S6vr/0un6/8/o
        +P/M5fb+xd7w+LnT5uekvdC7epKmXhwqOQ4AAAAFAAAAAwAAAAEAAAAAAAAAAAAAAABMcZIAAAAQApqy
        x23L3u3w2e/+/9nw///Y8P//1/D//9fv///X7///1+///9fv///Y8P//2PD//9jw///X7v7/x97v9Ju0
        yXsROWEEcKDMAAAAAAAAAAAAAAAAAAAAAAB+mrQAepewK8fa6OPa8f//1+///9fv///X7///1+///9fv
        ///X7///1+///9fv///X7///1+///9fv///X7///2fH//8jd7OyFoLg5jKa9AAAAAAAAAAAAAAAAAAAA
        AACZscUAkam/S9Tm8/rZ8f//2PD//9fv///X7///1+///9jw///Y8P//2PD//9jw///X7///1+///9fv
        ///Y8P//2PD//9Po9v+ZscVfssbWAAAAAAAAAAAAAAAAAAAAAACAoLsAf564Ns3h7+/M5P//wtv9/9bu
        ///a8v//2PD//8ri9P/G3vD/x9/x/8nh8v/X7///2fH//9bu///D3f3/y+T//8vj8/eKqMBIk7DIAAAA
        AAAAAAAAC3PDADSDzQAigsshHnTGiIq24/Orw/r/jKr5/73W8P+txdn/zub3/5avxv+Jobr/iaG6/5Cp
        wf/N5ff/sMjc/7rT7f+Mqvn/psH7/5K+5/gleceQJYXMJFao3QAJYrsAJ5LaAB+L2Ssif9PJF2fE/0Fu
        qP/N4PL/0uv//4WeuP8zTG//r8fb/8/n+P/Q6Pj/0Oj4/87m9/+40OT/OVJ0/3mRrf/Q6f//yuL3/0l3
        sf8XZsP/KITV0CaQ2jI0nt0AAIHeBSiP3J8cctL/F1yy/yJBb/+hudD/2PH//7fP4/+MpL3/yuLz/9nx
        ///Y8P//2PD//9nx///N5fb/jKW9/7DI3P/b8///qcTc/yRHeP8WWa3/KIrb/z6y6KsAbNUKHZfiIi6O
        29wYas7/GGbG/xlJif9BXoP/lrLL/73Z7v/M5/r/0ez9/9Pt///U7v//1O7//9Tt///S7P7/zur8/8Le
        8v+gvNT/SGeO/xhHhv8ed8r/OsXw/1PQ8+UjleAuIpniKjec4eMWetn/FHDV/xdnyf8bX6v/MXSa/0h3
        lv9egZ//cZCr/4Cctv+IpL3/iKS+/4GduP9zkK7/X36g/0RolP8nVY//GFem/xdlxv8nmuH/P9j4/1fU
        9O0pm+I5AHHUEE3E8ME3zP3/Cp74/wqD5/8Zgt3/Ocfv/zrE5f81sdP/M6PE/y6Ntf8dWp//G1Wd/xpW
        oP8YWKf/Flyy/xZhv/8WaMv/FHHW/wuB5f8ar/j/QuD//1PO9M8Ogdkaj///AD+x6WJm4/r4KsP//wCc
        //8Em/v/KcP6/z7Z+v8/2Pn/P9j5/y2q6f8XbdL/FmzR/xZt0v8VbtT/E3LX/xB73/8JiOv/A5b4/wCd
        //8Ipv//SdP7/EO26nT///8AD4DaAABj0QlRwO2RYNn7/BKo//8AnP//B6X//yDB//8qyv7/Hrz9/wmZ
        9v8GjvH/B47x/waQ8/8So/b/I736/ybG/v8TtP//AJ7//wGd//8lsvz+QbfvoBB91w8Xit0AAAAAABaM
        3gACdNYOUsDulljS/PwPpv//AJz//wCd//8Bnv//AJ3//wCd//8Anv//AJ7//xS1//812P//O97//zzf
        //8x0///BqP//yKw/P4+te+kG4naFCSb4gAAAJEAAAAAAAAAAAAXjN4ABHXWD1LB7ppVz/z9DaX//wCd
        //8AnP//AJ3//wCd//8Anf//BqP//zDS//873v//Ot3//zve//8qzP//Gqz8/ziy76cei9oVJJvhAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAGZDfAAh41xFTwu6eW9j8/i/M//8Zuf//A6D//wCd//8AnP//B6X//zPV
        //873///O97//zDS//8Vr/3/IqTvqyCN2hgjm+IAAACVAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AB6V
        4QANf9kUV8fvqGno/f9A3///Grv//wCd//8Anf//AZ7//xKx//8gwf//Grr//wik/f8Gk/CuFYnbGRaU
        5AAACiEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbwAinOMAEoTbGVfG76lk5fz9M9D//wKf
        //8AnP//AJ3//wCc//8Anf//AJn8/QCP8K0BftwbAIblAABCpQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAKsAH5viABCA2hJHuet6Q8T12hip+/sNo/3/CqH9/wad+/sAlfbbAIvrfQB8
        2hQAheUAADRpAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFP
        xgAAKrYCHo7dHiih6FIlo+t0H5/rdRKT6FUCgN4fAFy3AgBsxwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAA/8APAPAAAQDwAAEA4AAHAOAABwDgAAcA4AAHAMAAAwCAAAEAAAAAAAAA
        AAAAAAAAAAAAAIAAAQCAAAEAwAADAOAABwDwAA8A+AAfAPwAPwD+AH8A/wD/AP///wD///8AKAAAACAA
        AABAAAAAAQAgAAAAAAAAEAAAww4AAMMOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAACAAAAAgAA
        AAEAAAABAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAgAAAAQAAAAGAAAABwAAAAoAAAUQCxkoGBwwQR8rP1MmMUdbKjFGWioqPlEnGis8IQkU
        IBoAAAISAAAADAAAAAkAAAAJAAAACAAAAAYAAAAEAAAAAwAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAMAAAAJAAAADyg6SitfdotbgZiti5WswK6iuczGqcDS063E19uvxtnfrcbZ36nC
        19uivNHSmbTKxIunva14k6qKWnOJXis8TS8AAAITAAAADgAAAAsAAAAIAAAABQAAAAIAAAABAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAADVRaxR+l612rcLT08fb6/jS6Pf/1+38/9nv///Z8P//2fD//9nw
        ///Y8P//2PD//9fv///W7v7/0+v8/8zl9v+/2ev5qMHV2H6YroM4UGYdAAAABQAAAAUAAAADAAAAAQAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAF+BnwBNcZMUm7LHos/h7/vc8f7/2fH//9fv///X7///1+///9fv
        ///X7///1+///9fv///X7///1+///9fv///X7///2PD//9jw///Y8P//y+Ly/Z22y7NZepkefaPEAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABVeJgAAAAAAJCpwIPT5fL+2vH//9fv///X7///1+///9fv
        ///X7///1+///9fv///X7///1+///9fv///X7///1+///9fv///X7///1+///9fv///Y8P//0+f1/5iw
        xpkALVsFVXiYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFl8mwBIbpAXt8ra097y///X7///1+///9fv
        ///X7///1+///9fv///X7///1+///9fv///X7///1+///9fv///X7///1+///9fv///X7///1+///9fv
        ///b8f//vtLh5F+AnyZjhKIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAXX+eAFp8myPC0+Hk3fL//9fv
        ///X7///1+///9fv///X7///1+///9fv///X7///1+///9fv///X7///1+///9fv///X7///1+///9fv
        ///X7///1+///9rx///H2ujybo2oOGyMqAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABZe5oAQWeLE7bK
        287f8///0+v//9Do/v/W7v//1+///9fv///X7///2PD//9Xt/f/X7/7/2PD+/9Xt/f/Y8P//1+///9fv
        ///X7///1+///9Hp/v/U7P//2vH//7vR4uJef54kYIKhAAAAAAAAAAAAAAAAAAAAAAAAAAAAIXyxAAyF
        oAATbLIddabPutbp+/+Ws/n/fZz3/7rU/P/Z8f//1+/+/9nx//+81Of/fZaw/4miu/+Npb7/fJWv/7LK
        3v/Z8f//1+/+/9nx//+81vz/f573/5az+f/R6f3/g7HWzR1wsSUAdq0BH3iyAAAAAAAAAAAAAAAAABV9
        zAARe8oII4LNZx11y9Qjcsv7sMzr/7LK/P+Ytfr/v9j4/4aft/9yiqb/xt/w/7HJ3v+kvNL/nrfN/5my
        yf+mv9T/qMDW/83l9/97lK7/f5ix/7vU9f+Ws/r/qsX7/7XU8v8uec77IHfM1yiHz24SesoLF3/NAAAA
        AAACcdIAAFXOAyKM2HkjfNP3GGrM/xVPmv9zja//4vT//9nx///B2ev/OlN1/yY/Y/+guM7/2fH//9bu
        /v/Y8P//2PD//9bu/v/Y8P//r8fb/y1Gaf8wSWz/tc3g/9ry///a8v//fp3A/xVPm/8Yacv/KILV+iuT
        2ocAXM0FA3HSABuP3gAYjt45Kova6hls0P8XZMH/GD1y/z9bg//L3/D/1/D//9Lq+v+IoLn/dI2o/8Xd
        7//Y8P//1+///9fv///X7///1+///9jw///L4/T/eZGs/3yVr//N5fb/2fH//87n+P9JaZT/Fjx0/xdg
        vP8cc9L/Pqnl8SCX4UgqnuMAwP//ACub4ocogdb/FmnO/xdoyf8aSYb/Hztk/3mUsf/B3vP/zen7/9Ps
        /v/V7v7/1+///9fv///X7///1+///9fv///X7///1+///9fw///W7v7/1O3+/9Ls/v/J5fn/hqTB/yFA
        bf8YRYL/GWvH/y2o5v9R1vX/PrLpnAAAaQEAOccFNqLjsCV60/8WaM3/F2rO/xhlwv8aTI3/JUNu/1p0
        lP+OqsT/qsjg/7rY7v/D4PX/yOX5/8vn+v/M6Pv/zOj7/8vn+//J5fn/xOL2/73b8P+vzeT/lbPN/2OA
        oP8nR3P/GUmI/xdhvf8lkd3/PNH0/1Lc9/9Pwu7FAFPMDgAavQQ7qOWtLY/d/xB53P8TcdX/F2vP/xdo
        zP8babr/Kn2k/yxmiP83X3//R2aF/1hzkf9ngZ7/coyo/3iUrv95lK7/dI+q/2mFof9bdpX/SWWI/zVV
        fv8jS37/GU2Q/xhdsv8XaMr/F2rP/y6q5/881/j/U975/0/B7sMAUMsOpP//ADWm5YBV1/j/I8L+/wec
        +v8Jh+v/EnTY/x191/87y/P/Pc7v/zm93/80qsz/MJi6/y6MrP8ka5v/GkyN/xpNjf8aTo//GFCV/xdU
        n/8XWaz/F2C7/xdnyP8Xas7/F2vQ/xNy1v8LhOf/I7v6/zre//9a4/z/QLLpmAAAAAEXj98AEondM1/S
        9OZZ6P//HL3//wCd//8CmPv/C5Lw/zLH9f8/1fb/PtT2/z/V9/8/1vj/P9X3/yeV3/8Xac7/F2rP/xdq
        z/8Xas//F2rP/xdqz/8Xas//FW3S/xF32/8Kh+r/A5f5/wCd//8Orv//Qd3//13W9vEek+BGKJ7jAABv
        1QAAAJkCNKfmfXXl+fxN2///BKD//wCd//8Anf//FbP//zfX/f892vv/Pdj5/z3X+P8vu/D/F3rY/xRw
        1P8UcNT/FHHV/xNz1/8Qd9v/EIDh/w6N6/8IlvX/AZr9/wCe//8Anf//AJz//wii//9Ozvv/PbDolABB
        xgYBdNYAAAAAAAd62AAAZNIOQLHpmXbk+v0zvv//AJz//wCd//8Bnf//D67//yLD//8lxv//Grr//wah
        /f8Cl/r/A5f5/wOX+f8Cl/r/A5v7/xWx/f8pyv//MNP//y3P//8Us///AJ3//wCd//8En///OL37/0Cz
        660DddYXDoXcAAAAAAAAAAAAAAAAAAmA2gAAatMRQbLpnXPh+v0vu///AJz//wCd//8AnP//AJ3//wCd
        //8AnP//AJ3//wCd//8Anf//AJ3//wKg//8gwf//ONv//zve//873v//O9///zDS//8Fov//BJ///za8
        +/8/s+uvCXrXGhWQ3wAAALEAAAAAAAAAAAAAAAAAAAAAAAmA2gAAadMSQbLpoHHg+v4quP//AJz//wCd
        //8Anf//AJ3//wCd//8Anf//AJ3//wCd//8AnP//F7b//znc//863f//Ot3//zrd//873v//MNL//waj
        //8vt/z/P7PssQp71xoVkd8AAAi0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAqB2wAAbNQUQ7TqpXDg
        +/4ntv//BaP//wWi//8Anf//AJ3//wCd//8Anf//AJ3//wGe//8oyf//O97//zrd//863f//Ot3//zrd
        //8cvP//Ha38/zau7LYNfdgdFpHfAAAhvAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABnAA2F
        3QAAb9UWR7frqHTl+/9I3P//L9L//x29//8Eof//AJ3//wCd//8Anf//AZ7//yTF//883///O97//zve
        //842///IcL//w6l/P8ko+y5EoLYIBiU4QAAKY0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAACYABCL3gAAddcaSbrrs3rs/P9P5f//Od3//x6///8Anf//AJ3//wCd//8Anf//Caf//yPD
        //8qzP//JMX//xKx//8Cnfz/CpPtvBCD2SIUlOMAACKdAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAADXCABOQ3wAFedggTLzsuXns/P9P5f//MdT//wel//8Anf//AJ3//wCd
        //8Anf//AZ3//wKf//8Bnv//AJr8/wCN7b4CfNkkAonkAAAwsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB6gABeX4wAIfNkgR7frrG3i+ftL3///C6n//wCc
        //8AnP//AJ3//wCd//8Anf//AJ3//wCY+fwAi+uxAHzaIwCF5QAAXLYAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACbAAiF3QAAa9QQL6LkbUnB
        8M8stPj4F6n8/w+l/f8Mo/3/CqH8/wSZ+PkAkPDQAIXlbwB31BEAgeAAADFjAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAs
        tgAAAIYACXXVFyKX4UwpoeeAJ6PqmSOg6poamOiDConiUAB41hgALIIAAF23AAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/4AB//AAAA/gA
        AAH8AAAD+AAAH/gAAA/wAAAP8AAAD/AAAA/wAAAHwAAAA4AAAAGAAAABgAAAAAAAAAAAAAAAgAAAAIAA
        AAGAAAABwAAAA+AAAAfwAAAP+AAAH/wAAD/+AAB//wAA//+AAf//wAP///AP/////////////////ygA
        AAAwAAAAYAAAAAEAIAAAAAAAACQAAMMOAADDDgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAQAAAAIAAAACAAAAAwAA
        AAQAAAAFAAAABQAAAAUAAAAGAAAABgAAAAYAAAAGAAAABgAAAAcAAAAHAAAABwAAAAcAAAAGAAAABQAA
        AAUAAAAEAAAAAwAAAAMAAAACAAAAAgAAAAIAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAABAAAAAYAAAAJAAAACwAA
        AAwAAAANAAAADgAAABEAAgUWAw8bHAkYJiAXKTsmHjJFKyE1SC0hNUguHzJELBgpOSgKFyMhAwsTHQAB
        AxgAAAAUAAAAEQAAABAAAAAPAAAADgAAAAwAAAAKAAAACAAAAAcAAAAFAAAABAAAAAMAAAACAAAAAQAA
        AAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAMAAAAIAAAADgAA
        ABIAAAATAgYKGx4xQzE/WXFSWHOMdmuGnpZ5k6uuhZ+1woqjucqRqr/Ula7D2pavxd2Vr8Xdkq3D2oyo
        v9SDoLjJfJmyv3GPqKxjgJqTUm6HdDxUa1IeMEAzBAgMHgAAABUAAAATAAAAEQAAAA4AAAALAAAACQAA
        AAcAAAAFAAAAAwAAAAIAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAA
        AAQAAAAJAAAADBgpOR9MaIFedZCnqJeuw9uxxtj1w9fm/s7i8P/U6Pb/2Oz6/9nu/P/Z7/3/2e/+/9nv
        /v/Y7/7/1+7+/9bt/f/T6/z/0On6/8vk9v/C3O//ttHl/qXB1/OPq8PbdJCprk9rhGgfMUIpAAAAEAAA
        AA4AAAAMAAAACQAAAAcAAAAFAAAAAwAAAAIAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAEAFSsDUHGOQ4Setrq3y9r31ufz/97x/v/c8v//2vH//9jw///X7///1+///9fv
        ///X7///1+///9fv///X7///1+///9fv///X7///1+///9jw///Y8P//2fH//9nx///W7v7/zOT1/7PL
        3vqIorrIVXOPVxAiMwoAAAAEAAAABAAAAAMAAAACAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAARmuNABVBawNjhKFjo7nN59vq9f/g9P//2fD//9fv///X7///1+///9fv
        ///X7///1+///9fv///X7///1+///9fv///X7///1+///9fv///X7///1+///9fv///X7///1+///9fv
        ///X7///2PD//9rx///U6vj/qcDT8GuKpnw0W34Ju///AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABUd5cAjqm/AGCBoFerwNLu5PL8/9vx///X7///1+///9fv
        ///X7///1+///9fv///X7///1+///9fv///X7///1+///9fv///X7///1+///9fv///X7///1+///9fv
        ///X7///1+///9fv///X7///1+///9fv///X8P//3PH+/7TJ2vhqiaZ0AAA3AVF1lgAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABWeZkARmyPHZStwtDj8fr/2vH//9fv
        ///X7///1+///9fv///X7///1+///9fv///X7///1+///9fv///X7///1+///9fv///X7///1+///9fv
        ///X7///1+///9fv///X7///1+///9fv///X7///1+///9fv///X7///1+///+Dy/f+kus3lU3aXNFt9
        nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABri6gAY4SiXcTV
        4vzj9f//1+///9fv///X7///1+///9fv///X7///1+///9fv///X7///1+///9fv///X7///1+///9fv
        ///X7///1+///9fv///X7///1+///9fv///X7///1+///9fv///X7///1+///9fv///X7///1+///9zy
        ///R4ez/c5Gsg8XX5ABWeZkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFZ5
        mQC4y9sAdZOuhtfl7//e8v//1+///9fv///X7///1+///9fv///X7///1+///9fv///X7///1+///9fv
        ///X7///1+///9fv///X7///1+///9fv///X7///1+///9fv///X7///1+///9fv///X7///1+///9fv
        ///X7///1+///9jw///e7fj/h6K5rwAVSQRWeZkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAFZ5mQDT4u0AdpSvitnm8P/e8v//1+///9fv///X7///1+///9fv///X7///1+///9fv
        ///X7///1+///9fv///X7///1+///9fv///X7///1+///9fv///X7///1+///9fv///X7///1+///9fv
        ///X7///1+///9fv///X7///1+///9fv///d7fn/iqS7tAArWwZWeZkAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAFZ5mQB4lrEAaYqnbc3c6P/i9P//1+///9jw///Z8f//2PD//9fv
        ///X7///1+///9fv///X7///1+///9fv///Y8P//2fH//9fv///X7///2PD//9jw///X7///1+///9fv
        ///X7///1+///9fv///X7///2PD//9nx///Y8P//1+///9jw///U5vP/fJmzmP///wBWeZkAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABSfaIAS3eeN67G2u7o9v//1Oz//7rU
        /P+sx/v/wdr9/9bu///X7///1+///9fv///X7///1+///9bu/v/C2u3/vdXo/9Pr+//W7v3/wtrt/8DY
        6v/U7Pz/1+///9fv///X7///1+///9fv///X7///xN39/7DL+/+81v3/1Oz//9rx//+81Ob8XoapXWON
        sgD/dAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAF2imADGHxwAle7kOI3W2Umae
        zeTj8vz/udL8/26O9f9oiPX/eJf2/8bf/f/a8v//2fH//9nx///X7///2fH//6a/1P9Xb47/WnOR/26H
        o/92jqn/WnOR/1Zujf+Pp7//2PD//9fv///Z8f//2fH//9ry///I4f7/e5r3/2mJ9f9vj/X/tc/8/9vx
        //+AsNfzKHe1ZCN5uRB/+P8ADlWaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQcsIACW3ABiB/
        xk8ie8i8HHLJ9SJ0z/+20/L/0+T+/4qo+P97mvf/lbL5/8/o/v+yyt7/epKt/5Wtxf/Q6fn/2vL//4qj
        vP+CmrT/yODy/3GKpf9ngJ3/wtrs/4+owP93j6r/1+///9Xt/f+jvNL/fJSv/6nB1v/O5v3/k7D5/3mY
        9v+GpPj/w9z9/8Hf+P80f9P/HXPK9iZ/ycQigcdYCGm+CBBywgAAAAAAAAAAAAAAAAAAAAAAAAAAAAZ0
        ywAAa8gIHobRfSeE0vIbcM//F2rP/xRduP9tkbz/6fb9/9Ts///O5/7/1u7//8be7/9KY4P/JT5i/y1G
        av+Zscn/2vL//8ri8//G3vD/2fH//8/n9//N5fb/2fH//8ff8f/H3/H/2vL//7DI3P83UHP/JT5i/zxV
        d/+30OP/1u7//8zl/v/R6v7/2vH//4aoz/8XXrf/F2rO/x1y0P8ui9X1I4vSjgBuyRAHdMsAAAAAAAAA
        AAAAAAAAAXfUAAAAtQEVh9dxLY7Z9xxw0P8Xas//F2G7/xdBe/83VoL/1ePu/97z///X7///2fH//7vT
        5v84UHP/J0Bk/yU+Y/+Enbb/2fH//9jw///Y8P//1+///9jw///Y8P//1+///9jw///Y8P//2vL//521
        zP8pQmb/J0Bl/yxFaf+mvtT/2vL//9jw///Y8P//0Oj5/0tsmf8UP33/F162/xZqz/8ec9H/Opve/B2N
        2YYATcgEAHbTAAAAAAAAAAAABHzYAAJ82DIsl9/jI3nT/xZpzv8Xas//GVGZ/xo5aP8eP27/qLvP/+L1
        ///X7///2O///9Lq+/97lK7/PFV3/1Vujf+70+b/2PD//9fv///X7///1+///9fv///X7///1+///9fv
        ///X7///2PD//8be8P9geZb/OFFz/2d/nP/K4vT/2PD//9fv///a8f//s83j/ydKfP8XO2//GEyR/xdp
        zf8VaM3/K4LW/0Cs5u4GftlHC4LaAAB62AAAetgAAAAAABuR3442ld7/F2rO/xdqzv8Xa8//GVKb/xs5
        Zf8ZN2T/Xnmc/8jh9P/N6Pv/1O3+/9jw///U7Pv/wNjr/8vj9P/Y8P//1+///9fv///X7///1+///9fv
        ///X7///1+///9fv///X7///1+///9jw///N5fb/vdXo/8/n9//Y8P//1+///9Xu/v/S7P3/dJK0/xg6
        bP8ZOmv/GEyQ/xdpzf8ac9H/LaTj/17W9P8nnOKqAEXIBgB62AAAetgAAGbSEzGh5M4wiNj/FWjN/xdq
        zv8Xas//GGO//xtCeP8bN2D/JUJq/4Whvf+72vH/weD1/8fj9//O6fv/1O7+/9fv///X7///1+///9fv
        ///X7///1+///9fv///X7///1+///9fv///X7///1+///9fv///X7///1+///9Ps/f/O6Pv/yeX5/8Lh
        9v+Sss7/LEx4/xk4Zv8aP3T/GF21/xpy0v8xsOj/PdP1/2Dj+f9IuevjAG3UJQB62AAAetgAAHXXKz+r
        5uopftX/FmnO/xdqzv8Xas7/F2rP/xhhuv8bR4D/HDdf/yhBZv9jf57/m7rU/7TU7P+83PP/wN/1/8Pi
        9//H5Pj/yub5/83o+v/P6fv/0Or8/9Dq/P/Q6vz/0Or8/8/p+//N6Pr/y+f6/8nl+f/G4/j/w+H2/7/e
        9P+42O//pMTd/3GQr/8uS3P/Gjhj/xpDev8YXLH/F2nO/yiY3/8+0/X/PdP1/1rh+P9cy/H4AXvZRwR+
        2QAAetgAAHjYMUSw6O8pfdT/FmjN/xdpzf8Xac3/F2rO/xdrz/8XZ8j/GVil/xxFe/8ePWL/K0Nm/0hh
        gf9phKH/hKG8/5i20P+mxd7/r8/n/7XV7P+52O//u9rx/7zb8v+82/L/u9vy/7nZ8P+21u3/sdHp/6nJ
        4f+dvNX/i6nE/3GOrP9RbY3/MEtw/x06ZP8aQXb/GVOd/xhlw/8Xas//GW/Q/zS56/8/1PX/PdL1/1jg
        +P9j0fP9Bn/aVAeB2gAAetgAAHDVJ0Ox6Oc5mN//EoDf/w1+4v8Sddn/FmzQ/xdpzf8Xas7/F2rP/x12
        zv8zp8//L4mr/yZjhf8hSmz/IkBh/yhAYf8xSGj/PVNz/0hfff9RaYf/WnSQ/113k/9dd5T/W3WS/1Ru
        i/9KY4L/QVl5/zRNbv8pQ2X/ITxi/xw7Z/8ZQXb/GU2Q/xlbrv8XZsX/F2rP/xdqz/8Xac3/GnTS/zfF
        8f891/n/O9b4/13j+v9byvD2AHrYRAR92QAAetgAAFrPDzWn5cZk3/n/L9D+/xOz//8Cmvz/B47x/xB7
        3v8WbdH/F2jN/x9/1v88zvX/P9X3/z3P8f87wuT/N6/R/zKbvP8uh6j/KnaX/yhqiv8jW3//G0Jy/xo/
        cP8aP3D/GkBx/xpBdf8aRHv/GkiF/xlOkf8ZVZ//GVyv/xhjvv8XaMn/F2rP/xdr0P8Xas7/F2nN/xdr
        z/8Rddn/DY/s/zHP/f873v//Od3//2rs/v9Ht+rgAGvUIgB62AAAetgAadn2ABeN3n9u3vf/V+j//zXZ
        //8Us///AJ3//wGc/f8GkPL/Dnzf/xt+2P86yPH/PtT1/z7T9f8+1Pb/PtX3/z/W+P8+1ff/PtT2/z7T
        9P80tej/GWzL/xdnyf8XaMn/F2jJ/xdpy/8Xacz/F2rO/xdrz/8Xa9D/F2vQ/xdqz/8Xas7/F2rO/xdp
        zf8WbND/EXjb/wiL7f8Cmfz/AZ///yXG//863v//ReH//3Pm+v8lmuKjADbCBQB62AAAAAAAAnrYAABy
        1ipDtOrehPT+/0/l//8u0f//BqP//wCd//8Anv//AJz+/waX9/8swvj/Ptb3/z7T9f8+0/X/PtP1/z7T
        9f8+0/X/PtP1/z7U9f8qnuH/F2nO/xdqzv8Xas7/F2rO/xdqzv8Xas7/F2rO/xdqzv8Xas7/F2nN/xdp
        zf8Xa8//FHHV/w5/4v8Gj/L/AZv9/wCe//8Anf//AJz//w6t//811///ae3//1PD7/ACe9lGCYLbAAAA
        AAAAAAAAAHjXAP///wAQiNxwY9Hy+oj4//9O4///EK///wCc//8Anf//AJ3//wCd//8Prv//Ndf+/zzb
        /f882Pr/Pdb4/z3V9/8+1Pb/P9X2/za97f8cdtL/F2nN/xdpzf8Xac3/F2nN/xdqzv8Xas7/F2vP/xZt
        0f8TcNX/EHbb/wyA5P8GjPD/Apf5/wCd/v8Anv//AJ3//wCd//8Anf//AJ3//wCc//88yv//bNz2/xyT
        4JMATcoFAHbXAAAAAAAAAAAAAAAAAAB01gAAYdAMHpXhnHHd9v6L+f//McH//wCc//8Anf//AJ3//wCd
        //8Anf//E7L//zDS//863f//O97//zvd/v852v3/K8n8/xGd8/8Khun/C4Tn/wyD5v8Mg+b/C4Tn/wqG
        6f8Jiez/B43w/wWT9f8Mofn/FLH9/xe3//8Utf//CKf//wCd//8Anf//AJ3//wCd//8Anf//AJz//x2w
        //9j1vn/LaHkugBt1BsBd9cAAEzNAAAAAAAAAAAAAAAAAAAAAAABdtcAAGnTFSOa4qh03/f/g/D//yW0
        //8AnP//AJ3//wCd//8Anf//AJ3//wel//8Wtf//Hb7//xy8//8Ssf//BKH//wCd//8Anv//AJ7//wCe
        //8Anv//AJ7//wCe//8Anf//Caj//yLE//801///Odz//zrd//863f//MtT//xKw//8Anf//AJ3//wCd
        //8AnP//Ga3//13T+f8ypebCAHHWJgV/2gAAZtEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAXfXAABq
        0xgkmuKrdd/3/oHu//8hsv//AJz//wCd//8Anf//AJ3//wCd//8AnP//AJz//wCc//8AnP//AJ3//wCd
        //8Anf//AJ3//wCd//8Anf//AJ3//wCd//8Qrv//MdP//zve//863f//Ot3//zrd//863f//O97//yzO
        //8Dof//AJ3//wCc//8YrP//W9H5/zKm5sMActYpBoPbAABfzgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAFnNAAF42AAAadMYJJniq3bg9/997P//Hq///wCc//8Anf//AJ3//wCd//8Anf//AJ3//wCd
        //8Anf//AJ3//wCd//8Anf//AJ3//wCd//8Anf//AJz//wyq//8y1P//O97//zrd//863f//Ot3//zrd
        //863f//Ot7//zPV//8GpP//AJz//xar//9b0fr/M6bmxABy1ikGhdwAAFHJAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/wgABedgAAGvTGiSa4rF34ff/eer//xqt//8AnP//AJ3//wCd
        //8Anf//AJ3//wCd//8Anf//AJ3//wCd//8Anf//AJ3//wCd//8Anf//Ap///ybH//873v//Ot3//zrd
        //863f//Ot3//zrd//863f//O97//yzO//8CoP//DqX//1LM+v8zpubIAHLWKgeE3QAAUMEAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJAAAXnYAABs1B0mm+O1euP4/3Xn
        //8Wq///AJv//wCc//8AnP//AJz//wCd//8Anf//AJ3//wCd//8Anf//AJ3//wCd//8AnP//Caf//zXX
        //863f//Ot3//zrd//863f//Ot3//zrd//863f//Odz//xi3//8FoP//QcL6/zKm5swAdNYuB4XcAABk
        0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGbRAAJ6
        2AAAbdQfKZ7kt3zl+P9y5f//Jbz//xy9//8auv//Daz//wKe//8Anf//AJ3//wCd//8Anf//AJ3//wCd
        //8AnP//DKr//zfa//863f//Ot3//zrd//863f//Ot3//zrd//863f//Jcb//wSh//8rtPv/LqTnzwF2
        1jIKid0AAGPQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAABezwADfNkAAG7UIS2i5bx/6fn/fvX//0Xh//863f//Ntn//yLD//8Fov//AJ3//wCd
        //8Anf//AJ3//wCd//8Anf//BqP//y/R//873v//Ot3//zrd//863f//O97//zjb//8jw///BaL//xSm
        +/8knufRBXnXNQ+S3wAAZNAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWMwABYDaAABx1icxpubHguv6/3z0//9D4P//Od3//zve
        //8kxP//Ap///wCd//8Anf//AJ3//wCd//8Anf//AJ3//xCv//8tz///Ntn//zfa//801///Kcr//xOy
        //8Cn///A5z7/xGT6NQIfNc3EZfhAABezgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAF3OAAeG3AAAdNYxNKjmz4Xt
        +/978///Q+D//znd//842///EbD//wCc//8Anf//AJ3//wCd//8Anf//AJ3//wCd//8Eov//C6r//w2r
        //8Jp///Ap///wCd//8Amvv/Aoro1QN62DoIluUAAF7NAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABk
        0QAMkN8AAHXXNTir59GF7fv/e/T//0Pg//863v//IMD//wCd//8Anf//AJ3//wCd//8Anf//AJ3//wCd
        //8Anf//AJz//wCc//8AnP//AJ3//wCa+/8AienXAHrYPACH5QAAcNAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAXs8ADZfiAAB21zUxpubKeeP4/3vz//9H4v//I8X//wCd//8Anf//AJ3//wCd
        //8Anf//AJ3//wCd//8Anf//AJ3//wCd//8Anf//AJf5/wCI588Aetg7AIzsAABz0AAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAF7PAASM3gAAcNUiIJfhnlrJ8PRy6fz/OMv//wOf
        //8AnP//AJz//wCc//8AnP//AJz//wCd//8Anf//AJ3//wCa/P8AkPH1AIPipAB41iYAh+cAAGrGAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAatMAAFzPCQh/
        2lEtouS2Rbrv7zm69/8ns/z/Gq3+/xOo//8Qp///D6b+/w6k/P8InPj/AZDv8QCF5bcAfNpTAHHOCgB4
        1gAACFoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAWtAACT4gAAWc4LBXnXOBmP3ngnnuStLaXpzS2m6tcqpOrXJaDpzxmV5bILh9+AAXvYPQBw
        zgsAg+IAAEqjAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGOAAD//wAANr8EAGDOEQBo0BYAadAWAGbPEgBN
        wgYAAHgAABijAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAD///4B//8AAP/wAAAAfwAA/4AAAAAHAAD+AAAAAAMAAP4AAAAAAwAA/wAAAAAP
        AAD/AAAAAP8AAP8AAAAAfwAA/gAAAAB/AAD+AAAAAH8AAP4AAAAAPwAA/gAAAAA/AAD+AAAAAH8AAP4A
        AAAAfwAA/AAAAAA/AADwAAAAAA8AAOAAAAAABwAAwAAAAAADAADAAAAAAAMAAMAAAAAAAQAAgAAAAAAB
        AACAAAAAAAEAAIAAAAAAAQAAgAAAAAABAACAAAAAAAEAAMAAAAAAAQAAwAAAAAADAADgAAAAAAMAAOAA
        AAAABwAA8AAAAAAPAAD4AAAAAB8AAPwAAAAAPwAA/gAAAAB/AAD/AAAAAP8AAP+AAAAB/wAA/8AAAAP/
        AAD/4AAAB/8AAP/wAAAP/wAA//gAAB//AAD//AAAP/8AAP/+AAB//wAA//8AAP//AAD//8AD//8AAP//
        +B///wAA////////AAD///////8AAP///////wAA////////AACJUE5HDQoaCgAAAA1JSERSAAABAAAA
        AQAIBgAAAFxyqGYAAFGrSURBVHja7Z13fBzlnf/fM7NdvVjNtiy5yjYGY8AGgk2xwYEAAUJPI4RgSE8u
        uRy6+13uchc5d7m7kEsuBI5cSLlLMAkhCaF3G1NscMFl3WVbsnpdSVtn5vfHaOVdactskXZXnvfrta/d
        eeZ5Zp6Zne9nnvp9wMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA
        wMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAg
        DQiZzoBBenE2YgeuAC4BGoB6oAwoACyAidj/uwIEgBFgAOgCjgA7gC0NTbyT6Ws0SB+GAOQ4zkZuBy5D
        M/g6IG+ST6kCfYAT2AK82NDES5m+DwbJYQhAjuFs5FrgRjSDnw+Imc4T0A18gCYIf2xo4r1MZ8hAH4YA
        5ADORu4FPoJm9KWx4gqCgKNiBo7qaiyl5ZiLy5AKihAdhQgWG5jNIJqjHyDgRw14UUeGUIb7CQy58Pf3
        4u1qZ7i9A2//gJ4sbwM2AU83NOHM9P0ziI4hAFmKs5EPA59GM/pZ0eLZy0spnDsP+5z5mKvqEEurQTLH
        P4HsBzkAfg8oAfB7wWIn7JGw2MFsAyEkzDuE3NWC71QzI8ePMHD0KP7hkVhn2g5sbGjiyUzfU4OJGAKQ
        RTgbOQ+4H83oF0WKY7LZKFncQH7DMixzloCjeGIkVYGBDhhog/42GO6DkX7wuGBkQPtWFf0Zk8yaENjy
        wVYAtkLtd14J5JUi+/x4uzsYOnaU/sNHUJWIxx4EHgUeamjicKbvtYGGIQBZwOjb/n7g+kj7TQ47M1ac
        R96S85BqFoAohUcY6oX2A9B5BLqOwWAHKPLUX4hkRs4rx+0zM9TvZrCtJ5oYvA18q6GJN6Y+kwahGAKQ
        QZyNXIdm+FeP3yeaJEqXLqXonFWY6s8GyRQeofsYNL8PLR9ob/ssRJZh0AUDQwJerxopygfAAw1N/CXT
        eT1TMQQgA8R64zuqyqlcdxWWeeeB5Ajf6R2CQ2/Bwc3g6sr0ZSSExwt9/eAaBnWiFuwEvtHQxMuZzueZ
        hiEAU4izkYvQDP+T4/cVLaxnxpUfQapYDMK4nr2RPtjzIhzcojXe5TCBAPQNQP8gRKgdvAt8raGJrZnO
        55mCIQBThLORe4D/Hh9esmQ+5euuQyxfODGREoBdz8Del3Le8CdcmgK9/ZoYRBCC/wf8pKGJ3kznc7pj
        CMAk42zkeuDvgfNCw/NmVlJ9wy1IlUsjJ/R0QPcWePWViBYyXQjI0NunlQjGVQ1agS81NPGHTOdxOmMI
        wCQyOoDn4dAwk8NG7W23Yq5bCYIUIZUK/btg4ANtc/c+7VU5zfEHoLMbhoYn7NoK3N/QxO5M53E6YgjA
        JOBsZD2wETg3NLzqsosoWnMjmAoiJ1QD0PUGuFtPhx1phpOnMn1JU8bwCHR0gz+8xtMH3NXQxJ8ynb/p
        hiEAacbZyG3Ab0PD7DNKmfXxzyCWzo+eUPZA5yvg6wkPb+uAA0cyfVlTiqpCV6/WazCO7zY08XeZzt90
        whCANOJs5J+Bvw0Nq778YgrX3AKSLXrCgAs6Xta+x9PbB7v3Z/rSMoLbA22dE0oD29CqBMaEozRgCEAa
        cDZyNvBzYEUwzOSwUXfX3UhVy2In9vVC58taCSASQ0Ow/cyt/ioKtHeBaygseAS4qaGJ5zOdv1zHEIAU
        cTayFsLnwxfUz6LmzvvAWhY7sbdLM34lRhff8DBs25Xpy8w4A4Na28C4noLPNDTxWKbzlstkw1zynMXZ
        yA2MM/7qyy6m5tPfjG/8njboeCm28QOYTBhAUSHUzpxwO37ubDTaBFLBEIAkcTZyM4T3UdfdcQuFV3wS
        REvsxCMntQY/NRD/RIHpOwYgUWxWmDNL+w7hn5yNPJjpvOUqhgAkgbORW4EngtuCJDJvwwasi6+In3j4
        GHS9rn86rqxDJM4gTJJWEsgPd3z2FWejURVIBkMAEmTU+B8PbpscNuZ/+a8wzVweP/HwMeh+E82tnk58
        02sIcDoQBJhZpVULQvi0s5FfZzpvuYYhAAkw3vgthfnM/cI3EUvmxk/sOpi48QN4PInFP4OomgGlxWFB
        HzdEIDEMAdCJs5GPMc746z7/TYSCmviJXQeh9x0SNn6AYXemLz2rmVEWUQQeyXS+cgVDAHTgbORG4HfB
        bXO+QzN+R0X8xGPGnyTjOsANJhJBBD7nbOTHmc5XLmAIQBxGZ/ONObQ0OWzU3//1qTH+gF8bHG8Qlxll
        UFIUFvQFZyMbM52vbMcQgBg4G7kG+GNwW7KYmXvfVxEKZsZPnKrxA/T0R3SfYxCZinIoDm8Y/BtnI9/J
        dL6yGUMAouBsZB2c9lUnSCJz7/8yQvGc+InTYfwAXT2pH+MMo3IGFOaHBf0/ZyNNmc5XtmIIQAScjXwI
        eHEsQBCY//kvIpbNj584Xcbv80NPX6ZvRU5SXQkFhWG+Fh5wNvLdTOcrGzEEYByjvvm3jAUIAvPvvRdx
        xuL4idNl/ACn2o3ifwpUl8sUloU5VW10NvKvmc5XtmFMBgrB2cgSYBfaCroAzL37Lsx1q+InHj6mufBK
        B/4AvPO+5kEzl5EkbeieKIEU8q5RFZCDH3nSXJ6pKrSPlDLYHuZa8PsNTfx1pm9NtmAIwCjORuagGf9Y
        W3L9J+7EsnB1/MTJjPCLxdHjcKI19eNMNRYLzCiF0hIoLACzzolMXq/W3dk/CAMuzS9Ymko/qirQ7q9m
        MNyr0rcbmozGQTAEAABnI0Voxj/Wwld3+8ewLlkXP3G6jX/EDdt35ZYj0IJ8qK2B8rLwdQSTxeuD7h7o
        7NHmAaeIYsmnw13KYPOJ0ODGhiajm/CMFwBnIwKa8Y957qi98Vrs534kfmJ3S2ITe+KhKrBjr7acTi5g
        NsG8Om1M7mQ9SsNuaGvXvIKkUCVSKhbSfnIYV0tYyeqrDU38cArvWNZhNALCm4QY/6yr12bG+AGOt+SO
        8RcWwPnnQFUFk/oeybPD/HpYtQLqa7XlzZNA7DxI1flnk19THRr8oLORz0zlbcs2zugSgLORl4C1we3q
        taspvPQO4t6WyTD+nl74wJnpW6KP0hJYulBr5JtqZFkTypZToCRY7RJE1Mvvo+VPTzDSEba02l0NTfxi
        6i8m85yxJQBnI5sIMf6qNasoXHM7cY3f0w5dm9Nr/IMu2Hcw07dEHwV5mTN+0M47dw6sPBfKShJLqyoI
        7z7OrDvvw1YalvaxUQcvZxxnpAA4G3kIuCW4XXHhCorWfnLimnzj8bRD56v6PPnoZdClLf4h50CjnyTC
        0kWZM/5QbDZYthgWL0jMbdpQD8LOP1N799ewlRSH7nnC2chNmb6sqeaMEwBnI38D3BfcLlu+hJIP3xVl
        lZ4QvN3Q9Vp6jb+nD3bt1dbHygVqZ2mGl01UzoALlk+YBBCTEzsRWj+g9tNfwlIQNm74985GPprpS5pK
        zigBcDbyFTjd9VO8eB7lN2wAMU7Dkq8XOnU48EyEllOwx5kbb37QGt9mVad+nMnAaoFzlsBsHb4Zgmz/
        A4Lip+6zX8PksIfueepMEoEzRgBGW3sfDG7nz6yi8tYvxHfg6e+P77o7EXx+baGPw825NdS3sjw7iv7R
        EEStS3LxQhB1PNZKAF57BCG/mPq7vxxJBK7O9CVNBWeEAIwa//8Etx2VM5j5ya+AZI+dMODSXHfLaXDL
        pSrQ0gbvvq+t9pNrzChL/RhTQWU5LGvQJ1bDvbDlF4gVddTf/WUka5i74WfOBBGY9gIw2ro7Zvy20hJm
        ffqr4CiOnTAwDO0vgJyiSy5FgfZO2LYTDh/Lnfp+KIIwYY5tVlNSrFUJTDpE4ORu2PuSJgKf+TySNaxE
        +Mzowi/TlmktAKOtumPuu22lJdTe/TWE/NLYCf3D0PEiyCl44xke1lb2fft9cB6GkRx27mkyxe8hyTYK
        C+CsBn3Vgfefgq5jSDULqf/MFxDDBxu9NJ1FYNoOBBptyHkquG0pyKfunq8hlMRpKPIOwXP/ASM9mo+p
        ogLNCb3dHn1yiyyD2w1DI1q3Xm8/eLyZvgXpw2qBi87PdC6So6cX9hyI396SVwrXPQDWfALNH3Dsl4+g
        hA89/lBDE1szfTnpZloKwKgfvzFXXpb8POru+TpCaRzj97nhuX+Hvigz8QRh4mQXVc2txrxksNu0obi5
        SssprdE1HtUNcOWXQRA0EfjFwyhyWJVt2olAjpXr4jPacDNm/CaHnTl3fTG+8fs98OKPohs/aIauKOGf
        6W78wevOZWbVaA4D49Hm1KoDgKluGXV3fBohvArxprOR5Zm+nHQyrQTA2ch64JngtmS1UH/3lxAr6mIn
        lP3w8k+g+1imLyE7SXTMfTayaO6ERQUjsudFOL4DAPPCC6i/867xIrBjOonAtBGA0Yaa54LbktWiNehU
        1MdOqMjwyk+h41CmLyF7UXKw52I8kkkbNhwXFd78JQy0A5oI1N18+/iq31ZnI3oOlvVMCwFwNrKakGW6
        RZOJ+k9vQKpZGDuhqsLrj8KpfZm+hOxGVqaHCBQVakOH4+H3wKsPQ0BryLWctZr6cBGwA+87G9GxJlx2
        k/MC4GzkYuCNsQsymaj/1L1Is5bET7zlMTixM9OXkP2oKriGM52L9DCvLtw/YTQG2mHL6RnClmVrmHP9
        jaEx8oFduS4COS0Ao3WxN4PbgihSf+ddmOqWxU/89m/g6LuZvoTcobc/0zlIDxYzzNQ5p+H4Dq1NYBTb
        eVdSe/0NoTHygbecjVRl+rKSJWcFYNT4dwS3x4x//nnxE7/3BzjwRvx4Bqfp7k39GNnC7Bp9A4RA6xVo
        3Tu2aT9//XgRqAC2OxvJkbHS4eSkADgbWQpsHwsQBOpuvh3zwgviJ979LOx5IdOXkHsMj4ArR9yVxcNs
        hgqd9qoq8MbPYKBjLMh+/npmX31NaKyZaNWBnBOBnBOA0TrX24A20FsQqL/5dixn6XDfve8V2PGnTF9C
        7nKqI/VjZAtVOhZ3DeJzw6sPad+jOC66jllXrQ+NlZMikFMCMGr8u9DqXgDU3XQLlmVr4ic+9CZs+138
        eAbR6ejWfPhPB4qLtHUM9DLQAa//d5gruLxLbogkApudjSTnuTQD5IwARDL+2utvwHrO5fETH90Gb/0f
        afPdf6aiKJpDzulCaVFi8U/t1xqPQ4ggAovRughzwrZyIpOjxao3GGf89vPXx098crc2sCOdTjzPZNo6
        tZmO04GiBNyIBTm4ZUIbUt4lN1Bz6WWhQWehVQey3r6yPoOjxr8LrXgFQO11Oo2//aBWbFNyfI29bEJV
        4eA0GTKd50gu3XtPjQ0XDlKw9jZq1oRVRXNCBLI6c5GMf9ZV67FfoMP4u47By/8FsmH8aWdgUPNulOvY
        7UkmVOGN/9FeMCEUrLsjkgi8nunLjEXWCsBoQ8pmxhl/3iU3xE/c2wIv/QgCvkxfxvTl6HEYGsp0LlJD
        7+KlkVAC8OpPtWcthAgicImzkawddJKVAjBabHofrUEFSMD4+9vgxR+GddkYTAKKAnsPQSCNnpJzDZ9b
        e9G4wlYZomDdHVSuWhkatDpbRSDrBGDU+HehFZ8AqLn0Mn3G7+rS5vR7cvzNlCu43bD3YA77C0hDvt2D
        8NwPJohA8TV35YQIZJUAjBb73yHU+NesoWDtbfETj/Rrxj+Sgx53c5m+Ac3nYS72svjTVHoZ6ZsoAoKQ
        EyKQNQLgbKQI7c0/5nyuZs0aCtbdET+xdwhe+OEEFTaYIjq64FBzpnOROMNprCbmqAhkhQCEGP9Ynb/q
        4ov1Gb/fA88/OObAwSBDnGrPvZJAupdiz0ERyLgAhBj/nGBYzdpLKVr/ifiJ/R544T9j+/EzmDraOzUP
        vHKOOA/pmoQZjjkmAhkVAGcjhcBOQox/1tVrKbj0toned8cj+7VuGMOPX3bR0wc794I7y9dBGB4G1yQ1
        FueQCGS6BPAaUBfcmHX1WvIu+hhxvZUH/fi1Hchw9g0i4hqC93dntxORyZ7TMNIHz/4b9J86HZaFIpAx
        AXA28j5wbnB7pl7jVxV47RHDj1+24w/A7n1w6Gj2VQn6B6CzZ/LP4x6EF3+c1SWBjAjAeOOvvvxi8i+8
        ifjGr2p+2k7uzkS2DZKhtR3e26UZXTbgD2iNlVPFSB88/wOtmzpIFonAlK8MFMn4Cy/7uL6157b+WpvX
        n81YLGC1gs0MJrPmgDLofkpRNA+7fj94fdryYenqi84Fykthfh3YbJk5vyzDrn3pb/3XQ8EMuPqvwB4y
        BVlV6X/mMTreCfNN+ceGJm6YqmxNqQA4G9kKXBTcTsj43/5NdvrxE0UoL4GyEigu1tbRSwSvVxtM092r
        1ZmVHOpGSwZRgOpKqJ2pCeVU4fVqPRST1fCnh5KZsP6rYA1ZaTnDIjBlAuBs5CU4vcpqzhu/3QazqqFi
        RmqTSkLxB6CjE06e0koI0xlRhMpymFkF+ZO89Hh3Dxw4mh2lrdLZ8OGvgzmkFKSq9Dz5U7p3hVVtf93Q
        xCcnOztTIgDORv4XuDO4XbV6JUXrPq3T+H8LB7JoRqXVAvW12sM7WUtmK4o2uu7YSfBNcyEAKMiH6goo
        L9PcdqeLQRccO6GVsLKJygVw1ZdBDHlxKDI9f3hkvAj8tKGJ+yczK9JkX6uzkY1w+iIqLlxB8fq7QNBx
        6n3Pwu4s8eArCtoik0sXaWvPxxunkAqCoBlFTYUmBtNlUY5o+Hza+IGWNs1YfT7t1WQxJ36f3W7o7NZ6
        H463ZOcy7cO9mo/BOStOX58g4mhYgdp5DHdXdzDm+V9czfCPN0/eisSTWgJwNvIpYGx5lbJzFlN+4/0g
        6lD5/h3w+m+hf3Ays6gPqwWWLEzOhVQ66B+AfYfSUhpQZCFsDpwsi4iiiiCEz4zTwjJzuWMIgnbvrVbN
        lbdZApPptNGoCvhlzemLJwcbVRdfDitvDQ+T/XT833/Sfyisp+LWhiaemIwsTNpf7GzkZjid6cK5s6n+
        5NdB0tEC3LsNXE7YuSfzAlBSBEsXai36mcTng70HCPQM4/eJ+P0SgYBIICAQCIjIsvZbDojIioCiCCjy
        6PfoJxlESUUUVERRHfstmVRMkoJkUpEkBZNJ+5jN2sdk1rYNdLDqNmi4LDzMN0zLo99nuD3MDftNDU38
        Id2nnxQBcDZyBfBycNtWWsScLzSCOd4bVIWet2DoiLb53u7MttpWlEHDAv2ryKQBVQVVEVBUUFUh7Lfs
        V2h7sY2h5uz3dyAIKmazgsUqY7HIWEe/LVYFmy1gCEQQQYQr7odZZ4UFq64umn/6r/jCn//LGprS62Is
        7QLgbKQUbXLPLADJYmbeV/8GIb8mdkJVge4tMHL8dNi7O2FkJN1Z1EdFOSyeP2kNfarK2JtZVQUURTP8
        uC4qVGh9vpWhY9kvArGQJAWbXcZmDWCzB7DbA9gdZ6gwmG3wkW9BUfgSg2r/SQ7/57+iBMb8Wh4Dzmlo
        Im0DGdLeCPjF1fwjcHVwe+5nP4tUHm+Zbhm6XgP3uPHZzScz0y9eWqzV+dP05ldVre4tB0QCfhG/T8I/
        WmwPFQFdCJBfn4+nzYPflUP13Qn3RMDvk3C7zbgGrfT22unsyKOn24HLZcHrMaEqApJJq35Ma5QAnHLC
        vFUgna5qCrYiiuor6Ht/zANxCeD98eb0lQLSKgDORm4DfhDcnvWRK7EtuSLOxfuh82XwjJvPLyuaAEw1
        DhucvRSk5G+Nogij9XOtru73nzZ23YYeA0EUKKgrwHXYheKbXm9MRRHwek0MDVno67XR2ZFHX6+dkWEz
        siwiSSom0zQUBO8w9LfC3LDhwYhFNdisblyHx2a9XvbF1ez78WbSMhkmbQLgbGQl8Hxwu3D+HEqv+Uzs
        IrTihY6XwNc9cd/QELRN8Vp0ogjLFmuDfBJAUTht8D6tcS5dxh4NwSRgq7QxeHBw2i94JMsibreJgQEr
        XZ0OursduEcFwWxSkaRpcAMEAWoKobAIrOHrFlpmLcJ3bDe+gbGS/y1fXM2ff7yZlH2zp7OCO9bXL5pN
        VN96DwgxRsjJI9D+PPiizMrKxOCNObO0/vc4qCrIAQGfT8LtNuHxmEbf8jrq8GnEXmWn9NzSqb9PGSbg
        F+nrs3HieCF7Pihn/94yWlsKGHJZctM/qSBojc1VFdC3A7yd4/abqL7jHsTwUmlaBgilpQTgbORW4LvB
        7bpP3IFU0RA9gTwC7S9AIEYX39HjUzsc1uEYbfSL/NZWVe1N5PeJ+PzSWJE+09iqbLgODqH4smzK7RQS
        CIgMD5vp7bHT1ZmH221CRcBqlTM/lkEPC+dqIyGDeNohf37YYDnBnE9BTT79u/cEg1Z8cTV7fryZ/amc
        OuUSgLOR2cBPg9slSxdgmf+h6AnGjD9GQ6bHM/Xdf/PmTGj0U1Xw+0U8Hu1N7/NpfezZhCiJVHxoRqaz
        kTXIskBfr43mo0V8sGsGx44U09drywqxjsjMaqgJb/0nMAy9706IallwCUXz60KDvu9spCCV06ejCnA/
        Wuskgigy47pPELV3UY/xg7YA5VSW5Qrytdl8aKcNBIQxo/f7s+NNH4v8+nwsJQnOQjwDUBSB/n4rzcc0
        MTjeXMiQK4vuU0Ge9uKJxPBRGDkRHiaIVN74idBSaj0pVgVSqgI4G1lFyFDf2huuwVx7buTIsluf8cuK
        5rBhKr3ILKxHtuYR8Ev4fFrxfjIb8CYDySoxdDS3xwZMJqoq4HZr1YTeHjuyLGK1yEiZ6lEQRThnqeY/
        IhreTshfEF4VsBZis42E9gpc+sXV/O7Hm+kmCVItAYypj6UwD/vZ6yLHUvxaa3884wdoa5+yGXBer0R7
        TzEjjgq8XomAnFtGH0rB3AJES6ZdPOYGPp9Ee1see/eUc+hgCX29tqkX/NqZ4IizOKnshv73JwTnX3AN
        JtuYLwULKZQCkn5inI1cCHw6uD3rxhsjj/NXZeh8Bfz98Q8qB+DEqfjxUmRw0MKRw8Xs21OOp7CKDDhG
        SjuCJFA4P0OTlXKYIZeF5mNF7NldTtupfPz+KRBRiwVm1+iL6zoE3nEvd1MeM6+/JjTk885GliSTlVSu
        dkx1bGXFmOeuihyr562J3RrROHpi0t7+sizQ1elg355yjhwqYXBAU9CCeSm1oWQV+fMm2bHGNCYQELVS
        wQczaD5axNDQJLYVzJmZwEAzFfremxBqW3wpptMlCBNJlgKSEgBnI/XAjcHtmmuvi9znP7AbhnX67R90
        wan0D/zxeiVaThSwZ/cMWk4W4PWevvGiWcRWkSH/dJOAvdKOIOZ+aSaTqCr09dk4dKCEA/tL6euzpbc9
        2mzS+vsTwds5sUFQsjIrvBRwpbORhH2sJVsCuB+07gdzvgNz/fkTY7hPQb9O770BP+w9kNaW/5ERM81H
        i9i/t5yuLkfElnxruXVaGYxoFrGWT6GfvWlO8BnaF+MZSpjKGckNM+/fOSHIuvDC0MFBi0iiFJCsAFwS
        /FG9fh2I44pLslub2adnXJyiaM4u0jToxzVo4fBBfeptLZl+xmJ0B6Yf32gpcu8H5bS35SHLKdScq5Ic
        s+EfmFgKMOVTdcUloSHXJXrYhK9kdNTfmGdfe8OFEyP1vKWN89fDwSNpWUFmoN/Kgf2lHD5UgktnX6+5
        KMNOPiYBS6EhAJNFICDSdiqfPbvLOdWaTyCQoPnYrKk5QB34YEJQ/vLVoZtXOBu5PJFDJuPO9u7gj6Il
        S8FaEr536DC4dSzWqSpw8Bi0p7akd1+vjfa2PDyexC/FnDf9BMBcMP2uKdtQFIGO9jy6Oh2UlbuprBrG
        bNYxK7OkOLUT+3q1HgFr+ViQUDATe2Ul7o6x9rP7gVf1HjIZARgrc+SNf/srPuh7P/4RZAUOHNacNyaB
        qkJfr532trywRr1EESzTp/4fxKuAyyfglUFWte9gNcg36l0IIKCAPK56ZA25lSZRxRTygrNJYJVULKPf
        0vS7dQmjKFrPUnfXaSGwWGIMYCtKQ4/T0KEwAQAoXX0Zrb97PLh5SSKHS0gAnI3cAeQBIAjY5i4Kj9C/
        M37R3+2BfQeS8nSrqgI93TY62vPw+VKfxySas3vgzNCQwuCgTP+AzMCgwsCAzOCAtj3oknG7Fe3jUXGP
        KIy4g28hrW1jMm1UFMA2JgiaKDhMKg4z5JtV8kwqeWbIM6s4zCr5ZpUsv91Jo6rQ3WWnp9tOSambquph
        rNYIQqBjpmlchpuh9IKwXjf73KWhMaqdjSxqaELXyrmJlgBuDv4oWrQEc2GIogWGNXWKRXsnHG6G0y6O
        dKEoAt1dmseYdA7UyHQPgMsl09UdoKMzQFfX6Kdb++7rk5HlxHpF9F5NOq5aVcEdEHCP/ZWnjxrt+FYJ
        iqwqxVaFIotKsVUd3da+c10gVJWxocYlJR4qqkZwOEK8NsUb+afrJAFwt4Fj9liQlD8Da3EJ3v6+YND9
        wFf1HC5RARgrXoxTHdS+DxDUKPWgoSE4cjzhOf5+vzhWxJInYZiu4p98bzqqCj09AVpa/bS0+mhp8dPa
        6qej04/XOzkGnizpPH6kY/lk6BoR6BqRIkbMM6uU21Vm2FXKbQrldpVyuxJWNckV+vps9PXZKCjwUVE1
        TGFxIH1rSbhPhgkAQNF5F9D58tgaGrqrAYkKwFjlw1xVNxYoj7g5+sst1F9TjskR8m8NDcHJNq2un0Af
        /8iwme4uO72TPEY73QIgK3DihI+jR70cP+6jpdVP6yk/Xk/k86TryibbcJOPqCaUbMQPJ/wCJwYFQjuo
        Ciwq5TaVSodKdb5CdZ5WpcgFXC4LLpcFR4HCvItFJElJSQdUFQIDHZjLwsMd9QuBMQFYqvd4ugXA2cga
        Rv8VQZKwVc8c29f77i6Gjg+x/zE3NRcVUVrhRejsgQH9b3xZFujt0epRbnea1tqLd86R1GYc9vQEOHJU
        M/jDRzSj9/v1P5jTxXAnO/9DPoEhn0DzIAQnsBZYVGryVKryFGryVSodSlZXITxezZ8EiJgkFcmkJObK
        TNW6If0BEVX1YAq4EUynqxSmsjCfAroHuCRiaadb/2fXIoasgtv7ntY/GXDLnHillzazQlm5TFGxGbvd
        H1XxPB4TrkELgwNWXC7zlM/I8g0mNviof0Bm314P+/a52bffQ1/fRAFJ9Ap0xdd90Owy3Mk8/pBP4KBP
        4GCfZvWiADV5CrWFCnMKVarzFLJ1kGdAFgjIEgLawiuSqHk+FkJWY1JH14JQFM0T1fgVnRR3N1JBSDuA
        owTRZAq6EBecjVzT0MQz8fKSiABcHPxhLjg9ljngGmJk3Aw+v1+bWNHelocoqdhsAcxmBUlSkEdVzOM2
        ZdzRhn8wtlttj0fB6fSyb5+bvfs8nDp1Or6AjoffMNzJO9a4QBVoHRZpHRZ5qw3MIswu0AShrlChzJbh
        KoMaOUiWhaTatxSfK9yZhyCSXz+PwUNjjf+XQHoFYKzPz1RaORboOnA0Zv1ekQVGhrNzcIqnwzMhrL9f
        ZufOEXbscLPf6SEQOH1tE0symTdcs8VCUUkxxcXFFJYUU1hYQF5+PmaLhbw8BxaLFZPZhNVqRYrTeS+I
        EqqiACoqAn6vD1mWGRkZwe8P4HF7GBly4RocYsjlwjUwwMDAAAN9/brymu4bFMsFa0CBYwMCxwYkXkei
        2Koyr1hhfrFWZZjqV0+6HVyp/okL5lgrK+G0AKzSc5xEBGBsyJ+UXzQWOHxcx6i/LCUwEsA34MMjSGzb
        Nsy2bSMcPuwJ+7PS8aAkcwyr1UpN7WxmzppJRVUlRSXFFBUXkZefR16eA5vNhtVqQTJNTXtJLFRVxe/3
        43F7NJEYHsHlcjHQP0B3Zxed7e20tZyio61t9H5M7ts40v0e8Aq83yHxfodEnlllQYnCohJNDKbkHsnp
        bXBWAxNfXuaSsAFC9XqOk8jT4wj+kPJOD2hwt06x7/40IatwqE/kTz/s5MCJQESFnuy3RHlFOXMXLGBW
        7WyqaqopKS2moLAQR54diyV3xvQLgoDFYsFisVAYYwVlRVHwuj0Mj4ww0D9Id2cn7a2nONHczLFDR/B5
        PAmcNYl8jn6P+AV2dUrs6pQosqosKVNYXKZQaJlEMVAhMBTAlJ8mwZYnDrgzFRWHburyF59IbsaeSKng
        9Im8Xb1pvEuTT59HYGeXxJ5uCY8MoI1kScTYE4kriiJz6uuYv3gRM2fPpqKygpKyYvIL8jFlwdt7KhFF
        EXueA3ueg/IZ5cxbMDdkr4rH7cU1OEhvTy8dp9o5duQIh/btZ6C3L+lzjmd8NW7QJ/B2m8TbbRJ1hQrL
        ZijUF6bWVRcNb483bQKgqhEaoMOfJ10nSiQ3Y7dEDHk7BYYztHhngjQPimxvl2gePN1XlMp/HCmtyWxi
        4ZLFNCxdwpx5dcyomEFBYQFSCsuMnTkI2Ow2bHYbMyorWLSkgTXrLgPA6/XS19PHqZMtHDt8mH27PqCr
        vT210004u8rxQYHjgxKFFpHlFQpLy9PbtejucJM3Jy89B4sw6E4wh/X+pV0AJqB4vagJDuudSlTgQK/I
        220mut2ayaazYSq/oIAVqy6g4awlzK6rpaS4GFHK4s7oHMVqtVJVU0VVTRUrVp3Pxz5+O263m672To4d
        PswH29/j0H5n2s436BN4o0XinTaJ5RUKyyvktIxGHGmd5Jdl+LoWup7qlARAVbJ3NNaBPpGtp0z0ekYN
        P87t0NMwJYoiZ593LitWraR+/lxKSksQcmLpmemH3W6ntn4OtfVzuPTKtfi8XlpPtrJ/127eeu01XAOD
        KZ/DJ8O2NpFdnSLLK2TOrUytRODucCOPyEiONKhJpGH3Sli1QFerY1ICoGZiyW6dtA4JvN5ion04+MZP
        TaQkUeT8D13ERasvYc7cOVis08+L0HTAYrVSP38u9fPn8uGbrqeno5vd773Pa888x5ArNTHwyfBuu8Se
        HolVVTJLypXkCo0quI66KD6rOOXrVSMIgBLuUFdX0TwRAQgw2hAoD2n+/QUxe4q7IwGt2LavR8tTqu/l
        mlmzuObmG2hYuhibLTcchwoIIAijsxwFRFEaK/oI41ZpDvvvVBV1XDeI9oCpIftUVEVFUZWpXbUpCURB
        ZEZVBWs/8mGuuPpKTh5v4dVnn2XnO++m9Fy4/fDaSYn9PSKX1srMsCd+H/r39adFAARxoumqXnfopi6X
        XIkIwAhBAXBpY/xDhwNnkgO9Iq+cNOEJxDf8ePuXLj+H62+9iepZM7OmeC8IIqJkQpBERNGEIEqIooQg
        SgiiqH0EaUrzq6qK9lFGP6qCqsgoigyKgqLIKHJgbF/G7p0oUVs/h09//j5u/PidvPbcC7zx3HMo40qx
        UZaEjRjaOQK/OyBxXqXC+VWJDTn29ngZaR3BMdOhP1HEC5touoHB/tDNHj2HSUQABoFiAHno9CQfyWFH
        HnEncJj04ZPhpeOmsfHguufDR4i4YPFibv7UnVTP1LlgQ7oRBCTJgmgyIUpmJElClMwIkilrhCg8u6JW
        qtBRCFRVVRMHOYCiBDRhkAPIcgBF9uvyHZsOCosKuf62m7ni6vU887vf887rr8e/zqgXBe+1i5wcFLiq
        XqEggTEE3du7qZ1Zm9K1COLEdgRfZ1jPiC6X3IkIwHGgFiAwcFpczAX5GRGAXo/A00dM9HmFlPpsHXn5
        3PWFDSxaunjKDE2UTEgmC6LJPPptQhSn75gAQRAQJBOiFPkaVUXWxCDg00Qi4EMO+CdUS9JFfmEBt959
        F6uvvJLH/vOH9HTG9ksZ66noGhH4nVNiXb3M7AJ9+XWfcjN8cpi82cl3CQrSxLYod2vYqNwteo6TyFO3
        BVgN4DnVPBZoKS3C05GaY89EOekSefqoCZ+cWiPfuo/exLqr12JPh6eWaAgCJrMVyWxBMmnf4+vjZzqC
        KGESJQjvx9ZKC34fgYAPJeBHDvjS2gBdPXsm32z6Lk//dhNvvvRSnExGD/Ip8NxRiTWzFRaV6stfxxsd
        1N9Wj2BK7qUjmMOfWVX24+4IKwE8rec4iQjAH4EHANwdLaj+AILZhHVGKexP6hqS4uiAyDNHJRQ19oSO
        eLf1vgf+noazFkUcUpkSowZvstiQzFYkk1lHbgwiIYomRKsJk/V0fTkoCnLAR8DnQ5G9KbVJmsxmPvqJ
        O6mdP4/fPvxw0sdRVHjthIiswJLy+CLgH/TT9W4XFRcnuErQWMbDBUDubw8VR7mhiSO6DqP3fA1NvONs
        RAYkVZHxtrdjmz0LW3WSF5AEJwYFnj0qoar6TCpanG99/wdUzazWVi1OGRXJbMVktmlGb7Kkz/WTwQRC
        RcGap7UvyH4fcsBDwOdFCSQuCIIgsOKiC7HbHTz24A9C9iSuLFtaBMyiwILS+Gn7dvfhmOkgf07izkJF
        S7iHYV9H2KIhusdOJ1oWHZv542nWHIDaZ1UleIjk6PMIPHfMNGb8ej4wMfDrTf+qGT9oKxcngYCAyWLD
        VlBCQdks8oorseYVIZmthvFPMYIgYLJYsTqKyCuu0P6PkkqseYWaGCdgxIuXn80d99+PgDr60f+shX7e
        OCnSOaLjOVCh7eU2fP2Jr4olWovCtof27w3d1FX/h8QFYOzAI0f2AOCYVY1ontz5/rICzxyT8CuafSX0
        4fTnzvu+yOy6kNbXBLqnNKO3Yy8sI798Jo6iGVhs+Vk1FsIArTfFZNEEoaSSgvJZ2AvLMNvydP1Xy1et
        5LJrJ66wlYgAqCq80iyix+Wk4lVoebqFwFACQ+pFCcF8utSgBjz0f7ArNEZcRyBjh0rw9v4h+GOo2Ulg
        aBhBknDUzUrwMInxbrtEvye6okb+I9SwT8PZy1m5OmQZJV3Gr2Ky2EKMvhyz1ZGV3XIGkREEEbPVgb2g
        lIKymeSVVGF1FEbtkQC48saPMnNObdiLJNJDFuvFM+yH99r0mZff5efkH0/qFgHRFj7T13fqSGj939PQ
        xH/rvT8JCUBDE79ltH6hKgrD+zVfgEVnLUz6D4rHkA92dQoTDDr0Q8RP+P919zf+GjW0OBhDAETJhDWv
        mIIy7U1vGP30QTKZseYVkV9aTX5plVZ1GycGkmTitg336atiRiC439kjMKSzdO8b9HHiqRN4e+I3SkuO
        yrBt1863Qzd1F/8hudWBx04wtFP7OZkCsKNTTKjeP/4PEoDb7/sSpvGz9MbV/wUBzFY7juIK8kursToK
        Ig62MJg+iJIZq6OQvNLq0f+8cGy57YqaGi68Yp2u0mWkF5KANoR6f7f+F4ff5efEH07gOuqKGU/KOy0A
        imeAnvfeC92tq/tv7B4kcd8eCv4YOnkET+sprDPKcNTOTOJQsVFUONInJt0YIwCSJHH+mjUTDz5aAhBE
        cfSNMBN7YTkmszHZ50xEK/UVkV9ag6O4ArMtj8uvuy6KketsgAaO9idWclT8CqeeP0X7q+0ovghz/kUz
        ov2066+R/dtD52acJMQ+dV13ojeqoYlngTeC2653tIVIS1eek6a/4jSdI4LmtUdnvSvS58a7741Q3FcQ
        JRP2glLyS2uwOgqNxjyDMUxmK/aCUmrmL2XxuecDCbx0xj1/7gAMJDHUZMA5wNH/O8qgczBsYq9UMBtG
        B5Kpsp/OF58LTbaloYmEuhSSfepfC/7o2/0Wvp5eyladg5jmqbLdI0LC9a7xxbTzV18aFs9kdeAo1up/
        ZlueUbc3iIogCKy+9qNRGwEjvpAiRIvVgB0L2S3T9mobx544xsDBAVRFRSqqG9vvPrAN/9BQaJKE3v6Q
        vEOQh4D7gApVkRnY8jwzPnoH5RevoPPVt9L2B4wEEhvqO/42L15+PkFvXCaLA0thJSZrHvgGEl6gNBG8
        Hg97d+7g2MGD9PX0oqoKhcXF1M6dy7IV55FfWJj6SaYhqqpy9MABdm3fRktzM4P9/UgmE6Xl5cxfvJgV
        F15ESVlZ6idKgCUXXExZZTW9HW0JpQt9Fj0pPmq+Xh/tL7fTv9fL4kat/q/KXtr/8lRotD82NLE50WMn
        JQANTbQ7G3kUaATo27GFwguvoGLth+jesh3Fn44RdqAoqQ2iXX/HJ5AsDqyFVZrhB0n38N9RPG43z/7+
        97z67DN4o3i4lSSJVWsu5YaPf5yikpIEzzB9Obh3L5t+/j+cPHZswr7mQ4d4/623+N1jj3HhZZdx0yc+
        SUFRURJnSRxRFLjqjs/y+IP/HCdm9DUi0uUGvXTleWO/e19+Ab8rrLEw4bc/JF8FCJ6wF7Quwd4Xfo+5
        MJ/y1Rek5WIBbKYkR2ONFsdmLzyHvBnzwo1flZMeARiLluZmvvP1r/HcH56MavwAsiyz9dVX+IevfoW9
        O3akPR+5yF+eeIL/+PbfRzT+UBRFYesrr/Cdr3+NowcPTln+6hYvjdvyH6sh0JaGiZ6S3Ub5h7T2CF9X
        F71vPR+6+5GGJp5P5rhJC0BDEy0qwl8FL3/g0B6GPthF1fo1mPLT4/m0xEZCgy9C62FVs+ZgL66ceNBJ
        ePu3NDfz/b/7O3o6O3WnGRka4r82NrF7+/a05yeX+PNvf8uffvubhKb+Dvb388Pv/CPHj+ia75IyFdU1
        FJSU6Wr0i/QpS9H3B0DF5Rch2TXPVN3PPI4sK6Hyk9TbH1IrAbC4SX1MRXgnmJGO5x5HVRRm3nBVWm58
        ZZ6KSGRVHc/4P+aKj308ckQl8XHXsfC43Tz0L/+Cx524x1dZlnn0B/9Bd0duLq6SKnt37ODpJzYlldbj
        dvPwv30fr3dyFxMBEAWF1TfcHrW/L1ZptMgKeSmOlLeUFFGxVluac+Cdtxg4sj/U+O9c3KTuTPraUr05
        KuL3VERURLwuFz1/eYLSledQuHh+qofGZoJZhcHilb7BF8HPkpWrIx80zSWA5558ku7O5A3Y6/HwxGOP
        pTVPuYCiKPz20UdTOkZPZycvPPXHKcitysJzV8YdcBbpM78k9fr/zBvXI5rN+Hp6aH/pSYL2piK+saRJ
        +U0qx05ZAJY2BZ5SEb4VNL3uPe8x8O5b1H78Bkx5qZd9zq5QEh58YTKZKa6KMD9BCSQ0ASgeXq+HV575
        S8rH2fnuO3ScOpXycXKJD957j872xFrWI/Hqs88gy+lv0xlPxaxaJFGK8+yFD0e3mVQWpNhpUXzuUoqX
        L0ENBGj/3c8JeL2hr7qNqV5XWka/qIgPqYjHgsrU+tzvkQf6qbvr5pQH2FTlQV1RHAEYV+e65PpbEIQI
        w3iV9L799+3YGbPBLxHefzt93ae5wM5330nLcYZdLo44J98jjc1qZuX66xNqCFxRDaYUHn9zcSGzb/0I
        AJ1/eoLB1pbQt/+dZzX5n0v+6BppEYBlTV6XivD54G2QAzInfvMItopSaq5bm/LxL5qlYg861tEx+GLl
        lddHPpCc3vr/sUOHsvJYucCJNDbgHT9ydPIzrPhZse5a3Y2AdSVQV5z86QRJov4zt2DKc9D76gt07nw3
        VGp+vazJm1LRP0jaxr+e3eR5TkG8XUFEQcQ9NMzxXz1EyfnLKL8kta5BmwnW1SuYxPgNgZIoUjN/SeQI
        aS4BDPSlb2HU/h5dXpynDYMDA2k7Vjr/h1hU1y3Qln6L0wg4wwGrUpwaU3vn9eTVz6Z/62ZOvvo8QbtS
        EDsVxG+m65rSOgB+edPI4yri/cFiylB3Lyf/97+pWr+akvPPTunYZXZYV6eOiUCkhkFQWXnVdYhShGZX
        2Zv2BS3S6bVWyeLVliaDdA7BFqdo1qbNbuH8q66P2QhYkQdr5pDQWgHjqbluHaUXnEP/1s00P//n0GI/
        KuKNy5tG0rYyatpnwJzbNPRTBfH7QcXqb+/k2C8eouaay1IWgap8lavmKqMDhCK3C6z+6J2RE09C/386
        R6MVl+pazn3akM7rnbJ7J3u56Lo7ozYCzi7SjN+cgh5VXrmayisvofvFZzn63NMoqhD69l93btPQ1nRe
        0qRMgTuvafCvVaRHVSRUJFzdAxz82U+ouORcZly6KqVjz3DARxaolDsm1rvMVgvVU1T8B6idOy+Nx5qb
        9vxlM3MXLkrbseoXLpiaTKsKlXPmY7Vaw0qekqCyvAoumg1JLw4tCNRcv46q9as5tenXHN+8maD9jH7W
        ndc0+HK6L2nS5sCe39T3OQXxe2NtAsMenL96jPyaQmbe9OGUegfyzLB+nsrZFVpRK6jCV91xT8Q101AC
        2ifNLFuxApMpPQt6nLvqwrTnL5tZcdFFaTlOWUUFdfOnSAAASVRZ+4n7xl46JXZYN09gYXnyxxRMJuo+
        eSPFZy/iyKMP0brHGfrWR0Fcd35TX9qNHyZRAABWNvU8oCLeE6y/BGSVg88+j7ftEPV335zSkGFRgLMr
        Va6er1KRpwnABR/+WOTI8uSMFnPk53PxFVekfJyFS5cyu75+UvKYrSxcupS5C1P3JLXu2uumdkq37GXF
        VTdhkWB5lcDauQJFKawday4uZMGXPo0QGGLvIw/R194TWt8/qiKev7KpZ1KMH2DSW08e3Tyy47OrC/er
        iLcEL8zV3cdQ8xHmrL+UwIgfX1/yLcJ2E8wrgVlz59Fw3f2RI/kH0zoAKJT6BQt485VX8PuS62KUJIn7
        vvnXSc0MPHXiBIf278Nmd2B3pGHAeQJ4vR52vvsObSdbKK+oQEqiJFQ7dy5bX3k56cbUuvnz+cSG+6bW
        mYsqYymopLztNYrlrpS8wBcuWcCcW6+h/dXnOb5tJ7JMqPE/oiLeeGFT5/HJvJwpaT792eahvXevLtyq
        IpyvIsxQEfD7FboOHaWgzErZirMZPtGOKidvpGd9+rtYKyLUo5UA+GP7WEPWVrQliQfJarMxZ948tm3e
        nNSD/PENG1h23vkJp3vlL3/hv763kfe2buX1555j7qIGyisrdafv7uzg6U2b2PrqK6iKSk2t/sUqvV4P
        Td/8Jm88/zzvvbWV3du3c+GllyVcHSoqKaGkrJxd295N+PqLS0v5yt9/G0d+AotqBPwo/X0o/X2ogwPg
        84EkISQqXpIFR0UdvduTG4YsWq3MunEdZofKgb88j6vXNX5I0Z0XN7Vt/NlmvS5Fk2dK3eFsbpxlBu4H
        fjg+E9UzSxCx07c3ccETTWbO/t77CFKE5cr9LvCHeE1RVeSWE8jNR1C6OlAG+k87BxElxIJCxBkVSHVz
        kWrrGfMoEoe9O3fy6H/8OyPDw7riS5LEHZ+7l9VXXpnw9bpHRvjW5+4JG4V41ooVfOlv/05X+sH+fv7x
        a19laHBwLOyOz93LZR/+sK70b732Ko/96EdhYeuuu45b7vpMwtcCsG3LFn71k5/ontgzq66Oz3/rbyir
        iL8qlTrkInBwP/Kxwyh9vRG7goWCIqQ59ZgWLUYs1VGZNznAlMeuBy5A8SU2CazknEU4ZhVzfPsHeL0T
        /Ga8CPzb6qaWF5K6kUkwpW5vf755UPn55sF37lpdskNFrFYR64JFnkGXF9fQMCWVVqw2K75h/eJXvf4L
        5C+I0qjkGyDorEE+egjvC08T2LcbpbsL1T2ivfmDqCqq14PS24N89DAB5x4EkwmxvIJ4Zb2KqipWrl5D
        f28P7S0tMeMuXLqU+//6Wyw77zySYfubW3hva3hvUFFxie72iKc3Pc7+3eGrRx8/cpgrPnItoo5SUHtL
        C++//fa49Ee4ZN2V2OyJL7Q6s7aWC1ZfwmB/P20x7l1+YSHX3norn/r8F+J7VZJl/Nu24n31BZRTLaju
        GCtY+7wone0E9u9BGehHqp4Vu1SgKmApwGTPY3D/G+ghf3Y5JcvraW9ppf3oKQKyGlrcl1XEj69pOvmt
        n28enJo5zqNk1CHeq41zbwP+EZjQJ1Rm8WJFYLgrEHcAz9n/tBUpP8Ksi4AbfP2gqvg2v0LgwL6k8inV
        1mFdezXoLCp2d3Tw/ttvcfTgQfrHXIKVUDt3LstXrky5we9/H3mYN54P9/9w+z33cPnV18RN23Gqle9+
        85sR5zBcfs013P7Ze+Iew+vx8O2vfJm+7u6w8Dvu+RyXXX11Stc20NfHB++9R8vxZoYGBzWXYGXlzGto
        oGHZMkw6VqFSvR68z/4RpUu/f4ZQhPwCbB+5EaEwxjgPWzmKz82uB2KPci2ozkeqLKHlZD9y5CrufwEP
        Xd50dC8ZIKOL0l/edPTxlxvnP4VWLbiPECHo8mlvEnuJn2J1BGVExeedWGApWrw6svEDBLTiuO+tzUkb
        P4B8ohnvK89hvepaXfHLKyu56qM3TNp9G294AA3LlsVN19bSwoP/+A9RJzC9+swzjAwNcee992KzR29U
        tNpsXHvLrfzqoZ+EhTcfPpzytRWVlHDJunUpHcP36gtJGz9o1Qbv83/G9rE7INooQ9mLaCukbOUN9Lz7
        VNgus1XGWlHAoGDjxKAfmvtH94SVrn4FPLS26XBGZ4FlVAAA1jYd9gIPvtS46CE0IbgFuDi4f0SRGMEG
        dijIc1OgulE9Kl639sfUfORrkQ8se0Dxo/T3Eti7K+V8ysePIbeeRJo5O9O3DEGYWExvbz1F9azIeVMU
        hTdeeIEnf/nLuPXsd954g4P79nH97bdz4ZpLxxbKGE/17InTrUdG9LV/TCZKRxvyydQbzpX+PgJHDmFa
        0BA5guwBcz5VV95P77ansNplVLvEiKWIXrcALtD8eYfdv2PA88BD65oO7CYLyLgABFnXdMALPAg8+ELj
        4qvRxOAaQu7ggJLHAHlgBavNz4yiAmw1UUb+jTb8ySea05ZH+URzVgjAzDm17N6+LSzsZw/+gEvXr2fV
        mkupnFkDquYwY8+OHWx+4YWE5t73dXfzix//mD/8+tdccMklLFi8hPLKSkRRZKC/j707drLlpZcmpMtL
        pEV+kpDb0udXQWlrhWgCoPi1LsHyOQQaLqCr7QjIQOSmhmfRXOk/dFXT/jhdUlNLVjvFf7Zx2Qw0IbgU
        mNDCteKWf6BiSYTpxrIXvNoMMf977+B/P/FupkiYFi3Bsib16c2p0t7ayj985cspT0aqqa3l0vUf5vGf
        PZqWyUhf+tu/46wVKzJ6b/w7t+Pflp5StalhKZbVMRpWLUVgctDXvJ13fjGhJPoW2jJ6D13d9EFsb6cZ
        JGtKAJG4uumDLuA7AH9+YEU1sAH4NmizyWYsuiRywsDpbj+xNH1+5MWyFMZ7ppGqmTNZe+21vPTnPyd9
        jIVLl3LvN75JQWEhldXVPPbjH9Hfm/y02iXnLGfpuedm+tYgVdWQHqf0IFbVxI4ge8DkoLj2XFRTPrJ/
        bL7JDddtfH8qfJWlfo2ZzoBertv4fpuMeb6MGRkzdatuQpAirESkBMIcf0hz6mO35upEsNmRohUHM8DH
        PvmppMbTm81mrr3lVr72D/9IwWhX2uJzzuHv/+MHrFm/HknnuIdQ5i5axL3f+EZWrLIkVtWkpZomFpdi
        mhdnjoHsA1QEUWLBpZ8k+GzKmJMbEJEBcmr525tX1z+oIBUpSFxw0zcx2yP0BfuHtPpZEEFEqqpGPnpI
        G/GXDCYT1is/glicPVN2BVHkvIsupqCwiObDh/F5Y892tDscXLJ2LZ/7q2+wfOXKCcZqsVo5+7zzuejy
        KzCZTfR2d+MZiT3IpaCwkGtuvplP3Hc/1jQvC5cK0uw5KK0ntXEeydzb/AJsV38UwaZjTINoBtFEftlM
        nFv/hIKEglR/6+raH2/acmLyXRanSOYlWyePP3D5vcDDAI6icq792iMRsq+CuzPiuH91oB/vK8+hdHcl
        dF6xqATL2vWIZTMyfQuiEggE2LdzBwf27KWluZnhIReSJFFYXEL17FksXLKUhUuXYknASFVVpb21hWMH
        D9HWcpL+3l58Xh95+fnMqK5i3qIG5jU0JFVimKKbgu/dNwns3xM+2CsOpvkLMV98KYJV5wwfUx5YtBfR
        S4/8Fb2nxtyTNd628dWUnXZONjkjAP/7wJV/Bq4FuOijG6g/N0JfsewBb1/0g6gqgSOHkJ17kNtaY55P
        rKjC1LBU6wYyVg7OWdTBAQIH9iE3H0Xpj9zGkfBQ4LDEEti1IcmnDrzNa7/59+Celz6+8cXEx3lPMTkj
        AL984Oo+oBjgtr/+KRZHhHq9t0/31F/V69GGA/f3ofo0d2GC1YZQUIhYUamv+GeQU6h+H+rAAKrXc/r/
        LizU/7aPhr0CBAnZ7+b/vnt36J7CT218Nqu6/caT1b0AQR574LrPKKPGXzyjJrLxoybk9kuw2rTGoizo
        1zeYGgSzBaF8Eqpyih8kCclsp6p+GaeOjbkpvx/410xfdyxyomwrI10tIyEjsXhVlFKV7CXSCq0GBpNO
        iLepRSvXEnxWZaQ1mc5aPHKiBKAgjXX4z1p4TuRIk7Tkt4FBXEJ6narqFqOc7ly7JKnjTSFZXwJ4+IFb
        axWkagVJc8RQEGVgjyEABplCPV0CsNgLsTgKg92BRQ8/cGtqi2JMMlkvAMCYo7+5i8+BCBNhUGXtY2CQ
        CcY9ewuWhXl4ui7T2YtFLgjAWDGqvmF55BhpXvLbwCAh1OCCoBpzFoatf5HV1YBcEIDlwR9lVVFa7JV0
        jf42MEiSkMFnxeVVoXvStwDCJJALAjB2Nx0FUTznToLPfwODhAiZmWnLCxuinh0zyKKQ1QLw8AO3ioAD
        tNl/JmuUwTmGABhknNMCIJqsmC1jw64tDz9wa+YdJUQhqwUAGJt+V1xWQdSBi0YDoEGWUVwe5qJ9cabz
        E41sF4C64I+CaDPxDOM3yAbGza4sLA7rrs7ahR+zXQDGWv3yCqPU/ydpxR8Dg8QIN6X8orDndU6mc6cv
        19nHWKXfZIrmDtoY/muQBYwrAYzzt5C1k+6yXQDik6JfPAODlBFExtu4HAhrmM7aYarZLgA9wR8edxSX
        01nghsrgDEeY6BRFlsPGpmStZ6BsF4Ax9z2ekaEoUQwBMMgwwsQ5df3dYQuTHMh0FqOR7QKwJfij/WQU
        z8pCtl+CwbRHnCgAnadOhG6+k+ksRs16pjMQiw0bNw0BAQC/z4siRxjyK2SpTzqDMwcxvIFakX0E/GPz
        U/wbNm5KzjvpVGQ90xnQwZiTP587inclQwQMMsm4Zek9QwOhm4l5oZ1ickEAxhb262k/ETnGuD/AwGDK
        EM2Mb4fqbA2rrm5L5HBTnv1MZ0AHY+0AB3dFWeJLNATAIENIEx2KOt9/M3Rzi+5jZYBcEIBfBn8c3vNe
        5HYAKXsWpTA4wxgnAHLAw4nD+0ODHsl0FmOR9QKwYeOmY8BW0Bar6Dx5aGIkQTKqAQZTz+iqQKG0HtoT
        uvnyho2bBjOdzZiXkOkM6GRz8Mc7Lz0VOYbJkek8GpxpmMZPT1d58/nfhQa8mOksxiNXBOAhQAHoaGlm
        qLd9YgzJHrE/1sBgchC0Zy6E7pbDuE6vPtSK9txmNTkhABs2bjoO/Ca4/fqffhU5orkg01k1OFMw2cMH
        oakKLz/5WGiM32d78R9yRABGGVPT1uZDdLdEaAuQbBNU2cAg/QhgDnfyc3z/ewz0jnX5+8iBtz/kkABs
        2LjpTeA/g9vPP/4IaiRnoJbCiGOzDQzShskeNvgs4B3hpSd/Hhrj7zZs3OTMdDb1kDMCMMpDaOrKsGuA
        d1743cQYggi2EmOOgMHkIIjjqpoqLz3xSOj036PkyNsfckwARlX1U8Ht3W+/SnvzvokRBRNYSzBmChqk
        HXNB2Mtl/7svc+Jw2DP4V6NzWHKCnBIAgA0bNz0O/CK4/fSvfoRnKMK676LFEAGD9CLZwrqbu1sPs/mZ
        TaEx/mbDxk1PZTqbiZBzAjDKt4EBAEWWeeKh7xLwuSfGkqyGCBikB9EE1uKxzZGBLp76n38PjbF1w8ZN
        /5LpbCZ8WZnOQDKMdgveEtx2D7t48uHvIgciOF6RrGArNTwHGSSPIIG1lOCLxDPUy+P/9R0UecwjtR+4
        J9PZTIacnUf79Ja9R69bvXQ3cBtoLsNaDu9l4TkrEccPCBIkrfgm+xgdT2RgoA9BAlvZWKu/29XDEw/9
        Mz5PWIlz3YaNm7ZnOqvJkLMCAPD0lr3O61Yv3QvcCjDiGuDY3vdYtPxCxPFehAVR675RA8ZaAgb6GGf8
        rp42Nv3kn8Yb/1UbNm56JdNZTZacFgCAp7fs3Xfd6qUngI+CVhJw7tjCgmUrMFvzwiMLwuj4bcFYUdgg
        NqI5zPjbm/fx5H//C7Ic5u33qg0bN2X9eP9YTJuK8cMP3Hoz8ERwWxRFrv3Ul6mqWxI5geIHX7+xrqDB
        REx2sBShmYfKB1uf460X/jA+1pUbNm56KdNZTZWcLwEEGS0J7ARuB23q8IGdbyOoAarrFk1sBBSk0106
        RmnAAABBG0lqLgQE5ICHF3/zE/ZseyM0Ur+iqOvu+94Tb2gJIn5yhpzKrJ5reehbt1wuisKTQFFwx4ya
        Wq75xJewOooip1QC4B8EOWvXbzCYbEQTWIrHHHz2th3jT794MKy+r8LLbo//nq/94A8nSG1JqqxZzSaX
        BSBq3n/8zY/NMZukfwduCoaJosi6j91N3dILoieVPeB3GdWCMw1THlgKAAFF9rPtpd+z663wdj1VVf/2
        vu898b04R0qHYU+pOEw3AQgLe+hvbrlLFISfhYZVza5n3S2fw1FYHv3Isht8Q1qPgcH0Jeytr9LevJ8X
        Nv03npGwVahUf0C+/Yvf//2Twe0IR9JrtHriGQKQRL6jisGPvvGxq81m6UEB5oXuPPvCyzn/ihswWWJM
        H5Y94B/SGgwNpg+CAKb8sSm9g92tvP6nX9N24khYNFlR/m9gyPMfD/zX0x+MBo03zkS3I5FRUcgVAdBt
        8ON+CwD33niR45wFMzeYJDFsqKYgCFxw+Uc4a9U6TNYYLsUUHwRGIOAhi6pvBslgsmuNfIKIq+cUW597
        guOH9oZFUWFwxO374tcffOp3p4NCd0f8Rud2tDA9+/TsT4hcEIB4xh9q7EKEsLF4//aVj16WZ7PcK4rC
        jeNPsvzitSy7aB32grLoOVFVkEcg4DZKBbmGZAVzASoinScP8vYLf6CjtXlCNK8/8INjrT2P/uA3rwcX
        oQg19EhGHyss2rbeOMmEJ0S2C0As4x9v8NGMf0L3zPe/fP31+XbrV0RRWDX+hBUz57Bq7UepqmtAiOVj
        UJU1IZA9hhhkM5IVzPl4PW4O7tzK9teewe+b2NvjD8i/ae8Z/J9//p8Xg0N6VSYafaS3fzRDTkQQUik1
        pCQE2SoAsYr40Yw+kW0Aoenz115bXGC7WxLFK8afTJQkll+0lvlnr6KovAZBjDFkQlW0LkTZo1UXVGO+
        QcaRbHh8Mh0tx9ix5QU6W49HiiV7fYEnW7sGfv4vv3x5G9ENXI0SBsmVCmIZfKx4scKTEoJcEYB4b3Uh
        zidWGv7fZ6+6tKKk4DMWs7QeGDeJQBODsy5Yw6LlF1M0owZRmhAlHCWgCYHs00oHRm/ClCDLMv39Lvp7
        e/jg3dejGT0BWdnr9QVe33mw9Re/fGZbMFI8I9dbIoj0nc7fscJihUckFwUg1IjFceFiSHhomvHxIv6+
        dd3y6pVL59xlt5rXmCTx3GiZm1W/kIZzL6aqbiGOgtL47sdUdVQI/KPiEBidlGSUFFJBVVV6uzro6min
        s+0Uxw58gNcddSHegNcfeLW7f/iJ7zz6/DPBQ5CY4ccz+vFGG8+g9ZQKUm1biEkuC8D4z3jj11siINL3
        Nz5x+cWzKopvspillZIoziMKoihSu2Apcxcvp2LWXPKLyxFNOpcqU1WtLWHCRxn9yIZIhOD1uOlqa6W9
        9SS93Z20nzyOxz0cK0nA6wu8Nuzxbdv04o5f7TjYGnTVFe0trkcA4PSccj0iQJR90dKTwO9I29HCIpIL
        AhCp4S+S8Uf6rUcEiBAeGsaXbl29or6m7FarxXSBSRIXxMt8fmExcxaeRfWcBZRWzCS/uByTxZa8o9JQ
        MQgVCJQIYbmPosgM9vXR19NJT2c7PZ0d9HV3MtjfGzdtQFYO+fyy0zXi2b7xsZd+7fb6g3O/IxljLONX
        dMQlgW+ILxCJhJFE2ARyQQBCt+OVABIRAL09CGH5mT+r3Pbpa1feUeiwrrRYTBeIgjBD70WVV8+ievY8
        yqtnUzKjGkdBMRZbHpLZGruRMRHCxEGNIBYKoE78PcX4fV5cA/0MDQ7gGujHNdDHQF8vA309DPb1oij6
        fDYEZOWIx+ffPjjk2X24pXvb/z733uHgnQi9KxDzba0S2eDj1fnH3zi9XYWJ7ov1O9J2tLAJZKsAjM9b
        vFJApBJAPCGA+EIwPnzCPVtz7rzSdRcsvKYgz3a+1SKdK4pijRChITEeFpudqll1FJVVUFhcTl5RCY78
        ImyOfEwWKyazBUkyI0gmRFGaBLfnqiYYY8IR8hsYe9aD22q4vciBAH6/j4DPi8/rxed14/d68XpGcI8M
        MzI0yMiQC1d/L4P9vYwMJb5ojqqqAz6/vGvY43u/3+V2vrnr2PYtu472ob9onWhDn6IjfazzJbovmd+R
        tqOFTSCbBSA0f9EEACYaf6Sw8XEjHSeSEMQKJ9r23devWlxfU7aqwGG9wGySFkmSWC2AnTTeb0EQyC8q
        Ia+giLyCYqx2O5Jkxmy1YTKbkUxmzBYroihhsU4c7iyIwli4ogTweydOiZYDfvx+LwG/j4Dfh8/rQfb7
        8XpGkAMB3MMuRoYGcQ30hvrFTwsBWTniD8iHRjz+/X2uEefR1p6Dv39l14lx0VIx/NDfehsD451jfJ4S
        fbuns0dgWglApN/jjTfSGz+SIIC+XoHxYdHyECvPYdsbbrp42eyK4gscNstZFrO0QJLEGYIgFApgJUcd
        tCaLqqrDsqK2BGTllD8gt7i9/pODw57jLZ39zS++c6C5u394vKLEe8iTMfrx++K98fV8692X6u9YYbHC
        w8h2ARifx3gjAZP5QHwhiBVOjPixriUs7IIltYWXnTf/vKI821yb1VxrlsTqUYEoFUXBLoANQbAAJiG8
        JJMVqOBVVdWNyrCiqsOKoroUVR1SFKU/ICu9Pr/c6fb6uvoG3ScPnOg88dK7BzvDkyMQ+6HV+/ZMxvD1
        vu3RsS8RQ45XlJ9U44cse4gSyGe80oCewUB6egXQGZ7M71hhcffZrWbpmouXzKyZUVhZmGersppNRaIo
        WE2SmCeKol0QsIqikC8gmCRRyI9wCEkUxXwAVVUDqqpO6E9TVLyKqrhVlRFZVjyyorpkWfH6AoEBWVG9
        QyPenu7+4c43dx1tOd7ep9ebip6HU40TN95bWE/dXU8jYazvaL/jVUtixUFH3GTDI5IrAhAtv/FKBKG/
        oxm7OG47Vq9AaPxo+yPlMV7bQbxr0xOe6L2bCkLf7PHe8OPTjf+t5y0cy7gTNfhE9+nNOwmki3dvktkf
        Rq4JQLR8R3tbB7/j9fvHSxNLEPTsi/U7kWtK9L4kez9TIZEHMBHDSLRbT8+33n3R9uuJr3c73r1Lq+EH
        yVUBiJV3Pcap1/AjHS+ZHoJYeYp1PWmrMjD1/3UyD3Mib369JYJ4cfScjzj7En3D67lH6dgfl1wWAD3X
        kIgR6nmDJ5suWrxo15BqdSCZ/zVWGjVCHDVKulQMX28DWrr70hMpjidr7PHujZ79icaLy3QQgESuJ5bx
        JdOyr1cQYh0nXe0D6Tb6WKjjjpFIHV/vmzPavmTSJ2O0iRix3rR6jpWOuLqZbgKQzPXFe4smYnzpjhvv
        GpIVgmhxVJ3po6VNNl4qb9x0F78ns9U9USOeFKMPZboLQLLXm2hJIhVjTlfxPtqxUzHqVElnUTidI+CS
        yddkv60n3dgjcaYJQCwSuRfJVDWSCU/X/kSvLx2kYoh646TrHInESzVNOtKmDUMA9JPovZqs+OkQg2xi
        sgw0HQaW6jGywshjkWsPSy4wlY1x6T5GJplqY5mM82W9wY8n1x+aXCfVgTuZrN9ngqk0sJwz5mSYNqsD
        n2Ek2+1kEM4Zf9/OpLfHmchUlxTScZ4z3igNDAwMDAwMDAwMDAwmif8PAoW74vMCEmkAAAAASUVORK5C
        YII=
</value>
  </data>
</root>
```

`MapleNecrocer/MapleNecrocer.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>WinExe</OutputType>
    <TargetFramework>net6.0-windows</TargetFramework>
    <Nullable>enable</Nullable>
    <UseWindowsForms>true</UseWindowsForms>
    <ImplicitUsings>enable</ImplicitUsings>
    <Platforms>AnyCPU;x64</Platforms>
    <AllowUnsafeBlocks>True</AllowUnsafeBlocks>
    <ApplicationIcon>MapleStoryGM_Icon.ico</ApplicationIcon>
   
  </PropertyGroup>

  
  <ItemGroup>
    <Content Include="MapleStoryGM_Icon.ico" />
  </ItemGroup>

  <ItemGroup>
    <Reference Include="AForge">
      <HintPath>bin\x64\Release\net6.0-windows\AForge.dll</HintPath>
    </Reference>
    <Reference Include="AForge.Imaging">
      <HintPath>bin\x64\Release\net6.0-windows\AForge.Imaging.dll</HintPath>
    </Reference>
    <Reference Include="CharaSimResource">
      <HintPath>bin\x64\Release\net6.0-windows\CharaSimResource.dll</HintPath>
    </Reference>
    <Reference Include="DevComponents.DotNetBar2">
      <HintPath>bin\x64\Release\net6.0-windows\DevComponents.DotNetBar2.dll</HintPath>
    </Reference>
    <Reference Include="ImageListView">
      <HintPath>bin\x64\Release\net6.0-windows\ImageListView.dll</HintPath>
    </Reference>
    <Reference Include="ManagedBass">
      <HintPath>bin\x64\Release\net6.0-windows\ManagedBass.dll</HintPath>
    </Reference>
    <Reference Include="MonoGame.Forms.DX">
      <HintPath>bin\x64\Release\net6.0-windows\MonoGame.Forms.DX.dll</HintPath>
    </Reference>
    <Reference Include="MonoGame.Framework">
      <HintPath>..\WzComparerR2.PluginBase\bin\Release\net6.0-windows\MonoGame.Framework.dll</HintPath>
    </Reference>
    <Reference Include="SharpDX">
      <HintPath>bin\x64\Release\net6.0-windows\SharpDX.dll</HintPath>
    </Reference>
    <Reference Include="SharpDX.Direct3D11">
      <HintPath>bin\x64\Release\net6.0-windows\SharpDX.Direct3D11.dll</HintPath>
    </Reference>
    <Reference Include="SharpDX.DXGI">
      <HintPath>bin\x64\Release\net6.0-windows\SharpDX.DXGI.dll</HintPath>
    </Reference>
    <Reference Include="spine-monogame">
      <HintPath>bin\x64\Release\net6.0-windows\spine-monogame.dll</HintPath>
    </Reference>
    <Reference Include="WzComparerR2.Common">
      <HintPath>..\WzComparerR2.Common\bin\Release\net6.0-windows\WzComparerR2.Common.dll</HintPath>
    </Reference>
    <Reference Include="WzComparerR2.PluginBase">
      <HintPath>..\WzComparerR2.PluginBase\bin\Release\net6.0-windows\WzComparerR2.PluginBase.dll</HintPath>
    </Reference>
    <Reference Include="WzComparerR2.WzLib">
      <HintPath>..\WzComparerR2.WzLib\bin\Release\net6.0-windows\WzComparerR2.WzLib.dll</HintPath>
    </Reference>
  </ItemGroup>

  <ItemGroup>
    <Compile Update="Properties\Resources.Designer.cs">
      <DesignTime>True</DesignTime>
      <AutoGen>True</AutoGen>
      <DependentUpon>Resources.resx</DependentUpon>
    </Compile>
  </ItemGroup>

  <ItemGroup>
    <EmbeddedResource Update="Properties\Resources.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
    </EmbeddedResource>
  </ItemGroup>

</Project>
```

`MapleNecrocer/MedalForm.Designer.cs`:

```cs
namespace MapleNecrocer
{
    partial class MedalForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            panel1 = new Panel();
            label1 = new Label();
            textBox1 = new TextBox();
            button1 = new Button();
            SuspendLayout();
            // 
            // panel1
            // 
            panel1.Anchor = AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right;
            panel1.Location = new Point(12, 43);
            panel1.Name = "panel1";
            panel1.Size = new Size(335, 557);
            panel1.TabIndex = 0;
            // 
            // label1
            // 
            label1.AutoSize = true;
            label1.Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            label1.Location = new Point(12, 17);
            label1.Name = "label1";
            label1.Size = new Size(52, 18);
            label1.TabIndex = 1;
            label1.Text = "Search";
            // 
            // textBox1
            // 
            textBox1.Location = new Point(65, 15);
            textBox1.Name = "textBox1";
            textBox1.Size = new Size(116, 23);
            textBox1.TabIndex = 2;
            textBox1.TextChanged += textBox1_TextChanged;
            // 
            // button1
            // 
            button1.Location = new Point(234, 10);
            button1.Name = "button1";
            button1.Size = new Size(95, 28);
            button1.TabIndex = 3;
            button1.Text = "Remove";
            button1.UseVisualStyleBackColor = true;
            button1.Click += button1_Click;
            // 
            // MedalForm
            // 
            AutoScaleMode = AutoScaleMode.None;
            ClientSize = new Size(359, 612);
            Controls.Add(button1);
            Controls.Add(textBox1);
            Controls.Add(label1);
            Controls.Add(panel1);
            Font = new Font("Tahoma", 13F, FontStyle.Regular, GraphicsUnit.Pixel);
            KeyPreview = true;
            MaximumSize = new Size(377, 900);
            Name = "MedalForm";
            StartPosition = FormStartPosition.CenterScreen;
            Text = "Medal";
            TopMost = true;
            FormClosing += MedalForm_FormClosing;
            Shown += MedalForm_Shown;
            KeyDown += MedalForm_KeyDown;
            ResumeLayout(false);
            PerformLayout();
        }

        #endregion

        private Panel panel1;
        private Label label1;
        private TextBox textBox1;
        private Button button1;
    }
}
```

`MapleNecrocer/MedalForm.cs`:

```cs
using DevComponents.DotNetBar;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace MapleNecrocer;

public partial class MedalForm : Form
{
    public MedalForm()
    {
        InitializeComponent();
        Instance = this;
    }

    public static MedalForm Instance;
    public DataGridViewEx MedalListGrid;

   
    void CellClick(BaseDataGridView DataGrid, DataGridViewCellEventArgs e)
    {
        MedalTag.Delete();
        var ID = DataGrid.Rows[e.RowIndex].Cells[0].Value.ToString();
        MedalTag.Create(ID);

    }
    private void MedalForm_Shown(object sender, EventArgs e)
    {

        this.FormClosing += (s, e1) =>
        {
            this.Hide();
            e1.Cancel = true;
        };

        MedalListGrid = new(90, 164, 0, 0, 220, 400, true, panel1);
        MedalListGrid.Dock = DockStyle.Fill;
        MedalListGrid.SearchGrid.Dock = DockStyle.Fill;
        MedalListGrid.RowTemplate.Height = 40;

        var Graphic = MedalListGrid.CreateGraphics();
        var Font = new System.Drawing.Font(FontFamily.GenericSansSerif, 20, FontStyle.Bold);
        Graphic.DrawString("Loading...", Font, Brushes.Black, 10, 50);

        MedalListGrid.CellClick += (s, e) =>
        {
            CellClick(MedalListGrid, e);
        };

        MedalListGrid.SearchGrid.CellClick += (s, e) =>
        {
            CellClick(MedalListGrid.SearchGrid, e);
        };

        MedalListGrid.SetToolTipEvent(WzType.Character, this);

        string MedalName = null;
        Bitmap Bmp = null;
        foreach (var Img in Wz.GetNode("Character/Accessory").Nodes)
        {
            if (Img.Text.LeftStr(4) != "0114")
                continue;
            if (!Wz.HasNode("Character/Accessory/" + Img.Text + "/info/medalTag"))
                continue;
            int TagNum = Wz.GetNode("Character/Accessory/" + Img.Text + "/info/medalTag").ToInt();
            if (!Wz.HasNode("UI/NameTag.img/medal/" + TagNum))
                continue;
            string ID = Img.ImgID();
            if (Wz.HasNode("String/Eqp.img/Eqp/Accessory/" + ID.IntID()))
                MedalName = Wz.GetNode("String/Eqp.img/Eqp/Accessory/" + ID.IntID() + "/name").ToStr();
            if (Wz.HasNode("Character/Accessory/" + Img.Text + "/info/icon"))
                Bmp = Wz.GetNode("Character/Accessory/" + Img.Text + "/info/icon").ExtractPng();
            MedalListGrid.Rows.Add(ID, Bmp, MedalName);
        }

        for (int i = 0; i < MedalListGrid.Rows.Count; i++)
        {
            MedalListGrid.Rows[i].Cells[1].Style.Alignment = DataGridViewContentAlignment.MiddleCenter;
            MedalListGrid.Rows[i].Cells[2].Style.Alignment = DataGridViewContentAlignment.TopLeft;
        }

    }

    private void button1_Click(object sender, EventArgs e)
    {
        MedalTag.Delete();
    }

    private void MedalForm_KeyDown(object sender, KeyEventArgs e)
    {
        if (e.Alt)
            e.Handled = true;
        if (!textBox1.Focused)
            ActiveControl = null;
    }

    private void textBox1_TextChanged(object sender, EventArgs e)
    {
        MedalListGrid.Search(textBox1.Text);
    }

    private void MedalForm_FormClosing(object sender, FormClosingEventArgs e)
    {
        MainForm.Instance.ToolTipView.Visible = false;
    }
}

```

`MapleNecrocer/MedalForm.resx`:

```resx
<root>
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`MapleNecrocer/MobForm.Designer.cs`:

```cs
namespace MapleNecrocer
{
    partial class MobForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            pictureBox1 = new PictureBox();
            tabControl1 = new TabControl();
            tabPage1 = new TabPage();
            tabPage2 = new TabPage();
            button1 = new Button();
            label1 = new Label();
            textBox1 = new TextBox();
            button2 = new Button();
            label2 = new Label();
            textBox2 = new TextBox();
            ((System.ComponentModel.ISupportInitialize)pictureBox1).BeginInit();
            tabControl1.SuspendLayout();
            SuspendLayout();
            // 
            // pictureBox1
            // 
            pictureBox1.BorderStyle = BorderStyle.FixedSingle;
            pictureBox1.Location = new Point(8, 9);
            pictureBox1.Name = "pictureBox1";
            pictureBox1.Size = new Size(248, 153);
            pictureBox1.SizeMode = PictureBoxSizeMode.CenterImage;
            pictureBox1.TabIndex = 0;
            pictureBox1.TabStop = false;
            // 
            // tabControl1
            // 
            tabControl1.Anchor = AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right;
            tabControl1.Controls.Add(tabPage1);
            tabControl1.Controls.Add(tabPage2);
            tabControl1.Location = new Point(5, 241);
            tabControl1.Name = "tabControl1";
            tabControl1.SelectedIndex = 0;
            tabControl1.Size = new Size(260, 398);
            tabControl1.TabIndex = 1;
            // 
            // tabPage1
            // 
            tabPage1.Location = new Point(4, 28);
            tabPage1.Name = "tabPage1";
            tabPage1.Padding = new Padding(3);
            tabPage1.Size = new Size(252, 366);
            tabPage1.TabIndex = 0;
            tabPage1.Text = "tabPage1";
            tabPage1.UseVisualStyleBackColor = true;
            // 
            // tabPage2
            // 
            tabPage2.Location = new Point(4, 28);
            tabPage2.Name = "tabPage2";
            tabPage2.Padding = new Padding(3);
            tabPage2.Size = new Size(252, 366);
            tabPage2.TabIndex = 1;
            tabPage2.Text = "tabPage2";
            tabPage2.UseVisualStyleBackColor = true;
            // 
            // button1
            // 
            button1.Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            button1.Location = new Point(11, 170);
            button1.Name = "button1";
            button1.Size = new Size(52, 28);
            button1.TabIndex = 2;
            button1.Text = "Drop";
            button1.UseVisualStyleBackColor = true;
            button1.Click += button1_Click;
            // 
            // label1
            // 
            label1.AutoSize = true;
            label1.Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            label1.Location = new Point(63, 178);
            label1.Name = "label1";
            label1.Size = new Size(17, 18);
            label1.TabIndex = 3;
            label1.Text = "X";
            // 
            // textBox1
            // 
            textBox1.Location = new Point(83, 171);
            textBox1.Name = "textBox1";
            textBox1.Size = new Size(51, 27);
            textBox1.TabIndex = 4;
            textBox1.Text = "5";
            // 
            // button2
            // 
            button2.Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            button2.Location = new Point(187, 171);
            button2.Name = "button2";
            button2.Size = new Size(70, 28);
            button2.TabIndex = 5;
            button2.Text = "Remove";
            button2.UseVisualStyleBackColor = true;
            button2.Click += button2_Click;
            // 
            // label2
            // 
            label2.AutoSize = true;
            label2.Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            label2.Location = new Point(13, 213);
            label2.Name = "label2";
            label2.Size = new Size(52, 18);
            label2.TabIndex = 6;
            label2.Text = "Search";
            // 
            // textBox2
            // 
            textBox2.Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            textBox2.Location = new Point(71, 208);
            textBox2.Name = "textBox2";
            textBox2.Size = new Size(185, 24);
            textBox2.TabIndex = 7;
            textBox2.TextChanged += textBox2_TextChanged;
            // 
            // MobForm
            // 
            AutoScaleMode = AutoScaleMode.None;
            ClientSize = new Size(272, 644);
            Controls.Add(textBox2);
            Controls.Add(label2);
            Controls.Add(button2);
            Controls.Add(textBox1);
            Controls.Add(label1);
            Controls.Add(button1);
            Controls.Add(tabControl1);
            Controls.Add(pictureBox1);
            DoubleBuffered = true;
            KeyPreview = true;
            MaximumSize = new Size(290, 2000);
            Name = "MobForm";
            StartPosition = FormStartPosition.CenterScreen;
            Text = "Mob";
            TopMost = true;
            FormClosing += MobForm_FormClosing;
            Load += MobForm_Load;
            Shown += MobForm_Shown;
            KeyDown += MobForm_KeyDown;
            ((System.ComponentModel.ISupportInitialize)pictureBox1).EndInit();
            tabControl1.ResumeLayout(false);
            ResumeLayout(false);
            PerformLayout();
        }

        #endregion

        private PictureBox pictureBox1;
        private TabControl tabControl1;
        private TabPage tabPage1;
        private TabPage tabPage2;
        private Button button1;
        private Label label1;
        private TextBox textBox1;
        private Button button2;
        private Label label2;
        private TextBox textBox2;
    }
}
```

`MapleNecrocer/MobForm.cs`:

```cs
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using WzComparerR2.CharaSim;
using WzComparerR2.WzLib;

namespace MapleNecrocer;

public partial class MobForm : Form
{
    public MobForm()
    {
        InitializeComponent();
        Instance = this;
    }
    public static MobForm Instance;
    public DataGridViewEx MobListGrid;
    string MobID;
    /*
    protected override CreateParams CreateParams
    {
        get
        {
            CreateParams cp = base.CreateParams;
            cp.ExStyle |= 0x02000000;
            return cp;
        }
    }
    */
    private void MobForm_Load(object sender, EventArgs e)
    {

    }

    void CellClick(BaseDataGridView DataGrid, DataGridViewCellEventArgs e)
    {
        MobID = DataGrid.Rows[e.RowIndex].Cells[0].Value.ToString();
        var Link = Wz.GetNode("Mob/" + MobID + ".img/info/link");
        if (Link != null)
        {
            MobID = Link.ToStr();
        }
        Bitmap Bitmap;
        if (Wz.GetNodeA("Mob/" + MobID + ".img/stand/0") != null)
            Bitmap = Wz.GetNode("Mob/" + MobID + ".img/stand/0").ExtractPng();
        else if ((Wz.GetNodeA("Mob/" + MobID + ".img/fly/0") != null))
            Bitmap = Wz.GetNode("Mob/" + MobID + ".img/fly/0").ExtractPng();
        else
            return;
        pictureBox1.Image = Bitmap;
    }

    private void MobForm_Shown(object sender, EventArgs e)
    {
        this.FormClosing += (s, e1) =>
        {
            this.Hide();
            e1.Cancel = true;
        };
        MobListGrid = new(60, 164, 0, 0, 220, 400, false, tabControl1.TabPages[0]);
        MobListGrid.Dock = DockStyle.Fill;
        MobListGrid.SearchGrid.Dock = DockStyle.Fill;

        var Graphic = MobListGrid.CreateGraphics();
        var Font = new System.Drawing.Font(FontFamily.GenericSansSerif, 20, FontStyle.Bold);
        Graphic.DrawString("Loading...", Font, Brushes.Black, 10, 50);

        MobListGrid.CellClick += (s, e) =>
        {
            CellClick(MobListGrid, e);
        };

        MobListGrid.SearchGrid.CellClick += (s, e) =>
        {
            CellClick(MobListGrid.SearchGrid, e);
        };

        MobListGrid.SetToolTipEvent(WzType.Mob, this);

        string ID = null;
        string Name = null;
        Win32.SendMessage(MobListGrid.Handle, false);
        foreach (var Iter in MainForm.TreeNode.Nodes["Mob"].Nodes)
        {
            if (!Char.IsNumber(Iter.Text, 0))
                continue;
            ID = Iter.Text.LeftStr(7);
            Name = Wz.GetStr("String/Mob.img/" + ID.IntID() + "/name");
            MobListGrid.Rows.Add(ID, Name);
        }
        Win32.SendMessage(MobListGrid.Handle, true);
        MobListGrid.Refresh();
    }

    private void textBox2_TextChanged(object sender, EventArgs e)
    {
        MobListGrid.Search(textBox2.Text);
    }

    private void button1_Click(object sender, EventArgs e)
    {
        if (Wz.GetNode("Mob/" + MobID + ".img") == null)
            return;
        Random Random = new Random();
        if (Char.IsNumber(textBox1.Text[0]) && (textBox1.Text != ""))
        {
            for (int I = 0; I < textBox1.Text.ToInt(); I++)
            {
                int Range = Random.Next((int)Game.Player.X - 100, (int)Game.Player.X + 100);
                if (Range > Map.Left && Range < Map.Right)
                {
                    Mob.Spawn(MobID, Range, (int)Game.Player.Y - 100, Map.Left, Map.Right);
                    Mob.SummonedList.Add(MobID);
                }
            }
        }
    }

    private void button2_Click(object sender, EventArgs e)
    {
        foreach (var Iter in EngineFunc.SpriteEngine.SpriteList)
        {
            if (Iter is Mob)
            {
                for (int I = 0; I < Mob.SummonedList.Count; I++)
                {
                    if (((Mob)Iter).LocalID == Mob.SummonedList[I])
                    {
                        Iter.Dead();
                        Mob.MobList.Remove(Mob.SummonedList[I]);
                    }
                }
            }
        }
        EngineFunc.SpriteEngine.Dead();
    }

    private void MobForm_KeyDown(object sender, KeyEventArgs e)
    {
        if (e.Alt)
            e.Handled = true;
        if (!textBox2.Focused && !textBox1.Focused)
            ActiveControl = null;

    }

    private void MobForm_FormClosing(object sender, FormClosingEventArgs e)
    {
        MainForm.Instance.ToolTipView.Visible = false;
    }
}

```

`MapleNecrocer/MobForm.resx`:

```resx
<root>
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`MapleNecrocer/MorphForm.Designer.cs`:

```cs
namespace MapleNecrocer
{
    partial class MorphForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            tabControl1 = new TabControl();
            tabPage1 = new TabPage();
            tabPage2 = new TabPage();
            button1 = new Button();
            textBox1 = new TextBox();
            label1 = new Label();
            tabControl1.SuspendLayout();
            SuspendLayout();
            // 
            // tabControl1
            // 
            tabControl1.Anchor = AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right;
            tabControl1.Controls.Add(tabPage1);
            tabControl1.Controls.Add(tabPage2);
            tabControl1.Font = new Font("Microsoft JhengHei UI", 13F, FontStyle.Regular, GraphicsUnit.Pixel);
            tabControl1.Location = new Point(12, 55);
            tabControl1.Name = "tabControl1";
            tabControl1.SelectedIndex = 0;
            tabControl1.Size = new Size(408, 565);
            tabControl1.TabIndex = 3;
            // 
            // tabPage1
            // 
            tabPage1.Location = new Point(4, 26);
            tabPage1.Name = "tabPage1";
            tabPage1.Padding = new Padding(3);
            tabPage1.Size = new Size(400, 535);
            tabPage1.TabIndex = 0;
            tabPage1.Text = "tabPage1";
            tabPage1.UseVisualStyleBackColor = true;
            // 
            // tabPage2
            // 
            tabPage2.Location = new Point(4, 26);
            tabPage2.Name = "tabPage2";
            tabPage2.Padding = new Padding(3);
            tabPage2.Size = new Size(400, 535);
            tabPage2.TabIndex = 1;
            tabPage2.Text = "tabPage2";
            tabPage2.UseVisualStyleBackColor = true;
            // 
            // button1
            // 
            button1.Font = new Font("Tahoma", 13F, FontStyle.Regular, GraphicsUnit.Pixel);
            button1.Location = new Point(279, 15);
            button1.Name = "button1";
            button1.Size = new Size(96, 26);
            button1.TabIndex = 4;
            button1.Text = "Remove";
            button1.UseVisualStyleBackColor = true;
            button1.Click += button1_Click;
            // 
            // textBox1
            // 
            textBox1.Font = new Font("Tahoma", 13F, FontStyle.Regular, GraphicsUnit.Pixel);
            textBox1.Location = new Point(74, 16);
            textBox1.Name = "textBox1";
            textBox1.Size = new Size(137, 23);
            textBox1.TabIndex = 5;
            textBox1.TextChanged += textBox1_TextChanged;
            // 
            // label1
            // 
            label1.AutoSize = true;
            label1.Location = new Point(12, 16);
            label1.Name = "label1";
            label1.Size = new Size(56, 19);
            label1.TabIndex = 6;
            label1.Text = "Search";
            // 
            // MorphForm
            // 
            AutoScaleMode = AutoScaleMode.None;
            ClientSize = new Size(432, 632);
            Controls.Add(label1);
            Controls.Add(textBox1);
            Controls.Add(button1);
            Controls.Add(tabControl1);
            KeyPreview = true;
            MaximumSize = new Size(450, 1000);
            Name = "MorphForm";
            StartPosition = FormStartPosition.CenterScreen;
            Text = "Morph";
            TopMost = true;
            Shown += MorphForm_Shown;
            KeyDown += MorphForm_KeyDown;
            tabControl1.ResumeLayout(false);
            ResumeLayout(false);
            PerformLayout();
        }

        #endregion

        private TabControl tabControl1;
        private TabPage tabPage1;
        private TabPage tabPage2;
        private Button button1;
        private TextBox textBox1;
        private Label label1;
    }
}
```

`MapleNecrocer/MorphForm.cs`:

```cs
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace MapleNecrocer;

public partial class MorphForm : Form
{
    public MorphForm()
    {
        InitializeComponent();
        Instance = this;
    }
    public static MorphForm Instance;
    public DataGridViewEx MorphListGrid;

    void CellClick(BaseDataGridView DataGrid, DataGridViewCellEventArgs e)
    {
        if (MapleChair.IsUse || TamingMob.IsUse)
            return;
        var MorphImg = DataGrid.Rows[e.RowIndex].Cells[0].Value.ToString();
        if (MorphImg == "")
            return;
        Morph.Delete();
        Morph.Create(MorphImg);
        Morph.IsUse = true;
    }
    private void MorphForm_Shown(object sender, EventArgs e)
    {
        this.FormClosing += (s, e1) =>
        {
            this.Hide();
            e1.Cancel = true;
        };

        MorphListGrid = new(90, 164, 0, 0, 220, 400, true, tabControl1.TabPages[0]);
        MorphListGrid.Dock = DockStyle.Fill;
        MorphListGrid.SearchGrid.Dock = DockStyle.Fill;
        MorphListGrid.RowTemplate.Height = 80;
        MorphListGrid.Columns[1].Width = 80;
        ((DataGridViewImageColumn)MorphListGrid.Columns[1]).ImageLayout = DataGridViewImageCellLayout.Zoom;

        var Graphic = MorphListGrid.CreateGraphics();
        var Font = new System.Drawing.Font(FontFamily.GenericSansSerif, 20, FontStyle.Bold);
        Graphic.DrawString("Loading...", Font, Brushes.Black, 10, 50);

        MorphListGrid.CellClick += (s, e) =>
        {
            CellClick(MorphListGrid, e);
        };

        MorphListGrid.SearchGrid.CellClick += (s, e) =>
        {
            CellClick(MorphListGrid.SearchGrid, e);
        };

        string MorphName = "";
        Bitmap Bmp = null;
        foreach (var Iter in Wz.GetNode("Item/Consume/0221.img").Nodes)
        {
            if (!Iter.HasNode("spec/morph")) continue;
            if (Wz.HasNode("String/Consume.img/" + Iter.Text.IntID()))
                MorphName = Wz.GetNode("String/Consume.img/" + Iter.Text.IntID()).GetStr("name");
            else
                MorphName = "";
            string MorphID = Iter.GetNode("spec/morph").ToInt().ToString().PadLeft(4, '0');

            if (Wz.HasNode("Morph/" + MorphID + ".img"))
            {
                if (Wz.HasNode("Morph/" + MorphID + ".img/walk/0"))
                    Bmp = Wz.GetNode("Morph/" + MorphID + ".img/walk/0").ExtractPng();
            }
            MorphListGrid.Rows.Add(MorphID + ".img", Bmp, Iter.Text + "  " + "-" + "  " + MorphName);
        }

        for (int i = 0; i < MorphListGrid.Rows.Count; i++)
        {
            MorphListGrid.Rows[i].Cells[1].Style.Alignment = DataGridViewContentAlignment.MiddleCenter;
            MorphListGrid.Rows[i].Cells[2].Style.Alignment = DataGridViewContentAlignment.TopLeft;
        }
        MorphListGrid.Sort(MorphListGrid.Columns[0], ListSortDirection.Ascending);
    }

    private void button1_Click(object sender, EventArgs e)
    {
        Morph.Delete();
        Morph.IsUse = false;
    }

    private void textBox1_TextChanged(object sender, EventArgs e)
    {
        MorphListGrid.Search(textBox1.Text);
    }

    private void MorphForm_KeyDown(object sender, KeyEventArgs e)
    {
        if (e.Alt)
            e.Handled = true;
        if (!textBox1.Focused)
            ActiveControl = null;
    }
}

```

`MapleNecrocer/MorphForm.resx`:

```resx
<root>
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`MapleNecrocer/MountForm.Designer.cs`:

```cs
namespace MapleNecrocer
{
    partial class MountForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            button1 = new Button();
            textBox1 = new TextBox();
            tabControl1 = new TabControl();
            tabPage1 = new TabPage();
            tabPage2 = new TabPage();
            label1 = new Label();
            tabControl1.SuspendLayout();
            SuspendLayout();
            // 
            // button1
            // 
            button1.Font = new Font("Tahoma", 13F, FontStyle.Regular, GraphicsUnit.Pixel);
            button1.Location = new Point(247, 12);
            button1.Name = "button1";
            button1.Size = new Size(80, 26);
            button1.TabIndex = 0;
            button1.Text = "Remove";
            button1.UseVisualStyleBackColor = true;
            button1.Click += button1_Click;
            // 
            // textBox1
            // 
            textBox1.Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            textBox1.Location = new Point(63, 14);
            textBox1.Name = "textBox1";
            textBox1.Size = new Size(132, 24);
            textBox1.TabIndex = 1;
            textBox1.TextChanged += textBox1_TextChanged;
            // 
            // tabControl1
            // 
            tabControl1.Anchor = AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right;
            tabControl1.Controls.Add(tabPage1);
            tabControl1.Controls.Add(tabPage2);
            tabControl1.Location = new Point(2, 53);
            tabControl1.Name = "tabControl1";
            tabControl1.SelectedIndex = 0;
            tabControl1.Size = new Size(353, 497);
            tabControl1.TabIndex = 2;
            // 
            // tabPage1
            // 
            tabPage1.Location = new Point(4, 21);
            tabPage1.Name = "tabPage1";
            tabPage1.Padding = new Padding(3);
            tabPage1.Size = new Size(345, 472);
            tabPage1.TabIndex = 0;
            tabPage1.Text = "tabPage1";
            tabPage1.UseVisualStyleBackColor = true;
            // 
            // tabPage2
            // 
            tabPage2.Location = new Point(4, 28);
            tabPage2.Name = "tabPage2";
            tabPage2.Padding = new Padding(3);
            tabPage2.Size = new Size(345, 465);
            tabPage2.TabIndex = 1;
            tabPage2.Text = "tabPage2";
            tabPage2.UseVisualStyleBackColor = true;
            // 
            // label1
            // 
            label1.AutoSize = true;
            label1.Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            label1.Location = new Point(10, 16);
            label1.Name = "label1";
            label1.Size = new Size(52, 18);
            label1.TabIndex = 3;
            label1.Text = "Search";
            // 
            // MountForm
            // 
            AutoScaleMode = AutoScaleMode.None;
            ClientSize = new Size(359, 553);
            Controls.Add(label1);
            Controls.Add(tabControl1);
            Controls.Add(textBox1);
            Controls.Add(button1);
            DoubleBuffered = true;
            Font = new Font("Microsoft JhengHei UI", 9F, FontStyle.Regular, GraphicsUnit.Pixel);
            KeyPreview = true;
            MaximumSize = new Size(377, 1000);
            Name = "MountForm";
            StartPosition = FormStartPosition.CenterScreen;
            Text = "Mount";
            TopMost = true;
            Shown += MountForm_Shown;
            ForeColorChanged += MountForm_ForeColorChanged;
            KeyDown += MountForm_KeyDown;
            tabControl1.ResumeLayout(false);
            ResumeLayout(false);
            PerformLayout();
        }

        #endregion

        private Button button1;
        private TextBox textBox1;
        private TabControl tabControl1;
        private TabPage tabPage1;
        private TabPage tabPage2;
        private Label label1;
    }
}
```

`MapleNecrocer/MountForm.cs`:

```cs
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Security.Claims;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using WzComparerR2.CharaSim;

namespace MapleNecrocer;

public partial class MountForm : Form
{
    public MountForm()
    {
        InitializeComponent();
        Instance = this;
    }
    public static MountForm Instance;
    public DataGridViewEx MountListGrid;
    
      
    void CellClick(BaseDataGridView DataGrid, DataGridViewCellEventArgs e)
    {
        //if (Morph.IsUse)
        // return;
        var ID = DataGrid.Rows[e.RowIndex].Cells[0].Value.ToString();
        TamingMob.Remove();

        MapleChair.Remove();
        ItemEffect.Remove(EffectType.Chair);

        TamingMob.IsChairTaming = false;
        TamingMob.Create(ID);
        TamingMob.IsUse = true;

    }

    private void MountForm_Shown(object sender, EventArgs e)
    {
        this.FormClosing += (s, e1) =>
        {
            this.Hide();
            e1.Cancel = true;
        };
        MountListGrid = new(90, 174, 0, 0, 220, 800, true, tabControl1.TabPages[0]);
        MountListGrid.Dock = DockStyle.Fill;
        MountListGrid.SearchGrid.Dock = DockStyle.Fill;

        var Graphic = MountListGrid.CreateGraphics();
        var Font = new System.Drawing.Font(FontFamily.GenericSansSerif, 20, FontStyle.Bold);
        Graphic.DrawString("Loading...", Font, Brushes.Black, 10, 50);
        MountListGrid.CellClick += (s, e) =>
        {
            CellClick(MountListGrid, e);
        };

        MountListGrid.SearchGrid.CellClick += (s, e) =>
        {
            CellClick(MountListGrid.SearchGrid, e);
        };

        MountListGrid.SetToolTipEvent(WzType.Character, this);

        string MountName = "";
        Bitmap Bmp = null;
        Win32.SendMessage(MountListGrid.Handle, false);
        foreach (var Img in Wz.GetNodeA("Character/TamingMob").Nodes)
        {
            if (!Char.IsNumber(Img.Text[0]))
                continue;
            if (Img.Text.LeftStr(4) == "0191" || Img.Text.LeftStr(4) == "0198")
                continue;
            string ID = Img.ImgID();
            if (Wz.GetNode("String/Eqp.img/Eqp/Taming/" + ID.IntID()) != null)
                MountName = Wz.GetNode("String/Eqp.img/Eqp/Taming/" + ID.IntID()).GetStr("name");
            else
                MountName = "";
            var Entry = Wz.GetNode("Character/TamingMob/" + Img.Text + "/info/icon");
            if (Entry != null)
                Bmp = Entry.ExtractPng();
            MountListGrid.Rows.Add(ID, Bmp, MountName);
        }


        Dictionary<string, string> Dict = new();

        for (int i = 11; i <= 31; i++)
        {
            if (Wz.GetNode("Skill/" + "80011" + i.ToString() + ".img") != null)
            {
                foreach (var Iter in Wz.GetNode("Skill/80011" + i.ToString() + ".img/skill").Nodes)
                {
                    if (Iter.Nodes["vehicleID"] != null)
                        Dict.AddOrReplace("0" + Iter.Nodes["vehicleID"].ToStr(), Iter.Text);
                }
            }
        }

        for (int i = 0; i <= 9; i++)
        {
            if (Wz.GetNode("Skill/" + "8000" + i.ToString() + ".img") != null)
            {
                foreach (var Iter in Wz.GetNode("Skill/8000" + i.ToString() + ".img/skill").Nodes)
                {
                    if (Iter.Nodes["vehicleID"] != null)
                        Dict.AddOrReplace("0" + Iter.Nodes["vehicleID"].ToStr(), Iter.Text);
                }
            }
        }

        Dict.AddOrReplace("01932026", "80001015");
        Dict.AddOrReplace("01932064", "80001060");
        Dict.AddOrReplace("01932186", "80001060");
        Dict.AddOrReplace("01932003", "80001024");
        Dict.AddOrReplace("01932004", "80001024");
        Dict.AddOrReplace("01932065", "80001082");
        Dict.AddOrReplace("01932093", "80001082");
        Dict.AddOrReplace("01932066", "80001116");
        Dict.AddOrReplace("01932187", "80001312");
        Dict.AddOrReplace("01932188", "80001313");
        Dict.AddOrReplace("01932189", "80001314");
        Dict.AddOrReplace("01932190", "80001315");
        Dict.AddOrReplace("01932007", "80001004");
        Dict.AddOrReplace("01932019", "80001004");
        Dict.AddOrReplace("01932027", "80001016");
        Dict.AddOrReplace("01992002", "80001016");
        Dict.AddOrReplace("01932028", "80001017");
        Dict.AddOrReplace("01932034", "80001450");
        Dict.AddOrReplace("01932226", "80001450");
        Dict.AddOrReplace("01932284", "80001450");
        Dict.AddOrReplace("01992003", "80001066");
        Dict.AddOrReplace("01932177", "80001067");
        Dict.AddOrReplace("01992004", "80001067");
        Dict.AddOrReplace("01932013", "80001009");
        Dict.AddOrReplace("01932009", "80001006");
        Dict.AddOrReplace("01932008", "80001005");
        Dict.AddOrReplace("01932495", "80001005");
        Dict.AddOrReplace("01932191", "80001316");
        Dict.AddOrReplace("01932192", "80001317");
        Dict.AddOrReplace("01932193", "80001075");
        Dict.AddOrReplace("01992012", "80001075");
        Dict.AddOrReplace("01932014", "80001010");
        Dict.AddOrReplace("01932258", "80001077");
        Dict.AddOrReplace("01992014", "80001077");
        Dict.AddOrReplace("01932078", "80001118");
        Dict.AddOrReplace("01932194", "80001118");
        Dict.AddOrReplace("01932332", "80001533");
        Dict.AddOrReplace("01932102", "80001346");
        Dict.AddOrReplace("01932206", "80001346");
        Dict.AddOrReplace("01932002", "80001449");
        Dict.AddOrReplace("01932118", "80001449");
        Dict.AddOrReplace("01932225", "80001449");
        Dict.AddOrReplace("01932285", "80001449");
        Dict.AddOrReplace("01992006", "80001069");
        Dict.AddOrReplace("01992010", "80001008");
        Dict.AddOrReplace("01992007", "80001007");
        Dict.AddOrReplace("01932250", "80001074");
        Dict.AddOrReplace("01992011", "80001074");
        Dict.AddOrReplace("01932012", "80001074");
        Dict.AddOrReplace("01932011", "80001007");
        Dict.AddOrReplace("01932018", "80001046");
        Dict.AddOrReplace("01932023", "80001013");
        Dict.AddOrReplace("01932025", "80001014");
        Dict.AddOrReplace("01932029", "80001030");
        Dict.AddOrReplace("01932054", "80001030");
        Dict.AddOrReplace("01932062", "80001030");
        Dict.AddOrReplace("01932035", "80001019");
        Dict.AddOrReplace("01932227", "80001019");
        Dict.AddOrReplace("01932283", "80001019");
        Dict.AddOrReplace("01932038", "80001031");
        Dict.AddOrReplace("01932055", "80001031");
        Dict.AddOrReplace("01932172", "80001031");
        Dict.AddOrReplace("01992013", "80001031");
        Dict.AddOrReplace("01932041", "80001020");
        Dict.AddOrReplace("01932043", "80001021");
        Dict.AddOrReplace("01932044", "80001022");
        Dict.AddOrReplace("01932045", "80001054");
        Dict.AddOrReplace("01932058", "80001084");
        Dict.AddOrReplace("01932095", "80001175");
        Dict.AddOrReplace("01932122", "80001175");
        Dict.AddOrReplace("01932046", "80001044");
        Dict.AddOrReplace("01932059", "80001044");
        Dict.AddOrReplace("01932090", "80001044");
        Dict.AddOrReplace("01932197", "80001044");
        Dict.AddOrReplace("01932047", "80001056");
        Dict.AddOrReplace("01932061", "80001056");
        Dict.AddOrReplace("01932094", "80001056");
        Dict.AddOrReplace("01932048", "80001023");
        Dict.AddOrReplace("01932245", "80001023");
        Dict.AddOrReplace("01932049", "80001027");
        Dict.AddOrReplace("01932050", "80001028");
        Dict.AddOrReplace("01932053", "80001029");
        Dict.AddOrReplace("01932088", "80001029");
        Dict.AddOrReplace("01992008", "80001029");
        Dict.AddOrReplace("01932056", "80001032");
        Dict.AddOrReplace("01932080", "80001032");
        Dict.AddOrReplace("01932196", "80001032");
        Dict.AddOrReplace("01932057", "80001033");
        Dict.AddOrReplace("01932060", "80001413");
        Dict.AddOrReplace("01932219", "80001413");
        Dict.AddOrReplace("01932071", "80001061");
        Dict.AddOrReplace("01932072", "80001117");
        Dict.AddOrReplace("01932081", "80001062");
        Dict.AddOrReplace("01932083", "80001057");
        Dict.AddOrReplace("01932089", "80001039");
        Dict.AddOrReplace("01932092", "80001121");
        Dict.AddOrReplace("01932096", "80001090");
        Dict.AddOrReplace("01932097", "80001112");
        Dict.AddOrReplace("01932255", "80001112");
        Dict.AddOrReplace("01932098", "80001113");
        Dict.AddOrReplace("01932320", "80001113");
        Dict.AddOrReplace("01932099", "80001114");
        Dict.AddOrReplace("01932105", "80001124");
        Dict.AddOrReplace("01932109", "80001131");
        Dict.AddOrReplace("01932211", "80001131");
        Dict.AddOrReplace("01932110", "80001137");
        Dict.AddOrReplace("01932112", "80001142");
        Dict.AddOrReplace("01932208", "80001142");
        Dict.AddOrReplace("01932113", "80001144");
        Dict.AddOrReplace("01932136", "80001144");
        Dict.AddOrReplace("01932114", "80001148");
        Dict.AddOrReplace("01932137", "80001148");
        Dict.AddOrReplace("01932115", "80001149");
        Dict.AddOrReplace("01932138", "80001149");
        Dict.AddOrReplace("01932116", "80001156");
        Dict.AddOrReplace("01932117", "80001157");
        Dict.AddOrReplace("01932120", "80001173");
        Dict.AddOrReplace("01932121", "80001174");
        Dict.AddOrReplace("01932123", "80001179");
        Dict.AddOrReplace("01932124", "80001180");
        Dict.AddOrReplace("01932131", "80001183");
        Dict.AddOrReplace("01932127", "80001184");
        Dict.AddOrReplace("01932132", "80001184");
        Dict.AddOrReplace("01932128", "80001185");
        Dict.AddOrReplace("01932133", "80001185");
        Dict.AddOrReplace("01932129", "80001186");
        Dict.AddOrReplace("01932134", "80001186");
        Dict.AddOrReplace("01932130", "80001187");
        Dict.AddOrReplace("01932135", "80001187");
        Dict.AddOrReplace("01932139", "80001196");
        Dict.AddOrReplace("01932140", "80001197");
        Dict.AddOrReplace("01932145", "80001197");
        Dict.AddOrReplace("01932143", "80001220");
        Dict.AddOrReplace("01932146", "80001223");
        Dict.AddOrReplace("01932144", "80001221");
        Dict.AddOrReplace("01932147", "80001221");
        Dict.AddOrReplace("01932148", "80001228");
        Dict.AddOrReplace("01932149", "80001228");
        Dict.AddOrReplace("01932150", "80001229");
        Dict.AddOrReplace("01932151", "80001230");
        Dict.AddOrReplace("01932152", "80001241");
        Dict.AddOrReplace("01932349", "80001241");
        Dict.AddOrReplace("01932153", "80001237");
        Dict.AddOrReplace("01992036", "80001237");
        Dict.AddOrReplace("01932154", "80001240");
        Dict.AddOrReplace("01932156", "80001243");
        Dict.AddOrReplace("01932157", "80001244");
        Dict.AddOrReplace("01932158", "80001245");
        Dict.AddOrReplace("01932159", "80001246");
        Dict.AddOrReplace("01932348", "80001246");
        Dict.AddOrReplace("01992026", "80001246");
        Dict.AddOrReplace("01992050", "80001246");
        Dict.AddOrReplace("01932161", "80001257");
        Dict.AddOrReplace("01992035", "80001257");
        Dict.AddOrReplace("01932162", "80001258");
        Dict.AddOrReplace("01992032", "80001258");
        Dict.AddOrReplace("01932163", "80001260");
        Dict.AddOrReplace("01932222", "80001260");
        Dict.AddOrReplace("01932164", "80001261");
        Dict.AddOrReplace("01992027", "80001261");
        Dict.AddOrReplace("01932165", "80001277");
        Dict.AddOrReplace("01932166", "80001277");
        Dict.AddOrReplace("01932167", "80001285");
        Dict.AddOrReplace("01932168", "80001285");
        Dict.AddOrReplace("01932169", "80001285");
        Dict.AddOrReplace("01932174", "80001285");
        Dict.AddOrReplace("01932170", "80001289");
        Dict.AddOrReplace("01932175", "80001289");
        Dict.AddOrReplace("01932171", "80001290");
        Dict.AddOrReplace("01932176", "80001290");
        Dict.AddOrReplace("01932173", "80001292");
        Dict.AddOrReplace("01932178", "80001068");
        Dict.AddOrReplace("01932231", "80001068");
        Dict.AddOrReplace("01992005", "80001068");
        Dict.AddOrReplace("01932195", "80001320");
        Dict.AddOrReplace("01932198", "80001327");
        Dict.AddOrReplace("01932199", "80001331");
        Dict.AddOrReplace("01932203", "80001331");
        Dict.AddOrReplace("01932200", "80001336");
        Dict.AddOrReplace("01932201", "80001338");
        Dict.AddOrReplace("01932202", "80001343");
        Dict.AddOrReplace("01932204", "80001345");
        Dict.AddOrReplace("01932205", "80001333");
        Dict.AddOrReplace("01932207", "80001347");
        Dict.AddOrReplace("01932212", "80001355");
        Dict.AddOrReplace("01932214", "80001387");
        Dict.AddOrReplace("01932216", "80001398");
        Dict.AddOrReplace("01932217", "80001329");
        Dict.AddOrReplace("01992029", "80001329");
        Dict.AddOrReplace("01932218", "80001411");
        Dict.AddOrReplace("01932220", "80001419");
        Dict.AddOrReplace("01932221", "80001421");
        Dict.AddOrReplace("01932223", "80001404");
        Dict.AddOrReplace("01932224", "80001435");
        Dict.AddOrReplace("01932228", "80001453");
        Dict.AddOrReplace("01932230", "80001454");
        Dict.AddOrReplace("01932232", "80001002");
        Dict.AddOrReplace("01932235", "80001484");
        Dict.AddOrReplace("01932236", "80001531");
        Dict.AddOrReplace("01932253", "80001531");
        Dict.AddOrReplace("01932237", "80001440");
        Dict.AddOrReplace("01932238", "80001441");
        Dict.AddOrReplace("01932239", "80001442");
        Dict.AddOrReplace("01932240", "80001443");
        Dict.AddOrReplace("01932241", "80001444");
        Dict.AddOrReplace("01932242", "80001445");
        Dict.AddOrReplace("01932243", "80001447");
        Dict.AddOrReplace("01932244", "80001508");
        Dict.AddOrReplace("01932247", "80001490");
        Dict.AddOrReplace("01932248", "80001491");
        Dict.AddOrReplace("01932249", "80001492");
        Dict.AddOrReplace("01932262", "80001492");
        Dict.AddOrReplace("01992043", "80001492");
        Dict.AddOrReplace("01932251", "80001505");
        Dict.AddOrReplace("01932252", "80001517");
        Dict.AddOrReplace("01932254", "80001549");
        Dict.AddOrReplace("01932256", "80001552");
        Dict.AddOrReplace("01932259", "80001557");
        Dict.AddOrReplace("01932261", "80001584");
        Dict.AddOrReplace("01932276", "80001584");
        Dict.AddOrReplace("01932263", "80001561");
        Dict.AddOrReplace("01932264", "80001562");
        Dict.AddOrReplace("01932265", "80001563");
        Dict.AddOrReplace("01932266", "80001564");
        Dict.AddOrReplace("01932267", "80001565");
        Dict.AddOrReplace("01932268", "80001566");
        Dict.AddOrReplace("01932269", "80001567");
        Dict.AddOrReplace("01932270", "80001568");
        Dict.AddOrReplace("01932271", "80001569");
        Dict.AddOrReplace("01932272", "80001570");
        Dict.AddOrReplace("01932273", "80001571");
        Dict.AddOrReplace("01932274", "80001572");
        Dict.AddOrReplace("01932275", "80001582");
        Dict.AddOrReplace("01932310", "80001582");
        Dict.AddOrReplace("01932333", "80001582");
        Dict.AddOrReplace("01932278", "80011111");
        Dict.AddOrReplace("01932279", "80001586");
        Dict.AddOrReplace("01932280", "80011127");
        Dict.AddOrReplace("01932281", "80001776");
        Dict.AddOrReplace("01932324", "80001776");
        Dict.AddOrReplace("01932282", "80011129");
        Dict.AddOrReplace("01932286", "80002257");
        Dict.AddOrReplace("01932429", "80002257");
        Dict.AddOrReplace("01932287", "80011135");
        Dict.AddOrReplace("01932288", "80001778");
        Dict.AddOrReplace("01932325", "80001778");
        Dict.AddOrReplace("01932289", "80001766");
        Dict.AddOrReplace("01932321", "80001766");
        Dict.AddOrReplace("01932294", "80001630");
        Dict.AddOrReplace("01932296", "80001630");
        Dict.AddOrReplace("01932300", "80001630");
        Dict.AddOrReplace("01932295", "80001631");
        Dict.AddOrReplace("01932298", "80001631");
        Dict.AddOrReplace("01932301", "80001631");
        Dict.AddOrReplace("01932297", "80001592");
        Dict.AddOrReplace("01932357", "80001592");
        Dict.AddOrReplace("01932304", "80001701");
        Dict.AddOrReplace("01932305", "80001703");
        Dict.AddOrReplace("01932306", "80001707");
        Dict.AddOrReplace("01932307", "80001708");
        Dict.AddOrReplace("01932311", "80001713");
        Dict.AddOrReplace("01932314", "80001507");
        Dict.AddOrReplace("01932319", "80001763");
        Dict.AddOrReplace("01932323", "80001775");
        Dict.AddOrReplace("01932334", "80001784");
        Dict.AddOrReplace("01932335", "80001786");
        Dict.AddOrReplace("01932336", "80001790");
        Dict.AddOrReplace("01932337", "80001792");
        Dict.AddOrReplace("01932338", "80001796");
        Dict.AddOrReplace("01932367", "80001796");
        Dict.AddOrReplace("01932341", "80001811");
        Dict.AddOrReplace("01932342", "80001813");
        Dict.AddOrReplace("01932460", "80001813");
        Dict.AddOrReplace("01932343", "80001866");
        Dict.AddOrReplace("01932344", "80001867");
        Dict.AddOrReplace("01932345", "80001868");
        Dict.AddOrReplace("01932346", "80011256");
        Dict.AddOrReplace("01932347", "80001870");
        Dict.AddOrReplace("01932353", "80001918");
        Dict.AddOrReplace("01932354", "80001920");
        Dict.AddOrReplace("01932358", "80001934");
        Dict.AddOrReplace("01932359", "80001935");
        Dict.AddOrReplace("01932360", "80001921");
        Dict.AddOrReplace("01932361", "80001923");
        Dict.AddOrReplace("01932362", "80001931");
        Dict.AddOrReplace("01932363", "80001932");
        Dict.AddOrReplace("01932367", "80001942");
        Dict.AddOrReplace("01932368", "80001950");
        Dict.AddOrReplace("01932371", "80001950");
        Dict.AddOrReplace("01932369", "80001951");
        Dict.AddOrReplace("01932372", "80001951");
        Dict.AddOrReplace("01932370", "80001952");
        Dict.AddOrReplace("01932373", "80001952");
        Dict.AddOrReplace("01932374", "80001956");
        Dict.AddOrReplace("01932375", "80001958");
        Dict.AddOrReplace("01932377", "80001975");
        Dict.AddOrReplace("01932378", "80001977");
        Dict.AddOrReplace("01932379", "80001980");
        Dict.AddOrReplace("01932380", "80001982");
        Dict.AddOrReplace("01932381", "80001986");
        Dict.AddOrReplace("01932382", "80001986");
        Dict.AddOrReplace("01932383", "80001988");
        Dict.AddOrReplace("01932526", "80001988");
        Dict.AddOrReplace("01932384", "80001989");
        Dict.AddOrReplace("01932385", "80001990");
        Dict.AddOrReplace("01932386", "80001991");
        Dict.AddOrReplace("01932387", "80001991");
        Dict.AddOrReplace("01932388", "80001993");
        Dict.AddOrReplace("01932389", "80002221");
        Dict.AddOrReplace("01932402", "80002221");
        Dict.AddOrReplace("01932390", "80011359");
        Dict.AddOrReplace("01932404", "80011359");
        Dict.AddOrReplace("01932391", "80001997");
        Dict.AddOrReplace("01932392", "80001995");
        Dict.AddOrReplace("01932393", "80002200");
        Dict.AddOrReplace("01932394", "80002201");
        Dict.AddOrReplace("01932395", "80002202");
        Dict.AddOrReplace("01932407", "80002202");
        Dict.AddOrReplace("01932590", "80002202");
        Dict.AddOrReplace("01932396", "80011395");
        Dict.AddOrReplace("01932397", "80011397");
        Dict.AddOrReplace("01932398", "80002219");
        Dict.AddOrReplace("01932399", "80002204");
        Dict.AddOrReplace("01932408", "80002204");
        Dict.AddOrReplace("01932400", "80002205");
        Dict.AddOrReplace("01932401", "80002220");
        Dict.AddOrReplace("01932403", "80002222");
        Dict.AddOrReplace("01932404", "80011405");
        Dict.AddOrReplace("01932405", "80002223");
        Dict.AddOrReplace("01932406", "80002225");
        Dict.AddOrReplace("01932409", "80002229");
        Dict.AddOrReplace("01932410", "80002233");
        Dict.AddOrReplace("01932411", "80002234");
        Dict.AddOrReplace("01932412", "80002235");
        Dict.AddOrReplace("01932413", "80011421");
        Dict.AddOrReplace("01932414", "80002236");
        Dict.AddOrReplace("01932415", "80002238");
        Dict.AddOrReplace("01932416", "80011424");
        Dict.AddOrReplace("01932418", "80002240");
        Dict.AddOrReplace("01932461", "80002240");
        Dict.AddOrReplace("01932419", "80002242");
        Dict.AddOrReplace("01932420", "80002244");
        Dict.AddOrReplace("01932421", "80002248");
        Dict.AddOrReplace("01932422", "80002250");
        Dict.AddOrReplace("01932423", "80002252");
        Dict.AddOrReplace("01932424", "80002252");
        Dict.AddOrReplace("01932425", "80011431");
        Dict.AddOrReplace("01932426", "80002270");
        Dict.AddOrReplace("01932427", "80002259");
        Dict.AddOrReplace("01932428", "80002258");
        Dict.AddOrReplace("01932430", "80002260");
        Dict.AddOrReplace("01932431", "80002262");
        Dict.AddOrReplace("01932432", "80002265");
        Dict.AddOrReplace("01932433", "80011438");
        Dict.AddOrReplace("01932434", "80002266");
        Dict.AddOrReplace("01932435", "80011443");
        Dict.AddOrReplace("01932436", "80011445");
        Dict.AddOrReplace("01932437", "80011447");
        Dict.AddOrReplace("01932438", "80002272");
        Dict.AddOrReplace("01932439", "80002271");
        Dict.AddOrReplace("01932440", "80011436");
        Dict.AddOrReplace("01932441", "80002276");
        Dict.AddOrReplace("01932442", "80002278");
        Dict.AddOrReplace("01932443", "80011451");
        Dict.AddOrReplace("01932444", "80011453");
        Dict.AddOrReplace("01932445", "80002287");
        Dict.AddOrReplace("01932446", "80002289");
        Dict.AddOrReplace("01932447", "80002315");
        Dict.AddOrReplace("01932448", "80002294");
        Dict.AddOrReplace("01932449", "80002296");
        Dict.AddOrReplace("01932450", "80002299");
        Dict.AddOrReplace("01932451", "80002203");
        Dict.AddOrReplace("01932452", "80002302");
        Dict.AddOrReplace("01932453", "80002304");
        Dict.AddOrReplace("01932454", "80002305");
        Dict.AddOrReplace("01932455", "80002307");
        Dict.AddOrReplace("01932456", "80011486");
        Dict.AddOrReplace("01932457", "80011488");
        Dict.AddOrReplace("01932458", "80002309");
        Dict.AddOrReplace("01932459", "80002313");
        Dict.AddOrReplace("01932462", "80002317");
        Dict.AddOrReplace("01932463", "80002318");
        Dict.AddOrReplace("01932464", "80002319");
        Dict.AddOrReplace("01932465", "80002321");
        Dict.AddOrReplace("01932466", "80011500");
        Dict.AddOrReplace("01932467", "80011502");
        Dict.AddOrReplace("01932468", "80002335");
        Dict.AddOrReplace("01932469", "80011506");
        Dict.AddOrReplace("01932470", "80002345");
        Dict.AddOrReplace("01932471", "80002347");
        Dict.AddOrReplace("01932472", "80002349");
        Dict.AddOrReplace("01932473", "80002349");
        Dict.AddOrReplace("01932474", "80002356");
        Dict.AddOrReplace("01932475", "80002358");
        Dict.AddOrReplace("01932476", "80002351");
        Dict.AddOrReplace("01932478", "80002351");
        Dict.AddOrReplace("01932477", "80002352");
        Dict.AddOrReplace("01932480", "80002352");
        Dict.AddOrReplace("01932479", "80002361");
        Dict.AddOrReplace("01932481", "80011531");
        Dict.AddOrReplace("01942382", "80011533");
        Dict.AddOrReplace("01932483", "80002367");
        Dict.AddOrReplace("01932484", "80011524");
        Dict.AddOrReplace("01942385", "80011535");
        Dict.AddOrReplace("01932486", "80002369");
        Dict.AddOrReplace("01942387", "80011546");
        Dict.AddOrReplace("01932488", "80002372");
        Dict.AddOrReplace("01932492", "80002372");
        Dict.AddOrReplace("01932489", "80002373");
        Dict.AddOrReplace("01932493", "80002373");
        Dict.AddOrReplace("01932490", "80002374");
        Dict.AddOrReplace("01932494", "80002374");
        Dict.AddOrReplace("01932491", "80002375");
        Dict.AddOrReplace("01932496", "80011541");
        Dict.AddOrReplace("01932497", "80002392");
        Dict.AddOrReplace("01932498", "80002400");
        Dict.AddOrReplace("01932499", "80002402");
        Dict.AddOrReplace("01932500", "80002417");
        Dict.AddOrReplace("01932501", "80002418");
        Dict.AddOrReplace("01932572", "80002418");
        Dict.AddOrReplace("01932502", "80011551");
        Dict.AddOrReplace("01932503", "80011554");
        Dict.AddOrReplace("01932530", "80011554");
        Dict.AddOrReplace("01932539", "80011554");
        Dict.AddOrReplace("01932504", "80002425");
        Dict.AddOrReplace("01932505", "80002425");
        Dict.AddOrReplace("01932506", "80002427");
        Dict.AddOrReplace("01932507", "80002429");
        Dict.AddOrReplace("01932511", "80002429");
        Dict.AddOrReplace("01932508", "80002431");
        Dict.AddOrReplace("01932509", "80011571");
        Dict.AddOrReplace("01932510", "80002433");
        Dict.AddOrReplace("01932511", "80002435");
        Dict.AddOrReplace("01932512", "80011580");
        Dict.AddOrReplace("01932513", "80002437");
        Dict.AddOrReplace("01932514", "80002439");
        Dict.AddOrReplace("01932515", "80002443");
        Dict.AddOrReplace("01932516", "80002441");
        Dict.AddOrReplace("01932517", "80002446");
        Dict.AddOrReplace("01932518", "80002447");
        Dict.AddOrReplace("01932519", "80011639");
        Dict.AddOrReplace("01932520", "80011642");
        Dict.AddOrReplace("01932521", "80002448");
        Dict.AddOrReplace("01932522", "80002450");
        Dict.AddOrReplace("01932523", "80011646");
        Dict.AddOrReplace("01932524", "80002454");
        Dict.AddOrReplace("01932525", "80002424");
        Dict.AddOrReplace("01932527", "80002546");
        Dict.AddOrReplace("01932528", "80002547");
        Dict.AddOrReplace("01932529", "80011698");
        Dict.AddOrReplace("01932535", "80002569");
        Dict.AddOrReplace("01932536", "80002569");
        Dict.AddOrReplace("01932537", "80002571");
        Dict.AddOrReplace("01932538", "80002573");
        Dict.AddOrReplace("01932540", "80002622");
        Dict.AddOrReplace("01932541", "80011712");
        Dict.AddOrReplace("01932542", "80002585");
        Dict.AddOrReplace("01932543", "80002628");
        Dict.AddOrReplace("01932544", "80002630");
        Dict.AddOrReplace("01932545", "80011706");
        Dict.AddOrReplace("01932546", "80002625");
        Dict.AddOrReplace("01932548", "80002625");
        Dict.AddOrReplace("01932549", "80002625");
        Dict.AddOrReplace("01932547", "80011721");
        Dict.AddOrReplace("01932550", "80002648");
        Dict.AddOrReplace("01932551", "80002650");
        Dict.AddOrReplace("01932552", "80002594");
        Dict.AddOrReplace("01932553", "80002595");
        Dict.AddOrReplace("01932554", "80011733");
        Dict.AddOrReplace("01932555", "80011737");
        Dict.AddOrReplace("01932556", "80002654");
        Dict.AddOrReplace("01932557", "80002655");
        Dict.AddOrReplace("01932559", "80011743");
        Dict.AddOrReplace("01932560", "80002659");
        Dict.AddOrReplace("01932562", "80002663");
        Dict.AddOrReplace("01932563", "80002665");
        Dict.AddOrReplace("01932564", "80002667");
        Dict.AddOrReplace("01932565", "80011758");
        Dict.AddOrReplace("01932566", "80011760");
        Dict.AddOrReplace("01932567", "80002668");
        Dict.AddOrReplace("01932569", "80002668");
        Dict.AddOrReplace("01932570", "80011784");
        Dict.AddOrReplace("01932571", "80002698");
        Dict.AddOrReplace("01932572", "80002699");
        Dict.AddOrReplace("01932573", "80002702");
        Dict.AddOrReplace("01932574", "80011773");
        Dict.AddOrReplace("01932575", "80011775");
        Dict.AddOrReplace("01932576", "80011777");
        Dict.AddOrReplace("01932577", "80011779");
        Dict.AddOrReplace("01932578", "80011798");
        Dict.AddOrReplace("01932579", "80011791");
        Dict.AddOrReplace("01932580", "80002712");
        Dict.AddOrReplace("01932581", "80002713");
        Dict.AddOrReplace("01932582", "80011806");
        Dict.AddOrReplace("01932583", "80011808");
        Dict.AddOrReplace("01932587", "80011819");
        Dict.AddOrReplace("01932588", "80011820");
        Dict.AddOrReplace("01932599", "80011825");
        Dict.AddOrReplace("01932600", "80011844");
        Dict.AddOrReplace("01932610", "80011850");
        Dict.AddOrReplace("01939000", "80001617");
        Dict.AddOrReplace("01939001", "80001619");
        Dict.AddOrReplace("01939002", "80001621");
        Dict.AddOrReplace("01939003", "80001623");
        Dict.AddOrReplace("01939004", "80001625");
        Dict.AddOrReplace("01939005", "80001627");
        Dict.AddOrReplace("01939006", "80001629");
        Dict.AddOrReplace("01939011", "80011732");
        Dict.AddOrReplace("01992015", "80001120");
        Dict.AddOrReplace("01992030", "80001330");
        Dict.AddOrReplace("01992031", "80001403");
        Dict.AddOrReplace("01932322", "80001769");
        Dict.AddOrReplace("01932416", "80001769");
        Dict.AddOrReplace("01932331", "80011238");
        Dict.AddOrReplace("01932558", "80002714");
        Dict.AddOrReplace("01932561", "80002661");
        Dict.AddOrReplace("01932584", "80002715");
        Dict.AddOrReplace("01932585", "80002717");
        Dict.AddOrReplace("01932586", "80002717");
        Dict.AddOrReplace("01932589", "80002735");
        Dict.AddOrReplace("01932590", "80002738");
        Dict.AddOrReplace("01932591", "80002736");
        Dict.AddOrReplace("01932592", "80011821");
        Dict.AddOrReplace("01932594", "80002740");
        Dict.AddOrReplace("01932595", "80002747");
        Dict.AddOrReplace("01932596", "80002752");
        Dict.AddOrReplace("01932597", "80002754");
        Dict.AddOrReplace("01932598", "80002756");
        Dict.AddOrReplace("01932601", "80002742");
        Dict.AddOrReplace("01932603", "80002742");
        Dict.AddOrReplace("01932603", "80002744");
        Dict.AddOrReplace("01932602", "80002743");
        Dict.AddOrReplace("01932612", "80002824");
        Dict.AddOrReplace("01932614", "80002843");
        Dict.AddOrReplace("01932615", "80002831");
        Dict.AddOrReplace("01932616", "80002845");
        Dict.AddOrReplace("01932617", "80002846");
        Dict.AddOrReplace("01932618", "80002853");
        Dict.AddOrReplace("01932619", "80002854");
        Dict.AddOrReplace("01992028", "80001296");


        for (int i = 0; i < MountListGrid.Rows.Count; i++)
        {
            string ID = MountListGrid.Rows[i].Cells[0].Value.ToString();
            if (Dict.ContainsKey(ID) && Wz.GetNode("String/Skill.img/" + Dict[ID]) != null)
                MountListGrid.Rows[i].Cells[2].Value = Wz.GetNode("String/Skill.img/" + Dict[ID]).GetStr("name");
        }

        Win32.SendMessage(MountListGrid.Handle, true);
        MountListGrid.Refresh();

        for (int i = 0; i < MountListGrid.Rows.Count; i++)
        {
            MountListGrid.Rows[i].Cells[1].Style.Alignment = DataGridViewContentAlignment.MiddleCenter;
            MountListGrid.Rows[i].Cells[2].Style.Alignment = DataGridViewContentAlignment.TopLeft;
        }


    }

    private void textBox1_TextChanged(object sender, EventArgs e)
    {
        MountListGrid.Search(textBox1.Text);
    }

    private void button1_Click(object sender, EventArgs e)
    {
        TamingMob.Remove();
        ItemEffect.Remove(EffectType.Chair);
        MapleChair.Remove();
        Game.Player.ResetAction = true;
        Game.Player.NewAction = Game.Player.StandType;
    }

    private void MountForm_KeyDown(object sender, KeyEventArgs e)
    {
        if (e.Alt)
            e.Handled = true;
        if (!textBox1.Focused)
            ActiveControl = null;

    }

    private void MountForm_ForeColorChanged(object sender, EventArgs e)
    {
        MainForm.Instance.ToolTipView.Visible = false;
    }
}

```

`MapleNecrocer/MountForm.resx`:

```resx
<root>
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`MapleNecrocer/NpcForm.Designer.cs`:

```cs
namespace MapleNecrocer
{
    partial class NpcForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            tabControl1 = new TabControl();
            tabPage1 = new TabPage();
            tabPage2 = new TabPage();
            pictureBox1 = new PictureBox();
            textBox2 = new TextBox();
            label2 = new Label();
            button2 = new Button();
            button1 = new Button();
            tabControl1.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)pictureBox1).BeginInit();
            SuspendLayout();
            // 
            // tabControl1
            // 
            tabControl1.Anchor = AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right;
            tabControl1.Controls.Add(tabPage1);
            tabControl1.Controls.Add(tabPage2);
            tabControl1.Location = new Point(9, 231);
            tabControl1.Name = "tabControl1";
            tabControl1.SelectedIndex = 0;
            tabControl1.Size = new Size(260, 457);
            tabControl1.TabIndex = 9;
            // 
            // tabPage1
            // 
            tabPage1.Location = new Point(4, 28);
            tabPage1.Name = "tabPage1";
            tabPage1.Padding = new Padding(3);
            tabPage1.Size = new Size(252, 425);
            tabPage1.TabIndex = 0;
            tabPage1.Text = "tabPage1";
            tabPage1.UseVisualStyleBackColor = true;
            // 
            // tabPage2
            // 
            tabPage2.Location = new Point(4, 28);
            tabPage2.Name = "tabPage2";
            tabPage2.Padding = new Padding(3);
            tabPage2.Size = new Size(252, 325);
            tabPage2.TabIndex = 1;
            tabPage2.Text = "tabPage2";
            tabPage2.UseVisualStyleBackColor = true;
            // 
            // pictureBox1
            // 
            pictureBox1.BorderStyle = BorderStyle.FixedSingle;
            pictureBox1.Location = new Point(9, 3);
            pictureBox1.Name = "pictureBox1";
            pictureBox1.Size = new Size(248, 153);
            pictureBox1.SizeMode = PictureBoxSizeMode.CenterImage;
            pictureBox1.TabIndex = 8;
            pictureBox1.TabStop = false;
            // 
            // textBox2
            // 
            textBox2.Font = new Font("Arial", 13F, FontStyle.Regular, GraphicsUnit.Pixel);
            textBox2.Location = new Point(75, 198);
            textBox2.Name = "textBox2";
            textBox2.Size = new Size(185, 22);
            textBox2.TabIndex = 15;
            textBox2.TextChanged += textBox2_TextChanged;
            // 
            // label2
            // 
            label2.AutoSize = true;
            label2.Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            label2.Location = new Point(17, 203);
            label2.Name = "label2";
            label2.Size = new Size(52, 18);
            label2.TabIndex = 14;
            label2.Text = "Search";
            // 
            // button2
            // 
            button2.Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            button2.Location = new Point(188, 165);
            button2.Name = "button2";
            button2.Size = new Size(70, 28);
            button2.TabIndex = 13;
            button2.Text = "Remove";
            button2.UseVisualStyleBackColor = true;
            button2.Click += button2_Click;
            // 
            // button1
            // 
            button1.Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            button1.Location = new Point(14, 162);
            button1.Name = "button1";
            button1.Size = new Size(61, 28);
            button1.TabIndex = 10;
            button1.Text = "Drop";
            button1.UseVisualStyleBackColor = true;
            button1.Click += button1_Click;
            // 
            // NpcForm
            // 
            AutoScaleMode = AutoScaleMode.None;
            ClientSize = new Size(272, 692);
            Controls.Add(tabControl1);
            Controls.Add(pictureBox1);
            Controls.Add(textBox2);
            Controls.Add(label2);
            Controls.Add(button2);
            Controls.Add(button1);
            KeyPreview = true;
            MaximumSize = new Size(290, 2000);
            Name = "NpcForm";
            StartPosition = FormStartPosition.CenterScreen;
            Text = "Npc";
            TopMost = true;
            FormClosing += NpcForm_FormClosing;
            Shown += NpcForm_Shown;
            KeyDown += NpcForm_KeyDown;
            tabControl1.ResumeLayout(false);
            ((System.ComponentModel.ISupportInitialize)pictureBox1).EndInit();
            ResumeLayout(false);
            PerformLayout();
        }

        #endregion

        private TabControl tabControl1;
        private TabPage tabPage1;
        private TabPage tabPage2;
        private PictureBox pictureBox1;
        private TextBox textBox2;
        private Label label2;
        private Button button2;
        private Button button1;
    }
}
```

`MapleNecrocer/NpcForm.cs`:

```cs
using WzComparerR2.WzLib;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace MapleNecrocer;

public partial class NpcForm : Form
{
    public NpcForm()
    {
        InitializeComponent();
        Instance = this;
    }

    public static NpcForm Instance;
    public DataGridViewEx NpcListGrid;
    string NpcID;

    void CellClick(BaseDataGridView DataGrid, DataGridViewCellEventArgs e)
    {
        NpcID = DataGrid.Rows[e.RowIndex].Cells[0].Value.ToString();
        var Link = Wz.GetNode("Npc/" + NpcID + ".img/info/link");
        if (Link != null)
        {
            NpcID = Link.ToStr();

        }
        Bitmap Bitmap;
        if (Wz.GetNodeA("Npc/" + NpcID + ".img/stand/0") != null)
            Bitmap = Wz.GetNode("Npc/" + NpcID + ".img/stand/0").ExtractPng();
        else if ((Wz.GetNodeA("Npc/" + NpcID + ".img/fly/0") != null))
            Bitmap = Wz.GetNode("Npc/" + NpcID + ".img/fly/0").ExtractPng();
        else
            return;
        pictureBox1.Image = Bitmap;


    }

    private void NpcForm_Shown(object sender, EventArgs e)
    {
        this.FormClosing += (s, e1) =>
        {
            this.Hide();
            e1.Cancel = true;
        };


        NpcListGrid = new(60, 164, 0, 0, 220, 400, false, tabControl1.TabPages[0]);
        NpcListGrid.Dock = DockStyle.Fill;
        NpcListGrid.SearchGrid.Dock = DockStyle.Fill;

        var Graphic = NpcListGrid.CreateGraphics();
        var Font = new System.Drawing.Font(FontFamily.GenericSansSerif, 20, FontStyle.Bold);
        Graphic.DrawString("Loading...", Font, Brushes.Black, 10, 50);


        NpcListGrid.CellClick += (s, e) =>
        {
            CellClick(NpcListGrid, e);
        };

        NpcListGrid.SearchGrid.CellClick += (s, e) =>
        {
            CellClick(NpcListGrid.SearchGrid, e);
        };

        NpcListGrid.SetToolTipEvent(WzType.Npc, this);

        string ID = null;
        string Name = null;
        Win32.SendMessage(NpcListGrid.Handle, false);
        foreach (var Iter in MainForm.TreeNode.Nodes["Npc"].Nodes)
        {
            if (!Char.IsNumber(Iter.Text, 0))
                continue;
            ID = Iter.Text.LeftStr(7);
            if (Wz.GetNodeA("String/Npc.img/" + ID.IntID()) != null)
                Name = Wz.GetNodeA("String/Npc.img/" + ID.IntID()).GetStr("name");
            NpcListGrid.Rows.Add(ID, Name);

        }
        Win32.SendMessage(NpcListGrid.Handle, true);
        NpcListGrid.Refresh();



    }

    private void textBox2_TextChanged(object sender, EventArgs e)
    {
        NpcListGrid.Search(textBox2.Text);
    }

    private void button1_Click(object sender, EventArgs e)
    {

        if (Wz.GetNode("Npc/" + NpcID + ".img") == null)
            return;
        Random Random = new Random();
        Random RandomFlip = new Random();
        int Flip = RandomFlip.Next(0, 2);
        int Range = Random.Next((int)Game.Player.X - 100, (int)Game.Player.X + 100);
        if (Range > Map.Left && Range < Map.Right)
        {
            Npc.Spawn(NpcID, Range, (int)Game.Player.Y - 100, Flip);
            Npc.SummonedList.Add(NpcID);
        }

    }

    private void button2_Click(object sender, EventArgs e)
    {
        foreach (var Iter in EngineFunc.SpriteEngine.SpriteList)
        {
            if (Iter is Npc)
            {
                for (int I = 0; I < Npc.SummonedList.Count; I++)
                {
                    if (((Npc)Iter).LocalID == Npc.SummonedList[I])
                    {
                        Iter.Dead();
                        if (((Npc)Iter).Balloon != null)
                            ((Npc)Iter).Balloon.Dead();

                    }
                }
            }

            if (Iter is NpcText)
            {
                for (int I = 0; I < Npc.SummonedList.Count; I++)
                {
                    if (((NpcText)Iter).ID.RightStr(7) == Npc.SummonedList[I])
                    {
                        Iter.Dead();
                    }
                }
            }
        }
        EngineFunc.SpriteEngine.Dead();
    }

    private void NpcForm_KeyDown(object sender, KeyEventArgs e)
    {
        if (e.Alt)
            e.Handled = true;
        if (!textBox2.Focused)
            ActiveControl = null;
    }

    private void NpcForm_FormClosing(object sender, FormClosingEventArgs e)
    {
        MainForm.Instance.ToolTipView.Visible = false;
    }
}

```

`MapleNecrocer/NpcForm.resx`:

```resx
<root>
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`MapleNecrocer/ObjInfoForm.Designer.cs`:

```cs
namespace MapleNecrocer
{
    partial class ObjInfoForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            dataGridView1 = new DataGridView();
            label1 = new Label();
            button1 = new Button();
            button2 = new Button();
            ((System.ComponentModel.ISupportInitialize)dataGridView1).BeginInit();
            SuspendLayout();
            // 
            // dataGridView1
            // 
            dataGridView1.AllowUserToAddRows = false;
            dataGridView1.AllowUserToResizeColumns = false;
            dataGridView1.AllowUserToResizeRows = false;
            dataGridView1.ColumnHeadersHeightSizeMode = DataGridViewColumnHeadersHeightSizeMode.AutoSize;
            dataGridView1.ColumnHeadersVisible = false;
            dataGridView1.Location = new Point(11, 44);
            dataGridView1.Name = "dataGridView1";
            dataGridView1.RowHeadersVisible = false;
            dataGridView1.RowHeadersWidth = 51;
            dataGridView1.RowTemplate.Height = 29;
            dataGridView1.Size = new Size(675, 669);
            dataGridView1.TabIndex = 0;
            dataGridView1.CellClick += dataGridView1_CellClick;
            // 
            // label1
            // 
            label1.AutoSize = true;
            label1.Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            label1.Location = new Point(12, 25);
            label1.Name = "label1";
            label1.Size = new Size(18, 18);
            label1.TabIndex = 1;
            label1.Text = "  ";
            // 
            // button1
            // 
            button1.Font = new Font("Tahoma", 13F, FontStyle.Regular, GraphicsUnit.Pixel);
            button1.Location = new Point(501, 12);
            button1.Name = "button1";
            button1.Size = new Size(78, 28);
            button1.TabIndex = 2;
            button1.Text = "Save";
            button1.UseVisualStyleBackColor = true;
            button1.Click += button1_Click;
            // 
            // button2
            // 
            button2.Font = new Font("Tahoma", 13F, FontStyle.Regular, GraphicsUnit.Pixel);
            button2.Location = new Point(598, 12);
            button2.Name = "button2";
            button2.Size = new Size(85, 28);
            button2.TabIndex = 3;
            button2.Text = "Save All";
            button2.UseVisualStyleBackColor = true;
            button2.Click += button2_Click;
            // 
            // ObjInfoForm
            // 
            AutoScaleMode = AutoScaleMode.None;
            ClientSize = new Size(695, 725);
            Controls.Add(button2);
            Controls.Add(button1);
            Controls.Add(label1);
            Controls.Add(dataGridView1);
            Font = new Font("Tahoma", 13F, FontStyle.Regular, GraphicsUnit.Point);
            KeyPreview = true;
            MaximizeBox = false;
            Name = "ObjInfoForm";
            StartPosition = FormStartPosition.CenterScreen;
            Text = "ObjInfo";
            TopMost = true;
            Shown += ObjInfoForm_Shown;
            ((System.ComponentModel.ISupportInitialize)dataGridView1).EndInit();
            ResumeLayout(false);
            PerformLayout();
        }

        #endregion

        private DataGridView dataGridView1;
        private Label label1;
        private Button button1;
        private Button button2;
    }
}
```

`MapleNecrocer/ObjInfoForm.cs`:

```cs
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Drawing.Imaging;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using WzComparerR2.WzLib;

namespace MapleNecrocer;

public partial class ObjInfoForm : Form
{
    public ObjInfoForm()
    {
        InitializeComponent();
        Instance = this;
    }
    public static ObjInfoForm Instance;
    public DataGridViewEx ObjInfoListGrid;
    Dictionary<string, Image> Images = new Dictionary<string, Image>();

    public void DumpObjs()
    {
        Images.Clear();
        //obj
        for (int Layer = 0; Layer <= 7; Layer++)
        {
            foreach (var Iter in Map.Img.GetNode(Layer.ToString() + "/obj").Nodes)
            {
                var oS = Iter.GetValue2("oS", "");
                var L0 = Iter.GetValue2("l0", "");
                var L1 = Iter.GetValue2("l1", "");
                var L2 = Iter.GetValue2("l2", "");
                if (oS == "")
                    continue;
                var ObjNode = Wz.GetNode("Map/Obj/" + oS + ".img/" + L0 + "/" + L1 + "/" + L2);
                if (ObjNode != null)
                {
                    foreach (var Iter2 in ObjNode.Nodes)
                    {
                        if (Wz.GetNode(Iter2.FullPathToFile2()).Value is Wz_Png)
                            Images.AddOrReplace(Iter2.FullPathToFile2(), Wz.GetNode(Iter2.FullPathToFile2()).ExtractPng());
                    }
                }
            }
        }
        //back
        Wz_Node BackEntry, AniBackEntry;
        foreach (var Iter in Map.Img.GetNode("back").Nodes)
        {
            var bS = Iter.GetValue2("bS", "");
            if (bS == "")
                continue;
            var No = Iter.GetValue2("no", "0");
            var Ani = Iter.GetValue2("ani", "0");
            if (int.Parse(Ani) > 1)
                Ani = "0";
            if (Ani == "0")
            {
                BackEntry = Wz.GetNode("Map/Back/" + bS + ".img/back/" + No);
                if (BackEntry == null)
                    continue;
                Images.AddOrReplace(BackEntry.FullPathToFile2(), Wz.GetNode(BackEntry.FullPathToFile2()).ExtractPng());
            }

            if (Ani == "1")
            {
                AniBackEntry = Wz.GetNode("Map/Back/" + bS + ".img/ani/" + No);
                if (AniBackEntry == null)
                    continue;
                foreach (var Iter2 in AniBackEntry.Nodes)
                {
                    Images.AddOrReplace(Iter2.FullPathToFile2(), Wz.GetNode(Iter2.FullPathToFile2()).ExtractPng());
                }
            }
        }

        //tile
        var tS = "";
        for (int Layer = 0; Layer <= 7; Layer++)
        {
            var tSNode = Map.Img.GetNode(Layer.ToString() + "/info/tS");
            if (tSNode == null)
                continue;
            else
                tS = tSNode.Value.ToString();
            foreach (var Iter in Map.Img.GetNode(Layer.ToString() + "/tile").Nodes)
            {
                var u = Iter.GetValue2("u", "");
                var no = Iter.GetValue2("no", "");
                var Entry = Wz.GetNode("Map/Tile/" + tS + ".img/" + u + "/" + no);
                if (Entry != null)
                {
                    if (!Images.ContainsKey(Entry.FullPathToFile2()))
                        Images.Add(Entry.FullPathToFile2(), Wz.GetNode(Entry.FullPathToFile2()).ExtractPng());
                }
            }
        }

        LoadImages(dataGridView1, 73, true);
    }

    void LoadImages(DataGridView dataViewImages, int GridSize, bool Resize = false)
    {
        dataViewImages.Rows.Clear();
        dataViewImages.Columns.Clear();
        // dataViewImages.Refresh();
        int numColumnsForWidth = (dataViewImages.Width - 10) / (GridSize + 20);
        int numRows = 0;
        int numImages = Images.Count;
        numRows = numImages / numColumnsForWidth;

        if (numImages % numColumnsForWidth > 0)
        {
            numRows += 1;
        }
        if (numImages < numColumnsForWidth)
        {
            numColumnsForWidth = numImages;
        }
        int numGeneratedCells = numRows * numColumnsForWidth;
        // Dynamically create the columns
        for (int index = 0; index < numColumnsForWidth; index++)
        {
            DataGridViewImageColumn dataGridViewColumn = new DataGridViewImageColumn();
            dataViewImages.Columns.Add(dataGridViewColumn);
            dataViewImages.Columns[index].Width = GridSize + 20;
        }
        // Create the rows
        for (int index = 0; index < numRows; index++)
        {
            dataViewImages.Rows.Add();
            dataViewImages.Rows[index].Height = GridSize + 20;
        }

        int columnIndex = 0;
        int rowIndex = 0;
        Image image;
        foreach (var Iter in Images.Keys)
        {
            image = Images[Iter];
            if (Resize)
            {
                if (image.Width > 90 || image.Height > 90)
                    image = ResizeImage2(image, 70, 70);
            }
            dataViewImages.Rows[rowIndex].Cells[columnIndex].Value = image;
            dataViewImages.Rows[rowIndex].Cells[columnIndex].ToolTipText = Iter.ToString();

            if (columnIndex == numColumnsForWidth - 1)
            {
                rowIndex++;
                columnIndex = 0;
            }
            else
            {
                columnIndex++;
            }
        }
    }
    public Bitmap ResizeImage2(Image image, int width, int height)
    {
        var destRect = new Rectangle(0, 0, width, height);
        var destImage = new Bitmap(width, height);
        destImage.SetResolution(image.HorizontalResolution, image.VerticalResolution);
        using (var graphics = Graphics.FromImage(destImage))
        {
            graphics.CompositingMode = CompositingMode.SourceCopy;
            graphics.CompositingQuality = CompositingQuality.HighQuality;
            graphics.InterpolationMode = InterpolationMode.HighQualityBicubic;
            graphics.SmoothingMode = SmoothingMode.HighQuality;
            graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;

            using (var wrapMode = new ImageAttributes())
            {
                wrapMode.SetWrapMode(WrapMode.TileFlipXY);
                graphics.DrawImage(image, destRect, 0, 0, image.Width, image.Height, GraphicsUnit.Pixel, wrapMode);
            }
        }
        return destImage;
    }

    private void ObjInfoForm_Shown(object sender, EventArgs e)
    {
        DumpObjs();
    }

    private void dataGridView1_CellClick(object sender, DataGridViewCellEventArgs e)
    {
        label1.Text = dataGridView1.Rows[e.RowIndex].Cells[e.ColumnIndex].ToolTipText;
    }

    private void button1_Click(object sender, EventArgs e)
    {
        var dlg = new FolderBrowserDialog();
        dlg.SelectedPath = System.Environment.CurrentDirectory;
        dlg.Description = "選擇儲存路徑";
        if ((dlg.ShowDialog(new Form() { TopMost = true }) != DialogResult.OK))
            return;
        var Path1 = label1.Text;
        var Path2 = Path1;
        Path2 = Path2.Replace("/", ".");
        Images[Path1].Save(dlg.SelectedPath + "\\" + Path2 + ".png");
    }

    private void button2_Click(object sender, EventArgs e)
    {
        var dlg = new FolderBrowserDialog();
        dlg.SelectedPath = System.Environment.CurrentDirectory;
        dlg.Description = "選擇儲存路徑";
        if ((dlg.ShowDialog(new Form() { TopMost = true }) != DialogResult.OK))
            return;
        foreach (var Iter in Images.Keys)
        {
            var Path = Iter.ToString();
            Path = Path.Replace("/", ".");
            Images[Iter].Save(dlg.SelectedPath + "\\" + Path + ".png");
        }
    }
}

```

`MapleNecrocer/ObjInfoForm.resx`:

```resx
<root>
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`MapleNecrocer/OptionForm.Designer.cs`:

```cs
namespace MapleNecrocer
{
    partial class OptionForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            checkBox1 = new CheckBox();
            SuspendLayout();
            // 
            // checkBox1
            // 
            checkBox1.AutoSize = true;
            checkBox1.Location = new Point(89, 53);
            checkBox1.Name = "checkBox1";
            checkBox1.Size = new Size(63, 22);
            checkBox1.TabIndex = 0;
            checkBox1.Text = "Mute";
            checkBox1.UseVisualStyleBackColor = true;
            checkBox1.CheckedChanged += checkBox1_CheckedChanged;
            // 
            // OptionForm
            // 
            AutoScaleMode = AutoScaleMode.None;
            ClientSize = new Size(289, 126);
            Controls.Add(checkBox1);
            Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            KeyPreview = true;
            MaximizeBox = false;
            MinimizeBox = false;
            Name = "OptionForm";
            StartPosition = FormStartPosition.CenterScreen;
            Text = "Option";
            TopMost = true;
            Shown += OptionForm_Shown;
            KeyDown += OptionForm_KeyDown;
            ResumeLayout(false);
            PerformLayout();
        }

        #endregion

        private CheckBox checkBox1;
    }
}
```

`MapleNecrocer/OptionForm.cs`:

```cs
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace MapleNecrocer;

public partial class OptionForm : Form
{
    public OptionForm()
    {
        InitializeComponent();
        Instance = this;
    }
    public static OptionForm Instance;
    private void checkBox1_CheckedChanged(object sender, EventArgs e)
    {
        if (checkBox1.Checked)
            Music.Pause();
        else
            Music.Resume();
    }

    private void OptionForm_Shown(object sender, EventArgs e)
    {
        this.FormClosing += (s, e1) =>
        {
            this.Hide();
            e1.Cancel = true;
        };
    }

    private void OptionForm_KeyDown(object sender, KeyEventArgs e)
    {
        if (e.Alt)
            e.Handled = true;

        ActiveControl = null;
    }
}

```

`MapleNecrocer/OptionForm.resx`:

```resx
<root>
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`MapleNecrocer/PetForm.Designer.cs`:

```cs
namespace MapleNecrocer
{
    partial class PetForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            panel1 = new Panel();
            panel2 = new Panel();
            label1 = new Label();
            textBox1 = new TextBox();
            button1 = new Button();
            label2 = new Label();
            SuspendLayout();
            // 
            // panel1
            // 
            panel1.Anchor = AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left;
            panel1.Location = new Point(12, 46);
            panel1.Name = "panel1";
            panel1.Size = new Size(337, 594);
            panel1.TabIndex = 0;
            // 
            // panel2
            // 
            panel2.Anchor = AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right;
            panel2.Location = new Point(368, 46);
            panel2.Name = "panel2";
            panel2.Size = new Size(341, 594);
            panel2.TabIndex = 1;
            // 
            // label1
            // 
            label1.AutoSize = true;
            label1.Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            label1.Location = new Point(12, 18);
            label1.Name = "label1";
            label1.Size = new Size(52, 18);
            label1.TabIndex = 2;
            label1.Text = "Search";
            // 
            // textBox1
            // 
            textBox1.Location = new Point(73, 18);
            textBox1.Name = "textBox1";
            textBox1.Size = new Size(117, 23);
            textBox1.TabIndex = 3;
            textBox1.TextChanged += textBox1_TextChanged;
            // 
            // button1
            // 
            button1.Location = new Point(245, 13);
            button1.Name = "button1";
            button1.Size = new Size(80, 28);
            button1.TabIndex = 4;
            button1.Text = "Remove";
            button1.UseVisualStyleBackColor = true;
            button1.Click += button1_Click;
            // 
            // label2
            // 
            label2.AutoSize = true;
            label2.Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            label2.Location = new Point(488, 19);
            label2.Name = "label2";
            label2.Size = new Size(68, 18);
            label2.TabIndex = 5;
            label2.Text = "Pet Equip";
            // 
            // PetForm
            // 
            AutoScaleMode = AutoScaleMode.None;
            ClientSize = new Size(721, 652);
            Controls.Add(label2);
            Controls.Add(button1);
            Controls.Add(textBox1);
            Controls.Add(label1);
            Controls.Add(panel2);
            Controls.Add(panel1);
            Font = new Font("Tahoma", 13F, FontStyle.Regular, GraphicsUnit.Pixel);
            KeyPreview = true;
            MaximumSize = new Size(739, 1000);
            Name = "PetForm";
            StartPosition = FormStartPosition.CenterScreen;
            Text = "PetForm";
            TopMost = true;
            FormClosing += PetForm_FormClosing;
            Shown += PetForm_Shown;
            KeyDown += PetForm_KeyDown;
            ResumeLayout(false);
            PerformLayout();
        }

        #endregion

        private Panel panel1;
        private Panel panel2;
        private Label label1;
        private TextBox textBox1;
        private Button button1;
        private Label label2;
    }
}
```

`MapleNecrocer/PetForm.cs`:

```cs
using DevComponents.DotNetBar;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace MapleNecrocer;

public partial class PetForm : Form
{
    public PetForm()
    {
        InitializeComponent();
        Instance = this;
    }
    public static PetForm Instance;
    public DataGridViewEx PetListGrid, PetEquipListGrid;
    public static string PetID;
  

    void CellClick(BaseDataGridView DataGrid, DataGridViewCellEventArgs e)
    {
        PetID = DataGrid.Rows[e.RowIndex].Cells[0].Value.ToString();
        PetNameTag.Remove();
        Pet.Remove();
        PetEquip.Remove();
        Pet.Create(PetID);

        if (PetID == "5002120" || PetID == "5002125" || PetID == "5002126" || PetID == "5002189" || PetID == "5002190")
        {
            return;
        }
        else
        {
            if (Wz.HasNode("UI/NameTag.img/pet"))
            {
                PetNameTag.Create(PetID);
                PetNameTag.Instance.MedalName = DataGrid.Rows[e.RowIndex].Cells[2].Value.ToString();
                PetNameTag.Instance.InitData();
                PetNameTag.ReDraw();
            }
        }

        PetEquipListGrid.Rows.Clear();
        string EquipName = null;
        Bitmap Bmp = null;
        foreach (var Img in Wz.GetNodes("Character/PetEquip"))
        {
            foreach (var Iter in Wz.GetNodes("Character/PetEquip/" + Img.Text))
            {
                if (PetID != "" && Iter.Text == PetID)
                {
                    string ID = Img.ImgID();
                    if (Wz.HasNode("String/Eqp.img/Eqp/PetEquip/" + ID.IntID()))
                        EquipName = Wz.GetStr("String/Eqp.img/Eqp/PetEquip/" + ID.IntID() + "/name");
                    Bmp = Wz.GetBmp("Character/PetEquip/" + Img.Text + "/info/icon");
                    PetEquipListGrid.Rows.Add(ID, Bmp, EquipName);
                }
            }
        }

        for (int i = 0; i < PetEquipListGrid.Rows.Count; i++)
        {
            PetEquipListGrid.Rows[i].Cells[1].Style.Alignment = DataGridViewContentAlignment.MiddleCenter;
            PetEquipListGrid.Rows[i].Cells[2].Style.Alignment = DataGridViewContentAlignment.TopLeft;
        }
    }

    void CellClick2(BaseDataGridView DataGrid, DataGridViewCellEventArgs e)
    {
        var ID = DataGrid.Rows[e.RowIndex].Cells[0].Value.ToString();
        PetEquip.Remove();
        PetEquip.Create(ID);
    }

    private void PetForm_Shown(object sender, EventArgs e)
    {
        this.FormClosing += (s, e1) =>
        {
            this.Hide();
            e1.Cancel = true;
        };
        PetListGrid = new(80, 179, 0, 0, 220, 400, true, panel1);

        PetListGrid.Dock = DockStyle.Fill;
        PetListGrid.SearchGrid.Dock = DockStyle.Fill;
        PetListGrid.RowTemplate.Height = 40;

        PetEquipListGrid = new(90, 179, 0, 0, 220, 400, true, panel2);
        PetEquipListGrid.Dock = DockStyle.Fill;
        PetEquipListGrid.SearchGrid.Dock = DockStyle.Fill;
        PetEquipListGrid.RowTemplate.Height = 40;

        var Graphic = PetListGrid.CreateGraphics();
        var Font = new System.Drawing.Font(FontFamily.GenericSansSerif, 20, FontStyle.Bold);
        Graphic.DrawString("Loading...", Font, Brushes.Black, 10, 50);
        PetListGrid.CellClick += (s, e) =>
        {
            CellClick(PetListGrid, e);
        };

        PetListGrid.SearchGrid.CellClick += (s, e) =>
        {
            CellClick(PetListGrid.SearchGrid, e);
        };

        PetEquipListGrid.CellClick += (s, e) =>
        {
            CellClick2(PetEquipListGrid, e);
        };

        PetListGrid.SetToolTipEvent(WzType.Item, this);

        string PetName = null;
        Bitmap Bmp = null;
        foreach (var Img in Wz.GetNodes("Item/Pet"))
        {
            if (!Char.IsNumber(Img.Text, 0))
                continue;
            string ID = Img.ImgID();
            if (Wz.HasNode("String/Pet.img/" + ID))
                PetName = Wz.GetStr("String/Pet.img/" + ID + "/name");
            if (Wz.HasNode("String/Item.img/Pet/" + ID))
                PetName = Wz.GetStr("String/Item.img/Pet/" + ID + "/name");
            Bmp = Wz.GetBmp("Item/Pet/" + Img.Text + "/info/iconD");
            PetListGrid.Rows.Add(ID, Bmp, PetName);
        }
        for (int i = 0; i < PetListGrid.Rows.Count; i++)
        {
            PetListGrid.Rows[i].Cells[1].Style.Alignment = DataGridViewContentAlignment.MiddleCenter;
            PetListGrid.Rows[i].Cells[2].Style.Alignment = DataGridViewContentAlignment.TopLeft;
        }
    }

    private void PetForm_KeyDown(object sender, KeyEventArgs e)
    {
        if (e.Alt)
            e.Handled = true;
        if (!textBox1.Focused)
            ActiveControl = null;
    }

    private void textBox1_TextChanged(object sender, EventArgs e)
    {
        PetListGrid.Search(textBox1.Text);
    }

    private void button1_Click(object sender, EventArgs e)
    {
        Pet.Remove();
        PetNameTag.Remove();
    }

    private void PetForm_FormClosing(object sender, FormClosingEventArgs e)
    {
        MainForm.Instance.ToolTipView.Visible = false;
    }
}

```

`MapleNecrocer/PetForm.resx`:

```resx
<root>
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`MapleNecrocer/Program.cs`:

```cs
global using MonoGame.SpriteEngine;
global using WzComparerR2.Common;
using System.Runtime.InteropServices;

namespace MapleNecrocer;
internal static class Program
{
  

    ///  The main entry point for the application.
    /// </summary>
    [STAThread]
    static void Main()
    {
        // To customize application configuration such as set high DPI settings or default font,
        // see https://aka.ms/applicationconfiguration.
        Application.SetHighDpiMode(HighDpiMode.PerMonitor);
               
        ApplicationConfiguration.Initialize();
    
        Application.Run(new MainForm());
    }
}
```

`MapleNecrocer/Properties/Resources.Designer.cs`:

```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     這段程式碼是由工具產生的。
//     執行階段版本:4.0.30319.42000
//
//     對這個檔案所做的變更可能會造成錯誤的行為，而且如果重新產生程式碼，
//     變更將會遺失。
// </auto-generated>
//------------------------------------------------------------------------------

namespace MapleNecrocer.Properties {
    using System;
    
    
    /// <summary>
    ///   用於查詢當地語系化字串等的強類型資源類別。
    /// </summary>
    // 這個類別是自動產生的，是利用 StronglyTypedResourceBuilder
    // 類別透過 ResGen 或 Visual Studio 這類工具。
    // 若要加入或移除成員，請編輯您的 .ResX 檔，然後重新執行 ResGen
    // (利用 /str 選項)，或重建您的 VS 專案。
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   傳回這個類別使用的快取的 ResourceManager 執行個體。
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("MapleNecrocer.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   覆寫目前執行緒的 CurrentUICulture 屬性，對象是所有
        ///   使用這個強類型資源類別的資源查閱。
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   查詢類型 System.Drawing.Bitmap 的當地語系化資源。
        /// </summary>
        internal static System.Drawing.Bitmap _01050088_img_info_iconRaw {
            get {
                object obj = ResourceManager.GetObject("01050088.img.info.iconRaw", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
    }
}

```

`MapleNecrocer/Properties/Resources.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <assembly alias="System.Windows.Forms" name="System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />
  <data name="01050088.img.info.iconRaw" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\01050088.img.info.iconRaw.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
</root>
```

`MapleNecrocer/ReactorForm.Designer.cs`:

```cs
namespace MapleNecrocer
{
    partial class ReactorForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            button2 = new Button();
            button1 = new Button();
            pictureBox1 = new PictureBox();
            panel1 = new Panel();
            label1 = new Label();
            textBox1 = new TextBox();
            ((System.ComponentModel.ISupportInitialize)pictureBox1).BeginInit();
            SuspendLayout();
            // 
            // button2
            // 
            button2.Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            button2.Location = new Point(166, 180);
            button2.Name = "button2";
            button2.Size = new Size(70, 28);
            button2.TabIndex = 9;
            button2.Text = "Remove";
            button2.UseVisualStyleBackColor = true;
            button2.Click += button2_Click;
            // 
            // button1
            // 
            button1.Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            button1.Location = new Point(56, 180);
            button1.Name = "button1";
            button1.Size = new Size(69, 28);
            button1.TabIndex = 8;
            button1.Text = "Drop";
            button1.UseVisualStyleBackColor = true;
            button1.Click += button1_Click;
            // 
            // pictureBox1
            // 
            pictureBox1.BorderStyle = BorderStyle.FixedSingle;
            pictureBox1.Location = new Point(12, 7);
            pictureBox1.Name = "pictureBox1";
            pictureBox1.Size = new Size(285, 167);
            pictureBox1.SizeMode = PictureBoxSizeMode.CenterImage;
            pictureBox1.TabIndex = 6;
            pictureBox1.TabStop = false;
            // 
            // panel1
            // 
            panel1.Anchor = AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right;
            panel1.Location = new Point(8, 244);
            panel1.Name = "panel1";
            panel1.Size = new Size(292, 392);
            panel1.TabIndex = 10;
            // 
            // label1
            // 
            label1.AutoSize = true;
            label1.Location = new Point(50, 217);
            label1.Name = "label1";
            label1.Size = new Size(52, 18);
            label1.TabIndex = 12;
            label1.Text = "Search";
            // 
            // textBox1
            // 
            textBox1.Font = new Font("Tahoma", 13F, FontStyle.Regular, GraphicsUnit.Pixel);
            textBox1.Location = new Point(108, 215);
            textBox1.Name = "textBox1";
            textBox1.Size = new Size(137, 23);
            textBox1.TabIndex = 11;
            textBox1.TextChanged += textBox1_TextChanged;
            // 
            // ReactorForm
            // 
            AutoScaleMode = AutoScaleMode.None;
            ClientSize = new Size(309, 644);
            Controls.Add(label1);
            Controls.Add(textBox1);
            Controls.Add(panel1);
            Controls.Add(button2);
            Controls.Add(button1);
            Controls.Add(pictureBox1);
            Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            KeyPreview = true;
            MaximumSize = new Size(327, 1200);
            Name = "ReactorForm";
            StartPosition = FormStartPosition.CenterScreen;
            Text = "Reactor";
            TopMost = true;
            Shown += ReactorForm_Shown;
            KeyDown += ReactorForm_KeyDown;
            ((System.ComponentModel.ISupportInitialize)pictureBox1).EndInit();
            ResumeLayout(false);
            PerformLayout();
        }

        #endregion

        private Button button2;
        private Button button1;
        private PictureBox pictureBox1;
        private Panel panel1;
        private Label label1;
        private TextBox textBox1;
    }
}
```

`MapleNecrocer/ReactorForm.cs`:

```cs
using DevComponents.DotNetBar;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Reflection.Emit;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using static System.Net.Mime.MediaTypeNames;

namespace MapleNecrocer;

public partial class ReactorForm : Form
{
    public ReactorForm()
    {
        InitializeComponent();
        Instance = this;
    }
    public static ReactorForm Instance;
    public DataGridViewEx ReactorListGrid;
    string ReactorID;

    private void ReactorForm_Shown(object sender, EventArgs e)
    {
        ReactorListGrid = new(65, 195, 0, 20, 220, 530, false, panel1);
        ReactorListGrid.Anchor = (AnchorStyles.Left | AnchorStyles.Right | AnchorStyles.Top | AnchorStyles.Bottom);
        ReactorListGrid.Dock = DockStyle.Fill;
        ReactorListGrid.SearchGrid.Dock = DockStyle.Fill;
        ReactorListGrid.RowTemplate.Height = 20;
        var Graphic = ReactorListGrid.CreateGraphics();
        var Font = new System.Drawing.Font(FontFamily.GenericSansSerif, 20, FontStyle.Bold);
        Graphic.DrawString("Loading...", Font, Brushes.Black, 10, 50);

        void CellClick(BaseDataGridView DataGrid, DataGridViewCellEventArgs e)
        {
            if (pictureBox1.Image != null)
                pictureBox1.Image.Dispose();
            ReactorID = DataGrid.Rows[e.RowIndex].Cells[0].Value.ToString();
            if (Wz.HasNode("Reactor/" + ReactorID + ".img/0/0"))
            {
                var Bmp = Wz.GetBmp("Reactor/" + ReactorID + ".img/0/0");
                pictureBox1.Image = Bmp;
            }
        }

        ReactorListGrid.CellClick += (s, e) =>
        {
            CellClick(ReactorListGrid, e);
        };
        ReactorListGrid.SearchGrid.CellClick += (s, e) =>
        {
            CellClick(ReactorListGrid.SearchGrid, e);
        };


        Win32.SendMessage(ReactorListGrid.Handle, false);
        foreach (var Img in Wz.GetNodes("Reactor"))
        {
            var Entry = Wz.GetNode("Reactor/" + Img.Text);
            if (!Entry.HasNode("0") || !Entry.HasNode("0/0"))
                continue;
            if ((Entry.HasNode("0/0")) && (!Entry.HasNode("0/0/_inlink")) && (Entry.GetBmp("0/0").Width <= 4))
                continue;
            string ReactorName = "";
            if (Entry.HasNode("info/info"))
                ReactorName = Entry.GetStr("info/info");
            else if (Entry.HasNode("info/viewName"))
                ReactorName = Entry.GetStr("info/viewName");
            ReactorListGrid.Rows.Add(Img.ImgID(), ReactorName);
        }
        Win32.SendMessage(ReactorListGrid.Handle, true);
        ReactorListGrid.Refresh();

    }

    private void button1_Click(object sender, EventArgs e)
    {
        Reactor.Create(ReactorID);
    }

    private void button2_Click(object sender, EventArgs e)
    {
        Reactor.Remove();
    }

    private void ReactorForm_KeyDown(object sender, KeyEventArgs e)
    {
        if (e.Alt)
            e.Handled = true;
        if (!textBox1.Focused)
            ActiveControl = null;
    }

    private void textBox1_TextChanged(object sender, EventArgs e)
    {
        ReactorListGrid.Search(textBox1.Text);
    }
}

```

`MapleNecrocer/ReactorForm.resx`:

```resx
<root>
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`MapleNecrocer/RenderForm.Designer.cs`:

```cs
namespace MapleNecrocer
{
    partial class RenderForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            SuspendLayout();
            // 
            // RenderForm
            // 
            AutoScaleMode = AutoScaleMode.None;
            ClientSize = new Size(1024, 768);
            Font = new Font("Microsoft JhengHei UI", 9F, FontStyle.Regular, GraphicsUnit.Pixel);
            FormBorderStyle = FormBorderStyle.None;
            Location = new Point(257, 93);
            Name = "RenderForm";
            Text = "RrenderForm";
            Load += RenderForm_Load;
            ResumeLayout(false);
        }

        #endregion
    }
}
```

`MapleNecrocer/RenderForm.cs`:

```cs
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using MonoGame.Forms.Controls;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using Microsoft.Xna.Framework;

using WzComparerR2.Rendering;
using WzComparerR2.MapRender2;
using WzComparerR2.Animation;
using Spine;
using WzComparerR2.WzLib;
using WzComparerR2.PluginBase;
using System.Reflection;
namespace MapleNecrocer;

public partial class RenderForm : Form
{
    public RenderForm()
    {
        InitializeComponent();
        RenderFormDraw = new();
        RenderFormDraw.Width = 1024;
        RenderFormDraw.Height = 768;
        RenderFormDraw.Parent = this;

    }
    public static RenderFormDraw RenderFormDraw;


    private void RenderForm_Load(object sender, EventArgs e)
    {

    }

}



```

`MapleNecrocer/RenderForm.resx`:

```resx
<root>
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`MapleNecrocer/RenderFormDraw.cs`:

```cs
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using MonoGame.Forms.Controls;
using Spine;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WzComparerR2.Animation;
using WzComparerR2.MapRender2;
using WzComparerR2.WzLib;
using SpriteEngine;
using Input = Microsoft.Xna.Framework.Input.Keys;
using System.Security.Cryptography.Xml;
using System.Security.Claims;
using WzComparerR2.CharaSim;
using WzComparerR2;
using GameUI;
using MouseExt;
using System.Runtime.InteropServices;

namespace MapleNecrocer;
public enum ScreenMode { Normal, Scale, FullScreen }
public class RenderFormDraw : MonoGameControl
{
    public RenderFormDraw()
    {
        Instance = this;
    }
    public static RenderFormDraw Instance;

    public static bool CanDraw;
    public static ScreenMode ScreenMode = ScreenMode.Normal;
    static RenderTarget2D ScreenRenderTarget;
    static float TimeDelta;

    [DllImport("user32.dll")]
    static extern IntPtr GetDC(IntPtr hdc);
    [DllImport("user32.dll", EntryPoint = "ReleaseDC")]
    static extern IntPtr ReleaseDC(IntPtr hWnd, IntPtr hdc);
    [DllImport("gdi32.dll")]
    static extern int GetDeviceCaps(IntPtr hdc, int nIndex);
    protected override void Initialize()
    {
        //if (!CanDraw)
        // return;
        base.Initialize();
        this.AlwaysEnableKeyboardInput = true;

        this.Editor.services.AddService<Random>(new Random());
        this.Editor.services.AddService<IRandom>(new ParticleRandom(Editor.services.GetService<Random>()));
        this.SetMultiSampleCount(0);

        EngineFunc.AddFont(this.GraphicsDevice, "Arial13", "Arial", 13f);
        //GMS font
        EngineFunc.AddD2DFont("Arial14", "Arial", 14f);
        EngineFunc.AddD2DFont("Arial13", "Arial", 13f);
        EngineFunc.AddD2DFont("Arial12", "Arial", 12f);
        EngineFunc.AddD2DFont("Arial10", "Arial", 10f);
        //TMS font
        EngineFunc.AddFont(this.GraphicsDevice, "Verdana11", "Verdana", 11f);
        EngineFunc.AddFont(this.GraphicsDevice, "SimSun13", "SimSun", 13f);
        EngineFunc.AddFont(this.GraphicsDevice, "SimSun14", "SimSun", 14f);
        EngineFunc.AddFont(this.GraphicsDevice, "Verdana9", "Verdana", 9f);
        //JMS font
        EngineFunc.AddFont(this.GraphicsDevice, "MSGothic11", "MS Gothic", 11f);
        EngineFunc.AddFont(this.GraphicsDevice, "MSGothic12", "MS Gothic", 12f);
        EngineFunc.AddFont(this.GraphicsDevice, "MSGothic14", "MS Gothic", 14f);
        ScreenRenderTarget = new RenderTarget2D(this.GraphicsDevice, 4000, 4000,
                                                   false, SurfaceFormat.Color, DepthFormat.None);
        //kms
        //EngineFunc.AddD2DFont("Arial12", "Arial12", 12f);
        //EngineFunc.AddD2DFont("Arial13", "Arial13", 12f);
        MouseEx.PlatformSetWindowHandle(RenderFormDraw.Instance.Handle);
        IntPtr hdc = GetDC(IntPtr.Zero);
        TimeDelta = (float)1 / GetDeviceCaps(hdc, 116);
        ReleaseDC(IntPtr.Zero, hdc);

    }
    private static Vector2 NewPos, CurrentPos;

    void UpdateGame()
    {
        if (Map.GameMode == GameMode.Viewer)
        {
            if (Keyboard.KeyDown(Input.Right))
                EngineFunc.SpriteEngine.Camera.X += 5;
            if (Keyboard.KeyDown(Input.Left))
                EngineFunc.SpriteEngine.Camera.X -= 5;
            if (Keyboard.KeyDown(Input.Up))
                EngineFunc.SpriteEngine.Camera.Y -= 5;
            if (Keyboard.KeyDown(Input.Down))
                EngineFunc.SpriteEngine.Camera.Y += 5;
            if (EngineFunc.SpriteEngine.Camera.X > Map.Right - Map.DisplaySize.X)
                EngineFunc.SpriteEngine.Camera.X = Map.Right - Map.DisplaySize.X;
            if (EngineFunc.SpriteEngine.Camera.X < Map.Left)
                EngineFunc.SpriteEngine.Camera.X = Map.Left;
            if (EngineFunc.SpriteEngine.Camera.Y > Map.Bottom - Map.DisplaySize.Y)
                EngineFunc.SpriteEngine.Camera.Y = Map.Bottom - Map.DisplaySize.Y;
            if (EngineFunc.SpriteEngine.Camera.Y < Map.Top)
                EngineFunc.SpriteEngine.Camera.Y = Map.Top;
        }

        if (Map.ReLoad)
        {
            Map.LoadMap(Map.ID);
            Map.ReLoad = false;
        }
        //Keyboard.GetState();

        NewPos = EngineFunc.SpriteEngine.Camera;
        Map.CameraSpeed = NewPos - CurrentPos;
        CurrentPos = EngineFunc.SpriteEngine.Camera;
        EngineFunc.SpriteEngine.Move(1);
        //   EngineFunc.SpriteEngine.Camera.X+=0.2f*(float)(gameTime.ElapsedGameTime.TotalMilliseconds/16.66f);

        if (MapleChair.IsUse)
        {
            if (Keyboard.KeyPressed(Input.Left) || Keyboard.KeyPressed(Input.Right))
            {
                MapleChair.Remove();
                TamingMob.Remove();
                ItemEffect.Remove(EffectType.Chair);
                MapleChair.BodyRelMove.X = 0;
                MapleChair.BodyRelMove.Y = 0;
            }
        }

        if (ScreenMode == ScreenMode.Scale)
        {
            this.GraphicsDevice.SetRenderTarget(ScreenRenderTarget);
            EngineFunc.SpriteEngine.Draw();
            if (Map.FadeScreen.DoFade)
            {
                EngineFunc.Canvas.FillRoundRect(0, 0, Map.DisplaySize.X, Map.DisplaySize.Y,
                    new Microsoft.Xna.Framework.Color(0, 0, 0, Map.FadeScreen.AlphaCounter));
            }
            if (Map.ShowBgmName)
            {
                EngineFunc.Canvas.DrawString("Arial13", Map.BgmName, 35, 35, Microsoft.Xna.Framework.Color.Red);
            }
            if (Map.ShowFootholds)
            {
                FootholdTree.Instance.DrawFootholds();
            }
            this.GraphicsDevice.SetRenderTarget(null);
        }

        if (Sound.PlayendList.Count == 100)
        {
            for (int i = 0; i < Sound.PlayendList.Count; i++)
            {
                if (Sound.PlayendList[i].State != PlayState.Playing)
                {
                    Sound.PlayendList[i].UnLoad();
                    Sound.PlayendList.RemoveAt(i);
                }
            }
        }
    }
    
    private static float FixedUpdateDelta = 0.016666668f;
    private static float PreviousTime = 0;
    private static float Accumulator = 0.0f;
    protected override void Update(GameTime gameTime)
    {
        if (PreviousTime==0)
        {
               PreviousTime = (float)gameTime.TotalGameTime.TotalMilliseconds;
        }
     
        float Now = (float)gameTime.TotalGameTime.TotalMilliseconds;
        float FrameTime = Now - PreviousTime;
       
        if (FrameTime > TimeDelta)
        {
            FrameTime =  TimeDelta;
        }

        PreviousTime = Now;
        Accumulator += FrameTime;
        while (Accumulator >= FixedUpdateDelta)
        {
            UpdateGame();
            Accumulator -= FixedUpdateDelta;
        }
    }

    protected override void Draw()
    {
        this.Editor.graphics.Clear(Microsoft.Xna.Framework.Color.Black);
        EngineFunc.SpriteEngine.Dead();
        // EngineFunc.SpriteEngine.Draw();

        switch (ScreenMode)
        {
            case ScreenMode.Normal:
                EngineFunc.SpriteEngine.Draw();
                if (Map.FadeScreen.DoFade)
                {
                    EngineFunc.Canvas.FillRoundRect(0, 0, Map.DisplaySize.X, Map.DisplaySize.Y,
                        new Microsoft.Xna.Framework.Color(0, 0, 0, Map.FadeScreen.AlphaCounter));
                }
                if (Map.ShowBgmName)
                {
                    EngineFunc.Canvas.DrawString("Arial13", Map.BgmName, 35, 35, Microsoft.Xna.Framework.Color.Red);
                }
                if (Map.ShowFootholds)
                {
                    FootholdTree.Instance.DrawFootholds();
                }
                break;
            case ScreenMode.Scale:
                EngineFunc.Canvas.DrawStretch(ScreenRenderTarget, ScaleForm.ScaleX, ScaleForm.ScaleY, Map.DisplaySize.X, Map.DisplaySize.Y);
                break;
        }

        if (Map.ResetPos)
        {
            Map.OffsetY = (Map.DisplaySize.Y - 600) / 2;
            Back.ResetPos = true;
            EngineFunc.SpriteEngine.Move(1);
            Particle.ResetPos = true;
            Map.ResetPos = false;
        }

        if (UI.ControlManager != null)
        {
            // var m = MouseEx.GetState();
            UI.ControlManager.Update();
            UI.ControlManager.Draw();
            //  EngineFunc.SpriteEngine.Canvas.Draw(Wz.EquipImageLib[Wz.GetNode("UI/UIWindow.img/Shop/backgrnd")],
            //  m.X, m.Y);
        }

        if (Map.FirstLoaded)
            GameCursor.Draw();

    }
    protected override void OnMouseEnter(EventArgs e)
    {
        if (Map.FirstLoaded)
            Cursor.Hide();
    }

    protected override void OnMouseLeave(EventArgs e)
    {
        if (Map.FirstLoaded)
            Cursor.Show();
    }

}


```

`MapleNecrocer/RingForm.Designer.cs`:

```cs
namespace MapleNecrocer
{
    partial class RingForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            panel1 = new Panel();
            button1 = new Button();
            textBox1 = new TextBox();
            label1 = new Label();
            SuspendLayout();
            // 
            // panel1
            // 
            panel1.Anchor = AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right;
            panel1.Location = new Point(6, 48);
            panel1.Name = "panel1";
            panel1.Size = new Size(345, 519);
            panel1.TabIndex = 0;
            // 
            // button1
            // 
            button1.Font = new Font("Tahoma", 13F, FontStyle.Regular, GraphicsUnit.Pixel);
            button1.Location = new Point(226, 12);
            button1.Name = "button1";
            button1.Size = new Size(95, 28);
            button1.TabIndex = 6;
            button1.Text = "Remove";
            button1.UseVisualStyleBackColor = true;
            button1.Click += button1_Click;
            // 
            // textBox1
            // 
            textBox1.Font = new Font("Tahoma", 13F, FontStyle.Regular, GraphicsUnit.Pixel);
            textBox1.Location = new Point(62, 15);
            textBox1.Name = "textBox1";
            textBox1.Size = new Size(116, 23);
            textBox1.TabIndex = 5;
            textBox1.TextChanged += textBox1_TextChanged;
            // 
            // label1
            // 
            label1.AutoSize = true;
            label1.Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            label1.Location = new Point(12, 17);
            label1.Name = "label1";
            label1.Size = new Size(52, 18);
            label1.TabIndex = 4;
            label1.Text = "Search";
            // 
            // RingForm
            // 
            AutoScaleMode = AutoScaleMode.None;
            ClientSize = new Size(359, 574);
            Controls.Add(button1);
            Controls.Add(textBox1);
            Controls.Add(label1);
            Controls.Add(panel1);
            Font = new Font("Tahoma", 13F, FontStyle.Regular, GraphicsUnit.Point);
            KeyPreview = true;
            MaximumSize = new Size(377, 900);
            Name = "RingForm";
            StartPosition = FormStartPosition.CenterScreen;
            Text = "Ring";
            TopMost = true;
            FormClosing += RingForm_FormClosing;
            Shown += RingForm_Shown;
            KeyDown += RingForm_KeyDown;
            ResumeLayout(false);
            PerformLayout();
        }

        #endregion

        private Panel panel1;
        private Button button1;
        private TextBox textBox1;
        private Label label1;
    }
}
```

`MapleNecrocer/RingForm.cs`:

```cs
using WzComparerR2.WzLib;
namespace MapleNecrocer;

public partial class RingForm : Form
{
    public RingForm()
    {
        InitializeComponent();
    }
    public static RingForm Instance;
    public DataGridViewEx RingListGrid;


    void CellClick(BaseDataGridView DataGrid, DataGridViewCellEventArgs e)
    {
        NameTag.IsUse = false;
        var ID = DataGrid.Rows[e.RowIndex].Cells[0].Value.ToString();
        LabelRingTag.Delete();
        LabelRingTag.Create(ID);
        LabelRingTag.Instance.MedalName = Game.Player.Name;
        LabelRingTag.Instance.InitData();
        LabelRingTag.ReDraw();
    }
    private void RingForm_Shown(object sender, EventArgs e)
    {
        this.FormClosing += (s, e1) =>
        {
            this.Hide();
            e1.Cancel = true;
        };
        RingListGrid = new(90, 179, 0, 0, 220, 400, true, panel1);
        RingListGrid.Dock = DockStyle.Fill;
        RingListGrid.SearchGrid.Dock = DockStyle.Fill;
        RingListGrid.RowTemplate.Height = 40;

        var Graphic = RingListGrid.CreateGraphics();
        var Font = new System.Drawing.Font(FontFamily.GenericSansSerif, 20, FontStyle.Bold);
        Graphic.DrawString("Loading...", Font, Brushes.Black, 10, 50);
        RingListGrid.CellClick += (s, e) =>
        {
            CellClick(RingListGrid, e);
        };

        RingListGrid.SearchGrid.CellClick += (s, e) =>
        {
            CellClick(RingListGrid.SearchGrid, e);
        };

        RingListGrid.SetToolTipEvent(WzType.Character, this);

        string RingName = null;
        Bitmap Bmp = null;
        foreach (var Img in Wz.GetNodes("Character/Ring"))
        {
            if (Img.Text.LeftStr(6) != "011121" && Img.Text.LeftStr(6) != "011151"  &&
                Img.Text.LeftStr(6) != "011153" && Img.Text.LeftStr(6) !="011155")
                continue;
            if (!Wz.HasNode("Character/Ring/" + Img.Text + "/info/nameTag"))
                continue;
            int TagNum = Wz.GetInt("Character/Ring/" + Img.Text + "/info/nameTag");
            if (!Wz.HasNode("UI/NameTag.img/" + TagNum))
                continue;
            string ID = Img.ImgID();
            if (Wz.HasNode("String/Eqp.img/Eqp/Ring/" + ID.IntID()))
                RingName = Wz.GetStr("String/Eqp.img/Eqp/Ring/" + ID.IntID() + "/name");
            else if (Wz.HasNode("String/Item.img/Eqp/Ring/" + ID.IntID()))
                RingName = Wz.GetStr("String/Item.img/Eqp/Ring/" + ID.IntID() + "/name");
            if (Wz.HasNode("Character/Ring/" + Img.Text + "/info/icon"))
                Bmp = Wz.GetBmp("Character/Ring/" + Img.Text + "/info/icon");
            RingListGrid.Rows.Add(ID, Bmp, RingName);
        }
        for (int i = 0; i < RingListGrid.Rows.Count; i++)
        {
            RingListGrid.Rows[i].Cells[1].Style.Alignment = DataGridViewContentAlignment.MiddleCenter;
            RingListGrid.Rows[i].Cells[2].Style.Alignment = DataGridViewContentAlignment.TopLeft;
        }
    }

    private void button1_Click(object sender, EventArgs e)
    {
        NameTag.IsUse = true;
        LabelRingTag.Delete();
    }
    private void RingForm_KeyDown(object sender, KeyEventArgs e)
    {
        if (e.Alt)
            e.Handled = true;
        if (!textBox1.Focused)
            ActiveControl = null;
    }

    private void textBox1_TextChanged(object sender, EventArgs e)
    {
        RingListGrid.Search(textBox1.Text);
    }

    private void RingForm_FormClosing(object sender, FormClosingEventArgs e)
    {
        MainForm.Instance.ToolTipView.Visible = false;
    }
}

```

`MapleNecrocer/RingForm.resx`:

```resx
<root>
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`MapleNecrocer/SaveMapForm.Designer.cs`:

```cs
namespace MapleNecrocer
{
    partial class SaveMapForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            button1 = new Button();
            comboBox1 = new ComboBox();
            comboBox2 = new ComboBox();
            label1 = new Label();
            label2 = new Label();
            SuspendLayout();
            // 
            // button1
            // 
            button1.Location = new Point(122, 136);
            button1.Name = "button1";
            button1.Size = new Size(110, 37);
            button1.TabIndex = 0;
            button1.Text = "Save";
            button1.UseVisualStyleBackColor = true;
            button1.Click += button1_Click;
            // 
            // comboBox1
            // 
            comboBox1.FormattingEnabled = true;
            comboBox1.Items.AddRange(new object[] { "0", "-50", "-100", "-150", "-200", "-250", "-300", "-350", "-400", "-450", "-500", "-550", "-600", "-650", "-700", "-750", "-800", "-850", "-900", "-950", "-1000", "-1050", "-1100", "-1150", "-1200", "-1250", "-1300", "-1350", "-1400", "-1450", "-1500", "-1550", "-1600", "50", "100", "150", "200" });
            comboBox1.Location = new Point(122, 38);
            comboBox1.Name = "comboBox1";
            comboBox1.Size = new Size(110, 25);
            comboBox1.TabIndex = 1;
            comboBox1.Text = "0";
            // 
            // comboBox2
            // 
            comboBox2.FormattingEnabled = true;
            comboBox2.Items.AddRange(new object[] { "1", "-1", "-1.5", "-2" });
            comboBox2.Location = new Point(122, 84);
            comboBox2.Name = "comboBox2";
            comboBox2.Size = new Size(114, 25);
            comboBox2.TabIndex = 2;
            comboBox2.Text = "1";
            // 
            // label1
            // 
            label1.AutoSize = true;
            label1.Location = new Point(12, 41);
            label1.Name = "label1";
            label1.Size = new Size(100, 18);
            label1.TabIndex = 3;
            label1.Text = "Back Y Adjust";
            // 
            // label2
            // 
            label2.AutoSize = true;
            label2.Location = new Point(60, 87);
            label2.Name = "label2";
            label2.Size = new Size(40, 18);
            label2.TabIndex = 4;
            label2.Text = "Ratio";
            // 
            // SaveMapForm
            // 
            AutoScaleMode = AutoScaleMode.None;
            ClientSize = new Size(336, 246);
            Controls.Add(label2);
            Controls.Add(label1);
            Controls.Add(comboBox2);
            Controls.Add(comboBox1);
            Controls.Add(button1);
            Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            KeyPreview = true;
            MaximizeBox = false;
            MinimizeBox = false;
            Name = "SaveMapForm";
            StartPosition = FormStartPosition.CenterScreen;
            Text = "SaveMap";
            TopMost = true;
            Shown += SaveMapForm_Shown;
            KeyDown += SaveMapForm_KeyDown;
            ResumeLayout(false);
            PerformLayout();
        }

        #endregion

        private Button button1;
        public ComboBox comboBox1;
        public ComboBox comboBox2;
        private Label label1;
        private Label label2;
    }
}
```

`MapleNecrocer/SaveMapForm.cs`:

```cs
using Microsoft.Xna.Framework.Graphics;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace MapleNecrocer;

public partial class SaveMapForm : Form
{
    public SaveMapForm()
    {
        InitializeComponent();
        Instance = this;
    }
    public static SaveMapForm Instance;

    private void button1_Click(object sender, EventArgs e)
    {

        int MapWidth = Map.Info["MapWidth"];
        int MapHeight = 0;
        if (Map.Info.ContainsKey("VRLeft"))
            MapHeight = Map.Bottom - Map.Top;
        else
            MapHeight = Map.SaveMapBottom - Map.Top;

        EngineFunc.SpriteEngine.Camera.X = Map.Left;
        EngineFunc.SpriteEngine.Camera.Y = Map.Top;
        EngineFunc.SpriteEngine.VisibleWidth = MapWidth;
        EngineFunc.SpriteEngine.VisibleHeight = MapHeight;

        Map.SaveMap = true;
        RenderTarget2D SaveTexture = null;
        EngineFunc.SpriteEngine.Move(1);

        EngineFunc.Canvas.DrawTarget(ref SaveTexture, MapWidth, MapHeight, () =>
        {
            EngineFunc.SpriteEngine.Draw();
        });

        EngineFunc.SpriteEngine.Move(1);
        Map.SaveMap = false;
        Map.ResetPos = true;

        EngineFunc.SpriteEngine.VisibleWidth = Map.DisplaySize.X;
        EngineFunc.SpriteEngine.VisibleHeight = Map.DisplaySize.Y;
        string MapName = "";
        if (MainForm.Instance.MapNames.ContainsKey(Map.ID))
            MapName = MainForm.Instance.MapNames[Map.ID];
        MapName = MapName.Replace('<', '(');
        MapName = MapName.Replace('>', ')');
        Stream stream = File.OpenWrite(System.Environment.CurrentDirectory + "\\" + Map.ID + '-' + MapName + ".png");
        SaveTexture.SaveAsPng(stream, MapWidth, MapHeight);
        stream.Dispose();
        SaveTexture.Dispose();
        comboBox1.SelectedIndex = 0;
        comboBox2.SelectedIndex = 0;
    }

    private void SaveMapForm_Shown(object sender, EventArgs e)
    {
        this.FormClosing += (s, e1) =>
        {
            this.Hide();
            e1.Cancel = true;
        };
    }

    private void SaveMapForm_KeyDown(object sender, KeyEventArgs e)
    {
        if (e.Alt)
            e.Handled = true;
    }
}

```

`MapleNecrocer/SaveMapForm.resx`:

```resx
<root>
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`MapleNecrocer/ScaleForm.Designer.cs`:

```cs
namespace MapleNecrocer
{
    partial class ScaleForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            comboBox1 = new ComboBox();
            SuspendLayout();
            // 
            // comboBox1
            // 
            comboBox1.DropDownHeight = 300;
            comboBox1.FormattingEnabled = true;
            comboBox1.IntegralHeight = false;
            comboBox1.Items.AddRange(new object[] { "800X600 -> 1024X768", "800X600 -> 1366X768", "800X600 -> 1600X900", "800X600 -> 1920X1080", "800X600 -> 2560X1440", "800X600 -> 3200X1800", "800X600 -> 3840X2160", "1024X768 -> 1024X768", "1024X768 -> 1366X768", "1024X768 -> 1600X900", "1024X768 -> 1920X1080", "1024X768 -> 2560X1440", "1024X768 -> 3200X1800", "1024X768 -> 3840X2160", "1280X720 -> 1600X900", "1280X720 -> 1920X1080", "1280X720 -> 2560X1440", "1280X720 -> 3200X1800", "1280X720 -> 3840X2160", "1366X768 -> 1600X900", "1366X768 -> 1920X1080", "1366X768 -> 2560X1440", "1366X768 -> 3200X1800", "1366X768 -> 3840X2160", "1600X900 -> 1920X1080", "1600X900 -> 2560X1440", "1600X900 -> 3200X1800", "1600X900 -> 3840X2160", "1920X1080 -> 2560X1440", "1920X1080 -> 3200X1800", "1920X1080 -> 3840X2160", "2560X1440 -> 3200X1800", "2560X1440 -> 3840X2160" });
            comboBox1.Location = new Point(65, 90);
            comboBox1.Name = "comboBox1";
            comboBox1.Size = new Size(248, 27);
            comboBox1.TabIndex = 0;
            comboBox1.SelectedIndexChanged += comboBox1_SelectedIndexChanged;
            // 
            // ScaleForm
            // 
            AutoScaleMode = AutoScaleMode.None;
            ClientSize = new Size(376, 184);
            Controls.Add(comboBox1);
            KeyPreview = true;
            MaximizeBox = false;
            MinimizeBox = false;
            Name = "ScaleForm";
            StartPosition = FormStartPosition.CenterScreen;
            Text = "ScaleForm";
            TopMost = true;
            Load += ScaleForm_Load;
            KeyDown += ScaleForm_KeyDown;
            ResumeLayout(false);
        }

        #endregion

        private ComboBox comboBox1;
    }
}
```

`MapleNecrocer/ScaleForm.cs`:

```cs
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace MapleNecrocer;

public partial class ScaleForm : Form
{
    public ScaleForm()
    {
        InitializeComponent();
        Instance = this;
    }
    public static ScaleForm Instance;
    public static int ScaleX, ScaleY;

    private void comboBox1_SelectedIndexChanged(object sender, EventArgs e)
    {
        RenderFormDraw.ScreenMode = ScreenMode.Scale;
        var Split = comboBox1.Text.Split("->");

        var SrcStr = Split[0].Split('X');
        Map.DisplaySize.X = SrcStr[0].Trim(' ').ToInt();
        Map.DisplaySize.Y = SrcStr[1].Trim(' ').ToInt();

        var DestStr = Split[1].Split('X');
        ScaleX = DestStr[0].Trim(' ').ToInt();
        ScaleY = DestStr[1].Trim(' ').ToInt();
        RenderFormDraw.ScreenMode = ScreenMode.Scale;

        bool Result;
        Result = MainForm.MoveWindow(MainForm.Instance.Handle, MainForm.Instance.Left, MainForm.Instance.Top, ScaleX + 287, ScaleY + 152, true);
        //this.Width = Map.DisplaySize.X + 283;
        //this.Height = Map.DisplaySize.Y + 124;

        Result = MainForm.MoveWindow(MainForm.RenderForm.Handle, MainForm.RenderForm.Left, MainForm.RenderForm.Top, ScaleX, ScaleY, true);
        // RenderForm.Width = Map.DisplaySize.X;
        //RenderForm.Height = Map.DisplaySize.Y;
        RenderForm.RenderFormDraw.Width = ScaleX;
        RenderForm.RenderFormDraw.Height = ScaleY;
        RenderForm.RenderFormDraw.Parent = MainForm.RenderForm;
        EngineFunc.SpriteEngine.VisibleWidth = Map.DisplaySize.X + 200;
        EngineFunc.SpriteEngine.VisibleHeight = Map.DisplaySize.Y + 200;
        Map.ResetPos = true;
        MainForm.Instance.CenterToScreen2();
        MainForm.Instance.Refresh();

    }

    private void ScaleForm_Load(object sender, EventArgs e)
    {

        this.FormClosing += (s, e1) =>
        {
            this.Hide();
            e1.Cancel = true;
        };
    }

    private void ScaleForm_KeyDown(object sender, KeyEventArgs e)
    {
        if (e.Alt)
            e.Handled = true;
        if (!comboBox1.Focused)
            ActiveControl = null;


    }
}

```

`MapleNecrocer/ScaleForm.resx`:

```resx
<root>
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`MapleNecrocer/SelectFolderForm.Designer.cs`:

```cs
namespace MapleNecrocer
{
    partial class SelectFolderForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            SelectWzButton = new Button();
            RecentFilesGrid = new DataGridView();
            ((System.ComponentModel.ISupportInitialize)RecentFilesGrid).BeginInit();
            SuspendLayout();
            // 
            // SelectWzButton
            // 
            SelectWzButton.Font = new Font("Microsoft JhengHei UI", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            SelectWzButton.Location = new Point(154, 12);
            SelectWzButton.Name = "SelectWzButton";
            SelectWzButton.Size = new Size(178, 38);
            SelectWzButton.TabIndex = 0;
            SelectWzButton.Text = "Select Folder";
            SelectWzButton.UseVisualStyleBackColor = true;
            SelectWzButton.Click += SelectFolderButton_Click;
            // 
            // RecentFilesGrid
            // 
            RecentFilesGrid.AllowUserToAddRows = false;
            RecentFilesGrid.AllowUserToDeleteRows = false;
            RecentFilesGrid.AllowUserToResizeColumns = false;
            RecentFilesGrid.AllowUserToResizeRows = false;
            RecentFilesGrid.BackgroundColor = SystemColors.ButtonHighlight;
            RecentFilesGrid.ColumnHeadersHeightSizeMode = DataGridViewColumnHeadersHeightSizeMode.AutoSize;
            RecentFilesGrid.ColumnHeadersVisible = false;
            RecentFilesGrid.Location = new Point(12, 56);
            RecentFilesGrid.Name = "RecentFilesGrid";
            RecentFilesGrid.RowHeadersVisible = false;
            RecentFilesGrid.RowHeadersWidth = 51;
            RecentFilesGrid.RowTemplate.Height = 29;
            RecentFilesGrid.ShowCellToolTips = false;
            RecentFilesGrid.Size = new Size(494, 245);
            RecentFilesGrid.TabIndex = 1;
            RecentFilesGrid.CellContentClick += RecentFilesGrid_CellContentClick;
            // 
            // SelectFolderForm
            // 
            AutoScaleMode = AutoScaleMode.None;
            ClientSize = new Size(520, 313);
            Controls.Add(RecentFilesGrid);
            Controls.Add(SelectWzButton);
            FormBorderStyle = FormBorderStyle.FixedToolWindow;
            Name = "SelectFolderForm";
            Text = "Select wz";
            TopMost = true;
            Load += OpenWzForm_Load;
            ((System.ComponentModel.ISupportInitialize)RecentFilesGrid).EndInit();
            ResumeLayout(false);
        }

        #endregion

        private Button SelectWzButton;
        private DataGridView RecentFilesGrid;
    }
}
```

`MapleNecrocer/SelectFolderForm.cs`:

```cs
using DevComponents.DotNetBar.Controls;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using WzComparerR2.PluginBase;
using static System.Windows.Forms.VisualStyles.VisualStyleElement.Window;

namespace MapleNecrocer;

public partial class SelectFolderForm : Form
{
    public static partial class Directory
    {
        public static System.Collections.Generic.IEnumerable<string>
        EnumerateFiles
        (
          string Directory
        ,
          params string[] Pattern
        )
        {
            if ((Pattern == null) || (Pattern.Length == 0))
            {
                Pattern = new string[] { "*" };
            }

            foreach (string l in Pattern)
            {
                foreach (string p in l.Split(new char[] { ';' }, System.StringSplitOptions.RemoveEmptyEntries))
                {
                    foreach (string f in System.IO.Directory.EnumerateFiles(Directory, p, SearchOption.AllDirectories))
                    {
                        yield return f;
                    }
                }
            }

            yield break;
        }
    }



    public SelectFolderForm()
    {
        InitializeComponent();
        Instance = this;
    }
    public static SelectFolderForm Instance;
    private void OpenWzForm_Load(object sender, EventArgs e)
    {

        RecentFilesGrid.Rows.Clear();
        var listOfLines = File.ReadAllLines("RecentFiles.txt")
                       .Where(x => !string.IsNullOrWhiteSpace(x));

        RecentFilesGrid.ColumnCount = 1;
        RecentFilesGrid.Columns[0].Width = 400;
        foreach (var Iter in listOfLines)
            RecentFilesGrid.Rows.Add(Iter.Trim());
        DataGridViewButtonColumn dgvButton = new DataGridViewButtonColumn();
        dgvButton.Width = 60;
        dgvButton.UseColumnTextForButtonValue = true;
        dgvButton.Text = "Load";
        RecentFilesGrid.Columns.Add(dgvButton);
        this.FormClosing += (s, e1) =>
        {
            this.Hide();
            e1.Cancel = true;
        };


    }

    private void SelectFolderButton_Click(object sender, EventArgs e)
    {
        var ListOfLines = File.ReadAllLines("RecentFiles.txt")
                         .Where(x => !string.IsNullOrWhiteSpace(x));

        File.WriteAllLines("RecentFiles.txt", ListOfLines);
        FolderBrowserDialog Dialog = new FolderBrowserDialog();
        Dialog.InitialDirectory = ".\\";
        if (Dialog.ShowDialog(new Form() { TopMost = true }) == DialogResult.OK)
        {
            if (Dialog.SelectedPath.Length <= 3)
            {
                MessageBox.Show("Base.wz not found");
                return;
            }

            var FindBaseWz = Directory.EnumerateFiles(Dialog.SelectedPath, "Base.wz;Data.wz");
            if (FindBaseWz.Count() >= 1)
            {
                this.Hide();
                MainForm.Instance.RemoveWz();
                MainForm.Instance.MapListBox.Rows.Clear();
                var Graphic = MainForm.Instance.MapListBox.CreateGraphics();
                var Font = new System.Drawing.Font(FontFamily.GenericSansSerif, 20, FontStyle.Bold);
                Graphic.DrawString("Loading...", Font, Brushes.Black, 10, 50);

                MainForm.OpenWZ(FindBaseWz.First());

                if (Wz.GetNode("String/Mob.img/100100/name").ToStr() == "Snail")
                {
                    MainForm.Instance.MapListBox.Columns[0].Width = 72;
                    MainForm.Instance.MapListBox.Font = new Font("Arial", 13f, GraphicsUnit.Pixel);
                    MainForm.Instance.MapListBox.SearchGrid.Font = new Font("Arial", 13f, GraphicsUnit.Pixel);
                }
                else
                {
                    MainForm.Instance.MapListBox.Columns[0].Width = 72 + 4;
                    MainForm.Instance.MapListBox.DefaultCellStyle.Font = new Font("Microsoft JhengHei", 13f, GraphicsUnit.Pixel);
                    MainForm.Instance.MapListBox.SearchGrid.DefaultCellStyle.Font = new Font("Microsoft JhengHei", 13f, GraphicsUnit.Pixel);
                }


                MainForm.Instance.DumpMapIDs();
                foreach (var Iter in ListOfLines)
                {
                    if (Iter.Trim() == Dialog.SelectedPath)
                        return;
                }
                //append  to first line
                string Content = File.ReadAllText("RecentFiles.txt");
                Content = Dialog.SelectedPath + "\n" + Content;
                File.WriteAllText("RecentFiles.txt", Content);
            }
            else
            {
                MessageBox.Show("Base.wz not found");
                return;
            }

        }

    }

    private void RecentFilesGrid_CellContentClick(object sender, DataGridViewCellEventArgs e)
    {
        this.Hide();
        MainForm.Instance.MapListBox.Rows.Clear();
        var Graphic = MainForm.Instance.MapListBox.CreateGraphics();
        var Font = new System.Drawing.Font(FontFamily.GenericSansSerif, 20, FontStyle.Bold);
        Graphic.DrawString("Loading...", Font, Brushes.Black, 10, 50);

        var Path = RecentFilesGrid.Rows[e.RowIndex].Cells[0].Value.ToString();
        var FindBaseWz = Directory.EnumerateFiles(Path, "Base.wz;Data.wz");
        MainForm.Instance.RemoveWz();

        if (FindBaseWz.Count() >= 1)
            MainForm.OpenWZ(FindBaseWz.First());
        if (Wz.GetNode("String/Mob.img/100100/name").ToStr() == "Snail")
        {
            MainForm.Instance.MapListBox.Columns[0].Width = 72;
            MainForm.Instance.MapListBox.Font = new Font("Arial", 13f, GraphicsUnit.Pixel);
            MainForm.Instance.MapListBox.SearchGrid.Font = new Font("Arial", 13f, GraphicsUnit.Pixel);
        }
        else
        {
            MainForm.Instance.MapListBox.Columns[0].Width = 72 + 4;
            MainForm.Instance.MapListBox.DefaultCellStyle.Font = new Font("Microsoft JhengHei", 13f, GraphicsUnit.Pixel);
            MainForm.Instance.MapListBox.SearchGrid.DefaultCellStyle.Font = new Font("Microsoft JhengHei", 13f, GraphicsUnit.Pixel);
        }
        MainForm.Instance.DumpMapIDs();


    }
}

```

`MapleNecrocer/SelectFolderForm.resx`:

```resx
<root>
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`MapleNecrocer/SkillForm.Designer.cs`:

```cs
namespace MapleNecrocer
{
    partial class SkillForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            panel1 = new Panel();
            comboBox1 = new ComboBox();
            panel2 = new Panel();
            label1 = new Label();
            label2 = new Label();
            SuspendLayout();
            // 
            // panel1
            // 
            panel1.Location = new Point(425, 35);
            panel1.MaximumSize = new Size(434, 1000);
            panel1.Name = "panel1";
            panel1.Size = new Size(434, 593);
            panel1.TabIndex = 0;
            // 
            // comboBox1
            // 
            comboBox1.Font = new Font("Tahoma", 15F, FontStyle.Regular, GraphicsUnit.Pixel);
            comboBox1.FormattingEnabled = true;
            comboBox1.Items.AddRange(new object[] { "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z" });
            comboBox1.Location = new Point(395, 3);
            comboBox1.Name = "comboBox1";
            comboBox1.Size = new Size(67, 26);
            comboBox1.TabIndex = 1;
            comboBox1.SelectedIndexChanged += comboBox1_SelectedIndexChanged;
            // 
            // panel2
            // 
            panel2.Location = new Point(12, 35);
            panel2.Name = "panel2";
            panel2.Size = new Size(377, 593);
            panel2.TabIndex = 2;
            // 
            // label1
            // 
            label1.AutoSize = true;
            label1.Font = new Font("Tahoma", 16F, FontStyle.Regular, GraphicsUnit.Pixel);
            label1.Location = new Point(570, 11);
            label1.Name = "label1";
            label1.Size = new Size(119, 19);
            label1.TabIndex = 3;
            label1.Text = "Hotkey Settings";
            // 
            // label2
            // 
            label2.AutoSize = true;
            label2.Font = new Font("Tahoma", 16F, FontStyle.Regular, GraphicsUnit.Pixel);
            label2.Location = new Point(157, 9);
            label2.Name = "label2";
            label2.Size = new Size(64, 19);
            label2.TabIndex = 4;
            label2.Text = "Use List";
            // 
            // SkillForm
            // 
            AutoScaleMode = AutoScaleMode.None;
            ClientSize = new Size(871, 640);
            Controls.Add(label2);
            Controls.Add(label1);
            Controls.Add(panel2);
            Controls.Add(comboBox1);
            Controls.Add(panel1);
            Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            KeyPreview = true;
            Name = "SkillForm";
            StartPosition = FormStartPosition.CenterScreen;
            Text = "Skill";
            TopMost = true;
            FormClosing += SkillForm_FormClosing;
            Shown += SkillForm_Shown;
            ResumeLayout(false);
            PerformLayout();
        }

        #endregion

        private Panel panel1;
        private ComboBox comboBox1;
        private Panel panel2;
        private Label label1;
        private Label label2;
    }
}
```

`MapleNecrocer/SkillForm.cs`:

```cs
using DevComponents.DotNetBar.Controls;
using System;
using System.CodeDom;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using WzComparerR2.CharaSim;
using static System.Windows.Forms.VisualStyles.VisualStyleElement;
using Input = Microsoft.Xna.Framework.Input.Keys;
namespace MapleNecrocer;

public partial class SkillForm : Form
{
    public SkillForm()
    {
        InitializeComponent();
        Instance = this;
    }
    public static SkillForm Instance;
    public DataGridViewEx SkillListGrid, UseListGrid;
    int SelectRow;
    
   
    
    void CellClick(BaseDataGridView DataGrid, DataGridViewCellEventArgs e)
    {
        var Rec = DataGrid.GetCellDisplayRectangle(1, e.RowIndex, true);
        comboBox1.Top = Rec.Top + 7;
        comboBox1.Left = Rec.Left + 239;
        SelectRow = e.RowIndex;
        comboBox1.SelectedIndex = -1;
        comboBox1.Visible = true;
    }

    private void SkillForm_Shown(object sender, EventArgs e)
    {
        this.FormClosing += (s, e1) =>
        {
            this.Hide();
            e1.Cancel = true;
        };

        var Skill = new Skill(EngineFunc.SpriteEngine);
        Skill.Tag = 1;

        SkillListGrid = new(100, 185, 0, 0, 220, 400, true, panel1);
        SkillListGrid.Dock = DockStyle.Fill;
        SkillListGrid.SearchGrid.Dock = DockStyle.Fill;
        SkillListGrid.RowTemplate.Height = 40;
        var Str = new DataGridViewTextBoxColumn();
        SkillListGrid.Columns.AddRange(Str);
        SkillListGrid.Columns[3].Width = 75;
        comboBox1.Parent = SkillListGrid;

        UseListGrid = new(100, 185, 0, 0, 220, 400, true, panel2);
        UseListGrid.Dock = DockStyle.Fill;
        UseListGrid.SearchGrid.Dock = DockStyle.Fill;
        UseListGrid.RowTemplate.Height = 40;
        var Str2 = new DataGridViewTextBoxColumn();
        UseListGrid.Columns.AddRange(Str2);
        UseListGrid.Columns[3].Width = 75;


        SkillListGrid.CellClick += (s, e) =>
        {
            CellClick(SkillListGrid, e);
        };

        SkillListGrid.Scroll += (s, e) =>
        {
            comboBox1.Visible = false;
        };

        SkillListGrid.SetToolTipEvent(WzType.Skill, this);
        var Graphic = SkillListGrid.CreateGraphics();
       
        var Font = new System.Drawing.Font(FontFamily.GenericSansSerif, 20, FontStyle.Bold);
        Graphic.DrawString("Loading...", Font, Brushes.Black, 10, 50);
        Win32.SendMessage(SkillListGrid.Handle, false);
        foreach (var Img in Wz.GetNodes("Skill"))
        {
            if (!Char.IsNumber(Img.Text[0]))
                continue;
            if (Img.Text[0] == '0')
                continue;
            if (!Wz.HasNode("Skill/" + Img.Text + "/skill"))
                continue;
            foreach (var ID in Wz.GetNodes("Skill/" + Img.Text + "/skill"))
            {
                if (ID.Text[0] == '0')
                    continue;
                if (!ID.HasNode("hit"))
                    continue;
                if (!ID.HasNode("common"))
                    continue;
                if (!ID.HasNode("common/lt"))
                    continue;
                if (!ID.HasNode("effect"))
                    continue;
                Bitmap Bmp = Wz.GetBmp("Skill/" + Skill.GetJobImg(ID.Text) + ".img/skill/" + ID.Text + "/icon");
                string SkillName = "";
                if (Wz.HasNode("String/Skill.img/" + ID.Text))
                    SkillName = Wz.GetStr("String/Skill.img/" + ID.Text + "/name");
                SkillListGrid.Rows.Add(ID.Text, Bmp, SkillName);

            }

        }
        Win32.SendMessage(SkillListGrid.Handle, true);
        SkillListGrid.Refresh();

        for (int i = 0; i < SkillListGrid.Rows.Count; i++)
        {
            SkillListGrid.Rows[i].Cells[1].Style.Alignment = DataGridViewContentAlignment.MiddleCenter;
            SkillListGrid.Rows[i].Cells[2].Style.Alignment = DataGridViewContentAlignment.TopLeft;
        }

    }

    private void comboBox1_SelectedIndexChanged(object sender, EventArgs e)
    {

        if (comboBox1.SelectedIndex == -1)
            return;
        UseListGrid.Rows.Add("", null, "", "");

        for (int i = UseListGrid.RowCount - 1; i >= 0; i--)
        {
            if (UseListGrid.Rows[i].Cells[0].Value.ToString() == SkillListGrid.Rows[SelectRow].Cells[0].Value.ToString())
                UseListGrid.Rows.RemoveAt(i);
            if (UseListGrid.Rows[i].Cells[3].Value.ToString() == comboBox1.Text)
                UseListGrid.Rows.RemoveAt(i);
        }

        for (int i = 0; i < UseListGrid.Columns.Count; i++)
            UseListGrid.Rows[UseListGrid.RowCount - 1].Cells[i].Value = SkillListGrid.Rows[SelectRow].Cells[i].Value;
        UseListGrid.Rows[UseListGrid.RowCount - 1].Cells[3].Value = comboBox1.Text;

        Skill.HotKeyList.Clear();
        for (int i = 0; i < UseListGrid.Rows.Count; i++)
        {
            string Char = UseListGrid.Rows[i].Cells[3].Value.ToString();
            string ID = UseListGrid.Rows[i].Cells[0].Value.ToString();
            Skill.HotKeyList.AddOrReplace((Input)Enum.Parse(typeof(Input), Char, true), ID);
        }

        string SkillID = SkillListGrid.Rows[SelectRow].Cells[0].Value.ToString();
        if (!Skill.LoadedList.Contains(SkillID))
            Skill.Load(SkillID);
        Skill.LoadedList.Add(SkillID);
        // comboBox1.Visible = false;

    }

    private void SkillForm_FormClosing(object sender, FormClosingEventArgs e)
    {
        MainForm.Instance.ToolTipView.Visible = false;
    }
}

```

`MapleNecrocer/SkillForm.resx`:

```resx
<root>
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`MapleNecrocer/SoulEffectForm.Designer.cs`:

```cs
namespace MapleNecrocer
{
    partial class SoulEffectForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            button1 = new Button();
            panel1 = new Panel();
            SuspendLayout();
            // 
            // button1
            // 
            button1.Location = new Point(115, 10);
            button1.Name = "button1";
            button1.Size = new Size(79, 28);
            button1.TabIndex = 10;
            button1.Text = "Remove";
            button1.UseVisualStyleBackColor = true;
            button1.Click += button1_Click;
            // 
            // panel1
            // 
            panel1.Anchor = AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right;
            panel1.Location = new Point(5, 44);
            panel1.Name = "panel1";
            panel1.Size = new Size(348, 443);
            panel1.TabIndex = 7;
            // 
            // SoulEffectForm
            // 
            AutoScaleMode = AutoScaleMode.None;
            ClientSize = new Size(359, 496);
            Controls.Add(button1);
            Controls.Add(panel1);
            Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            KeyPreview = true;
            MaximumSize = new Size(377, 1200);
            Name = "SoulEffectForm";
            StartPosition = FormStartPosition.CenterScreen;
            Text = "SoulEffect";
            TopMost = true;
            FormClosing += SoulEffectForm_FormClosing;
            Shown += SoulEffectForm_Shown;
            KeyDown += SoulEffectForm_KeyDown;
            ResumeLayout(false);
        }

        #endregion

        private Button button1;
        private Panel panel1;
    }
}
```

`MapleNecrocer/SoulEffectForm.cs`:

```cs
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace MapleNecrocer;

public partial class SoulEffectForm : Form
{
    public SoulEffectForm()
    {
        InitializeComponent();
        Instance = this;
    }
    public static SoulEffectForm Instance;
    public DataGridViewEx SoulEffectListGrid;
   
    private void SoulEffectForm_Shown(object sender, EventArgs e)
    {
        this.FormClosing += (s, e1) =>
        {
            this.Hide();
            e1.Cancel = true;
        };
        SoulEffectListGrid = new(80, 190, 0, 0, 220, 400, true, panel1);
        SoulEffectListGrid.Dock = DockStyle.Fill;
        SoulEffectListGrid.SearchGrid.Dock = DockStyle.Fill;
        SoulEffectListGrid.RowTemplate.Height = 40;
        var Str = new DataGridViewTextBoxColumn();
        SoulEffectListGrid.Columns.AddRange(Str);
        SoulEffectListGrid.Columns[3].Width = 0;

        var Graphic = SoulEffectListGrid.CreateGraphics();
        var Font = new System.Drawing.Font(FontFamily.GenericSansSerif, 20, FontStyle.Bold);
        Graphic.DrawString("Loading...", Font, Brushes.Black, 10, 50);

        void CellClick(BaseDataGridView DataGrid, DataGridViewCellEventArgs e)
        {
            string ID = DataGrid.Rows[e.RowIndex].Cells[3].Value.ToString();
            ItemEffect.Remove(EffectType.Soul);
            ItemEffect.Create(ID, EffectType.Soul);
        }

        SoulEffectListGrid.CellClick += (s, e) =>
        {
            CellClick(SoulEffectListGrid, e);
        };

        SoulEffectListGrid.SearchGrid.CellClick += (s, e) =>
        {
            CellClick(SoulEffectListGrid.SearchGrid, e);
        };
        SoulEffectListGrid.SetToolTipEvent(WzType.Item, this);

        Bitmap Bmp = null;
        string Name = "";
        foreach (var Iter in Wz.GetNodes("Etc/SoulCollection.img"))
        {
            string ID = Iter.GetInt("soulList/0/0").ToString();
            if (Wz.HasNode("Item/Consume/0259.img/0" + ID + "/info/icon"))
                Bmp = Wz.GetBmp("Item/Consume/0259.img/0" + ID + "/info/icon");
            if (Wz.HasNode("String/Consume.img/" + ID))
                Name = Wz.GetStr("String/Consume.img/" + ID + "/name");
            SoulEffectListGrid.Rows.Add('0' + ID, Bmp, Name, Iter.GetInt("soulSkill"));
        }
        for (int i = 0; i < SoulEffectListGrid.Rows.Count; i++)
        {
            SoulEffectListGrid.Rows[i].Cells[1].Style.Alignment = DataGridViewContentAlignment.MiddleCenter;
            SoulEffectListGrid.Rows[i].Cells[2].Style.Alignment = DataGridViewContentAlignment.TopLeft;
        }
    }

    private void button1_Click(object sender, EventArgs e)
    {
        ItemEffect.Remove(EffectType.Soul);
    }

    private void SoulEffectForm_KeyDown(object sender, KeyEventArgs e)
    {
        if (e.Alt)
            e.Handled = true;

        ActiveControl = null;
    }

    private void textBox1_TextChanged(object sender, EventArgs e)
    {

    }

    private void SoulEffectForm_FormClosing(object sender, FormClosingEventArgs e)
    {
        MainForm.Instance.ToolTipView.Visible = false;
    }
}

```

`MapleNecrocer/SoulEffectForm.resx`:

```resx
<root>
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`MapleNecrocer/SoundPlayer/BassSoundPlayer.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Timers;
using ManagedBass;
using System.IO;
using System.Runtime.InteropServices;

namespace WzComparerR2
{
    public class BassSoundPlayer : ISoundPlayer
    {
        public BassSoundPlayer()
        {
            volume = 100;
            autoPlay = true;
            loadedPlugin = new HashSet<int>();
        }

        private bool inited;
        private bool autoPlay;
        private int volume;
        private bool loop;
        
        private int hStream;
        private bool isDisposed;

        private string playingSoundName;
        private byte[] data;

        private HashSet<int> loadedPlugin;

        public string PlayingSoundName
        {
            get { return playingSoundName; }
            set { playingSoundName = value; }
        }

        public byte[] Data
        {
            get { return data; }
            set { data = value; }
        }

        public bool Inited
        {
            get { return inited; }
        }

        public bool Init()
        {
          /*
            if (!inited)
            {
                try
                {
                    Bass.Configure(Configuration.IncludeDefaultDevice, true);
                    if (inited = Bass.Init(-1, 44100, DeviceInitFlags.Default, IntPtr.Zero))
                    {
                        if (Directory.Exists(Program.LibPath))
                        {
                            foreach (string file in Directory.GetFiles(Program.LibPath, "bass*.dll", SearchOption.AllDirectories))
                            {
                                int p = Bass.PluginLoad(file);
                                if (p != 0)
                                {
                                    loadedPlugin.Add(p);
                                }
                            }
                        }
                    }
                }
                catch
                {
                }
            }
            
            return inited;
          */
          return false;
            
        }

        public Errors GetLastError()
        {
            return Bass.LastError;
        }

        public IEnumerable<string> GetPluginSupportedExt()
        {
            if (this.loadedPlugin == null || this.loadedPlugin.Count == 0)
                yield break;
            foreach (var p in this.loadedPlugin)
            {
                PluginInfo info = Bass.PluginGetInfo(p);
                foreach (PluginFormat form in info.Formats)
                {
                    yield return form.Name + "(" + form.FileExtensions + ")" + "|" + form.FileExtensions;
                }
            }
        }

        public void PreLoad(ISoundFile sound)
        {
            if (sound == null) return;
            this.UnLoad();

            try
            {
                hStream = Bass.CreateStream(sound.FileName, sound.StartPosition, sound.Length, BassFlags.Default);
            }
            catch
            {
                hStream = 0;
            }

            if (hStream != 0)
            {
                this.Volume = this.Volume;//调节音量到设定值
                this.Loop = this.Loop;
                if (this.autoPlay)
                    this.Play();
            }
        }

        public void PreLoad(byte[] data)
        {
            if (data == null) return;
            this.UnLoad();

            try
            {
                IntPtr pData = Marshal.UnsafeAddrOfPinnedArrayElement(data,0);
                hStream = Bass.CreateStream(pData, 0, data.Length, BassFlags.Default);
            }
            catch
            {
                hStream = 0;
            }

            if (hStream != 0)
            {
                this.Volume = this.Volume;//调节音量到设定值
                this.Loop = this.Loop;
                this.data = data;
                if (this.autoPlay)
                    this.Play();
            }
            else
            {
                var lastErr = Bass.LastError;
            }
        }

        public void UnLoad()
        {
            if (hStream != 0)
            {
                Bass.ChannelStop(hStream);
                Bass.StreamFree(hStream);
                this.data = null;
            }
        }

        public void Play()
        {
            bool success = Bass.ChannelPlay(hStream, true);
        }

        public void Pause()
        {
            Bass.ChannelPause(hStream);
        }

        public void Resume()
        {
            Bass.ChannelPlay(hStream, false);
        }

        public void Stop()
        {
            Bass.ChannelStop(hStream);
            Bass.ChannelSetPosition(hStream, 0);
        }

        public int Volume
        {
            get
            {
                return this.volume;
            }
            set
            {
                this.volume = Math.Min(Math.Max(value, 0), 100);
                Bass.ChannelSetAttribute(hStream, ChannelAttribute.Volume, this.volume * 0.01f);
            }
        }

        public double SoundPosition
        {
            get
            {
                if (this.hStream != 0)
                    return Bass.ChannelBytes2Seconds(hStream, Bass.ChannelGetPosition(hStream));
                else
                    return 0d;
            }
            set
            {
                if (this.hStream != 0)
                {
                    double totalLen = this.SoundLength;
                    value = Math.Min(Math.Max(value, 0), totalLen);
                    Bass.ChannelSetPosition(hStream, Bass.ChannelSeconds2Bytes(hStream, value));
                }
            }
        }

        public double SoundLength
        {
            get
            {
                if (this.hStream != 0)
                    return Bass.ChannelBytes2Seconds(hStream, Bass.ChannelGetLength(hStream));
                else
                    return 0d;
            }
        }

        public void Dispose()
        {
            if (!isDisposed)
            {
                this.UnLoad();
                Bass.Free();
                if (this.loadedPlugin != null && this.loadedPlugin.Count > 0)
                {
                    bool success = Bass.PluginFree(0);
                    this.loadedPlugin.Clear();
                }
                isDisposed = true;
            }
        }

        public bool AutoPlay
        {
            get
            {
                return this.autoPlay;
            }
            set
            {
                this.autoPlay = value;
            }
        }

        public bool Loop
        {
            get
            {
                return this.loop;
            }
            set
            {
                this.loop = value;
                if (this.hStream != 0)
                {
                    if (this.loop)
                        Bass.ChannelFlags(hStream, BassFlags.Loop, BassFlags.Loop);
                    else
                        Bass.ChannelFlags(hStream, BassFlags.Default, BassFlags.Loop);
                }
            }
        }

        public PlayState State
        {
            get
            {
                if (this.hStream != 0)
                {
                    PlaybackState active = Bass.ChannelIsActive(hStream);
                    switch (active)
                    {
                        case PlaybackState.Stopped: return PlayState.Stopped;
                        case PlaybackState.Playing: return PlayState.Playing;
                        case PlaybackState.Paused: return PlayState.Paused;
                        default: return PlayState.Stopped;
                    }
                }
                else
                {
                    return PlayState.Stopped;
                }
            }
        }
    }
}

```

`MapleNecrocer/SoundPlayer/CustomSoundFile.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using WzComparerR2.WzLib;

namespace WzComparerR2
{
    public class CustomSoundFile : ISoundFile
    {
        public CustomSoundFile(string fileName)
            : this(fileName, 0, 0)
        {
        }

        public CustomSoundFile(string fileName, int startPos, int length)
        {
            this.fileName = fileName;
            this.startPosition = startPos;
            this.length = length;
        }

        private string fileName;
        private int startPosition;
        private int length;

        public string FileName
        {
            get { return this.fileName; }
        }

        public int StartPosition
        {
            get { return this.startPosition; }
        }

        public int Length
        {
            get { return this.length; }
        }
    }
}

```

`MapleNecrocer/SoundPlayer/ISoundFile.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace WzComparerR2
{
    public interface ISoundFile
    {
        string FileName { get; }
        int StartPosition { get; }
        int Length { get; }
    }
}

```

`MapleNecrocer/SoundPlayer/ISoundPlayer.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace WzComparerR2
{
    public interface ISoundPlayer : IDisposable
    {
        bool Inited { get; }
        bool Init();
        void PreLoad(ISoundFile sound);
        void UnLoad();
        void Play();
        void Pause();
        void Resume();
        void Stop();
        bool AutoPlay { get; set; }
        int Volume { get; set; }
        double SoundPosition { get; set; }
        double SoundLength { get; }
        PlayState State { get; }
    }
}

```

`MapleNecrocer/SoundPlayer/PlayState.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace WzComparerR2
{
    public enum PlayState
    {
        Stopped = 0,
        Playing,
        Paused
    }
}

```

`MapleNecrocer/TitleForm.Designer.cs`:

```cs
namespace MapleNecrocer
{
    partial class TitleForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            panel1 = new Panel();
            button1 = new Button();
            textBox1 = new TextBox();
            label1 = new Label();
            SuspendLayout();
            // 
            // panel1
            // 
            panel1.Anchor = AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right;
            panel1.Location = new Point(12, 44);
            panel1.Name = "panel1";
            panel1.Size = new Size(335, 517);
            panel1.TabIndex = 0;
            // 
            // button1
            // 
            button1.Font = new Font("Tahoma", 13F, FontStyle.Regular, GraphicsUnit.Pixel);
            button1.Location = new Point(252, 7);
            button1.Name = "button1";
            button1.Size = new Size(95, 28);
            button1.TabIndex = 6;
            button1.Text = "Remove";
            button1.UseVisualStyleBackColor = true;
            button1.Click += button1_Click;
            // 
            // textBox1
            // 
            textBox1.Font = new Font("Tahoma", 13F, FontStyle.Regular, GraphicsUnit.Pixel);
            textBox1.Location = new Point(62, 11);
            textBox1.Name = "textBox1";
            textBox1.Size = new Size(116, 23);
            textBox1.TabIndex = 5;
            textBox1.TextChanged += textBox1_TextChanged;
            // 
            // label1
            // 
            label1.AutoSize = true;
            label1.Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            label1.Location = new Point(13, 12);
            label1.Name = "label1";
            label1.Size = new Size(52, 18);
            label1.TabIndex = 4;
            label1.Text = "Search";
            // 
            // TitleForm
            // 
            AutoScaleMode = AutoScaleMode.None;
            ClientSize = new Size(359, 573);
            Controls.Add(button1);
            Controls.Add(textBox1);
            Controls.Add(label1);
            Controls.Add(panel1);
            Font = new Font("Tahoma", 13F, FontStyle.Regular, GraphicsUnit.Point);
            KeyPreview = true;
            MaximumSize = new Size(377, 900);
            Name = "TitleForm";
            StartPosition = FormStartPosition.CenterScreen;
            Text = "TitleForm";
            TopMost = true;
            FormClosing += TitleForm_FormClosing;
            Shown += TitleForm_Shown;
            KeyDown += TitleForm_KeyDown;
            ResumeLayout(false);
            PerformLayout();
        }

        #endregion

        private Panel panel1;
        private Button button1;
        private TextBox textBox1;
        private Label label1;
    }
}
```

`MapleNecrocer/TitleForm.cs`:

```cs
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace MapleNecrocer;

public partial class TitleForm : Form
{
    public TitleForm()
    {
        InitializeComponent();
    }
    public static TitleForm Instance;
    public DataGridViewEx TitleListGrid;
    protected override CreateParams CreateParams
    {
        get
        {
            CreateParams cp = base.CreateParams;
            cp.ExStyle |= 0x02000000;
            return cp;
        }
    }

    void CellClick(BaseDataGridView DataGrid, DataGridViewCellEventArgs e)
    {
        NickNameTag.Delete();
        var ID = DataGrid.Rows[e.RowIndex].Cells[0].Value.ToString();
        int TagNum = Wz.GetNode("Item/Install/0370.img/" + ID + "/info/nickTag").ToInt();
        if (Wz.GetNode("UI/NameTag.img/nick/" + TagNum) != null)
            NickNameTag.Create(ID);
    }

    private void TitleForm_Shown(object sender, EventArgs e)
    {
        this.FormClosing += (s, e1) =>
        {
            this.Hide();
            e1.Cancel = true;
        };

        TitleListGrid = new(90, 164, 0, 0, 220, 400, true, panel1);
        TitleListGrid.Dock = DockStyle.Fill;
        TitleListGrid.SearchGrid.Dock = DockStyle.Fill;
        TitleListGrid.RowTemplate.Height = 40;

        var Graphic = TitleListGrid.CreateGraphics();
        var Font = new System.Drawing.Font(FontFamily.GenericSansSerif, 20, FontStyle.Bold);
        Graphic.DrawString("Loading...", Font, Brushes.Black, 10, 50);

        TitleListGrid.CellClick += (s, e) =>
        {
            CellClick(TitleListGrid, e);
        };

        TitleListGrid.SearchGrid.CellClick += (s, e) =>
        {
            CellClick(TitleListGrid.SearchGrid, e);
        };
        TitleListGrid.SetToolTipEvent(WzType.Item, this);


        string TitleName = null;
        Bitmap Bmp = null;
        foreach (var Iter in Wz.GetNode("Item/Install/0370.img").Nodes)
        {
            string ID = Iter.Text;
            if (Wz.HasNode("String/Ins.img/" + ID.IntID()))
                TitleName = Wz.GetNode("String/Ins.img/" + ID.ToInt() + "/name").ToStr();
            if (Iter.HasNode("info/icon"))
                Bmp = Iter.GetNode("info/icon").ExtractPng();
            TitleListGrid.Rows.Add(ID, Bmp, TitleName);
        }
    }

    private void button1_Click(object sender, EventArgs e)
    {
        NickNameTag.Delete();
    }

    private void TitleForm_KeyDown(object sender, KeyEventArgs e)
    {
        if (e.Alt)
            e.Handled = true;
        if (!textBox1.Focused)
            ActiveControl = null;
    }

    private void textBox1_TextChanged(object sender, EventArgs e)
    {
        TitleListGrid.Search(textBox1.Text);
    }

    private void TitleForm_FormClosing(object sender, FormClosingEventArgs e)
    {
        MainForm.Instance.ToolTipView.Visible = false;
    }
}

```

`MapleNecrocer/TitleForm.resx`:

```resx
<root>
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`MapleNecrocer/TotemEffectForm.Designer.cs`:

```cs
namespace MapleNecrocer
{
    partial class TotemEffectForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            panel1 = new Panel();
            button1 = new Button();
            label1 = new Label();
            textBox1 = new TextBox();
            SuspendLayout();
            // 
            // panel1
            // 
            panel1.Anchor = AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right;
            panel1.Location = new Point(5, 42);
            panel1.Name = "panel1";
            panel1.Size = new Size(348, 443);
            panel1.TabIndex = 1;
            // 
            // button1
            // 
            button1.Location = new Point(260, 7);
            button1.Name = "button1";
            button1.Size = new Size(79, 28);
            button1.TabIndex = 6;
            button1.Text = "Remove";
            button1.UseVisualStyleBackColor = true;
            button1.Click += button1_Click;
            // 
            // label1
            // 
            label1.AutoSize = true;
            label1.Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            label1.Location = new Point(17, 14);
            label1.Name = "label1";
            label1.Size = new Size(52, 18);
            label1.TabIndex = 5;
            label1.Text = "Search";
            // 
            // textBox1
            // 
            textBox1.Location = new Point(80, 11);
            textBox1.Name = "textBox1";
            textBox1.Size = new Size(113, 25);
            textBox1.TabIndex = 4;
            textBox1.TextChanged += textBox1_TextChanged;
            // 
            // TotemEffectForm
            // 
            AutoScaleMode = AutoScaleMode.None;
            ClientSize = new Size(359, 496);
            Controls.Add(button1);
            Controls.Add(label1);
            Controls.Add(textBox1);
            Controls.Add(panel1);
            Font = new Font("Microsoft JhengHei UI", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            KeyPreview = true;
            MaximumSize = new Size(377, 1200);
            Name = "TotemEffectForm";
            StartPosition = FormStartPosition.CenterScreen;
            Text = "TotemEffect";
            TopMost = true;
            FormClosing += TotemEffectForm_FormClosing;
            Shown += TotemEffectForm_Shown;
            KeyDown += TotemEffectForm_KeyDown;
            ResumeLayout(false);
            PerformLayout();
        }

        #endregion

        private Panel panel1;
        private Button button1;
        private Label label1;
        private TextBox textBox1;
    }
}
```

`MapleNecrocer/TotemEffectForm.cs`:

```cs
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace MapleNecrocer;

public partial class TotemEffectForm : Form
{
    public TotemEffectForm()
    {
        InitializeComponent();
        Instance = this;
    }
    public static TotemEffectForm Instance;
    public DataGridViewEx TotemEffectListGrid;
  

    private void TotemEffectForm_Shown(object sender, EventArgs e)
    {
        this.FormClosing += (s, e1) =>
        {
            this.Hide();
            e1.Cancel = true;
        };
        TotemEffectListGrid = new(80, 185, 0, 0, 220, 400, true, panel1);
        TotemEffectListGrid.Dock = DockStyle.Fill;
        TotemEffectListGrid.SearchGrid.Dock = DockStyle.Fill;
        TotemEffectListGrid.RowTemplate.Height = 40;

        var Graphic = TotemEffectListGrid.CreateGraphics();
        var Font = new System.Drawing.Font(FontFamily.GenericSansSerif, 20, FontStyle.Bold);
        Graphic.DrawString("Loading...", Font, Brushes.Black, 10, 50);

        void CellClick(BaseDataGridView DataGrid, DataGridViewCellEventArgs e)
        {
            string ID = DataGrid.Rows[e.RowIndex].Cells[0].Value.ToString();
            ItemEffect.Remove(EffectType.Totem);
            ItemEffect.Create(ID, EffectType.Totem);
        }

        TotemEffectListGrid.CellClick += (s, e) =>
        {
            CellClick(TotemEffectListGrid, e);
        };

        TotemEffectListGrid.SearchGrid.CellClick += (s, e) =>
        {
            CellClick(TotemEffectListGrid.SearchGrid, e);
        };

        TotemEffectListGrid.SetToolTipEvent(WzType.Character, this);
        Bitmap Bmp = null;
        string Name = "";
        foreach (var Iter in Wz.GetNodes("Effect/ItemEff.img"))
        {
            if (Iter.Text.LeftStr(2) == "12")
            {
                string ID = Iter.Text;
                if (Wz.HasNode("Character/Totem/0" + ID + ".img/info/icon"))
                    Bmp = Wz.GetBmp("Character/Totem/0" + ID + ".img/info/icon");
                if (Wz.HasNode("String/Eqp.img/Eqp/Accessory/" + ID))
                    Name = Wz.GetStr("String/Eqp.img/Eqp/Accessory/" + ID + "/name");
                TotemEffectListGrid.Rows.Add('0' + ID, Bmp, Name);
            }
        }
        for (int i = 0; i < TotemEffectListGrid.Rows.Count; i++)
        {
            TotemEffectListGrid.Rows[i].Cells[1].Style.Alignment = DataGridViewContentAlignment.MiddleCenter;
            TotemEffectListGrid.Rows[i].Cells[2].Style.Alignment = DataGridViewContentAlignment.TopLeft;
        }
    }

    private void button1_Click(object sender, EventArgs e)
    {
        ItemEffect.Remove(EffectType.Totem);
    }

    private void TotemEffectForm_KeyDown(object sender, KeyEventArgs e)
    {
        if (e.Alt)
            e.Handled = true;
        if (!textBox1.Focused)
            ActiveControl = null;
    }

    private void textBox1_TextChanged(object sender, EventArgs e)
    {
        TotemEffectListGrid.Search(textBox1.Text);
    }

    private void TotemEffectForm_FormClosing(object sender, FormClosingEventArgs e)
    {
        MainForm.Instance.ToolTipView.Visible = false;
    }
}

```

`MapleNecrocer/TotemEffectForm.resx`:

```resx
<root>
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`MapleNecrocer/ViewForm.Designer.cs`:

```cs
namespace MapleNecrocer
{
    partial class ViewForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            Tile = new CheckBox();
            Obj = new CheckBox();
            Back = new CheckBox();
            Front = new CheckBox();
            Npc = new CheckBox();
            Mob = new CheckBox();
            Portal = new CheckBox();
            ID = new CheckBox();
            BgmName = new CheckBox();
            UI = new CheckBox();
            MiniMap = new CheckBox();
            PortalInfo = new CheckBox();
            MobInfo = new CheckBox();
            MobName = new CheckBox();
            Foothold = new CheckBox();
            Player = new CheckBox();
            NpcName = new CheckBox();
            NpcChat = new CheckBox();
            panel1 = new Panel();
            button1 = new Button();
            textBox1 = new TextBox();
            label1 = new Label();
            ScrollingBar = new CheckBox();
            textBox2 = new TextBox();
            panel1.SuspendLayout();
            SuspendLayout();
            // 
            // Tile
            // 
            Tile.AutoSize = true;
            Tile.Checked = true;
            Tile.CheckState = CheckState.Checked;
            Tile.Location = new Point(12, 12);
            Tile.Name = "Tile";
            Tile.Size = new Size(52, 22);
            Tile.TabIndex = 0;
            Tile.Text = "Tile";
            Tile.UseVisualStyleBackColor = true;
            Tile.CheckedChanged += Tile_CheckedChanged;
            // 
            // Obj
            // 
            Obj.AutoSize = true;
            Obj.Checked = true;
            Obj.CheckState = CheckState.Checked;
            Obj.Location = new Point(70, 12);
            Obj.Name = "Obj";
            Obj.Size = new Size(53, 22);
            Obj.TabIndex = 1;
            Obj.Text = "Obj";
            Obj.UseVisualStyleBackColor = true;
            Obj.CheckedChanged += Tile_CheckedChanged;
            // 
            // Back
            // 
            Back.AutoSize = true;
            Back.Checked = true;
            Back.CheckState = CheckState.Checked;
            Back.Location = new Point(129, 12);
            Back.Name = "Back";
            Back.Size = new Size(61, 22);
            Back.TabIndex = 2;
            Back.Text = "Back";
            Back.UseVisualStyleBackColor = true;
            Back.CheckedChanged += Tile_CheckedChanged;
            // 
            // Front
            // 
            Front.AutoSize = true;
            Front.Checked = true;
            Front.CheckState = CheckState.Checked;
            Front.Location = new Point(196, 12);
            Front.Name = "Front";
            Front.Size = new Size(64, 22);
            Front.TabIndex = 3;
            Front.Text = "Front";
            Front.UseVisualStyleBackColor = true;
            Front.CheckedChanged += Tile_CheckedChanged;
            // 
            // Npc
            // 
            Npc.AutoSize = true;
            Npc.Checked = true;
            Npc.CheckState = CheckState.Checked;
            Npc.Location = new Point(266, 12);
            Npc.Name = "Npc";
            Npc.Size = new Size(55, 22);
            Npc.TabIndex = 4;
            Npc.Text = "Npc";
            Npc.UseVisualStyleBackColor = true;
            Npc.CheckedChanged += Tile_CheckedChanged;
            // 
            // Mob
            // 
            Mob.AutoSize = true;
            Mob.Checked = true;
            Mob.CheckState = CheckState.Checked;
            Mob.Location = new Point(327, 12);
            Mob.Name = "Mob";
            Mob.Size = new Size(58, 22);
            Mob.TabIndex = 5;
            Mob.Text = "Mob";
            Mob.UseVisualStyleBackColor = true;
            Mob.CheckedChanged += Tile_CheckedChanged;
            // 
            // Portal
            // 
            Portal.AutoSize = true;
            Portal.Checked = true;
            Portal.CheckState = CheckState.Checked;
            Portal.Location = new Point(391, 12);
            Portal.Name = "Portal";
            Portal.Size = new Size(66, 22);
            Portal.TabIndex = 6;
            Portal.Text = "Portal";
            Portal.UseVisualStyleBackColor = true;
            Portal.CheckedChanged += Tile_CheckedChanged;
            // 
            // ID
            // 
            ID.AutoSize = true;
            ID.Location = new Point(463, 12);
            ID.Name = "ID";
            ID.Size = new Size(46, 22);
            ID.TabIndex = 7;
            ID.Text = "ID";
            ID.UseVisualStyleBackColor = true;
            ID.CheckedChanged += Tile_CheckedChanged;
            // 
            // BgmName
            // 
            BgmName.AutoSize = true;
            BgmName.Location = new Point(515, 12);
            BgmName.Name = "BgmName";
            BgmName.Size = new Size(104, 22);
            BgmName.TabIndex = 8;
            BgmName.Text = "Bgm Name";
            BgmName.UseVisualStyleBackColor = true;
            BgmName.CheckedChanged += Tile_CheckedChanged;
            // 
            // UI
            // 
            UI.AutoSize = true;
            UI.Enabled = false;
            UI.Location = new Point(627, 11);
            UI.Name = "UI";
            UI.Size = new Size(46, 22);
            UI.TabIndex = 9;
            UI.Text = "UI";
            UI.UseVisualStyleBackColor = true;
            // 
            // MiniMap
            // 
            MiniMap.AutoSize = true;
            MiniMap.Checked = true;
            MiniMap.CheckState = CheckState.Checked;
            MiniMap.Location = new Point(12, 54);
            MiniMap.Name = "MiniMap";
            MiniMap.Size = new Size(87, 22);
            MiniMap.TabIndex = 10;
            MiniMap.Text = "Mini Map";
            MiniMap.UseVisualStyleBackColor = true;
            MiniMap.CheckedChanged += Tile_CheckedChanged;
            // 
            // PortalInfo
            // 
            PortalInfo.AutoSize = true;
            PortalInfo.Location = new Point(105, 54);
            PortalInfo.Name = "PortalInfo";
            PortalInfo.Size = new Size(98, 22);
            PortalInfo.TabIndex = 11;
            PortalInfo.Text = "Portal Info";
            PortalInfo.UseVisualStyleBackColor = true;
            PortalInfo.CheckedChanged += Tile_CheckedChanged;
            // 
            // MobInfo
            // 
            MobInfo.AutoSize = true;
            MobInfo.Enabled = false;
            MobInfo.Location = new Point(209, 54);
            MobInfo.Name = "MobInfo";
            MobInfo.Size = new Size(90, 22);
            MobInfo.TabIndex = 12;
            MobInfo.Text = "Mob Info";
            MobInfo.UseVisualStyleBackColor = true;
            // 
            // MobName
            // 
            MobName.AutoSize = true;
            MobName.Location = new Point(305, 54);
            MobName.Name = "MobName";
            MobName.Size = new Size(123, 22);
            MobName.TabIndex = 13;
            MobName.Text = "Mob Lv/Name";
            MobName.UseVisualStyleBackColor = true;
            MobName.CheckedChanged += Tile_CheckedChanged;
            // 
            // Foothold
            // 
            Foothold.AutoSize = true;
            Foothold.Location = new Point(424, 54);
            Foothold.Name = "Foothold";
            Foothold.Size = new Size(85, 22);
            Foothold.TabIndex = 14;
            Foothold.Text = "Foothold";
            Foothold.UseVisualStyleBackColor = true;
            Foothold.CheckedChanged += Tile_CheckedChanged;
            // 
            // Player
            // 
            Player.AutoSize = true;
            Player.Checked = true;
            Player.CheckState = CheckState.Checked;
            Player.Location = new Point(515, 54);
            Player.Name = "Player";
            Player.Size = new Size(69, 22);
            Player.TabIndex = 15;
            Player.Text = "Player";
            Player.UseVisualStyleBackColor = true;
            Player.CheckedChanged += Tile_CheckedChanged;
            // 
            // NpcName
            // 
            NpcName.AutoSize = true;
            NpcName.Checked = true;
            NpcName.CheckState = CheckState.Checked;
            NpcName.Location = new Point(590, 54);
            NpcName.Name = "NpcName";
            NpcName.Size = new Size(99, 22);
            NpcName.TabIndex = 16;
            NpcName.Text = "Npc Name";
            NpcName.UseVisualStyleBackColor = true;
            NpcName.CheckedChanged += Tile_CheckedChanged;
            // 
            // NpcChat
            // 
            NpcChat.AutoSize = true;
            NpcChat.Checked = true;
            NpcChat.CheckState = CheckState.Checked;
            NpcChat.Location = new Point(590, 91);
            NpcChat.Name = "NpcChat";
            NpcChat.Size = new Size(90, 22);
            NpcChat.TabIndex = 17;
            NpcChat.Text = "Npc Chat";
            NpcChat.UseVisualStyleBackColor = true;
            NpcChat.CheckedChanged += Tile_CheckedChanged;
            // 
            // panel1
            // 
            panel1.BorderStyle = BorderStyle.FixedSingle;
            panel1.Controls.Add(button1);
            panel1.Controls.Add(textBox1);
            panel1.Controls.Add(label1);
            panel1.Location = new Point(12, 91);
            panel1.Name = "panel1";
            panel1.Size = new Size(416, 35);
            panel1.TabIndex = 18;
            // 
            // button1
            // 
            button1.ImageAlign = ContentAlignment.TopCenter;
            button1.Location = new Point(341, 4);
            button1.Name = "button1";
            button1.Size = new Size(70, 25);
            button1.TabIndex = 2;
            button1.Text = "OK";
            button1.TextAlign = ContentAlignment.TopCenter;
            button1.UseVisualStyleBackColor = true;
            button1.Click += button1_Click;
            // 
            // textBox1
            // 
            textBox1.Font = new Font("Segoe UI", 15F, FontStyle.Regular, GraphicsUnit.Pixel);
            textBox1.Location = new Point(81, 3);
            textBox1.Name = "textBox1";
            textBox1.Size = new Size(256, 27);
            textBox1.TabIndex = 1;
            textBox1.Text = "SuperGM";
            textBox1.TextAlign = HorizontalAlignment.Right;
            // 
            // label1
            // 
            label1.AutoSize = true;
            label1.Location = new Point(7, 8);
            label1.Name = "label1";
            label1.Size = new Size(68, 18);
            label1.TabIndex = 0;
            label1.Text = "Player ID";
            // 
            // ScrollingBar
            // 
            ScrollingBar.AutoSize = true;
            ScrollingBar.Location = new Point(15, 141);
            ScrollingBar.Name = "ScrollingBar";
            ScrollingBar.Size = new Size(107, 22);
            ScrollingBar.TabIndex = 19;
            ScrollingBar.Text = "Scrolling Bar";
            ScrollingBar.UseVisualStyleBackColor = true;
            // 
            // textBox2
            // 
            textBox2.Font = new Font("Segoe UI", 15F, FontStyle.Regular, GraphicsUnit.Pixel);
            textBox2.Location = new Point(117, 139);
            textBox2.Name = "textBox2";
            textBox2.Size = new Size(455, 27);
            textBox2.TabIndex = 20;
            // 
            // ViewForm
            // 
            AutoScaleMode = AutoScaleMode.None;
            ClientSize = new Size(682, 173);
            Controls.Add(textBox2);
            Controls.Add(ScrollingBar);
            Controls.Add(panel1);
            Controls.Add(NpcChat);
            Controls.Add(NpcName);
            Controls.Add(Player);
            Controls.Add(Foothold);
            Controls.Add(MobName);
            Controls.Add(MobInfo);
            Controls.Add(PortalInfo);
            Controls.Add(MiniMap);
            Controls.Add(UI);
            Controls.Add(BgmName);
            Controls.Add(ID);
            Controls.Add(Portal);
            Controls.Add(Mob);
            Controls.Add(Npc);
            Controls.Add(Front);
            Controls.Add(Back);
            Controls.Add(Obj);
            Controls.Add(Tile);
            Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            KeyPreview = true;
            MaximizeBox = false;
            MinimizeBox = false;
            Name = "ViewForm";
            StartPosition = FormStartPosition.CenterScreen;
            Text = "View";
            TopMost = true;
            Shown += ViewForm_Shown;
            KeyDown += ViewForm_KeyDown;
            panel1.ResumeLayout(false);
            panel1.PerformLayout();
            ResumeLayout(false);
            PerformLayout();
        }

        #endregion

        private CheckBox Tile;
        private CheckBox Obj;
        private CheckBox Back;
        private CheckBox Front;
        private CheckBox Npc;
        private CheckBox Mob;
        private CheckBox Portal;
        private CheckBox ID;
        private CheckBox BgmName;
        private CheckBox UI;
        private CheckBox MiniMap;
        private CheckBox PortalInfo;
        private CheckBox MobInfo;
        private CheckBox MobName;
        private CheckBox Foothold;
        private CheckBox Player;
        private CheckBox NpcName;
        private CheckBox NpcChat;
        private Panel panel1;
        private Button button1;
        private TextBox textBox1;
        private Label label1;
        private CheckBox ScrollingBar;
        private TextBox textBox2;
    }
}
```

`MapleNecrocer/ViewForm.cs`:

```cs
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace MapleNecrocer;

public partial class ViewForm : Form
{
    public ViewForm()
    {
        InitializeComponent();
        Instance = this;
    }
    public static ViewForm Instance;

    private void ViewForm_Shown(object sender, EventArgs e)
    {
        this.FormClosing += (s, e1) =>
        {
            this.Hide();
            e1.Cancel = true;
        };

    }

    private void ViewForm_KeyDown(object sender, KeyEventArgs e)
    {
        if (e.Alt)
            e.Handled = true;
        if (!textBox1.Focused && !textBox2.Focused)
            ActiveControl = null;
    }

    private void Tile_CheckedChanged(object sender, EventArgs e)
    {
        switch (((CheckBox)sender).Name)
        {
            case "Tile": Map.ShowTile = !Map.ShowTile; break;
            case "Obj": Map.ShowObj = !Map.ShowObj; break;
            case "Back": Map.ShowBack = !Map.ShowBack; break;
            case "Front": Map.ShowFront = !Map.ShowFront; break;
            case "Npc": Map.ShowNpc = !Map.ShowNpc; break;
            case "NpcName": Map.ShowNpcName = !Map.ShowNpcName; break;
            case "NpcChat": Map.ShowNpcChat = !Map.ShowNpcChat; break;
            case "Mob": Map.ShowMob = !Map.ShowMob; break;
            case "MobName": Map.ShowMobName = !Map.ShowMobName; break;
            case "ID": Map.ShowID = !Map.ShowID; break;
            case "Portal": Map.ShowPortal = !Map.ShowPortal; break;
            case "BgmName": Map.ShowBgmName = !Map.ShowBgmName; break;
            case "Foothold": Map.ShowFootholds = !Map.ShowFootholds; break;
            case "Player": Map.ShowPlayer = !Map.ShowPlayer; break;
            case "MiniMap": Map.ShowMiniMap = !Map.ShowMiniMap; break;
            case "PortalInfo": Map.ShowPortalInfo = !Map.ShowPortalInfo; break;
        }
    }

    private void button1_Click(object sender, EventArgs e)
    {
        if (LabelRingTag.Instance != null)
        {
            LabelRingTag.Instance.MedalName = textBox1.Text;
            LabelRingTag.Instance.InitData();
            LabelRingTag.ReDraw();
        }
        Game.Player.Name = textBox1.Text;
        NameTag.ReDraw = true;
    }
}

```

`MapleNecrocer/ViewForm.resx`:

```resx
<root>
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`MapleNecrocer/Win32.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;

namespace MapleNecrocer;

public class Win32
{
    [DllImport("user32.dll")]
    private static extern int SendMessage(IntPtr hWnd, Int32 wMsg, bool wParam, Int32 lParam);
    public static void SendMessage(IntPtr hWnd, bool wParam)
    {
        SendMessage(hWnd, 11, wParam, 0);
    }
}

```

`MapleNecrocer/WorldMapForm.Designer.cs`:

```cs
namespace MapleNecrocer
{
    partial class WorldMapForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            pictureBox1 = new PictureBox();
            ((System.ComponentModel.ISupportInitialize)pictureBox1).BeginInit();
            SuspendLayout();
            // 
            // pictureBox1
            // 
            pictureBox1.AccessibleDescription = "";
            pictureBox1.Dock = DockStyle.Fill;
            pictureBox1.Location = new Point(0, 0);
            pictureBox1.Name = "pictureBox1";
            pictureBox1.Size = new Size(800, 450);
            pictureBox1.TabIndex = 0;
            pictureBox1.TabStop = false;
            // 
            // WorldMapForm
            // 
            AutoScaleMode = AutoScaleMode.None;
            ClientSize = new Size(800, 450);
            Controls.Add(pictureBox1);
            Font = new Font("Tahoma", 14F, FontStyle.Regular, GraphicsUnit.Pixel);
            KeyPreview = true;
            MaximizeBox = false;
            MinimizeBox = false;
            Name = "WorldMapForm";
            StartPosition = FormStartPosition.CenterScreen;
            Text = "WorldMap";
            TopMost = true;
            Load += WorldMapForm_Load;
            Shown += WorldMapForm_Shown;
            ((System.ComponentModel.ISupportInitialize)pictureBox1).EndInit();
            ResumeLayout(false);
        }

        #endregion

        public PictureBox pictureBox1;
    }
}
```

`MapleNecrocer/WorldMapForm.cs`:

```cs
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace MapleNecrocer;

public partial class WorldMapForm : Form
{
    public WorldMapForm()
    {
        InitializeComponent();
        Instance = this;
    }
    public static WorldMapForm Instance;
    private void WorldMapForm_Shown(object sender, EventArgs e)
    {


    }

    private void WorldMapForm_Load(object sender, EventArgs e)
    {
        this.FormClosing += (s, e1) =>
        {
            this.Hide();
            e1.Cancel = true;
        };
        MainForm.Instance.WorldMapListGrid.ColumnCount = 2;
        MainForm.Instance.WorldMapListGrid.Columns[0].Width = 203;
        MainForm.Instance.WorldMapListGrid.Columns[1].Width = 0;
        
        /*
        var StreetNameDict = new Dictionary<string, string>();
        foreach (var Iter in Wz.GetNodes("String/Map.img"))
        {
            foreach (var Iter2 in Iter.Nodes)
            {
                string ID = Iter2.Text.PadLeft(9, '0');
                var StreetName = Iter2.GetStr("streetName");
                if (!StreetNameDict.ContainsKey(ID))
                    StreetNameDict.Add(ID, StreetName);
            }
        }
      
        foreach (var img in Wz.GetNodes("Map/WorldMap"))
        {
            foreach (var Iter in Wz.GetNodes("Map/WorldMap/" + img.Text))
            {
                if (Iter.Text!="MapList")
                    continue;
                if(Iter.HasNode("0/mapNo/0"))
                {
                    if(StreetNameDict.ContainsKey(Iter.GetStr("0/mapNo/0")))
                      //  MainForm.Instance.WorldMapListGrid.Rows.Add(img.Text);
                        MainForm.Instance.WorldMapListGrid.Rows.Add(StreetNameDict[Iter.GetStr("0/mapNo/0")] );
                }
            }
        }
        */
        Dictionary<string, string> Dict = new();
        Dict.Add("BWorldMap.img", "Maple World");
        Dict.Add("GWorldMap.img", "Grandis");
        Dict.Add("MWorldMap.img", "Mirror World");
        Dict.Add("SWorldMap.img", "Star Planet");
        Dict.Add("WorldMap.img", "Maple World");
        Dict.Add("WorldMap000.img", "Maple Island");
        Dict.Add("WorldMap010.img", "Victoria Island");
        Dict.Add("WorldMap0101.img", "Kerning Tower");
        Dict.Add("WorldMap011.img", "Nautilus");
        Dict.Add("WorldMap012.img", "Sleepywood");
        Dict.Add("WorldMap0121.img", "Dark World Tree");
        Dict.Add("WorldMap015.img", "WorldMap015 ");
        Dict.Add("WorldMap016.img", "Shinsoo International School");
        Dict.Add("WorldMap017.img", "Ellinel Fairy Academy");
        Dict.Add("WorldMap018.img", "Gold Beach");
        Dict.Add("WorldMap019.img", "Mushroom Castle");
        Dict.Add("WorldMap020.img", "E1 Nath Mts.");
        Dict.Add("WorldMap021.img", "Dead Mine");
        Dict.Add("WorldMap022.img", "Lion King Castle");
        Dict.Add("WorldMap030.img", "Ludus Lake");
        Dict.Add("WorldMap031.img", "Clocktower Bottom Floor");
        Dict.Add("WorldMap032.img", "Ellin Forest ");
        Dict.Add("WorldMap033.img", "Fantastic Theme World");
        Dict.Add("WorldMap034.img", "Korean Folk Town");
        Dict.Add("WorldMap035.img", "Omega Sector");
        Dict.Add("WorldMap040.img", "Aqua Road");
        Dict.Add("WorldMap041.img", "Twisted Aqua Road");
        Dict.Add("WorldMap050.img", "Minar Forest");
        Dict.Add("WorldMap051.img", "Neo City ");
        Dict.Add("WorldMap052.img", "Stone Colossus");
        Dict.Add("WorldMap060.img", "Mu Lung Garden");
        Dict.Add("WorldMap061.img", "Golden Temple ");
        Dict.Add("WorldMap070.img", "Nihal Desert");
        Dict.Add("WorldMap071.img", "Ancient City Azwan");
        Dict.Add("WorldMap072.img", "Nihal Desert Trade Zone");
        Dict.Add("WorldMap080.img", "Temple of Time");
        Dict.Add("WorldMap081.img", "Gate of Future");
        Dict.Add("WorldMap082.img", "Arcane River");
        Dict.Add("WorldMap0821.img", "Vanishing Journey");
        Dict.Add("WorldMap0822.img", "Chu Chu Island");
        Dict.Add("WorldMap08221.img", "Lonely Chu Chu Island");
        Dict.Add("WorldMap0823.img", "Lachelein, the Dreaming City");
        Dict.Add("WorldMap0824.img", "Arcana");
        Dict.Add("WorldMap0825.img", "Morass, Swamp of Memory");
        Dict.Add("WorldMap0826.img", "Esfera ");
        Dict.Add("WorldMap090.img", "Ereve");
        Dict.Add("WorldMap100.img", "Rien");
        Dict.Add("WorldMap101.img", "Riena Strait");
        Dict.Add("WorldMap110.img", "Edelstein");
        Dict.Add("WorldMap111.img", "Scrapyard");
        Dict.Add("WorldMap120.img", "Crystal Garden");
        Dict.Add("WorldMap130.img", "Pantheon");
        Dict.Add("WorldMap140.img", "Heliseum");
        Dict.Add("WorldMap141.img", "Tyrant Castle");
        Dict.Add("WorldMap143.img", "Masteria");
        Dict.Add("WorldMap152.img", "皇陵之巔");
        Dict.Add("WorldMap153.img", "Commerci");
        Dict.Add("WorldMap154.img", "Arboren");
        Dict.Add("WorldMap155.img", "Meso Gear");
        Dict.Add("WorldMap160.img", "Zipangu");
        Dict.Add("WorldMap161.img", "Mushroom Shrine");
        Dict.Add("WorldMap163.img", "Ninja Castle");
        Dict.Add("WorldMap164.img", "未來 ");
        Dict.Add("WorldMap167.img", "東京 ");
        Dict.Add("WorldMap169.img", "Blackgate City");
        Dict.Add("WorldMap170.img", "Kritias");
        Dict.Add("WorldMap171.img", "Momijigaoka");
        Dict.Add("WorldMap172.img", "Spring Valley");
        Dict.Add("WorldMap173.img", "The Afterlands");
        Dict.Add("WorldMap174.img", "Eluna");
        Dict.Add("WorldMap175.img", "Beautyroid");
        Dict.Add("WorldMap176.img", "Abrup Basin");
        Dict.Add("WorldMap180.img", "Fox point Village");
        Dict.Add("WorldMap181.img", "Fox Valley");
        Dict.Add("WorldMap190.img", "Savage Terminal");
        Dict.Add("WorldMap191.img", "Sanctuary ");
        Dict.Add("WorldMap200.img", "Verdel");
        Dict.Add("WorldMap210.img", "Cheong-woon");
        Dict.Add("WorldMap220.img", " Ristonia");
        foreach (var img in Wz.GetNodes("Map/WorldMap"))
        {
            if (Dict.ContainsKey(img.Text))
                MainForm.Instance.WorldMapListGrid.Rows.Add(Dict[img.Text], img.Text);
            else
                MainForm.Instance.WorldMapListGrid.Rows.Add(img.Text, img.Text);
        }


    }
}

```

`MapleNecrocer/WorldMapForm.resx`:

```resx
<root>
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`MapleNecrocer/WzUtils.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WzComparerR2.Rendering;
using WzComparerR2.WzLib;
using WzComparerR2.Common;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework;
using System.Text.RegularExpressions;
using WzComparerR2.PluginBase;
using SharpDX;
using System.Drawing;
using MonoGame.Framework.Utilities.Deflate;
using System.Xml.Linq;
using System.Xml;
using Microsoft.Xna.Framework.Audio;
using DevComponents.AdvTree;
using System.Reflection.Metadata.Ecma335;

namespace MapleNecrocer;

public struct NodeInfo
{
    public string OriNode;
    public string UOLNode;
    public Wz_Node UOLEntry;
}
public enum WzType
{
    Character,
    Item,
    Mob,
    Npc,
    Skill
}
internal class Wz
{
    public static Dictionary<string, Wz_Node> Data = new Dictionary<string, Wz_Node>();
    public static Dictionary<string, Wz_Node> EquipData = new Dictionary<string, Wz_Node>();
    public static Dictionary<string, Texture2D> ImageKeys = new Dictionary<string, Texture2D>();
    public static Dictionary<Wz_Node, Texture2D> ImageLib = new Dictionary<Wz_Node, Texture2D>();
    public static Dictionary<Wz_Node, Texture2D> EquipImageLib = new Dictionary<Wz_Node, Texture2D>();
    public static Dictionary<Wz_Node, Texture2D> UIImageLib = new Dictionary<Wz_Node, Texture2D>();
    public static Dictionary<string, Wz_Node> UIData = new Dictionary<string, Wz_Node>();
    public static string Region;
    public static bool HasStringWz;
    //very old Data.wz has no Map1,Map2,Map3... dir
    public static bool HasMap9Dir;
    public static bool IsDataWz;
    private static List<NodeInfo> NodeList1 = new();

    private static List<NodeInfo> NodeList2 = new();


    public static void DumpDataA(Wz_Node WzNode, Dictionary<string, Wz_Node> DataLib, Dictionary<Wz_Node, Texture2D> ImageLib)
    {

        switch (WzNode.Value)
        {
            case Wz_Png:
                ImageLib.AddOrReplace(WzNode, WzLibExtension.ToTexture((Wz_Png)GetNode(WzNode.FullPathToFile2()).Value, RenderFormDraw.Instance.GraphicsDevice));
                DataLib.AddOrReplace(WzNode.FullPathToFile2(), WzNode);
                break;
            case Wz_Uol:
                DataLib.AddOrReplace(WzNode.FullPathToFile2(), GetNode(WzNode.FullPathToFile2()));
                break;
            default:
                DataLib.AddOrReplace(WzNode.FullPathToFile2(), WzNode);
                break;
        }

        foreach (var E in WzNode.Nodes)
            // if (!(E.Value is Wz_Image))
            DumpDataA(E, DataLib, ImageLib);
    }

    public static void DumpData(Wz_Node WzNode, Dictionary<string, Wz_Node> DataLib, Dictionary<Wz_Node, Texture2D> ImageLib,
       bool UseDye = false, int Hue = 0, int Saturation = 0, int Lightness = 0)
    {
        NodeList1.Clear();
        NodeList2.Clear();
        Scan1(WzNode, DataLib, ImageLib, UseDye, Hue, Saturation, Lightness);
        foreach (var P in NodeList1)
            Scan2(P.OriNode, P.UOLNode, P.UOLEntry, DataLib, ImageLib, UseDye, Hue, Saturation,Lightness);
        foreach (var P in NodeList2)
            Scan3(P.OriNode, P.UOLNode, P.UOLEntry, DataLib);
    }

    static void Scan1(Wz_Node WzNode, Dictionary<string, Wz_Node> DataLib, Dictionary<Wz_Node, Texture2D> ImageLib,
          bool UseDye = false, int Hue = 0, int Saturation = 0,int Lightness=0)
    {
        switch (WzNode.Value)
        {
            case Wz_Uol:
                var Entry = WzNode.ParentNode;
                var Child = Entry.Get(WzNode.ToStr());
                if (Child == null)
                    return;
                if (Child.Value is Wz_Uol)
                    Child = Child.ParentNode.Get(Child.ToStr());
                if (Child == null)
                    return;
                var NodeInfo = new NodeInfo();
                NodeInfo.OriNode = WzNode.FullPathToFile2();
                NodeInfo.UOLNode = Child.FullPathToFile2();
                NodeInfo.UOLEntry = Child;
                NodeList1.Add(NodeInfo);
                break;

            case Wz_Png:
                DataLib.AddOrReplace(WzNode.FullPathToFile2(), WzNode);
                if (UseDye)
                {
                    Texture2D Texture = ImageFilter.GetHSL(RenderFormDraw.Instance.GraphicsDevice, GetImgNode(WzNode.FullPathToFile2()).ExtractPng(), Hue, Saturation,Lightness);
                    ImageLib.AddOrReplace(WzNode, Texture);
                }
                else
                {
                    ImageLib.AddOrReplace(WzNode, WzLibExtension.ToTexture((Wz_Png)GetImgNode(WzNode.FullPathToFile2()).Value, RenderFormDraw.Instance.GraphicsDevice));
                }
                break;

            default:
                DataLib.AddOrReplace(WzNode.FullPathToFile2(), WzNode);
                break;
        }

        foreach (var C in WzNode.Nodes)
            Scan1(C, DataLib, ImageLib, UseDye, Hue, Saturation,Lightness);
    }

    static void Scan2(string OriNode, string UOLNode, Wz_Node WzNode, Dictionary<string, Wz_Node> DataLib, Dictionary<Wz_Node, Texture2D> ImageLib,
           bool UseDye = false, int Hue = 0, int Saturation = 0,int Lightness = 0)
    {
        Wz_Node Child;
        if (WzNode.Value is Wz_Uol)
        {
            var Entry = WzNode.ParentNode;
            Child = Entry.Get(WzNode.ToStr());
            if (Child == null)
                return;
            if (Child.Value is Wz_Uol)
                Child = Child.ParentNode.Get(Child.ToStr());
            //  if (Child == null)
            //  return;
        }
        else
            Child = WzNode;

        if (!(Child.Value is Wz_Uol))
        {
            string Str = WzNode.FullPathToFile2().Replace(UOLNode, "");
            DataLib.AddOrReplace(OriNode + Str, Child);
            NodeInfo NodeInfo = new NodeInfo();
            NodeInfo.OriNode = OriNode + Str;
            NodeInfo.UOLNode = Child.FullPathToFile2();
            NodeInfo.UOLEntry = Child;
            NodeList2.Add(NodeInfo);
        }

        if (Child.Value is Wz_Png)
        {
            if (!DataLib.ContainsKey(WzNode.FullPathToFile2()))
            {
                DataLib.AddOrReplace(WzNode.FullPathToFile2(), WzNode);

                if (UseDye)
                {
                    Texture2D Texture = ImageFilter.GetHSL(RenderFormDraw.Instance.GraphicsDevice, GetImgNode(WzNode.FullPathToFile2()).ExtractPng(), Hue, Saturation, Lightness);
                    ImageLib.AddOrReplace(WzNode, Texture);
                }
                else
                {
                    ImageLib.AddOrReplace(WzNode, WzLibExtension.ToTexture((Wz_Png)GetImgNode(WzNode.FullPathToFile2()).Value, RenderFormDraw.Instance.GraphicsDevice));
                }
            }
        }

        foreach (var C in WzNode.Nodes)
            Scan2(OriNode, UOLNode, C, DataLib, ImageLib, UseDye, Hue, Saturation);
    }

    static void Scan3(string OriNode, string UOLNode, Wz_Node WzNode, Dictionary<string, Wz_Node> DataLib)
    {
        string Str = WzNode.FullPathToFile2().Replace(UOLNode, "");
        DataLib.AddOrReplace(OriNode + Str, WzNode);
        foreach (var C in WzNode.Nodes)
            Scan3(OriNode, UOLNode, C, DataLib);
    }
    public static bool HasNode(string Path)
    {
        return Wz.GetNode(Path) != null;
    }
    public static bool HasData(string Path)
    {
        return Data.ContainsKey(Path) != false;

    }
    public static bool HasDataE(string Path)
    {
        return EquipData.ContainsKey(Path) != false;

    }

    public static int GetInt(string Path, int DefaultValue = 0)
    {
        if (Wz.HasNode(Path))
            return Wz.GetNode(Path).GetValueEx<int>(DefaultValue);
        else
            return DefaultValue;
    }
    public static string GetStr(string Path, string DefaultValue = "")
    {
        if (Wz.HasNode(Path))
            return Wz.GetNode(Path).GetValueEx<string>(DefaultValue);
        else
            return DefaultValue;
    }

    public static bool GetBool(string Path)
    {
        return Convert.ToBoolean(Wz.GetNode(Path).GetValueEx<int>(0));
    }

    public static Wz_Vector GetVector(string Path)
    {
        return Wz.GetNode(Path).GetValueEx<Wz_Vector>(new Wz_Vector(0, 0)); ;
    }

    public static Bitmap GetBmp(string Path)
    {
        if (Wz.GetNode(Path) != null && Wz.GetNode(Path).Value is Wz_Png)
        {
            return Wz.GetNode(Path).ExtractPng();
        }
        else
        {
            return new Bitmap(1, 1);
        }
    }

    public static Wz_Node.WzNodeCollection GetNodes(string Path)
    {
        return Wz.GetNode(Path).Nodes;
    }


    public static Wz_Node GetNodeA(string Path)
    {
        return PluginManager.FindWz(Path);
        /*
        if (Node != null)
        {
            if (Node.Value is Wz_Uol)
            {
                return Node.ResolveUol();
            }
            else
            {
                return Node;
            }
        }
        */
        // return null;
    }

    public static Wz_Node GetNode(string Path)
    {
        Wz_Node Node = PluginManager.FindWz(Path);
        if (Node != null)
        {
            if (Node.Value is Wz_Uol)
            {
                Wz_Node Node2;
                Node2 = Node.ResolveUol();
                if (Node2.FindNodeByPath("_outlink", true) != null)
                {
                    var LinkStr = Node2.FindNodeByPath("_outlink", true).Value.ToString();
                    string[] Split = LinkStr.Split('/');
                    string DestPath = "";
                    switch (Split[0])
                    {
                        case "Mob":
                            return PluginManager.FindWz(LinkStr);
                            break;

                        case "Map":
                            return PluginManager.FindWz(LinkStr);
                            /*
                             if(Split[1] == "Map")
                                 DestPath = LinkStr.Remove(0,4);
                             else
                                 DestPath = Regex.Replace(LinkStr,"Map/","");
                             return MainForm.GetNode(DestPath);
                             */
                            break;
                        case "Skill":
                            return GetNode(LinkStr);
                            break;
                        default:
                            DestPath = Regex.Replace(LinkStr, Node.GetNodeWzFile().Type.ToString() + "/", "");
                            //   return (Node.GetNodeWzFile().WzStructure.WzNode.GetNode(DestPath).Value as Wz_Png).ExtractPng();
                            break;
                    };
                }
                return Node2;
            }
            else
                return Node.GetLinkedSourceNode(PluginManager.FindWz);
        }
        else
        {
            string[] Split = Path.Split('/');
            var Node2 = PluginManager.FindWz(Split[0]);
            int Count = 0;
            string Str = "";
            string Path1 = "";
            string Path2 = "";
            bool HasUol = false;
            for (int i = 1; i < Split.Length; i++)
            {
                if (i == 1)
                    Str = Str + Split[i];
                else
                    Str += '/' + Split[i];
                if ((Node2.FindNodeByPathA(Str, true) != null) && (Node2.FindNodeByPathA(Str, true).Value is Wz_Uol))
                {
                    HasUol = true;
                    Count = i;
                    Path1 = Str;
                    break;
                }
            }

            if (HasUol)
            {
                Str = "";
                for (int i = Count + 1; i < Split.Length; i++)
                {
                    if (i == Count + 1)
                        Str = Str + Split[i];
                    else
                        Str = Str + '/' + Split[i];
                    Path2 = Str;
                }
                return Node2.FindNodeByPathA(Path1, true).ResolveUol().FindNodeByPathA(Path2, true);
            }
        }
        return null;
    }

    public static Wz_Node GetImgNodeA(string Path)
    {
        var Split = Path.Split(".img/");
        return PluginManager.FindWz(Split[0] + ".img").Get(Split[1]);
    }
    public static Wz_Node GetImgNode(string Path)
    {
        //  Path = Path.Replace("Data/", "");
        var Split = Path.Split(".img/");
        return PluginManager.FindWz(Split[0] + ".img").Get2(Split[1]);
    }
    public static Wz_Node GetTopEntry(Wz_Node Node)
    {
        var E = Node.ParentNode;
        while (E != null)
        {
            E = E.ParentNode;
            if ((E.Text.Length >= 4) && (E.Text.RightStr(4) == ".img"))
                return E;
        }
        return null;
    }

    public static Wz_Node GetNodeByID(string ID, WzType wzType)
    {
        if (wzType == WzType.Item)
        {
            switch (ID.LeftStr(2))
            {
                case "02":
                    return GetNode("Item/Consume/" + ID.LeftStr(4) + ".img/" + ID);
                case "04":
                    return GetNode("Item/Etc/" + ID.LeftStr(4) + ".img/" + ID);
                case "05":
                    return GetNode("Item/Cash/" + ID.LeftStr(4) + ".img/" + ID);
                case "50":
                    return GetNode("Item/Pet/" + ID + ".img");

                case "03":
                    if (GetNode("Item/Install/03010.img") != null)
                    {
                        switch (ID.LeftStr(5))
                        {
                            case "03015":
                                return GetNode("Item/Install/" + ID.LeftStr(6) + ".img/" + ID);
                                break;
                            case "03010":
                            case "03011":
                            case "03012":
                            case "03013":
                            case "03014":
                            case "03016":
                            case "03017":
                            case "03018":
                                return GetNode("Item/Install/" + ID.LeftStr(5) + ".img/" + ID);
                                break;
                            default:
                                return GetNode("Item/Install/" + ID.LeftStr(4) + ".img/" + ID);
                                break;
                        }
                    }
                    else
                    {
                        return GetNode("Item/Install/" + ID.LeftStr(4) + ".img/" + ID);
                    }
                    break;
            }
        }
        else if (wzType == WzType.Character)
        {
            switch (int.Parse(ID) / 10000)
            {
                case 2:
                    return GetNode("Character/Face/" + ID + ".img");
                    break;
                case 3:
                case 4:
                case 6:
                    return GetNode("Character/Hair/" + ID + ".img");
                    break;
                case 101:
                case 102:
                case 103:
                case 112:
                case 113:
                case 114:
                case 115:
                case 116:
                case 118:
                case 119:
                    return GetNode("Character/Accessory/" + ID + ".img");
                    break;
                case 120:
                    return GetNode("Character/Totem/" + ID + ".img");
                    break;
                case 100:
                    return GetNode("Character/Cap/" + ID + ".img");
                    break;
                case 110:
                    return GetNode("Character/Cape/" + ID + ".img");
                    break;
                case 104:
                    return GetNode("Character/Coat/" + ID + ".img");
                    break;
                case 105:
                    return GetNode("Character/Longcoat/" + ID + ".img");
                    break;
                case 106:
                    return GetNode("Character/Pants/" + ID + ".img");
                    break;
                case 107:
                    return GetNode("Character/Shoes/" + ID + ".img");
                    break;
                case 108:
                    return GetNode("Character/Glove/" + ID + ".img");
                case 109:
                    return GetNode("Character/Shield/" + ID + ".img");
                    break;

                case 111:
                    return GetNode("Character/Ring/" + ID + ".img");
                    break;

                case 161:
                    return GetNode("Character/Mechanic/" + ID + ".img");
                    break;

                case 166:
                case 167:
                    return GetNode("Character/Android/" + ID + ".img");
                    break;
                case 168:
                    return GetNode("Character/Bits/" + ID + ".img");
                    break;
                case int n when (n >= 121 && n <= 170):
                    return GetNode("Character/Weapon/" + ID + ".img");
                    break;
                case int n when (n >= 190 && n <= 199):
                    return GetNode("Character/TamingMob/" + ID + ".img");
                    break;
                case 180:
                    return GetNode("Character/PetEquip/" + ID + ".img");
                    break;
                case 996:
                case 997:
                    return GetNode("Character/Familiar/" + ID + ".img");
                    break;
                case int n when (n >= 200 && n <= 294):
                    return GetNode("Item/Consume/" + ID.LeftStr(4) + ".img/" + ID);
                    break;
                case int n when (n >= 400 && n <= 446):
                    return GetNode("Item/Etc/" + ID.LeftStr(4) + ".img/" + ID);
                    break;

                case 500:
                    return GetNode("Item/Pet/" + ID + ".img");
                    break;
            }
        }
        else if (wzType == WzType.Mob)
        {
            return GetNode("Mob/" + ID + ".img");
        }
        else if (wzType == WzType.Npc)
        {
            return GetNode("Npc/" + ID + ".img");
        }
        else if (wzType == WzType.Skill)
        {
            if (ID.LeftStr(1) == "8")
                return GetNode("Skill/" + (int.Parse(ID) / 100).ToString() + ".img/skill/" + ID);
            else
                return GetNode("Skill/" + (int.Parse(ID) / 10000).ToString() + ".img/skill/" + ID);
        }
        return null;
    }


}
internal class WzDict
{
    public static int GetInt(string Path, int DefaultValue = 0)
    {
        if (Wz.Data.ContainsKey(Path))
            return Wz.Data[Path].GetValueEx<int>(0);
        else
            return DefaultValue;
    }

    public static string GetStr(string Path, string DefaultValue = "")
    {
        if (Wz.Data.ContainsKey(Path))
            return Wz.Data[Path].GetValueEx<string>("");
        return
            DefaultValue;
    }
    public static Wz_Vector GetVector(string Path)
    {
        if (Wz.Data.ContainsKey(Path))
        {
            return Wz.Data[Path].ToVector();
        }
        else
            return new Wz_Vector(0, 0);
    }

    public static Vector2 GetVectorE(string Path)
    {
        if (Wz.EquipData.ContainsKey(Path))
        {
            Vector2 V;
            V.X = Wz.EquipData[Path].ToVector().X;
            V.Y = Wz.EquipData[Path].ToVector().Y;
            return V;
        }
        else
            return new Vector2(0, 0);
    }
    public static bool GetBool(string Path)
    {
        if (Wz.Data.ContainsKey(Path))
        {
            return Wz.Data[Path].ToBool();
        }
        else
            return false;
    }
}

public static class Wz_NodeExtension3
{
    public static Wz_Node GetNode(this Wz_Node Node, string Path)
    {

        if (Node.FindNodeByPathA(Path, true) != null)
        {
            if (Node.FindNodeByPathA(Path, true).Value is Wz_Uol)
            {
                Wz_Node Child = Node.FindNodeByPathA(Path, true).ResolveUol();

                if (Child != null)
                {
                    switch (Child.Value)
                    {
                        //uol link to uol
                        case Wz_Uol:
                            return Child.ParentNode.Get(Child.ToStr());
                            break;
                        // UOL link to Canvas
                        case Wz_Png:
                            if (Child.Nodes["_inlink"] != null)
                                return Wz.GetTopEntry(Child).Get(Child.Nodes["_inlink"].ToStr());
                            else if (Child.Nodes["_outlink"] != null)
                                return Wz.GetImgNode(Child.Nodes["_outlink"].ToStr());
                            break;
                    }
                }
                return Child;
            }
            else
            {
                var FullPath = Node.FindNodeByPathA(Path, true).FullPathToFileEx();

                string[] Split = FullPath.Split('/');
                switch (Split[0])
                {
                    case "Data":
                        FullPath = FullPath.Replace("Data/", "");
                        break;

                    case "Map001":
                        FullPath = FullPath.Replace("Map001", "Map");
                        break;
                    case "Map002":
                        FullPath = FullPath.Replace("Map002", "Map");
                        break;
                    case "Map2":
                        FullPath = FullPath.Replace("Map2", "Map");
                        break;
                    case "Mob001":
                        FullPath = FullPath.Replace("Mob001", "Mob");
                        break;
                    case "Mob002":
                        FullPath = FullPath.Replace("Mob002", "Mob");
                        break;
                    case "Mob2":
                        FullPath = FullPath.Replace("Mob2", "Mob");
                        break;
                    case "Skill001":
                        FullPath = FullPath.Replace("Skill001", "Skill");
                        break;
                    case "Skill002":
                        FullPath = FullPath.Replace("Skill002", "Skill");
                        break;
                    case "Skill003":
                        FullPath = FullPath.Replace("Skill003", "Skill");
                        break;
                    case "Sound001":
                        FullPath = FullPath.Replace("Sound001", "Sound");
                        break;
                    case "Sound002":
                        FullPath = FullPath.Replace("Sound002", "Sound");
                        break;
                    case "Sound2":
                        FullPath = FullPath.Replace("Sound2", "Sound");
                        break;
                }

                Node = PluginManager.FindWz(FullPath);
                return Node.GetLinkedSourceNode(PluginManager.FindWz);

            }
        }
        else
        {
            string[] Split = Path.Split('/');
            int Count = 0;
            string Str = "";
            string Path1 = "";
            string Path2 = "";
            bool HasUol = false;
            for (int i = 0; i < Split.Length; i++)
            {

                if (i == 0)
                    Str = Str + Split[i];
                else
                    Str += '/' + Split[i];
                if ((Node.FindNodeByPathA(Str, true) != null) && (Node.FindNodeByPathA(Str, true).Value is Wz_Uol))
                {
                    HasUol = true;
                    Count = i;
                    Path1 = Str;
                    break;
                }

            }

            if (HasUol)
            {
                Str = "";
                for (int i = Count + 1; i < Split.Length; i++)
                {
                    if (i == Count + 1)
                        Str = Str + Split[i];
                    else
                        Str = Str + '/' + Split[i];
                    Path2 = Str;
                }
                return Node.FindNodeByPathA(Path1, true).ResolveUol().FindNodeByPathA(Path2, true);
            }
        }
        return null;
    }

    public static Wz_Node.WzNodeCollection GetNodes(this Wz_Node Node, string Path)
    {
        return Node.GetNode(Path).Nodes;
    }

    public static bool HasNode(this Wz_Node Node, string Path)
    {
        return Node.GetNode(Path) != null;

    }
    public static int GetInt(this Wz_Node Node, string Path, int DefaultValue = 0)
    {
        return Node.GetNode(Path).GetValueEx(DefaultValue);
    }
    public static bool GetBool(this Wz_Node Node, string Path)
    {
        return Convert.ToBoolean(Node.GetNode(Path).GetValueEx<int>(0));
    }
    public static string GetStr(this Wz_Node Node, string Path, string DefaultStr = "")
    {
        return Node.GetNode(Path).GetValueEx<string>(DefaultStr);
    }
    public static Wz_Vector GetVector(this Wz_Node Node, string Path)
    {
        return Node.GetNode(Path).GetValueEx<Wz_Vector>(new Wz_Vector(0, 0));

    }
    public static Bitmap GetBmp(this Wz_Node Node, string Path)
    {
        return Node.GetNode(Path).ExtractPng();
    }

    public static Wz_Node Get2(this Wz_Node Node, string Path)
    {


        var Split = Path.Split('/');
        var Result = Node;


        for (int i = 0; i < Split.Length; i++)
        {

            if (Split[i] == "..")
                Result = Result.ParentNode;
            else
                Result = Result.Nodes[Split[i]];
        }

        switch (Result.Value)
        {
            case Wz_Uol:
                Wz_Node Entry = Result.ParentNode;
                Wz_Node Child = Entry.Get(Result.ToStr());
                if (Child == null)
                {
                    string Err = Result.FullPathToFile2();
                    if (Err.LeftStr(3) != "Npc")
                    {
                        string s1 = Result.FullPathToFile2();
                        string s2 = Result.ToStr().Replace("../", "");
                        Split = s2.Split("/");
                        s2 = "";
                        for (int i = 0; i < Split.Length; i++)
                            s2 = s2 + Split[i] + "/";
                        s2 = Split[0] + ".img/" + s2;
                        s2 = s2.Remove(s2.Length - 1);
                        Child = Wz.GetImgNode(s1.Replace(s1.RightStr(s2.Length), s2));
                        if (Child == null)
                            return Wz.GetImgNode("Character/00002000.img/alert/0/arm");
                    }
                    else
                        Child = Wz.GetImgNode("Character/00002000.img/alert/0/arm");
                }

                if (Child != null)
                {
                    switch (Child.Value)
                    {
                        //uol link to uol
                        case Wz_Uol:
                            return Child.ParentNode.Get(Child.ToStr());
                            break;
                        // UOL link to Canvas
                        case Wz_Png:
                            if (Child.Nodes["_inlink"] != null)
                                return Wz.GetTopEntry(Child).Get(Child.Nodes["_inlink"].ToStr());
                            else if (Child.Nodes["_outlink"] != null)
                                return Wz.GetImgNode(Child.Nodes["_outlink"].ToStr());
                            break;
                    }
                }
                return Child;
                break;

            case Wz_Png:
                if (Result.Nodes["_outlink"] != null)
                {
                    string OutLink = Result.Nodes["_outlink"].ToStr();
                    Result = Wz.GetImgNode(OutLink);
                }
                else if (Result.Nodes["_inlink"] != null)
                {
                    Result = Wz.GetTopEntry(Result).Get(Result.Nodes["_inlink"].ToStr());

                }
                else if (Result.Nodes["source"] != null)
                {
                    Result = Wz.GetImgNode(Result.Nodes["source"].ToStr());
                }
                break;

        }
        return Result;
    }
}


```

`README.md`:

```md
# MapleNecrocer
C# version of MapleStory GM Client.  
The C# version supports more features that aim to replace Delphi 32bit version.  

Features:  
-64 Bit Client.  
-Support _Canvas wz files  
-Support map's skeleton animation and particle system.  
-Auto detect wz region, you don't need to select corresponding wz version   
-A better wz lib (for older and newer wz)   


![alt tag](https://imgur.com/bgBOS1c.jpg"")  
![alt tag](https://i.imgur.com/bI1OhlG.jpg"")  
![alt tag](https://i.imgur.com/1wwsTem.jpg"")  
![alt tag](https://i.imgur.com/ELaZq9Y.jpg"")  


Compile:  
Vs 2022 or higher  
Credits and Acknowledgement:  
Kagamia's WzComparerR2  


```

`WzComparerR2.Common/Animation/Frame.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using WzComparerR2.WzLib;
using WzComparerR2.Common;
using WzComparerR2.Rendering;
using Rectangle=Microsoft.Xna.Framework.Rectangle;
using Point = Microsoft.Xna.Framework.Point;

namespace WzComparerR2.Animation
{
    public class Frame
    {
        public Frame()
        {
            this.A0 = 255;
            this.A1 = 255;
        }

        public Frame(Texture2D texture) : this(texture, null)
        {
        }

        public Frame(Texture2D atlasPage, Rectangle? atlasRect) : this()
        {
            this.Texture = atlasPage;
            this.AtlasRect = atlasRect;
        }

        public Texture2D Texture { get; set; }
        public Rectangle? AtlasRect { get; set; }
        public Wz_Png Png { get; set; }
        public Point Origin { get; set; }
        public int Z { get; set; }
        public int Delay { get; set; }
        public int A0 { get; set; }
        public int A1 { get; set; }
        public bool Blend { get; set; }

        public Rectangle Rectangle
        {
            get
            {
                if (AtlasRect != null)
                {
                    return new Rectangle(-Origin.X, -Origin.Y, AtlasRect.Value.Width, AtlasRect.Value.Height);
                }
                else if (Texture != null)
                {
                    return new Rectangle(-Origin.X, -Origin.Y, Texture.Width, Texture.Height);
                }
                else
                {
                    return Rectangle.Empty;
                }   
            }
        }

        public static Frame CreateFromNode(Wz_Node frameNode, GraphicsDevice graphicsDevice, GlobalFindNodeFunction findNode)
        {
            if (frameNode == null || frameNode.Value == null)
            {
                return null;
            }

            while (frameNode.Value is Wz_Uol)
            {
                Wz_Uol uol = frameNode.Value as Wz_Uol;
                Wz_Node uolNode = uol.HandleUol(frameNode);
                if (uolNode != null)
                {
                    frameNode = uolNode;
                }
                else
                {
                    break;
                }
            }
            if (frameNode.Value is Wz_Png)
            {
                var linkNode = frameNode.GetLinkedSourceNode(findNode);
                Wz_Png png = linkNode?.GetValue<Wz_Png>() ?? (Wz_Png)frameNode.Value;

                var frame = new Frame(png.ToTexture(graphicsDevice))
                {
                    Png = png,
                };

                foreach (Wz_Node propNode in frameNode.Nodes)
                {
                    switch (propNode.Text)
                    {
                        case "origin":
                            frame.Origin = (propNode.Value as Wz_Vector).ToPoint();
                            break;
                        case "delay":
                            frame.Delay = propNode.GetValue<int>();
                            break;
                        case "z":
                            frame.Z = propNode.GetValue<int>();
                            break;
                        case "a0":
                            frame.A0 = propNode.GetValue<int>();
                            break;
                        case "a1":
                            frame.A1 = propNode.GetValue<int>();
                            break;
                    }
                }

                if (frame.Delay == 0)
                {
                    frame.Delay = 100;//给予默认delay
                }
                return frame;
            }
            return null;
        }
    }
}

```

`WzComparerR2.Common/Animation/FrameAnimationData.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using WzComparerR2.WzLib;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Rectangle = Microsoft.Xna.Framework.Rectangle;


namespace WzComparerR2.Animation
{
    public class FrameAnimationData 
    {
        public FrameAnimationData()
        {
            this.Frames = new List<Frame>();
        }

        public FrameAnimationData(IEnumerable<Frame> frames)
        {
            this.Frames = new List<Frame>(frames);
        }

        public List<Frame> Frames { get; private set; }

        public Rectangle GetBound()
        {
            Rectangle? bound = null;
            foreach (var frame in this.Frames)
            {
                bound = bound == null ? frame.Rectangle : Rectangle.Union(frame.Rectangle, bound.Value);
            }
            return bound ?? Rectangle.Empty;
        }

        public static FrameAnimationData CreateFromNode(Wz_Node node, GraphicsDevice graphicsDevice, FrameAnimationCreatingOptions options, GlobalFindNodeFunction findNode)
        {
            if (node == null)
                return null;
            var anime = new FrameAnimationData();
            if (options.HasFlag(FrameAnimationCreatingOptions.ScanAllChildrenFrames))
            {
                foreach(var frameNode in node.Nodes)
                {
                    Frame frame = Frame.CreateFromNode(frameNode, graphicsDevice, findNode);
                    if (frame != null)
                    {
                        anime.Frames.Add(frame);
                    }
                }
            }
            else
            {
                for (int i = 0; ; i++)
                {
                    Wz_Node frameNode = node.FindNodeByPath(i.ToString());

                    if (frameNode == null || frameNode.Value == null)
                        break;
                    Frame frame = Frame.CreateFromNode(frameNode, graphicsDevice, findNode);

                    if (frame == null)
                        break;
                    anime.Frames.Add(frame);
                }
            }

            if (anime.Frames.Count > 0)
                return anime;
            else
                return null;
        }
    }

    [Flags]
    public enum FrameAnimationCreatingOptions
    {
        None = 0,
        FindFrameNameInOrdinalNumber = 1 << 0,
        ScanAllChildrenFrames = 1 << 1,
    }
}

```

`WzComparerR2.Common/Animation/FrameAnimator.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Collections.ObjectModel;
using WzComparerR2.Controls;
using Microsoft.Xna.Framework;
using Rectangle = Microsoft.Xna.Framework.Rectangle;


namespace WzComparerR2.Animation
{
    public class FrameAnimator : AnimationItem
    {
        public FrameAnimator(FrameAnimationData data)
        {
            this.Data = data;
            this.Load();
        }

        public FrameAnimationData Data { get; private set; }

        public Frame CurrentFrame { get; protected set; }

        public override int Length
        {
            get { return this._length; }
        }

        public int CurrentTime
        {
            get { return _timeOffset; }
            protected set { _timeOffset = value; }
        }

        private int _timeOffset;
        private int _length;
        private int[] _timeline;

        public override void Update(TimeSpan elapsedTime)
        {
            if (_length <= 0)
            {
                _timeOffset = 0;
            }
            else
            {
                _timeOffset += (int)elapsedTime.TotalMilliseconds;
                _timeOffset %= _length;
            }
            this.UpdateFrame();
        }

        public override void Reset()
        {
            _timeOffset = 0;
            this.UpdateFrame();
        }

        public override Rectangle Measure()
        {
            return CurrentFrame?.Rectangle ?? Rectangle.Empty;
        }

        public KeyFrame[] GetKeyFrames()
        {
            return this.Data.Frames.Select(f =>
                new KeyFrame() { Length = f.Delay, Animated = f.A0 != f.A1 }
                ).ToArray();
        }

        protected virtual void Load()
        {
            _timeline = CreateTimeline(this.Data.Frames.Select(f => f.Delay));
            _length = _timeline.Last();
            _timeOffset = 0;
            this.UpdateFrame();
        }

        protected virtual void UpdateFrame()
        {
            if (this.Data.Frames.Count <= 0)
            {
                this.CurrentFrame = null;
                return;
            }

            float progress;
            int index = GetProcessFromTimeline(_timeline, _timeOffset, out progress);

            var frame = this.Data.Frames[index];
            if (this.CurrentFrame == null)
            {
                this.CurrentFrame = new Frame();
            }
            this.CurrentFrame.Texture = frame.Texture;
            this.CurrentFrame.AtlasRect = frame.AtlasRect;
            this.CurrentFrame.Z = frame.Z;
            this.CurrentFrame.Origin = frame.Origin;
            this.CurrentFrame.A0 = (int)MathHelper.Lerp(frame.A0, frame.A1, progress);
            this.CurrentFrame.Blend = frame.Blend;
        }

        public override object Clone()
        {
            return new FrameAnimator(this.Data);
        }

        public static int[] CreateTimeline(IEnumerable<int> delays)
        {
            var timeLine = new List<int>() { 0 };
            foreach (var ms in delays)
            {
                timeLine.Add(timeLine[timeLine.Count - 1] + ms);
            }
            return timeLine.ToArray();
        }

        public static int GetProcessFromTimeline(int[] timeline, int timeOffset, out float progress)
        {
            int index = Array.BinarySearch(timeline, timeOffset);
            progress = 0;
            if (index < 0)
            {
                index = ~index - 1;
                progress = (float)(timeOffset - timeline[index]) / (timeline[index + 1] - timeline[index]);
            }
            return index;
        }
    }
}

```

`WzComparerR2.Common/Animation/ISpineAnimationData.cs`:

```cs
using System;
using WzComparerR2.Common;

namespace WzComparerR2.Animation
{
    public interface ISpineAnimationData
    {
        bool PremultipliedAlpha { get; }
        object SkeletonData { get; }
        SpineVersion SpineVersion { get; }
        ISpineAnimator CreateAnimator();
    }
}

```

`WzComparerR2.Common/Animation/ISpineAnimator.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;

namespace WzComparerR2.Animation
{
    public interface ISpineAnimator
    {
        ISpineAnimationData Data { get; }
        object Skeleton { get; }
        ReadOnlyCollection<string> Animations { get; }
        ReadOnlyCollection<string> Skins { get; }
        int SelectedAnimationIndex { get; set; }
        string SelectedAnimationName { get; set; }
        string SelectedSkin { get; set; }
        int CurrentTime { get; }
        void Render(Spine.SkeletonRenderer renderer);
    }
}

```

`WzComparerR2.Common/Animation/KeyFrame.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace WzComparerR2.Animation
{
    public struct KeyFrame
    {
        public int Length { get; set; }
        public bool Animated { get; set; }
    }
}

```

`WzComparerR2.Common/Animation/ModelBound.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.Xna.Framework;
using Rectangle = Microsoft.Xna.Framework.Rectangle;

namespace WzComparerR2.Animation
{
    public struct ModelBound
    {
        public float minX, minY, maxX, maxY;

        public bool IsEmpty
        {
            get { return minX >= maxX || minY >= maxY; }
        }

        public void Update(float[] vertices, int count)
        {
            int i = 0;
            if (count % 4 != 0)
            {
                if (vertices[0] > maxX) maxX = vertices[0];
                if (vertices[0] < minX) minX = vertices[0];
                if (vertices[1] > maxY) maxY = vertices[1];
                if (vertices[1] < minY) minY = vertices[1];
                i += 2;
            }

            while (i < count)
            {
                if (vertices[i] > vertices[i + 2])
                {
                    if (vertices[i] > maxX) maxX = vertices[i];
                    if (vertices[i + 2] < minX) minX = vertices[i + 2];
                }
                else
                {
                    if (vertices[i + 2] > maxX) maxX = vertices[i + 2];
                    if (vertices[i] < minX) minX = vertices[i];
                }

                if (vertices[i + 1] > vertices[i + 3])
                {
                    if (vertices[i + 1] > maxY) maxY = vertices[i + 1];
                    if (vertices[i + 3] < minY) minY = vertices[i + 3];
                }
                else
                {
                    if (vertices[i + 3] > maxY) maxY = vertices[i + 3];
                    if (vertices[i + 1] < minY) minY = vertices[i + 1];
                }

                i += 4;
            }
        }

        public Rectangle GetBound()
        {
            if (IsEmpty)
            {
                return new Rectangle();
            }

            return new Rectangle((int)Math.Round(minX),
                (int)Math.Round(minY),
                (int)Math.Round(maxX - minX),
                (int)Math.Round(maxY - minY));
        }

        public static ModelBound Empty
        {
            get
            {
                var b = new ModelBound();
                b.minX = b.minY = float.MaxValue;
                b.maxX = b.maxY = float.MinValue;
                return b;
            }
        }
    }
}

```

`WzComparerR2.Common/Animation/MultiFrameAnimationData.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using WzComparerR2.WzLib;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;

namespace WzComparerR2.Animation
{
    public class MultiFrameAnimationData 
    {
        public MultiFrameAnimationData()
        {
            this.Frames = new Dictionary<string, List<Frame>>();
        }

        public Dictionary<string, List<Frame>> Frames { get; private set; }

        public Rectangle GetBound(string aniName)
        {
            Rectangle? bound = null;
            if (aniName == null)
            {
                return Rectangle.Empty;
            }
            foreach (var frame in this.Frames[aniName])
            {
                bound = bound == null ? frame.Rectangle : Rectangle.Union(frame.Rectangle, bound.Value);
            }
            return bound ?? Rectangle.Empty;
        }

        public static MultiFrameAnimationData CreateFromNode(Wz_Node node, GraphicsDevice graphicsDevice, GlobalFindNodeFunction findNode)
        {
            if (node == null)
                return null;
            var anime = new MultiFrameAnimationData();
            for (int i = 0; ; i++)
            {
                Wz_Node frameNode = node.FindNodeByPath(i.ToString());

                if (frameNode == null)
                    break;

                while (frameNode.Value is Wz_Uol)
                {
                    Wz_Uol uol = frameNode.Value as Wz_Uol;
                    Wz_Node uolNode = uol.HandleUol(frameNode);
                    if (uolNode != null)
                    {
                        frameNode = uolNode;
                    }
                }

                int delay = frameNode.Nodes["delay"].GetValueEx<int>(100);
                int count = 0;
                foreach (Wz_Node aniNode in frameNode.Nodes)
                {
                    Frame frame = Frame.CreateFromNode(aniNode, graphicsDevice, findNode);

                    if (frame == null)
                        continue;
                    frame.Delay = delay;
                    if (!anime.Frames.ContainsKey(aniNode.Text))
                    {
                        if (i != 0)
                        {
                            return null;
                        }
                        anime.Frames[aniNode.Text] = new List<Frame>();
                    }
                    anime.Frames[aniNode.Text].Add(frame);
                    count++;
                }
                if (anime.Frames.Count != count)
                {
                    return null;
                }
            }
            if (anime.Frames.Count > 0)
                return anime;
            else
                return null;
        }
    }
}

```

`WzComparerR2.Common/Animation/MultiFrameAnimator.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Collections.ObjectModel;
using WzComparerR2.Controls;
using Microsoft.Xna.Framework;

namespace WzComparerR2.Animation
{
    public class MultiFrameAnimator : AnimationItem
    {
        public MultiFrameAnimator(MultiFrameAnimationData data)
        {
            this.Data = data;
            this._selectedAniIndex = 0;
            this.Load();
        }

        public MultiFrameAnimationData Data { get; private set; }

        public ReadOnlyCollection<string> Animations { get; private set; }

        public Frame CurrentFrame { get; protected set; }

        public int SelectedAnimationIndex
        {
            get
            {
                return this._selectedAniIndex;
            }
            set
            {
                if (value > -1)
                {
                    this._selectedAniIndex = value;
                }
                else
                {
                    this._selectedAniIndex = -1;
                }

                this._timeOffset = 0;
            }
        }

        public string SelectedAnimationName
        {
            get
            {
                if (this._selectedAniIndex > -1)
                {
                    return this.Animations[this._selectedAniIndex];
                }
                return null;
            }
            set
            {
                if (value != null)
                {
                    this.SelectedAnimationIndex = this.Animations.IndexOf(value);
                }
                else
                {
                    this.SelectedAnimationIndex = -1;
                }
            }
        }

        public override int Length
        {
            get { return SelectedAnimationName != null ? this._length : 0; }
        }

        public int CurrentTime
        {
            get { return _timeOffset; }
            protected set { _timeOffset = value; }
        }

        private int _timeOffset;
        private int _length;
        private int[] _timeline;
        private int _selectedAniIndex;

        public override void Update(TimeSpan elapsedTime)
        {
            if (_length <= 0)
            {
                _timeOffset = 0;
            }
            else
            {
                _timeOffset += (int)elapsedTime.TotalMilliseconds;
                _timeOffset %= _length;
            }
            this.UpdateFrame();
        }

        public override void Reset()
        {
            _timeOffset = 0;
            this.UpdateFrame();
        }

        public override Rectangle Measure()
        {
            return CurrentFrame?.Rectangle ?? Rectangle.Empty;
        }

        public KeyFrame[] GetKeyFrames()
        {
            return this.Data.Frames[SelectedAnimationName].Select(f =>
                new KeyFrame() { Length = f.Delay, Animated = f.A0 == f.A1 }
                ).ToArray();
        }

        protected virtual void Load()
        {
            IList<string> aniNames = this.Data.Frames.Keys.ToList();
            this.Animations = new ReadOnlyCollection<string>(aniNames);

            if (this.Animations.Count > 0)
            {
                this.SelectedAnimationIndex = 0;
            }
            else
            {
                this.SelectedAnimationIndex = -1;
            }

            _timeline = CreateTimeline(this.Data.Frames[SelectedAnimationName].Select(f => f.Delay));
            _length = _timeline.Last();
            _timeOffset = 0;
            this.UpdateFrame();
        }

        protected virtual void UpdateFrame()
        {
            if (SelectedAnimationName == null || this.Data.Frames[SelectedAnimationName].Count <= 0)
            {
                this.CurrentFrame = null;
                return;
            }

            float progress;
            int index = GetProcessFromTimeline(_timeline, _timeOffset, out progress);

            var frame = this.Data.Frames[SelectedAnimationName][index];
            this.CurrentFrame = new Frame(frame.Texture, frame.AtlasRect)
            {
                Z = frame.Z,
                Origin = frame.Origin,
                A0 = (int)MathHelper.Lerp(frame.A0, frame.A1, progress),
            };
        }

        public override object Clone()
        {
            var clonedAnimator = new MultiFrameAnimator(this.Data);
            clonedAnimator.SelectedAnimationIndex = this.SelectedAnimationIndex;
            return clonedAnimator;
        }

        public static int[] CreateTimeline(IEnumerable<int> delays)
        {
            var timeLine = new List<int>() { 0 };
            foreach (var ms in delays)
            {
                timeLine.Add(timeLine[timeLine.Count - 1] + ms);
            }
            return timeLine.ToArray();
        }

        public static int GetProcessFromTimeline(int[] timeline, int timeOffset, out float progress)
        {
            int index = Array.BinarySearch(timeline, timeOffset);
            progress = 0;
            if (index < 0)
            {
                index = ~index - 1;
                progress = (float)(timeOffset - timeline[index]) / (timeline[index + 1] - timeline[index]);
            }
            return index;
        }
    }
}

```

`WzComparerR2.Common/Animation/SpineAnimationData.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Spine;
using WzComparerR2.Common;
using WzComparerR2.WzLib;
using WzComparerR2.Rendering;
using Microsoft.Xna.Framework.Graphics;

namespace WzComparerR2.Animation
{
    public class SpineAnimationData
    {
        private SpineAnimationData()
        {

        }

        public bool PremultipliedAlpha { get; set; }
        public SkeletonData SkeletonData { get; private set; }
        public string DefaultSkin { get; set; }

        public static SpineAnimationData CreateFromNode(Wz_Node atlasNode, bool? useJson, GraphicsDevice graphicsDevice, GlobalFindNodeFunction findNode)
        {
            var textureLoader = new WzSpineTextureLoader(atlasNode.ParentNode, graphicsDevice, findNode);
            return CreateFromNode(atlasNode, useJson, textureLoader);
        }

        public static SpineAnimationData CreateFromNode(Wz_Node atlasNode, bool? useJson, TextureLoader textureLoader)
        {
            var parentNode = atlasNode.ParentNode;

            var loadType = SkeletonLoadType.Auto;
            if (useJson != null)
            {
                loadType = useJson.Value ? SkeletonLoadType.Json : SkeletonLoadType.Binary;
            }

            var skeletonData = SpineLoader.LoadSkeleton(atlasNode, loadType, textureLoader);

            if (skeletonData == null)
            {
                return null;
            }

            bool pma = parentNode.FindNodeByPath("PMA").GetValueEx<int>(0) != 0;

            var anime = new SpineAnimationData();
            anime.SkeletonData = skeletonData;
            anime.PremultipliedAlpha = pma;
            return anime;
        }
    }
}

```

`WzComparerR2.Common/Animation/SpineAnimationDataV2.cs`:

```cs
using System;
using WzComparerR2.Common;
using WzComparerR2.WzLib;

using Microsoft.Xna.Framework.Graphics;
using Spine.V2;

namespace WzComparerR2.Animation
{
    public class SpineAnimationDataV2 : ISpineAnimationData
    {
        private SpineAnimationDataV2()
        {
        }

        public bool PremultipliedAlpha { get; set; }
        public SkeletonData SkeletonData { get; private set; }

        public static SpineAnimationDataV2 CreateFromNode(Wz_Node atlasOrSkelNode, GraphicsDevice graphicsDevice, GlobalFindNodeFunction findNode)
        {
            var textureLoader = new WzSpineTextureLoader(atlasOrSkelNode.ParentNode, graphicsDevice, findNode);
            return CreateFromNode(atlasOrSkelNode, textureLoader);
        }

        public static SpineAnimationDataV2 CreateFromNode(Wz_Node atlasOrSkelNode, TextureLoader textureLoader)
        {
            return Create(SpineLoader.Detect(atlasOrSkelNode), textureLoader);
        }

        public static SpineAnimationDataV2 Create(SpineDetectionResult detectionResult, TextureLoader textureLoader)
        {
            var skeletonData = SpineLoader.LoadSkeletonV2(detectionResult, textureLoader);

            if (skeletonData == null)
            {
                return null;
            }

            bool pma = detectionResult.SourceNode.ParentNode.FindNodeByPath("PMA").GetValueEx<int>(0) != 0;

            var anime = new SpineAnimationDataV2();
            anime.SkeletonData = skeletonData;
            anime.PremultipliedAlpha = pma;
            return anime;
        }

        #region ISpineAnimationData
        bool ISpineAnimationData.PremultipliedAlpha => this.PremultipliedAlpha;
        object ISpineAnimationData.SkeletonData => this.SkeletonData;
        SpineVersion ISpineAnimationData.SpineVersion => SpineVersion.V2;
        ISpineAnimator ISpineAnimationData.CreateAnimator() => new SpineAnimatorV2(this);
        #endregion
    }
}

```

`WzComparerR2.Common/Animation/SpineAnimationDataV4.cs`:

```cs
using System;
using WzComparerR2.Common;
using WzComparerR2.WzLib;

using Microsoft.Xna.Framework.Graphics;
using Spine;

namespace WzComparerR2.Animation
{
    public class SpineAnimationDataV4 : ISpineAnimationData
    {
        private SpineAnimationDataV4()
        {
        }

        public bool PremultipliedAlpha { get; set; }
        public SkeletonData SkeletonData { get; private set; }

        public static SpineAnimationDataV4 CreateFromNode(Wz_Node atlasOrSkelNode, GraphicsDevice graphicsDevice, GlobalFindNodeFunction findNode)
        {
            var textureLoader = new WzSpineTextureLoader(atlasOrSkelNode.ParentNode, graphicsDevice, findNode);
            return CreateFromNode(atlasOrSkelNode, textureLoader);
        }

        public static SpineAnimationDataV4 CreateFromNode(Wz_Node atlasOrSkelNode, TextureLoader textureLoader)
        {
            return Create(SpineLoader.Detect(atlasOrSkelNode), textureLoader);
        }

        public static SpineAnimationDataV4 Create(SpineDetectionResult detectionResult, TextureLoader textureLoader)
        {
            var skeletonData = SpineLoader.LoadSkeletonV4(detectionResult, textureLoader);

            if (skeletonData == null)
            {
                return null;
            }

            bool pma = detectionResult.SourceNode.ParentNode.FindNodeByPath("PMA").GetValueEx<int>(0) != 0;

            var anime = new SpineAnimationDataV4();
            anime.SkeletonData = skeletonData;
            anime.PremultipliedAlpha = pma;
            return anime;
        }

        #region ISpineAnimationData
        bool ISpineAnimationData.PremultipliedAlpha => this.PremultipliedAlpha;
        object ISpineAnimationData.SkeletonData => this.SkeletonData;
        SpineVersion ISpineAnimationData.SpineVersion => SpineVersion.V4;
        ISpineAnimator ISpineAnimationData.CreateAnimator() => new SpineAnimatorV4(this);
        #endregion
    }
}

```

`WzComparerR2.Common/Animation/SpineAnimator.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Text;
using Spine;
using WzComparerR2.WzLib;
using WzComparerR2.Controls;
using Microsoft.Xna.Framework;

namespace WzComparerR2.Animation
{
    public class SpineAnimator : AnimationItem
    {
        public SpineAnimator(SpineAnimationData data)
        {
            this.Data = data;
            this._selectedAniIndex = -1;
            this.Load();
        }

        public SpineAnimationData Data { get; private set; }

        public Skeleton Skeleton { get; private set; }

        public ReadOnlyCollection<string> Animations { get; private set; }

        public ReadOnlyCollection<string> Skins { get; private set; }

        public int SelectedAnimationIndex
        {
            get
            {
                return this._selectedAniIndex;
            }
            set
            {
                if (value > -1)
                {
                    string aniName = this.Animations[value];
                    var ani = this.Data.SkeletonData.FindAnimation(aniName);
                    this._animationState.SetAnimation(0, aniName, true);
                    this._selectedAniIndex = value;
                }
                else
                {
                    this._animationState.ClearTracks();
                    this._selectedAniIndex = -1;
                }
                
                this.Skeleton.SetToSetupPose();
                this._animationState.Apply(this.Skeleton);
                this.Skeleton.UpdateWorldTransform();
            }
        }

        public string SelectedAnimationName
        {
            get
            {
                if( this._selectedAniIndex > -1)
                {
                    return this.Animations[this._selectedAniIndex];
                }
                return null;
            }
            set
            {
                if (value != null)
                {
                    this.SelectedAnimationIndex = this.Animations.IndexOf(value);
                }
                else
                {
                    this.SelectedAnimationIndex = -1;
                }
            }
        }

        public string SelectedSkin
        {
            get { return this.Skeleton.Skin?.Name; }
            set { this.Skeleton.SetSkin(value); }
        }

        public int CurrentTime
        {
            get { return (int)((this._animationState?.GetCurrent(0)?.Time ?? 0) * 1000); }
        }

        internal Spine.Animation SelectedAnimation
        {
            get
            {
                if (this._selectedAniIndex > -1)
                {
                    return this.Data.SkeletonData.FindAnimation(SelectedAnimationName);
                }
                return null;
            }
        }

        public override void Reset()
        {
            this.SelectedAnimationIndex = this.SelectedAnimationIndex;
        }

        public override int Length
        {
            get
            {
                return (int)((this.SelectedAnimation?.Duration ?? 0f) * 1000);
            }
        }

        private int _selectedAniIndex;
        private AnimationState _animationState;

        public override void Update(TimeSpan elapsedTime)
        {
            this._animationState.Update((float)elapsedTime.TotalSeconds);
            this._animationState.Apply(Skeleton);
            this.Skeleton.UpdateWorldTransform();
        }

        public override Rectangle Measure()
        {
            ModelBound bound = ModelBound.Empty;
            UpdateBounds(ref bound, this.Skeleton);
            return bound.GetBound();
        }

        private void UpdateBounds(ref ModelBound bound, Skeleton skeleton)
        {
            float[] vertices = new float[8];
            var drawOrder = skeleton.DrawOrder;
            for (int i = 0, n = drawOrder.Count; i < n; i++)
            {
                Slot slot = drawOrder.Items[i];
                Attachment attachment = slot.Attachment;
                if (attachment is RegionAttachment)
                {
                    RegionAttachment region = (RegionAttachment)attachment;
                    region.ComputeWorldVertices(slot.Bone, vertices);
                    bound.Update(vertices, 8);
                }
                else if (attachment is MeshAttachment)
                {
                    MeshAttachment mesh = (MeshAttachment)attachment;
                    int vertexCount = mesh.Vertices.Length;
                    if (vertices.Length < vertexCount) vertices = new float[vertexCount];
                    mesh.ComputeWorldVertices(slot, vertices);
                    bound.Update(vertices, vertexCount);
                }
                else if (attachment is SkinnedMeshAttachment)
                {
                    SkinnedMeshAttachment mesh = (SkinnedMeshAttachment)attachment;
                    int vertexCount = mesh.UVs.Length;
                    if (vertices.Length < vertexCount) vertices = new float[vertexCount];
                    mesh.ComputeWorldVertices(slot, vertices);
                    bound.Update(vertices, vertexCount);
                }
            }
        }

        public KeyFrame[] GetKeyFrames()
        {
            //放弃了 算法太麻烦还不如直接对比。。
            return null;
            var frames = new LinkedList<KeyFrame>();
            var track = this._animationState.GetCurrent(0);
            if (track != null)
            {
                foreach (var timeLine in track.Animation.Timelines)
                {
                    var tlFrames = GetTimeLineKeyFrames(timeLine);
                    if (tlFrames.Count > 0)
                    {
                        if (frames.Count <= 0) //直接加入
                        {
                            foreach(var frame in tlFrames)
                            {
                                frames.AddLast(frame);
                            }
                        }
                        else //合并关键帧
                        {

                        }
                    }
                }
            }
            return frames.ToArray();
        }

        private LinkedList<KeyFrame> GetTimeLineKeyFrames(Timeline timeLine)
        {
            float[] frameTimes;
            int interval = 0;
            bool animated = false;
            try
            {
                //懒得反射了。。。
                dynamic m = timeLine;
                frameTimes = (float[])((dynamic)m).Frames;
            }
            catch
            {
                frameTimes = null;
            }

            if (timeLine is AttachmentTimeline)
            {
                interval = 1;
                animated = false;
            }
            else if (timeLine is CurveTimeline)
            {
                animated = true;

                if (timeLine is ColorTimeline)
                {
                    interval = 5;
                }
                else if (timeLine is FFDTimeline)
                {
                    interval = 1;
                }
                else if (timeLine is IkConstraintTimeline)
                {
                    interval = 3;
                }
                else if (timeLine is RotateTimeline)
                {
                    interval = 2;
                }
                else if (timeLine is TranslateTimeline)
                {
                    interval = 3;
                }
            }
            else if (timeLine is DrawOrderTimeline)
            {
                interval = 1;
                animated = false;
            }
            else if (timeLine is EventTimeline)
            {
                //对模型好像没啥变化 忽略
            }
            else if (timeLine is FlipXTimeline)
            {
                interval = 2;
                animated = false;
            }

            var frameList = new LinkedList<KeyFrame>();

            if (frameTimes != null && frameTimes.Length > 0 && interval > 0)
            {
                if (frameTimes[0] > 0)
                {
                    frameList.AddFirst(new KeyFrame() { Length = (int)(frameTimes[0] * 1000), Animated = false });
                }

                for (int i = 0; i < frameTimes.Length; i += interval)
                {
                    float length = i < frameTimes.Length - interval ? (frameTimes[i + interval] - frameTimes[i]) : 0;
                    frameList.AddLast(new KeyFrame() { Length = (int)(length * 1000), Animated = animated });
                }
            }

            return frameList;
        }

        public override object Clone()
        {
            var clonedAnimator = new SpineAnimator(this.Data);
            clonedAnimator.SelectedAnimationIndex = this.SelectedAnimationIndex;
            if (this.SelectedSkin != null)
            {
                clonedAnimator.SelectedSkin = this.SelectedSkin;
            }
            return clonedAnimator;
        }

        private void Load()
        {
            this.Skeleton = new Skeleton(this.Data.SkeletonData);
            IList<string> aniNames = this.Data.SkeletonData.Animations.Select(ani => ani.Name).ToList();
            this.Animations = new ReadOnlyCollection<string>(aniNames);
            this._animationState = new AnimationState(new AnimationStateData(this.Data.SkeletonData));
            this.Skins = new ReadOnlyCollection<string>(this.Data.SkeletonData.Skins.Select(skin => skin.Name).ToList());

            if (!string.IsNullOrEmpty(this.Data.DefaultSkin))
            {
                var skin = this.Skeleton.Data.FindSkin(this.Data.DefaultSkin);
                if (skin != null)
                {
                    this.Skeleton.SetSkin(skin);
                }
            }

            if (this.Animations.Count > 0)
            {
                this.SelectedAnimationIndex = 0;
            }
            else
            {
                this.SelectedAnimationIndex = -1;
            }
        }
    }
}

```

`WzComparerR2.Common/Animation/SpineAnimatorV2.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using WzComparerR2.Controls;

using Microsoft.Xna.Framework;
using Spine.V2;

using Rectangle=Microsoft.Xna.Framework.Rectangle;

namespace WzComparerR2.Animation
{
    public class SpineAnimatorV2 : AnimationItem, ISpineAnimator
    {
        public SpineAnimatorV2(SpineAnimationDataV2 data)
        {
            this.Data = data;
            this._selectedAniIndex = -1;
            this.Load();
        }

        public SpineAnimationDataV2 Data { get; private set; }

        public Skeleton Skeleton { get; private set; }

        public ReadOnlyCollection<string> Animations { get; private set; }

        public ReadOnlyCollection<string> Skins { get; private set; }

        public int SelectedAnimationIndex
        {
            get
            {
                return this._selectedAniIndex;
            }
            set
            {
                if (value > -1)
                {
                    string aniName = this.Animations[value];
                    var ani = this.Data.SkeletonData.FindAnimation(aniName);
                    this._animationState.SetAnimation(0, ani, true);
                    this._selectedAniIndex = value;
                }
                else
                {
                    this._animationState.ClearTracks();
                    this._selectedAniIndex = -1;
                }
                
                this.Skeleton.SetToSetupPose();
                this._animationState.Apply(this.Skeleton);
                this.Skeleton.UpdateWorldTransform();
            }
        }

        public string SelectedAnimationName
        {
            get
            {
                if( this._selectedAniIndex > -1)
                {
                    return this.Animations[this._selectedAniIndex];
                }
                return null;
            }
            set
            {
                if (value != null)
                {
                    this.SelectedAnimationIndex = this.Animations.IndexOf(value);
                }
                else
                {
                    this.SelectedAnimationIndex = -1;
                }
            }
        }

        public string SelectedSkin
        {
            get { return this.Skeleton.Skin?.Name; }
            set { this.Skeleton.SetSkin(value); }
        }

        public int CurrentTime
        {
            get { return (int)((this._animationState?.GetCurrent(0)?.Time ?? 0) * 1000); }
        }

        internal Spine.V2.Animation SelectedAnimation
        {
            get
            {
                if (this._selectedAniIndex > -1)
                {
                    return this.Data.SkeletonData.FindAnimation(SelectedAnimationName);
                }
                return null;
            }
        }

        public override void Reset()
        {
            this.SelectedAnimationIndex = this.SelectedAnimationIndex;
        }

        public override int Length
        {
            get
            {
                return (int)((this.SelectedAnimation?.Duration ?? 0f) * 1000);
            }
        }

        private int _selectedAniIndex;
        private AnimationState _animationState;

        public override void Update(TimeSpan elapsedTime)
        {
            this._animationState.Update((float)elapsedTime.TotalSeconds);
            this._animationState.Apply(Skeleton);
            this.Skeleton.UpdateWorldTransform();
        }

        public override Rectangle Measure()
        {
            ModelBound bound = ModelBound.Empty;
            UpdateBounds(ref bound, this.Skeleton);
            return bound.GetBound();
        }

        private void UpdateBounds(ref ModelBound bound, Skeleton skeleton)
        {
            float[] vertices = new float[8];
            var drawOrder = skeleton.DrawOrder;
            for (int i = 0, n = drawOrder.Count; i < n; i++)
            {
                Slot slot = drawOrder.Items[i];
                Attachment attachment = slot.Attachment;
                if (attachment is RegionAttachment)
                {
                    RegionAttachment region = (RegionAttachment)attachment;
                    region.ComputeWorldVertices(slot.Bone, vertices);
                    bound.Update(vertices, 8);
                }
                else if (attachment is MeshAttachment)
                {
                    MeshAttachment mesh = (MeshAttachment)attachment;
                    int vertexCount = mesh.Vertices.Length;
                    if (vertices.Length < vertexCount) vertices = new float[vertexCount];
                    mesh.ComputeWorldVertices(slot, vertices);
                    bound.Update(vertices, vertexCount);
                }
                else if (attachment is SkinnedMeshAttachment)
                {
                    SkinnedMeshAttachment mesh = (SkinnedMeshAttachment)attachment;
                    int vertexCount = mesh.UVs.Length;
                    if (vertices.Length < vertexCount) vertices = new float[vertexCount];
                    mesh.ComputeWorldVertices(slot, vertices);
                    bound.Update(vertices, vertexCount);
                }
            }
        }

        public override object Clone()
        {
            var clonedAnimator = new SpineAnimatorV2(this.Data);
            clonedAnimator.SelectedAnimationIndex = this.SelectedAnimationIndex;
            if (this.SelectedSkin != null)
            {
                clonedAnimator.SelectedSkin = this.SelectedSkin;
            }
            return clonedAnimator;
        }

        private void Load()
        {
            var skeletonData = this.Data.SkeletonData;
            this.Skeleton = new Skeleton(skeletonData);
            this.Animations = new ReadOnlyCollection<string>(skeletonData.Animations.Select(ani => ani.Name).ToList());
            this.Skins = new ReadOnlyCollection<string>(skeletonData.Skins.Select(skin => skin.Name).ToList());
            this._animationState = new AnimationState(new AnimationStateData(skeletonData));

            if (this.Animations.Count > 0)
            {
                this.SelectedAnimationIndex = 0;
            }
            else
            {
                this.SelectedAnimationIndex = -1;
            }
        }

        #region ISpineAnimator
        ISpineAnimationData ISpineAnimator.Data => this.Data;
        object ISpineAnimator.Skeleton => this.Skeleton;
        ReadOnlyCollection<string> ISpineAnimator.Animations => this.Animations;
        ReadOnlyCollection<string> ISpineAnimator.Skins => this.Skins;
        int ISpineAnimator.SelectedAnimationIndex { get => this.SelectedAnimationIndex; set => this.SelectedAnimationIndex = value; }
        string ISpineAnimator.SelectedAnimationName { get => this.SelectedAnimationName; set => this.SelectedAnimationName = value; }
        string ISpineAnimator.SelectedSkin { get => this.SelectedSkin; set => this.SelectedSkin = value; }
        int ISpineAnimator.CurrentTime { get => this.CurrentTime; }
        void ISpineAnimator.Render(Spine.SkeletonRenderer renderer) => renderer.Draw(this.Skeleton);
        #endregion
    }
}

```

`WzComparerR2.Common/Animation/SpineAnimatorV4.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using WzComparerR2.Controls;

using Microsoft.Xna.Framework;
using Spine;


namespace WzComparerR2.Animation
{
    public class SpineAnimatorV4 : AnimationItem, ISpineAnimator
    {
        public SpineAnimatorV4(SpineAnimationDataV4 data)
        {
            this.Data = data;
            this._selectedAniIndex = -1;
            this.Load();
        }

        public SpineAnimationDataV4 Data { get; private set; }

        public Skeleton Skeleton { get; private set; }

        public ReadOnlyCollection<string> Animations { get; private set; }

        public ReadOnlyCollection<string> Skins { get; private set; }

        public int SelectedAnimationIndex
        {
            get
            {
                return this._selectedAniIndex;
            }
            set
            {
                if (value > -1)
                {
                    string aniName = this.Animations[value];
                    var ani = this.Data.SkeletonData.FindAnimation(aniName);
                    this._animationState.SetAnimation(0, ani, true);
                    this._selectedAniIndex = value;
                }
                else
                {
                    this._animationState.ClearTracks();
                    this._selectedAniIndex = -1;
                }

                this.Skeleton.SetToSetupPose();
                this._animationState.Apply(this.Skeleton);
                this.Skeleton.UpdateWorldTransform();
            }
        }

        public string SelectedAnimationName
        {
            get
            {
                if (this._selectedAniIndex > -1)
                {
                    return this.Animations[this._selectedAniIndex];
                }
                return null;
            }
            set
            {
                if (value != null)
                {
                    this.SelectedAnimationIndex = this.Animations.IndexOf(value);
                }
                else
                {
                    this.SelectedAnimationIndex = -1;
                }
            }
        }

        public string SelectedSkin
        {
            get { return this.Skeleton.Skin?.Name; }
            set { this.Skeleton.SetSkin(value); }
        }

        public int CurrentTime
        {
            get { return (int)((this._animationState?.GetCurrent(0)?.TrackTime ?? 0) * 1000); }
        }

        internal Spine.Animation SelectedAnimation
        {
            get
            {
                if (this._selectedAniIndex > -1)
                {
                    return this.Data.SkeletonData.FindAnimation(SelectedAnimationName);
                }
                return null;
            }
        }

        public override void Reset()
        {
            this.SelectedAnimationIndex = this.SelectedAnimationIndex;
        }

        public override int Length
        {
            get
            {
                return (int)((this.SelectedAnimation?.Duration ?? 0f) * 1000);
            }
        }

        private int _selectedAniIndex;
        private AnimationState _animationState;

        public override void Update(TimeSpan elapsedTime)
        {
            this._animationState.Update((float)elapsedTime.TotalSeconds);
            this._animationState.Apply(Skeleton);
            this.Skeleton.UpdateWorldTransform();
        }

        public override Microsoft.Xna.Framework.Rectangle Measure()
        {
            ModelBound bound = ModelBound.Empty;
            UpdateBounds(ref bound, this.Skeleton);
            return bound.GetBound();
        }

        private void UpdateBounds(ref ModelBound bound, Skeleton skeleton)
        {
            float[] vertices = new float[8];
            var drawOrder = skeleton.DrawOrder;
            for (int i = 0, n = drawOrder.Count; i < n; i++)
            {
                Slot slot = drawOrder.Items[i];
                Attachment attachment = slot.Attachment;
                if (attachment is RegionAttachment)
                {
                    RegionAttachment region = (RegionAttachment)attachment;
                    region.ComputeWorldVertices(slot, vertices, 0);
                    bound.Update(vertices, 8);
                }
                else if (attachment is MeshAttachment)
                {
                    MeshAttachment mesh = (MeshAttachment)attachment;
                    int vertexCount = mesh.WorldVerticesLength;
                    if (vertices.Length < vertexCount) vertices = new float[vertexCount];
                    mesh.ComputeWorldVertices(slot, vertices);
                    bound.Update(vertices, vertexCount);
                }
                else if (attachment is ClippingAttachment)
                {
                    // ignore, don't know how it works
                }
            }
        }

        public override object Clone()
        {
            var clonedAnimator = new SpineAnimatorV4(this.Data);
            clonedAnimator.SelectedAnimationIndex = this.SelectedAnimationIndex;
            if (this.SelectedSkin != null)
            {
                clonedAnimator.SelectedSkin = this.SelectedSkin;
            }
            return clonedAnimator;
        }

        private void Load()
        {
            var skeletonData = this.Data.SkeletonData;
            this.Skeleton = new Skeleton(skeletonData);
            this.Animations = new ReadOnlyCollection<string>(skeletonData.Animations.Select(ani => ani.Name).ToList());
            this.Skins = new ReadOnlyCollection<string>(skeletonData.Skins.Select(skin => skin.Name).ToList());
            this._animationState = new AnimationState(new AnimationStateData(skeletonData));

            if (this.Animations.Count > 0)
            {
                this.SelectedAnimationIndex = 0;
            }
            else
            {
                this.SelectedAnimationIndex = -1;
            }
        }

        #region ISpineAnimator
        ISpineAnimationData ISpineAnimator.Data => this.Data;
        object ISpineAnimator.Skeleton => this.Skeleton;
        ReadOnlyCollection<string> ISpineAnimator.Animations => this.Animations;
        ReadOnlyCollection<string> ISpineAnimator.Skins => this.Skins;
        int ISpineAnimator.SelectedAnimationIndex { get => this.SelectedAnimationIndex; set => this.SelectedAnimationIndex = value; }
        string ISpineAnimator.SelectedAnimationName { get => this.SelectedAnimationName; set => this.SelectedAnimationName = value; }
        string ISpineAnimator.SelectedSkin { get => this.SelectedSkin; set => this.SelectedSkin = value; }
        int ISpineAnimator.CurrentTime { get => this.CurrentTime; }
        void ISpineAnimator.Render(Spine.SkeletonRenderer renderer) => renderer.Draw(this.Skeleton);
        #endregion
    }
}

```

`WzComparerR2.Common/Animation/WzSpineTextureLoader.cs`:

```cs
using System;
using WzComparerR2.Common;
using WzComparerR2.Rendering;
using WzComparerR2.WzLib;

using Microsoft.Xna.Framework.Graphics;

namespace WzComparerR2.Animation
{
    public class WzSpineTextureLoader : Spine.TextureLoader, Spine.V2.TextureLoader
    {
        public WzSpineTextureLoader(Wz_Node topNode, GraphicsDevice graphicsDevice)
            : this(topNode, graphicsDevice, null)
        {
        }

        public WzSpineTextureLoader(Wz_Node topNode, GraphicsDevice graphicsDevice, GlobalFindNodeFunction findNodeFunc)
        {
            this.TopNode = topNode;
            this.GraphicsDevice = graphicsDevice;
            this.FindNodeFunction = findNodeFunc;
        }

        public Wz_Node TopNode { get; private set; }

        public GraphicsDevice GraphicsDevice { get; private set; }

        public GlobalFindNodeFunction FindNodeFunction { get; set; }

        public void Load(Spine.AtlasPage page, string path)
        {
            if (this.TryLoadTexture(path, out var texture))
            {
                page.rendererObject = texture;
                page.width = texture.Width;
                page.height = texture.Height;
            }
        }

        public void Load(Spine.V2.AtlasPage page, string path)
        {
            if (this.TryLoadTexture(path, out var texture))
            {
                page.rendererObject = texture;
                page.width = texture.Width;
                page.height = texture.Height;
            }
        }

        public void Unload(object texture)
        {
            (texture as Texture2D)?.Dispose();
        }

        private bool TryLoadTexture(string path, out Texture2D texture)
        {
            texture = null;
            var frameNode = this.TopNode.FindNodeByPath(path);
            frameNode = frameNode.ResolveUol();

            if (frameNode.Value is Wz_Png)
            {
                var linkNode = frameNode.GetLinkedSourceNode(FindNodeFunction);
                Wz_Png png = (linkNode ?? frameNode).GetValue<Wz_Png>();
                texture = png.ToTexture(this.GraphicsDevice);
                return true;
            }

            return false;
        }
    }
}

```

`WzComparerR2.Common/BitmapOrigin.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;
using WzComparerR2.WzLib;
using WzComparerR2.Common;

namespace WzComparerR2
{
    public struct BitmapOrigin
    {
        public BitmapOrigin(Bitmap bitmap)
            : this(bitmap, new Point(0, 0))
        {
        }

        public BitmapOrigin(Bitmap bitmap, int x, int y)
            : this(bitmap, new Point(x, y))
        {
        }

        public BitmapOrigin(Bitmap bitmap, Point origin)
        {
            this.bitmap = bitmap;
            this.origin = origin;
        }

        private Bitmap bitmap;
        private Point origin;

        /// <summary>
        /// 获取图片。
        /// </summary>
        public Bitmap Bitmap
        {
            get { return bitmap; }
            set { bitmap = value; }
        }

        /// <summary>
        /// 获取或设置图片的原点坐标。
        /// </summary>
        public Point Origin
        {
            get { return origin; }
            set { origin = value; }
        }

        /// <summary>
        /// 获取图片原点的相反数，一般为绘图坐标区域的实际绘图原点。
        /// </summary>
        public Point OpOrigin
        {
            get { return new Point(-origin.X, -origin.Y); }
        }

        /// <summary>
        /// 获取图片的实际绘图区域，它由图片大小和原点的相反数组成。
        /// </summary>
        public Rectangle Rectangle
        {
            get
            {
                if (this.bitmap == null)
                    return new Rectangle(this.OpOrigin, new Size());
                else
                    return new Rectangle(this.OpOrigin, this.bitmap.Size);
            }
        }

        public static BitmapOrigin CreateFromNode(Wz_Node node, GlobalFindNodeFunction findNode)
        {
            BitmapOrigin bp = new BitmapOrigin();
            Wz_Uol uol;
            while ((uol = node.GetValue<Wz_Uol>(null)) != null)
            {
                node = uol.HandleUol(node);
            }

            //获取linkNode
            var linkNode = node.GetLinkedSourceNode(findNode);
            Wz_Png png = linkNode?.GetValue<Wz_Png>() ?? (Wz_Png)node.Value;

            bp.Bitmap = png?.ExtractPng();
            Wz_Node originNode = node.FindNodeByPath("origin");
            Wz_Vector vec = (originNode == null) ? null : originNode.GetValue<Wz_Vector>();
            bp.Origin = (vec == null) ? new Point() : new Point(vec.X, vec.Y);

            return bp;
        }
    }
}

```

`WzComparerR2.Common/BuildInApngEncoder.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Drawing;
using System.Runtime.InteropServices;

namespace WzComparerR2.Common
{
    public class BuildInApngEncoder : GifEncoder
    {
        public BuildInApngEncoder(string fileName, int width, int height)
            : base(fileName, width, height)
        {
            var err = apng_init(fileName, width, height, out this.handle);
            if (err != ApngError.Success)
            {
                throw new Exception($"Apng error: {err}.");
            }
        }

        private IntPtr handle;

        public bool OptimizeEnabled { get; set; }

        public override void AppendFrame(IntPtr pBuffer, int delay)
        {
            var err = apng_append_frame(this.handle, pBuffer, 0, 0, this.Width, this.Height, this.Width * 4, delay, this.OptimizeEnabled);
            if (err != ApngError.Success)
            {
                throw new Exception($"Apng error: {err}.");
            }
        }

        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                apng_write_end(this.handle);
                apng_destroy(ref this.handle);
            }
            base.Dispose(disposing);
        }

        enum ApngError : int
        {
            Success = 0,
            ContextCreateFailed = 1,
            FileError = 2,
            ArgumentError = 3,
            MemoryError = 4,
        };

        [DllImport("libapng.dll")]
        static extern ApngError apng_init([MarshalAs(UnmanagedType.LPWStr)]string fileName, int width, int height, out IntPtr ppEnc);
        [DllImport("libapng.dll")]
        static extern ApngError apng_append_frame(IntPtr pEnc, IntPtr pData, int x, int y, int width, int height, int stride, int delay_ms, bool optimize);
        [DllImport("libapng.dll")]
        static extern void apng_write_end(IntPtr pEnc);
        [DllImport("libapng.dll")]
        static extern void apng_destroy(ref IntPtr ppEnc);
    }
}

```

`WzComparerR2.Common/BuildInGifEncoder.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using System.Drawing;
using System.Drawing.Imaging;
using ImageManipulation;

namespace WzComparerR2.Common
{
    public class BuildInGifEncoder : GifEncoder
    {
        public BuildInGifEncoder(string fileName, int width, int height)
            : base(fileName, width, height)
        {
            bWriter = new BinaryWriter(File.Create(fileName));
            mStream = new MemoryStream();
            quantizer = new OctreeQuantizer(255, 8);

            WriteHeader();
        }

        private BinaryWriter bWriter;
        private MemoryStream mStream;
        private Quantizer quantizer;

        private static readonly byte[] gifHeader = new byte[] { 0x47, 0x49, 0x46, 0x38, 0x39, 0x61 };//GIF89a
        private static readonly byte[] logicalScreen = new byte[] { 0x70, 0x00, 0x00 };//无全局色彩表 无视背景色 无视像素纵横比
        private static readonly byte[] appExtension = new byte[] { 0x21,0xff,0x0b, //块标志
                0x4e,0x45,0x54,0x53,0x43,0x41,0x50,0x45,0x32,0x2e,0x30, //NETSCAPE2.0
                0x03,0x01,0x00,0x00,0x00};//循环信息 其他信息
        private static readonly byte[] gifEnd = new byte[] { 0x3b };//结束信息

        public override void AppendFrame(Bitmap image, int delay)
        {
            mStream.SetLength(0);
            mStream.Position = 0;
            using (var tempGif = quantizer.Quantize(image))
            {
                tempGif.Save(mStream, ImageFormat.Gif);
            }

            byte[] tempArray = mStream.GetBuffer();
            // 781开始为Graphic Control Extension块 标志为21 F9 04 
            tempArray[784] = (byte)0x09; //图像刷新时屏幕返回初始帧 貌似不打会bug 意味不明 测试用
            delay = delay / 10;
            tempArray[785] = (byte)(delay & 0xff);
            tempArray[786] = (byte)(delay >> 8 & 0xff); //写入2字节的帧delay 
                                                        // 787为透明色索引  788为块结尾0x00
            tempArray[787] = (byte)0xff;
            // 789开始为Image Descriptor块 标志位2C
            // 790~793为帧偏移大小 默认为0
            // 794~797为帧图像大小 默认他
            tempArray[798] = (byte)(tempArray[798] | 0X87); //本地色彩表标志

            //写入到gif文件
            bWriter.Write(tempArray, 781, 18);
            bWriter.Write(tempArray, 13, 768);
            bWriter.Write(tempArray, 799, (int)mStream.Length - 800);
        }

        public override void AppendFrame(IntPtr pBuffer, int delay)
        {
            using(var bmp = new Bitmap(Width, Height, Width *4, PixelFormat.Format32bppArgb, pBuffer))
            {
                this.AppendFrame(bmp, delay);
            }
        }

        private void WriteHeader()
        {
            //写入gif头信息
            bWriter.Write(gifHeader);
            bWriter.Write((ushort)Width);
            bWriter.Write((ushort)Height);
            bWriter.Write(logicalScreen);
            //写入循环标记
            bWriter.Write(appExtension);
        }

        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                bWriter.Write(gifEnd);
                bWriter.Close();
            }

            if (mStream != null)
            {
                mStream.Dispose();
                mStream = null;
            }
        }
    }
}

```

`WzComparerR2.Common/Calculator.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Text.RegularExpressions;

namespace WzComparerR2
{
    public static class Calculator
    {
        public static decimal Parse(string mathExpression, params decimal[] args)
        {
            var tokens = Lexer(mathExpression);
            var inst = Suffix(tokens);

            var paramList = new Dictionary<string, object>();

            if (args != null)
            {
                for (int i = 0; i < args.Length; i++)
                {
                    switch (i)
                    {
                        case 0: paramList["x"] = args[0]; break;
                        case 1: paramList["y"] = args[1]; break;
                        case 2: paramList["z"] = args[2]; break;
                        case 3: paramList["w"] = args[3]; break;
                    }
                }
            }

            return Execute(inst, new EvalContext(paramList));
        }

        private static List<Token> Lexer(string expr)
        {
            var tokens = new List<Token>();
            if (string.IsNullOrEmpty(expr))
                return tokens;

            int begin;
            for (int i = 0; i < expr.Length; i++)
            {
                switch (expr[i])
                {
                    case '+':
                    case '-':
                    case '*':
                    case '/': tokens.Add(new Token(TokenType.Operator, expr[i].ToString())); break;
                    case '.': tokens.Add(new Token(TokenType.Dot, null)); break;
                    case '(': tokens.Add(new Token(TokenType.BracketStart, null)); break;
                    case ')': tokens.Add(new Token(TokenType.BracketEnd, null)); break;
                    case ',': tokens.Add(new Token(TokenType.Comma, null)); break;
                    case ' ': break; //whitespace当不存在
                    case '%': break; //ignore
                    default:
                        if (char.IsDigit(expr[i]))
                        { //尽力读取number
                            begin = i;
                            bool dot = false;
                            while (++i < expr.Length)
                            {
                                if (char.IsDigit(expr[i]))
                                {
                                    //继续读
                                }
                                else if (expr[i] == '.' && !dot)
                                {
                                    dot = true;
                                }
                                else
                                {
                                    break;
                                }
                            }
                            tokens.Add(new Token(TokenType.Number, expr.Substring(begin, i - begin)));
                            i--;
                        }
                        else if (char.IsLetter(expr[i]))
                        { //尽力读取id
                            begin = i;
                            while (++i < expr.Length)
                            {
                                if (!char.IsLetterOrDigit(expr[i]))
                                {
                                    break;
                                }
                            }
                            tokens.Add(new Token(TokenType.ID, expr.Substring(begin, i - begin)));
                            i--;
                        }
                        else if (char.IsWhiteSpace(expr[i]))
                        {
                            //空白字符跳过
                        }
                        else
                        { //无效字符
                            throw new Exception("Unknown char '" + expr[i] + "'.");
                        }
                        break;
                }
            }
            return tokens;
        }

        //suffix 逆波兰表达式
        private static List<Token> Suffix(List<Token> tokens)
        {
            var value = new List<Token>();
            var stack = new Stack<Token>();
            for (int i = 0; i < tokens.Count; i++)
            {
                var token = tokens[i];
                switch (token.Type)
                {
                    case TokenType.BracketStart: //括号 推进stack
                        stack.Push(token);
                        if (token.Tag == Tag.Call)
                            value.Add(new Token(TokenType.CallStart, ""));
                        break;

                    case TokenType.BracketEnd: //括号结束 弹出到上一个括号
                        {
                            Token t;
                            int count = 0;
                            while ((t = stack.Pop()) != null)
                            {
                                if (t.Type != TokenType.BracketStart)
                                {
                                    value.Add(t);
                                    count++;
                                }
                                else
                                {
                                    if (t.Tag == Tag.Call)
                                        value.Add(new Token(TokenType.CallEnd, ""));
                                    break;
                                }
                            }
                        }
                        break;

                    case TokenType.Operator: //运算符
                        if (i == 0 || tokens[i - 1].Type == TokenType.BracketStart || tokens[i - 1].Type == TokenType.Operator)
                        { //独立判定一元运算符
                            token.Tag = Tag.Unary;
                        }
                        goto case TokenType.Dot;
                    case TokenType.Dot: //取成员
                        while (stack.Count > 0)
                        { //比较优先级
                            Token t = stack.Peek();
                            if (Priority(token) > Priority(t)
                                || (token.Tag == Tag.Unary && t.Tag == Tag.Unary))
                            { //优先级比上个高
                                break;
                            }
                            else
                            {
                                value.Add(stack.Pop());
                            }
                        }
                        stack.Push(token);
                        break;

                    case TokenType.ID: //预判如果后面是括号 当成函数处理
                        value.Add(token);
                        if (i + 1 < tokens.Count && tokens[i + 1].Type == TokenType.BracketStart)
                        {
                            while (stack.Count > 0)
                            {
                                Token t = stack.Peek();
                                if (t.Type == TokenType.Dot)
                                {
                                    value.Add(stack.Pop());
                                }
                                else
                                {
                                    break;
                                }
                            }
                            //标记下一个括号为call
                            tokens[i + 1].Tag = Tag.Call;
                        }
                        break;

                    case TokenType.Number:
                        value.Add(token);
                        break;

                    case TokenType.Comma: //逗号 忽略好像也没事..感觉像卖萌的..
                        break;
                }
            }

            value.AddRange(stack);
            return value;
        }

        private static decimal Execute(List<Token> inst, EvalContext param)
        {
            var stack = new Stack<object>();
            object obj;
            decimal d1, d2;
            foreach (var token in inst)
            {
                switch (token.Type)
                {
                    case TokenType.Number: stack.Push(Convert.ToDecimal(token.Value)); break;
                    case TokenType.ID:
                        if (param.TryGetValue(token.Value, out obj))
                        {
                            stack.Push(obj);
                        }
                        else
                        {
                            throw new Exception("ID '" + token.Value + "' not found.");
                        }
                        break;
                    case TokenType.Operator:
                        if (token.Tag == Tag.Unary)
                        {
                            d1 = Convert.ToDecimal(stack.Pop());
                            switch (token.Value)
                            {
                                case "+": stack.Push(d1); break;
                                case "-": stack.Push(-d1); break;
                            }
                        }
                        else
                        {
                            d2 = Convert.ToDecimal(stack.Pop());
                            d1 = Convert.ToDecimal(stack.Pop());
                            switch (token.Value)
                            {
                                case "+": stack.Push(d1 + d2); break;
                                case "-": stack.Push(d1 - d2); break;
                                case "*": stack.Push(d1 * d2); break;
                                case "/": stack.Push(d1 / d2); break;
                            }
                        }
                        break;
                    case TokenType.Dot:
                        throw new NotSupportedException();
                    case TokenType.CallStart: stack.Push(TokenType.CallStart); break;
                    case TokenType.CallEnd:
                        var p = new Stack<object>();
                        while (!TokenType.CallStart.Equals(obj = stack.Pop()))
                        {
                            p.Push(obj);
                        }
                        obj = (stack.Pop() as Delegate).DynamicInvoke(p.ToArray());
                        stack.Push(obj);
                        break;
                }
            }
            return stack.Count <= 0 ? 0 : Convert.ToDecimal(stack.Pop());
        }


        private class Token
        {
            public Token(TokenType type, String value)
            {
                this.Type = type;
                this.Value = value;
            }
            public TokenType Type;
            public string Value;
            public Tag Tag;
        }

        //优先级
        private static int Priority(Token token)
        {
            if (token.Tag == Tag.Unary) return 4;
            switch (token.Value)
            {
                case "+":
                case "-": return 1;
                case "*":
                case "/": return 2;
                case ".": return 3;
                default: return 0;
            }
        }

        private enum TokenType
        {
            ID, //x,funcName
            Number, //123.45
            BracketStart, //(
            BracketEnd, //)
            Dot, //.成员运算符
            Operator, //+-*/
            Comma, //,逗号 函数参数分隔符

            CallStart = 100, //标记用 参数开始
            CallEnd, //标记用
        }

        private enum Tag
        {
            None = 0,
            Call,
            Unary,
        }

        private class EvalContext
        {
            public EvalContext()
                : this(null)
            {
            }

            public EvalContext(Dictionary<string, object> parameters)
            {
                this._dict = new Dictionary<string, object>();

                if (parameters != null && parameters.Count > 0)
                {
                    foreach (var kv in parameters)
                    {
                        _dict.Add(kv.Key, kv.Value);
                    }
                }
            }

            public Dictionary<string, object> _dict;

            public bool TryGetValue(string key, out object value)
            {
                return _dict.TryGetValue(key, out value)
                    || TryGetFunction(key, out value);
            }

            private bool TryGetFunction(string key, out object value)
            {
                Match m;

                if (key == "u")
                {
                    value = (Func<decimal, decimal>)Math.Ceiling;
                    return true;
                }
                else if (key == "d")
                {
                    value = (Func<decimal, decimal>)Math.Floor;
                    return true;
                }
                else if ((m = Regex.Match(key, @"log(\d+)")).Success)
                {
                    var logBase = int.Parse(m.Result("$1"));
                    value = (Func<decimal, decimal>)(x => x <= 0 ? 0 : (decimal)Math.Floor(Math.Log(decimal.ToDouble(x), logBase)));
                    return true;
                }

                value = null;
                return false;
            }
        }
    }
}

```

`WzComparerR2.Common/CharaSim/Addition.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using WzComparerR2.WzLib;

namespace WzComparerR2.CharaSim
{
    public class Addition
    {
        public Addition()
        {
            Props = new Dictionary<string, string>();
            ConValue = new List<int>();
        }

        public AdditionType Type { get; set; }
        public GearPropType ConType { get; set; }
        public List<int> ConValue { get; private set; }
        public Dictionary<string, string> Props { get; private set; }

        public string GetPropString()
        {
            StringBuilder sb;
            switch (this.Type)
            {
                case AdditionType.boss:
                    sb = new StringBuilder();
                    //sb.Append("When attacking Bosses, "); NECESSARY FOR GMS VERSION
                    {
                        string v1;
                        if (this.Props.TryGetValue("prob", out v1))
                            sb.Append("Has a " + v1 + "% chance ");
                        sb.Append("to deal " + Props["damage"] + "% extra damage on boss monsters.");
                    }
                    return sb.ToString();
                case AdditionType.critical:
                    sb = new StringBuilder();
                    {
                        string val;
                        if (this.Props.TryGetValue("prob", out val))
                        {
                            sb.AppendFormat("Critical Rate: +{0}%\r\n", val);
                        }
                        if (this.Props.TryGetValue("damage", out val))
                        {
                            sb.AppendFormat("Critical Damage: +{0}%\r\n", val);
                        }
                        if (sb.Length > 2)
                        {
                            sb.Remove(sb.Length - 2, 2);
                        }
                    }
                    return sb.ToString();
                case AdditionType.elemboost:
                    {
                        string v1, elem;
                        if (this.Props.TryGetValue("elemVol", out v1))
                        {
                            switch (v1[0])
                            {
                                case 'I': elem = "Ice"; break;
                                case 'F': elem = "Fire"; break;
                                case 'L': elem = "Lightning"; break;
                                default: elem = v1[0].ToString(); break;
                            }
                            return elem + " Attribute: +" + v1.Substring(1) + "%";
                        }
                    }
                    break;
                case AdditionType.hpmpchange:
                    sb = new StringBuilder();
                    sb.Append("Recover");
                    {
                        string v1;
                        if (this.Props.TryGetValue("hpChangePerTime", out v1))
                        {
                            sb.Append("HP per 10 seconds " + v1);
                        }
                    }
                    return sb.ToString();
                case AdditionType.mobcategory:
                    return "When attacking " + ItemStringHelper.GetMobCategoryName(Convert.ToInt32(this.Props["category"])) + " enemies, deals " + this.Props["damage"] + "% extra damage.";
                case AdditionType.mobdie:
                    sb = new StringBuilder();
                    {
                        string v1;
                        if (this.Props.TryGetValue("hpIncOnMobDie", out v1))
                        {
                            sb.AppendLine("When you kill a monster, to recover " + v1 + " HP");
                        }
                        if (this.Props.TryGetValue("hpIncRatioOnMobDie", out v1))
                        {
                            sb.AppendLine("When you kill a monster, has a " + Props["hpRatioProp"] + "% chance to recover " + v1 + "% of damage to as HP (Cannot recover more than 10% of Max HP.)");
                        }
                        if (this.Props.TryGetValue("mpIncOnMobDie", out v1))
                        {
                            sb.AppendLine("When you kill a monster, to recover " + v1 + " MP");
                        }
                        if (this.Props.TryGetValue("mpIncRatioOnMobDie", out v1))
                        {
                            sb.AppendLine("When you kill a monster, has a " + Props["hpRatioProp"] + "% chance to recover " + v1 + "% of damage to as MP (Cannot recover more than 10% of Max MP.)");
                        }
                    }
                    if (sb.Length > 0)
                    {
                        sb.Append("Function may be limited in some locations.");
                        return sb.ToString();
                    }
                    break;
                case AdditionType.skill:
                    switch (Convert.ToInt32(this.Props["id"]))
                    {
                        case 90000000: return "Has a chance to add: Instant Death effect";
                        case 90001001: return "Has a chance to add: Knock Down effect";
                        case 90001002: return "Has a chance to add: Slow effect";
                        case 90001003: return "Has a chance to add: Poison effect";
                        case 90001004: return "Has a chance to add: Darkness effect";
                        case 90001005: return "Has a chance to add: Seal effect";
                        case 90001006: return "Has a chance to add: Freeze effect";
                    }
                    break;
                case AdditionType.statinc:
                    sb = new StringBuilder();
                    {
                        List<GearPropType> props = new List<GearPropType>();
                        foreach (var kv in Props)
                        {
                            try
                            {
                                GearPropType propType = (GearPropType)Enum.Parse(typeof(GearPropType), kv.Key);
                                props.Add(propType);
                            }
                            catch
                            {
                            }
                        }
                        props.Sort();
                        foreach (GearPropType type in props)
                        {
                            sb.AppendLine(ItemStringHelper.GetGearPropString(type, Convert.ToInt32(Props[Enum.GetName(typeof(GearPropType), type)])));
                        }
                    }
                    if (sb.Length > 0)
                    {
                        return sb.ToString();
                    }
                    break;
                default: return null;
            }
            return null;
        }

        public string GetConString()
        {
            switch (this.ConType)
            {
                case GearPropType.reqJob:
                    string[] reqJobs = new string[this.ConValue.Count];
                    for (int i = 0; i < reqJobs.Length; i++)
                    {
                        reqJobs[i] = ItemStringHelper.GetJobName(this.ConValue[i]) ?? this.ConValue[i].ToString();
                    }
                    return "When your job is " + string.Join(" or ", reqJobs) + ",";
                case GearPropType.reqLevel:
                    return "When your level is " + this.ConValue[0] + " or higher,";
                case GearPropType.reqCraft:
                    int lastExp;
					return "When Diligence EXP is " + this.ConValue[0] + " (Lv. " + getPersonalityLevel(this.ConValue[0], out lastExp) + " " + lastExp + " Points) or higher";
                case GearPropType.reqWeekDay:
                    string[] weekdays = new string[this.ConValue.Count];
                    for (int i = 0; i < this.ConValue.Count; i++)
                    {
                        weekdays[i] = GetWeekDayString(this.ConValue[i]);
                    }
                    return string.Join(", ", weekdays);
                default:
                    return null;
            }
        }

        private int getPersonalityLevel(int totalExp, out int lastExp)
        {
            int curExp = 0;
            for (int level = 0; ; level++)
            {
                if (level == 0)
                {
                    curExp = 20;
                }
                else if (level < 10)
                {
                    curExp = (int)Math.Round(curExp * 1.3, MidpointRounding.AwayFromZero);
                }
                else if (level < 20)
                {
                    curExp = (int)Math.Round(curExp * 1.1, MidpointRounding.AwayFromZero);
                }
                else if (level < 30)
                {
                    curExp = (int)Math.Round(curExp * 1.03, MidpointRounding.AwayFromZero);
                }
                else if (level < 70)
                {
                    curExp = (int)Math.Round(curExp * 1.015, MidpointRounding.AwayFromZero);
                }
                else if (level < 100)
                {
                    curExp = (int)Math.Round(curExp * 1.003, MidpointRounding.AwayFromZero);
                }
                else
                {
                    lastExp = 0;
                    return 100;
                }
                if (totalExp - curExp <= 0)
                {
                    lastExp = totalExp;
                    return level;
                }
                else
                {
                    totalExp -= curExp;
                }
            }
        }

        private static string GetWeekDayString(int weekDay)
        {
            switch (weekDay)
            {
                case 0: return "Sunday";
                case 1: return "Monday";
                case 2: return "Tuesday";
                case 3: return "Wednesday";
                case 4: return "Thursday";
                case 5: return "Friday";
                case 6: return "Saturday";
                default: return "Week" + weekDay; //这怎么可能...
            }
        }

        public static Addition CreateFromNode(Wz_Node node)
        {
            if (node == null)
                return null;
            foreach (AdditionType type in Enum.GetValues(typeof(AdditionType)))
            {
                if (type.ToString() == node.Text)
                {
                    Addition addition = new Addition();
                    addition.Type = type;
                    Action<Wz_Node> addInt32 = n => addition.ConValue.Add(n.GetValue<int>());
                    Action<Wz_Node> addWeekDay = n =>
                    {
                        try
                        {
                            DayOfWeek weekday = (DayOfWeek)Enum.Parse(typeof(DayOfWeek), n.GetValue<string>(), true);
                            addition.ConValue.Add((int)weekday);
                        }
                        catch { }
                    };

                    foreach (Wz_Node subNode in node.Nodes)
                    {
                        if (subNode.Text == "con")
                        {
                            Action<Wz_Node> addValueFunc = addInt32;
                            foreach (Wz_Node conNode in subNode.Nodes)
                            {
                                switch (conNode.Text)
                                {
                                    case "job":
                                        addition.ConType = GearPropType.reqJob;
                                        break;
                                    //case "lv": //已不被官方识别了
                                    case "level":
                                        addition.ConType = GearPropType.reqLevel;
                                        break;
                                    case "craft":
                                        addition.ConType = GearPropType.reqCraft;
                                        break;
                                    case "weekDay":
                                        addition.ConType = GearPropType.reqWeekDay;
                                        addValueFunc = addWeekDay; //改变解析方法
                                        break;
                                    default: //不识别的东西
                                        addition.ConType = (GearPropType)0;
                                        continue;
                                }

                                if (conNode.Nodes.Count > 0)
                                {
                                    foreach (Wz_Node conValNode in conNode.Nodes)
                                    {
                                        addValueFunc(conValNode);
                                    }
                                }
                                else
                                {
                                    addValueFunc(conNode);
                                }
                            }
                        }
                        else
                        {
                            addition.Props.Add(subNode.Text, Convert.ToString(subNode.Value));
                        }
                    }
                    return addition;
                }
            }
            return null;
        }
    }
}

```

`WzComparerR2.Common/CharaSim/AdditionType.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace WzComparerR2.CharaSim
{
    public enum AdditionType
    {
        skill = 1,
        mobcategory,
        elemboost,
        hpmpchange,
        critical,
        mobdie,
        boss,
        statinc = 8
    }
}

```

`WzComparerR2.Common/CharaSim/AlienStone.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace WzComparerR2.CharaSim
{
    public class AlienStone
    {
        public AlienStoneGrade Grade { get; set; }
    }
}

```

`WzComparerR2.Common/CharaSim/AlienStoneGrade.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace WzComparerR2.CharaSim
{
    public enum AlienStoneGrade
    {
        /// <summary>
        /// 表示D级星岩。
        /// </summary>
        Normal = 0,
        /// <summary>
        /// 表示C级星岩。
        /// </summary>
        Rare = 1,
        /// <summary>
        /// 表示B级星岩。
        /// </summary>
        Epic = 2,
        /// <summary>
        /// 表示A级星岩。
        /// </summary>
        Unique = 3,
        /// <summary>
        /// 表示S级星岩。
        /// </summary>
        Legendary = 4
    }
}

```

`WzComparerR2.Common/CharaSim/CashPackage.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

using WzComparerR2.WzLib;

namespace WzComparerR2.CharaSim
{
    public class CashPackage : ItemBase
    {
        public CashPackage()
        {
            SN = new List<int>();
        }
        public string name;
        public string desc;
        public int onlyCash;
        public List<int> SN;

        public static CashPackage CreateFromNode(Wz_Node itemNode, Wz_Node cashPackageNode, GlobalFindNodeFunction findNode)
        {
            CashPackage cashPackage = new CashPackage();
            int value;
            if (itemNode == null
                || !Int32.TryParse(itemNode.Text, out value)
                && !((value = itemNode.Text.IndexOf(".img")) > -1 && Int32.TryParse(itemNode.Text.Substring(0, value), out value)))
            {
                return null;
            }
            cashPackage.ItemID = value;

            Wz_Node pngNode;
            foreach (Wz_Node subNode in itemNode.Nodes)
            {
                switch (subNode.Text)
                {
                    case "icon":
                        pngNode = subNode;
                        if (pngNode.Value is Wz_Uol)
                        {
                            Wz_Uol uol = pngNode.Value as Wz_Uol;
                            Wz_Node uolNode = uol.HandleUol(subNode);
                            if (uolNode != null)
                            {
                                pngNode = uolNode;
                            }
                        }
                        if (pngNode.Value is Wz_Png)
                        {
                            cashPackage.Icon = BitmapOrigin.CreateFromNode(pngNode, findNode);
                        }

                        break;
                    case "name":
                        cashPackage.name = Convert.ToString(subNode.Value);
                        break;
                    case "desc":
                        cashPackage.desc = Convert.ToString(subNode.Value);
                        break;
                    case "onlyCash":
                        cashPackage.onlyCash = Convert.ToInt32(subNode.Value);
                        break;
                }
            }

            if (cashPackageNode != null)
            {
                Wz_Node snNode = cashPackageNode.FindNodeByPath("SN");
                if (snNode != null)
                {
                    foreach (Wz_Node subNode in snNode.Nodes)
                    {
                        int SN = Convert.ToInt32(subNode.Value);
                        cashPackage.SN.Add(SN);
                    }
                }
            }

            return cashPackage;
        }
    }
}

```

`WzComparerR2.Common/CharaSim/Commodity.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

using WzComparerR2.WzLib;

namespace WzComparerR2.CharaSim
{
    public class Commodity
    {
        public Commodity()
        {
        }
        public int SN;
        public int ItemId;
        public int Count;
        public int Price;
        public int Bonus;
        public int Period;
        public int Priority;
        public int ReqPOP;
        public int ReqLEV;
        public int Gender;
        public int OnSale;
        public int Class;
        public int Limit;
        public string gameWorld;
        public int LimitMax;
        public int LimitQuestID;
        public int originalPrice;
        public int discount;
        public int PbCash;
        public int PbPoint;
        public int PbGift;
        public int Refundable;
        public int WebShop;
        public int termStart;
        public string termEnd;

        public static Commodity CreateFromNode(Wz_Node commodityNode)
        {
            if (commodityNode == null)
                return null;

            Commodity commodity = new Commodity();

            foreach (Wz_Node subNode in commodityNode.Nodes)
            {
                int value;
                Int32.TryParse(Convert.ToString(subNode.Value), out value);
                switch (subNode.Text)
                {
                    case "SN":
                        commodity.SN = value;
                        break;
                    case "ItemId":
                        commodity.ItemId = value;
                        break;
                    case "Count":
                        commodity.Count = value;
                        break;
                    case "Price":
                        commodity.Price = value;
                        break;
                    case "Bonus":
                        commodity.Bonus = value;
                        break;
                    case "Period":
                        commodity.Period = value;
                        break;
                    case "Priority":
                        commodity.Priority = value;
                        break;
                    case "ReqPOP":
                        commodity.ReqPOP = value;
                        break;
                    case "ReqLEV":
                        commodity.ReqLEV = value;
                        break;
                    case "Gender":
                        commodity.Gender = value;
                        break;
                    case "OnSale":
                        commodity.OnSale = value;
                        break;
                    case "Class":
                        commodity.Class = value;
                        break;
                    case "Limit":
                        commodity.Limit = value;
                        break;
                    case "gameWorld":
                        commodity.gameWorld = Convert.ToString(subNode.Value);
                        break;
                    case "originalPrice":
                        commodity.originalPrice = value;
                        break;
                    case "discount":
                        commodity.discount = value;
                        break;
                    case "PbCash":
                        commodity.PbCash = value;
                        break;
                    case "PbPoint":
                        commodity.PbPoint = value;
                        break;
                    case "PbGift":
                        commodity.PbGift = value;
                        break;
                    case "Refundable":
                        commodity.Refundable = value;
                        break;
                    case "WebShop":
                        commodity.WebShop = value;
                        break;
                    case "termStart":
                        commodity.termStart = value;
                        break;
                    case "termEnd":
                        if (value != 0)
                            commodity.termEnd = string.Format("{0:D8}/{1:D2}0000", value / 100, value % 100);
                        else
                            commodity.termEnd = Convert.ToString(subNode.Value);
                        break;
                }
            }

            return commodity;
        }
    }
}

```

`WzComparerR2.Common/CharaSim/ExclusiveEquip.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using WzComparerR2.WzLib;

namespace WzComparerR2.CharaSim
{
    public class ExclusiveEquip
    {
        public ExclusiveEquip()
        {
            this.Items = new List<int>();
        }
        public string Info { get; set; }
        public List<int> Items { get; private set; }
        public string Msg { get; set; }

        public static ExclusiveEquip CreateFromNode(Wz_Node exclusiveEquipNode)
        {
            if (exclusiveEquipNode == null)
                return null;

            ExclusiveEquip exclusiveEquip = new ExclusiveEquip();

            foreach (Wz_Node subNode in exclusiveEquipNode.Nodes)
            {
                switch (subNode.Text)
                {
                    case "info":
                        exclusiveEquip.Info = Convert.ToString(subNode.Value);
                        break;
                    case "item":
                        foreach (Wz_Node itemNode in subNode.Nodes)
                        {
                            int itemID = Convert.ToInt32(itemNode.Value);
                            exclusiveEquip.Items.Add(itemID);
                        }
                        break;
                    case "msg":
                        exclusiveEquip.Msg = Convert.ToString(subNode.Value);
                        break;
                }
            }

            return exclusiveEquip;
        }
    }
}

```

`WzComparerR2.Common/CharaSim/FormulaVersion.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace WzComparerR2.CharaSim
{
    public enum FormulaVersion
    {
        Bigbang = 0,
        Chaos = 1
    }
}

```

`WzComparerR2.Common/CharaSim/Gear.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Text.RegularExpressions;
using System.Drawing;
using System.Linq;
using WzComparerR2.WzLib;

namespace WzComparerR2.CharaSim
{
    public class Gear : ItemBase
    {
        public Gear()
        {
            Props = new Dictionary<GearPropType, int>();
            VariableStat = new Dictionary<GearPropType, float>();
            AbilityTimeLimited = new Dictionary<GearPropType, int>();
            Options = new Potential[3];
            AdditionalOptions = new Potential[3];
            Additions = new List<Addition>();
        }
        public GearGrade Grade { get; set; }
        public GearGrade AdditionGrade { get; set; }
        public GearType type;
        public GearState State { get; set; }

        public int diff
        {
            get { return Compare(this); }
        }

        public Potential[] Options { get; private set; }
        public Potential[] AdditionalOptions { get; private set; }
        public AlienStone AlienStoneSlot { get; set; }

        public int Star { get; set; }
        public int ScrollUp { get; set; }
        public int Hammer { get; set; }
        public bool HasTuc { get; internal set; }
        public int PlatinumHammer { get; set; }
        public bool CanPotential { get; internal set; }
        public string EpicHs { get; internal set; }

        public bool FixLevel { get; internal set; }
        public List<GearLevelInfo> Levels { get; internal set; }
        public List<GearSealedInfo> Seals { get; internal set; }

        public List<Addition> Additions { get; private set; }
        public Dictionary<GearPropType, int> Props { get; private set; }
        public Dictionary<GearPropType, float> VariableStat { get; private set; }
        public Dictionary<GearPropType, int> AbilityTimeLimited { get; private set; }

        /// <summary>
        /// 获取或设置装备的标准属性。
        /// </summary>
        public Dictionary<GearPropType, int> StandardProps { get; private set; }


        public bool Epic
        {
            get { return GetBooleanValue(GearPropType.epicItem); }
        }

        public bool TimeLimited
        {
            get { return GetBooleanValue(GearPropType.timeLimited); }
        }

        public bool Cash
        {
            get { return GetBooleanValue(GearPropType.cash); }
        }

        public bool GetBooleanValue(GearPropType type)
        {
            int value;
            return this.Props.TryGetValue(type, out value) && value != 0;
        }

        public IEnumerable<KeyValuePair<GearPropType, int>> PropsV5
        {
            get
            {
                return this.Props.Where(kv => IsV5SupportPropType(kv.Key));
            }
        }

        public int GetMaxStar()
        {
            if (!this.HasTuc)
            {
                return 0;
            }
            if (this.Cash)
            {
                return 0;
            }
            if (this.GetBooleanValue(GearPropType.onlyUpgrade))
            {
                return 0;
            }
            if (this.type == GearType.machineEngine || this.type == GearType.machineArms || this.type == GearType.machineLegs || this.type == GearType.machineBody || this.type == GearType.machineTransistors || this.type == GearType.dragonMask || this.type == GearType.dragonPendant || this.type == GearType.dragonWings || this.type == GearType.dragonTail)
            {
                return 0;
            }

            int reqLevel;
            this.Props.TryGetValue(GearPropType.reqLevel, out reqLevel);
            int[] data = null;
            foreach (int[] item in starData)
            {
                if (reqLevel >= item[0])
                {
                    data = item;
                }
                else
                {
                    break;
                }
            }
            if (data == null)
            {
                return 0;
            }

            return data[this.GetBooleanValue(GearPropType.superiorEqp) ? 2 : 1];
        }

        private static readonly int[][] starData = new int[][] {
            new[]{ 0, 5, 3 }, 
            new[]{ 95, 8, 5 }, 
            new[]{ 108, 10, 8 },
            //new[]{ 120, 12, 10 }, before GMS 25 Stars update
            new[]{ 118, 15, 10 },
            //new[]{ 130, 13, 12 }, before GMS 25 Stars update
            new[]{ 128, 20, 12 },
            //new[]{ 140, 15, 15 }, before GMS 25 Stars update
            new[]{ 138, 25, 15 },
        };

        public override object Clone()
        {
            Gear gear = (Gear)this.MemberwiseClone();
            gear.Props = new Dictionary<GearPropType, int>(this.Props.Count);
            foreach (KeyValuePair<GearPropType, int> p in this.Props)
            {
                gear.Props.Add(p.Key, p.Value);
            }
            gear.Options = (Potential[])this.Options.Clone();
            gear.Additions = new List<Addition>(this.Additions);
            return gear;
        }

        public void MakeTimeLimitedPropAvailable()
        {
            if (AbilityTimeLimited.Count > 0)
            {
                foreach (var kv in AbilityTimeLimited)
                {
                    this.Props[kv.Key] = this.Props[kv.Key] + kv.Value;
                }
                this.Props[GearPropType.abilityTimeLimited] = 1;
            }
        }

        public void RestoreStandardProperties()
        {
            if (this.StandardProps != null)
            {
                this.Props.Clear();
                foreach (var kv in AbilityTimeLimited)
                {
                    this.Props[kv.Key] = kv.Value;
                }
            }
        }

        public void Upgrade(Wz_Node infoNode, int count)
        {
            this.ScrollUp += count;
            foreach (Wz_Node subNode in infoNode.Nodes)
            {
                GearPropType type;
                if (!int.TryParse(subNode.Text, out _) && Enum.TryParse(subNode.Text, out type) && (int)type < 100)
                {
                    try
                    {
                        if (this.Props.ContainsKey(type))
                        {
                            this.Props[type] += Convert.ToInt32(subNode.Value) * count;
                        }
                        else
                        {
                            this.Props.Add(type, Convert.ToInt32(subNode.Value) * count);
                        }
                    }
                    finally
                    {
                    }
                }
            }
            if (this.Props.ContainsKey(GearPropType.tuc))
            {
                this.Props[GearPropType.tuc] -= count;
            }
        }

        public static bool IsFace(GearType type)
        {
            string gearTypeName = Enum.GetName(typeof(GearType), type);
            return gearTypeName != null && Regex.IsMatch(gearTypeName, @"^face\d*$");
        }

        public static bool IsHair(GearType type)
        {
            string gearTypeName = Enum.GetName(typeof(GearType), type);
            return gearTypeName != null && Regex.IsMatch(gearTypeName, @"^hair\d*$");
        }

        public static bool IsWeapon(GearType type)
        {
            return IsLeftWeapon(type)
                || IsDoubleHandWeapon(type);
        }

        /// <summary>
        /// 获取一个值，指示装备类型是否为主手武器。
        /// </summary>
        /// <param name="type">装备类型。</param>
        /// <returns></returns>
        public static bool IsLeftWeapon(GearType type)
        {
            return (int)type >= 121 && (int)type <= 139 && type != GearType.katara
                || ((int)type / 10) == 121;
        }

        public static bool IsSubWeapon(GearType type)
        {
            switch (type)
            {
                case GearType.katara:
                //case GearType.shield:
                case GearType.demonShield:
                case GearType.soulShield:
                    return true;

                default:
                    if ((int)type / 1000 == 135)
                    {
                        return true;
                    }
                    return false;
            }
        }

        /// <summary>
        /// 获取一个值，指示装备类型是否为双手武器。
        /// </summary>
        /// <param name="type">装备类型。</param>
        /// <returns></returns>
        public static bool IsDoubleHandWeapon(GearType type)
        {
            int _type = (int)type;
            return (_type >= 140 && _type <= 149)
                || (_type >= 152 && _type <= 159)
                || type == GearType.boxingCannon
                || type == GearType.chakram;
        }

        public static bool IsMechanicGear(GearType type)
        {
            return (int)type >= 161 && (int)type <= 165;
        }

        public static bool IsDragonGear(GearType type)
        {
            return (int)type >= 194 && (int)type <= 197;
        }

        public static int Compare(Gear gear, Gear originGear)
        {
            if (gear.ItemID != originGear.ItemID)
                return 0;
            int diff = 0;
            int tempValue;
            foreach (KeyValuePair<GearPropType, int> prop in gear.Props)
            {
                originGear.Props.TryGetValue(prop.Key, out tempValue);//在原装备中寻找属性 若没有找到 视为0
                diff += (int)Math.Round((prop.Value - tempValue) / (double)GetPropTypeWeight(prop.Key));
            }
            foreach (KeyValuePair<GearPropType, int> prop in originGear.Props)
            {
                if (!gear.Props.TryGetValue(prop.Key, out tempValue))//寻找装备原属性里新装备没有的
                {
                    diff -= (int)Math.Round(prop.Value / (double)GetPropTypeWeight(prop.Key));
                }
            }
            return diff;
        }

        public static int Compare(Gear gear)
        {
            int diff = 0;
            int tempValue;
            foreach (KeyValuePair<GearPropType, int> prop in gear.Props)
            {
                gear.StandardProps.TryGetValue(prop.Key, out tempValue);//在原装备中寻找属性 若没有找到 视为0
                diff += (int)Math.Round((prop.Value - tempValue) / (double)GetPropTypeWeight(prop.Key));
            }
            foreach (KeyValuePair<GearPropType, int> prop in gear.StandardProps)
            {
                if (!gear.Props.TryGetValue(prop.Key, out tempValue))//寻找装备原属性里新装备没有的
                {
                    diff -= (int)Math.Round(prop.Value / (double)GetPropTypeWeight(prop.Key));
                }
            }
            return diff;
        }

        private static int GetPropTypeWeight(GearPropType type)
        {
            if ((int)type < 100)
            {
                switch (type)
                {
                    case GearPropType.incSTR:
                    case GearPropType.incDEX:
                    case GearPropType.incINT:
                    case GearPropType.incLUK:
                    case GearPropType.incPAD:
                    case GearPropType.incMAD:
                    case GearPropType.incSpeed:
                    case GearPropType.incJump:
                        return 1;
                    case GearPropType.incMHP:
                    case GearPropType.incMMP:
                        return 100;
                    case GearPropType.incPDD_incMDD:
                    case GearPropType.incPDD:
                        return 10;
                    case GearPropType.incPAD_incMAD:
                    case GearPropType.incAD:
                        return 2;
                    case GearPropType.incMHP_incMMP:
                        return 200;
                }
            }
            return int.MaxValue;
        }

        public static bool IsEpicPropType(GearPropType type)
        {
            switch (type)
            {
                case GearPropType.incPAD:
                case GearPropType.incMAD:
                case GearPropType.incSTR:
                case GearPropType.incDEX:
                case GearPropType.incINT:
                case GearPropType.incLUK:
                    return true;
                default:
                    return false;
            }
        }

        public static bool IsV5SupportPropType(GearPropType type)
        {
            switch (type)
            {
                case GearPropType.incMDD:
                case GearPropType.incMDDr:
                case GearPropType.incACC:
                case GearPropType.incACCr:
                case GearPropType.incEVA:
                case GearPropType.incEVAr:
                    return false;
                default:
                    return true;
            }
        }

        /// <summary>
        /// 获取装备类型。
        /// </summary>
        /// <param Name="gearCode"></param>
        /// <returns></returns>
        public static GearType GetGearType(int code)
        {
            switch (code / 1000)
            {
                case 1098:
                    return GearType.soulShield;
                case 1099:
                    return GearType.demonShield;
                case 1212:
                    return GearType.shiningRod;
                case 1213:
                    return GearType.tuner;
                case 1214:
                    return GearType.breathShooter;
                case 1403:
                    return GearType.boxingCannon;
                case 1404:
                    return GearType.chakram;
            }
            if (code / 10000 == 135)
            {
                switch (code / 100)
                {
                    case 13522:
                    case 13528:
                    case 13529:
                    case 13540:
                        return (GearType)(code / 10);

                    default:
                        return (GearType)(code / 100 * 10);
                }
            }
            if (code / 10000 == 119)
            {
                switch(code / 100)
                {
                    case 11902:
                        return (GearType)(code / 10);
                }
            }
            return (GearType)(code / 10000);
        }

        public static int GetGender(int code)
        {
            GearType type = GetGearType(code);
            switch (type)
            {
                case GearType.emblem:
                case GearType.powerSource:
                case GearType.bit:
                case (GearType)3: //发型
                    return 2;
            }

            return code / 1000 % 10;
        }

        public static bool SpecialCanPotential(GearType type)
        {
            switch (type)
            {
                case GearType.soulShield:
                case GearType.demonShield:
                case GearType.katara:
                case GearType.magicArrow:
                case GearType.card:
                case GearType.box:
                case GearType.orb:
                case GearType.novaMarrow:
                case GearType.soulBangle:
                case GearType.mailin:
                case GearType.emblem:
                    return true;
                default:
                    return false;
            }
        }

        public static IEnumerable<KeyValuePair<GearPropType, int>> CombineProperties(IEnumerable<KeyValuePair<GearPropType, int>> props)
        {
            var wrappedProp = props.Select(kv => new KeyValuePair<GearPropType, object>(kv.Key, kv.Value));
            var combinedProp = CombineProperties(wrappedProp);
            return combinedProp.Select(kv => new KeyValuePair<GearPropType, int>(kv.Key, Convert.ToInt32(kv.Value)));
        }

        public static IEnumerable<KeyValuePair<GearPropType, object>> CombineProperties(IEnumerable<KeyValuePair<GearPropType, object>> props)
        {
            var combinedProps = new SortedDictionary<GearPropType, object>();
            var propCache = new SortedDictionary<GearPropType, object>();
            foreach (var kv in props)
            {
                propCache.Add(kv.Key, kv.Value);
            }

            object obj;
            foreach (var prop in propCache)
            {
                switch (prop.Key)
                {
                    case GearPropType.incAllStat:
                        if (combinedProps.ContainsKey(GearPropType.incAllStat_incMHP25) || combinedProps.ContainsKey(GearPropType.incAllStat_incMHP50_incMMP50))
                        {
                            break;
                        }
                        else if (propCache.TryGetValue(GearPropType.incMHP, out obj)
                            && object.Equals((int)prop.Value * 25, obj)
                            && !propCache.ContainsKey(GearPropType.incMMP))
                        {
                            combinedProps.Add(GearPropType.incAllStat_incMHP25, prop.Value);
                            break;
                        }
                        else if (propCache.TryGetValue(GearPropType.incMHP, out obj)
                            && object.Equals((int)prop.Value * 50, obj)
                            && propCache.TryGetValue(GearPropType.incMMP, out obj)
                            && object.Equals((int)prop.Value * 50, obj))
                        {
                            combinedProps.Add(GearPropType.incAllStat_incMHP50_incMMP50, prop.Value);
                            break;
                        }
                        goto default;

                    case GearPropType.incMHP:
                        if (combinedProps.ContainsKey(GearPropType.incAllStat_incMHP25))
                        {
                            break;
                        }
                        goto case GearPropType.incMMP;
                    case GearPropType.incMMP:
                        if (combinedProps.ContainsKey(GearPropType.incMHP_incMMP) || combinedProps.ContainsKey(GearPropType.incAllStat_incMHP50_incMMP50))
                        {
                            break;
                        }
                        else if (propCache.TryGetValue(prop.Key == GearPropType.incMHP ? GearPropType.incMMP : GearPropType.incMHP, out obj)
                            && object.Equals(prop.Value, obj)
                            && !combinedProps.ContainsKey(GearPropType.incAllStat_incMHP50_incMMP50))
                        {
                            combinedProps.Add(GearPropType.incMHP_incMMP, prop.Value);
                            break;
                        }
                        goto default;

                    case GearPropType.incMHPr:
                    case GearPropType.incMMPr:
                        if (combinedProps.ContainsKey(GearPropType.incMHPr_incMMPr))
                        {
                            break;
                        }
                        else if (propCache.TryGetValue(prop.Key == GearPropType.incMHPr ? GearPropType.incMMPr : GearPropType.incMHPr, out obj)
                            && object.Equals(prop.Value, obj))
                        {
                            combinedProps.Add(GearPropType.incMHPr_incMMPr, prop.Value);
                            break;
                        }
                        goto default;

                    case GearPropType.incPAD:
                    case GearPropType.incMAD:
                        if (combinedProps.ContainsKey(GearPropType.incPAD_incMAD))
                        {
                            break;
                        }
                        else if (propCache.TryGetValue(prop.Key == GearPropType.incPAD ? GearPropType.incMAD : GearPropType.incPAD, out obj)
                            && object.Equals(prop.Value, obj))
                        {
                            combinedProps.Add(GearPropType.incPAD_incMAD, prop.Value);
                            break;
                        }
                        goto default;

                    case GearPropType.incPDD:
                    case GearPropType.incMDD:
                        if (combinedProps.ContainsKey(GearPropType.incPDD_incMDD))
                        {
                            break;
                        }
                        else if (propCache.TryGetValue(prop.Key == GearPropType.incPDD ? GearPropType.incMDD : GearPropType.incPDD, out obj)
                            && object.Equals(prop.Value, obj))
                        {
                            combinedProps.Add(GearPropType.incPDD_incMDD, prop.Value);
                            break;
                        }
                        goto default;

                    case GearPropType.incACC:
                    case GearPropType.incEVA:
                        if (combinedProps.ContainsKey(GearPropType.incACC_incEVA))
                        {
                            break;
                        }
                        else if (propCache.TryGetValue(prop.Key == GearPropType.incACC ? GearPropType.incEVA : GearPropType.incACC, out obj)
                            && object.Equals(prop.Value, obj))
                        {
                            combinedProps.Add(GearPropType.incACC_incEVA, prop.Value);
                            break;
                        }
                        goto default;

                    default:
                        combinedProps.Add(prop.Key, prop.Value);
                        break;
                }
            }
            return combinedProps;
        }

        public static Gear CreateFromNode(Wz_Node node, GlobalFindNodeFunction findNode)
        {
            int gearID;
            Match m = Regex.Match(node.Text, @"^(\d{8})\.img$");
            if (!(m.Success && Int32.TryParse(m.Result("$1"), out gearID)))
            {
                return null;
            }
            Gear gear = new Gear();
            gear.ItemID = gearID;
            gear.type = Gear.GetGearType(gear.ItemID);
            Wz_Node infoNode = node.FindNodeByPath("info");

            if (infoNode != null)
            {
                foreach (Wz_Node subNode in infoNode.Nodes)
                {
                    switch (subNode.Text)
                    {
                        case "icon":
                            if (subNode.Value is Wz_Png || subNode.Value is Wz_Uol)
                            {
                                gear.Icon = BitmapOrigin.CreateFromNode(subNode, findNode);
                            }
                            break;

                        case "iconRaw":
                            if (subNode.Value is Wz_Png || subNode.Value is Wz_Uol)
                            {
                                gear.IconRaw = BitmapOrigin.CreateFromNode(subNode, findNode);
                            }
                            break;

                        case "sample":
                            if (subNode.Value is Wz_Png)
                            {
                                gear.Sample = BitmapOrigin.CreateFromNode(subNode, findNode);
                            }
                            break;

                        case "addition": //附加属性信息
                            foreach (Wz_Node addiNode in subNode.Nodes)
                            {
                                Addition addi = Addition.CreateFromNode(addiNode);
                                if (addi != null)
                                    gear.Additions.Add(addi);
                            }
                            gear.Additions.Sort((add1, add2) => (int)add1.Type - (int)add2.Type);
                            break;

                        case "option": //附加潜能信息
                            Wz_Node itemWz = findNode !=null? findNode("Item\\ItemOption.img"):null;
                            if (itemWz == null)
                                break;
                            int optIdx = 0;
                            foreach (Wz_Node optNode in subNode.Nodes)
                            {
                                int optId = 0, optLevel = 0;
                                foreach (Wz_Node optArgNode in optNode.Nodes)
                                {
                                    switch (optArgNode.Text)
                                    {
                                        case "option": optId = Convert.ToInt32(optArgNode.Value); break;
                                        case "level": optLevel = Convert.ToInt32(optArgNode.Value); break;
                                    }
                                }

                                Potential opt = Potential.CreateFromNode(itemWz.FindNodeByPath(optId.ToString("d6")), optLevel);
                                if (opt != null)
                                    gear.Options[optIdx++] = opt;
                            }
                            break;

                        case "level": //可升级信息
                            if (subNode.Nodes["fixLevel"].GetValueEx<int>(0) != 0)
                            {
                                gear.FixLevel = true;
                            }

                            Wz_Node levelInfo = subNode.Nodes["info"];
                            gear.Levels = new List<GearLevelInfo>();
                            if (levelInfo != null)
                            {
                                for (int i = 1; ; i++)
                                {
                                    Wz_Node levelInfoNode = levelInfo.Nodes[i.ToString()];
                                    if (levelInfoNode != null)
                                    {
                                        GearLevelInfo info = GearLevelInfo.CreateFromNode(levelInfoNode);
                                        int lv;
                                        Int32.TryParse(levelInfoNode.Text, out lv);
                                        info.Level = lv;
                                        gear.Levels.Add(info);
                                    }
                                    else
                                    {
                                        break;
                                    }
                                }
                            }

                            Wz_Node levelCase = subNode.Nodes["case"];
                            if (levelCase != null)
                            {
                                int probTotal = 0;
                                foreach (Wz_Node caseNode in levelCase.Nodes)
                                {
                                    int prob = caseNode.Nodes["prob"].GetValueEx(0);
                                    probTotal += prob;
                                    for (int i = 0; i < gear.Levels.Count; i++)
                                    {
                                        GearLevelInfo info = gear.Levels[i];
                                        Wz_Node caseLevel = caseNode.Nodes[info.Level.ToString()];
                                        if (caseLevel != null)
                                        {
                                            //desc
                                            Wz_Node caseHS = caseLevel.Nodes["hs"];
                                            if (caseHS != null)
                                            {
                                                info.HS = caseHS.GetValue<string>();
                                            }

                                            //随机技能
                                            Wz_Node caseSkill = caseLevel.Nodes["Skill"];
                                            if (caseSkill != null)
                                            {
                                                foreach (Wz_Node skillNode in caseSkill.Nodes)
                                                {
                                                    int id = skillNode.Nodes["id"].GetValueEx(-1);
                                                    int level = skillNode.Nodes["level"].GetValueEx(-1);
                                                    if (id >= 0 && level >= 0)
                                                    {
                                                        info.Skills[id] = level;
                                                    }
                                                }
                                            }

                                            //装备技能
                                            Wz_Node equipSkill = caseLevel.Nodes["EquipmentSkill"];
                                            if (equipSkill != null)
                                            {
                                                foreach (Wz_Node skillNode in equipSkill.Nodes)
                                                {
                                                    int id = skillNode.Nodes["id"].GetValueEx(-1);
                                                    int level = skillNode.Nodes["level"].GetValueEx(-1);
                                                    if (id >= 0 && level >= 0)
                                                    {
                                                        info.EquipmentSkills[id] = level;
                                                    }
                                                }
                                            }
                                            info.Prob = prob;
                                        }
                                    }
                                }

                                foreach (var info in gear.Levels)
                                {
                                    info.ProbTotal = probTotal;
                                }
                            }
                            gear.Props.Add(GearPropType.level, 1);
                            break;

                        case "sealed": //封印解除信息
                            Wz_Node sealedInfo = subNode.Nodes["info"];
                            gear.Seals = new List<GearSealedInfo>();
                            if (sealedInfo != null)
                            {
                                foreach (Wz_Node levelInfoNode in sealedInfo.Nodes)
                                {
                                    GearSealedInfo info = GearSealedInfo.CreateFromNode(levelInfoNode, findNode);
                                    int lv;
                                    Int32.TryParse(levelInfoNode.Text, out lv);
                                    info.Level = lv;
                                    gear.Seals.Add(info);
                                }
                            }
                            gear.Props.Add(GearPropType.@sealed, 1);
                            break;

                        case "variableStat": //升级奖励属性
                            foreach (Wz_Node statNode in subNode.Nodes)
                            {
                                GearPropType type;
                                if (Enum.TryParse(statNode.Text, out type))
                                {
                                    try
                                    {
                                        gear.VariableStat.Add(type, Convert.ToSingle(statNode.Value));
                                    }
                                    finally
                                    {
                                    }
                                }
                            }
                            break;

                        case "abilityTimeLimited": //限时属性
                            foreach (Wz_Node statNode in subNode.Nodes)
                            {
                                GearPropType type;
                                if (Enum.TryParse(statNode.Text, out type))
                                {
                                    try
                                    {
                                        gear.AbilityTimeLimited.Add(type, Convert.ToInt32(statNode.Value));
                                    }
                                    finally
                                    {
                                    }
                                }
                            }
                            break;

                        case "onlyUpgrade":
                            int upgradeItemID = subNode.Nodes["0"]?.GetValueEx(0) ?? 0;
                            gear.Props.Add(GearPropType.onlyUpgrade, upgradeItemID);
                            break;

                        case "epic":
                            Wz_Node hsNode = subNode.Nodes["hs"];
                            if (hsNode != null)
                            {
                                gear.EpicHs = Convert.ToString(hsNode.Value);
                            }
                            break;

                        case "gatherTool":
                            foreach (Wz_Node gatherNode in subNode.Nodes)
                            {
                                GearPropType type;
                                if (Enum.TryParse(subNode.Text + "_" + gatherNode.Text, out type))
                                {
                                    try
                                    {
                                        gear.Props.Add(type, Convert.ToInt32(gatherNode.Value));
                                    }
                                    finally
                                    {
                                    }
                                }
                            }
                            break;

                        default:
                            {
                                GearPropType type;
                                if (!int.TryParse(subNode.Text, out _) && Enum.TryParse(subNode.Text, out type))
                                {
                                    try
                                    {
                                        gear.Props.Add(type, Convert.ToInt32(subNode.Value));
                                    }
                                    finally
                                    {
                                    }
                                }
                            }
                            break;
                    }
                }
            }
            int value;

            //读取默认可升级状态
            if (gear.Props.TryGetValue(GearPropType.tuc, out value) && value > 0)
            {
                gear.HasTuc = true;
                gear.CanPotential = true;
            }
            else if (Gear.SpecialCanPotential(gear.type) || Gear.IsSubWeapon(gear.type) || (gear.Props.TryGetValue(GearPropType.tucIgnoreForPotential, out value) && value > 0))
            {
                gear.CanPotential = true;
            }
            if (Gear.IsMechanicGear(gear.type) || Gear.IsDragonGear(gear.type))
            {
                gear.CanPotential = false;
            }
            else if (gear.Props.TryGetValue(GearPropType.noPotential, out value) && value > 0)
            {
                gear.CanPotential = false;
            }

            //读取默认gearGrade
            if (gear.Props.TryGetValue(GearPropType.fixedGrade, out value))
            {
                //gear.Grade = (GearGrade)(value - 1);
                switch (value)
                {
                    case 2: gear.Grade = GearGrade.B; break;
                    case 3: gear.Grade = GearGrade.A; break;
                    case 5: gear.Grade = GearGrade.S; break;
                    case 7: gear.Grade = GearGrade.SS; break;
                    default: gear.Grade = (GearGrade)(value - 1); break;
                }
            }

            //自动填充Grade
            if (gear.Options.Any(opt => opt != null) && gear.Grade == GearGrade.C)
            {
                gear.Grade = GearGrade.B;
            }

            //添加默认装备要求
            GearPropType[] types = new GearPropType[]{
                GearPropType.reqJob,GearPropType.reqLevel,GearPropType.reqSTR,GearPropType.reqDEX,
            GearPropType.reqINT,GearPropType.reqLUK};
            foreach (GearPropType type in types)
            {
                if (!gear.Props.ContainsKey(type))
                {
                    gear.Props.Add(type, 0);
                }
            }

            //修复恶魔盾牌特殊属性
            if (gear.type == GearType.demonShield)
            {
                if (gear.Props.TryGetValue(GearPropType.incMMP, out value))
                {
                    gear.Props.Remove(GearPropType.incMMP);
                    gear.Props.Add(GearPropType.incMDF, value);
                }
            }

            //备份标准属性
            gear.StandardProps = new Dictionary<GearPropType, int>(gear.Props);

            //追加限时属性
            gear.MakeTimeLimitedPropAvailable();

            if (Gear.IsFace(gear.type))
            {
                gear.Icon = BitmapOrigin.CreateFromNode(findNode(@"Item\Install\0380.img\03801284\info\icon"), findNode);
                gear.IconRaw = BitmapOrigin.CreateFromNode(findNode(@"Item\Install\0380.img\03801284\info\iconRaw"), findNode);
            }
            if (Gear.IsHair(gear.type))
            {
                gear.Icon = BitmapOrigin.CreateFromNode(findNode(@"Item\Install\0380.img\03801283\info\icon"), findNode);
                gear.IconRaw = BitmapOrigin.CreateFromNode(findNode(@"Item\Install\0380.img\03801283\info\iconRaw"), findNode);
            }
            if (gear.type == GearType.head)
            {
                gear.Icon = BitmapOrigin.CreateFromNode(findNode(@"Item\Install\0380.img\03801577\info\icon"), findNode);
                gear.IconRaw = BitmapOrigin.CreateFromNode(findNode(@"Item\Install\0380.img\03801577\info\iconRaw"), findNode);
            }

            if (gear.Props.TryGetValue(GearPropType.incCHUC, out value))
            {
                gear.Star = value;
            }

            return gear;
        }
    }
}
```

`WzComparerR2.Common/CharaSim/GearGrade.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace WzComparerR2.CharaSim
{
    public enum GearGrade
    {
        /// <summary>
        /// C级(一般物品)
        /// </summary>
        C = 0,
        /// <summary>
        /// B级(高级物品)
        /// </summary>
        B = 1,
        /// <summary>
        /// A级(史诗物品)
        /// </summary>
        A = 2,
        /// <summary>
        /// S级(传说物品)
        /// </summary>
        S = 3,
        /// <summary>
        /// SS级(垃圾物品)
        /// </summary>
        SS = 4,
        /// <summary>
        /// (特殊物品)
        /// </summary>
        Special=5,
    }
}

```

`WzComparerR2.Common/CharaSim/GearLevelInfo.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using WzComparerR2.WzLib;

namespace WzComparerR2.CharaSim
{
    public class GearLevelInfo
    {
        public GearLevelInfo()
        {
            this.BonusProps = new Dictionary<GearPropType, Range>();
            this.Skills = new Dictionary<int, int>();
            this.EquipmentSkills = new Dictionary<int, int>();
        }

        public int Level { get; set; }
        public Dictionary<GearPropType, Range> BonusProps { get; private set; }
        public int Exp { get; set; }
        public int Point { get; set; }
        public int DecPoint { get; set; }

        public string HS { get; set; }
        public int Prob { get; set; }
        public int ProbTotal { get; set; }
        public Dictionary<int, int> Skills { get; private set; }
        public Dictionary<int, int> EquipmentSkills { get; private set; }

        public static GearLevelInfo CreateFromNode(Wz_Node node)
        {
            GearLevelInfo info = new GearLevelInfo();

            foreach (Wz_Node child in node.Nodes)
            {
                if (child.Text == "exp")
                {
                    info.Exp = child.GetValue(0);
                }
                else if (child.Text == "point")
                {
                    info.Point = child.GetValue(0);
                }
                else if (child.Text == "decPoint")
                {
                    info.DecPoint = child.GetValue(0);
                }
                else 
                {
                    string prefix;
                    if (child.Text.EndsWith("Min") || child.Text.EndsWith("Max"))
                    {
                        prefix = child.Text.Substring(0, child.Text.Length - 3);
                    }
                    else
                    {
                        prefix = child.Text;
                    }
                    
                    Range range;
                    try
                    {
                        GearPropType propType = (GearPropType)Enum.Parse(typeof(GearPropType), prefix, true);
                        info.BonusProps.TryGetValue(propType, out range);
                        if (child.Text.EndsWith("Min"))
                        {
                            range.Min = child.GetValue(0);
                            info.BonusProps[propType] = range;
                        }
                        else if (child.Text.EndsWith("Max"))
                        {
                            range.Max = child.GetValue(0);
                            info.BonusProps[propType] = range;
                        }
                        else
                        {
                            range.Min = range.Max = child.GetValue(0);
                            info.BonusProps[propType] = range;
                        }
                    }
                    catch
                    {
                    }
                }
            }
            return info;
        }

        public struct Range
        {
            public Range(int min, int max)
            {
                this.min = min;
                this.max = max;
            }

            private int min;
            private int max;
            public int Min
            {
                get { return min; }
                set { min = value; }
            }
            public int Max
            {
                get { return max; }
                set { max = value; }
            }
        }
    }
}

```

`WzComparerR2.Common/CharaSim/GearPropType.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace WzComparerR2.CharaSim
{
    public enum GearPropType
    {
        //普通装备属性
        incSTR = 1,
        incSTRr,
        incDEX,
        incDEXr,
        incINT,
        incINTr,
        incLUK,
        incLUKr,
        incAllStat,
        incAllStat_incMHP25,
        incAllStat_incMHP50_incMMP50,
        incMHP_incMMP,
        incMHPr_incMMPr,
        incMHP,
        incMHPr,
        incMMP,
        incMMPr,
        incMDF,
        incARC,
        incAUT,
        incPAD_incMAD,
        incPAD,
        incMAD,
        incAD,
        incPDD_incMDD,
        incPDD,
        incMDD,
        incACC_incEVA,
        incACC,
        incEVA,
        incSpeed,
        incJump,
        incCraft,
        knockback,
        incPVPDamage,
        bdR,
        incBDR,
        imdR,
        incIMDR,
        damR,
        nbdR,
        statR,
        incCHUC,

        //潜能属性
        incPADr = 100,
        incMADr,
        incPDDr,
        incMDDr,
        incACCr,
        incEVAr,
        incCr,
        incCDr,
        incDAMr,
        RecoveryHP,
        RecoveryMP,
        face,
        prop,
        time,
        HP,
        MP,
        attackType,
        ignoreTargetDEF,
        ignoreDAM,
        ignoreDAMr,
        DAMreflect,
        mpconReduce,
        mpRestore,
        incMesoProp,
        incRewardProp,
        incAllskill,
        RecoveryUP,
        boss,
        level,
        incTerR,
        incAsrR,
        incEXPr,
        reduceCooltime,
        incCriticaldamageMax,
        incCriticaldamageMin,
        @sealed,
        incSTRlv,
        incDEXlv,
        incINTlv,
        incLUKlv,
        incMaxDamage,
        incMHPlv,
        incPADlv,
        incMADlv,
        incCriticaldamage,

        Option,
        OptionToMob,
        activeSkill,
        bonusByTime,

        //特殊装备属性
        attackSpeed = 200,
        tuc,
        setItemID,
        durability,
        reqCraft,
        cash,
        royalSpecial,
        masterSpecial,
        reduceReq,

        //技能特有属性
        mastery = 300,
        //criticaldamageMin,
        //criticaldamageMax,
        criticaldamage,
        epad,
        emad,
        epdd,
        emdd,
        emhp,
        emmp,
        smartpad,
        smartacc,
        smarteva,

        //装备特有属性
        reqLevel = 1000,
        reqSTR,
        reqDEX,
        reqINT,
        reqLUK,
        reqJob,
        reqPOP,
        reqSpecJob,
        reqWeekDay, //要求日子
        grade,

        only = 1100,
        //notSale,
        //dropBlock,
        tradeBlock,
        accountSharable,
        onlyEquip,
        tradeAvailable,
        equipTradeBlock,
        sharableOnce,
        notExtend,
        epicItem,
        charismaEXP,
        senseEXP,
        insightEXP,
        willEXP,
        craftEXP,
        charmEXP,
        cashForceCharmExp,
        accountShareTag,
        noPotential,
        fixedPotential,
        timeLimited,
        specialGrade,
        fixedGrade,
        unchangeable,
        superiorEqp,
        incPQEXPr,
        limitBreak,
        nActivatedSocket,
        jokerToSetItem,
        plusToSetItem,
        medalTag,
        ringOptionSkill,
        ringOptionSkillLv,
        abilityTimeLimited,
        blockGoldHammer,
        exceptUpgrade,
        colorvar,
        noMoveToLocker,
        onlyUpgrade,
        cantRepair,
        noPetEquipStatMoveItem,
        BTSLabel,
        BLACKPINKLabel,
        android,
        noLookChange,
        tucIgnoreForPotential,
        Etuc,

        gatherTool_incSkillLevel = 2000,
        gatherTool_incSpeed,
        gatherTool_incNum,
        gatherTool_reqSkillLevel,
    }
}

```

`WzComparerR2.Common/CharaSim/GearSealedInfo.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using WzComparerR2.WzLib;

namespace WzComparerR2.CharaSim
{
    public class GearSealedInfo
    {
        public GearSealedInfo()
        {
            this.BonusProps = new Dictionary<GearPropType, int>();
        }

        public int Level { get; set; }
        public Dictionary<GearPropType, int> BonusProps { get; private set; }
        public int Exp { get; set; }
        public bool HasIcon { get; set; }
        public BitmapOrigin Icon { get; set; }
        public BitmapOrigin IconRaw { get; set; }

        public static GearSealedInfo CreateFromNode(Wz_Node node, GlobalFindNodeFunction findNode)
        {
            GearSealedInfo info = new GearSealedInfo();

            foreach (Wz_Node child in node.Nodes)
            {
                switch (child.Text)
                {
                    case "exp":
                        info.Exp = child.GetValue(0);
                        break;

                    case "icon":
                        info.Icon = BitmapOrigin.CreateFromNode(child, findNode);
                        info.HasIcon = true;
                        break;

                    case "iconRaw":
                        info.IconRaw = BitmapOrigin.CreateFromNode(child, findNode);
                        info.HasIcon = true;
                        break;

                    default:
                        try
                        {
                            GearPropType propType = (GearPropType)Enum.Parse(typeof(GearPropType), child.Text, true);
                            info.BonusProps[propType] = child.GetValue(0);
                        }
                        finally
                        {
                        }
                        break;
                }
            }
            return info;
        }
    }
}

```

`WzComparerR2.Common/CharaSim/GearState.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace WzComparerR2.CharaSim
{
    public enum GearState
    {
        itemList = 0,
        enable = 1,
        disable = 2
    }
}

```

`WzComparerR2.Common/CharaSim/GearType.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace WzComparerR2.CharaSim
{
    public enum GearType
    {
        body = 0,
        head = 1,
        face = 2,
        hair = 3,
        hair2 = 4,
        face2 = 5,
        hair3 = 6,

        /// <summary>
        /// 脸饰 101
        /// </summary>
        faceAccessory = 101,
        /// <summary>
        /// 眼饰 102
        /// </summary>
        eyeAccessory = 102,
        /// <summary>
        /// 耳环 103
        /// </summary>
        earrings = 103,
        /// <summary>
        /// 坠子 112
        /// </summary>
        pendant = 112,
        /// <summary>
        /// 腰带 113
        /// </summary>
        belt = 113,
        /// <summary>
        /// 勋章 114
        /// </summary>
        medal = 114,
        /// <summary>
        /// 肩饰 115
        /// </summary>
        shoulderPad = 115,
        /// <summary>
        /// 头盔 100
        /// </summary>
        cap = 100,
        /// <summary>
        /// 披风 110
        /// </summary>
        cape = 110,
        /// <summary>
        /// 上衣 104
        /// </summary>
        coat = 104,
        /// <summary>
        /// 龙神帽子 194
        /// </summary>
        dragonMask = 194,
        /// <summary>
        /// 龙神吊坠 195
        /// </summary>
        dragonPendant = 195,
        /// <summary>
        /// 龙神翅膀 196
        /// </summary>
        dragonWings = 196,
        /// <summary>
        /// 龙神尾巴 197
        /// </summary>
        dragonTail = 197,
        /// <summary>
        /// 手套 108
        /// </summary>
        glove = 108,
        /// <summary>
        /// 套服 105
        /// </summary>
        longcoat = 105,
        /// <summary>
        /// 机甲引擎 161
        /// </summary>
        machineEngine = 161,
        /// <summary>
        /// 机甲机械臂 162
        /// </summary>
        machineArms = 162,
        /// <summary>
        /// 机甲机械腿 163
        /// </summary>
        machineLegs = 163,
        /// <summary>
        /// 机甲机身材质 164
        /// </summary>
        machineBody = 164,
        /// <summary>
        /// 机甲晶体管 165
        /// </summary>
        machineTransistors = 165,
        /// <summary>
        /// 安卓 166
        /// </summary>
        android = 166,
        /// <summary>
        /// 心脏 167
        /// </summary>
        machineHeart = 167,
        /// <summary>
        /// 口袋物品 116
        /// </summary>
        pocket = 116,
        /// <summary>
        /// 徽章 118
        /// </summary>
        badge = 118,
        /// <summary>
        /// 纹章 119
        /// </summary>
        emblem = 119,
        powerSource = 119020,
        /// <summary>
        /// 裤/裙 106
        /// </summary>
        pants = 106,
        /// <summary>
        /// 戒指 111
        /// </summary>
        ring = 111,
        /// <summary>
        /// 盾牌 109
        /// </summary>
        shield = 109,
        /// <summary>
        /// 灵魂盾 1098xxx
        /// </summary>
        soulShield = 1098,
        /// <summary>
        /// 精气盾 1099xxx
        /// </summary>
        demonShield = 1099,
        /// <summary>
        /// 鞋子 107
        /// </summary>
        shoes = 107,
        /// <summary>
        /// 双头杖 1212
        /// </summary>
        shiningRod = 1212,
        /// <summary>
        /// 调谐器 1213
        /// </summary>
        tuner = 1213,
        /// <summary>
        /// 龙息臂箭 1214
        /// </summary>
        breathShooter = 1214,
        /// <summary>
        /// 灵魂手铳 122
        /// </summary>
        soulShooter = 122,
        /// <summary>
        /// 亡命剑 123
        /// </summary>
        desperado = 123,
        /// <summary>
        /// 能量剑 124
        /// </summary>
        energySword = 124,
        /// <summary>
        /// 驯兽魔法棒 125
        /// </summary>
        magicStick = 125,
        /// <summary>
        /// ESP限制器
        /// </summary>
        espLimiter = 126,
        /// <summary>
        /// 锁链 127
        /// </summary>
        chain2 = 127,
        /// <summary>
        /// 魔力手套 128
        /// </summary>
        magicGauntlet = 128,
        /// <summary>
        /// 扇子 129
        /// </summary>
        handFan = 129,
        /// <summary>
        /// 单手剑 130
        /// </summary>
        ohSword = 130,
        /// <summary>
        /// 单手斧 131
        /// </summary>
        ohAxe = 131,
        /// <summary>
        /// 单手钝器 132
        /// </summary>
        ohBlunt = 132,
        /// <summary>
        /// 短刀 133
        /// </summary>
        dagger = 133,
        /// <summary>
        /// 刀 134
        /// </summary>
        katara = 134,
        /// <summary>
        /// 魔法箭矢 135_00
        /// </summary>
        magicArrow = 135200,
        /// <summary>
        /// 卡片 135_10
        /// </summary>
        card = 135210,
        /// <summary>
        /// 吊坠 135_20
        /// </summary>
        heroMedal = 135220,
        /// <summary>
        /// 念珠 135_21
        /// </summary>
        rosario = 135221,
        /// <summary>
        /// 铁链 135_22
        /// </summary>
        chain = 135222,
        /// <summary>
        /// 魔导书(火毒) 135_23
        /// </summary>
        book1 = 135223,
        /// <summary>
        /// 魔导书(冰雷) 135_24
        /// </summary>
        book2 = 135224,
        /// <summary>
        /// 魔导书(牧师) 135_25
        /// </summary>
        book3 = 135225,
        /// <summary>
        /// 箭羽 135_26
        /// </summary>
        bowMasterFeather = 135226,
        /// <summary>
        /// 扳指 135_27
        /// </summary>
        crossBowThimble = 135227,
        /// <summary>
        /// 短剑剑鞘 135_28
        /// </summary>
        shadowerSheath = 135228,
        /// <summary>
        /// 护身符 135_29
        /// </summary>
        nightLordPoutch = 135229,
        /// <summary>
        /// 宝盒 135_30
        /// </summary>
        box = 135230,
        /// <summary>
        /// 宝珠 135_40
        /// </summary>
        orb = 135240,
        /// <summary>
        /// 龙之精髓 135_50
        /// </summary>
        novaMarrow = 135250,
        /// <summary>
        /// 灵魂戒指 135_60
        /// </summary>
        soulBangle = 135260,
        /// <summary>
        /// 麦林 135_70
        /// </summary>
        mailin = 135270,
        /// <summary>
        /// 小太刀 135_80
        /// </summary>
        kodachi = 135280,
        /// <summary>
        /// 哨子 135_81
        /// </summary>
        whistle = 135281,
        /// <summary>
        /// 拳爪 135_82
        /// </summary>
        boxingClaw = 135282,
        /// <summary>
        /// 小太刀 135_83
        /// </summary>
        kodachi2 = 135283,
        /// <summary>
        /// 哨子 135_84
        /// </summary>
        whistle2 = 135284,
        /// <summary>
        /// 拳天 135_86
        /// </summary>
        boxingSky = 135286,
        /// <summary>
        /// 手腕护带 135_90
        /// </summary>
        viperWristband = 135290,
        /// <summary>
        /// 望远镜 135_91
        /// </summary>
        captainSight = 135291,
        /// <summary>
        /// 火药桶 135_92
        /// </summary>
        cannonGunPowder = 135292,
        /// <summary>
        /// 砝码 135_93
        /// </summary>
        aranPendulum = 135293,
        /// <summary>
        /// 文件 135_94
        /// </summary>
        evanPaper = 135294,
        /// <summary>
        /// 魔法球 135_95
        /// </summary>
        battlemageBall = 135295,
        /// <summary>
        /// 箭轴 135_96
        /// </summary>
        wildHunterArrowHead = 135296,
        /// <summary>
        /// 珠宝 135_97
        /// </summary>
        cygnusGem = 135297,
        /// <summary>
        /// 火药桶 135_98
        /// </summary>
        cannonGunPowder2 = 135298,
        /// <summary>
        /// 控制器 135300
        /// </summary>
        controller = 135300,
        /// <summary>
        /// 狐狸珠 135310
        /// </summary>
        foxPearl = 135310,
        /// <summary>
        /// 棋子 135320
        /// </summary>
        chess = 135320,
        /// <summary>
        /// 武器传送装置 135330
        /// </summary>
        transmitter = 135330,
        /// <summary>
        /// 装弹 135340
        /// </summary>
        ExplosivePill = 135340,
        /// <summary>
        /// 魔力翅膀 135350
        /// </summary>
        magicWing = 135350,
        /// <summary>
        /// 精气珠 135360
        /// </summary>
        pathOfAbyss = 135360,
        /// <summary>
        /// 遗物 135370x
        /// </summary>
        relic = 135370,
        /// <summary>
        /// 扇坠 135380x
        /// </summary>
        fanTassel = 135380,
        /// <summary>
        /// 手链 135400x
        /// </summary>
        bracelet = 135400,
        /// <summary>
        /// 武器腰带 135401x
        /// </summary>
        weaponBelt = 135401,
        /// <summary>
        /// 饰品 135402x
        /// </summary>
        ornament = 135402,
        /// <summary>
        /// 헥스시커 135403x
        /// </summary>
        hexSeeker = 135403,
        /// <summary>
        /// 手杖
        /// </summary>
        cane = 136,
        /// <summary>
        /// 短杖 137
        /// </summary>
        wand = 137,
        /// <summary>
        /// 长杖 138
        /// </summary>
        staff = 138,
        /// <summary>
        /// 空手 139
        /// </summary>
        barehand = 139,
        /// <summary>
        /// 双手剑 140
        /// </summary>
        thSword = 140,
        /// <summary>
        /// 拳封 140_3xxx
        /// </summary>
        boxingCannon = 1403,
        /// <summary>
        /// 차크람 140_4xxx
        /// </summary>
        chakram = 1404,
        /// <summary>
        /// 双手斧 141
        /// </summary>
        thAxe = 141,
        /// <summary>
        /// 双手钝器 142
        /// </summary>
        thBlunt = 142,
        /// <summary>
        /// 枪 143
        /// </summary>
        spear = 143,
        /// <summary>
        /// 矛 144
        /// </summary>
        polearm = 144,
        /// <summary>
        /// 弓 145
        /// </summary>
        bow = 145,
        /// <summary>
        /// 弩 146
        /// </summary>
        crossbow = 146,
        /// <summary>
        /// 拳套 147
        /// </summary>
        throwingGlove = 147,
        /// <summary>
        /// 指节 148
        /// </summary>
        knuckle = 148,
        /// <summary>
        /// 短枪 149
        /// </summary>
        gun = 149,
        /// <summary>
        /// 采药工具 150
        /// </summary>
        shovel = 150,
        /// <summary>
        /// 采矿工具 151
        /// </summary>
        pickaxe = 151,
        /// <summary>
        /// 双弓 152
        /// </summary>
        dualBow = 152,
        /// <summary>
        /// 手持火炮 153
        /// </summary>
        handCannon = 153,
        /// <summary>
        /// 太刀 154
        /// </summary>
        katana = 154,
        /// <summary>
        /// 扇 155
        /// </summary>
        fan = 155,

        /// <summary>
        /// 大剑 156
        /// </summary>
        swordZB = 156,
        /// <summary>
        /// 太刀 157
        /// </summary>
        swordZL = 157,
        /// <summary>
        /// 机甲手枪 158
        /// </summary>
        GauntletBuster = 158,
        /// <summary>
        /// 远古弓 159
        /// </summary>
        ancientBow = 159,
        /// <summary>
        /// 拼图 168
        /// </summary>
        bit = 168,
        /// <summary>
        /// 点装武器 170
        /// </summary>
        cashWeapon = 170,
        /// <summary>
        /// 武器 -1
        /// </summary>
        weapon = -1,
        /// <summary>
        /// 武器 -1
        /// </summary>
        subWeapon = -2,
        /// <summary>
        /// 图腾 120
        /// </summary>
        totem = 120,
        /// <summary>
        /// 宠物装备 180
        /// </summary>
        petEquip = 180,
        /// <summary>
        /// 骑兽 190
        /// </summary>
        taming = 190,
        /// <summary>
        /// 鞍子 191
        /// </summary>
        saddle = 191,
        /// <summary>
        /// 骑兽 193
        /// </summary>
        taming2 = 193,
        /// <summary>
        /// 椅子用骑兽 198
        /// </summary>
        tamingChair = 198,
        /// <summary>
        /// 骑兽 199
        /// </summary>
        taming3 = 199
    }
}
```

`WzComparerR2.Common/CharaSim/HyperSkillType.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace WzComparerR2.CharaSim
{
    public enum HyperSkillType
    {
        None = 0,
        S = 1,
        P = 2,
        A = 3
    }
}

```

`WzComparerR2.Common/CharaSim/Item.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using WzComparerR2.WzLib;

namespace WzComparerR2.CharaSim
{
    public class Item : ItemBase
    {
        public Item()
        {
            this.Props = new Dictionary<ItemPropType, int>();
            this.Specs = new Dictionary<ItemSpecType, int>();
            this.CoreSpecs = new Dictionary<ItemCoreSpecType, Wz_Node>();
            this.AddTooltips = new List<int>();
        }

        public int Level { get; set; }
        public string ConsumableFrom { get; set; }
        public string EndUseDate { get; set; }
        public string SamplePath { get; set; }

        public List<GearLevelInfo> Levels { get; internal set; }

        public Dictionary<ItemPropType, int> Props { get; private set; }
        public Dictionary<ItemSpecType, int> Specs { get; private set; }
        public Dictionary<ItemCoreSpecType, Wz_Node> CoreSpecs { get; private set; }
        public List<int> AddTooltips { get; internal set; } // Additional Tooltips

        public bool Cash
        {
            get { return GetBooleanValue(ItemPropType.cash); }
        }

        public bool TimeLimited
        {
            get { return GetBooleanValue(ItemPropType.timeLimited); }
        }

        public bool GetBooleanValue(ItemPropType type)
        {
            int value;
            return this.Props.TryGetValue(type, out value) && value != 0;
        }

        public static Item CreateFromNode(Wz_Node node, GlobalFindNodeFunction findNode)
        {
            Item item = new Item();
            int value;
            if (node == null
                || !Int32.TryParse(node.Text, out value)
                && !((value = node.Text.IndexOf(".img")) > -1 && Int32.TryParse(node.Text.Substring(0, value), out value)))
            {
                return null;
            }
            item.ItemID = value;

            Wz_Node infoNode = node.FindNodeByPath("info");
            if (infoNode != null)
            {
                Wz_Node pngNode;
                foreach (Wz_Node subNode in infoNode.Nodes)
                {
                    switch (subNode.Text)
                    {
                        case "icon":
                            pngNode = subNode;
                            while (pngNode.Value is Wz_Uol)
                            {
                                Wz_Uol uol = pngNode.Value as Wz_Uol;
                                Wz_Node uolNode = uol.HandleUol(subNode);
                                if (uolNode != null)
                                {
                                    pngNode = uolNode;
                                }
                            }
                            if (pngNode.Value is Wz_Png)
                            {
                                item.Icon = BitmapOrigin.CreateFromNode(pngNode, findNode);
                            }
                            break;

                        case "iconRaw":
                            pngNode = subNode;
                            while (pngNode.Value is Wz_Uol)
                            {
                                Wz_Uol uol = pngNode.Value as Wz_Uol;
                                Wz_Node uolNode = uol.HandleUol(subNode);
                                if (uolNode != null)
                                {
                                    pngNode = uolNode;
                                }
                            }
                            if (pngNode.Value is Wz_Png)
                            {
                                item.IconRaw = BitmapOrigin.CreateFromNode(pngNode, findNode);
                            }
                            break;

                        case "sample":
                            if (subNode.Value is Wz_Png)
                            {
                                item.Sample = BitmapOrigin.CreateFromNode(subNode, findNode);
                            }
                            break;

                        case "lv":
                            item.Level = Convert.ToInt32(subNode.Value);
                            break;

                        case "consumableFrom":
                            item.ConsumableFrom = Convert.ToString(subNode.Value);
                            break;

                        case "endUseDate":
                            item.EndUseDate = Convert.ToString(subNode.Value);
                            break;

                        case "samplePath":
                            item.SamplePath = Convert.ToString(subNode.Value);
                            break;

                        case "exp":
                            foreach (Wz_Node subNode2 in subNode.Nodes)
                            {
                                ItemPropType type2;
                                if (Enum.TryParse("exp_" + subNode2.Text, out type2))
                                {
                                    try
                                    {
                                        item.Props.Add(type2, Convert.ToInt32(subNode2.Value));
                                    }
                                    finally
                                    {
                                    }
                                }
                            }
                            break;

                        case "level": //可升级信息
                            Wz_Node levelInfo = subNode.Nodes["info"];
                            item.Levels = new List<GearLevelInfo>();
                            if (levelInfo != null)
                            {
                                for (int i = 1; ; i++)
                                {
                                    Wz_Node levelInfoNode = levelInfo.Nodes[i.ToString()];
                                    if (levelInfoNode != null)
                                    {
                                        GearLevelInfo info = GearLevelInfo.CreateFromNode(levelInfoNode);
                                        int lv;
                                        Int32.TryParse(levelInfoNode.Text, out lv);
                                        info.Level = lv;
                                        item.Levels.Add(info);
                                    }
                                    else
                                    {
                                        break;
                                    }
                                }
                            }

                            Wz_Node levelCase = subNode.Nodes["case"];
                            if (levelCase != null)
                            {
                                int probTotal = 0;
                                foreach (Wz_Node caseNode in levelCase.Nodes)
                                {
                                    int prob = caseNode.Nodes["prob"].GetValueEx(0);
                                    probTotal += prob;
                                    for (int i = 0; i < item.Levels.Count; i++)
                                    {
                                        GearLevelInfo info = item.Levels[i];
                                        Wz_Node caseLevel = caseNode.Nodes[info.Level.ToString()];
                                        if (caseLevel != null)
                                        {
                                            //desc
                                            Wz_Node caseHS = caseLevel.Nodes["hs"];
                                            if (caseHS != null)
                                            {
                                                info.HS = caseHS.GetValue<string>();
                                            }

                                            //随机技能
                                            Wz_Node caseSkill = caseLevel.Nodes["Skill"];
                                            if (caseSkill != null)
                                            {
                                                foreach (Wz_Node skillNode in caseSkill.Nodes)
                                                {
                                                    int id = skillNode.Nodes["id"].GetValueEx(-1);
                                                    int level = skillNode.Nodes["level"].GetValueEx(-1);
                                                    if (id >= 0 && level >= 0)
                                                    {
                                                        info.Skills[id] = level;
                                                    }
                                                }
                                            }

                                            //装备技能
                                            Wz_Node equipSkill = caseLevel.Nodes["EquipmentSkill"];
                                            if (equipSkill != null)
                                            {
                                                foreach (Wz_Node skillNode in equipSkill.Nodes)
                                                {
                                                    int id = skillNode.Nodes["id"].GetValueEx(-1);
                                                    int level = skillNode.Nodes["level"].GetValueEx(-1);
                                                    if (id >= 0 && level >= 0)
                                                    {
                                                        info.EquipmentSkills[id] = level;
                                                    }
                                                }
                                            }
                                            info.Prob = prob;
                                        }
                                    }
                                }

                                foreach (var info in item.Levels)
                                {
                                    info.ProbTotal = probTotal;
                                }
                            }
                            item.Props.Add(ItemPropType.level, 1);
                            break;

                        case "addTooltip":
                            if (subNode.Nodes.Count > 0)
                            {
                                foreach (Wz_Node tooltipNode in subNode.Nodes)
                                {
                                    item.AddTooltips.Add(Convert.ToInt32(tooltipNode.Value));
                                }
                            }
                            else
                            {
                                item.AddTooltips.Add(Convert.ToInt32(subNode.Value));
                            }
                            break;

                        default:
                            ItemPropType type;
                            if (Enum.TryParse(subNode.Text, out type))
                            {
                                try
                                {
                                    item.Props.Add(type, Convert.ToInt32(subNode.Value));
                                }
                                catch (Exception)
                                {
                                }
                            }
                            break;
                    }
                }
            }

            Wz_Node specNode = node.FindNodeByPath("spec");
            if (specNode != null)
            {
                foreach (Wz_Node subNode in specNode.Nodes)
                {
                    ItemSpecType type;
                    if (Enum.TryParse(subNode.Text, out type))
                    {
                        try
                        {
                            item.Specs.Add(type, Convert.ToInt32(subNode.Value));
                        }
                        finally
                        {
                        }
                    }
                }
            }

            Wz_Node coreSpecNode = node.FindNodeByPath("corespec");
            if (coreSpecNode != null)
            {
                item.Props.Remove(ItemPropType.tradeBlock);
                foreach (Wz_Node subNode in coreSpecNode.Nodes)
                {
                    ItemCoreSpecType type;
                    if (Enum.TryParse(subNode.Text, out type))
                    {
                        item.CoreSpecs.Add(type, subNode);
                    }
                }
                if (item.CoreSpecs.ContainsKey(ItemCoreSpecType.Ctrl_addMission))
                {
                    List<ItemCoreSpecType> removeSpecs = item.CoreSpecs.Keys.Where(k => k != ItemCoreSpecType.Ctrl_addMission).ToList();
                    foreach (ItemCoreSpecType type in removeSpecs)
                    {
                        item.CoreSpecs.Remove(type);
                    }
                }
            }
            return item;
        }

    }
}

```

`WzComparerR2.Common/CharaSim/ItemBase.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace WzComparerR2.CharaSim
{
    public abstract class ItemBase : ICloneable
    {
        public ItemBase()
        {
        }

        public int ItemID { get; set; }
        public BitmapOrigin Icon { get; set; }
        public BitmapOrigin IconRaw { get; set; }
        public BitmapOrigin Sample { get; set; }

        public virtual ItemBaseType Type
        {
            get { return (ItemBaseType)(this.ItemID / 1000000); }
        }

        public virtual object Clone()
        {
            return this.MemberwiseClone();
        }
    }
}

```

`WzComparerR2.Common/CharaSim/ItemBaseType.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace WzComparerR2.CharaSim
{
    public enum ItemBaseType
    {
        Unknown = 0,
        Equip = 1,
        Consume = 2,
        Install = 3,
        Etc = 4,
        Cash = 5
    }
}

```

`WzComparerR2.Common/CharaSim/ItemCoreSpecType.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace WzComparerR2.CharaSim
{
    public enum ItemCoreSpecType
    {
        Ctrl_mobLv,
        Ctrl_mobHPRate,
        Ctrl_mobRate,
        Ctrl_mobRateSpecial,
        Ctrl_change_Mob,
        Ctrl_change_BGM,
        Ctrl_change_BackGrnd,
        Ctrl_partyExp,
        Ctrl_partyExpSpecial,
        Ctrl_addMob,
        Ctrl_dropRate,
        Ctrl_dropRateSpecial,
        Ctrl_dropRate_Herb,
        Ctrl_dropRate_Mineral,
        Ctrl_dropRareEquip,
        Ctrl_reward,
        Ctrl_addMission,
    }
}

```

`WzComparerR2.Common/CharaSim/ItemPropType.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace WzComparerR2.CharaSim
{
    public enum ItemPropType
    {
        price = 1,
        lv,
        reqLevel,
        cash,
        quest,
        pquest,
        tradeBlock,
        notSale,
        only,
        tradeAvailable,
        accountSharable,
        exchangeableOnce,
        timeLimited,
        setItemID,
        charismaEXP,
        senseEXP,
        insightEXP,
        willEXP,
        craftEXP,
        charmEXP,
        nickTag,
        wonderGrade,
        life,
        permanent,
        multiPet,
        limitedLife,
        flatRate,
        noMoveToLocker,
        exp_minLev,
        exp_maxLev,
        dressUpgrade,
        onlyCash,
        noScroll,
        noRevive,
        pickupItem,
        longRange,
        sweepForDrop,
        pickupAll,
        consumeHP,
        consumeMP,
        autoBuff,
        giantPet,
        consumeCure,
        useTradeBlock,
        level,
        sharableOnce,
        BTSLabel,
        BLACKPINKLabel,
        addTooltip_tuc,
        addTooltip_tucCnt,
        pointCost,
        tamingMob,
    }
}

```

`WzComparerR2.Common/CharaSim/ItemSpecType.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace WzComparerR2.CharaSim
{
    public enum ItemSpecType
    {
        recipe = 100,
        reqSkill,
        reqSkillLevel,
        reqSkillProficiency,
        recipeValidDay,
        recipeUseCount,
    }
}

```

`WzComparerR2.Common/CharaSim/ItemStringHelper.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace WzComparerR2.CharaSim
{
    public static class ItemStringHelper
    {
        /// <summary>
        /// 获取怪物category属性对应的类型说明。
        /// </summary>
        /// <param Name="category">怪物的category属性的值。</param>
        /// <returns></returns>
        public static string GetMobCategoryName(int category)
        {
            switch (category)
            {
                case 0: return "No type";
                case 1: return "Mammal type";
                case 2: return "Plant type";
                case 3: return "Fish type";
                case 4: return "Reptile type";
                case 5: return "Spirit type";
                case 6: return "Devil type";
                case 7: return "Undead type";
                case 8: return "Enchanted type";
                default: return null;
            }
        }

        public static string GetGearPropString(GearPropType propType, int value)
        {
            return GetGearPropString(propType, value, 0);
        }

        /// <summary>
        /// 获取GearPropType所对应的文字说明。
        /// </summary>
        /// <param Name="propType">表示装备属性枚举GearPropType。</param>
        /// <param Name="Value">表示propType属性所对应的值。</param>
        /// <returns></returns>
        public static string GetGearPropString(GearPropType propType, int value, int signFlag)
        {

            string sign;
            switch (signFlag)
            {
                default:
                case 0: //默认处理符号
                    sign = value > 0 ? "+" : null;
                    break;

                case 1: //固定加号
                    sign = "+";
                    break;

                case 2: //无特别符号
                    sign = "";
                    break;
            }
            switch (propType)
            {
                case GearPropType.incSTR: return "STR : " + sign + value;
                case GearPropType.incSTRr: return "STR : " + sign + value + "%";
                case GearPropType.incDEX: return "DEX : " + sign + value;
                case GearPropType.incDEXr: return "DEX : " + sign + value + "%";
                case GearPropType.incINT: return "INT : " + sign + value;
                case GearPropType.incINTr: return "INT : " + sign + value + "%";
                case GearPropType.incLUK: return "LUK : " + sign + value;
                case GearPropType.incLUKr: return "LUK : " + sign + value + "%";
                case GearPropType.incAllStat: return "All Stats: " + sign + value;
                case GearPropType.statR: return "All Stats: " + sign + value + "%";
                case GearPropType.incMHP: return "MaxHP : " + sign + value;
                case GearPropType.incMHPr: return "MaxHP : " + sign + value + "%";
                case GearPropType.incMMP: return "MaxMP : " + sign + value;
                case GearPropType.incMMPr: return "MaxMP : " + sign + value + "%";
                case GearPropType.incMDF: return "MaxDF : " + sign + value;
                case GearPropType.incPAD: return "Attack Power: " + sign + value;
                case GearPropType.incPADr: return "Attack Power: " + sign + value + "%";
                case GearPropType.incMAD: return "Magic Attack: " + sign + value;
                case GearPropType.incMADr: return "Magic Attack: " + sign + value + "%";
                case GearPropType.incPDD: return "Defense: " + sign + value;
                case GearPropType.incPDDr: return "Defense: " + sign + value + "%";
                //case GearPropType.incMDD: return "MAGIC DEF. : " + sign + value;
                //case GearPropType.incMDDr: return "MAGIC DEF. : " + sign + value + "%";
                //case GearPropType.incACC: return "ACCURACY : " + sign + value;
                //case GearPropType.incACCr: return "ACCURACY : " + sign + value + "%";
                //case GearPropType.incEVA: return "AVOIDABILITY : " + sign + value;
                //case GearPropType.incEVAr: return "AVOIDABILITY : " + sign + value + "%";
                case GearPropType.incSpeed: return "Speed: " + sign + value;
                case GearPropType.incJump: return "Jump: " + sign + value;
                case GearPropType.incCraft: return "Diligence: " + sign + value;
                case GearPropType.damR:
                case GearPropType.incDAMr: return "Damage: " + sign + value + "%";
                case GearPropType.incCr: return "Critical Rate: " + sign + value + "%";
                case GearPropType.incCDr: return "Critical Damage: " + sign + value + "%";
                case GearPropType.knockback: return "Knockback Chance: " + value + "%";
                //case GearPropType.incPVPDamage: return "Battle Mode ATT " + sign + " " + value;
                case GearPropType.incPQEXPr: return "Party Quest EXP: +" + value + "%";
                case GearPropType.incEXPr: return "Party EXP: +" + value + "%";
                case GearPropType.incBDR:
                case GearPropType.bdR: return "Boss Damage: +" + value + "%";
                case GearPropType.incIMDR:
                case GearPropType.imdR: return "Ignored Enemy DEF: +" + value + "%";
                case GearPropType.limitBreak: return "Damage Cap: " + value;
                case GearPropType.reduceReq: return "Required Level: -" + value;
                case GearPropType.nbdR: return "Damage Against Normal Monsters: +" + value + "%"; //KMST 1069

                case GearPropType.only: return value == 0 ? null : "One-of-a-kind Item";
                case GearPropType.tradeBlock: return value == 0 ? null : "Untradable";
                case GearPropType.equipTradeBlock: return value == 0 ? null : "Cannot be Traded when equipped";
                case GearPropType.accountSharable: return value == 0 ? null : "Account-bound. Transferable within world."; //v218 Transferable within world
                case GearPropType.sharableOnce: return value == 0 ? null : "Tradable once within the same world.\n(Cannot be traded after transfer)"; //old "Can be traded once within account"
                case GearPropType.onlyEquip: return value == 0 ? null : "Unique Equipped Item";
                case GearPropType.notExtend: return value == 0 ? null : "Duration cannot be extended.";
                case GearPropType.tradeAvailable:
                    switch (value)
                    {
                        case 1: return "#cUse the Scissors of Karma to enable this item to be traded one time.#";
                        case 2: return "#cUse the Platinum Scissors of Karma to\n\renable this item to be traded one time.#";
                        default: return null;
                    }
                case GearPropType.accountShareTag:
                    switch (value)
                    {
                        case 1: return "#cUse the Sharing Tag to move an item to another character on the same account once.#";
                        default: return null;
                    }
                //case GearPropType.noPotential: return value == 0 ? null : "This item cannot gain Potential.";
                case GearPropType.fixedPotential: return value == 0 ? null : "Potential Reset Not Allowed";
                case GearPropType.superiorEqp: return value == 0 ? null : "Allows you to gain even higher stats with successful item enhancement.";
                case GearPropType.nActivatedSocket: return value == 0 ? null : "#cYou can mount a Nebulite on this item#";
                case GearPropType.jokerToSetItem: return value == 0 ? null : "\n#cThis lucky item counts towards any set,\n\rso long as you have at least 3 set pieces equipped!#";//\n\r#cThis lucky...
                case GearPropType.plusToSetItem: return value == 0 ? null : "#cWhen equipped, the item set will count as having equipped two.#";
                case GearPropType.abilityTimeLimited: return value == 0 ? null : "Limited Time Stats";
                case GearPropType.blockGoldHammer: return value == 0 ? null : "Golden Hammer cannot be used.";
                case GearPropType.colorvar: return value == 0 ? null : "#cThis item can be dyed using a Dye.#";
                case GearPropType.cantRepair: return value == 0 ? null : "Cannot be repaired";
                case GearPropType.noLookChange: return value == 0 ? null : "Cannot use Fusion Anvil";

                case GearPropType.incAllStat_incMHP25: return "All Stats: " + sign + value + ", MaxHP : " + sign + (value * 25);// check once Lv 250 set comes out in GMS
                case GearPropType.incAllStat_incMHP50_incMMP50: return "All Stats: " + sign + value + ", MaxHP / MaxMP : " + sign + (value * 50);
                case GearPropType.incMHP_incMMP: return "MaxHP / MaxMP: " + sign + value;
                case GearPropType.incMHPr_incMMPr: return "MaxHP / MaxMP: " + sign + value + "%";
                case GearPropType.incPAD_incMAD:
                case GearPropType.incAD: return "Attack Power && Magic ATT: " + sign + value;
                case GearPropType.incPDD_incMDD: return "Defense: " + sign + value;
                //case GearPropType.incACC_incEVA: return "ACC/AVO :" + sign + value;

                case GearPropType.incARC: return "ARC : " + sign + value;
                case GearPropType.incAUT: return "SAC : " + sign + value;
                default: return null;
            }
        }


        public static string GetGearPropDiffString(GearPropType propType, int value, int standardValue)
        {
            var propStr = GetGearPropString(propType, value);
            if (value > standardValue)
            {
                string subfix = null;
                switch (propType)
                {
                    case GearPropType.incSTR:
                    case GearPropType.incDEX:
                    case GearPropType.incINT:
                    case GearPropType.incLUK:
                    case GearPropType.incMHP:
                    case GearPropType.incMMP:
                    case GearPropType.incMDF:
                    case GearPropType.incARC:
                    case GearPropType.incAUT:
                    case GearPropType.incPAD:
                    case GearPropType.incMAD:
                    case GearPropType.incPDD:
                    case GearPropType.incMDD:
                    case GearPropType.incSpeed:
                    case GearPropType.incJump:
                        subfix = $"({standardValue} #$+{value - standardValue}#)"; break;

                    case GearPropType.bdR:
                    case GearPropType.incBDR:
                    case GearPropType.imdR:
                    case GearPropType.incIMDR:
                    case GearPropType.damR:
                    case GearPropType.incDAMr:
                    case GearPropType.statR:
                        subfix = $"({standardValue}% #$+{value - standardValue}%#)"; break;
                }
                propStr = "#$" + propStr + "# " + subfix;
            }
            return propStr;
        }

        /// <summary>
        /// 获取gearGrade所对应的字符串。
        /// </summary>
        /// <param Name="rank">表示装备的潜能等级GearGrade。</param>
        /// <returns></returns>
        public static string GetGearGradeString(GearGrade rank)
        {
            switch (rank)
            {
                //case GearGrade.C: return "C级(一般物品)";
                case GearGrade.B: return "(Rare Item)";
                case GearGrade.A: return "(Epic Item)";
                case GearGrade.S: return "(Unique Item)";
                case GearGrade.SS: return "(Legendary Item)";
                case GearGrade.Special: return "(Special Item)";
                default: return null;
            }
        }

        /// <summary>
        /// 获取gearType所对应的字符串。
        /// </summary>
        /// <param Name="Type">表示装备类型GearType。</param>
        /// <returns></returns>
        public static string GetGearTypeString(GearType type)
        {
            switch (type)
            {
                //case GearType.body: return "Avatar (Body)";
                case GearType.head: return "Avatar (Head)";
                case GearType.face:
                case GearType.face2: return "Face";
                case GearType.hair:
                case GearType.hair2:
                case GearType.hair3: return "Hair";
                case GearType.faceAccessory: return "FACE ACCESSORY";
                case GearType.eyeAccessory: return "EYE ACCESSORY";
                case GearType.earrings: return "EARRINGS";
                case GearType.pendant: return "PENDANT";
                case GearType.belt: return "BELT";
                case GearType.medal: return "MEDAL";
                case GearType.shoulderPad: return "SHOULDER";
                case GearType.cap: return "Hat";
                case GearType.cape: return "Cape";
                case GearType.coat: return "Top";
                case GearType.dragonMask: return "Dragon Hat";
                case GearType.dragonPendant: return "Dragon Pendant";
                case GearType.dragonWings: return "Dragon Wing Accessory";
                case GearType.dragonTail: return "Dragon Tail Accessory";
                case GearType.glove: return "GLOVES";
                case GearType.longcoat: return "Outfit";
                case GearType.machineEngine: return "Mechanic Engine";
                case GearType.machineArms: return "Mechanic Arm";
                case GearType.machineLegs: return "Mechanic Leg";
                case GearType.machineBody: return "Mechanic Frame";
                case GearType.machineTransistors: return "Mechanic Transistor";
                case GearType.pants: return "Bottom";
                case GearType.ring: return "RING";
                case GearType.shield: return "Shield";
                case GearType.shoes: return "Shoes";
                case GearType.shiningRod: return "Shining Rod";
                case GearType.soulShooter: return "Soul Shooter";
                case GearType.ohSword: return "One-handed Sword";
                case GearType.ohAxe: return "One-handed Axe";
                case GearType.ohBlunt: return "One-handed Blunt Weapon";
                case GearType.dagger: return "Dagger";
                case GearType.katara: return "Katara";
                case GearType.magicArrow: return "Magic Arrow";
                case GearType.card: return "Card";
                case GearType.box: return "Core";
                case GearType.orb: return "Orb";
                case GearType.novaMarrow: return "Dragon Essence";
                case GearType.soulBangle: return "Soul Ring";
                case GearType.mailin: return "Magnum";
                case GearType.cane: return "Cane";
                case GearType.wand: return "Wand";
                case GearType.staff: return "Staff";
                case GearType.thSword: return "Two-handed Sword";
                case GearType.thAxe: return "Two-handed Axe";
                case GearType.thBlunt: return "Two-handed Blunt Weapon";
                case GearType.spear: return "Spear";
                case GearType.polearm: return "Polearm";
                case GearType.bow: return "Bow";
                case GearType.crossbow: return "Crossbow";
                case GearType.throwingGlove: return "Claw";
                case GearType.knuckle: return "Knuckle";
                case GearType.gun: return "Gun";
                case GearType.android: return "ANDROID";
                case GearType.machineHeart: return "MECHANICAL HEART";
                case GearType.pickaxe: return "Mining Tool";
                case GearType.shovel: return "Herbalism Tool";
                case GearType.pocket: return "POCKET ITEM";
                case GearType.dualBow: return "Dual Bowguns";
                case GearType.handCannon: return "Hand Cannon";
                case GearType.badge: return "BADGE";
                case GearType.emblem: return "EMBLEM";
                case GearType.soulShield: return "Soul Shield";
                case GearType.demonShield: return "Demon Aegis";
                //case GearType.totem: return "Totem";
                case GearType.petEquip: return "Pet Equipment";
                case GearType.taming:
                case GearType.taming2:
                case GearType.taming3: 
                case GearType.tamingChair: return "TAMED MONSTER";
                case GearType.saddle: return "Saddle";
                case GearType.katana: return "Katana";
                case GearType.fan: return "Fan";
                case GearType.swordZB: return "Heavy Sword";
                case GearType.swordZL: return "Long Sword";
                case GearType.weapon: return "Weapon";
                case GearType.subWeapon: return "Secondary Weapon";
                case GearType.heroMedal: return "Medallions";
                case GearType.rosario: return "Rosary";
                case GearType.chain: return "Iron Chain";
                case GearType.book1:
                case GearType.book2:
                case GearType.book3: return "Magic Book";
                case GearType.bowMasterFeather: return "Arrow Fletching";
                case GearType.crossBowThimble: return "Bow Thimble";
                case GearType.shadowerSheath: return "Dagger Scabbard";
                case GearType.nightLordPoutch: return "Charm";
                case GearType.viperWristband: return "Wrist Band";
                case GearType.captainSight: return "Far Sight";
                case GearType.cannonGunPowder:
                case GearType.cannonGunPowder2: return "Powder Keg";
                case GearType.aranPendulum: return "Mass";
                case GearType.evanPaper: return "Document";
                case GearType.battlemageBall: return "Magic Marble";
                case GearType.wildHunterArrowHead: return "Arrowhead";
                case GearType.cygnusGem: return "Jewel";
                case GearType.controller: return "Controller";
                case GearType.foxPearl: return "Fox Marble";
                case GearType.chess: return "Chess Piece";
                case GearType.powerSource: return "Power Source";

                case GearType.energySword: return "Whip Blade";
                case GearType.desperado: return "Desperado";
                case GearType.magicStick: return "Beast Tamer Scepter";
                case GearType.whistle:
                case GearType.whistle2: return "Whistle";
                case GearType.boxingClaw: return "Fist";
                case GearType.kodachi:
                case GearType.kodachi2: return "Kodachi";
                case GearType.espLimiter: return "Psy-limiter";

                case GearType.GauntletBuster: return "Arm Cannon";
                case GearType.ExplosivePill: return "Charge";

                case GearType.chain2: return "Chain";
                case GearType.magicGauntlet: return "Lucent Gauntlet";
                case GearType.transmitter: return "Warp Forge";
                case GearType.magicWing: return "Lucent Wings";
                case GearType.pathOfAbyss: return "Abyssal Path";

                case GearType.relic: return "Relic";
                case GearType.ancientBow: return "Ancient Bow";

                case GearType.handFan: return "Ritual Fan";
                case GearType.fanTassel: return "Fan Tassel";

                case GearType.tuner: return "Bladecaster";
                case GearType.bracelet: return "Bladebinder";

                case GearType.breathShooter: return "Whispershot";
                case GearType.weaponBelt: return "Weapon Belt";

                case GearType.ornament: return "Ornament";

                case GearType.chakram: return "Chakram";
                case GearType.hexSeeker: return "Hex Seeker";

                case GearType.boxingCannon: return "拳封";//Mo Xuan weapon
                case GearType.boxingSky: return "拳天";//Mo Xuan weapon
                default: return null;
            }
        }

        /// <summary>
        /// 获取武器攻击速度所对应的字符串。
        /// </summary>
        /// <param Name="attackSpeed">表示武器的攻击速度，通常为2~9的数字。</param>
        /// <returns></returns>
        public static string GetAttackSpeedString(int attackSpeed)
        {
            string str;
            switch (attackSpeed)
            {
                case 2:
                case 3: str = "Very Fast"; break;
                case 4:
                case 5: str = "Fast"; break;
                case 6: str = "Normal"; break;
                case 7:
                case 8: str = "Slow"; break;
                case 9: str = "Very Slow"; break;
                default:
                    if (attackSpeed < 2) return "吃屎一样快";
                    else if (attackSpeed > 9) return "吃屎一样慢";
                    else return attackSpeed.ToString();
            }
            return str + " (Stage " + (10 - attackSpeed) + ")";
        }

        /// <summary>
        /// 获取套装装备类型的字符串。
        /// </summary>
        /// <param Name="Type">表示套装装备类型的GearType。</param>
        /// <returns></returns>
        public static string GetSetItemGearTypeString(GearType type)
        {
            return GetGearTypeString(type);
        }

        /// <summary>
        /// 获取装备额外职业要求说明的字符串。
        /// </summary>
        /// <param Name="Type">表示装备类型的GearType。</param>
        /// <returns></returns>
        public static string GetExtraJobReqString(GearType type)
        {
            switch (type)
            {
                //0xxx
                case GearType.heroMedal: return "Hero only";
                case GearType.rosario: return "Paladin only";
                case GearType.chain: return "Dark Knight only";
                case GearType.book1: return "Fire/Poison Magician only";
                case GearType.book2: return "Ice/Lightning Magician only";
                case GearType.book3: return "Bishop Magician only";
                case GearType.bowMasterFeather: return "Bow Master only";
                case GearType.crossBowThimble: return "Marksman only";
                case GearType.relic: return "Pathfinder only";
                case GearType.shadowerSheath: return "Shadower only";
                case GearType.nightLordPoutch: return "Night Lord only";
                case GearType.katara: return "Dual Blade only";
                case GearType.viperWristband: return "Buccaneer only";
                case GearType.captainSight: return "Corsair only";
                case GearType.cannonGunPowder:
                case GearType.cannonGunPowder2: return "Cannoneer only";
                case GearType.box:
                case GearType.boxingClaw: return "Jett only";

                //1xxx
                case GearType.cygnusGem: return "Cygnus Knights only";

                //2xxx
                case GearType.aranPendulum: return GetExtraJobReqString(21);
                case GearType.dragonMask:
                case GearType.dragonPendant:
                case GearType.dragonWings:
                case GearType.dragonTail:
                case GearType.evanPaper: return GetExtraJobReqString(22);
                case GearType.magicArrow: return GetExtraJobReqString(23);
                case GearType.card: return GetExtraJobReqString(24);
                case GearType.foxPearl: return GetExtraJobReqString(25);
                case GearType.orb:
                case GearType.shiningRod: return GetExtraJobReqString(27);

                //3xxx
                case GearType.demonShield: return GetExtraJobReqString(31);
                case GearType.desperado: return "Demon Avenger only";
                case GearType.battlemageBall: return "Battle Mage only";
                case GearType.wildHunterArrowHead: return "Wild Hunter only";
                case GearType.machineEngine:
                case GearType.machineArms:
                case GearType.machineLegs:
                case GearType.machineBody:
                case GearType.machineTransistors:
                case GearType.mailin: return "Mechanic only";
                case GearType.controller:
                case GearType.powerSource:
                case GearType.energySword: return GetExtraJobReqString(36);
                case GearType.GauntletBuster:
                case GearType.ExplosivePill: return GetExtraJobReqString(37);

                //4xxx
                case GearType.katana:
                case GearType.kodachi:
                case GearType.kodachi2: return GetExtraJobReqString(41);
                case GearType.fan: return "Kanna only"; //Haku only?

                //5xxx
                case GearType.soulShield: return "Mihile only";

                //6xxx
                case GearType.novaMarrow: return GetExtraJobReqString(61);
                case GearType.weaponBelt:
                case GearType.breathShooter: return GetExtraJobReqString(63);
                case GearType.chain2:
                case GearType.transmitter: return GetExtraJobReqString(64);
                case GearType.soulBangle:
                case GearType.soulShooter: return GetExtraJobReqString(65);

                //10xxx
                case GearType.swordZB:
                case GearType.swordZL: return GetExtraJobReqString(101);

                case GearType.whistle:
                case GearType.magicStick: return GetExtraJobReqString(112);

                case GearType.espLimiter:
                case GearType.chess: return GetExtraJobReqString(142);

                case GearType.magicGauntlet:
                case GearType.magicWing: return GetExtraJobReqString(152);

                case GearType.pathOfAbyss: return GetExtraJobReqString(155);
                case GearType.handFan:
                case GearType.fanTassel: return GetExtraJobReqString(164);

                case GearType.tuner:
                case GearType.bracelet: return GetExtraJobReqString(151);

                case GearType.boxingCannon:
                case GearType.boxingSky: return GetExtraJobReqString(175);

                case GearType.ornament: return GetExtraJobReqString(162);
                default: return null;
            }
        }

        /// <summary>
        /// 获取装备额外职业要求说明的字符串。
        /// </summary>
        /// <param Name="specJob">表示装备属性的reqSpecJob的值。</param>
        /// <returns></returns>
        public static string GetExtraJobReqString(int specJob)
        {
            switch (specJob)
            {
                case 21: return "Aran only";
                case 22: return "Evan only";
                case 23: return "Mercedes only";
                case 24: return "Phantom only";
                case 25: return "Shade only";
                case 27: return "Luminous only";
                case 31: return "Demon only";
                case 36: return "Xenon only";
                case 37: return "Blaster only";
                case 41: return "Hayato only";
                case 42: return "Kanna only";
                case 51: return "Mihile only";
                case 61: return "Kaiser only";
                case 63: return "Kain only";
                case 64: return "Cadena only";
                case 65: return "Angelic Buster only";
                case 101: return "Zero only";
                case 112: return "Beast Tamer only";
                case 142: return "Kinesis only";
                case 151: return "Adele only";
                case 152: return "Illium only";
                case 154: return "Khali only";
                case 155: return "Ark only";
                case 162: return "Lara only";
                case 164: return "Hoyoung only";
                case 175: return "Mo Xuan only";

                default: return null;
            }
        }

        public static string GetItemPropString(ItemPropType propType, int value)
        {
            switch (propType)
            {
                case ItemPropType.tradeBlock:
                    return GetGearPropString(GearPropType.tradeBlock, value);
                case ItemPropType.useTradeBlock:
                    return value == 0 ? null : "Cannot be traded after use";
                case ItemPropType.tradeAvailable:
                    return GetGearPropString(GearPropType.tradeAvailable, value);
                case ItemPropType.only:
                    return GetGearPropString(GearPropType.only, value);
                case ItemPropType.accountSharable:
                    return GetGearPropString(GearPropType.accountSharable, value);
                case ItemPropType.sharableOnce:
                    return GetGearPropString(GearPropType.sharableOnce, value);
                case ItemPropType.exchangeableOnce:
                    return value == 0 ? null : "Tradable once (untradable after using or trading)";
                case ItemPropType.quest:
                    return value == 0 ? null : "Quest Item";
                case ItemPropType.pquest:
                    return value == 0 ? null : "Party Quest Item";
                case ItemPropType.permanent:
                    return value == 0 ? null : "PERMANENT";//GMS PLACEHOLDER?
                case ItemPropType.multiPet://GMS string for: "Normal Pet (Cannot be used with other pets)" and "Multi Pet (Can use up to 3 pets at once)"
                    return value == 0 ? "" : "";
                default:
                    return null;
            }
        }

        public static string GetItemCoreSpecString(ItemCoreSpecType coreSpecType, int value, string desc)
        {
            bool hasCoda = false;
            if (desc?.Length > 0)
            {
                char lastCharacter = desc.Last();
                hasCoda = lastCharacter >= '가' && lastCharacter <= '힣' && (lastCharacter - '가') % 28 != 0;
            }
            switch (coreSpecType)
            {
                case ItemCoreSpecType.Ctrl_mobLv:
                    return value == 0 ? null : "Monster Level " + "+" + value;
                case ItemCoreSpecType.Ctrl_mobHPRate:
                    return value == 0 ? null : "Monster HP " + "+" + value + "%";
                case ItemCoreSpecType.Ctrl_mobRate:
                    return value == 0 ? null : "Monster Population " + "+" + value + "%";
                case ItemCoreSpecType.Ctrl_mobRateSpecial:
                    return value == 0 ? null : "Monster Population " + "+" + value + "%";
                case ItemCoreSpecType.Ctrl_change_Mob:
                    return desc == null ? null : "Change monster skins for " + desc;
                case ItemCoreSpecType.Ctrl_change_BGM:
                    return desc == null ? null : "Change music for " + desc;
                case ItemCoreSpecType.Ctrl_change_BackGrnd:
                    return desc == null ? null : "Change background image for " + desc;
                case ItemCoreSpecType.Ctrl_partyExp:
                    return value == 0 ? null : "Party EXP " + "+" + value + "%";
                case ItemCoreSpecType.Ctrl_partyExpSpecial:
                    return value == 0 ? null : "Party EXP " + "+" + value + "%";
                case ItemCoreSpecType.Ctrl_addMob:
                    return value == 0 || desc == null ? null : desc + ", Link " + value + " added to area";
                case ItemCoreSpecType.Ctrl_dropRate:
                    return value == 0 ? null : "Drop Rate " + "+" + value + "%";
                case ItemCoreSpecType.Ctrl_dropRateSpecial:
                    return value == 0 ? null : "Drop Rate " + "+" + value + "%";
                case ItemCoreSpecType.Ctrl_dropRate_Herb:
                    return value == 0 ? null : "Herb Drop Rate " + "+" + value + "%";
                case ItemCoreSpecType.Ctrl_dropRate_Mineral:
                    return value == 0 ? null : "Mineral Drop Rate " + "+" + value + "%";
                case ItemCoreSpecType.Ctrl_dropRareEquip:
                    return value == 0 ? null : "Rare Equipment Drop";
                case ItemCoreSpecType.Ctrl_reward:
                case ItemCoreSpecType.Ctrl_addMission:
                    return desc;
                default:
                    return null;
            }
        }

        public static string GetSkillReqAmount(int skillID, int reqAmount)
        {
            switch (skillID / 10000)
            {
                case 11200: return "[Required Bear Skill Point(s): " + reqAmount + "]";
                case 11210: return "[Required Leopard Skill Point(s): " + reqAmount + "]";
                case 11211: return "[Required Hawk Skill Point(s): " + reqAmount + "]";
                case 11212: return "[Required Cat Skill Point(s): " + reqAmount + "]";
                default: return "[Required ?? Skill Point(s): " + reqAmount + "]";
            }
        }

        public static string GetJobName(int jobCode)
        {
            switch (jobCode)
            {
                case 0: return "Beginner";
                case 100: return "Swordsman";
                case 110: return "Fighter";
                case 111: return "Crusader";
                case 112: return "Hero";
                case 120: return "Page";
                case 121: return "White Knight";
                case 122: return "Paladin";
                case 130: return "Spearman";
                case 131: return "Dragon Knight";
                case 132: return "Dark Knight";
                case 200: return "Magician";
                case 210: return "Wizard (Fire,Poison)";
                case 211: return "Mage (Fire, Poison)";
                case 212: return "Arch Mage (Fire,Poison)";
                case 220: return "Wizard (Ice,Lightning)";
                case 221: return "Mage (Ice,Lightning)";
                case 222: return "Arch Mage (Ice,Lightning)";
                case 230: return "Cleric";
                case 231: return "Priest";
                case 232: return "Bishop";
                case 300: return "Archer";
                case 301: return "Archer";
                case 310: return "Hunter";
                case 311: return "Ranger";
                case 312: return "Bowmaster";
                case 320: return "Crossbowman";
                case 321: return "Sniper";
                case 322: return "Marksman";
                case 330: return "Ancient Archer";
                case 331: return "Soulchaser";
                case 332: return "Pathfinder";
                case 333: return "Pathfinder (5)";
                case 400: return "Rogue";
                case 410: return "Assassin";
                case 411: return "Hermit";
                case 412: return "Night Lord";
                case 420: return "Thief";
                case 421: return "Chief Bandit";
                case 422: return "Shadower";
                case 430: return "Blade Recruit";
                case 431: return "Blade Acolyte";
                case 432: return "Blade Specialist";
                case 433: return "Blade Loard";
                case 434: return "Blade Master";
                case 500: return "Pirate";
                case 501: return "Pirate";
                case 508: return "Jett(1)";
                case 510: return "Brawler";
                case 511: return "Marauder";
                case 512: return "Buccaneer";
                case 520: return "Gunslinger";
                case 521: return "Outlaw";
                case 522: return "Captain";
                case 530: return "Cannoneer";
                case 531: return "Cannon Trooper";
                case 532: return "Cannon Master";
                case 570: return "Jett(2)";
                case 571: return "Jett(3)";
                case 572: return "Jett(4)";

                case 1000: return "Noblesse";
                case 1100: return "Dawn Warrior(1)";
                case 1110: return "Dawn Warrior(2)";
                case 1111: return "Dawn Warrior(3)";
                case 1112: return "Dawn Warrior(4)";
                case 1200: return "Blaze Wizard(1)";
                case 1210: return "Blaze Wizard(2)";
                case 1211: return "Blaze Wizard(3)";
                case 1212: return "Blaze Wizard(4)";
                case 1300: return "Wind Archer(1)";
                case 1310: return "Wind Archer(2)";
                case 1311: return "Wind Archer(3)";
                case 1312: return "Wind Archer(4)";
                case 1400: return "Night Walker(1)";
                case 1410: return "Night Walker(2)";
                case 1411: return "Night Walker(3)";
                case 1412: return "Night Walker(4)";
                case 1500: return "Thunder Breaker(1)";
                case 1510: return "Thunder Breaker(2)";
                case 1511: return "Thunder Breaker(3)";
                case 1512: return "Thunder Breaker(4)";

                case 2000: return "Legend";
                case 2001: return "Evan";
                case 2002: return "Mercedes";
                case 2003: return "Phantom";
                case 2004: return "Luminous";
                case 2005: return "Shade";
                case 2100: return "Aran(1)";
                case 2110: return "Aran(2)";
                case 2111: return "Aran(3)";
                case 2112: return "Aran(4)";
                case 2200:
                case 2210: return "Evan(1)";
                case 2211:
                case 2212:
                case 2213: return "Evan(2)";
                case 2214:
                case 2215:
                case 2216: return "Evan (3)";
                case 2217:
                case 2218: return "Evan(4)";
                case 2300: return "Mercedes(1)";
                case 2310: return "Mercedes(2)";
                case 2311: return "Mercedes(3)";
                case 2312: return "Mercedes(4)";
                case 2400: return "Phantom(1)";
                case 2410: return "Phantom(2)";
                case 2411: return "Phantom(3)";
                case 2412: return "Phantom(4)";
                case 2500: return "Shade(1)";
                case 2510: return "Shade(2)";
                case 2511: return "Shade(3)";
                case 2512: return "Shade(4)";
                case 2700: return "Luminous(1)";
                case 2710: return "Luminous(2)";
                case 2711: return "Luminous(3)";
                case 2712: return "Luminous(4)";


                case 3000: return "Citizen";
                case 3001: return "Demon";
                case 3100: return "Demon Slayer(1)";
                case 3110: return "Demon Slayer(2)";
                case 3111: return "Demon Slayer(3)";
                case 3112: return "Demon Slayer(4)";
                case 3101: return "Demon Avenger(1)";
                case 3120: return "Demon Avenger(2)";
                case 3121: return "Demon Avenger(3)";
                case 3122: return "Demon Avenger(4)";
                case 3200: return "Battle Mage(1)";
                case 3210: return "Battle Mage(2)";
                case 3211: return "Battle Mage(3)";
                case 3212: return "Battle Mage(4)";
                case 3300: return "Wild Hunter(1)";
                case 3310: return "Wild Hunter(2)";
                case 3311: return "Wild Hunter(3)";
                case 3312: return "Wild Hunter(4)";
                case 3500: return "Mechanic(1)";
                case 3510: return "Mechanic(2)";
                case 3511: return "Mechanic(3)";
                case 3512: return "Mechanic(4)";
                case 3002: return "Xenon";
                case 3600: return "Xenon(1)";
                case 3610: return "Xenon(2)";
                case 3611: return "Xenon(3)";
                case 3612: return "Xenon(4)";
                case 3700: return "Blaster(1)";
                case 3710: return "Blaster(2)";
                case 3711: return "Blaster(3)";
                case 3712: return "Blaster(4)";

                case 4001: return "Hayato";
                case 4002: return "Kanna";
                case 4100: return "Hayato(1)";
                case 4110: return "Hayato(2)";
                case 4111: return "Hayato(3)";
                case 4112: return "Hayato(4)";
                case 4200: return "Kanna(1)";
                case 4210: return "Kanna(2)";
                case 4211: return "Kanna(3)";
                case 4212: return "Kanna(4)";


                case 5000: return "Mihile";
                case 5100: return "Mihile(1)";
                case 5110: return "Mihile(2)";
                case 5111: return "Mihile(3)";
                case 5112: return "Mihile(4)";


                case 6000: return "Kaiser";
                case 6001: return "Angelic Buster";
                case 6002: return "Cadena";
                case 6003: return "Kain";
                case 6100: return "Kaiser(1)";
                case 6110: return "Kaiser(2)";
                case 6111: return "Kaiser(3)";
                case 6112: return "Kaiser(4)";
                case 6300: return "Kain(1)";
                case 6310: return "Kain(2)";
                case 6311: return "Kain(3)";
                case 6312: return "Kain(4)";
                case 6400: return "Cadena(1)";
                case 6410: return "Cadena(2)";
                case 6411: return "Cadena(3)";
                case 6412: return "Cadena(4)";
                case 6500: return "Angelic Buster(1)";
                case 6510: return "Angelic Buster(2)";
                case 6511: return "Angelic Buster(3)";
                case 6512: return "Angelic Buster(4)";

                case 10000: return "Zero";
                case 10100: return "Zero(1)";
                case 10110: return "Zero(2)";
                case 10111: return "Zero(3)";
                case 10112: return "Zero(4)";

                case 11000: return "Chase";
                case 11200: return "Beast Tamer(1)";
                case 11210: return "Beast Tamer(2)";
                case 11211: return "Beast Tamer(3)";
                case 11212: return "Beast Tamer(4)";

                case 13000: return "Pink Bean";
                case 13001: return "Yetihood";
                case 13100: return "Pink Bean";
                case 13500: return "Yeti";

                case 14000: return "Kinesis";
                case 14200: return "Kinesis(1)";
                case 14210: return "Kinesis(2)";
                case 14211: return "Kinesis(3)";
                case 14212: return "Kinesis(4)";
                case 14213: return "Kinesis(5)";

                case 15000: return "Illium";
                case 15001: return "Ark";
                case 15002: return "Adele";
                case 15003: return "Khali";
                case 15100: return "Adele(1)";
                case 15110: return "Adele(2)";
                case 15111: return "Adele(3)";
                case 15112: return "Adele(4)";
                case 15200: return "Illium(1)";
                case 15210: return "Illium(2)";
                case 15211: return "Illium(3)";
                case 15212: return "Illium(4)";
                case 15400: return "Khali(1)";
                case 15410: return "Khali(2)";
                case 15411: return "Khali(3)";
                case 15412: return "Khali(4)";
                case 15500: return "Ark(1)";
                case 15510: return "Ark(2)";
                case 15511: return "Ark(3)";
                case 15512: return "Ark(4)";

                case 16000: return "Anima Thief";
                case 16001: return "Lara";
                case 16200: return "Lara(1)";
                case 16210: return "Lara(2)";
                case 16211: return "Lara(3)";
                case 16212: return "Lara(4)";
                case 16400: return "Hoyoung(1)";
                case 16410: return "Hoyoung(2)";
                case 16411: return "Hoyoung(3)";
                case 16412: return "Hoyoung(4)";
            }
            return null;
        }
    }
}

```

`WzComparerR2.Common/CharaSim/Mob.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Text.RegularExpressions;
using WzComparerR2.WzLib;

namespace WzComparerR2.CharaSim
{
    public class Mob
    {
        public Mob()
        {
            this.ID = -1;
            this.ElemAttr = new MobElemAttr(null);
            this.Revive = new List<int>();
            //this.Animates = new LifeAnimateCollection();

            this.FirstAttack = false;
            this.BodyAttack = false;
            this.DamagedByMob = false;
            this.IgnoreMoveImpact = false;
            this.IgnoreMovable = false;
        }

        public int ID { get; set; }
        public int Level { get; set; }
        public string DefaultHP { get; set; }
        public string DefaultMP { get; set; }
        public string FinalMaxHP { get; set; }
        public string FinalMaxMP { get; set; }
        public long MaxHP { get; set; }
        public long MaxMP { get; set; }
        public int HPRecovery { get; set; }
        public int MPRecovery { get; set; }
        public int? Speed { get; set; }
        public int? FlySpeed { get; set; }
        public int PADamage { get; set; }
        public int MADamage { get; set; }
        public int PDRate { get; set; }
        public int MDRate { get; set; }
        public int PDDamage { get; set; }
        public int MDDamage { get; set; }
        public int Acc { get; set; }
        public int Eva { get; set; }
        public long Pushed { get; set; }
        public int Exp { get; set; }
        public int CharismaEXP { get; set; }
        public int SenseEXP { get; set; }
        public int InsightEXP { get; set; }
        public int WillEXP { get; set; }
        public int CraftEXP { get; set; }
        public int CharmEXP { get; set; }
        public bool Boss { get; set; }
        public bool Undead { get; set; }
        public int Category { get; set; }
        public bool FirstAttack { get; set; }
        public bool BodyAttack { get; set; }
        public int FixedBodyAttackDamageR { get; set; }
        public int RemoveAfter { get; set; }
        public bool DamagedByMob { get; set; }
        public bool ChangeableMob { get; set; }
        public bool AllyMob { get; set; }
        public bool Invincible { get; set; }
        public bool NotAttack { get; set; }
        public int FixedDamage { get; set; }
        public bool IgnoreDamage { get; set; }
        public bool IgnoreMoveImpact { get; set; }
        public bool IgnoreMovable { get; set; }
        public bool NoDebuff { get; set; }
        public bool OnlyNormalAttack { get; set; }
        public bool OnlyHittedByCommonAttack { get; set; }
        public bool PartyBonusMob { get; set; }
        public int WP { get; set; }
        public MobElemAttr ElemAttr { get; set; }

        public int? Link { get; set; }
        public bool Skeleton { get; set; }
        public bool JsonLoad { get; set; }

        public List<int> Revive { get; private set; }

        public BitmapOrigin Default { get; set; }
        //public LifeAnimateCollection Animates { get; private set; }


        public static Mob CreateFromNode(Wz_Node node, GlobalFindNodeFunction findNode)
        {
            int mobID;
            Match m = Regex.Match(node.Text, @"^(\d{7})\.img$");
            if (!(m.Success && Int32.TryParse(m.Result("$1"), out mobID)))
            {
                return null;
            }

            Mob mobInfo = new Mob();
            mobInfo.ID = mobID;
            Wz_Node infoNode = node.FindNodeByPath("info");
            //加载基础属性
            if (infoNode != null)
            {
                foreach (var propNode in infoNode.Nodes)
                {
                    switch (propNode.Text)
                    {
                        case "level": mobInfo.Level = propNode.GetValueEx<int>(0); break;
                        case "defaultHP": mobInfo.DefaultHP = propNode.GetValueEx<string>(null); break;
                        case "defaultMP": mobInfo.DefaultMP = propNode.GetValueEx<string>(null); break;
                        case "finalmaxHP": mobInfo.FinalMaxHP = propNode.GetValueEx<string>(null); break;
                        case "finalmaxMP": mobInfo.FinalMaxMP = propNode.GetValueEx<string>(null); break;
                        case "maxHP": mobInfo.MaxHP = propNode.GetValueEx<long>(0); break;
                        case "maxMP": mobInfo.MaxMP = propNode.GetValueEx<long>(0); break;
                        case "hpRecovery": mobInfo.HPRecovery = propNode.GetValueEx<int>(0); break;
                        case "mpRecovery": mobInfo.MPRecovery = propNode.GetValueEx<int>(0); break;
                        case "speed": mobInfo.Speed = propNode.GetValueEx<int>(0); break;
                        case "flySpeed": mobInfo.FlySpeed = propNode.GetValueEx<int>(0); break;

                        case "PADamage": mobInfo.PADamage = propNode.GetValueEx<int>(0); break;
                        case "MADamage": mobInfo.MADamage = propNode.GetValueEx<int>(0); break;
                        case "PDRate": mobInfo.PDRate = propNode.GetValueEx<int>(0); break;
                        case "MDRate": mobInfo.MDRate = propNode.GetValueEx<int>(0); break;
                        case "PDDamage": mobInfo.PDDamage = propNode.GetValueEx<int>(0); break;
                        case "MDDamage": mobInfo.MDDamage = propNode.GetValueEx<int>(0); break;
                        //case "acc": mobInfo.Acc = propNode.GetValueEx<int>(0); break; //no longer used
                        //case "eva": mobInfo.Eva = propNode.GetValueEx<int>(0); break; //no longer used
                        case "pushed": mobInfo.Pushed = propNode.GetValueEx<long>(0); break;
                        case "exp": mobInfo.Exp = propNode.GetValueEx<int>(0); break;
                        case "charismaEXP": mobInfo.CharismaEXP = propNode.GetValueEx<int>(0); break;
                        case "senseEXP": mobInfo.SenseEXP = propNode.GetValueEx<int>(0); break;
                        case "insightEXP": mobInfo.InsightEXP = propNode.GetValueEx<int>(0); break;
                        case "willEXP": mobInfo.WillEXP = propNode.GetValueEx<int>(0); break;
                        case "craftEXP": mobInfo.CraftEXP = propNode.GetValueEx<int>(0); break;
                        case "charmEXP": mobInfo.CharmEXP = propNode.GetValueEx<int>(0); break;
                        case "wp": mobInfo.WP = propNode.GetValueEx<int>(0); break;

                        case "boss": mobInfo.Boss = propNode.GetValueEx<int>(0) != 0; break;
                        case "partyBonusMob": mobInfo.PartyBonusMob = propNode.GetValueEx<int>(0) != 0; break;
                        case "undead": mobInfo.Undead = propNode.GetValueEx<int>(0) != 0; break;
                        case "firstAttack": mobInfo.FirstAttack = propNode.GetValueEx<int>(0) != 0; break;
                        case "bodyAttack": mobInfo.BodyAttack = propNode.GetValueEx<int>(0) != 0; break;
                        case "fixedBodyAttackDamageR": mobInfo.FixedBodyAttackDamageR = propNode.GetValueEx<int>(0); break;
                        case "category": mobInfo.Category = propNode.GetValueEx<int>(0); break;
                        case "removeAfter": mobInfo.RemoveAfter = propNode.GetValueEx<int>(0); break;
                        case "damagedByMob": mobInfo.DamagedByMob = propNode.GetValueEx<int>(0) != 0; break;
                        case "changeableMob": mobInfo.ChangeableMob = propNode.GetValueEx<int>(0) != 0; break;
                        case "allyMob": mobInfo.AllyMob = propNode.GetValueEx<int>(0) != 0; break;
                        case "invincible": mobInfo.Invincible = propNode.GetValueEx<int>(0) != 0; break;
                        case "notAttack": mobInfo.NotAttack = propNode.GetValueEx<int>(0) != 0; break;
                        case "fixedDamage": mobInfo.FixedDamage = propNode.GetValueEx<int>(0); break;
                        case "ignoreDamage": mobInfo.IgnoreDamage = propNode.GetValueEx<int>(0) != 0; break;
                        case "ignoreMoveImpact": mobInfo.IgnoreMoveImpact = propNode.GetValueEx<int>(0) != 0; break;
                        case "ignoreMovable": mobInfo.IgnoreMovable = propNode.GetValueEx<int>(0) != 0; break;
                        case "noDebuff": mobInfo.NoDebuff = propNode.GetValueEx<int>(0) != 0; break;
                        case "onlyNormalAttack": mobInfo.OnlyNormalAttack = propNode.GetValueEx<int>(0) != 0; break;
                        case "onlyHittedByCommonAttack": mobInfo.OnlyHittedByCommonAttack = propNode.GetValueEx<int>(0) != 0; break;
                        case "elemAttr": mobInfo.ElemAttr = new MobElemAttr(propNode.GetValueEx<string>(null)); break;

                        case "link": mobInfo.Link = propNode.GetValueEx<int>(0); break;
                        case "skeleton": mobInfo.Skeleton = propNode.GetValueEx<int>(0) != 0; break;
                        case "jsonLoad": mobInfo.JsonLoad = propNode.GetValueEx<int>(0) != 0; break;

                        //case "skill": LoadSkill(mobInfo, propNode); break;
                        //case "attack": LoadAttack(mobInfo, propNode); break;
                        //case "buff": LoadBuff(mobInfo, propNode); break;
                        case "revive":
                            for (int i = 0; ; i++)
                            {
                                var reviveNode = propNode.FindNodeByPath(i.ToString());
                                if (reviveNode == null)
                                {
                                    break;
                                }
                                mobInfo.Revive.Add(reviveNode.GetValue<int>());
                            }
                            break;
                    }
                }
            }

            //读取怪物默认动作
            {
                Wz_Node linkNode = null;
                if (mobInfo.Link != null && findNode != null)
                {
                    linkNode = findNode(string.Format("Mob\\{0:d7}.img", mobInfo.Link));
                }
                if (linkNode == null)
                {
                    linkNode = node;
                }

                var imageFrame = new BitmapOrigin();

                foreach (var action in new[] { "stand", "move", "fly" })
                {
                    var actNode = linkNode.FindNodeByPath(action + @"\0");
                    if (actNode != null)
                    {
                        imageFrame = BitmapOrigin.CreateFromNode(actNode, findNode);
                        if (imageFrame.Bitmap != null)
                        {
                            break;
                        }
                    }
                }

                mobInfo.Default = imageFrame;
            }

            return mobInfo;
        }
    }
}

```

`WzComparerR2.Common/CharaSim/MobElemAttr.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace WzComparerR2.CharaSim
{
    public class MobElemAttr
    {
        public MobElemAttr(string elemAttr)
        {
            this.StringValue = elemAttr;
            if (string.IsNullOrEmpty(elemAttr))
            {
                return;
            }

            for (int i = 0; i < elemAttr.Length; i += 2)
            {
                ElemResistance resist = (ElemResistance)(elemAttr[i + 1] - 48);
                switch (elemAttr[i])
                {
                    case 'P': this.P = resist; break;
                    case 'H': this.H = resist; break;
                    case 'F': this.F = resist; break;
                    case 'I': this.I = resist; break;
                    case 'S': this.S = resist; break;
                    case 'L': this.L = resist; break;
                    case 'D': this.D = resist; break;
                }
            }
        }
        public string StringValue { get; private set; }
        public ElemResistance P { get; private set; }
        public ElemResistance H { get; private set; }
        public ElemResistance F { get; private set; }
        public ElemResistance I { get; private set; }
        public ElemResistance S { get; private set; }
        public ElemResistance L { get; private set; }
        public ElemResistance D { get; private set; }
    }

    public enum ElemResistance : byte
    {
        Normal = 0,
        Immune = 1,
        Resist = 2,
        Weak = 3,
    }
}

```

`WzComparerR2.Common/CharaSim/Npc.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Text.RegularExpressions;
using WzComparerR2.WzLib;

namespace WzComparerR2.CharaSim
{
    public class Npc
    {
        public Npc()
        {
            this.ID = -1;
            //this.Animates = new LifeAnimateCollection();
        }

        public int ID { get; set; }
        public bool Shop { get; set; }

        public int? Link { get; set; }

        public BitmapOrigin Default { get; set; }

        //public LifeAnimateCollection Animates { get; private set; }

        public static Npc CreateFromNode(Wz_Node node, GlobalFindNodeFunction findNode)
        {
            int npcID;
            Match m = Regex.Match(node.Text, @"^(\d{7})\.img$");
            if (!(m.Success && Int32.TryParse(m.Result("$1"), out npcID)))
            {
                return null;
            }

            Npc npcInfo = new Npc();
            npcInfo.ID = npcID;
            Wz_Node infoNode = node.FindNodeByPath("info");

            //加载基础属性
            if (infoNode != null)
            {
                foreach (var propNode in infoNode.Nodes)
                {
                    switch (propNode.Text)
                    {
                        case "shop": npcInfo.Shop = propNode.GetValueEx<int>(0) != 0; break;
                        case "link": npcInfo.Link = propNode.GetValueEx<int>(0); break;
                        case "default": npcInfo.Default = BitmapOrigin.CreateFromNode(propNode, null); break;
                    }
                }
            }

            //读取默认图片
            if (npcInfo.Default.Bitmap == null)
            {
                Wz_Node linkNode = null;
                if (npcInfo.Link != null && findNode != null)
                {
                    linkNode = findNode(string.Format("Npc\\{0:d7}.img", npcInfo.Link));
                }
                if (linkNode == null)
                {
                    linkNode = node;
                }

                var imageFrame = new BitmapOrigin();

                foreach (var action in new[] { "stand", "move", "fly" })
                {
                    var actNode = linkNode.FindNodeByPath(action + @"\0");
                    if (actNode != null)
                    {
                        imageFrame = BitmapOrigin.CreateFromNode(actNode, findNode);
                        if (imageFrame.Bitmap != null)
                        {
                            break;
                        }
                    }
                }

                npcInfo.Default = imageFrame;
            }

            return npcInfo;
        }
    }
}

```

`WzComparerR2.Common/CharaSim/Potential.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using WzComparerR2.WzLib;

namespace WzComparerR2.CharaSim
{
    public class Potential
    {
        public Potential()
        {
            props = new Dictionary<GearPropType, int>();
        }
        public int code;
        public int optionType;
        public int reqLevel;
        public Dictionary<GearPropType, int> props;
        public int weight;
        public string stringSummary;

        /// <summary>
        /// 指示潜能是否是附加潜能。
        /// </summary>
        public bool IsPotentialEx
        {
            get { return this.code / 1000 % 10 == 2; }
        }

        public override string ToString()
        {
            return this.code.ToString("d6") + " " + ConvertSummary()
                + (weight > 0 ? (" - " + weight) : null);
        }

        public string ConvertSummary()
        {
            if (string.IsNullOrEmpty(this.stringSummary))
                return null;
            List<string> types = new List<string>(this.props.Keys.Count);
            foreach (GearPropType k in this.props.Keys)
                types.Add(k.ToString());
            types.Sort((a, b) => b.Length.CompareTo(a.Length));
            string str = this.stringSummary;
            foreach (string s in types)
            {
                GearPropType t = (GearPropType)Enum.Parse(typeof(GearPropType), s);
                str = str.Replace("#" + s, this.props[t].ToString());
            }
            return str;
        }

        public static int GetPotentialLevel(int gearReqLevel)
        {
            if (gearReqLevel <= 0) return 1;
            else if (gearReqLevel >= 200) return 20;
            else return (gearReqLevel + 9) / 10;
        }

        public static bool CheckOptionType(int optionType, GearType gearType)
        {
            switch (optionType)
            {
                case 0: return true;
                case 10:
                    return Gear.IsWeapon(gearType)
               || Gear.IsSubWeapon(gearType) // IsSubWeapon should return `true` for GearType.katara
               || gearType == GearType.shield;
                case 11:
                    return !CheckOptionType(10, gearType);
                case 20:
                    return Gear.IsSubWeapon(gearType)
               || gearType == GearType.pants
               || gearType == GearType.shoes
               || gearType == GearType.cap
               || gearType == GearType.coat
               || gearType == GearType.longcoat
               || gearType == GearType.glove
               || gearType == GearType.cape
               || gearType == GearType.belt
               || gearType == GearType.shoulderPad;
                case 40:
                    return gearType == GearType.faceAccessory
               || gearType == GearType.eyeAccessory
               || gearType == GearType.ring
               || gearType == GearType.earrings
               || gearType == GearType.pendant;
                case 51: return gearType == GearType.cap;
                case 52: return gearType == GearType.coat || gearType == GearType.longcoat;
                case 53: return gearType == GearType.pants;
                case 54: return gearType == GearType.glove;
                case 55: return gearType == GearType.shoes;
                default: return false;
            }
        }

        public static Potential CreateFromNode(Wz_Node potentialNode, int pLevel)
        {
            Potential potential = new Potential();
            if (potentialNode == null || !Int32.TryParse(potentialNode.Text, out potential.code))
                return null;
            foreach (Wz_Node subNode in potentialNode.Nodes)
            {
                if (subNode.Text == "info")
                {
                    foreach (Wz_Node infoNode in subNode.Nodes)
                    {
                        switch (infoNode.Text)
                        {
                            case "optionType":
                                potential.optionType = Convert.ToInt32(infoNode.Value);
                                break;
                            case "reqLevel":
                                potential.reqLevel = Convert.ToInt32(infoNode.Value);
                                break;
                            case "weight":
                                potential.weight = Convert.ToInt32(infoNode.Value);
                                break;
                            case "string":
                                potential.stringSummary = Convert.ToString(infoNode.Value);
                                break;
                        }
                    }
                }
                else if (subNode.Text == "level")
                {
                    Wz_Node levelNode = subNode.FindNodeByPath(pLevel.ToString());
                    if (levelNode != null)
                    {
                        foreach (Wz_Node propNode in levelNode.Nodes)
                        {
                            try
                            {
                                GearPropType propType = (GearPropType)Enum.Parse(typeof(GearPropType), propNode.Text);
                                int value = (propType == GearPropType.face ? 0 : Convert.ToInt32(propNode.Value));
                                potential.props.Add(propType, value);
                            }
                            catch
                            {
                            }
                        }
                    }
                    else
                    {
                        return null;
                    }
                }
            }
            return potential;
        }

        public static Potential LoadFromWz(int optID, int optLevel, GlobalFindNodeFunction findNode)
        {
            Wz_Node itemWz = findNode("Item\\ItemOption.img");
            if (itemWz == null)
                return null;

            Potential opt = Potential.CreateFromNode(itemWz.FindNodeByPath(optID.ToString("d6")), optLevel);
            return opt;
        }
    }
}

```

`WzComparerR2.Common/CharaSim/Recipe.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using WzComparerR2.WzLib;

namespace WzComparerR2.CharaSim
{
    public class Recipe
    {
        public Recipe()
        {
            this.TargetItems = new List<RecipeItemInfo>();
            this.RecipeItems = new List<RecipeItemInfo>();
            this.Props = new Dictionary<RecipePropType, int>();
        }

        public int RecipeID { get; set; }
        public List<RecipeItemInfo> TargetItems { get; private set; }
        public List<RecipeItemInfo> RecipeItems { get; private set; }
        public Dictionary<RecipePropType, int> Props { get; private set; }

        public int MainTargetItemID
        {
            get
            {
                if (this.TargetItems.Count > 0)
                {
                    return this.TargetItems[0].ItemID;
                }
                return 0;
            }
        }

        public static Recipe CreateFromNode(Wz_Node node)
        {
            Recipe recipe = new Recipe();
            int recipeID;
            if (!Int32.TryParse(node.Text, out recipeID))
                return null;
            recipe.RecipeID = recipeID;

            foreach (Wz_Node subNode in node.Nodes)
            {
                switch (subNode.Text)
                {
                    case "target":
                        for (int i = 0; ; i++)
                        {
                            Wz_Node itemNode = subNode.FindNodeByPath(i.ToString());
                            if (itemNode == null)
                            {
                                break;
                            }

                            RecipeItemInfo itemInfo = new RecipeItemInfo();
                            foreach (var itemPropNode in itemNode.Nodes)
                            {
                                switch (itemPropNode.Text)
                                {
                                    case "item":
                                        itemInfo.ItemID = itemPropNode.GetValue<int>();
                                        break;
                                    case "count":
                                        itemInfo.Count = itemPropNode.GetValue<int>();
                                        break;
                                    case "probWeight":
                                        itemInfo.ProbWeight = itemPropNode.GetValue<int>();
                                        break;
                                }
                            }
                            recipe.TargetItems.Add(itemInfo);
                        }
                        break;

                    case "recipe":
                        for (int i = 0; ; i++)
                        {
                            Wz_Node itemNode = subNode.FindNodeByPath(i.ToString());
                            if (itemNode == null)
                            {
                                break;
                            }
                            RecipeItemInfo itemInfo = new RecipeItemInfo();
                            foreach (var itemPropNode in itemNode.Nodes)
                            {
                                switch (itemPropNode.Text)
                                {
                                    case "item":
                                        itemInfo.ItemID = itemPropNode.GetValue<int>();
                                        break;
                                    case "count":
                                        itemInfo.Count = itemPropNode.GetValue<int>();
                                        break;
                                }
                            }
                            recipe.RecipeItems.Add(itemInfo);
                        }
                        break;

                    default:
                        RecipePropType type;
                        if (Enum.TryParse(subNode.Text, out type))
                        {
                            try
                            {
                                recipe.Props.Add(type, Convert.ToInt32(subNode.Value));
                            }
                            finally
                            {
                            }
                        }
                        break;
                }
            }

            return recipe;
        }
    }
}

```

`WzComparerR2.Common/CharaSim/RecipeItemInfo.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace WzComparerR2.CharaSim
{
    public class RecipeItemInfo
    {
        public RecipeItemInfo()
        {
        }

        public int ItemID { get; set; }
        public int Count { get; set; }
        public int ProbWeight { get; set; }
    }
}

```

`WzComparerR2.Common/CharaSim/RecipePropType.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace WzComparerR2.CharaSim
{
    public enum RecipePropType
    {
        reqSkillLevel = 1,
        reqSkillProficiency,
        coolTimeSec,
        intFatigability,
        incSkillMasterProficiency,
        probMod,
    }
}

```

`WzComparerR2.Common/CharaSim/SetItem.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

using WzComparerR2.WzLib;

namespace WzComparerR2.CharaSim
{
    public class SetItem
    {
        public SetItem()
        {
            ItemIDs = new SetItemIDList();
            Effects = new Dictionary<int, SetItemEffect>();
        }

        public int SetItemID { get; set; }
        public int CompleteCount { get; set; }
        public int currentCount;
        public bool Parts { get; set; }
        public bool ExpandToolTip { get; set; }
        public SetItemIDList ItemIDs { get; private set; }
        public string SetItemName { get; set; }
        public Dictionary<int, SetItemEffect> Effects { get; private set; }

        public static SetItem CreateFromNode(Wz_Node setItemNode, Wz_Node optionNode)
        {
            if (setItemNode == null)
                return null;

            SetItem setItem = new SetItem();
            int setItemID;
            if (int.TryParse(setItemNode.Text, out setItemID))
            {
                setItem.SetItemID = setItemID;
            }

            Dictionary<string, string> desc = new Dictionary<string, string>();

            foreach (Wz_Node subNode in setItemNode.Nodes)
            {
                switch (subNode.Text)
                {
                    case "setItemName":
                        setItem.SetItemName = Convert.ToString(subNode.Value);
                        break;
                    case "completeCount":
                        setItem.CompleteCount = Convert.ToInt32(subNode.Value);
                        break;
                    case "parts":
                        setItem.Parts = subNode.GetValue<int>() != 0;
                        break;
                    case "expandToolTip":
                        setItem.ExpandToolTip = subNode.GetValue<int>() != 0;
                        break;
                    case "ItemID":
                        foreach (Wz_Node itemNode in subNode.Nodes)
                        {
                            int idx = Convert.ToInt32(itemNode.Text);
                            if (itemNode.Nodes.Count == 0)
                            {
                                int itemID = Convert.ToInt32(itemNode.Value);
                                setItem.ItemIDs.Add(idx, new SetItemIDPart(itemID));
                            }
                            else
                            {
                                SetItemIDPart part = new SetItemIDPart();
                                int num;
                                foreach (Wz_Node itemNode2 in itemNode.Nodes)
                                {
                                    switch (itemNode2.Text)
                                    {
                                        case "representName":
                                            part.RepresentName = Convert.ToString(itemNode2.Value);
                                            break;
                                        case "typeName":
                                            part.TypeName = Convert.ToString(itemNode2.Value);
                                            break;
                                        case "byGender":
                                            part.ByGender = Convert.ToInt32(itemNode2.Value) != 0;
                                            break;
                                        default:
                                            if (Int32.TryParse(itemNode2.Text, out num) && num > 0)
                                            {
                                                part.ItemIDs[Convert.ToInt32(itemNode2.Value)] = false;
                                            }
                                            break;
                                    }
                                }
                                setItem.ItemIDs.Add(idx, part);
                            }
                        }
                        break;
                    case "Effect":
                        foreach (Wz_Node effectNode in subNode.Nodes)
                        {
                            int count = Convert.ToInt32(effectNode.Text);
                            SetItemEffect effect = new SetItemEffect();
                            foreach (Wz_Node propNode in effectNode.Nodes)
                            {
                                switch (propNode.Text)
                                {
                                    case "Option":
                                        if (optionNode != null)
                                        {
                                            List<Potential> potens = new List<Potential>();
                                            foreach (Wz_Node pNode in propNode.Nodes)
                                            {
                                                string optText = Convert.ToString(pNode.FindNodeByPath("option").Value).PadLeft(6, '0');
                                                Wz_Node opn = optionNode.FindNodeByPath(optText);
                                                if (opn == null)
                                                    continue;
                                                Potential p = Potential.CreateFromNode(opn, Convert.ToInt32(pNode.FindNodeByPath("level").Value));
                                                if (p != null)
                                                {
                                                    potens.Add(p);
                                                }
                                            }
                                            effect.Props.Add(GearPropType.Option, potens);
                                        }
                                        break;

                                    case "OptionToMob":
                                        List<SetItemOptionToMob> opToMobList = new List<SetItemOptionToMob>();
                                        for (int i = 1; ; i++)
                                        {
                                            Wz_Node optNode = propNode.FindNodeByPath(i.ToString());
                                            if (optNode == null)
                                            {
                                                break;
                                            }

                                            SetItemOptionToMob option = new SetItemOptionToMob();

                                            foreach (Wz_Node pNode in optNode.Nodes)
                                            {
                                                switch (pNode.Text)
                                                {
                                                    case "mob":
                                                        foreach (Wz_Node mobNode in pNode.Nodes)
                                                        {
                                                            option.Mobs.Add(mobNode.GetValue<int>());
                                                        }
                                                        break;

                                                    case "mobName":
                                                        option.MobName = pNode.GetValue<string>();
                                                        break;

                                                    default:
                                                        {
                                                            GearPropType type;
                                                            if (Enum.TryParse(pNode.Text, out type))
                                                            {
                                                                option.Props.Add(type, pNode.GetValue<int>());
                                                            }
                                                        }
                                                        break;
                                                }
                                            }

                                            opToMobList.Add(option);
                                        }
                                        effect.Props.Add(GearPropType.OptionToMob, opToMobList);
                                        break;

                                    case "activeSkill":
                                        List<SetItemActiveSkill> activeSkillList = new List<SetItemActiveSkill>();
                                        for (int i = 0; ; i++)
                                        {
                                            Wz_Node optNode = propNode.FindNodeByPath(i.ToString());
                                            if (optNode == null)
                                            {
                                                break;
                                            }

                                            SetItemActiveSkill activeSkill = new SetItemActiveSkill();
                                            foreach (Wz_Node pNode in optNode.Nodes)
                                            {
                                                switch (pNode.Text)
                                                {
                                                    case "id":
                                                        activeSkill.SkillID = pNode.GetValue<int>();
                                                        break;

                                                    case "level":
                                                        activeSkill.Level = pNode.GetValue<int>();
                                                        break;
                                                }
                                            }
                                            activeSkillList.Add(activeSkill);
                                        }
                                        effect.Props.Add(GearPropType.activeSkill, activeSkillList);
                                        break;

                                    case "bonusByTime":
                                        var bonusByTimeList = new List<SetItemBonusByTime>();
                                        for (int i = 0; ; i++)
                                        {
                                            Wz_Node optNode = propNode.FindNodeByPath(i.ToString());
                                            if (optNode == null)
                                            {
                                                break;
                                            }

                                            var bonusByTime = new SetItemBonusByTime();
                                            foreach (Wz_Node pNode in optNode.Nodes)
                                            {
                                                switch (pNode.Text)
                                                {
                                                    case "termStart":
                                                        bonusByTime.TermStart = pNode.GetValue<int>();
                                                        break;

                                                    default:
                                                        {
                                                            GearPropType type;
                                                            if (Enum.TryParse(pNode.Text, out type))
                                                            {
                                                                bonusByTime.Props.Add(type, pNode.GetValue<int>());
                                                            }
                                                        }
                                                        break;
                                                }
                                            }
                                            bonusByTimeList.Add(bonusByTime);
                                        }
                                        effect.Props.Add(GearPropType.bonusByTime, bonusByTimeList);
                                        break;

                                    default:
                                        {
                                            GearPropType type;
                                            if (Enum.TryParse(propNode.Text, out type))
                                            {
                                                effect.Props.Add(type, Convert.ToInt32(propNode.Value));
                                            }
                                        }
                                        break;
                                }
                            }
                            setItem.Effects.Add(count, effect);
                        }
                        break;
                    case "Desc":
                        foreach (var descNode in subNode.Nodes)
                        {
                            desc[descNode.Text] = Convert.ToString(descNode.Value);
                        }
                        break;
                }
            }

            //处理额外分组
            if (desc.Count > 0)
            {
                foreach (var kv in desc)
                {
                    SetItemIDPart combinePart = null;
                    string combineTypeName = null;
                    switch (kv.Key)
                    {
                        case "weapon":
                            combinePart = CombinePart(setItem, gearID => Gear.IsWeapon(Gear.GetGearType(gearID)));
                            combineTypeName = ItemStringHelper.GetSetItemGearTypeString(GearType.weapon);
                            break;

                        case "subweapon":
                            combinePart = CombinePart(setItem, gearID => Gear.IsSubWeapon(Gear.GetGearType(gearID)));
                            combineTypeName = ItemStringHelper.GetSetItemGearTypeString(GearType.subWeapon);
                            break;

                        case "pocket":
                            combinePart = CombinePart(setItem, gearID => Gear.GetGearType(gearID) == GearType.pocket);
                            combineTypeName = ItemStringHelper.GetSetItemGearTypeString(GearType.pocket);
                            break;

                        case "emblem":
                            combinePart = CombinePart(setItem, gearID => Gear.GetGearType(gearID) == GearType.emblem);
                            combineTypeName = ItemStringHelper.GetSetItemGearTypeString(GearType.emblem);
                            break;
                    }

                    if (combinePart != null)
                    {
                        combinePart.RepresentName = kv.Value;
                        combinePart.TypeName = combineTypeName; ItemStringHelper.GetSetItemGearTypeString(GearType.weapon);
                    }
                }
            }


            return setItem;
        }

        /// <summary>
        /// 按一定条件合并装备部件的分组。
        /// </summary>
        /// <param name="predicate">装备id符合条件的判断方法。</param>
        /// <returns></returns>
        private static SetItemIDPart CombinePart(SetItem setItem, Predicate<int> predicate)
        {
            List<int> itemIDList = new List<int>();
            List<int> preRemovedPartIdx = new List<int>();
            int? idx = null;
            foreach (var part in setItem.ItemIDs.Parts)
            {
                bool add = false;
                foreach (var itemID in part.Value.ItemIDs.Keys)
                {
                    if (predicate(itemID)) //id满足条件
                    {
                        itemIDList.Add(itemID);
                        add = true;
                    }
                }

                if (add) //提取出被合并项的最大partID
                {
                    //idx = idx == null ? part.Key : Math.Max(part.Key, idx.Value);
                    if (!preRemovedPartIdx.Contains(part.Key))
                        preRemovedPartIdx.Add(part.Key);
                }

                idx = idx == null ? part.Key : Math.Max(part.Key, idx.Value);
            }
            if (itemIDList.Count > 0)
            {
                SetItemIDPart part = new SetItemIDPart(itemIDList);
                foreach (int i in preRemovedPartIdx)
                {
                    setItem.ItemIDs.Remove(i);
                }
                setItem.ItemIDs.Add(idx.Value + 1, part);
                return part;
            }
            return null;
        }
    }
}
```

`WzComparerR2.Common/CharaSim/SetItemActiveSkill.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace WzComparerR2.CharaSim
{
    public class SetItemActiveSkill
    {
        public SetItemActiveSkill()
        {
        }

        public int SkillID { get; set; }
        public int Level { get; set; }
    }
}

```

`WzComparerR2.Common/CharaSim/SetItemBonusByTime.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace WzComparerR2.CharaSim
{
    public class SetItemBonusByTime
    {
        public SetItemBonusByTime()
        {
            this.Props = new Dictionary<GearPropType, int>();
        }

        public int TermStart { get; set; }
        public Dictionary<GearPropType, int> Props { get; private set; }
    }
}

```

`WzComparerR2.Common/CharaSim/SetItemEffect.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Linq;

namespace WzComparerR2.CharaSim
{
    public class SetItemEffect
    {
        public SetItemEffect()
        {
            props = new SortedDictionary<GearPropType, object>();
            enabled = false;
        }
        private SortedDictionary<GearPropType, object> props;
        private bool enabled;

        public SortedDictionary<GearPropType, object> Props
        {
            get { return props; }
        }

        public IEnumerable<KeyValuePair<GearPropType, object>> PropsV5
        {
            get { return props.Where(kv => Gear.IsV5SupportPropType(kv.Key)); }
        }

        public bool Enabled
        {
            get { return enabled; }
            set { enabled = value; }
        }
    }
}

```

`WzComparerR2.Common/CharaSim/SetItemIDList.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace WzComparerR2.CharaSim
{
    public class SetItemIDList
    {
        public SetItemIDList()
        {
            this.Parts = new List<KeyValuePair<int, SetItemIDPart>>();
        }

        public List<KeyValuePair<int, SetItemIDPart>> Parts {get;private set;}

        public void Add(int partID, SetItemIDPart part)
        {
            this.Parts.Add(new KeyValuePair<int, SetItemIDPart>(partID, part));
        }

        public void Remove(int partID)
        {
            this.Parts.RemoveAll(kv => kv.Key == partID);
        }

        /// <summary>
        /// 获取或设置装备是否有效。
        /// </summary>
        /// <param Name="ItemID">装备ID。</param>
        /// <returns></returns>
        public bool this[int itemID]
        {
            get
            {
                foreach (var kv in Parts)
                {
                    bool enabled;
                    kv.Value.ItemIDs.TryGetValue(itemID, out enabled);
                    if (enabled)
                        return true;
                }
                return false;
            }
            set
            {
                foreach (var kv in Parts)
                {
                    bool enabled;
                    if (kv.Value.ItemIDs.TryGetValue(itemID, out enabled) && (enabled ^ value))
                    {
                        kv.Value.ItemIDs[itemID] = value;
                    }
                }
            }
        }
    }
}

```

`WzComparerR2.Common/CharaSim/SetItemIDPart.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace WzComparerR2.CharaSim
{
    public class SetItemIDPart
    {
        public SetItemIDPart()
        {
            itemIDs = new Dictionary<int, bool>();
        }

        /// <summary>
        /// 通过一件装备ID初始化SetItemIDPart的实例。
        /// </summary>
        /// <param Name="ItemID">要初始化的装备ID。</param>
        public SetItemIDPart(int itemID)
            : this()
        {
            itemIDs[itemID] = false;
        }

        /// <summary>
        /// 通过一个装备ID集合初始化SetItemIDPart的实例。
        /// </summary>
        /// <param Name="itemIDList">要初始化的装备ID集合。</param>
        public SetItemIDPart(IEnumerable<int> itemIDList)
            : this()
        {
            foreach (int itemID in itemIDList)
            {
                itemIDs[itemID] = false;
            }
        }

        private Dictionary<int, bool> itemIDs;
        private string representName;
        private string typeName;
        private bool byGender;

        public Dictionary<int, bool> ItemIDs
        {
            get { return itemIDs; }
        }

        /// <summary>
        /// 获取一个值，它表示是否当前的装备ID中，至少有一个是生效的。
        /// </summary>
        public bool Enabled
        {
            get
            {
                foreach (var kv in itemIDs)
                {
                    if (kv.Value)
                        return true;
                }
                return false;
            }
        }

        /// <summary>
        /// 获取或设置套装部件的显示名称。
        /// </summary>
        public string RepresentName
        {
            get { return representName; }
            set { representName = value; }
        }

        /// <summary>
        /// 获取或设置套装部件的类型显示名称。
        /// </summary>
        public string TypeName
        {
            get { return typeName; }
            set { typeName = value; }
        }

        public bool ByGender
        {
            get { return byGender; }
            set { byGender = value; }
        }
    }
}

```

`WzComparerR2.Common/CharaSim/SetItemOptionToMob.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace WzComparerR2.CharaSim
{
    public class SetItemOptionToMob
    {
        public SetItemOptionToMob()
        {
            this.Mobs = new List<int>();
            this.Props = new Dictionary<GearPropType, int>();
        }

        public List<int> Mobs { get; private set; }
        public string MobName { get; set; }
        public Dictionary<GearPropType, int> Props { get; private set; }

        public string ConvertSummary()
        {
            StringBuilder sb = new StringBuilder();

            foreach (var kv in this.Props)
            {
                if (kv.Key == GearPropType.damR)
                {
                    sb.AppendFormat("+{0}% Damage , ", kv.Value);
                }
                else
                {
                    sb.Append(ItemStringHelper.GetGearPropString(kv.Key, kv.Value) + ", ");
                }
            }

            string mobStr = null;
            if (MobName != null)
            {
                mobStr = MobName;
            }
            else if (Mobs.Count > 0)
            {
                mobStr = Mobs[0].ToString();
            }

            return sb.ToString(0, sb.Length - 2) + string.Format("when attacking {0}", mobStr);
        }
    }
}

```

`WzComparerR2.Common/CharaSim/Skill.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Text;
using WzComparerR2.WzLib;

namespace WzComparerR2.CharaSim
{
    public class Skill
    {
        public Skill()
        {
            this.level = 0;
            this.levelCommon = new List<Dictionary<string, string>>();
            this.common = new Dictionary<string, string>();
            this.PVPcommon = new Dictionary<string, string>();
            this.RelationSkill = null;
            this.ReqSkill = new Dictionary<int, int>();
            this.Action = new List<string>();
        }

        private int level;
        internal List<Dictionary<string, string>> levelCommon;
        internal Dictionary<string, string> common;

        public Dictionary<string, string> Common
        {
            get
            {
                if (PreBBSkill && this.level > 0 && this.level <= levelCommon.Count)
                    return levelCommon[this.level - 1];
                else
                    return common;
            }
        }

        public Dictionary<string, string> PVPcommon { get; private set; }
        public int SkillID { get; set; }
        public BitmapOrigin Icon { get; set; }
        public BitmapOrigin IconMouseOver { get; set; }
        public BitmapOrigin IconDisabled { get; set; }

        public HyperSkillType Hyper { get; set; }
        public bool HyperStat { get; set; }

        public int Level
        {
            get { return level; }
            set
            {
                bool canBreakLevel = this.CombatOrders || this.VSkill
                    || this.SkillID / 100000 == 4000; //fix for evan
                int maxLevel = canBreakLevel ? 100 : this.MaxLevel;
                level = Math.Max(0, Math.Min(value, maxLevel));
            }
        }

        public int ReqLevel { get; set; }
        public int ReqAmount { get; set; }
        public bool PreBBSkill { get; set; }
        public bool Invisible { get; set; }
        public bool CombatOrders { get; set; }
        public bool NotRemoved { get; set; }
        public bool VSkill { get; set; }
        public bool NotIncBuffDuration { get; set; }
        public bool NotCooltimeReset { get; set; }
        public bool TimeLimited { get; set; }
        public Tuple<int, int> RelationSkill { get; set; }
        public bool IsPetAutoBuff { get; set; }
        public bool DisableNextLevelInfo { get; set; }
        public int MasterLevel { get; set; }
        public Dictionary<int, int> ReqSkill { get; private set; }
        public List<string> Action { get; private set; }
        public int AddAttackToolTipDescSkill { get; set; }
        public int AssistSkillLink { get; set; }
        public int VehicleID { get; set; }

        public Point LT { get; set; }
        public Point RB { get; set; }

        public int MaxLevel
        {
            get
            {
                string v;
                if (this.PreBBSkill)
                    return levelCommon.Count;
                else if (common.TryGetValue("maxLevel", out v))
                    return Convert.ToInt32(v);
                return 0;
            }
        }

        public static Skill CreateFromNode(Wz_Node node, GlobalFindNodeFunction findNode)
        {
            Skill skill = new Skill();
            int skillID;
            if (!Int32.TryParse(node.Text, out skillID))
                return null;
            skill.SkillID = skillID;

            foreach (Wz_Node childNode in node.Nodes)
            {
                switch (childNode.Text)
                {
                    case "icon":
                        skill.Icon = BitmapOrigin.CreateFromNode(childNode, findNode);
                        break;
                    case "iconMouseOver":
                        skill.IconMouseOver = BitmapOrigin.CreateFromNode(childNode, findNode);
                        break;
                    case "iconDisabled":
                        skill.IconDisabled = BitmapOrigin.CreateFromNode(childNode, findNode);
                        break;
                    case "common":
                        foreach (Wz_Node commonNode in childNode.Nodes)
                        {
                            if (commonNode.Value != null && !(commonNode.Value is Wz_Vector))
                            {
                                skill.common[commonNode.Text] = commonNode.Value.ToString();
                            }
                            else if (commonNode.Value != null && commonNode.Value is Wz_Vector)
                            {
                                Wz_Vector cNode = commonNode.Value as Wz_Vector;
                                if (commonNode.Text == "lt")
                                {
                                    skill.LT = new Point(cNode.X, cNode.Y);
                                }
                                else if (commonNode.Text == "rb")
                                {
                                    skill.RB = new Point(cNode.X, cNode.Y);
                                }
                            }
                        }
                        break;
                    case "PVPcommon":
                        foreach (Wz_Node commonNode in childNode.Nodes)
                        {
                            if (commonNode.Value != null && !(commonNode.Value is Wz_Vector))
                            {
                                skill.PVPcommon[commonNode.Text] = commonNode.Value.ToString();
                            }
                        }
                        break;
                    case "level":
                        for (int i = 1; ; i++)
                        {
                            Wz_Node levelNode = childNode.FindNodeByPath(i.ToString());
                            if (levelNode == null)
                                break;
                            Dictionary<string, string> levelInfo = new Dictionary<string, string>();

                            foreach (Wz_Node commonNode in levelNode.Nodes)
                            {
                                if (commonNode.Value != null && !(commonNode.Value is Wz_Vector))
                                {
                                    levelInfo[commonNode.Text] = commonNode.Value.ToString();
                                }
                            }

                            skill.levelCommon.Add(levelInfo);
                        }
                        break;
                    case "hyper":
                        skill.Hyper = (HyperSkillType)childNode.GetValue<int>();
                        break;
                    case "hyperStat":
                        skill.HyperStat = childNode.GetValue<int>() != 0;
                        break;
                    case "invisible":
                        skill.Invisible = childNode.GetValue<int>() != 0;
                        break;
                    case "combatOrders":
                        skill.CombatOrders = childNode.GetValue<int>() != 0;
                        break;
                    case "notRemoved":
                        skill.NotRemoved = childNode.GetValue<int>() != 0;
                        break;
                    case "vSkill":
                        skill.VSkill = childNode.GetValue<int>() != 0;
                        break;
                    case "notIncBuffDuration":
                        skill.NotIncBuffDuration = childNode.GetValue<int>() != 0;
                        break;
                    case "notCooltimeReset":
                        skill.NotCooltimeReset = childNode.GetValue<int>() != 0;
                        break;
                    case "timeLimited":
                        skill.TimeLimited = childNode.GetValue<int>() != 0;
                        break;
                    case "relationSkill":
                        skill.RelationSkill = Tuple.Create(childNode.Nodes["skillID"].GetValueEx<int>(0), childNode.Nodes["periodMin"].GetValueEx<int>(0));
                        break;
                    case "isPetAutoBuff":
                        skill.IsPetAutoBuff = childNode.GetValue<int>() != 0;
                        break;
                    case "disableNextLevelInfo":
                        skill.DisableNextLevelInfo = childNode.GetValue<int>() != 0;
                        break;
                    case "masterLevel":
                        skill.MasterLevel = childNode.GetValue<int>();
                        break;
                    case "reqLev":
                        skill.ReqLevel = childNode.GetValue<int>();
                        break;
                    case "req":
                        foreach (Wz_Node reqNode in childNode.Nodes)
                        {
                            if (reqNode.Text == "level")
                            {
                                skill.ReqLevel = reqNode.GetValue<int>();
                            }
                            else if (reqNode.Text == "reqAmount")
                            {
                                skill.ReqAmount = reqNode.GetValue<int>();
                            }
                            else
                            {
                                int reqSkill;
                                if (Int32.TryParse(reqNode.Text, out reqSkill))
                                {
                                    skill.ReqSkill[reqSkill] = reqNode.GetValue<int>();
                                }
                            }
                        }
                        break;
                    case "action":
                        for (int i = 0; ; i++)
                        {
                            Wz_Node idxNode = childNode.FindNodeByPath(i.ToString());
                            if (idxNode == null)
                                break;
                            skill.Action.Add(idxNode.GetValue<string>());
                        }
                        break;
                    case "addAttack":
                        Wz_Node toolTipDescNode = childNode.FindNodeByPath("toolTipDesc");
                        if (toolTipDescNode != null && toolTipDescNode.GetValue<int>() != 0)
                        {
                            skill.AddAttackToolTipDescSkill = childNode.FindNodeByPath("toolTipDescSkill").GetValue<int>();
                        }
                        break;
                    case "assistSkillLink":
                        skill.AssistSkillLink = childNode.FindNodeByPath("skill").GetValue<int>();
                        break;
                    case "vehicleID":
                        skill.VehicleID = childNode.GetValue<int>();
                        break;
                }
            }

            if ((skill.common.ContainsKey("forceCon") || (skill.levelCommon.Count > 0 && skill.levelCommon[0].ContainsKey("forceCon"))) && skill.Hyper == HyperSkillType.None)
            {
                Wz_Node forceNode = null;
                if (skill.SkillID / 10000 == 3001 || skill.SkillID / 10000 == 3100 || skill.SkillID / 10000 == 3110 || skill.SkillID / 10000 == 3111 || skill.SkillID / 10000 == 3112)
                {
                    forceNode = findNode.Invoke(string.Format("UI\\UIWindow2.img\\Skill\\main\\Force\\{0}", (Int32.Parse(skill.common["forceCon"]) - 1) / 30));
                }
                else if (skill.SkillID / 10000 / 1000 == 10)
                {
                    forceNode = findNode.Invoke(string.Format("UI\\UIWindow2.img\\SkillZero\\main\\Alpha\\{0}", skill.SkillID / 1000 % 10));
                }
                if (forceNode != null)
                {
                    BitmapOrigin force = BitmapOrigin.CreateFromNode(forceNode, findNode);
                    using (Graphics graphics = Graphics.FromImage(skill.Icon.Bitmap))
                    {
                        graphics.DrawImage(force.Bitmap, new Point(0, 0));
                    }
                    using (Graphics graphics = Graphics.FromImage(skill.IconMouseOver.Bitmap))
                    {
                        graphics.DrawImage(force.Bitmap, new Point(0, 0));
                    }
                    using (Graphics graphics = Graphics.FromImage(skill.IconDisabled.Bitmap))
                    {
                        graphics.DrawImage(force.Bitmap, new Point(0, 0));
                    }
                }
            }

            //判定技能声明版本
            skill.PreBBSkill = false;
            if (skill.levelCommon.Count > 0)
            {
                if (skill.common.Count <= 0
                    || (skill.common.Count == 1 && skill.common.ContainsKey("maxLevel")))
                {
                    skill.PreBBSkill = true;
                }
            }

            return skill;
        }
    }
}

```

`WzComparerR2.Common/CharaSim/SummaryParams.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace WzComparerR2.CharaSim
{
    public struct SummaryParams
    {
        private string r;
        private string n;
        private string cStart;
        private string cEnd;
        private string gStart;
        private string gEnd;

        /// <summary>
        /// 获取或设置回车符(\r)的替换字符串。
        /// </summary>
        public string R
        {
            get { return r; }
            set { r = value; }
        }

        /// <summary>
        /// 获取或设置换行符(\n)的替换字符串。
        /// </summary>
        public string N
        {
            get { return n; }
            set { n = value; }
        }

        /// <summary>
        /// 获取或设置高亮起始符(#c)的替换字符串。
        /// </summary>
        public string CStart
        {
            get { return cStart; }
            set { cStart = value; }
        }

        /// <summary>
        /// 获取或设置高亮结束符(#)的替换字符串
        /// </summary>
        public string CEnd
        {
            get { return cEnd; }
            set { cEnd = value; }
        }

        /// <summary>
        /// 获取或设置自定义高亮起始符(#g)的替换字符串。
        /// </summary>
        public string GStart
        {
            get { return gStart; }
            set { gStart = value; }
        }

        /// <summary>
        /// 获取或设置自定义高亮结束符(#)的替换字符串
        /// </summary>
        public string GEnd
        {
            get { return gEnd; }
            set { gEnd = value; }
        }

        /// <summary>
        /// 获取默认的替换字符串组合。
        /// </summary>
        public static SummaryParams Default
        {
            get
            {
                return new SummaryParams()
                {
                    R = @"\r",
                    N = @"\n",
                    cStart = @"#c",
                    cEnd = @"#",
                    gStart = @"#g",
                    gEnd = @"#"
                };
            }
        }

        public static SummaryParams Text
        {
            get
            {
                return new SummaryParams()
                {
                    R = "\r",
                    N = "\n",
                    cStart = @"#c",
                    cEnd = @"#",
                    gStart = @"#g",
                    gEnd = @"#"
                };
            }
        }

        public static SummaryParams Html
        {
            get
            {
                return new SummaryParams()
                {
                    R = null,
                    N = "<br />",
                    cStart = @"<span style=""font-weight:bold; color:orange;"">",
                    cEnd = @"</span>",
                    gStart = @"<span style=""font-weight:bold; color:#3f0;"">",
                    gEnd = @"</span>"
                };
            }
        }
    }
}

```

`WzComparerR2.Common/CharaSim/SummaryParser.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Text.RegularExpressions;
using WzComparerR2.Common;

namespace WzComparerR2.CharaSim
{
    public class SummaryParser
    {
        static SummaryParser()
        {
            GlobalVariableMapping = new Dictionary<string, string>();
            GlobalVariableMapping["comboConAran"] = "aranComboCon";
        }

        public static string GetSkillSummary(string H, int Level, Dictionary<string, string> CommonProps, SummaryParams param, SkillSummaryOptions options = default)
        {
            if (H == null) return null;

            int idx = 0;
            StringBuilder sb = new StringBuilder();
            bool beginC = false;
            while (idx < H.Length)
            {
                if (H[idx] == '#')
                {
                    int end = idx, len = 0;
                    while ((++end) < H.Length)
                    {
                        if (H[end] == '_' ||
                            ('a' <= H[end] && H[end] <= 'z') ||
                            ('A' <= H[end] && H[end] <= 'Z') ||
                            (end - idx > 1 && '0' <= H[end] && H[end] <= '9')) //^[_A-Za-z][_A-Za-z0-9]*$
                        {
                            len++;
                        }
                        else
                        {
                            break;
                        }
                    }
                    //优先匹配common
                    string prop = null;
                    string propKey = null;
                    if (CommonProps != null)
                    {
                        for (int i = len; i > 0; i--)
                        {
                            propKey = H.Substring(idx + 1, i);
                            if (GetValueIgnoreCase(CommonProps, propKey, out prop))
                            {
                                len = i;
                                break;
                            }
                        }
                    }
                    if (prop != null)
                    {
                        var val = Calculator.Parse(prop.ToLower(), Level);
                        if (options.ConvertCooltimeMS && propKey == "cooltimeMS")
                        {
                            sb.Append((val / 1000).ToString("f2", System.Globalization.CultureInfo.InvariantCulture));
                        }
                        else if (options.ConvertPerM && propKey.EndsWith("PerM", StringComparison.Ordinal))
                        {
                            sb.Append((val / 100).ToString("f1"));
                        }
                        else
                        {
                            sb.Append(val);
                        }
                        idx += len + 1;
                        continue;
                    }
                    else //试图匹配全局变量
                    {
                        string key = null;
                        for (int i = len; i > 0; i--)
                        {
                            key = H.Substring(idx + 1, i);
                            if (GlobalVariableMapping.TryGetValue(key, out prop))
                            {
                                break;
                            }
                        }
                        if (prop != null)
                        {
                            if (prop != "" && GetValueIgnoreCase(CommonProps, prop, out prop))
                            {
                                var val = Calculator.Parse(prop.ToLower(), Level);
                                sb.Append(val);
                            }
                            else
                            {
                                sb.Append(param.GStart).Append("[").Append(key).Append("]").Append(param.GEnd);
                            }

                            idx += len + 1;
                            continue;
                        }
                    }
                    //匹配#c...#段落
                    if (idx + 1 < H.Length && H[idx + 1] == 'c')
                    {
                        beginC = true;
                        sb.Append(param.CStart);
                        idx += 2;
                    }
                    else if (beginC)
                    {
                        beginC = false;
                        sb.Append(param.CEnd);
                        idx++;
                    }
                    else if (idx + 1 < H.Length && len == 0)//匹配省略c的段落
                    {
                        beginC = true;
                        sb.Append(param.CStart);
                        idx++;
                    }
                    else //无法匹配 取最长的common段
                    {
                        string key = H.Substring(idx + 1, len);
                        if (System.Text.RegularExpressions.Regex.IsMatch(key, @"^\d+$"))
                        {
                            sb.Append(key);
                        }
                        else
                        {
                            //sb.Append(0);//默认值
                        }
                        idx += len + 1;
                    }
                }
                else if (H[idx] == '\\')
                {
                    if (idx + 1 < H.Length)
                    {
                        switch (H[idx + 1])
                        {
                            case 'c': break; // \c忽略掉 原因不明
                            case 'r': sb.Append(param.R); break;
                            case 'n': sb.Append(param.N); break;
                            case '\\': sb.Append('\\'); break;
                            default: sb.Append(H[idx + 1]); break;
                        }
                        idx += 2;
                    }
                    else //转义失败
                    {
                        idx++;
                    }
                }
                else
                {
                    sb.Append(H[idx++]);
                }
            }
            return Regex.Replace(sb.ToString().Replace("\t", ""), @"(\\r|\\n)+$", "");
        }

        private static bool GetValueIgnoreCase(Dictionary<string,string> dict, string key, out string value)
        {
            //bool find = false;
            foreach (var kv in dict)
            {
                if (kv.Key.Equals(key, StringComparison.CurrentCulture))//'CurrentCultureIgnoreCase' bugged #cR variable etc.
                {
                    value = kv.Value;
                    return true;
                }
            }
            value = null;
            return false;
        }

        public static string GetSkillSummary(Skill skill, StringResult sr, SummaryParams param)
        {
            if (skill == null)
                return null;
            return GetSkillSummary(skill, skill.Level, sr, param);
        }

        public static string GetSkillSummary(Skill skill, int level, StringResult sr, SummaryParams param, SkillSummaryOptions options = default)
        {
            if (skill == null || sr == null)
                return null;

            string h = null;
            if (skill.PreBBSkill) //用level声明的技能
            {
                string hs;
                if (skill.Level == level && skill.Common.TryGetValue("hs", out hs))
                {
                    h = sr[hs];
                }
                else if (sr.SkillH.Count >= level)
                {
                    h = sr.SkillH[level - 1];
                }
            }
            else
            {
                if (sr.SkillH.Count > 0)
                {
                    h = sr.SkillH[0];
                }
            }

            return GetSkillSummary(h, level, skill.Common, param, options);
        }

        public static Dictionary<string,string> GlobalVariableMapping { get; private set; }
    }

    public struct SkillSummaryOptions
    {
        public bool ConvertCooltimeMS { get; set; }
        public bool ConvertPerM { get; set; }
    }
}

```

`WzComparerR2.Common/CharaSim/TooltipHelp.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace WzComparerR2.CharaSim
{
    public class TooltipHelp : ICloneable
    {
        public TooltipHelp(string title, string desc)
        {
            this.Title = title;
            this.Desc = desc;
        }

        public string Title { get; set; }
        public string Desc { get; set; }

        public virtual object Clone()
        {
            return this.MemberwiseClone();
        }
    }
}

```

`WzComparerR2.Common/Class1.cs`:

```cs
namespace WzComparerR2.Common
{
    public class Class1
    {
    }
}
```

`WzComparerR2.Common/Config/ConfigArrayList.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Configuration;

namespace WzComparerR2.Config
{
    public class ConfigArrayList<T> : ConfigurationElementCollection, IEnumerable<T>
    {
        public T this[int index]
        {
            get { return ((ItemElement)base.BaseGet(index)).Value; }
            set
            {
                base.BaseRemoveAt(index);
                base.BaseAdd(index, new ItemElement() { Value = value });
            }
        }

        public void Add(T item)
        {
            base.BaseAdd(new ItemElement() { Value = item }, false);
        }

        public void Insert(int index, T item)
        {
            base.BaseAdd(index, new ItemElement() { Value = item });
        }

        public void RemoveAt(int index)
        {
            base.BaseRemoveAt(index);
        }

        public bool Remove(T item)
        {
            int index = this.IndexOf(item);
            if (index > -1)
            {
                base.BaseRemoveAt(index);
                return true;
            }
            return false;
        }

        public int IndexOf(T item)
        {
            var elem = this.OfType<ItemElement>().FirstOrDefault(e => object.Equals(e.Value, item));
            int index = elem == null ? -1 : base.BaseIndexOf(elem);
            return index;
        }

        public void Clear()
        {
            base.BaseClear();
        }

        protected override ConfigurationElement CreateNewElement()
        {
            return new ItemElement();
        }

        protected override object GetElementKey(ConfigurationElement element)
        {
            return element;
        }

        public new IEnumerator<T> GetEnumerator()
        {
            return this.OfType<ItemElement>().Select(elem => elem.Value).GetEnumerator();
        }

        protected override string ElementName
        {
            get { return "item"; }
        }

        public class ItemElement : ConfigurationElement
        {
            public ItemElement()
            {
                this.Hash = Guid.NewGuid();
            }

            [ConfigurationProperty("hash", IsRequired = true)]
            public Guid Hash
            {
                get { return (Guid)this["hash"]; }
                set { this["hash"] = value; }
            }

            [ConfigurationProperty("value", IsRequired = true)]
            public T Value
            {
                get { return (T)this["value"]; }
                set { this["value"] = value; }
            }
        }
    }
}

```

`WzComparerR2.Common/Config/ConfigItem.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Configuration;

namespace WzComparerR2.Config
{
    public class ConfigItem<T> : ConfigurationElement
    {
        [ConfigurationProperty("value", IsRequired = true)]
        public T Value
        {
            get { return (T)this["value"]; }
            set { this["value"] = value; }
        }

        public static implicit operator T(ConfigItem<T> item)
        {
            return item.Value;
        }

        public static implicit operator ConfigItem<T>(T item)
        {
            return new ConfigItem<T>() { Value = item };
        }

        public override string ToString()
        {
            return nameof(ConfigItem<T>) + " [" + this.Value + "]";
        }
    }
}

```

`WzComparerR2.Common/Config/ConfigItemCollectionBase.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Configuration;

namespace WzComparerR2.Config
{
    public class ConfigItemCollectionBase<T> : ConfigurationElementCollection
        where T : ConfigurationElement, new()
    {
        
        public T this[int index]
        {
            get { return (T)base.BaseGet(index); }
            set
            {
                base.BaseRemoveAt(index);
                base.BaseAdd(index, value);
            }
        }

        public void Add(T item)
        {
            base.BaseAdd(item, false);
        }

        public void Insert(int index, T item)
        {
            base.BaseAdd(index, item);
        }

        public void RemoveAt(int index)
        {
            base.BaseRemoveAt(index);
        }

        public void Remove(T item)
        {
            int index = base.BaseIndexOf(item);
            if (index > -1)
            {
                base.BaseRemoveAt(index);
            }
        }

        public void Clear()
        {
            base.BaseClear();
        }

        protected override ConfigurationElement CreateNewElement()
        {
            return new T();
        }

        protected override object GetElementKey(ConfigurationElement element)
        {
            return element;
        }
    }
}

```

`WzComparerR2.Common/Config/ConfigManager.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Configuration;
using System.IO;
using System.Windows.Forms;
using System.Reflection;
using System.Runtime.CompilerServices;

namespace WzComparerR2.Config
{
    public static class ConfigManager
    {
        public static string ConfigFileName
        {
            get { return Path.Combine(Application.StartupPath, "Setting.config"); }
        }

        public static Configuration ConfigFile
        {
            get { return _configFile = (_configFile ?? Open()); }
        }

        private static Configuration _configFile;

        private static Configuration Open()
        {
            var configFile = ConfigurationManager.OpenMappedMachineConfiguration(
                new ConfigurationFileMap()
                {
                    MachineConfigFilename = ConfigFileName
                });

            return configFile;
        }

        public static void Reload()
        {
            _configFile = Open();
        }

        public static void Save()
        {
            _configFile?.Save(ConfigurationSaveMode.Full);
        }

        public static bool RegisterSection<T>() where T : ConfigSectionBase<T>, new()
        {
            return RegisterSection(typeof(T));
        }

        public static bool RegisterSection(Type type)
        {
            if (type == null || !type.IsSubclassOf(typeof(ConfigSectionBase<>).MakeGenericType(type)))
            {
                throw new ArgumentException($"类型{type}没有继承于{typeof(ConfigSectionBase<>)}。");
            }

            string secName = GetSectionName(type);
          
            if (ConfigFile.GetSection(secName) == null)
            {
                ConfigFile.Sections.Add(secName, Activator.CreateInstance(type) as ConfigurationSection);
                var section = ConfigFile.GetSection(secName);
                return true;
            }
            return false;
        }

        /// <summary>
        /// 对此方法的调用不应为尾调用, 否则<see cref="Assembly.GetCallingAssembly"/>会因尾调用优化出错.
        /// </summary>
        /// <seealso cref="https://docs.microsoft.com/en-us/dotnet/api/system.reflection.assembly.getcallingassembly?redirectedfrom=MSDN&view=netcore-3.1#System_Reflection_Assembly_GetCallingAssembly"/>
        public static void RegisterAllSection()
        {
            var asm = Assembly.GetCallingAssembly();
            var secTypes = asm.GetExportedTypes().Where(type => {
                try
                {
                    var baseType = type.BaseType;
                    return baseType != null && baseType.IsGenericType && baseType.GetGenericTypeDefinition() == typeof(ConfigSectionBase<>);
                }
                catch
                {
                    return false;
                }
            });
            bool needSave = false;
            foreach (var type in secTypes)
            {
                needSave |= RegisterSection(type);
            }

            if (needSave)
            {
                Save();
            }
        }

        public static string GetSectionName(Type type)
        {
            var attrList = type.GetCustomAttributes(typeof(SectionNameAttribute), false).OfType<SectionNameAttribute>();
            return attrList.Select(attr => attr.Name).FirstOrDefault(secName => !string.IsNullOrEmpty(secName)) ?? type.Name;
        }
    }
}

```

`WzComparerR2.Common/Config/ConfigSectionBase.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Configuration;
using System.Reflection;

namespace WzComparerR2.Config
{
    public abstract class ConfigSectionBase<T> : ConfigurationSection
        where T : ConfigSectionBase<T>, new()
    {
        public static T Default
        {
            get
            {
                string secName = ConfigManager.GetSectionName(typeof(T));
                try
                {
                    return ConfigManager.ConfigFile.GetSection(secName) as T;
                }
                catch (ConfigurationErrorsException e)
                {
                    ConfigManager.Reload();
                    return ConfigManager.ConfigFile.GetSection(secName) as T;
                }
            }
        }
    }
}

```

`WzComparerR2.Common/Config/SectionNameAttribute.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace WzComparerR2.Config
{
    public sealed class SectionNameAttribute : Attribute
    {
        public SectionNameAttribute(string sectionName)
        {
            this.Name = sectionName;
        }

        public string Name { get; set; }
    }
}

```

`WzComparerR2.Common/Controls/AlphaForm.cs`:

```cs
using System;
using System.Windows.Forms;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Drawing.Imaging;

namespace WzComparerR2.Controls
{
    public class AlphaForm : PerPixelAlphaForm
    {
        public AlphaForm()
        {
            TopMost = true;
            //TopLevel = false;
            ShowInTaskbar = false;
            Visible = true;
            AutoSize = false;
            MaximizeBox = false;
            MinimizeBox = false;
            HideOnHover = false;
        }

        private bool hideOnHover;
        private Rectangle captionRectangle;
        private Bitmap bitmap;

        /// <summary>
        /// 获取或设置一个值，表示窗体是否在鼠标滑过时自动隐藏。
        /// </summary>
        public bool HideOnHover
        {
            get { return hideOnHover; }
            set { hideOnHover = value; }
        }

        /// <summary>
        /// 获取或设置一个Rectangle，表示窗体的虚拟标题栏区域。
        /// </summary>
        public Rectangle CaptionRectangle
        {
            get { return captionRectangle; }
            set { captionRectangle = value; }
        }

        protected override void WndProc(ref Message m)
        {
            switch (m.Msg)
            {
                case 0x0084: /*WM_NCHITTEST*/
                    if (!hideOnHover)
                    {
                        Point hitPoint = this.PointToClient(new Point((int)m.LParam));
                        if (captionHitTest(hitPoint))
                        {
                            m.Result = (IntPtr)2; //HTCAPTION
                            return;
                        }
                    }
                    else
                    {
                        m.Msg = 0x0018; /*WM_SHOWWINDOW*/
                        m.WParam = (IntPtr)0;
                        break;
                    }
                    break;

                case 0x00A5: /*WM_NCRBUTTONUP*/
                    {
                        Point hitPoint = this.PointToClient(new Point((int)m.LParam));
                        this.OnMouseClick(new MouseEventArgs(System.Windows.Forms.MouseButtons.Right, 1, hitPoint.X, hitPoint.Y, 0));
                    }
                    return;

                case 0x00A3: /*WM_NCLBUTTONDBLCLK*/ //防止双击最大化
                    return;
            }
            
            base.WndProc(ref m);
        }

        protected override void OnKeyDown(KeyEventArgs e)
        {
            base.OnKeyDown(e);
        }

        protected override void OnFormClosing(FormClosingEventArgs e)
        {
            if (e.CloseReason == System.Windows.Forms.CloseReason.UserClosing)
            {
                e.Cancel = true;
                this.Hide();
                return;
            }
            base.OnFormClosing(e);
        }

        protected virtual bool captionHitTest(Point point)
        {
            return this.captionRectangle.Contains(point);
        }

        public Bitmap Bitmap
        {
            get { return bitmap; }
            set { bitmap = value; }
        }
    }

    public class PerPixelAlphaForm : Form
    {
        public PerPixelAlphaForm()
        {
            // This form should not have A border or else Windows will clip it.
            FormBorderStyle = FormBorderStyle.None;
        }

        /// <para>Changes the current Bitmap.</para>
        public void SetBitmap(Bitmap bitmap)
        {
            SetBitmap(bitmap, 255);
        }

        /// <para>Changes the current Bitmap with A custom opacity Level.  Here is where all happens!</para>
        public void SetBitmap(Bitmap bitmap, byte opacity)
        {
            if (bitmap.PixelFormat != PixelFormat.Format32bppArgb)
                throw new ApplicationException("The bitmap must be 32ppp with alpha-channel.");

            // The ideia of this is very simple,
            // 1. Create A compatible DC with screen;
            // 2. Select the Bitmap with 32bpp with alpha-channel in the compatible DC;
            // 3. Call the UpdateLayeredWindow.

            IntPtr screenDc = Win32.GetDC(IntPtr.Zero);
            IntPtr memDc = Win32.CreateCompatibleDC(screenDc);
            IntPtr hBitmap = IntPtr.Zero;
            IntPtr oldBitmap = IntPtr.Zero;

            try
            {
                hBitmap = bitmap.GetHbitmap(Color.FromArgb(0));  // grab A GDI handle from this GDI+ Bitmap
                oldBitmap = Win32.SelectObject(memDc, hBitmap);

                Win32.Size size = new Win32.Size(bitmap.Width, bitmap.Height);
                Win32.Point pointSource = new Win32.Point(0, 0);
                Win32.Point topPos = new Win32.Point(Left, Top);
                Win32.BLENDFUNCTION blend = new Win32.BLENDFUNCTION();
                blend.BlendOp = Win32.AC_SRC_OVER;
                blend.BlendFlags = 0;
                blend.SourceConstantAlpha = opacity;
                blend.AlphaFormat = Win32.AC_SRC_ALPHA;

                Win32.UpdateLayeredWindow(Handle, screenDc, ref topPos, ref size, memDc, ref pointSource, 0, ref blend, Win32.ULW_ALPHA);
                //if (this.AutoSize)
                //  this.Size = bitmap.Size;
            }
            finally
            {
                Win32.ReleaseDC(IntPtr.Zero, screenDc);
                if (hBitmap != IntPtr.Zero)
                {
                    Win32.SelectObject(memDc, oldBitmap);
                    //Windows.DeleteObject(hBitmap); // The documentation says that we have to use the Windows.DeleteObject... but since there is no such method I use the Normal DeleteObject from Win32 GDI and it's working fine without any resource leak.
                    Win32.DeleteObject(hBitmap);
                }
                Win32.DeleteDC(memDc);
            }
        }


        protected override CreateParams CreateParams
        {
            get
            {
                CreateParams cp = base.CreateParams;
                cp.ExStyle |= 0x00080000; // This form has to have the WS_EX_LAYERED extended style
                return cp;
            }
        }
    }

    class Win32
    {
        public enum Bool
        {
            False = 0,
            True
        };

        [StructLayout(LayoutKind.Sequential)]
        public struct Point
        {
            public Int32 x;
            public Int32 y;

            public Point(Int32 x, Int32 y) { this.x = x; this.y = y; }
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct Size
        {
            public Int32 cx;
            public Int32 cy;

            public Size(Int32 cx, Int32 cy) { this.cx = cx; this.cy = cy; }
        }

        [StructLayout(LayoutKind.Sequential, Pack = 1)]
        public struct BLENDFUNCTION
        {
            public byte BlendOp;
            public byte BlendFlags;
            public byte SourceConstantAlpha;
            public byte AlphaFormat;
        }

        public const Int32 ULW_COLORKEY = 0x00000001;
        public const Int32 ULW_ALPHA = 0x00000002;
        public const Int32 ULW_OPAQUE = 0x00000004;

        public const byte AC_SRC_OVER = 0x00;
        public const byte AC_SRC_ALPHA = 0x01;

        [DllImport("user32.dll", ExactSpelling = true, SetLastError = true)]
        public static extern Bool UpdateLayeredWindow(IntPtr hwnd, IntPtr hdcDst, ref Point pptDst, ref Size psize, IntPtr hdcSrc, ref Point pprSrc, Int32 crKey, ref BLENDFUNCTION pblend, Int32 dwFlags);

        [DllImport("user32.dll", ExactSpelling = true, SetLastError = true)]
        public static extern IntPtr GetDC(IntPtr hWnd);

        [DllImport("user32.dll", ExactSpelling = true)]
        public static extern int ReleaseDC(IntPtr hWnd, IntPtr hDC);

        [DllImport("gdi32.dll", ExactSpelling = true, SetLastError = true)]
        public static extern IntPtr CreateCompatibleDC(IntPtr hDC);

        [DllImport("gdi32.dll", ExactSpelling = true, SetLastError = true)]
        public static extern Bool DeleteDC(IntPtr hdc);

        [DllImport("gdi32.dll", ExactSpelling = true)]
        public static extern IntPtr SelectObject(IntPtr hDC, IntPtr hObject);

        [DllImport("gdi32.dll", ExactSpelling = true, SetLastError = true)]
        public static extern Bool DeleteObject(IntPtr hObject);
    }
}

```

`WzComparerR2.Common/Controls/AnimationClipOptions.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.Xna.Framework;

namespace WzComparerR2.Controls
{
    public class AnimationClipOptions
    {
        public int? StartTime { get; set; }
        public int? StopTime { get; set; }

        public int? Left { get; set; }
        public int? Top { get; set; }
        public int? Right { get; set; }
        public int? Bottom { get; set; }

        public int? OutputWidth { get; set; }
        public int? OutputHeight { get; set; }
    }
}

```

`WzComparerR2.Common/Controls/AnimationControl.Designer.cs`:

```cs
namespace WzComparerR2.Controls
{
    partial class AnimationControl
    {
        /// <summary> 
        /// 必需的设计器变量。
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary> 
        /// 清理所有正在使用的资源。
        /// </summary>
        /// <param name="disposing">如果应释放托管资源，为 true；否则为 false。</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region 组件设计器生成的代码

        /// <summary> 
        /// 设计器支持所需的方法 - 不要修改
        /// 使用代码编辑器修改此方法的内容。
        /// </summary>
        private void InitializeComponent()
        {
            components = new System.ComponentModel.Container();
        }

        #endregion
    }
}

```

`WzComparerR2.Common/Controls/AnimationControl.cs`:

```cs
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Text;
using System.Diagnostics;
using System.Windows.Forms;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using WzComparerR2.Animation;
using WzComparerR2.Rendering;

using Point = Microsoft.Xna.Framework.Point;

namespace WzComparerR2.Controls
{
    public partial class AnimationControl : GraphicsDeviceControl
    {
        public AnimationControl()
        {
            InitializeComponent();
            this.MouseDown += AnimationControl_MouseDown;
            this.MouseUp += AnimationControl_MouseUp;
            this.MouseMove += AnimationControl_MouseMove;
            this.MouseWheel += AnimationControl_MouseWheel;

            this.Items = new List<AnimationItem>();
            this.MouseDragEnabled = true;
            this.GlobalScale = 1f;

            this.timer = new System.Windows.Forms.Timer();
            timer.Interval = 30;
            timer.Tick += Timer_Tick;
            timer.Enabled = true;
            this.sw = Stopwatch.StartNew();
        }

        public List<AnimationItem> Items { get; private set; }
        public bool MouseDragEnabled { get; set; }
        public bool MouseDragSaveEnabled { get; set; }
        public bool ShowPositionGridOnDrag { get; set; }

        public float GlobalScale
        {
            get { return this.globalScale; }
            set { this.globalScale = MathHelper.Clamp(value, 0.1f, 10f); }
        }

        public bool IsPlaying
        {
            get { return this.timer.Enabled; }
            set
            {
                if (value)
                {
                    this.lastUpdateTime = TimeSpan.Zero;
                    this.sw.Restart();
                }
                this.timer.Enabled = value;
            }
        }

        public int FrameInterval
        {
            get { return this.timer.Interval; }
            set { this.timer.Interval = value; }
        }

        private float globalScale;
        private System.Windows.Forms.Timer timer;
        private Stopwatch sw;
        private TimeSpan lastUpdateTime;

        private SpriteBatchEx sprite;
        private AnimationGraphics graphics;

        //拖拽相关
        private MouseDragContext mouseDragContext;

        //离屏绘制相关

        protected override void Initialize()
        {
            sprite = new SpriteBatchEx(this.GraphicsDevice);
            graphics = new AnimationGraphics(this.GraphicsDevice, sprite);
        }

        protected virtual void Update(TimeSpan elapsed)
        {
            foreach (var animation in this.Items)
            {
                if (animation != null)
                {
                    animation.Update(elapsed);
                }
            }
        }

        public virtual void DrawBackground()
        {
            this.GraphicsDevice.Clear(this.BackColor.ToXnaColor());
        }

        protected override void Draw()
        {
            //绘制背景色
            this.DrawBackground();
            //绘制场景
            foreach (var animation in this.Items)
            {
                if (animation != null)
                {
                    Matrix mt = Matrix.CreateRotationZ(MathHelper.PiOver2)
                        * Matrix.CreateTranslation(100, 100, 0);

                    mt = Matrix.CreateScale(GlobalScale, GlobalScale, 1);

                    if (animation is FrameAnimator frameAni)
                    {
                        graphics.Draw(frameAni, mt);
                    }
                    else if (animation is ISpineAnimator spineAni)
                    {
                        graphics.Draw(spineAni, mt);
                    }
                }
            }

            //绘制辅助内容
            if (ShowPositionGridOnDrag && this.mouseDragContext.IsDragging && this.mouseDragContext.DraggingItem != null)
            {
                var pos = this.mouseDragContext.DraggingItem.Position;
                this.sprite.Begin();
                this.sprite.DrawLine(new Point(0, pos.Y), new Point(this.Width, pos.Y), 1, Microsoft.Xna.Framework.Color.Indigo);
                this.sprite.DrawLine(new Point(pos.X, 0), new Point(pos.X, this.Height), 1, Microsoft.Xna.Framework.Color.Indigo);
                this.sprite.End();
            }
        }

        public virtual AnimationItem GetItemAt(int x, int y)
        {
            for(int i = this.Items.Count - 1; i >= 0; i--)
            {
                var item = this.Items[i];
                var bound = item.Measure();
                var rect = new Microsoft.Xna.Framework.Rectangle(
                    (int)Math.Round(item.Position.X + bound.X* this.GlobalScale),
                    (int)Math.Round(item.Position.Y + bound.Y * this.GlobalScale),
                    (int)Math.Round(bound.Width * this.GlobalScale),
                    (int)Math.Round(bound.Height * this.GlobalScale));
                if (rect.Contains(x, y))
                {
                    return item;
                }
            }
            return null;
        }

        #region EVENTS
        protected virtual void OnItemDragSave(AnimationItemEventArgs e)
        {

        }


        private void AnimationControl_MouseDown(object sender, MouseEventArgs e)
        {
            this.Focus();

            if (this.MouseDragEnabled && e.Button == MouseButtons.Left)
            {
                var item = GetItemAt(e.X, e.Y);
                if (item != null)
                {
                    this.mouseDragContext.IsDragging = true;
                    this.mouseDragContext.MouseDownPoint = new Point(e.X, e.Y);
                    this.mouseDragContext.DraggingItem = item;
                    this.mouseDragContext.StartPosition = item.Position;
                }
            }
            if ((Control.ModifierKeys & Keys.Control) != 0 && e.Button == MouseButtons.Middle)
            {
                this.GlobalScale = 1f;
            }
        }

        private void AnimationControl_MouseUp(object sender, MouseEventArgs e)
        {
            if (this.MouseDragEnabled && e.Button == MouseButtons.Left)
            {
                this.mouseDragContext.IsDragging = false;
            }
        }

        private void AnimationControl_MouseMove(object sender, MouseEventArgs e)
        {
            if (this.MouseDragEnabled && this.mouseDragContext.IsDragging && this.mouseDragContext.DraggingItem != null)
            {
                this.mouseDragContext.DraggingItem.Position = new Point(
                    e.X - mouseDragContext.MouseDownPoint.X + mouseDragContext.StartPosition.X,
                    e.Y - mouseDragContext.MouseDownPoint.Y + mouseDragContext.StartPosition.Y);

                //处理拖拽保存
                if (this.MouseDragSaveEnabled && (Control.ModifierKeys & Keys.Control) != 0)
                {
                    var dragSize = SystemInformation.DragSize;
                    var dragBox = new Microsoft.Xna.Framework.Rectangle(mouseDragContext.MouseDownPoint, new Point(dragSize.Width, dragSize.Height));
                    if (!dragBox.Contains(new Point(e.X, e.Y)))
                    {
                        var e2 = new AnimationItemEventArgs(this.mouseDragContext.DraggingItem);
                        this.OnItemDragSave(e2);
                        if (e2.Handled)
                        {
                            this.mouseDragContext.IsDragging = false;
                        }
                    }
                }
            }
        }

        private void AnimationControl_MouseWheel(object sender, MouseEventArgs e)
        {
            const int WHEEL_DELTA = 120;
            if ((Control.ModifierKeys & Keys.Control) != 0)
            {
                float wheelTicks = e.Delta / WHEEL_DELTA;
                float oldScale = this.GlobalScale;
                float newScale = oldScale * (1 + 0.1f * wheelTicks);
                if (oldScale.CompareTo(1f) * newScale.CompareTo(1f) == -1) // scaling cross 100%
                {
                    newScale = 1f;
                }
                this.GlobalScale = newScale;
            }
        }

        private void Timer_Tick(object sender, EventArgs e)
        {
            var curTime = sw.Elapsed;
            var elapsed = curTime - lastUpdateTime;
            lastUpdateTime = curTime;

            if (this.Visible)
            {
                this.Update(elapsed);
                this.Invalidate();
            }
        }
        #endregion

        private struct MouseDragContext
        {
            public bool IsDragging;
            public Point MouseDownPoint;
            public Point StartPosition;
            public AnimationItem DraggingItem;
        }
    }
}

```

`WzComparerR2.Common/Controls/AnimationItem.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.Xna.Framework;
using Rectangle = Microsoft.Xna.Framework.Rectangle;
using Point = Microsoft.Xna.Framework.Point;

namespace WzComparerR2.Controls
{
    public abstract class AnimationItem : ICloneable
    {
        public Point Position { get; set; }

        public virtual int Length
        {
            get { return 0; }
        }

        public abstract void Update(TimeSpan elapsed);

        public virtual Rectangle Measure()
        {
            return Rectangle.Empty;
        }

        public virtual void Reset()
        {

        }

        public virtual object Clone()
        {
            var aniItem = (AnimationItem)base.MemberwiseClone();
            aniItem.Reset();
            return aniItem;
        }
    }
}

```

`WzComparerR2.Common/Controls/AnimationItemEventArgs.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace WzComparerR2.Controls
{
    public class AnimationItemEventArgs
    {
        public AnimationItemEventArgs(AnimationItem item)
        {
            this.Item = item;
        }

        /// <summary>
        /// 事件相关联的AnimationItem。
        /// </summary>
        public AnimationItem Item { get; private set; }
        public bool Handled { get; set; }
    }
}

```

`WzComparerR2.Common/Controls/AnimationRecoder.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using WzComparerR2.Rendering;
using WzComparerR2.Animation;
using Point =Microsoft.Xna.Framework.Point;
using Rectangle=Microsoft.Xna.Framework.Rectangle;
using Color =Microsoft.Xna.Framework.Color;

namespace WzComparerR2.Controls
{
    public class AnimationRecoder
    {
        public AnimationRecoder(GraphicsDevice graphicsDevice)
        {
            this._device = graphicsDevice;
            this._graphics = new AnimationGraphics(_device);
            this.Items = new List<AnimationItem>();
            this.BackgroundColor = Color.Transparent;
        }

        public List<AnimationItem> Items { get; private set; }

        public System.Drawing.Color GdipBackgroundColor
        {
            get
            {
                var c = this.BackgroundColor;
                return System.Drawing.Color.FromArgb(c.A, c.R, c.G, c.B);
            }
            set
            {
                this.BackgroundColor = value.ToXnaColor();
            }
        }

        public Microsoft.Xna.Framework.Color BackgroundColor { get; set; }

        public Texture2D BackgroundImage { get; set; }

        private GraphicsDevice _device;
        private RenderTargetBinding[] _oldBuffer;
        private RenderTarget2D _rt2d;
        private Rectangle _viewport;
        private Point _targetSize;
        private AnimationGraphics _graphics;
        private SpriteBatch _sb;
        private PngEffect _eff;

        public void Begin(Rectangle viewport, Point? targetSize = null)
        {
            this._targetSize = targetSize ?? viewport.Size;
            _rt2d = new RenderTarget2D(_device, _targetSize.X, _targetSize.Y, false, SurfaceFormat.Bgra32, DepthFormat.None, 0, RenderTargetUsage.PreserveContents);
            var binding = _device.GetRenderTargets();
            _device.SetRenderTarget(_rt2d);

            this._viewport = viewport;
            this._oldBuffer = binding;

            this._sb = new SpriteBatch(_device);
            this._eff = new PngEffect(_device);
        }

        public void Update(TimeSpan elapsed)
        {
            foreach (var aniItem in this.Items)
            {
                aniItem.Update(elapsed);
            }
        }

        public void Draw()
        {
            System.Threading.Monitor.Enter(this._device);
            try
            {
                _device.SetRenderTarget(_rt2d);
                this.DrawAnimation();
            }
            finally
            {
                _device.SetRenderTargets(_oldBuffer);
                System.Threading.Monitor.Exit(this._device);
            }
        }

        private void DrawAnimation()
        {
            if (this.BackgroundImage != null)
            {
                this._device.Clear(Color.Black);
                var rect = new Rectangle(0, 0, _targetSize.X, _targetSize.Y);
                _sb.Begin(blendState: BlendState.Opaque, samplerState: SamplerState.PointWrap);
                _sb.Draw(this.BackgroundImage, Vector2.Zero, rect, Color.White);
                _sb.End();
            }
            else
            {
                this._device.Clear(this.BackgroundColor);
            }

            Matrix world = Matrix.CreateTranslation(-this._viewport.Left, -this._viewport.Top, 0);
            if (_targetSize != _viewport.Size)
            {
                world *= Matrix.CreateScale(
                    1f * _targetSize.X / _viewport.Width,
                    1f * _targetSize.Y / _viewport.Height,
                    1f);
            }

            foreach (var animation in this.Items.Where(_ani => _ani != null))
            {
                if (animation is FrameAnimator framAni)
                {
                    _graphics.Draw(framAni, world);
                }
                else if (animation is ISpineAnimator spineAni)
                {
                    _graphics.Draw(spineAni, world);
                }
            }
        }

        public Texture2D GetPngTexture()
        {
            System.Threading.Monitor.Enter(this._device);
            try
            {
                var texture = new RenderTarget2D(_device, _rt2d.Width, _rt2d.Height, false, SurfaceFormat.Bgra32, DepthFormat.None);
                _device.SetRenderTarget(texture);
                _eff.AlphaMixEnabled = false;

                _device.Clear(Color.Transparent);
                _sb.Begin(SpriteSortMode.Immediate, BlendState.Opaque, SamplerState.LinearClamp, null, null, _eff, null);
                _sb.Draw(_rt2d, Vector2.Zero, Color.White);
                _sb.End();
                return texture;
            }
            finally
            {
                _device.SetRenderTargets(_oldBuffer);
                System.Threading.Monitor.Exit(this._device);
            }
        }

        public Texture2D GetGifTexture(Color mixColor, int minMixedAlpha)
        {
            System.Threading.Monitor.Enter(this._device);
            try
            {
                var texture = new RenderTarget2D(_device, _rt2d.Width, _rt2d.Height, false, SurfaceFormat.Bgra32, DepthFormat.None);
                _device.SetRenderTarget(texture);

                _eff.AlphaMixEnabled = true;
                _eff.MixedColor = mixColor;
                _eff.MinMixedAlpha = minMixedAlpha;

                _device.Clear(Color.Transparent);
                _sb.Begin(SpriteSortMode.Immediate, BlendState.Opaque, SamplerState.LinearClamp, null, null, _eff, null);
                _sb.Draw(_rt2d, Vector2.Zero, Color.White);
                _sb.End();

                return texture;
            }
            finally
            {
                _device.SetRenderTargets(_oldBuffer);
                System.Threading.Monitor.Exit(this._device);
            }
        }

        public void ResetAll()
        {
            foreach (var aniItem in this.Items)
            {
                aniItem.Reset();
            }
        }

        public int GetMaxLength()
        {
            return this.Items.Select(aniItem => Math.Max(0, aniItem.Length)).Max();
        }

        public int[] GetGifTimeLine(int preferredFrameDelay, int? maxFrameDelay = null)
        {
            if (preferredFrameDelay <= 0)
            {
                preferredFrameDelay = 1;
            }
            if (maxFrameDelay != null && maxFrameDelay < preferredFrameDelay)
            {
                maxFrameDelay = preferredFrameDelay;
            }

            // only calculate the first layer
            foreach (var animation in this.Items.Where(_ani => _ani != null))
            {
                if (animation is FrameAnimator frameAni)
                {
                    // we won't skip any frame even frame delay is greater than preferred delay
                    var timeline = new List<int>();
                    int totalLength = 0;
                    foreach (var frame in frameAni.GetKeyFrames())
                    {
                        totalLength += frame.Length;
                        if (frame.Animated)
                        {
                            for (int ms = frame.Length; ms > 0;)
                            {
                                if (ms >= preferredFrameDelay)
                                {
                                    timeline.Add(preferredFrameDelay);
                                    ms -= preferredFrameDelay;
                                }
                                else
                                {
                                    if (timeline.Count > 0)
                                    {
                                        timeline[timeline.Count - 1] += ms;
                                    }
                                    else
                                    {
                                        // duration of the first frame less than minFrameDelay, but we can't simply ignore it.
                                        timeline.Add(ms);
                                    }
                                    ms = 0;
                                }
                            }
                        }
                        else
                        {
                            if (maxFrameDelay != null)
                            {
                                for (int ms = frame.Length; ms > 0;)
                                {
                                    if (ms >= maxFrameDelay.Value)
                                    {
                                        timeline.Add(maxFrameDelay.Value);
                                        ms -= maxFrameDelay.Value;
                                    }
                                    else
                                    {
                                        timeline.Add(ms);
                                        ms = 0;
                                    }
                                }
                            }
                            else
                            {
                                timeline.Add(frame.Length);
                            }
                        }
                    }

                    return timeline.ToArray();
                }
                else if (animation is ISpineAnimator)
                {
                    return null;
                }
            }

            return null;
        }

        public void End()
        {
            var binding = _device.GetRenderTargets();
            _device.SetRenderTargets(_oldBuffer);
            this._device = null;
            this._oldBuffer = null;

            for (int i = 0; i < binding.Length; i++)
            {
                binding[i].RenderTarget.Dispose();
            }

            _eff.Dispose();
            _sb.Dispose();
        }
    }
}

```

`WzComparerR2.Common/Controls/FrmProgressDialog.Designer.cs`:

```cs

namespace WzComparerR2.Controls
{
    partial class FrmProgressDialog
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.tableLayoutPanel1 = new System.Windows.Forms.TableLayoutPanel();
            this.labelX1 = new DevComponents.DotNetBar.LabelX();
            this.progressBarX1 = new DevComponents.DotNetBar.Controls.ProgressBarX();
            this.tableLayoutPanel1.SuspendLayout();
            this.SuspendLayout();
            // 
            // tableLayoutPanel1
            // 
            this.tableLayoutPanel1.ColumnCount = 1;
            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 100F));
            this.tableLayoutPanel1.Controls.Add(this.labelX1, 0, 0);
            this.tableLayoutPanel1.Controls.Add(this.progressBarX1, 0, 1);
            this.tableLayoutPanel1.Dock = System.Windows.Forms.DockStyle.Fill;
            this.tableLayoutPanel1.Location = new System.Drawing.Point(0, 0);
            this.tableLayoutPanel1.Name = "tableLayoutPanel1";
            this.tableLayoutPanel1.RowCount = 2;
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent, 50F));
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent, 50F));
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Absolute, 20F));
            this.tableLayoutPanel1.Size = new System.Drawing.Size(284, 51);
            this.tableLayoutPanel1.TabIndex = 0;
            // 
            // labelX1
            // 
            this.labelX1.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
            | System.Windows.Forms.AnchorStyles.Left) 
            | System.Windows.Forms.AnchorStyles.Right)));
            // 
            // 
            // 
            this.labelX1.BackgroundStyle.CornerType = DevComponents.DotNetBar.eCornerType.Square;
            this.labelX1.Location = new System.Drawing.Point(3, 3);
            this.labelX1.Name = "labelX1";
            this.labelX1.Size = new System.Drawing.Size(278, 19);
            this.labelX1.TabIndex = 0;
            this.labelX1.Text = "Message";
            // 
            // progressBarX1
            // 
            this.progressBarX1.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
            | System.Windows.Forms.AnchorStyles.Left) 
            | System.Windows.Forms.AnchorStyles.Right)));
            // 
            // 
            // 
            this.progressBarX1.BackgroundStyle.CornerType = DevComponents.DotNetBar.eCornerType.Square;
            this.progressBarX1.Location = new System.Drawing.Point(3, 28);
            this.progressBarX1.Name = "progressBarX1";
            this.progressBarX1.Size = new System.Drawing.Size(278, 20);
            this.progressBarX1.TabIndex = 1;
            this.progressBarX1.Text = "progressBarX1";
            // 
            // FrmProgressDialog
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 12F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(284, 51);
            this.Controls.Add(this.tableLayoutPanel1);
            this.DoubleBuffered = true;
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedToolWindow;
            this.MaximizeBox = false;
            this.MinimizeBox = false;
            this.Name = "FrmProgressDialog";
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
            this.Text = "Processing";
            this.tableLayoutPanel1.ResumeLayout(false);
            this.ResumeLayout(false);

        }

        #endregion

        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel1;
        private DevComponents.DotNetBar.LabelX labelX1;
        private DevComponents.DotNetBar.Controls.ProgressBarX progressBarX1;
    }
}
```

`WzComparerR2.Common/Controls/FrmProgressDialog.cs`:

```cs
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Windows.Forms;

namespace WzComparerR2.Controls
{
    public partial class FrmProgressDialog : DevComponents.DotNetBar.Office2007Form
    {
        public FrmProgressDialog()
        {
            InitializeComponent();
        }

        public string Message
        {
            get { return this.labelX1.Text; }
            set { this.labelX1.Text = value; }
        }

        public int Progress
        {
            get { return this.progressBarX1.Value; }
            set { this.progressBarX1.Value = value; }
        }

        public int ProgressMin
        {
            get { return this.progressBarX1.Minimum; }
            set { this.progressBarX1.Minimum = value; }
        }

        public int ProgressMax
        {
            get { return this.progressBarX1.Maximum; }
            set { this.progressBarX1.Maximum = value; }
        }
    }
}

```

`WzComparerR2.Common/Controls/FrmProgressDialog.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`WzComparerR2.Common/Controls/GraphicsDeviceControl.cs`:

```cs
#region File Description
//-----------------------------------------------------------------------------
// GraphicsDeviceControl.cs
//
// Microsoft XNA Community Game Platform
// Copyright (C) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#endregion

#region Using Statements
using System;
using System.Drawing;
using System.Reflection;
using System.Windows.Forms;
using Microsoft.Xna.Framework.Graphics;
#endregion

namespace WzComparerR2.Controls
{
    // System.Drawing and the XNA Framework both define Color and Rectangle
    // types. To avoid conflicts, we specify exactly which ones to use.
    using Color = System.Drawing.Color;
    using Rectangle = Microsoft.Xna.Framework.Rectangle;


    /// <summary>
    /// Custom control uses the XNA Framework GraphicsDevice to render onto
    /// a Windows Form. Derived classes can override the Initialize and Draw
    /// methods to add their own drawing code.
    /// </summary>
    abstract public class GraphicsDeviceControl : Control
    {
        #region Fields


        // However many GraphicsDeviceControl instances you have, they all share
        // the same underlying GraphicsDevice, managed by this helper service.
        GraphicsDeviceService graphicsDeviceService;
        SwapChainRenderTarget swapChainRT;

        #endregion

        #region Properties


        /// <summary>
        /// Gets a GraphicsDevice that can be used to draw onto this control.
        /// </summary>
        public GraphicsDevice GraphicsDevice
        {
            get { return graphicsDeviceService.GraphicsDevice; }
        }


        /// <summary>
        /// Gets an IServiceProvider containing our IGraphicsDeviceService.
        /// This can be used with components such as the ContentManager,
        /// which use this service to look up the GraphicsDevice.
        /// </summary>
        public ServiceContainer Services
        {
            get { return services; }
        }

        ServiceContainer services = new ServiceContainer();


        #endregion

        #region Initialization


        /// <summary>
        /// Initializes the control.
        /// </summary>
        protected override void OnCreateControl()
        {
            // Don't initialize the graphics device if we are running in the designer.
            if (!DesignMode)
            {
                this.graphicsDeviceService = GraphicsDeviceService.AddRef(Handle,
                                                                     ClientSize.Width,
                                                                     ClientSize.Height);
                this.swapChainRT = new SwapChainRenderTarget(graphicsDeviceService.GraphicsDevice, this.Handle, ClientSize.Width, ClientSize.Height);
                this.swapChainRT.Disposing += SwapChainRT_Disposing;
                // Register the service, so components like ContentManager can find it.
                services.AddService<IGraphicsDeviceService>(graphicsDeviceService);

                // Give derived classes a chance to initialize themselves.
                Initialize();
            }

            base.OnCreateControl();
        }


        /// <summary>
        /// Disposes the control.
        /// </summary>
        protected override void Dispose(bool disposing)
        {
            if (this.swapChainRT != null && !this.swapChainRT.IsDisposed)
            {
                this.swapChainRT.Dispose();
                this.swapChainRT = null;
            }

            if (this.graphicsDeviceService != null)
            {
                this.graphicsDeviceService.Release(disposing);
                this.graphicsDeviceService = null;
            }

            base.Dispose(disposing);
        }

        private void SwapChainRT_Disposing(object sender, EventArgs e)
        {
            // fix monogame memory leak bug.
            if (sender is SwapChainRenderTarget swapChainRT)
            {
                var backBufferField = sender.GetType().GetField("_backBuffer", BindingFlags.Instance | BindingFlags.NonPublic);
                if (backBufferField != null && backBufferField.GetValue(swapChainRT) is SharpDX.Direct3D11.Resource d3dResource)
                {
                    SharpDX.Utilities.Dispose(ref d3dResource);
                    backBufferField.SetValue(swapChainRT, null);
                }
            }
        }
        #endregion

        #region Paint


        /// <summary>
        /// Redraws the control in response to a WinForms paint message.
        /// </summary>
        protected override void OnPaint(PaintEventArgs e)
        {
            try
            {
                if (!DesignMode)
                {
                    System.Threading.Monitor.Enter(this.GraphicsDevice);
                }

                string beginDrawError = this.BeginDraw();

                if (string.IsNullOrEmpty(beginDrawError))
                {
                    // Draw the control using the GraphicsDevice.
                    Draw();
                    EndDraw();
                }
                else
                {
                    // If BeginDraw failed, show an error message using System.Drawing.
                    PaintUsingSystemDrawing(e.Graphics, beginDrawError);
                }
            }
            finally
            {
                if (!DesignMode)
                {
                    System.Threading.Monitor.Exit(this.GraphicsDevice);
                }
            }
        }

        /// <summary>
        /// Attempts to begin drawing the control. Returns an error message string
        /// if this was not possible, which can happen if the graphics device is
        /// lost, or if we are running inside the Form designer.
        /// </summary>
        string BeginDraw()
        {
            // If we have no graphics device, we must be running in the designer.
            if (graphicsDeviceService == null)
            {
                return Text + "\n\n" + GetType();
            }

            // Make sure the graphics device is big enough, and is not lost.
            string deviceResetError = HandleDeviceReset();

            if (!string.IsNullOrEmpty(deviceResetError))
            {
                return deviceResetError;
            }

            // Many GraphicsDeviceControl instances can be sharing the same
            // GraphicsDevice. The device backbuffer will be resized to fit the
            // largest of these controls. But what if we are currently drawing
            // a smaller control? To avoid unwanted stretching, we set the
            // viewport to only use the top left portion of the full backbuffer.
            Viewport viewport = new Viewport();

            viewport.X = 0;
            viewport.Y = 0;

            viewport.Width = ClientSize.Width;
            viewport.Height = ClientSize.Height;

            viewport.MinDepth = 0;
            viewport.MaxDepth = 1;

            GraphicsDevice.Viewport = viewport;
            GraphicsDevice.PresentationParameters.BackBufferWidth = viewport.Width;
            GraphicsDevice.PresentationParameters.BackBufferHeight = viewport.Height;
            GraphicsDevice.SetRenderTarget(swapChainRT);

            return null;
        }


        /// <summary>
        /// Ends drawing the control. This is called after derived classes
        /// have finished their Draw method, and is responsible for presenting
        /// the finished image onto the screen, using the appropriate WinForms
        /// control handle to make sure it shows up in the right place.
        /// </summary>
        void EndDraw()
        {
            try
            {
                Rectangle sourceRectangle = new Rectangle(0, 0, ClientSize.Width,
                                                                ClientSize.Height);

                //GraphicsDevice.Present(sourceRectangle, null, this.Handle);
                this.swapChainRT.Present();
                GraphicsDevice.SetRenderTarget(null);
            }
            catch
            {
                // Present might throw if the device became lost while we were
                // drawing. The lost device will be handled by the next BeginDraw,
                // so we just swallow the exception.
            }
        }


        /// <summary>
        /// Helper used by BeginDraw. This checks the graphics device status,
        /// making sure it is big enough for drawing the current control, and
        /// that the device is not lost. Returns an error string if the device
        /// could not be reset.
        /// </summary>
        string HandleDeviceReset()
        {
            bool deviceNeedsReset = false;
            var clientSize = this.ClientSize;

            switch (GraphicsDevice.GraphicsDeviceStatus)
            {
                case GraphicsDeviceStatus.Lost:
                    // If the graphics device is lost, we cannot use it at all.
                    return "Graphics device lost";

                case GraphicsDeviceStatus.NotReset:
                    // If device is in the not-reset state, we should try to reset it.
                    deviceNeedsReset = true;
                    break;

                default:
                    // If the device state is ok, check whether it is big enough.
                    PresentationParameters pp = GraphicsDevice.PresentationParameters;

                    deviceNeedsReset = (clientSize.Width != pp.BackBufferWidth) ||
                                       (clientSize.Height != pp.BackBufferHeight);
                    break;
            }

            // Do we need to reset the device?
            if (deviceNeedsReset)
            {
                try
                {
                    this.swapChainRT.Dispose();
                    this.swapChainRT = new SwapChainRenderTarget(
                        this.graphicsDeviceService.GraphicsDevice,
                        this.Handle,
                        clientSize.Width,
                        clientSize.Height);
                    this.swapChainRT.Disposing += SwapChainRT_Disposing;
                }
                catch (Exception e)
                {
                    return "Graphics device reset failed\n\n" + e;
                }
            }

            return null;
        }


        /// <summary>
        /// If we do not have a valid graphics device (for instance if the device
        /// is lost, or if we are running inside the Form designer), we must use
        /// regular System.Drawing method to display a status message.
        /// </summary>
        protected virtual void PaintUsingSystemDrawing(Graphics graphics, string text)
        {
            graphics.Clear(Color.CornflowerBlue);

            using (Brush brush = new SolidBrush(Color.Black))
            {
                using (StringFormat format = new StringFormat())
                {
                    format.Alignment = StringAlignment.Center;
                    format.LineAlignment = StringAlignment.Center;

                    graphics.DrawString(text, Font, brush, ClientRectangle, format);
                }
            }
        }


        /// <summary>
        /// Ignores WinForms paint-background messages. The default implementation
        /// would clear the control to the current background color, causing
        /// flickering when our OnPaint implementation then immediately draws some
        /// other color over the top using the XNA Framework GraphicsDevice.
        /// </summary>
        protected override void OnPaintBackground(PaintEventArgs pevent)
        {
        }


        #endregion

        #region Abstract Methods


        /// <summary>
        /// Derived classes override this to initialize their drawing code.
        /// </summary>
        protected abstract void Initialize();


        /// <summary>
        /// Derived classes override this to draw themselves using the GraphicsDevice.
        /// </summary>
        protected abstract void Draw();


        #endregion
    }
}

```

`WzComparerR2.Common/Controls/GraphicsDeviceService.cs`:

```cs
#region File Description
//-----------------------------------------------------------------------------
// GraphicsDeviceService.cs
//
// Microsoft XNA Community Game Platform
// Copyright (C) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#endregion

#region Using Statements
using System;
using System.Threading;
using Microsoft.Xna.Framework.Graphics;
#endregion

// The IGraphicsDeviceService interface requires a DeviceCreated event, but we
// always just create the device inside our constructor, so we have no place to
// raise that event. The C# compiler warns us that the event is never used, but
// we don't care so we just disable this warning.
#pragma warning disable 67

namespace WzComparerR2.Controls
{
    /// <summary>
    /// Helper class responsible for creating and managing the GraphicsDevice.
    /// All GraphicsDeviceControl instances share the same GraphicsDeviceService,
    /// so even though there can be many controls, there will only ever be a single
    /// underlying GraphicsDevice. This implements the standard IGraphicsDeviceService
    /// interface, which provides notification events for when the device is reset
    /// or disposed.
    /// </summary>
    class GraphicsDeviceService : IGraphicsDeviceService
    {
        #region Fields


        // Singleton device service instance.
        static GraphicsDeviceService singletonInstance;


        // Keep track of how many controls are sharing the singletonInstance.
        static int referenceCount;


        #endregion


        /// <summary>
        /// Constructor is private, because this is a singleton class:
        /// client controls should use the public AddRef method instead.
        /// </summary>
        GraphicsDeviceService(IntPtr windowHandle, int width, int height)
        {
            parameters = new PresentationParameters();

            parameters.BackBufferWidth = Math.Max(width, 1);
            parameters.BackBufferHeight = Math.Max(height, 1);
            parameters.BackBufferFormat = SurfaceFormat.Color;
            parameters.DepthStencilFormat = DepthFormat.Depth24;
            parameters.DeviceWindowHandle = windowHandle;
            parameters.PresentationInterval = PresentInterval.Immediate;
            parameters.IsFullScreen = false;

            graphicsDevice = new GraphicsDevice(GraphicsAdapter.DefaultAdapter,
                                                GraphicsProfile.HiDef,
                                                parameters);
        }


        /// <summary>
        /// Gets a reference to the singleton instance.
        /// </summary>
        public static GraphicsDeviceService AddRef(IntPtr windowHandle,
                                                   int width, int height)
        {
            // Increment the "how many controls sharing the device" reference count.
            if (Interlocked.Increment(ref referenceCount) == 1)
            {
                // If this is the first control to start using the
                // device, we must create the singleton instance.
                singletonInstance = new GraphicsDeviceService(IntPtr.Zero, 1, 1);
            }

            return singletonInstance;
        }


        /// <summary>
        /// Releases a reference to the singleton instance.
        /// </summary>
        public void Release(bool disposing)
        {
            // Decrement the "how many controls sharing the device" reference count.
            if (Interlocked.Decrement(ref referenceCount) == 0)
            {
                // If this is the last control to finish using the
                // device, we should dispose the singleton instance.
                if (disposing)
                {
                    if (DeviceDisposing != null)
                        DeviceDisposing(this, EventArgs.Empty);

                    graphicsDevice.Dispose();
                }

                graphicsDevice = null;
            }
        }


        /// <summary>
        /// Resets the graphics device to whichever is bigger out of the specified
        /// resolution or its current size. This behavior means the device will
        /// demand-grow to the largest of all its GraphicsDeviceControl clients.
        /// </summary>
        public void ResetDevice(int width, int height)
        {
            if (DeviceResetting != null)
                DeviceResetting(this, EventArgs.Empty);

            parameters.BackBufferWidth = Math.Max(1, width);
            parameters.BackBufferHeight = Math.Max(1, height);

            graphicsDevice.Reset(parameters);

            if (DeviceReset != null)
                DeviceReset(this, EventArgs.Empty);
        }


        /// <summary>
        /// Gets the current graphics device.
        /// </summary>
        public GraphicsDevice GraphicsDevice
        {
            get { return graphicsDevice; }
        }

        GraphicsDevice graphicsDevice;


        // Store the current device settings.
        PresentationParameters parameters;


        // IGraphicsDeviceService events.
        public event EventHandler<EventArgs> DeviceCreated;
        public event EventHandler<EventArgs> DeviceDisposing;
        public event EventHandler<EventArgs> DeviceReset;
        public event EventHandler<EventArgs> DeviceResetting;
    }
}

```

`WzComparerR2.Common/Controls/ProgressDialog.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace WzComparerR2.Controls
{
    public static class ProgressDialog
    {
        public static DialogResult Show(IWin32Window owner, string text, string caption, bool closeOnComplete, bool closeOnError, Func<IProgressDialogContext, CancellationToken, Task> factory)
        {
            return new ProgressDialogContext(text, caption, closeOnComplete, closeOnError, factory).ShowDialog(owner);
        }
    }
}

```

`WzComparerR2.Common/Controls/ProgressDialogContext.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows.Forms;
using System.Threading;
using System.Threading.Tasks;

namespace WzComparerR2.Controls
{
    public interface IProgressDialogContext
    {
        string Message { get; set; }
        int Progress { get; set; }
        int ProgressMin { get; set; }
        int ProgressMax { get; set; }
    }

    internal class ProgressDialogContext : IProgressDialogContext
    {
        internal ProgressDialogContext(
            string text,
            string caption,
            bool closeOnComplete,
            bool closeOnError,
            Func<ProgressDialogContext, CancellationToken, Task> factory)
        {
            this.dialog = new FrmProgressDialog();
            if (caption != null)
            {
                this.dialog.Text = caption;
            }
            if (text != null)
            {
                this.dialog.Message = text;
            }
            this.cancellationTokenSource = new CancellationTokenSource();
            this.closeOnComplete = closeOnComplete;
            this.closeOnError = closeOnError;
            this.factory = factory;
        }

        public string Message
        {
            get { return this.dialog.Message; }
            set { this.dialog.Message = value; }
        }

        public int Progress
        {
            get { return this.dialog.Progress; }
            set { this.dialog.Progress = value; }
        }

        public int ProgressMin
        {
            get { return this.dialog.ProgressMin; }
            set { this.dialog.ProgressMin = value; }
        }

        public int ProgressMax
        {
            get { return this.dialog.ProgressMax; }
            set { this.dialog.ProgressMax = value; }
        }

        private readonly FrmProgressDialog dialog;
        private readonly CancellationTokenSource cancellationTokenSource;
        private readonly bool closeOnComplete;
        private readonly bool closeOnError;
        private readonly Func<ProgressDialogContext, CancellationToken, Task> factory;

        private DialogResult dialogResult;

        internal DialogResult ShowDialog(IWin32Window owner)
        {
            this.dialog.Load += Dialog_Load;
            this.dialog.FormClosing += Dialog_FormClosing;
            this.dialogResult = DialogResult.None;
            dialog.ShowDialog(owner);
            return this.dialogResult;
        }

        private async void Dialog_Load(object sender, EventArgs e)
        {
            try
            {
                if (this.factory != null)
                {
                    await this.factory(this, this.cancellationTokenSource.Token);
                }
                this.dialog.FormClosing -= Dialog_FormClosing;
                this.dialogResult = DialogResult.OK;
                if (this.closeOnComplete)
                {
                    this.dialog.Close();
                }
            }
            catch
            {
                this.OnCancel();
                if (this.closeOnError)
                {
                    this.dialog.Close();
                }
            }
        }

        private void Dialog_FormClosing(object sender, FormClosingEventArgs e)
        {
            this.OnCancel();
        }

        private void OnCancel()
        {
            this.dialogResult = DialogResult.Cancel;
            if (!this.cancellationTokenSource.IsCancellationRequested)
            {
                this.cancellationTokenSource.Cancel();
            }
        }
    }
}

```

`WzComparerR2.Common/Controls/ServiceContainer.cs`:

```cs
#region File Description
//-----------------------------------------------------------------------------
// ServiceContainer.cs
//
// Microsoft XNA Community Game Platform
// Copyright (C) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#endregion

#region Using Statements
using System;
using System.Collections.Generic;
#endregion

namespace WzComparerR2.Controls
{
    /// <summary>
    /// Container class implements the IServiceProvider interface. This is used
    /// to pass shared services between different components, for instance the
    /// ContentManager uses it to locate the IGraphicsDeviceService implementation.
    /// </summary>
    public class ServiceContainer : IServiceProvider
    {
        Dictionary<Type, object> services = new Dictionary<Type, object>();


        /// <summary>
        /// Adds a new service to the collection.
        /// </summary>
        public void AddService<T>(T service)
        {
            services.Add(typeof(T), service);
        }


        /// <summary>
        /// Looks up the specified service.
        /// </summary>
        public object GetService(Type serviceType)
        {
            object service;

            services.TryGetValue(serviceType, out service);

            return service;
        }
    }
}

```

`WzComparerR2.Common/Gif.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Drawing.Imaging;
using ImageManipulation;

using WzComparerR2.WzLib;

namespace WzComparerR2.Common
{
    public class Gif
    {
        public Gif()
        {
            this.Frames = new List<IGifFrame>();
        }

        public List<IGifFrame> Frames { get; private set; }

        public Bitmap EncodeGif(Color backgrnd)
        {
            return EncodeGif(backgrnd, 0x00);
        }

        public Bitmap EncodeGif(Color backgrnd, int minAlpha)
        {
            return EncodeGif(backgrnd, minAlpha, 0, this.Frames.Count);
        }

        public Bitmap EncodeGif(Color backgrnd, int minAlpha, int startIndex, int frameCount)
        {
            if (frameCount <= 0)
            {
                return null;
            }

            return EncodeGif<BuildInGifEncoder>(backgrnd, minAlpha, startIndex, frameCount);
        }

        public Bitmap EncodeGif2(Color backgrnd, int minAlpha)
        {
            return EncodeGif2(backgrnd, minAlpha, 0, this.Frames.Count);
        }

        public Bitmap EncodeGif2(Color backgrnd, int minAlpha, int startIndex, int frameCount)
        {
            if (frameCount <= 0)
            {
                return null;
            }

            return EncodeGif<IndexGifEncoder>(backgrnd, minAlpha, startIndex, frameCount);
        }

        private Bitmap EncodeGif<T>(Color backgrnd, int minAlpha, int startIndex, int frameCount)
            where T : GifEncoder
        {
            //预判大小
            Rectangle rect = this.GetRect();
            Bitmap canvas = new Bitmap(rect.Width, rect.Height, PixelFormat.Format32bppArgb);
            string tempFileName = Path.GetTempFileName();
            GifEncoder enc = (GifEncoder)Activator.CreateInstance(typeof(T), tempFileName, rect.Width, rect.Height);

            //写入帧信息
            for (int i = startIndex, j = startIndex + frameCount; i < j; i++)
            {
                if (i >= this.Frames.Count)
                    break;
                IGifFrame frame = this.Frames[i];
                if (frame == null)
                {
                    continue;
                }

                PrepareFrame(canvas, frame, rect, backgrnd, minAlpha);
                enc.AppendFrame(canvas, frame.Delay);
            }

            enc.Dispose();
            return Image.FromFile(tempFileName) as Bitmap;
        }

        public Rectangle GetRect()
        {
            Rectangle rect = Rectangle.Empty;
            foreach (var f in this.Frames)
            {
                var newRect = ((IGifFrame)f).Region;
                rect = rect.Size.IsEmpty ? newRect : Rectangle.Union(rect, newRect);
            }
            return rect.Size.IsEmpty ? Rectangle.Empty : rect;
        }

        public Bitmap GetFrame(int i)
        {
            var iFrame = this.Frames[i];
            var rect = iFrame.Region;
            return GetFrame(i, rect);
        }

        private Bitmap GetFrame(int i, Rectangle canvasRect)
        {
            var iFrame = this.Frames[i];
            Bitmap bmp = new Bitmap(canvasRect.Width, canvasRect.Height, PixelFormat.Format32bppArgb);
            Graphics g = Graphics.FromImage(bmp);
            iFrame.Draw(g, canvasRect);
            g.Dispose();
            return bmp;
        }

        private static Bitmap PrepareFrame(IGifFrame frame, Rectangle canvasRect, Color backgrnd, int minAlpha)
        {
            Bitmap gifFrame = new Bitmap(canvasRect.Width, canvasRect.Height, PixelFormat.Format32bppArgb);
            PrepareFrame(gifFrame, frame, canvasRect, backgrnd, minAlpha);
            return gifFrame;
        }

        /// <summary>
        /// 预处理帧坐标，生成新的图片。
        /// </summary>
        private static void PrepareFrame(Bitmap canvas, IGifFrame frame, Rectangle canvasRect, Color backgrnd, int minAlpha)
        {
            Graphics g = Graphics.FromImage(canvas);

            if (backgrnd.A == 0xff) //背景色
            {
                g.Clear(backgrnd);
                frame.Draw(g, canvasRect);
            }
            else //透明混合色
            {
                g.Clear(Color.Transparent);
                Rectangle frameRect = frame.Region;
                frameRect.Offset(-canvasRect.X, -canvasRect.Y);
                frame.Draw(g, canvasRect);

                BitmapData data = canvas.LockBits(new Rectangle(Point.Empty, canvas.Size), ImageLockMode.ReadWrite, PixelFormat.Format32bppArgb);
                unsafe
                {
                    byte* buffer = (byte*)data.Scan0.ToPointer();

                    for (int y = frameRect.Top; y < frameRect.Bottom; y++)
                    {
                        for (int x = frameRect.Left; x < frameRect.Right; x++)
                        {
                            int i = 4 * x + y * data.Stride;

                            byte a = buffer[i + 3];
                            if (a <= minAlpha)
                            {
                                buffer[i] = buffer[i + 1] = buffer[i + 2] = buffer[i + 3] = 0;
                            }
                            else if (a < 0xff)
                            {
                                float al = a / 255f;
                                float be = (1 - al);
                                buffer[i] = (byte)(buffer[i] * al + backgrnd.B * be);
                                buffer[i + 1] = (byte)(buffer[i + 1] * al + backgrnd.G * be);
                                buffer[i + 2] = (byte)(buffer[i + 2] * al + backgrnd.R * be);
                                buffer[i + 3] = 0xff;
                            }
                        }
                    }
                }
                canvas.UnlockBits(data);
            }
        }

        public static Gif CreateFromNode(Wz_Node node, GlobalFindNodeFunction findNode)
        {
            if (node == null)
                return null;
            Gif gif = new Gif();
            for (int i = 0; ; i++)
            {
                Wz_Node frameNode = node.FindNodeByPath(i.ToString());

                if (frameNode == null || frameNode.Value == null)
                    break;
                GifFrame gifFrame = CreateFrameFromNode(frameNode, findNode);

                if (gifFrame == null)
                    break;
                gif.Frames.Add(gifFrame);
            }
            if (gif.Frames.Count > 0)
                return gif;
            else
                return null;
        }

        public static GifFrame CreateFrameFromNode(Wz_Node frameNode, GlobalFindNodeFunction findNode)
        {
            if (frameNode == null || frameNode.Value == null)
            {
                return null;
            }

            while (frameNode.Value is Wz_Uol)
            {
                Wz_Uol uol = frameNode.Value as Wz_Uol;
                Wz_Node uolNode = uol.HandleUol(frameNode);
                if (uolNode != null)
                {
                    frameNode = uolNode;
                }
            }
            if (frameNode.Value is Wz_Png)
            {
                var linkNode = frameNode.GetLinkedSourceNode(findNode);
                Wz_Png png = linkNode?.GetValue<Wz_Png>() ?? (Wz_Png)frameNode.Value;

                var gifFrame = new GifFrame(png.ExtractPng());
                foreach (Wz_Node propNode in frameNode.Nodes)
                {
                    switch (propNode.Text)
                    {
                        case "origin":
                            gifFrame.Origin = (propNode.Value as Wz_Vector);
                            break;
                        case "delay":
                            gifFrame.Delay = propNode.GetValue<int>();
                            break;
                        case "a0":
                            gifFrame.A0 = propNode.GetValue<int>();
                            break;
                        case "a1":
                            gifFrame.A1 = propNode.GetValue<int>();
                            break;
                    }
                }
                if (gifFrame.Delay == 0)
                {
                    gifFrame.Delay = 100;//给予默认delay
                }
                return gifFrame;
            }
            return null;
        }
    }
}

```

`WzComparerR2.Common/GifCanvas.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;

namespace WzComparerR2.Common
{
    public class GifCanvas
    {
        public GifCanvas()
        {
            this.Layers = new List<GifLayer>();
            this.AlphaGradientDelay = 30;
        }

        public List<GifLayer> Layers { get; private set; }

        public int AlphaGradientDelay { get; set; }

        public Gif Combine()
        {
            //获取全部关键帧延时
            List<int> delays = new List<int>();
            delays.Add(0);
            foreach (var layer in this.Layers)
            {
                int delay = 0;
                foreach (var frame in layer.Frames)
                {
                    delay += frame.Delay;
                    int idx = delays.BinarySearch(delay);
                    if (idx < 0)
                    {
                        delays.Insert(~idx, delay);
                    }
                }
            }

            //构建关键帧
            LinkedList<KeyFrame> keyFrames = new LinkedList<KeyFrame>();
            for (int i = 1; i < delays.Count; i++)
            {
                keyFrames.AddLast(new KeyFrame() { Delay = delays[i] - delays[i - 1] });
            }

            //开始填充
            foreach (var layer in this.Layers)
            {
                var node = keyFrames.First;
                foreach (var frame in layer.Frames) //把图层按关键帧拆分
                {
                    var frame0 = frame;
                    int delay = frame.Delay;
                    while (delay > 0)
                    {
                        if (frame.Bitmap != null)
                        {
                            if (node.Value.Delay == frame0.Delay) //直接加入
                            {
                                node.Value.Frames.Add(frame0);
                            }
                            else if (node.Value.Delay < frame0.Delay) //拆分
                            {
                                GifFrame f1, f2;
                                SplitGifFrame(frame0, node.Value.Delay, out f1, out f2);
                                node.Value.Frames.Add(f1);
                                frame0 = f2;
                            }
                            else
                            {
                                throw new Exception("key frame delay error.");
                            }
                        }

                        delay -= node.Value.Delay;
                        node = node.Next;
                    }
                }
            }

            //开始合并
            Gif gif = new Gif();
            {
                var node = keyFrames.First;
                while (node != null)
                {
                    if (AlphaGradientDelay > 0 && node.Value.HasAlphaGradient && AlphaGradientDelay < node.Value.Delay) //分离渐变帧
                    {
                        KeyFrame f1, f2;
                        node.Value.Split(AlphaGradientDelay, out f1, out f2);
                        node.Value = f1;
                        keyFrames.AddAfter(node, f2);
                    }

                    gif.Frames.Add(node.Value);
                    node = node.Next;
                }
            }
            return gif;
        }

        private static void SplitGifFrame(GifFrame frame, int time, out GifFrame frame1, out GifFrame frame2)
        {
            double p = (double)time / frame.Delay;
            int a = frame.A0 == frame.A1 ? frame.A0 : (int)Math.Round(frame.A0 * (1 - p) + frame.A1 * p);
            frame1 = new GifFrame(frame.Bitmap, frame.Origin, time) { A0 = frame.A0, A1 = a };
            frame2 = new GifFrame(frame.Bitmap, frame.Origin, frame.Delay - time) { A0 = a, A1 = frame.A1 };
        }

        private class KeyFrame : IGifFrame
        {
            public KeyFrame()
            {
                this.Frames = new List<GifFrame>();
            }

            public List<GifFrame> Frames { get; private set; }
            public int Delay { get; set; }

            public bool HasAlphaGradient
            {
                get
                {
                    return !this.Frames.TrueForAll(f => f.A0 == f.A1);
                }
            }

            public void Split(int time, out KeyFrame keyFrame1, out KeyFrame keyFrame2)
            {
                keyFrame1 = new KeyFrame();
                keyFrame2 = new KeyFrame();
                double p = (double)time / this.Delay;
                foreach (var f in this.Frames)
                {
                    GifFrame f1, f2;
                    SplitGifFrame(f, time, out f1, out f2);
                    keyFrame1.Frames.Add(f1);
                    keyFrame2.Frames.Add(f2);
                }
                keyFrame1.Delay = time;
                keyFrame2.Delay = this.Delay - time;
            }

            int IGifFrame.Delay
            {
                get { return this.Delay; }
            }

            Rectangle IGifFrame.Region
            {
                get
                {
                    Rectangle rect = Rectangle.Empty;
                    foreach (var f in this.Frames)
                    {
                        var newRect = ((IGifFrame)f).Region;
                        rect = rect.Size.IsEmpty ? newRect : Rectangle.Union(rect, newRect);
                    }
                    return rect.Size.IsEmpty ? Rectangle.Empty : rect;
                }
            }

            void IGifFrame.Draw(Graphics g, Rectangle canvasRect)
            {
                foreach (var f in this.Frames)
                {
                    ((IGifFrame)f).Draw(g, canvasRect);
                }
            }
        }
    }
}

```

`WzComparerR2.Common/GifEncoder.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Drawing;
using System.Drawing.Imaging;

namespace WzComparerR2.Common
{
    public abstract class GifEncoder : IDisposable
    {
        protected GifEncoder(string fileName, int width, int height)
        {
            this.FileName = fileName;
            this.Width = width;
            this.Height = height;
        }

        public string FileName { get; private set; }
        public int Width { get; private set; }
        public int Height { get; private set; }

        public virtual void AppendFrame(Bitmap image, int delay)
        {
            BitmapData data = image.LockBits(new Rectangle(Point.Empty, image.Size), ImageLockMode.ReadWrite, PixelFormat.Format32bppArgb);
            this.AppendFrame(data.Scan0, delay);
            image.UnlockBits(data);
        }

        public abstract void AppendFrame(IntPtr pBuffer, int delay);


        public void Dispose()
        {
            this.Dispose(true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {

        }

        ~GifEncoder()
        {
            this.Dispose(false);
        }
    }
}

```

`WzComparerR2.Common/GifFrame.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;
using System.Drawing.Imaging;

namespace WzComparerR2.Common
{
    public class GifFrame : IGifFrame
    {
        public GifFrame()
        {
            this.A0 = 255;
            this.A1 = 255;
        }

        public GifFrame(Bitmap bitmap)
            : this(bitmap, Point.Empty, 0)
        {
        }

        public GifFrame(Bitmap bitmap, int delay)
            : this(bitmap, Point.Empty, delay)
        {
        }

        public GifFrame(Bitmap bitmap, Point origin, int delay)
            : this()
        {
            this.Bitmap = bitmap;
            this.Origin = origin;
            this.Delay = delay;
        }

        public Bitmap Bitmap { get; set; }
        public Point Origin { get; set; }
        public int Delay { get; set; }
        public int A0 { get; set; }
        public int A1 { get; set; }

        int IGifFrame.Delay
        {
            get { return this.Delay; }
        }

        Rectangle IGifFrame.Region
        {
            get
            {
                var size = this.Bitmap == null ? Size.Empty : this.Bitmap.Size;
                return new Rectangle(-this.Origin.X, -this.Origin.Y, size.Width, size.Height);
            }
        }

        void IGifFrame.Draw(Graphics g, Rectangle canvasRect)
        {
            if (this.Bitmap == null)
            {
                return;
            }

            Point pos = new Point(-this.Origin.X - canvasRect.X, -this.Origin.Y - canvasRect.Y);

            if (A0 >= 255)
            {
                g.DrawImage(this.Bitmap, pos);
            }
            else if (A0 > 0)
            {
                var imageAttr = new ImageAttributes();
                float a = A0 / 255f;
                var mt = new ColorMatrix(new[]{
                        new float[]{1,0,0,0,0},
                        new float[]{0,1,0,0,0},
                        new float[]{0,0,1,0,0},
                        new float[]{0,0,0,a,0},
                        new float[]{0,0,0,0,1},
                    });
                imageAttr.SetColorMatrix(mt);
                g.DrawImage(this.Bitmap,
                    new Rectangle(pos, this.Bitmap.Size),
                    0, 0, this.Bitmap.Width, this.Bitmap.Height, GraphicsUnit.Pixel,
                    imageAttr);
                imageAttr.Dispose();
            }
        }
    }
}

```

`WzComparerR2.Common/GifLayer.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace WzComparerR2.Common
{
    public class GifLayer
    {
        public GifLayer()
        {
            this.Frames = new List<GifFrame>();
        }

        public List<GifFrame> Frames { get; private set; }

        public void AddFrame(GifFrame frame)
        {
            this.Frames.Add(frame);
        }

        public void AddBlank(int delay)
        {
            this.Frames.Add(new GifFrame(null, delay));
        }
    }
}

```

`WzComparerR2.Common/GlobalFindNodeFunction.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using WzComparerR2.WzLib;

namespace WzComparerR2
{
    public delegate Wz_Node GlobalFindNodeFunction(string fullPath);
}

```

`WzComparerR2.Common/IGifFrame.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;

namespace WzComparerR2.Common
{
    public interface IGifFrame
    {
        Rectangle Region { get; }
        int Delay { get; }
        void Draw(Graphics g, Rectangle canvasRect);
    }
}

```

`WzComparerR2.Common/ImageDataObject.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Windows.Forms;
using System.Drawing;
using System.IO;

namespace WzComparerR2.Common
{
    public class ImageDataObject : DataObject
    {
        public ImageDataObject(Image image, string fileName)
        {
            this.Image = image;
            this.FileName = fileName;

            this.SetData(DataFormats.Bitmap, fileName);
            this.SetData(DataFormats.FileDrop, fileName);
            this.SetData(QQ_RichEdit_Format, new MemoryStream(new byte[0]));
            this.SetData(QQ_Unicode_RichEdit_Format, new MemoryStream(new byte[0]));
        }

        public Image Image { get; private set; }
        public string FileName { get; private set; }

        private static readonly string QQ_RichEdit_Format = "QQ_RichEdit_Format";
        private static readonly string QQ_Unicode_RichEdit_Format = "QQ_Unicode_RichEdit_Format";

        public override object GetData(string format, bool autoConvert)
        {
            if (format == DataFormats.Bitmap
                || format == typeof(Bitmap).FullName)
            {
                PrepareImageFile();
                base.SetData(DataFormats.Bitmap, this.FileName);
            }
            else if (format == DataFormats.FileDrop
                || format == "FileName"
                || format == "FileNameW")
            {
                PrepareImageFile();
                base.SetData(DataFormats.FileDrop, new string[] { this.FileName });
            }
            else if (format == QQ_RichEdit_Format)
            {
                PrepareImageFile();
                byte[] buffer = Encoding.Default.GetBytes(GetQQRichFormatString());
                this.SetData(QQ_RichEdit_Format, new MemoryStream(buffer));
            }
            else if (format == QQ_Unicode_RichEdit_Format)
            {
                PrepareImageFile();
                byte[] buffer = Encoding.Unicode.GetBytes(GetQQRichFormatString());
                this.SetData(QQ_Unicode_RichEdit_Format, new MemoryStream(buffer));
            }

            return base.GetData(format, autoConvert);
        }

        private void PrepareImageFile()
        {
            string fileName = this.FileName;
            string tempDir = new DirectoryInfo(Environment.GetEnvironmentVariable("TEMP")).FullName;
            bool willSaveImage = false;
            if (string.IsNullOrEmpty(fileName))
            {
                fileName = Path.Combine(tempDir, Path.GetRandomFileName());
                willSaveImage = true;
            }
            else
            {
                if (string.IsNullOrEmpty(Path.GetDirectoryName(fileName)))//没有文件夹 保存文件
                {
                    fileName = Path.Combine(tempDir, fileName);
                    if (File.Exists(fileName))
                    {
                        string fileNameNoExt = Path.GetFileNameWithoutExtension(fileName);
                        string ext = Path.GetExtension(fileName);
                        for (int i = 1; ; i++)
                        {
                            fileName = Path.Combine(tempDir, string.Format("{0}({1}){2}", fileNameNoExt, i, ext));
                            if (!File.Exists(fileName))
                            {
                                break;
                            }
                        }
                    }
                    willSaveImage = true;
                }
            }

            if (willSaveImage)
            {
                Image.Save(fileName, Image.RawFormat);
                this.FileName = fileName;
            }
        }

        private string GetQQRichFormatString()
        {
            return string.Format(@"<QQRichEditFormat><Info version=""1001""></Info><EditElement type=""1"" filepath=""{0}"" shortcut=""""></EditElement></QQRichEditFormat>", FileName);
        }
    }
}

```

`WzComparerR2.Common/IndexGifEncoder.cs`:

```cs
using System;
using System.Drawing;
using System.Drawing.Imaging;
using System.Runtime.InteropServices;

namespace WzComparerR2.Common
{
    public class IndexGifEncoder : GifEncoder
    {
        public IndexGifEncoder(string location, int width, int height)
             : this(location, width, height, 255, Color.FromArgb(0))
        {

        }
        public IndexGifEncoder(string location, int width, int height, int max_color, Color back_color)
            :base(location, width, height)
        {
            encoder_pointer = construct(location, width, height, max_color, back_color.ToArgb());
        }

        private IntPtr encoder_pointer;


        public override void AppendFrame(IntPtr pBuffer, int delay)
        {
            encoder.append_frame(pBuffer, delay, encoder_pointer);
        }


        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                encoder.destruct(encoder_pointer);
            }
        }

        private gif_encoder_structure encoder
        {
            get
            {
                return (gif_encoder_structure)Marshal.PtrToStructure(encoder_pointer, typeof(gif_encoder_structure));
            }
        }

        [DllImport("libgif.dll", EntryPoint = "#1", CharSet = CharSet.Unicode)]
        private extern static IntPtr construct(string location, int width, int height, int maxColor, int backColor);

        private delegate void gif_encoder_destruct(IntPtr encoder_pointer);
        private delegate void gif_encoder_append_frame(IntPtr pixels, int delay, IntPtr encoder_pointer);

        [StructLayout(LayoutKind.Sequential)]
        private struct gif_encoder_structure
        {
            public gif_encoder_destruct destruct;
            public gif_encoder_append_frame append_frame;
        }
    }
}

```

`WzComparerR2.Common/Properties/AssemblyInfo.cs`:

```cs
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// 有关程序集的常规信息通过以下
// 特性集控制。更改这些特性值可修改
// 与程序集关联的信息。
[assembly: AssemblyTitle("WzComparerR2.Common")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("WzComparerR2.Common")]
[assembly: AssemblyCopyright("Copyright © Kagamia Studio 2015-2021")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// 将 ComVisible 设置为 false 使此程序集中的类型
// 对 COM 组件不可见。如果需要从 COM 访问此程序集中的类型，
// 则将该类型上的 ComVisible 特性设置为 true。
[assembly: ComVisible(false)]

// 如果此项目向 COM 公开，则下列 GUID 用于类型库的 ID
[assembly: Guid("b7285749-1724-4f18-9824-7d067ac26402")]

// 程序集的版本信息由下面四个值组成:
//
//      主版本
//      次版本 
//      生成号
//      修订号
//
// 可以指定所有这些值，也可以使用“生成号”和“修订号”的默认值，
// 方法是按如下所示使用“*”:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("2.2.0.0")]
[assembly: AssemblyFileVersion("2.2.0.10725")]

```

`WzComparerR2.Common/Rendering/AnimationGraphics.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using WzComparerR2.Animation;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using WzComparerR2.Controls;

namespace WzComparerR2.Rendering
{
    public class AnimationGraphics
    {
        public AnimationGraphics(GraphicsDevice graphicsDevice)
            : this (graphicsDevice, new SpriteBatch(graphicsDevice))
        {
        }

        public AnimationGraphics(GraphicsDevice graphicsDevice, SpriteBatch sprite)
        {
            this.GraphicsDevice = graphicsDevice;
            this.sprite = sprite;
            this.spineRenderer = new Spine.SkeletonRenderer(graphicsDevice);
            this.blendState = StateEx.NonPremultipled_Hidef();
        }

        public GraphicsDevice GraphicsDevice { get; private set; }

        private SpriteBatch sprite;
        private Spine.SkeletonRenderer spineRenderer;
        private BlendState blendState;

        public void Draw(FrameAnimator animator, Matrix world)
        {
            Frame frame = animator.CurrentFrame;
            if (frame != null && frame.Texture != null)
            {
                if (animator.Position != Microsoft.Xna.Framework.Point.Zero)
                {
                    world *= Matrix.CreateTranslation(animator.Position.X, animator.Position.Y, 0);
                }

                sprite.Begin(SpriteSortMode.Deferred, this.blendState, transformMatrix: world);
                sprite.Draw(frame.Texture,
                    Vector2.Zero,
                    frame.AtlasRect,
                    new Microsoft.Xna.Framework.Color(Microsoft.Xna.Framework.Color.White, frame.A0),
                    0,
                    frame.Origin.ToVector2(),
                    1,
                    SpriteEffects.None,
                    0);
                sprite.End();
            }
        }

        public void Draw(ISpineAnimator animator, Matrix world)
        {
            if (animator is AnimationItem aniItem && aniItem.Position != Microsoft.Xna.Framework.Point.Zero)
            {
                world *= Matrix.CreateTranslation(aniItem.Position.X, aniItem.Position.Y, 0);
            }

            spineRenderer.PremultipliedAlpha = animator.Data.PremultipliedAlpha;
            if (spineRenderer.Effect is BasicEffect basicEff)
            {
                basicEff.World = world;
                basicEff.Projection = Matrix.CreateOrthographicOffCenter(0, this.GraphicsDevice.Viewport.Width, this.GraphicsDevice.Viewport.Height, 0, 1, 0);
            }

            spineRenderer.Begin();
            animator.Render(spineRenderer);
            spineRenderer.End();
        }
    }
}

```

`WzComparerR2.Common/Rendering/BlendEx.cs`:

```cs
using System;
using Microsoft.Xna.Framework.Graphics;

namespace WzComparerR2.Rendering
{
    public static class StateEx
    {
        public static BlendState NonPremultipled_Hidef() => new BlendState()
        {
            AlphaSourceBlend = Blend.One,
            AlphaDestinationBlend = Blend.InverseSourceAlpha,
            AlphaBlendFunction = BlendFunction.Add,
            ColorSourceBlend = Blend.SourceAlpha,
            ColorDestinationBlend = Blend.InverseSourceAlpha,
            ColorBlendFunction = BlendFunction.Add,
        };

        public static BlendState SrcAlphaMask() => new BlendState()
        {
            AlphaSourceBlend = Blend.Zero,
            AlphaDestinationBlend = Blend.InverseSourceAlpha,
            AlphaBlendFunction = BlendFunction.Add,
            ColorSourceBlend = Blend.Zero,
            ColorDestinationBlend = Blend.InverseSourceAlpha,
            ColorBlendFunction = BlendFunction.Add,
        };

        public static BlendState MultiplyRGB() => new BlendState()
        {
            AlphaSourceBlend = Blend.Zero,
            AlphaDestinationBlend = Blend.One,
            AlphaBlendFunction = BlendFunction.Add,
            ColorSourceBlend = Blend.Zero,
            ColorDestinationBlend = Blend.SourceColor,
            ColorBlendFunction = BlendFunction.Add,
        };

        public static RasterizerState Scissor() => new RasterizerState()
        {
            ScissorTestEnable = true,
            CullMode = CullMode.None,
            MultiSampleAntiAlias = false,
            FillMode = FillMode.Solid
        };
    }
}

```

`WzComparerR2.Common/Rendering/D2DContext.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using SharpDX.Direct2D1;
using SharpDX.DirectWrite;
using SharpDX.DXGI;

namespace WzComparerR2.Rendering
{
    public sealed class D2DContext : IDisposable
    {
        public Surface DxgiSurface { get; internal set; }
        public RenderTarget D2DRenderTarget { get; internal set; }
        
        internal bool IsBeginEndPair { get; private set; }
        private SolidColorBrush cachedBrush;


        public SharpDX.Direct2D1.Brush GetBrush(Microsoft.Xna.Framework.Color color)
        {
            return this.GetBrush(color.XnaToDxColor());
        }

        public SharpDX.Direct2D1.Brush GetBrush(SharpDX.Color4 color)
        {
            if (this.cachedBrush == null || this.cachedBrush.IsDisposed)
            {
                this.cachedBrush = new SolidColorBrush(this.D2DRenderTarget, color);
            }
            else
            {
                this.cachedBrush.Color = color;
            }
            return this.cachedBrush;
        }

        public void Dispose()
        {
            this.cachedBrush?.Dispose();
            this.DxgiSurface?.Dispose();
            this.D2DRenderTarget?.Dispose();
        }
    }
}

```

`WzComparerR2.Common/Rendering/D2DFactory.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Runtime.CompilerServices;
using System.Reflection;
using Microsoft.Xna.Framework.Graphics;
using SharpDX.Direct2D1;
using SharpDX.DirectWrite;

namespace WzComparerR2.Rendering
{
    public class D2DFactory : IDisposable
    {
        private static D2DFactory _instance;

        public static D2DFactory Instance
        {
            get
            {
                if (_instance == null || _instance.IsDisposed)
                {
                    _instance = new D2DFactory();
                }
                return _instance;
            }
        }

        private D2DFactory()
        {
            this.factory2D = new SharpDX.Direct2D1.Factory();
            this.factoryDWrite = new SharpDX.DirectWrite.Factory();
            this.dictContext = new ConditionalWeakTable<SharpDX.DisposeBase, D2DContext>();
            this.deviceSwapChainField = typeof(GraphicsDevice)
                    .GetField("_swapChain", BindingFlags.Instance | BindingFlags.NonPublic);
            this.textureResourceField = typeof(Texture)
                    .GetField("_texture", BindingFlags.Instance | BindingFlags.NonPublic);
        }

        public bool IsDisposed { get; private set; }

        internal readonly SharpDX.Direct2D1.Factory factory2D;
        internal readonly SharpDX.DirectWrite.Factory factoryDWrite;
        private ConditionalWeakTable<SharpDX.DisposeBase, D2DContext> dictContext;
        private readonly FieldInfo deviceSwapChainField;
        private readonly FieldInfo textureResourceField;

        public D2DContext GetContext(GraphicsDevice graphicsDevice)
        {
            SharpDX.ComObject obj = GetRenderTargetResource(graphicsDevice);
            D2DContext context = GetOrCreateContext(obj);

            if (context == null)
            {
                return null;
            }

            AlphaMode alphaMode = AlphaMode.Ignore;
            if (context.DxgiSurface == null || context.DxgiSurface.IsDisposed)
            {
                if (obj is SharpDX.DXGI.SwapChain)
                {
                    var swapChain = (SharpDX.DXGI.SwapChain)obj;
                    context.DxgiSurface = SharpDX.DXGI.Surface.FromSwapChain(swapChain, 0);
                    alphaMode = AlphaMode.Ignore;
                }
                else if (obj is SharpDX.Direct3D11.Resource)
                {
                    context.DxgiSurface = obj.QueryInterface<SharpDX.DXGI.Surface>();
                    alphaMode = AlphaMode.Premultiplied;
                }
                else
                {
                    return null;
                }
            }

            if (context.D2DRenderTarget == null || context.D2DRenderTarget.IsDisposed)
            {
                var rtProp = new RenderTargetProperties(new PixelFormat(SharpDX.DXGI.Format.Unknown, alphaMode));
                var d2drt = new RenderTarget(this.factory2D, context.DxgiSurface, rtProp);
                d2drt.TextRenderingParams = new RenderingParams(factoryDWrite, 1f, 0f, 0f, PixelGeometry.Flat, RenderingMode.CleartypeGdiClassic);
                d2drt.TextAntialiasMode = SharpDX.Direct2D1.TextAntialiasMode.Grayscale;
                context.D2DRenderTarget = d2drt;
                context.DxgiSurface.Disposing += (o, e) => d2drt.Dispose();
            }
            
            return context;
        }

        public void ReleaseContext(GraphicsDevice graphicsDevice)
        {
            SharpDX.ComObject obj = GetRenderTargetResource(graphicsDevice);
            D2DContext context;
            if (this.dictContext.TryGetValue(obj, out context))
            {
                context.Dispose();
            }
        }

        private SharpDX.ComObject GetRenderTargetResource(GraphicsDevice graphicsDevice)
        {
            var rt = graphicsDevice.GetRenderTargets();

            SharpDX.ComObject obj;
            if (rt.Length <= 0)
            {
                obj = (SharpDX.DXGI.SwapChain)this.deviceSwapChainField.GetValue(graphicsDevice);
            }
            else
            {
                obj = (SharpDX.Direct3D11.Resource)this.textureResourceField.GetValue(rt[0].RenderTarget);
            }

            return obj;
        }

        private D2DContext GetOrCreateContext(SharpDX.ComObject comObject)
        {
            if (comObject == null)
            {
                return null;
            }

            if (comObject.IsDisposed)
            {
                dictContext.Remove(comObject);
                return null;
            }

            D2DContext context;
            if (!this.dictContext.TryGetValue(comObject, out context))
            {
                context = new D2DContext();
                comObject.Disposing += ComObject_Disposing;
                this.dictContext.Add(comObject, context);
            }
            return context;
        }

        private void ComObject_Disposing(object sender, EventArgs e)
        {
            var comObject = sender as SharpDX.ComObject;
            D2DContext context;
            if (comObject != null && this.dictContext.TryGetValue(comObject, out context))
            {
                context?.Dispose();
                this.dictContext.Remove(comObject);
            }
        }

        ~D2DFactory()
        {
            this.Dispose(false);
        }

        public void Dispose()
        {
            this.Dispose(true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (disposing && !this.IsDisposed)
            {
                if (this.factory2D != null)
                {
                    this.factory2D.Dispose();
                }
                if (this.factoryDWrite != null)
                {
                    this.factoryDWrite.Dispose();
                }

                this.dictContext = null;
                this.IsDisposed = true;
            }
        }
    }
}

```

`WzComparerR2.Common/Rendering/D2DFont.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Collections.Concurrent;
using System.Linq;
using System.Text;
using SharpDX.Direct2D1;
using SharpDX.DXGI;
using SharpDX.DirectWrite;
using Microsoft.Xna.Framework;

namespace WzComparerR2.Rendering
{
    public class D2DFont : IDisposable
    {
        public D2DFont(string familyName, float size)
            : this(familyName, size, false, false)
        {
            
        }

        public D2DFont(string familyName, float size, bool bold, bool italic)
        {
            this.FamilyName = familyName;
            this.Size = size;

            FontWeight weight = bold ? FontWeight.Bold : FontWeight.Normal;
            SharpDX.DirectWrite.FontStyle style = italic ? SharpDX.DirectWrite.FontStyle.Italic : SharpDX.DirectWrite.FontStyle.Normal;
            var factory = D2DFactory.Instance.factoryDWrite;
            this.textFormat = new TextFormat(factory, this.FamilyName, weight, style, this.Size);

            this.CacheFontMetrics();
            this.Height = this.Height;
        }

        public D2DFont(System.Drawing.Font font) :
            this(font.Name, font.SizeInPoints * 96 / 72, font.Bold, font.Italic)
        {

        }

        public string FamilyName { get; private set; }
        public float Size { get; private set; }

        public float Height
        {
            get
            {
                if (this.lineHeight <= 0)
                {
                    if (this.metrics.DesignUnitsPerEm > 0)
                    {
                        float ratio = this.textFormat.FontSize / this.metrics.DesignUnitsPerEm;
                        float size = (this.metrics.Ascent + this.metrics.Descent + this.metrics.LineGap) * ratio;
                        this.lineHeight = (float)Math.Ceiling(size);
                    }
                    else
                    {
                        this.lineHeight = this.Size;
                    }
                }

                return this.lineHeight;
            }
            set
            {
                LineSpacingMethod method;
                float lineSpacing;
                float baseLine;
                this.textFormat.GetLineSpacing(out method, out lineSpacing, out baseLine);
                if (method == LineSpacingMethod.Default || baseLine <= 0)
                {
                    if (this.metrics.DesignUnitsPerEm > 0)
                    {
                        float ratio = this.textFormat.FontSize / metrics.DesignUnitsPerEm;
                        baseLine = metrics.Ascent * ratio;
                    }
                    else
                    {
                        baseLine = this.Size;
                    }
                }
                this.textFormat.SetLineSpacing(LineSpacingMethod.Uniform, value, baseLine);
                this.lineHeight = value;
            }
        }

        private readonly TextFormat textFormat;
        private float lineHeight;
        private FontMetrics metrics;

        private SharpDX.DirectWrite.Font GetMatchingFont()
        {
            var fontCollection = this.textFormat.FontCollection;
            int index;
            if (fontCollection.FindFamilyName(this.textFormat.FontFamilyName, out index))
            {
                using (var family = fontCollection.GetFontFamily(index))
                {
                    var font = family.GetFirstMatchingFont(this.textFormat.FontWeight,
                        this.textFormat.FontStretch,
                        this.textFormat.FontStyle);
                    return font;
                }
            }
            return null;
        }

        private bool CacheFontMetrics()
        {
            var font = this.GetMatchingFont();
            if (font != null)
            {
                using (font)
                {
                    this.metrics = font.Metrics;
                    return true;
                }
            }
            return false;
        }

        internal void DrawText(D2DContext context, string text, Vector2 position, Microsoft.Xna.Framework.Color color)
        {
             this.DrawText(context, text, position, Vector2.Zero, color);
        }

        internal void DrawText(D2DContext context, string text, Vector2 position, Vector2 size, Microsoft.Xna.Framework.Color color)
        {
            var rt = context.D2DRenderTarget;

            using (var layout = this.LayoutString(text, size.X, size.Y))
            {
                rt.DrawTextLayout(new SharpDX.Vector2(position.X, position.Y),
                    layout,
                    context.GetBrush(color),
                    DrawTextOptions.None);
            }
        }

        public Vector2 MeasureString(string text)
        {
            return this.MeasureString(text, Vector2.Zero);
        }

        public Vector2 MeasureString(string text, Vector2 size)
        {
            using (var layout = this.LayoutString(text, size.X, size.Y))
            {
                var metrics = layout.Metrics;
                if (metrics.LineCount > 0 && this.metrics.DesignUnitsPerEm > 0)
                {
                    float ratio = this.textFormat.FontSize / this.metrics.DesignUnitsPerEm;
                    var gap = this.lineHeight - (this.metrics.Ascent + this.metrics.Descent) * ratio;
                    if (gap > 0)
                    {
                        metrics.Height -= gap;
                    }
                }

                return new Vector2(metrics.WidthIncludingTrailingWhitespace, metrics.Height);
            }
        }

        private TextLayout LayoutString(string text, float maxWidth, float maxHeight)
        {
            if (maxWidth <= 0)
            {
                maxWidth = Int16.MaxValue;
            }
            var layout = new TextLayout(D2DFactory.Instance.factoryDWrite, text, this.textFormat, maxWidth, 0, 1, false);
            layout.WordWrapping = WordWrapping.Wrap;
            layout.TextAlignment = TextAlignment.Leading;
            layout.ParagraphAlignment = ParagraphAlignment.Near;
            return layout;
        }

        ~D2DFont()
        {
            this.Dispose(false);
        }

        public void Dispose()
        {
            this.Dispose(true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (disposing)
            {
                this.textFormat.Dispose();
            }
        }
    }
}

```

`WzComparerR2.Common/Rendering/D2DRenderer.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;

namespace WzComparerR2.Rendering
{
    public class D2DRenderer
    {
        public D2DRenderer(GraphicsDevice graphicsDevice)
        {
            this.GraphicsDevice = graphicsDevice;
        }

        public GraphicsDevice GraphicsDevice { get; private set; }

        internal bool IsBeginEndPair { get; private set; }

        protected D2DContext context;

        public void Begin()
        {
            this.Begin(SharpDX.Matrix3x2.Identity);
        }

        public void Begin(Microsoft.Xna.Framework.Matrix transform)
        {
            var mt3x2 = new SharpDX.Matrix3x2(transform.M11, transform.M12,
                transform.M21, transform.M22,
                transform.M41, transform.M42);
            this.Begin(mt3x2);
        }

        private void Begin(SharpDX.Matrix3x2 transform)
        {
            this.context = D2DFactory.Instance.GetContext(this.GraphicsDevice);
            if (this.context == null)
            {
                throw new Exception("Create D2D context failed.");
            }
            this.context.D2DRenderTarget.Transform = transform;
            this.context.D2DRenderTarget.BeginDraw();
            this.IsBeginEndPair = true;
        }

        public void PushClip(Microsoft.Xna.Framework.Rectangle clipRect)
        {
            this.context.D2DRenderTarget.PushAxisAlignedClip(clipRect.XnaToDxRect(), SharpDX.Direct2D1.AntialiasMode.PerPrimitive);
        }

        public void PopClip()
        {
            this.context.D2DRenderTarget.PopAxisAlignedClip();
        }

        public void DrawString(D2DFont font, string text, Vector2 position, Microsoft.Xna.Framework.Color color)
        {
            font.DrawText(this.context, text, position, color);
        }

        public void DrawString(D2DFont font, string text, Vector2 position, Vector2 size, Microsoft.Xna.Framework.Color color)
        {
            font.DrawText(this.context, text, position, size, color);
        }

        public void DrawLine(Vector2 point0, Vector2 point1, float width, Microsoft.Xna.Framework.Color color)
        {
            var rt = this.context.D2DRenderTarget;
            rt.DrawLine(new SharpDX.Vector2(point0.X, point0.Y),
                new SharpDX.Vector2(point1.X, point1.Y),
                this.context.GetBrush(color),
                width);
        }

        public void DrawRectangle(Microsoft.Xna.Framework.Rectangle rectangle, Microsoft.Xna.Framework.Color color)
        {
            var rt = this.context.D2DRenderTarget;
            rt.DrawRectangle(rectangle.XnaToDxRect(), this.context.GetBrush(color));
        }

        public void FillRectangle(Microsoft.Xna.Framework.Rectangle rectangle, Microsoft.Xna.Framework.Color color)
        {
            var rt = this.context.D2DRenderTarget;
            rt.FillRectangle(rectangle.XnaToDxRect(), this.context.GetBrush(color));
        }

        public void FillRoundedRectangle(Microsoft.Xna.Framework.Rectangle rectangle, float cornerRadius, Microsoft.Xna.Framework.Color color)
        {
            var rt = this.context.D2DRenderTarget;
            var rRect = new SharpDX.Direct2D1.RoundedRectangle()
            {
                RadiusX = cornerRadius,
                RadiusY = cornerRadius,
                Rect = rectangle.XnaToDxRect()
            };
            rt.FillRoundedRectangle(rRect, this.context.GetBrush(color));
        }

        public void End()
        {
            this.context.D2DRenderTarget.EndDraw();
            this.IsBeginEndPair = false;
        }
    }
}

```

`WzComparerR2.Common/Rendering/DxExtension.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.Xna.Framework;

namespace WzComparerR2.Rendering
{
    public static class DxExtension
    {
        public static Microsoft.Xna.Framework.Color DxToXnaColor(this SharpDX.Color color)
        {
            return new Microsoft.Xna.Framework.Color(color.R, color.G, color.B, color.A);
        }

        public static SharpDX.Color XnaToDxColor(this Microsoft.Xna.Framework.Color color)
        {
            return SharpDX.Color.FromRgba(color.PackedValue);
        }

        public static SharpDX.RectangleF XnaToDxRect(this Microsoft.Xna.Framework.Rectangle rect)
        {
            return new SharpDX.RectangleF(rect.X, rect.Y, rect.Width, rect.Height);
        }
    }
}

```

`WzComparerR2.Common/Rendering/Effect/EffectCompiler.bat`:

```bat
@echo off
setlocal

dotnet tool install --global dotnet-mgfxc --version 3.8.0.1641
mgfxc "PngEffect.fx" "PngEffect.mgfxo" /Profile:DirectX_11

endlocal
```

`WzComparerR2.Common/Rendering/Effect/Macros.fxh`:

```fxh
//-----------------------------------------------------------------------------
// Macros.fxh
//
// Microsoft XNA Community Game Platform
// Copyright (C) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#ifdef SM4

// Macros for targetting shader model 4.0 (DX11)

#define TECHNIQUE(name, vsname, psname ) \
	technique name { pass { VertexShader = compile vs_4_0_level_9_1 vsname (); PixelShader = compile ps_4_0_level_9_1 psname(); } }

#define BEGIN_CONSTANTS     cbuffer Parameters : register(b0) {
#define MATRIX_CONSTANTS
#define END_CONSTANTS       };

#define _vs(r)
#define _ps(r)
#define _cb(r)

#define DECLARE_TEXTURE(Name, index) \
    Texture2D<float4> Name : register(t##index); \
    sampler Name##Sampler : register(s##index)

#define DECLARE_CUBEMAP(Name, index) \
    TextureCube<float4> Name : register(t##index); \
    sampler Name##Sampler : register(s##index)

#define SAMPLE_TEXTURE(Name, texCoord)  Name.Sample(Name##Sampler, texCoord)
#define SAMPLE_CUBEMAP(Name, texCoord)  Name.Sample(Name##Sampler, texCoord)


#else


// Macros for targetting shader model 2.0 (DX9)

#define TECHNIQUE(name, vsname, psname ) \
	technique name { pass { VertexShader = compile vs_2_0 vsname (); PixelShader = compile ps_2_0 psname(); } }

#define BEGIN_CONSTANTS
#define MATRIX_CONSTANTS
#define END_CONSTANTS

#define _vs(r)  : register(vs, r)
#define _ps(r)  : register(ps, r)
#define _cb(r)

#define DECLARE_TEXTURE(Name, index) \
    sampler2D Name : register(s##index);

#define DECLARE_CUBEMAP(Name, index) \
    samplerCUBE Name : register(s##index);

#define SAMPLE_TEXTURE(Name, texCoord)  tex2D(Name, texCoord)
#define SAMPLE_CUBEMAP(Name, texCoord)  texCUBE(Name, texCoord)


#endif



//Extensions

#ifdef SM4

#define TECHNIQUE_SB(name, psname ) \
	technique name { pass { PixelShader = compile ps_4_0_level_9_1 psname(); } }
#else

#define TECHNIQUE_SB(name, psname ) \
	technique name { pass { PixelShader = compile ps_2_0 psname(); } }
#endif

```

`WzComparerR2.Common/Rendering/Effect/PngEffect.fx`:

```fx
#include "Macros.fxh"

DECLARE_TEXTURE(Texture, 0);

BEGIN_CONSTANTS

  float4 mixedColor;
  float clipAlpha;

  MATRIX_CONSTANTS

END_CONSTANTS

struct VSOutput
{
	float4 position		: SV_Position;
	float4 color		: COLOR0;
	float2 texCoord		: TEXCOORD0;
};

float4 RGBAtoNonPremultiplied(float4 input)
{
	if (input.a <= 1) {
		input.rgb /= input.a;
	}
	return input;
}

float4 Blend(float4 background, float4 premultipliedColor)
{
	return float4(background.rgb * (1 - premultipliedColor.a) + premultipliedColor.rgb, 1);
}

float4 PS(VSOutput input) : SV_Target0
{
	float4 color = SAMPLE_TEXTURE(Texture, input.texCoord) * input.color;
	return RGBAtoNonPremultiplied(color);
}

float4 PS_AlphaTest(VSOutput input) : SV_Target0
{
	float4 color = SAMPLE_TEXTURE(Texture, input.texCoord) * input.color;
	clip(color.a <= clipAlpha ? -1 : 1);
	return Blend(mixedColor, color);
}

TECHNIQUE_SB(tech0, PS);
TECHNIQUE_SB(tech1, PS_AlphaTest);

```

`WzComparerR2.Common/Rendering/MonogameUtils.cs`:

```cs
using System;
using System.Runtime.InteropServices;
using GdipColor = System.Drawing.Color;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using SharpDX.Direct3D11;
using Texture2D = Microsoft.Xna.Framework.Graphics.Texture2D;
using WzComparerR2.WzLib;

namespace WzComparerR2.Rendering
{
    public static class MonogameUtils
    {
        internal const SharpDX.DXGI.Format DXGI_FORMAT_B4G4R4A4_UNORM = (SharpDX.DXGI.Format)115;

        public static Microsoft.Xna.Framework.Color ToXnaColor(this GdipColor color)
        {
            return new Microsoft.Xna.Framework.Color(color.R, color.G, color.B, color.A);
        }

        public static Microsoft.Xna.Framework.Color GetXnaColor(this Wz_Node node)
        {
            var argbColor = node.GetValueEx<int>(0);
            var bgra = BitConverter.GetBytes(argbColor);
            return new Microsoft.Xna.Framework.Color(bgra[2], bgra[1], bgra[0], bgra[3]);
        }

        public static Texture2D CreateMosaic(GraphicsDevice device, Microsoft.Xna.Framework.Color c0, Microsoft.Xna.Framework.Color c1, int blockSize)
        {
            var t2d = new Texture2D(device, blockSize * 2, blockSize * 2, false, SurfaceFormat.Color);
            Microsoft.Xna.Framework.Color[] colorData = new Microsoft.Xna.Framework.Color[blockSize * blockSize * 4];
            int offset = blockSize * blockSize * 2;
            for (int i = 0; i < blockSize; i++)
            {
                colorData[i] = c0;
                colorData[blockSize + i] = c1;
                colorData[offset + i] = c1;
                colorData[offset + blockSize + i] = c0;
            }
            for (int i = 1; i < blockSize; i++)
            {
                Array.Copy(colorData, 0, colorData, blockSize * 2 * i, blockSize * 2);
                Array.Copy(colorData, offset, colorData, offset + blockSize * 2 * i, blockSize * 2);
            }
            t2d.SetData(colorData);
            return t2d;
        }

        public static Texture2D ToTexture(this System.Drawing.Bitmap bitmap, GraphicsDevice device)
        {
            var t2d = new Texture2D(device, bitmap.Width, bitmap.Height, false, SurfaceFormat.Bgra32);
            bitmap.ToTexture(t2d, Microsoft.Xna.Framework.Point.Zero);
            return t2d;
        }

        public static void ToTexture(this System.Drawing.Bitmap bitmap, Texture2D texture, Microsoft.Xna.Framework.Point origin)
        {
            var rect = new System.Drawing.Rectangle(0, 0, bitmap.Width, bitmap.Height);
            var bmpData = bitmap.LockBits(rect, System.Drawing.Imaging.ImageLockMode.ReadOnly,
                System.Drawing.Imaging.PixelFormat.Format32bppArgb);
            byte[] buffer = new byte[bmpData.Stride * bmpData.Height];
            Marshal.Copy(bmpData.Scan0, buffer, 0, buffer.Length);
            bitmap.UnlockBits(bmpData);

            texture.SetData(0, 0, new Microsoft.Xna.Framework.Rectangle(origin.X, origin.Y, rect.Width, rect.Height), buffer, 0, buffer.Length);
        }

        public static void BgraToColor(byte[] pixelData)
        {
            for (int i = 0; i < pixelData.Length; i += 4)
            {
                byte temp = pixelData[i];
                pixelData[i] = pixelData[i + 2];
                pixelData[i + 2] = temp;
            }
        }

        public static Device _d3dDevice(this GraphicsDevice device)
        {
            return (Device)device.Handle;
        }

        public static bool IsSupportFormat(this GraphicsDevice device, SharpDX.DXGI.Format format)
        {
            var d3dDevice = device._d3dDevice();
            var fmtSupport = d3dDevice.CheckFormatSupport(format);
            return (fmtSupport & SharpDX.Direct3D11.FormatSupport.Texture2D) != 0;
        }

        public static bool IsSupportBgra4444(this GraphicsDevice device)
        {
            return device.IsSupportFormat(DXGI_FORMAT_B4G4R4A4_UNORM);
        }

        public static bool IsSupportBgr565(this GraphicsDevice device)
        {
            return device.IsSupportFormat(SharpDX.DXGI.Format.B5G6R5_UNorm);
        }

        public static bool IsSupportBgra5551(this GraphicsDevice device)
        {
            return device.IsSupportFormat(SharpDX.DXGI.Format.B5G5R5A1_UNorm);
        }
    }
}

```

`WzComparerR2.Common/Rendering/PngEffect.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Reflection;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;

namespace WzComparerR2.Rendering
{
    public class PngEffect : Effect
    {
        public PngEffect(GraphicsDevice graphicDevice)
            :base(graphicDevice, GetEffectCode())
        {
            this.AlphaMixEnabled = false;
            this.MinMixedAlpha = 255;
            this.MixedColor = Microsoft.Xna.Framework.Color.White;
        }

        public bool AlphaMixEnabled
        {
            get { return alphaMixed; }
            set
            {
                this.CurrentTechnique = this.Techniques[value ? "tech1" : "tech0"];
                this.alphaMixed = value;
            }
        }

        public int MinMixedAlpha
        {
            get { return (int)(this.Parameters["clipAlpha"].GetValueSingle() * 255); }
            set { this.Parameters["clipAlpha"].SetValue((float)value / 255); }
        }

        public Microsoft.Xna.Framework.Color MixedColor
        {
            get { return new Microsoft.Xna.Framework.Color(this.Parameters["mixedColor"].GetValueVector4()); }
            set { this.Parameters["mixedColor"].SetValue(value.ToVector4()); }
        }

        private bool alphaMixed;

        private static byte[] GetEffectCode()
        {
            var asm = Assembly.GetAssembly(typeof(PngEffect));
            
            using (var input = asm.GetManifestResourceStream("WzComparerR2.Rendering.Effect.PngEffect.mgfxo"))
            {
                byte[] code = new byte[input.Length];
                input.Read(code, 0, code.Length);
                return code;
            }
        }
    }
}

```

`WzComparerR2.Common/Rendering/SpriteBatchEx.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using System.Drawing;
using System.Drawing.Imaging;
using System.Drawing.Drawing2D;
using GDIColor = System.Drawing.Color;
using GDIRect = System.Drawing.Rectangle;
using Rectangle = Microsoft.Xna.Framework.Rectangle;
using Color = Microsoft.Xna.Framework.Color;
using Point = Microsoft.Xna.Framework.Point;

namespace WzComparerR2.Rendering
{
    public class SpriteBatchEx : SpriteBatch
    {
        public SpriteBatchEx(GraphicsDevice graphicsDevice)
            : base(graphicsDevice)
        {
            this.singlePixel = CreateSinglePixel();
        }

        Texture2D singlePixel;

        private Texture2D CreateSinglePixel()
        {
            Texture2D pixel = new Texture2D(this.GraphicsDevice, 1, 1, false, SurfaceFormat.Color);
            pixel.SetData(new Color[] { Color.White });
            return pixel;
        }

        public void DrawStringEx(XnaFont xnaFont, string text, Vector2 location, Color color)
        {
            DrawStringEx(xnaFont, text, 0, text == null ? 0 : text.Length, location, Vector2.Zero, color);
        }

        public void DrawStringEx(XnaFont xnaFont, string text, Vector2 location, Vector2 size, Color color)
        {
            DrawStringEx(xnaFont, text, 0, text == null ? 0 : text.Length, location, size, color);
        }

        private void DrawStringEx(XnaFont xnaFont, string text, int startIndex, int length, Vector2 location, Vector2 size, Color color)
        {
            IEnumerable<char> e = TextUtils.CreateCharEnumerator(text, startIndex, length);
            DrawStringEx(xnaFont, e, location, size, color, Vector2.Zero, 0);
        }

        public void DrawStringEx(XnaFont xnaFont, StringBuilder stringBuilder, Vector2 location, Color color)
        {
            DrawStringEx(xnaFont, stringBuilder, 0, stringBuilder == null ? 0 : stringBuilder.Length, location, color, Vector2.Zero);
        }

        public void DrawStringEx(XnaFont xnaFont, StringBuilder stringBuilder, Vector2 location, Color color, Vector2 origin)
        {
            DrawStringEx(xnaFont, stringBuilder, 0, stringBuilder == null ? 0 : stringBuilder.Length, location, color, origin);
        }

        public void DrawStringEx(XnaFont xnaFont, StringBuilder stringBuilder, int startIndex, int length, Vector2 location, Color color)
        {
            DrawStringEx(xnaFont, stringBuilder, startIndex, length, location, color, Vector2.Zero);
        }

        public void DrawStringEx(XnaFont xnaFont, StringBuilder stringBuilder, int startIndex, int length, Vector2 location, Color color, Vector2 origin)
        {
            IEnumerable<char> e = TextUtils.CreateCharEnumerator(stringBuilder, startIndex, length);
            DrawStringEx(xnaFont, e, location, Vector2.Zero, color, origin, 0);
        }

        private void DrawStringEx(XnaFont font, IEnumerable<char> text, Vector2 location, Vector2 size, Color color, Vector2 origin, float layerDepth)
        {
            if (font == null || text == null)
            {
                return;
            }

            float dx = location.X, dy = location.Y;

            foreach (char c in text)
            {
                if (c == '\r')
                {
                    continue;
                }
                else if (c == '\n') //换行符
                {
                    dy += font.Height;
                    dx = location.X;
                    continue;
                }
                else
                {
                    Rectangle rect = font.TryGetRect(c);
                    if (size.X > 0 && dx > location.X && dx + rect.Width > location.X + size.X) //强制换行
                    {
                        dy += font.Height;
                        dx = location.X;
                    }
                    base.Draw(font.TextureBuffer, new Vector2(dx, dy), rect, color, 0f, origin, 1f, SpriteEffects.None, layerDepth);
                    dx += rect.Width;
                }
            }
            location.X = dx;
            location.Y = dy;
        }

        public void DrawPath(Point[] path, Color color)
        {
            Rectangle[] rectPath = new Rectangle[path.Length];
            for (int i = 0; i < path.Length - 1; i++)
            {
                if (path[i].X == path[i + 1].X)
                {
                    int dy = path[i + 1].Y - path[i].Y;
                    if (dy > 0)
                    {
                        rectPath[i] = new Rectangle(path[i].X, path[i].Y, 1, dy);
                    }
                    else if (dy < 0)
                    {
                        rectPath[i] = new Rectangle(path[i].X, path[i + 1].Y + 1, 1, -dy);
                    }
                }
                else if (path[i].Y == path[i + 1].Y)
                {
                    int dx = path[i + 1].X - path[i].X;
                    if (dx > 0)
                    {
                        rectPath[i] = new Rectangle(path[i].X, path[i].Y, dx, 1);
                    }
                    else if (dx < 0)
                    {
                        rectPath[i] = new Rectangle(path[i + 1].X + 1, path[i].Y, -dx, 1);
                    }
                }
            }
            if (path[0] != path[path.Length - 1] || path.Length == 1)
            {
                rectPath[path.Length - 1] = new Rectangle(
                    path[path.Length - 1].X,
                    path[path.Length - 1].Y,
                    1,
                    1);
            }
            for (int i = 0; i < rectPath.Length; i++)
            {
                if (rectPath[i].Width > 0 && rectPath[i].Height > 0)
                {
                    this.FillRectangle(rectPath[i], color);
                }
            }
        }

        public void FillRectangle(Rectangle rectangle, Color color)
        {
            base.Draw(singlePixel, rectangle, color);
        }

        public void FillRectangle(Rectangle rectangle, Color color, Vector2 origin)
        {
            rectangle.X -= (int)origin.X;
            rectangle.Y -= (int)origin.Y;
            base.Draw(singlePixel, rectangle, color);
        }

        public void FillRoundedRectangle(Rectangle rectangle, Color color)
        {
            if (rectangle.Width > 2 && rectangle.Height > 2)
            {
                base.Draw(singlePixel, new Rectangle(rectangle.X + 1, rectangle.Y, rectangle.Width - 2, 1), color);
                base.Draw(singlePixel, new Rectangle(rectangle.X, rectangle.Y + 1, rectangle.Width, rectangle.Height - 2), color);
                base.Draw(singlePixel, new Rectangle(rectangle.X + 1, rectangle.Bottom - 1, rectangle.Width - 2, 1), color);
            }
            else
            {
                base.Draw(singlePixel, rectangle, color);
            }
        }

        public void DrawRectangle(Rectangle rectangle, Color color)
        {
            if (!rectangle.IsEmpty)
            {
                Point[] path = new Point[5];
                path[0] = new Point(rectangle.X, rectangle.Y);
                path[1] = new Point(path[0].X, rectangle.Y + rectangle.Height);
                path[2] = new Point(rectangle.X + rectangle.Width, path[1].Y);
                path[3] = new Point(path[2].X, path[0].Y);
                path[4] = path[0];
                this.DrawPath(path, color);
            }
        }

        public void DrawLine(Point point1, Point point2, int width, Color color)
        {
            if (point1 != point2)
            {
                float length = Vector2.Distance(new Vector2(point1.X, point1.Y), new Vector2(point2.X, point2.Y));
                Rectangle dest = new Rectangle(point1.X, point1.Y, (int)length, width);
                Vector2 origin = new Vector2(0, 0.5f);
                float rot = (float)Math.Atan2(point2.Y - point1.Y, point2.X - point1.X);
                this.Draw(this.singlePixel, dest, null, color, rot, origin, SpriteEffects.None, 0);
            }
        }

        public void Flush()
        {
            this.End();
            this.GetType().BaseType.GetField("_beginCalled", System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic)
                .SetValue(this, true);
        }

        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                if (this.singlePixel != null)
                {
                    this.singlePixel.Dispose();
                }
            }
            base.Dispose(disposing);
        }
    }
}

```

`WzComparerR2.Common/Rendering/TextUtils.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace WzComparerR2.Rendering
{
    internal static class TextUtils
    {
        public static IEnumerable<char> CreateCharEnumerator(string text, int startIndex, int length)
        {
            for (int i = 0; i < length; i++)
            {
                yield return text[startIndex + i];
            }
        }

        public static IEnumerable<char> CreateCharEnumerator(StringBuilder stringBuilder, int startIndex, int length)
        {
            for (int i = 0; i < length; i++)
            {
                yield return stringBuilder[startIndex + i];
            }
        }
    }
}

```

`WzComparerR2.Common/Rendering/WzLibExtension.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using WzComparerR2.WzLib;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;

namespace WzComparerR2.Rendering
{
    public static class WzLibExtension
    {
        public static Texture2D ToTexture(this Wz_Png png, GraphicsDevice graphicsDevice)
        {
            var format = GetTextureFormatOfPng(png.Form);
            if (format == SurfaceFormat.Bgra4444)
            {
                //检测是否支持 pre-win8
                if (!graphicsDevice.IsSupportBgra4444())
                {
                    format = SurfaceFormat.Bgra32;
                }
            }
            else if (format == SurfaceFormat.Bgr565)
            {
                //检测是否支持 pre-win8
                if (!graphicsDevice.IsSupportBgr565())
                {
                    format = SurfaceFormat.Bgra32;
                }
            }
            else if (format == SurfaceFormat.Bgra5551)
            {
                //检测是否支持 pre-win8
                if (!graphicsDevice.IsSupportBgra5551())
                {
                    format = SurfaceFormat.Bgra32;
                }
            }

            var t2d = new Texture2D(graphicsDevice, png.Width, png.Height, false, format);
            png.ToTexture(t2d, Microsoft.Xna.Framework.Point.Zero);
            return t2d;
        }

        public static void ToTexture(this Wz_Png png, Texture2D texture, Microsoft.Xna.Framework.Point origin)
        {
            Microsoft.Xna.Framework.Rectangle rect = new Microsoft.Xna.Framework.Rectangle(origin, new Microsoft.Xna.Framework.Point(png.Width, png.Height));

            //检查大小
            if (rect.X < 0 || rect.Y < 0 || rect.Right > texture.Width || rect.Bottom > texture.Height)
            {
                throw new ArgumentException("Png rectangle is out of bounds.");
            }

            //检查像素格式
            var format = GetTextureFormatOfPng(png.Form);

            if (texture.Format == SurfaceFormat.Bgra32)
            {
                using (var bmp = png.ExtractPng())
                {
                    bmp.ToTexture(texture, origin);
                }
            }
            else if (texture.Format != format)
            {
                throw new ArgumentException($"Texture format({texture.Format}) does not fit the png form({png.Form}).");
            }
            else
            {
                byte[] plainData = png.GetRawData();
                if (plainData == null)
                {
                    throw new Exception("png decoding failed.");
                }

                switch (png.Form)
                {
                    case 1:
                    case 2:
                    case 257:
                    case 513:
                    case 1026:
                    case 2050:
                        texture.SetData(0, 0, rect, plainData, 0, plainData.Length);
                        break;

                    case 3:
                        var pixel = Wz_Png.GetPixelDataForm3(plainData, png.Width, png.Height);
                        texture.SetData(0, 0, rect, pixel, 0, pixel.Length);
                        break;

                    case 517:
                        pixel = Wz_Png.GetPixelDataForm517(plainData, png.Width, png.Height);
                        texture.SetData(0, 0, rect, pixel, 0, pixel.Length);
                        break;

                    default:
                        throw new Exception($"unknown png form ({png.Form}).");
                }
            }
        }

        public static SurfaceFormat GetTextureFormatOfPng(int pngform)
        {
            switch (pngform)
            {
                case 1: return SurfaceFormat.Bgra4444;
                case 2:
                case 3: return SurfaceFormat.Bgra32;
                case 257: return SurfaceFormat.Bgra5551;
                case 513: 
                case 517: return SurfaceFormat.Bgr565;
                case 1026: return SurfaceFormat.Dxt3;
                case 2050: return SurfaceFormat.Dxt5;
                default: return SurfaceFormat.Bgra32;
            }
        }


        public static Microsoft.Xna.Framework.Point ToPoint(this Wz_Vector vector)
        {
            return new Microsoft.Xna.Framework.Point(vector.X, vector.Y);
        }
    }
}

```

`WzComparerR2.Common/Rendering/XnaFont.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;
using System.Drawing.Imaging;
using System.Drawing.Drawing2D;
using System.Drawing.Text;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using GDIColor = System.Drawing.Color;
using GDIRect = System.Drawing.Rectangle;
using Rectangle = Microsoft.Xna.Framework.Rectangle;

namespace WzComparerR2.Rendering
{
    public class XnaFont : IDisposable
    {
        public XnaFont(GraphicsDevice graphicsDevice, FontFamily fontFamily, float size)
            : this(graphicsDevice, new Font(fontFamily, size, GraphicsUnit.Pixel))
        {
        }

        public XnaFont(GraphicsDevice graphicsDevice, string familyName, float size)
            : this(graphicsDevice, new Font(familyName, size, GraphicsUnit.Pixel))
        {
        }

        public XnaFont(GraphicsDevice graphicsDevice, Font baseFont)
        {
            if (graphicsDevice == null || baseFont == null)
            {
                throw new ArgumentNullException();
            }
            this.baseFont = baseFont;
            this.Height = baseFont.Height;
            this.textureBuffer = new Texture2D(graphicsDevice, 2048, 2048, false, SurfaceFormat.Bgra32);
            RebuildGdiBuffer(this.baseFont.Height);
            this.charLocation = new Dictionary<char, Rectangle>();
        }

        Font baseFont;
        Texture2D textureBuffer;
        Bitmap gdiBuffer;
        Graphics g;
        Dictionary<char, Rectangle> charLocation;
        int textureSpaceX;
        int textureSpaceY;
        int textureCurLineHeight;
        int gdiBufferX;

        public Texture2D TextureBuffer
        {
            get { return textureBuffer; }
        }

        public Font BaseFont
        {
            get { return baseFont; }
        }

        public int Height { get; set; }

        public Vector2 MeasureString(string text)
        {
            return MeasureString(text, Vector2.Zero);
        }

        public Vector2 MeasureString(StringBuilder stringBuilder)
        {
            return MeasureString(stringBuilder, Vector2.Zero);
        }

        public Vector2 MeasureString(string text, Vector2 size)
        {
            var ie = TextUtils.CreateCharEnumerator(text, 0, text.Length);
            return MeasureString(ie, size);
        }

        public Vector2 MeasureString(StringBuilder stringBuilder, Vector2 size)
        {
            var ie = TextUtils.CreateCharEnumerator(stringBuilder, 0, stringBuilder.Length);
            return MeasureString(ie, size);
        }

        public Vector2 MeasureString(string text, int startIndex, int length)
        {
            return MeasureString(TextUtils.CreateCharEnumerator(text, startIndex, length), Vector2.Zero);
        }

        public Vector2 MeasureString(StringBuilder stringBuilder, int startIndex, int length)
        {
            return MeasureString(TextUtils.CreateCharEnumerator(stringBuilder, startIndex, length), Vector2.Zero);
        }

        public Vector2 MeasureString(IEnumerable<char> text, Vector2 layoutSize)
        {
            if (text == null)
                return Vector2.Zero;

            Size size = new Size();
            int maxWidth = 0;
            int lineHeight = 0;
            foreach (char c in text)
            {
                if (c == '\r')
                {
                    continue;
                }
                if (c == '\n')
                {
                    if (lineHeight <= 0)
                    {
                        //lineHeight = this.baseFont.Height;
                    }
                    size.Height += this.baseFont.Height;
                    maxWidth = Math.Max(maxWidth, size.Width);
                    size.Width = 0;
                    lineHeight = 0;
                }
                else
                {
                    Rectangle rect = TryGetRect(c);
                    if (layoutSize.X > 0 && size.Width > 0 && size.Width + rect.Width > layoutSize.X) //强制换行
                    {
                        size.Height += this.baseFont.Height;
                        maxWidth = Math.Max(maxWidth, size.Width);
                        size.Width = 0;
                        lineHeight = 0;
                    }
                    size.Width += rect.Width;
                    lineHeight = Math.Max(rect.Height, lineHeight);
                }
            }
            size.Width = Math.Max(maxWidth, size.Width);
            size.Height += lineHeight;
            if (size.Width <= 0)
                return Vector2.Zero;
            return new Vector2(size.Width, size.Height);
        }

        public Rectangle TryGetRect(char c)
        {
            Rectangle rect;
            if (!this.charLocation.TryGetValue(c, out rect))
            {
                rect = this.CreateCharBuffer(c);
                this.charLocation[c] = rect;
            }
            return rect;
        }

        private Rectangle CreateCharBuffer(char c)
        {
            string text = c.ToString();
            SizeF size;

            size = g.MeasureString(text, this.baseFont, byte.MaxValue, StringFormat.GenericTypographic);
            GDIRect originRect = new GDIRect(gdiBufferX, 0, (int)Math.Ceiling(size.Width), (int)Math.Ceiling(size.Height));
            if (originRect.Width == 0)
            {
                originRect.Width = (int)(this.baseFont.Size / 2);
            }
            if (gdiBuffer.Height < originRect.Height)
            {
                RebuildGdiBuffer(originRect.Height);
                originRect.X = 0; //2012-10-3
            }
            if (gdiBufferX + originRect.Width > gdiBuffer.Width)
            {
                g.Clear(GDIColor.Transparent);
                gdiBufferX = 0;
                originRect.X = 0;
            }
            g.DrawString(text, baseFont, Brushes.White, originRect.Location, StringFormat.GenericTypographic);

            //计算范围并且复制图像数据到数组
            byte[] b = new byte[4 * originRect.Width * originRect.Height];
            BitmapData data = gdiBuffer.LockBits(originRect, ImageLockMode.ReadOnly, PixelFormat.Format32bppArgb);
            for (int i = 0; i < originRect.Height; i++)
            {
                IntPtr source = IntPtr.Add(data.Scan0, data.Stride * i);
                System.Runtime.InteropServices.Marshal.Copy(source, b, i * 4 * originRect.Width, 4 * originRect.Width);
            }
            gdiBuffer.UnlockBits(data);
            gdiBufferX += originRect.Width;

            //调整xnaTexture的大小并粘贴图像
            textureBuffer.GraphicsDevice.Textures[0] = null;

            if (textureSpaceX + originRect.Width > textureBuffer.Width)
            {
                textureSpaceX = 0;
                textureSpaceY += textureCurLineHeight;
                textureCurLineHeight = 0;
            }
            textureCurLineHeight = Math.Max(textureCurLineHeight, originRect.Height);
            if (textureSpaceY + textureCurLineHeight > textureBuffer.Height)
            {
                ClearTextureBuffer();
                textureSpaceX = 0;
                textureSpaceY = 0;
                charLocation.Clear();
            }

            Rectangle rect = new Rectangle(textureSpaceX, textureSpaceY, originRect.Width, originRect.Height);

            textureBuffer.SetData(0, rect, b, 0, b.Length);
            textureSpaceX += rect.Width;
            return rect;
        }

        private void RebuildGdiBuffer(int height)
        {
            if (gdiBuffer != null)
            {
                g.Dispose();
                gdiBuffer.Dispose();
            }
            gdiBuffer = new Bitmap(textureBuffer.Width, height, PixelFormat.Format32bppArgb);
            gdiBufferX = 0;
            g = Graphics.FromImage(gdiBuffer);
            g.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAliasGridFit;
            g.SmoothingMode = SmoothingMode.HighQuality;
            // g.CompositingMode = CompositingMode.SourceCopy; 乱用这句出事故...
        }

        private void ClearTextureBuffer()
        {
            int[] ary = new int[textureBuffer.Width * textureBuffer.Height];
            textureBuffer.SetData(ary);
            ary = null;
        }

        ~XnaFont()
        {
            this.Dispose(false);
        }

        public void Dispose()
        {
            this.Dispose(true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (disposing)
            {
                this.textureBuffer.Dispose();
                this.g.Dispose();
                this.baseFont.Dispose();
                this.gdiBuffer.Dispose();
            }
        }

        public static FontFamily GdiLoadFontFile(string fontFileName)
        {
            try
            {
                PrivateFontCollection font = new PrivateFontCollection();
                font.AddFontFile(fontFileName);
                gdiFontCache.Add(font);
                return font.Families[0];
            }
            catch
            {
                return null;
            }
        }

        private static List<PrivateFontCollection> gdiFontCache = new List<PrivateFontCollection>();
    }
}

```

`WzComparerR2.Common/Rendering/XnaFontRenderer.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;
using WzComparerR2.Text;

namespace WzComparerR2.Rendering
{
    public class XnaFontRenderer : TextRenderer<XnaFont>
    {
        public XnaFontRenderer(SpriteBatchEx spriteBatch)
        {
            this.SpriteBatch = spriteBatch;
        }

        public SpriteBatchEx SpriteBatch { get; set; }


        protected override void MeasureRuns(List<Run> runs)
        {
            int x = 0;
            foreach (var run in runs)
            {
                if (run.IsBreakLine)
                {
                    run.X = x;
                    run.Length = 0;
                }
                else
                {
                    var size = base.font.MeasureString(base.sb, run.StartIndex, run.Length);
                    run.X = x;
                    run.Width = (int)size.X;
                    x += run.Width;
                }
            }
        }

        protected override Rectangle[] MeasureChars(int startIndex, int length)
        {
            var regions = new Rectangle[length];
            int x = 0;
            for (int i = 0; i < length; i++)
            {
                var rect = this.font.TryGetRect(this.sb[startIndex + i]);
                regions[i] = new Rectangle(x, 0, rect.Width, rect.Height);
                x += rect.Width;
            }
            return regions;
        }

        protected override void Flush(StringBuilder sb, int startIndex, int length, int x, int y, string colorID)
        {
            var color = this.GetColor(colorID);
            var pos = new Microsoft.Xna.Framework.Vector2(x, y);
            this.SpriteBatch.DrawStringEx(this.font, sb, startIndex, length, pos, color);
        }

        public virtual Microsoft.Xna.Framework.Color GetColor(string colorID)
        {
            switch (colorID)
            {
                case "c":
                    return new Microsoft.Xna.Framework.Color(255, 153, 0);
                default:
                    return Microsoft.Xna.Framework.Color.White;
            }
        }
    }
}

```

`WzComparerR2.Common/SpineLoader.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using WzComparerR2.WzLib;

namespace WzComparerR2.Common
{
    public static class SpineLoader
    {
        private const string AtlasExtension = ".atlas";
        private const string JsonExtension = ".json";
        private const string SkelExtension = ".skel";
        private const string SharedAtlasNodeName = "atlas";

        public static SpineDetectionResult Detect(Wz_Node wzNode)
        {
            if (wzNode == null || wzNode.ParentNode == null)
            {
                return SpineDetectionResult.Failed("WzNode or its parent cannot be null.");
            }
           
            Wz_Node parentNode = wzNode.ParentNode;
            Wz_Node atlasNode = null;
            Wz_Node skelNode = null;
            SkeletonLoadType loadType;
            SpineVersion spineVersion;

            if (wzNode.Text.EndsWith(AtlasExtension)) // detect from atlasNode
            {
                atlasNode = wzNode;
                string spineName = atlasNode.Text.Substring(0, atlasNode.Text.Length - AtlasExtension.Length);

                // find skel node in sibling nodes
                if ((skelNode = parentNode.Nodes[spineName + JsonExtension]) != null)
                {
                    loadType = SkeletonLoadType.Json;
                }
                else if ((skelNode = parentNode.Nodes[spineName] ?? parentNode.Nodes[spineName + SkelExtension]) != null)
                {
                    loadType = SkeletonLoadType.Binary;
                }
                else
                {
                    return SpineDetectionResult.Failed("Failed to find skel node.");
                }
            }
            else // detect from skel node
            {
                skelNode = wzNode;
                string spineName = null;
                if (skelNode.Text.EndsWith(JsonExtension))
                {
                    spineName = skelNode.Text.Substring(0, skelNode.Text.Length - JsonExtension.Length);
                    loadType = SkeletonLoadType.Json;
                }
                else if (skelNode.Text.EndsWith(SkelExtension))
                {
                    spineName = skelNode.Text.Substring(0, skelNode.Text.Length - SkelExtension.Length);
                    loadType = SkeletonLoadType.Binary;
                }
                else
                {
                    switch (skelNode.ResolveUol()?.Value)
                    {
                        case Wz_Sound sound when sound.SoundType == Wz_SoundType.Binary:
                        case Wz_RawData rawData:
                            spineName = skelNode.Text;
                            loadType = SkeletonLoadType.Binary;
                            break;

                        default:
                            return SpineDetectionResult.Failed("Failed to infer the wzNode as atlasNode or skelNode.");
                    }
                }

                if (spineName != null)
                {
                    // find atlas node in sibling nodes
                    // KMST 1172: the atlas node name could be constant
                    atlasNode = parentNode.Nodes[spineName + AtlasExtension] ?? parentNode.Nodes[SharedAtlasNodeName];
                    if (atlasNode == null)
                    {
                        return SpineDetectionResult.Failed("Failed to find atlas node.");
                    }
                }
            }

            // resolve uols
            if ((atlasNode = atlasNode.ResolveUol()) == null)
            {
                return SpineDetectionResult.Failed("Failed to resolve uol for atlasNode.");
            }
            if ((skelNode = skelNode.ResolveUol()) == null)
            {
                return SpineDetectionResult.Failed("Failed to resolve uol for skelNode.");
            }

            // check atlas data type
            if (atlasNode.Value is not string)
            {
                return SpineDetectionResult.Failed("AtlasNode does not contain a string value.");
            }

            // inference spine version
            string versionStr = null;
            switch (loadType)
            {
                case SkeletonLoadType.Json when skelNode.Value is string json:
                    versionStr = ReadSpineVersionFromJson(json);
                    break;

                case SkeletonLoadType.Binary when skelNode.Value is Wz_Sound wzSound && wzSound.SoundType == Wz_SoundType.Binary:
                    versionStr = ReadSpineVersionFromBinary(wzSound.WzFile.FileStream, wzSound.Offset, wzSound.DataLength);
                    break;

                case SkeletonLoadType.Binary when skelNode.Value is Wz_RawData wzRawData:
                    versionStr = ReadSpineVersionFromBinary(wzRawData.WzFile.FileStream, wzRawData.Offset, wzRawData.Length);
                    break;
            }

            if (versionStr == null)
            {
                return SpineDetectionResult.Failed($"Failed to read version string from skel {loadType}.");
            }
            if (!Version.TryParse(versionStr, out var version))
            {
                return SpineDetectionResult.Failed($"Failed to parse version '{versionStr}'.");
            }

            switch (version.Major)
            {
                case 2: spineVersion = SpineVersion.V2; break;
                case 4: spineVersion = SpineVersion.V4; break;
                default: return SpineDetectionResult.Failed($"Spine version '{versionStr}' is not supported."); ;
            }

            return SpineDetectionResult.Create(wzNode, atlasNode, skelNode, loadType, spineVersion);
        }

        private static string ReadSpineVersionFromJson(string jsonText)
        {
            // { "skeleton": { "spine": "2.1.27" } }
            using var sr = new StringReader(jsonText);
            object skelObj = Spine.Json.Deserialize(sr);
            if (skelObj is IDictionary<string, object> jRootDict
                && jRootDict.TryGetValue("skeleton", out var jSkeleton)
                && jSkeleton is IDictionary<string, object> jSkeletonDict
                && jSkeletonDict.TryGetValue("spine", out var jSpine)
                && Version.TryParse(jSpine as string, out var spineVer))
            {
                return jSpine as string;
            }
            return null;
        }

        private static string ReadSpineVersionFromBinary(Stream stream, uint offset, int length)
        {
            /* 
             * v4 format:
             * 00-07 hash
             * 08    version len
             * 09-XX version (len-1 bytes)
             * 
             * v2 format:
             * 00        hash len
             * 01-XX     hash (len-1 bytes)
             * (XX+1)    version len
             * (XX+2)-YY version (len-1 bytes) 
             */

            long oldPos = stream.Position;
            try
            {
                stream.Position = offset;
                // this method can detect version from v4 and pre-v3 file format.
                string version = Spine.SkeletonBinary.GetVersionString(stream);
                return version;
            }
            catch 
            {
                // ignore error;
                return null;
            }
            finally 
            { 
                stream.Position = oldPos;
            }
        }

        public static Spine.V2.SkeletonData LoadSkeletonV2(Wz_Node wzNode, Spine.V2.TextureLoader textureLoader)
        {
            var detectionResult = Detect(wzNode);
            if (detectionResult.Success && detectionResult.Version == SpineVersion.V2)
            {
                return LoadSkeletonV2(detectionResult, textureLoader);
            }
            return null;
        }

        public static Spine.V2.SkeletonData LoadSkeletonV2(SpineDetectionResult detectionResult, Spine.V2.TextureLoader textureLoader)
        { 
            using var atlasReader = new StringReader((string)detectionResult.ResolvedAtlasNode.Value);
            var atlas = new Spine.V2.Atlas(atlasReader, "", textureLoader);

            switch (detectionResult.LoadType)
            {
                case SkeletonLoadType.Json:
                    using (var skeletonReader = new StringReader((string)detectionResult.ResolvedSkelNode.Value))
                    {
                        var skeletonJson = new Spine.V2.SkeletonJson(atlas);
                        return skeletonJson.ReadSkeletonData(skeletonReader);
                    }

                case SkeletonLoadType.Binary:
                    FileStream fs;
                    switch (detectionResult.ResolvedSkelNode.Value)
                    {
                        case Wz_Sound wzSound:
                            fs = wzSound.WzFile.FileStream;
                            fs.Position = wzSound.Offset;
                            break;

                        case Wz_RawData rawData:
                            fs = rawData.WzFile.FileStream;
                            fs.Position = rawData.Offset;
                            break;

                        default:
                            return null;
                    }
                    var skeletonBinary = new Spine.V2.SkeletonBinary(atlas);
                    return skeletonBinary.ReadSkeletonData(fs);

                default:
                    return null;
            }
        }

        public static Spine.SkeletonData LoadSkeletonV4(Wz_Node atlasOrSkelNode, Spine.TextureLoader textureLoader)
        {
            var detectionResult = Detect(atlasOrSkelNode);
            if (detectionResult.Success && detectionResult.Version == SpineVersion.V4)
            {
                return LoadSkeletonV4(detectionResult, textureLoader);
            }
            return null;
        }

        public static Spine.SkeletonData LoadSkeletonV4(SpineDetectionResult detectionResult, Spine.TextureLoader textureLoader)
        {
            using var atlasReader = new StringReader((string)detectionResult.ResolvedAtlasNode.Value);
            var atlas = new Spine.Atlas(atlasReader, "", textureLoader);

            switch (detectionResult.LoadType)
            {
                case SkeletonLoadType.Json:
                    using (var skeletonReader = new StringReader((string)detectionResult.ResolvedSkelNode.Value))
                    {
                        var skeletonJson = new Spine.SkeletonJson(atlas);
                        return skeletonJson.ReadSkeletonData(skeletonReader);
                    }

                case SkeletonLoadType.Binary:
                    FileStream fs;
                    switch (detectionResult.ResolvedSkelNode.Value)
                    {
                        case Wz_Sound wzSound:
                            fs = wzSound.WzFile.FileStream;
                            fs.Position = wzSound.Offset;
                            break;

                        case Wz_RawData rawData:
                            fs = rawData.WzFile.FileStream;
                            fs.Position = rawData.Offset;
                            break;

                        default:
                            return null;
                    }
                    var skeletonBinary = new Spine.SkeletonBinary(atlas);
                    return skeletonBinary.ReadSkeletonData(fs);

                default:
                    return null;
            }
        }
    }

    public enum SkeletonLoadType
    {
        None = 0,
        Json = 1,
        Binary = 2,
    }

    public enum SpineVersion
    {
        Unknown = 0,
        V2 = 2,
        V4 = 4
    }

    public sealed class SpineDetectionResult
    {
        internal SpineDetectionResult()
        {
        }

        public bool Success { get; internal set; }
        public string ErrorDetail { get; internal set; }
        public Wz_Node SourceNode { get; internal set; }
        public Wz_Node ResolvedAtlasNode { get; internal set; }
        public Wz_Node ResolvedSkelNode { get; internal set; }
        public SkeletonLoadType LoadType { get; internal set; }
        public SpineVersion Version { get; internal set; }

        public static SpineDetectionResult Failed(string error = null) => new SpineDetectionResult
        {
            Success = false,
            ErrorDetail = error,
        };

        public static SpineDetectionResult Create(Wz_Node sourceNode, Wz_Node atlasNode, Wz_Node skelNode, SkeletonLoadType loadType, SpineVersion version) => new SpineDetectionResult
        {
            Success = true,
            ErrorDetail = null,
            SourceNode = sourceNode,
            ResolvedAtlasNode = atlasNode,
            ResolvedSkelNode = skelNode,
            LoadType = loadType,
            Version = version
        };
    }
}

```

`WzComparerR2.Common/StringLinker.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using WzComparerR2.WzLib;

namespace WzComparerR2.Common
{
    public class StringLinker
    {
        public StringLinker()
        {
            stringEqp = new Dictionary<int, StringResult>();
            stringItem = new Dictionary<int, StringResult>();
            stringMap = new Dictionary<int, StringResult>();
            stringMob = new Dictionary<int, StringResult>();
            stringNpc = new Dictionary<int, StringResult>();
            stringSkill = new Dictionary<int, StringResult>();
            stringSkill2 = new Dictionary<string, StringResult>();
            stringSetItem = new Dictionary<int, StringResult>();
        }

        public bool Load(Wz_File stringWz, Wz_File itemWz, Wz_File etcWz)
        {
            if (stringWz == null || stringWz.Node == null || itemWz == null || itemWz.Node == null || etcWz == null || etcWz.Node == null)
                return false;
            this.Clear();
            int id;
            foreach (Wz_Node node in stringWz.Node.Nodes)
            {
                Wz_Image image = node.Value as Wz_Image;
                if (image == null)
                    continue;
                switch (node.Text)
                {
                    case "Pet.img":
                    case "Cash.img":
                    case "Ins.img":
                    case "Consume.img":
                        if (!image.TryExtract()) break;
                        foreach (Wz_Node tree in image.Node.Nodes)
                        {
                            if (Int32.TryParse(tree.Text, out id))
                            {
                                StringResult strResult = new StringResult();
                                strResult.Name = GetDefaultString(tree, "name");
                                strResult.Desc = GetDefaultString(tree, "desc");
                                strResult.AutoDesc = GetDefaultString(tree, "autodesc");
                                strResult.FullPath = tree.FullPath;

                                AddAllValue(strResult, tree);
                                stringItem[id] = strResult;
                            }
                        }
                        break;
                    case "Etc.img":
                        if (!image.TryExtract()) break;
                        foreach (Wz_Node tree0 in image.Node.Nodes)
                        {
                            foreach (Wz_Node tree in tree0.Nodes)
                            {
                                if (Int32.TryParse(tree.Text, out id))
                                {
                                    StringResult strResult = new StringResult();
                                    strResult.Name = GetDefaultString(tree, "name");
                                    strResult.Desc = GetDefaultString(tree, "desc");
                                    strResult.FullPath = tree.FullPath;

                                    AddAllValue(strResult, tree);
                                    stringItem[id] = strResult;
                                }
                            }
                        }
                        break;
                    case "Mob.img":
                        if (!image.TryExtract()) break;
                        foreach (Wz_Node tree in image.Node.Nodes)
                        {
                            if (Int32.TryParse(tree.Text, out id))
                            {
                                StringResult strResult = new StringResult();
                                strResult.Name = GetDefaultString(tree, "name");
                                strResult.FullPath = tree.FullPath;

                                AddAllValue(strResult, tree);
                                stringMob[id] = strResult;
                            }
                        }
                        break;
                    case "Npc.img":
                        if (!image.TryExtract()) break;
                        foreach (Wz_Node tree in image.Node.Nodes)
                        {
                            if (Int32.TryParse(tree.Text, out id))
                            {
                                StringResult strResult = new StringResult();
                                strResult.Name = GetDefaultString(tree, "name");
                                strResult.Desc = GetDefaultString(tree, "func");
                                strResult.FullPath = tree.FullPath;

                                AddAllValue(strResult, tree);
                                stringNpc[id] = strResult;
                            }
                        }
                        break;
                    case "Map.img":
                        if (!image.TryExtract()) break;
                        foreach (Wz_Node tree0 in image.Node.Nodes)
                        {
                            foreach (Wz_Node tree in tree0.Nodes)
                            {
                                if (Int32.TryParse(tree.Text, out id))
                                {
                                    StringResult strResult = new StringResult();
                                    strResult.Name = string.Format("{0} : {1}",
                                        GetDefaultString(tree, "streetName"),
                                        GetDefaultString(tree, "mapName"));
                                    strResult.Desc = GetDefaultString(tree, "mapDesc");
                                    strResult.FullPath = tree.FullPath;

                                    AddAllValue(strResult, tree);
                                    stringMap[id] = strResult;
                                }
                            }
                        }
                        break;
                    case "Skill.img":
                        if (!image.TryExtract()) break;
                        foreach (Wz_Node tree in image.Node.Nodes)
                        {
                            StringResult strResult = new StringResultSkill();
                            strResult.Name = GetDefaultString(tree, "name");//?? GetDefaultString(tree, "bookName");
                            strResult.Desc = GetDefaultString(tree, "desc");
                            strResult.Pdesc = GetDefaultString(tree, "pdesc");
                            strResult.SkillH.Add(GetDefaultString(tree, "h"));
                            strResult.SkillpH.Add(GetDefaultString(tree, "ph"));
                            strResult.SkillhcH.Add(GetDefaultString(tree, "hch"));
                            if (strResult.SkillH[0] == null)
                            {
                                strResult.SkillH.RemoveAt(0);
                                for (int i = 1; ; i++)
                                {
                                    string hi = GetDefaultString(tree, "h" + i);
                                    if (string.IsNullOrEmpty(hi))
                                        break;
                                    strResult.SkillH.Add(hi);
                                }
                            }
                            strResult.SkillH.TrimExcess();
                            strResult.SkillpH.TrimExcess();
                            strResult.FullPath = tree.FullPath;

                            AddAllValue(strResult, tree);
                            if (tree.Text.Length >= 7 && Int32.TryParse(tree.Text, out id))
                            {
                                stringSkill[id] = strResult;
                            }
                            stringSkill2[tree.Text] = strResult;
                        }
                        break;
                    case "Eqp.img":
                        if (!image.TryExtract()) break;
                        foreach (Wz_Node tree0 in image.Node.Nodes)
                        {
                            foreach (Wz_Node tree1 in tree0.Nodes)
                            {
                                foreach (Wz_Node tree in tree1.Nodes)
                                {
                                    if (Int32.TryParse(tree.Text, out id))
                                    {
                                        StringResult strResult = new StringResult();
                                        strResult.Name = GetDefaultString(tree, "name");
                                        strResult.Desc = GetDefaultString(tree, "desc");
                                        strResult.FullPath = tree.FullPath;

                                        AddAllValue(strResult, tree);
                                        stringEqp[id] = strResult;
                                    }
                                }
                            }
                        }
                        break;
                }
            }

            foreach (Wz_Node node in itemWz.Node.FindNodeByPath("Special").Nodes)
            {
                Wz_Image image = node.Value as Wz_Image;
                if (image == null)
                    continue;
                switch (node.Text)
                {
                    case "0910.img":
                        if (!image.TryExtract()) break;
                        foreach (Wz_Node tree in image.Node.Nodes)
                        {
                            if (Int32.TryParse(tree.Text, out id))
                            {
                                StringResult strResult = new StringResult();
                                strResult.Name = GetDefaultString(tree, "name");
                                strResult.Desc = GetDefaultString(tree, "desc");
                                strResult.FullPath = tree.FullPath;

                                AddAllValue(strResult, tree);
                                stringItem[id] = strResult;
                            }
                        }
                        break;
                }
            }

            foreach (Wz_Node node in etcWz.Node.Nodes)
            {
                Wz_Image image = node.Value as Wz_Image;
                if (image == null)
                    continue;
                switch (node.Text)
                {
                    case "SetItemInfo.img":
                        if (!image.TryExtract()) break;
                        foreach (Wz_Node tree in image.Node.Nodes)
                        {
                            if (Int32.TryParse(tree.Text, out id))
                            {
                                StringResult strResult = new StringResult();
                                strResult.Name = GetDefaultString(tree, "setItemName");
                                strResult.FullPath = tree.FullPath;

                                AddAllValue(strResult, tree);
                                stringSetItem[id] = strResult;
                            }
                        }
                        break;
                }
            }

            return this.HasValues;
        }

        public bool Load(Wz_Node stringWz, Wz_Node itemWz, Wz_Node etcWz)
        {
            if (stringWz == null || itemWz == null || etcWz == null)
                return false;
            this.Clear();
            int id;
            foreach (Wz_Node node in stringWz.Nodes)
            {
                Wz_Image image = node.Value as Wz_Image;
                if (image == null)
                    continue;
                switch (node.Text)
                {
                    case "Item.img":
                        if (!image.TryExtract()) break;
                        foreach (Wz_Node tree0 in image.Node.Nodes)
                        {
                            if (tree0.Text == "Eqp")
                            {
                                foreach (Wz_Node tree1 in tree0.Nodes)
                                {
                                    foreach (Wz_Node tree in tree1.Nodes)
                                    {
                                        if (Int32.TryParse(tree.Text, out id))
                                        {
                                            StringResult strResult = new StringResult();
                                            strResult.Name = GetDefaultString(tree, "name");
                                            strResult.Desc = GetDefaultString(tree, "desc");
                                            strResult.FullPath = tree.FullPath;

                                            AddAllValue(strResult, tree);
                                            stringEqp[id] = strResult;
                                        }
                                    }
                                }
                            }
                            else
                            {
                                foreach (Wz_Node tree in tree0.Nodes)
                                {
                                    if (Int32.TryParse(tree.Text, out id))
                                    {
                                        StringResult strResult = new StringResult();
                                        strResult.Name = GetDefaultString(tree, "name");
                                        strResult.Desc = GetDefaultString(tree, "desc");
                                        strResult.AutoDesc = GetDefaultString(tree, "autodesc");
                                        strResult.FullPath = tree.FullPath;

                                        AddAllValue(strResult, tree);
                                        stringItem[id] = strResult;
                                    }
                                }
                            }
                        }
                        break;

                    case "Mob.img":
                        if (!image.TryExtract()) break;
                        foreach (Wz_Node tree in image.Node.Nodes)
                        {
                            if (Int32.TryParse(tree.Text, out id))
                            {
                                StringResult strResult = new StringResult();
                                strResult.Name = GetDefaultString(tree, "name");
                                strResult.FullPath = tree.FullPath;

                                AddAllValue(strResult, tree);
                                stringMob[id] = strResult;
                            }
                        }
                        break;
                    case "Npc.img":
                        if (!image.TryExtract()) break;
                        foreach (Wz_Node tree in image.Node.Nodes)
                        {
                            if (Int32.TryParse(tree.Text, out id))
                            {
                                StringResult strResult = new StringResult();
                                strResult.Name = GetDefaultString(tree, "name");
                                strResult.Desc = GetDefaultString(tree, "func");
                                strResult.FullPath = tree.FullPath;

                                AddAllValue(strResult, tree);
                                stringNpc[id] = strResult;
                            }
                        }
                        break;
                    case "Map.img":
                        if (!image.TryExtract()) break;
                        foreach (Wz_Node tree0 in image.Node.Nodes)
                        {
                            foreach (Wz_Node tree in tree0.Nodes)
                            {
                                if (Int32.TryParse(tree.Text, out id))
                                {
                                    StringResult strResult = new StringResult();
                                    strResult.Name = string.Format("{0} : {1}",
                                        GetDefaultString(tree, "streetName"),
                                        GetDefaultString(tree, "mapName"));
                                    strResult.Desc = GetDefaultString(tree, "mapDesc");
                                    strResult.FullPath = tree.FullPath;

                                    AddAllValue(strResult, tree);
                                    stringMap[id] = strResult;
                                }
                            }
                        }
                        break;
                    case "Skill.img":
                        if (!image.TryExtract()) break;
                        foreach (Wz_Node tree in image.Node.Nodes)
                        {
                            StringResult strResult = new StringResultSkill();
                            strResult.Name = GetDefaultString(tree, "name");//?? GetDefaultString(tree, "bookName");
                            strResult.Desc = GetDefaultString(tree, "desc");
                            strResult.Pdesc = GetDefaultString(tree, "pdesc");
                            strResult.SkillH.Add(GetDefaultString(tree, "h"));
                            strResult.SkillpH.Add(GetDefaultString(tree, "ph"));
                            strResult.SkillhcH.Add(GetDefaultString(tree, "hch"));
                            if (strResult.SkillH[0] == null)
                            {
                                strResult.SkillH.RemoveAt(0);
                                for (int i = 1; ; i++)
                                {
                                    string hi = GetDefaultString(tree, "h" + i);
                                    if (string.IsNullOrEmpty(hi))
                                        break;
                                    strResult.SkillH.Add(hi);
                                }
                            }
                            strResult.SkillH.TrimExcess();
                            strResult.SkillpH.TrimExcess();
                            strResult.FullPath = tree.FullPath;

                            AddAllValue(strResult, tree);
                            if (tree.Text.Length >= 7 && Int32.TryParse(tree.Text, out id))
                            {
                                stringSkill[id] = strResult;
                            }
                            stringSkill2[tree.Text] = strResult;
                        }
                        break;

                }
            }

            foreach (Wz_Node node in itemWz.FindNodeByPath("Special").Nodes)
            {
                Wz_Image image = node.Value as Wz_Image;
                if (image == null)
                    continue;
                switch (node.Text)
                {
                    case "0910.img":
                        if (!image.TryExtract()) break;
                        foreach (Wz_Node tree in image.Node.Nodes)
                        {
                            if (Int32.TryParse(tree.Text, out id))
                            {
                                StringResult strResult = new StringResult();
                                strResult.Name = GetDefaultString(tree, "name");
                                strResult.Desc = GetDefaultString(tree, "desc");
                                strResult.FullPath = tree.FullPath;

                                AddAllValue(strResult, tree);
                                stringItem[id] = strResult;
                            }
                        }
                        break;
                }
            }

            foreach (Wz_Node node in etcWz.Nodes)
            {
                Wz_Image image = node.Value as Wz_Image;
                if (image == null)
                    continue;
                switch (node.Text)
                {
                    case "SetItemInfo.img":
                        if (!image.TryExtract()) break;
                        foreach (Wz_Node tree in image.Node.Nodes)
                        {
                            if (Int32.TryParse(tree.Text, out id))
                            {
                                StringResult strResult = new StringResult();
                                strResult.Name = GetDefaultString(tree, "setItemName");
                                strResult.FullPath = tree.FullPath;

                                AddAllValue(strResult, tree);
                                stringSetItem[id] = strResult;
                            }
                        }
                        break;
                }
            }

            return this.HasValues;
        }


        public bool Load(Wz_File stringWz)
        {
            if (stringWz == null || stringWz.Node == null)
                return false;
            this.Clear();
            int id;
            foreach (Wz_Node node in stringWz.Node.Nodes)
            {
                Wz_Image image = node.Value as Wz_Image;
                if (image == null)
                    continue;
                switch (node.Text)
                {
                    case "Pet.img":
                    case "Cash.img":
                    case "Ins.img":
                    case "Consume.img":
                        if (!image.TryExtract()) break;
                        foreach (Wz_Node tree in image.Node.Nodes)
                        {
                            if (Int32.TryParse(tree.Text, out id))
                            {
                                StringResult strResult = new StringResult();
                                strResult.Name = GetDefaultString(tree, "name");
                                strResult.Desc = GetDefaultString(tree, "desc");
                                strResult.AutoDesc = GetDefaultString(tree, "autodesc");
                                strResult.FullPath = tree.FullPath;

                                AddAllValue(strResult, tree);
                                stringItem[id] = strResult;
                            }
                        }
                        break;
                    case "Etc.img":
                        if (!image.TryExtract()) break;
                        foreach (Wz_Node tree0 in image.Node.Nodes)
                        {
                            foreach (Wz_Node tree in tree0.Nodes)
                            {
                                if (Int32.TryParse(tree.Text, out id))
                                {
                                    StringResult strResult = new StringResult();
                                    strResult.Name = GetDefaultString(tree, "name");
                                    strResult.Desc = GetDefaultString(tree, "desc");
                                    strResult.FullPath = tree.FullPath;

                                    AddAllValue(strResult, tree);
                                    stringItem[id] = strResult;
                                }
                            }
                        }
                        break;
                    case "Mob.img":
                        if (!image.TryExtract()) break;
                        foreach (Wz_Node tree in image.Node.Nodes)
                        {
                            if (Int32.TryParse(tree.Text, out id))
                            {
                                StringResult strResult = new StringResult();
                                strResult.Name = GetDefaultString(tree, "name");
                                strResult.FullPath = tree.FullPath;

                                AddAllValue(strResult, tree);
                                stringMob[id] = strResult;
                            }
                        }
                        break;
                    case "Npc.img":
                        if (!image.TryExtract()) break;
                        foreach (Wz_Node tree in image.Node.Nodes)
                        {
                            if (Int32.TryParse(tree.Text, out id))
                            {
                                StringResult strResult = new StringResult();
                                strResult.Name = GetDefaultString(tree, "name");
                                strResult.Desc = GetDefaultString(tree, "func");
                                strResult.FullPath = tree.FullPath;

                                AddAllValue(strResult, tree);
                                stringNpc[id] = strResult;
                            }
                        }
                        break;
                    case "Map.img":
                        if (!image.TryExtract()) break;
                        foreach (Wz_Node tree0 in image.Node.Nodes)
                        {
                            foreach (Wz_Node tree in tree0.Nodes)
                            {
                                if (Int32.TryParse(tree.Text, out id))
                                {
                                    StringResult strResult = new StringResult();
                                    strResult.Name = string.Format("{0}：{1}",
                                        GetDefaultString(tree, "streetName"),
                                        GetDefaultString(tree, "mapName"));
                                    strResult.Desc = GetDefaultString(tree, "mapDesc");
                                    strResult.FullPath = tree.FullPath;

                                    AddAllValue(strResult, tree);
                                    stringMap[id] = strResult;
                                }
                            }
                        }
                        break;
                    case "Skill.img":
                        if (!image.TryExtract()) break;
                        foreach (Wz_Node tree in image.Node.Nodes)
                        {
                            StringResult strResult = new StringResultSkill();
                            strResult.Name = GetDefaultString(tree, "name");//?? GetDefaultString(tree, "bookName");
                            strResult.Desc = GetDefaultString(tree, "desc");
                            strResult.Pdesc = GetDefaultString(tree, "pdesc");
                            strResult.SkillH.Add(GetDefaultString(tree, "h"));
                            strResult.SkillpH.Add(GetDefaultString(tree, "ph"));
                            strResult.SkillhcH.Add(GetDefaultString(tree, "hch"));
                            if (strResult.SkillH[0] == null)
                            {
                                strResult.SkillH.RemoveAt(0);
                                for (int i = 1; ; i++)
                                {
                                    string hi = GetDefaultString(tree, "h" + i);
                                    if (string.IsNullOrEmpty(hi))
                                        break;
                                    strResult.SkillH.Add(hi);
                                }
                            }
                            strResult.SkillH.TrimExcess();
                            strResult.SkillpH.TrimExcess();
                            strResult.FullPath = tree.FullPath;

                            AddAllValue(strResult, tree);
                            if (tree.Text.Length >= 7 && Int32.TryParse(tree.Text, out id))
                            {
                                stringSkill[id] = strResult;
                            }
                            stringSkill2[tree.Text] = strResult;
                        }
                        break;
                    case "Eqp.img":
                        if (!image.TryExtract()) break;
                        foreach (Wz_Node tree0 in image.Node.Nodes)
                        {
                            foreach (Wz_Node tree1 in tree0.Nodes)
                            {
                                foreach (Wz_Node tree in tree1.Nodes)
                                {
                                    if (Int32.TryParse(tree.Text, out id))
                                    {
                                        StringResult strResult = new StringResult();
                                        strResult.Name = GetDefaultString(tree, "name");
                                        strResult.Desc = GetDefaultString(tree, "desc");
                                        strResult.FullPath = tree.FullPath;

                                        AddAllValue(strResult, tree);
                                        stringEqp[id] = strResult;
                                    }
                                }
                            }
                        }
                        break;
                }
            }

            return this.HasValues;
        }

        public void Clear()
        {
            stringEqp.Clear();
            stringItem.Clear();
            stringMob.Clear();
            stringMap.Clear();
            stringNpc.Clear();
            stringSkill.Clear();
            stringSkill2.Clear();
            stringSetItem.Clear();
        }

        public bool HasValues
        {
            get
            {
                return (stringEqp.Count + stringItem.Count + stringMap.Count +
                    stringMob.Count + stringNpc.Count + stringSkill.Count + stringSetItem.Count > 0);
            }
        }

        private Dictionary<int, StringResult> stringEqp;
        private Dictionary<int, StringResult> stringItem;
        private Dictionary<int, StringResult> stringMap;
        private Dictionary<int, StringResult> stringMob;
        private Dictionary<int, StringResult> stringNpc;
        private Dictionary<int, StringResult> stringSkill;
        private Dictionary<string, StringResult> stringSkill2;
        private Dictionary<int, StringResult> stringSetItem;

        private string GetDefaultString(Wz_Node node, string searchNodeText)
        {
            node = node.FindNodeByPath(searchNodeText);
            return node == null ? null : Convert.ToString(node.Value);
        }

        private void AddAllValue(StringResult sr, Wz_Node node)
        {
            foreach (Wz_Node child in node.Nodes)
            {
                if (child.Value != null)
                {
                    sr[child.Text] = child.GetValue<string>();
                }
            }
        }

        public Dictionary<int, StringResult> StringEqp
        {
            get { return stringEqp; }
        }

        public Dictionary<int, StringResult> StringItem
        {
            get { return stringItem; }
        }

        public Dictionary<int, StringResult> StringMap
        {
            get { return stringMap; }
        }

        public Dictionary<int, StringResult> StringMob
        {
            get { return stringMob; }
        }

        public Dictionary<int, StringResult> StringNpc
        {
            get { return stringNpc; }
        }

        public Dictionary<int, StringResult> StringSkill
        {
            get { return stringSkill; }
        }

        public Dictionary<string, StringResult> StringSkill2
        {
            get { return stringSkill2; }
        }

        public Dictionary<int, StringResult> StringSetItem
        {
            get { return stringSetItem; }
        }

    }
}
```

`WzComparerR2.Common/StringResult.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace WzComparerR2.Common
{
    public class StringResult
    {
        public StringResult()
        {
        }

        public string Name { get; set; }
        public string Desc { get; set; }
        public string Pdesc { get; set; }
        public string AutoDesc { get; set; }
        public string FullPath { get; set; }

        private List<KeyValuePair<string, string>> allValues;

        public virtual List<string> SkillH
        {
            get { return null; }
        }

        public virtual List<string> SkillpH
        {
            get { return null; }
        }

        public virtual List<string> SkillhcH
        {
            get { return null; }
        }

        public string this[string key]
        {
            get
            {
                if (this.allValues != null && key != null)
                {
                    foreach(var kv in this.allValues)
                    {
                        if (kv.Key == key)
                        {
                            return kv.Value;
                        }
                    }
                }
                return null;
            }
            set
            {
                if (key != null)
                {
                    if (this.allValues == null)
                    {
                        this.allValues = new List<KeyValuePair<string, string>>();
                    }

                    for(int i = 0; i < this.allValues.Count; i++)
                    {
                        var kv = this.allValues[i];
                        if (kv.Key == key)
                        {
                            this.allValues[i] = new KeyValuePair<string, string>(key, value);
                            return;
                        }
                    }
                    this.allValues.Add(new KeyValuePair<string, string>(key, value));
                }
            }
        }
    }

    public sealed class StringResultSkill : StringResult
    {

        public StringResultSkill()
        {
            this.skillH = new List<string>();
            this.skillpH = new List<string>();
            this.skillhcH = new List<string>();
        }

        public override List<string> SkillH
        {
            get { return this.skillH; }
        }

        public override List<string> SkillpH
        {
            get { return this.skillpH; }
        }

        public override List<string> SkillhcH
        {
            get { return this.skillhcH; }
        }

        private readonly List<string> skillH;
        private readonly List<string> skillpH;
        private readonly List<string> skillhcH;
    }
}

```

`WzComparerR2.Common/Text/DocumentElements.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Drawing;

namespace WzComparerR2.Text
{
    public abstract class DocElement
    {
    }

    public sealed class Span : DocElement
    {
        public string ColorID { get; set; }
        public string Text { get; set; }
    }

    public sealed class LineBreak : DocElement
    {
        private LineBreak() { }
        public static readonly LineBreak Instance = new LineBreak();
    }
}

```

`WzComparerR2.Common/Text/Parser.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace WzComparerR2.Text
{
    public class Parser
    {
        private Parser()
        {
        }

        public static IList<DocElement> Parse(string format)
        {
            var elements = new List<DocElement>();
            var sb = new StringBuilder();
            var colorStack = new Stack<string>();
            colorStack.Push("");

            int strPos = 0;
            char curChar;

            int offset = 0;

            Action flushRun = () =>
            {
                if (offset < format.Length && sb.Length > offset)
                {
                    elements.Add(new Span()
                    {
                        Text = sb.ToString(offset, sb.Length - offset),
                        ColorID = colorStack.Peek()
                    });
                    offset = sb.Length;
                }
            };

            while (strPos < format.Length)
            {
                curChar = format[strPos++];
                if (curChar == '\\')
                {
                    if (strPos < format.Length)
                    {
                        curChar = format[strPos++];
                        switch (curChar)
                        {
                            case 'r': curChar = '\r'; break;
                            case 'n': curChar = '\n'; break;
                        }
                    }
                    else //结束符处理
                    {
                        curChar = '#';
                    }
                }

                switch (curChar)
                {
                    case '#':
                        if (strPos < format.Length && format[strPos] == 'c')//遇到#c 换橙刷子并flush
                        {
                            flushRun();
                            colorStack.Push("c");
                            strPos++;
                        }
                        else if (strPos < format.Length && format[strPos] == 'g')//遇到#g(自定义) 换绿刷子并flush
                        {
                            flushRun();
                            colorStack.Push("g");
                            strPos++;
                        }
                        else if (strPos < format.Length && format[strPos] == '$')//遇到#$(自定义) 换青色刷子并flush
                        {
                            flushRun();
                            colorStack.Push("$");
                            strPos++;
                        }
                        else if (colorStack.Count == 1) //同#c
                        {
                            flushRun();
                            colorStack.Push("c");
                            //strPos++;
                        }
                        else//遇到# 换白刷子并flush
                        {
                            flushRun();
                            colorStack.Pop();
                        }
                        break;

                    case '\r': //忽略
                        break;

                    case '\n': //插入换行
                        flushRun();
                        elements.Add(LineBreak.Instance);
                        break;

                    default:
                        sb.Append(curChar);
                        break;
                }
            }

            flushRun();
            return elements;
        }
    }
}

```

`WzComparerR2.Common/Text/TextRenderer.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Drawing;

namespace WzComparerR2.Text
{
    public abstract class TextRenderer<TFont>
    {
        public TextRenderer()
        {
            sb = new StringBuilder();
        }

        public bool WordWrapEnabled { get; set; }

        const int MAX_RANGES = 32;

        protected StringBuilder sb;
        protected TFont font;

        public void DrawFormatString(string s, TFont font, int width, ref int y, int height)
        {
            //初始化环境
            this.font = font;
            this.sb.Clear();
            this.sb.EnsureCapacity(s.Length);

            //读取格式
            var doc = Parser.Parse(s);
            var runs = PrepareRuns(doc);

            //拆分成词
            runs = runs.SelectMany(run => SplitWords(run)).ToList();

            //对词进行measure
            MeasureRuns(runs);

            //直接绘制
            DrawRuns(runs, width, ref y, height);
        }

        public void DrawPlainText(string s, TFont font, int width, ref int y, int height)
        {
            this.font = font;
            this.sb.Clear();
            this.sb.EnsureCapacity(s.Length);

            var runs = PrepareRuns(s);
            runs = runs.SelectMany(run => SplitWords(run)).ToList();
            MeasureRuns(runs);
            DrawRuns(runs, width, ref y, height);
        }

        private List<Run> PrepareRuns(IList<DocElement> doc)
        {
            var runs = new List<Run>();
            foreach (var elem in doc)
            {
                if (elem is Span)
                {
                    var span = (Span)elem;
                    int start = sb.Length;
                    sb.Append(span.Text);
                    runs.Add(new Run(start, sb.Length - start) { ColorID = span.ColorID });
                }
                else if (elem is LineBreak)
                {
                    runs.Add(new Run(sb.Length, 0) { IsBreakLine = true });
                }
            }
            return runs;
        }

        private List<Run> PrepareRuns(string text)
        {
            List<Run> runs = new List<Run>();
            var sr = new System.IO.StringReader(text);
            for (int row = 0; sr.Peek() > -1; row++)
            {
                if (row > 0)
                {
                    runs.Add(new Run(sb.Length, 0) { IsBreakLine = true });
                }
                var line = sr.ReadLine();
                if (!string.IsNullOrEmpty(line))
                {
                    sb.Append(line);
                    runs.Add(new Run(sb.Length - line.Length, line.Length));
                }
            }
            return runs;
        }

        private List<Run> SplitWords(Run run)
        {
            List<Run> runs = new List<Run>();

            if (run.IsBreakLine)
            {
                runs.Add(run);
            }
            else
            {
                for (int i = run.StartIndex, i0 = run.StartIndex + run.Length; i < i0; i++)
                {
                    int start = i, len;
                    switch (sb[i])
                    {
                        case ' ':
                        case '\t':
                            while (++i < i0)
                            {
                                if (!(sb[i] == ' ' || sb[i] == '\t'))
                                {
                                    break;
                                }
                            }
                            len = (i--) - start;
                            runs.Add(new Run(start, len) { IsWhiteSpace = true });
                            break;

                        case '\r':
                            if (i + 1 < i0 && sb[i + 1] == '\n')
                            {
                                i++;
                                goto case '\n';
                            }
                            else
                            {
                                runs.Add(new Run(start, 1) { IsWhiteSpace = true });
                            }
                            break;

                        case '\n':
                            len = i - start + 1;
                            runs.Add(new Run(start, len) { IsBreakLine = true });
                            break;

                        default:
                            if (this.WordWrapEnabled)
                            {
                                while (++i < i0)
                                {
                                    if (sb[i] == ' ' || sb[i] == '\t' || sb[i] == '\r' || sb[i] == '\n')
                                    {
                                        break;
                                    }
                                }

                                len = (i--) - start;
                                runs.Add(new Run(start, len) { ColorID = run.ColorID });
                            }
                            else
                            {
                                runs.Add(new Run(start, 1) { ColorID = run.ColorID });
                            }
                            break;
                    }
                }
            }
            return runs;
        }

        private float GetFontLineHeight(Font font)
        {
            var ff = font.FontFamily;
            return (float)Math.Ceiling(1.0 * font.Height * ff.GetLineSpacing(font.Style) / ff.GetEmHeight(font.Style));
        }

        protected abstract void MeasureRuns(List<Run> runs);

        protected abstract Rectangle[] MeasureChars(int startIndex, int length);

        protected abstract void Flush(StringBuilder sb, int startIndex, int length, int x, int y, string ColorID);

        private void DrawRuns(List<Run> runs, int width, ref int y, int lineHeight)
        {
            int drawX = 0;
            int drawY = y;
            int start = -1, end = -1;
            int xOffset = 0;

            int curX = drawX;

            Func<bool> hasContent = () => start > -1 && end > start;
            string colorID = null;

            Action<bool> flush = (isNewLine) =>
            {
                if (hasContent())
                {
                    Flush(sb, start, end - start, drawX, drawY, colorID);
                }
                if (isNewLine)
                {
                    drawX = curX = 0;
                    drawY += lineHeight;
                }
                else
                {
                    drawX = curX;
                }
                start = end = -1;
            };

            for (int r = 0; r < runs.Count; r++)
            {
                var run = runs[r];
                if (run.IsBreakLine)
                { //强行换行 并且flush
                    flush(true);
                    if (r < runs.Count - 1)
                    {
                        xOffset = runs[r + 1].X;
                    }
                }
                else
                {
                    if (!run.IsWhiteSpace && run.ColorID != colorID)
                    {
                        end = run.StartIndex;
                        curX = run.X - xOffset;
                        flush(false);
                        colorID = run.ColorID;
                    }

                    if (start < 0)
                    {
                        start = run.StartIndex;
                    }

                    if (!(run.IsWhiteSpace && run.Width <= 0))
                    { //非空 计算宽度
                        curX = run.X - xOffset;
                        if (this.WordWrapEnabled ? (width - curX < run.Width) : (curX >= width))  //奇怪的算法 暂定
                        { //宽度不够
                            if (curX > 0) //(hasContent())
                            { //有内容
                                // 判断行尾标点是否追加
                                if (run.ColorID == colorID && run.Length == 1 && ",.".IndexOf(this.sb[run.StartIndex]) > -1)
                                {
                                    end = run.StartIndex + run.Length;
                                    if (++r >= runs.Count)
                                    {
                                        break;
                                    }
                                    run = runs[r];
                                }
                                flush(true);
                                start = run.StartIndex;
                                xOffset = run.X;
                            }
                            if (width - curX < run.Width)
                            { //宽度还是不够 按字符拆分
                                var rects = MeasureChars(run.StartIndex, run.Length);

                                for (int i = 0, ir = run.StartIndex; i < rects.Length; i++, ir++)
                                {
                                    rects[i].X += run.X;

                                    if (start < 0)
                                    {
                                        start = ir;
                                        xOffset = run.X;
                                    }

                                    if (rects[i].Right - xOffset > width)
                                    { //超宽 flush之前内容
                                        if (ir - start <= 0)
                                        { //限定至少输出一个字符
                                            end = start + 1;
                                            flush(true);
                                            xOffset = rects[i].Right;
                                            continue;
                                        }
                                        else
                                        {
                                            end = ir;
                                            flush(true);
                                            start = ir;
                                            xOffset = rects[i].X;
                                        }
                                    }
                                }
                                end = run.StartIndex + run.Length;
                                curX = rects[rects.Length - 1].Right - xOffset;
                                flush(false);

                                continue;
                            }
                        }
                    }

                    //正常绘制
                    end = run.StartIndex + run.Length;

                }
            }

            //输出结尾
            flush(true);
            y = drawY;
        }
    }

    public class Run
    {
        public Run(int startIndex, int length)
        {
            this.StartIndex = startIndex;
            this.Length = length;
        }

        public int StartIndex;
        public int Length;
        public bool IsWhiteSpace;
        public bool IsBreakLine;
        public int X;
        public int Width;
        public string ColorID;
    }
}

```

`WzComparerR2.Common/WzComparerR2.Common.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net6.0-windows</TargetFramework>
    <Nullable>enable</Nullable>
    <UseWindowsForms>true</UseWindowsForms>
    <ImplicitUsings>enable</ImplicitUsings>
    <AllowUnsafeBlocks>True</AllowUnsafeBlocks>
  </PropertyGroup>

  <ItemGroup>
    <Reference Include="DevComponents.DotNetBar2">
      <HintPath>bin\Release\net6.0-windows\DevComponents.DotNetBar2.dll</HintPath>
    </Reference>
    <Reference Include="ImageManipulation">
      <HintPath>bin\Release\net6.0-windows\ImageManipulation.dll</HintPath>
    </Reference>
    <Reference Include="MonoGame.Framework">
      <HintPath>bin\Release\net6.0-windows\MonoGame.Framework.dll</HintPath>
    </Reference>
    <Reference Include="SharpDX">
      <HintPath>bin\Release\net6.0-windows\SharpDX.dll</HintPath>
    </Reference>
    <Reference Include="SharpDX.Direct2D1">
      <HintPath>bin\Release\net6.0-windows\SharpDX.Direct2D1.dll</HintPath>
    </Reference>
    <Reference Include="SharpDX.Direct3D11">
      <HintPath>bin\Release\net6.0-windows\SharpDX.Direct3D11.dll</HintPath>
    </Reference>
    <Reference Include="SharpDX.Direct3D9">
      <HintPath>bin\Release\net6.0-windows\SharpDX.Direct3D9.dll</HintPath>
    </Reference>
    <Reference Include="SharpDX.DXGI">
      <HintPath>bin\Release\net6.0-windows\SharpDX.DXGI.dll</HintPath>
    </Reference>
    <Reference Include="SharpDX.Mathematics">
      <HintPath>bin\Release\net6.0-windows\SharpDX.Mathematics.dll</HintPath>
    </Reference>
    <Reference Include="SharpDX.MediaFoundation">
      <HintPath>bin\Release\net6.0-windows\SharpDX.MediaFoundation.dll</HintPath>
    </Reference>
    <Reference Include="SharpDX.XAudio2">
      <HintPath>bin\Release\net6.0-windows\SharpDX.XAudio2.dll</HintPath>
    </Reference>
    <Reference Include="SharpDX.XInput">
      <HintPath>bin\Release\net6.0-windows\SharpDX.XInput.dll</HintPath>
    </Reference>
    <Reference Include="spine-monogame">
      <HintPath>bin\Release\net6.0-windows\spine-monogame.dll</HintPath>
    </Reference>
    <Reference Include="WzComparerR2.PluginBase">
      <HintPath>..\WzComparerR2.PluginBase\bin\Release\net6.0-windows\WzComparerR2.PluginBase.dll</HintPath>
    </Reference>
    <Reference Include="WzComparerR2.WzLib">
      <HintPath>..\WzComparerR2.WzLib\bin\Release\net6.0-windows\WzComparerR2.WzLib.dll</HintPath>
    </Reference>
  </ItemGroup>

</Project>

```

`WzComparerR2.Common/Wz_NodeExtension2.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using WzComparerR2.WzLib;
using System.Drawing;
using System.IO;
using Microsoft.Xna.Framework;
using WzComparerR2.PluginBase;

namespace WzComparerR2.Common
{
    public static class Wz_NodeExtension2
    {
        public static Wz_Node GetLinkedSourceNode(this Wz_Node node, GlobalFindNodeFunction findNode)
        {
            string path;

            if (!string.IsNullOrEmpty(path = node.Nodes["source"].GetValueEx<string>(null)))
            {
                return findNode?.Invoke(path);
            }
            else if (!string.IsNullOrEmpty(path = node.Nodes["_inlink"].GetValueEx<string>(null)))
            {
                var img = node.GetNodeWzImage();
                return img?.Node.FindNodeByPath(true, path.Split('/'));
            }
            else if (!string.IsNullOrEmpty(path = node.Nodes["_outlink"].GetValueEx<string>(null)))
            {
                return findNode?.Invoke(path);
            }
            else
            {
                return node;
            }
        }

        public static Wz_Node Get(this Wz_Node Node, string Path)
        {
            var Split = Path.Split('/');
            var Result = Node;
            for (int i = 0; i < Split.Length; i++)
            {
                if (Split[i] == "..")
                    Result = Result.ParentNode;
                else
                    Result = Result.Nodes[Split[i]];
                if (Result == null)
                    return null;
            }
            return Result;
        }

        public static string IDString(this string Str)
        {
            return int.Parse(Str).ToString();

        }

        public static string GetPathD(this Wz_Node Node)
        {
            if (Node != null)
            {
                Stack<string> Path = new Stack<string>();
                Wz_Node ThisNode = Node;
                do
                {
                    Path.Push(ThisNode.Text);
                    ThisNode = ThisNode.ParentNode;
                } while (ThisNode != null);
                return string.Join(".", Path.ToArray());
            }
            return null;
        }

        public static string GetPath(this Wz_Node Node)
        {
            Stack<string> Path = new Stack<string>();
            Wz_Node ThisNode = Node;
            do
            {
                Path.Push(ThisNode.Text);
                ThisNode = ThisNode.ParentNode;
            } while (ThisNode != null);
            return string.Join("/", Path.ToArray());

        }

        public static int ToInt(this Wz_Node Node, int DefaultValue = 0)
        {
            return Node.GetValueEx<int>(DefaultValue);
        }
        public static string ToStr(this Wz_Node Node)
        {
            if (Node.Value is string)
                return Node.GetValueEx<string>("");
            else if (Node.Value is Wz_Uol)
                return Node.GetValue<Wz_Uol>().Uol;
            else
                return "";
        }
        public static string ToStr(this Wz_Node Node, string DefaultValue)
        {
            return Node.GetValueEx<string>(DefaultValue);
        }
        public static bool ToBool(this Wz_Node Node)
        {
            return Convert.ToBoolean(Node.GetValueEx<int>(0));
        }
        public static Wz_Vector ToVector(this Wz_Node Node)
        {
            return  Node.GetValueEx<Wz_Vector>(new Wz_Vector(0, 0)); ;
        }

        public static string ImgName(this Wz_Node Node)
        {
            return Node.GetNodeWzImage().Name;
        }

        public static string ImgID(this Wz_Node Node)
        {
            return Node.GetNodeWzImage().Name.Replace(".img", "");
        }
        public static T GetValue2<T>(this Wz_Node Node, string Path, T DefaultValue)
        {
            if (Node.FindNodeByPathA(Path, true) != null)
                return Node.FindNodeByPathA(Path, true).GetValueEx(DefaultValue);
            else
                return DefaultValue;
        }

        public static Wz_Node FindNodeByPathA(this Wz_Node Node, string FullPath, bool ExtractImage)
        {
            string[] Patten = FullPath.Split('/');
            return Node.FindNodeByPath(ExtractImage, Patten);

        }

        public static string FullPathToFileEx(this Wz_Node Node)
        {
            Stack<string> path = new Stack<string>();
            Wz_Node node = Node;
            do
            {
                if (node.Value is Wz_File wzf && !wzf.IsSubDir)
                {
                    if (node.Text.EndsWith(".wz", StringComparison.OrdinalIgnoreCase))
                    {
                        path.Push(node.Text.Substring(0, node.Text.Length - 3));
                    }
                    else
                    {
                        path.Push(node.Text);
                    }
                    break;
                }

                path.Push(node.Text);

                var img = node.GetValue<Wz_Image>();
                if (img != null)
                {
                    node = img.OwnerNode;
                }

                if (node != null)
                {
                    node = node.ParentNode;
                }
            } while (node != null);
            return string.Join("/", path.ToArray());

        }

        public static string FullPathToFile2(this Wz_Node Node)
        {
            var FullPath = Node.FullPathToFileEx();
            string[] Split = FullPath.Split('/');
            switch (Split[0])
            {
                case "Data":
                    FullPath = FullPath.Replace("Data/", "");
                    break;
                case "Map001":
                    FullPath = FullPath.Replace("Map001", "Map");
                    break;
                case "Map002":
                    FullPath = FullPath.Replace("Map002", "Map");
                    break;
                case "Map2":
                    FullPath = FullPath.Replace("Map2", "Map");
                    break;
                case "Mob001":
                    FullPath = FullPath.Replace("Mob001", "Mob");
                    break;
                case "Mob002":
                    FullPath = FullPath.Replace("Mob002", "Mob");
                    break;
                case "Mob2":
                    FullPath = FullPath.Replace("Mob2", "Mob");
                    break;
                case "Skill001":
                    FullPath = FullPath.Replace("Skill001", "Skill");
                    break;
                case "Skill002":
                    FullPath = FullPath.Replace("Skill002", "Skill");
                    break;
                case "Skill003":
                    FullPath = FullPath.Replace("Skill003", "Skill");
                    break;
                case "Sound001":
                    FullPath = FullPath.Replace("Sound001", "Sound");
                    break;
                case "Sound002":
                    FullPath = FullPath.Replace("Sound002", "Sound");
                    break;
                case "Sound2":
                    FullPath = FullPath.Replace("Sound2", "Sound");
                    break;

            }
            return FullPath;

        }

        public static string FullPathToFile2D(this Wz_Node Node)
        {
            var Path = FullPathToFile2(Node);
            Path = Path.Replace("/", ".");
            return Path;
        }
        public static Bitmap ExtractPng(this Wz_Node Node)
        {
            return (Node.Value as Wz_Png).ExtractPng();

        }
    }
}



```

`WzComparerR2.PluginBase/FindWzEventArgs.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using WzComparerR2.WzLib;

namespace WzComparerR2
{
    public class FindWzEventArgs:EventArgs
    {
        public FindWzEventArgs()
        {
        }

        public FindWzEventArgs(Wz_Type type)
        {
            this.wzType = type;
        }

        private string fullPath;
        private Wz_Type wzType;
        private Wz_File wzFile;
        private Wz_Node wzNode;

        /// <summary>
        /// 获取或设置要查找wz节点的完全名称，用于输入参数。
        /// </summary>
        public string FullPath
        {
            get { return fullPath; }
            set { fullPath = value; }
        }

        /// <summary>
        /// 获取或设置要查找wz节点的Wz_Type，用于输入参数。
        /// </summary>
        public Wz_Type WzType
        {
            get { return wzType; }
            set { wzType = value; }
        }

        /// <summary>
        /// 获取或设置要查找wz节点的所属Wz_File，用于输入和输出参数。
        /// </summary>
        public Wz_File WzFile
        {
            get { return wzFile; }
            set { wzFile = value; }
        }

        /// <summary>
        /// 获取或设置要查找wz节点的Wz_Node，用于输出参数。
        /// </summary>
        public Wz_Node WzNode
        {
            get { return wzNode; }
            set { wzNode = value; }
        }
    }
}

```

`WzComparerR2.PluginBase/FindWzEventHandler.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace WzComparerR2
{
    public delegate void FindWzEventHandler(object sender, FindWzEventArgs e);
}

```

`WzComparerR2.PluginBase/PluginContext.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Windows.Forms;
using WzComparerR2.WzLib;
using WzComparerR2.Common;
//using DevComponents.DotNetBar;
//using WzComparerR2.Controls;

namespace WzComparerR2.PluginBase
{
    public class PluginContext
    {
        internal PluginContext(PluginContextProvider contextProvider)
        {
            this.contextProvider = contextProvider;
        }

        private PluginContextProvider contextProvider;

       // public Form MainForm
       // {
           // get { return this.contextProvider.MainForm; }
       // }

      //  public DotNetBarManager DotNetBarManager
       // {
          //  get { return this.contextProvider.DotNetBarManager; }
       // }

      //  public Wz_Node SelectedNode1
       // {
         //   get { return this.contextProvider.SelectedNode1; }
       // }

       // public Wz_Node SelectedNode2
      //  {
        //    get { return this.contextProvider.SelectedNode2; }
      //  }

      //  public Wz_Node SelectedNode3
      //  {
         //   get { return this.contextProvider.SelectedNode3; }
       // }

      //  public SuperTabItem SelectedTab
      //  {
        //    get { return this.SuperTabControl1.SelectedTab; }
       // }

       // public event EventHandler<WzNodeEventArgs> SelectedNode1Changed
       // {
         //   add { contextProvider.SelectedNode1Changed += value; }
          //  remove { contextProvider.SelectedNode1Changed -= value; }
      //  }

      //  public event EventHandler<WzNodeEventArgs> SelectedNode2Changed
      //  {
       //     add { contextProvider.SelectedNode2Changed += value; }
         //   remove { contextProvider.SelectedNode2Changed -= value; }
       // }

      //  public event EventHandler<WzNodeEventArgs> SelectedNode3Changed
      //  {
         //   add { contextProvider.SelectedNode3Changed += value; }
          //  remove { contextProvider.SelectedNode3Changed -= value; }
      //  }

        public event EventHandler<WzStructureEventArgs> WzOpened
        {
            add { contextProvider.WzOpened += value; }
            remove { contextProvider.WzOpened-= value; }
        }

      //  public event EventHandler<WzStructureEventArgs> WzClosing
     //   {
         //   add { contextProvider.WzClosing += value; }
           // remove { contextProvider.WzClosing -= value; }
      //  }

      //  public StringLinker DefaultStringLinker
        //{
         //   get { return this.contextProvider.DefaultStringLinker; }
       // }

       // public AlphaForm DefaultTooltipWindow
       // {
         //   get { return this.contextProvider.DefaultTooltipWindow; }
       // }

      //  private SuperTabControl SuperTabControl1
       // {
          //  get
          //  {
               // var controls = this.contextProvider.MainForm.Controls.Find("superTabControl1", true);
             //   SuperTabControl tabControl = controls.Length > 0 ? (controls[0] as SuperTabControl) : null;
             //   return tabControl;
           // }
       // }

       

       

      

       
    }
}

```

`WzComparerR2.PluginBase/PluginContextProvider.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
//using DevComponents.DotNetBar;
using WzComparerR2.WzLib;
using WzComparerR2;
//using WzComparerR2.Common;
//using WzComparerR2.Controls;

namespace WzComparerR2.PluginBase
{
    internal interface PluginContextProvider
    {
      //  Office2007RibbonForm MainForm { get; }
      //  DotNetBarManager DotNetBarManager { get; }
       IList<Wz_Structure> LoadedWz { get; }
      //  Wz_Node SelectedNode1 { get; }
     //   Wz_Node SelectedNode2 { get; }
      //  Wz_Node SelectedNode3 { get; }
      //  StringLinker DefaultStringLinker { get; }
      //  AlphaForm DefaultTooltipWindow { get; }

      //  event EventHandler<WzNodeEventArgs> SelectedNode1Changed;
       // event EventHandler<WzNodeEventArgs> SelectedNode2Changed;
      //  event EventHandler<WzNodeEventArgs> SelectedNode3Changed;
        event EventHandler<WzStructureEventArgs> WzOpened;
      //  event EventHandler<WzStructureEventArgs> WzClosing;
    }
}

```

`WzComparerR2.PluginBase/PluginEntry.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Reflection;

namespace WzComparerR2.PluginBase
{
    public abstract class PluginEntry
    {
        public PluginEntry(PluginContext context)
        {
            this.Context = context;
        }

        public PluginContext Context
        {
             get;
            private set;
        }

        public virtual string Name
        {
            get
            {
                var attr = GetAsmAttr<AssemblyTitleAttribute>();
                return attr != null ? attr.Title : null;
            }
        }

        public virtual string Author
        {
            get
            {
                var attr = GetAsmAttr<AssemblyCompanyAttribute>();
                return attr != null ? attr.Company : null;
            }
        }

        public virtual string Version
        {
            get
            {
                return this.GetType().Assembly.GetName().Version.ToString();
            }
        }

        public virtual string FileVersion
        {
            get
            {
                var attrInfoVersion = GetAsmAttr<AssemblyInformationalVersionAttribute>();
                if (!string.IsNullOrEmpty(attrInfoVersion?.InformationalVersion))
                {
                    return attrInfoVersion.InformationalVersion;
                }

                var attrFileVersion = GetAsmAttr<AssemblyFileVersionAttribute>();
                return attrFileVersion?.Version;
            }
        }

        private T GetAsmAttr<T>()
        {
            object[] attr = this.GetType().Assembly.GetCustomAttributes(typeof(T), true);
            if (attr != null && attr.Length > 0)
            {
                return (T)attr[0];
            }
            return default(T);
        }

        protected internal virtual void OnLoad()
        {

        }

        protected internal virtual void OnUnload()
        {

        }
    }
}

```

`WzComparerR2.PluginBase/PluginInfo.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Reflection;

namespace WzComparerR2.PluginBase
{
    internal class PluginInfo
    {
        public string FileName { get; set; }
        public Assembly Assembly { get; set; }
        public PluginEntry Instance { get; set; }
    }
}

```

`WzComparerR2.PluginBase/PluginManager.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using WzComparerR2.WzLib;
using System.IO;
using System.Reflection;
using System.Diagnostics;
using System.Collections.ObjectModel;
//using DevComponents.DotNetBar;
using System.Windows.Forms;
using System.Linq;

namespace WzComparerR2.PluginBase
{
    public class PluginManager
    {
        /// <summary>
        /// 当执行FindWz函数时发生，用来寻找对应的Wz_File。
        /// </summary>
        public static event FindWzEventHandler WzFileFinding;

        /// <summary>
        /// 为CharaSim组件提供全局的搜索Wz_File的方法。
        /// </summary>
        /// <param Name="Type">要搜索wz文件的Wz_Type。</param>
        /// <returns></returns>
        public static Wz_Node FindWz(Wz_Type type)
        {
            return FindWz(type, null);
        }

        public static Wz_Node FindWz(Wz_Type type, Wz_File sourceWzFile)
        {
            FindWzEventArgs e = new FindWzEventArgs(type) { WzFile = sourceWzFile };
            if (WzFileFinding != null)
            {
                WzFileFinding(null, e);
                if (e.WzNode != null)
                {
                    return e.WzNode;
                }
                if (e.WzFile != null)
                {
                    return e.WzFile.Node;
                }
            }
            return null;
        }

        /// <summary>
        /// 通过wz完整路径查找对应的Wz_Node，若没有找到则返回null。
        /// </summary>
        /// <param name="fullPath">要查找节点的完整路径，可用'/'或者'\'作分隔符，如"Mob/8144006.img/die1/6"。</param>
        /// <returns></returns>
        public static Wz_Node FindWz(string fullPath)
        {
            return FindWz(fullPath, null);
        }

        public static Wz_Node FindWz(string fullPath, Wz_File sourceWzFile)
        {
            FindWzEventArgs e = new FindWzEventArgs() { FullPath = fullPath, WzFile = sourceWzFile };
            if (WzFileFinding != null)
            {
                WzFileFinding(null, e);
                if (e.WzNode != null)
                {
                    return e.WzNode;
                }
                if (e.WzFile != null)
                {
                    return e.WzFile.Node;
                }
            }
            return null;
        }

        public static void LogError(string logger, string format, params object[] args)
        {
            LogError(logger, null, format, args);
        }

        public static void LogError(string logger, Exception ex, string format, params object[] args)
        {
            string logText = string.Format("[{0:yyyy-MM-dd HH:mm:ss}][Error][{1}] {2}{3}",
                DateTime.Now,
                logger,
                args == null ? format : string.Format(format, args),
                ex?.ToString());

            string logFile = Path.Combine(Path.GetDirectoryName(MainExecutorPath), "error.log");

            try
            {
                File.AppendAllLines(logFile, new[] { logText });
            }
            catch
            {
            }
        }

        internal static string MainExecutorPath
        {
            get
            {
                var asmArray = AppDomain.CurrentDomain.GetAssemblies();
                foreach (var asm in asmArray)
                {
                    string asmName = asm.GetName().Name;
                    if (string.Equals(asmName, "WzComparerR2", StringComparison.OrdinalIgnoreCase))
                    {
                        return asm.Location;
                    }
                }
                return "";
            }
        }

        internal static string[] GetPluginFiles()
        {
            List<string> fileList = new List<string>();
            string baseDir = Path.GetDirectoryName(MainExecutorPath);
            string pluginDir = Path.Combine(baseDir, "Plugin");
            if (Directory.Exists(pluginDir))
            {
                foreach (string file in Directory.GetFiles(pluginDir, "WzComparerR2.*.dll", SearchOption.AllDirectories))
                {
                    fileList.Add(file);
                }
            }
            else
            {
                Directory.CreateDirectory(pluginDir);
            }
            return fileList.ToArray();
        }

        internal static IEnumerable<PluginInfo> LoadPlugin(Assembly assembly, PluginContext context)
        {
            var baseType = typeof(PluginEntry);
            return assembly.GetExportedTypes().Where(type => type.IsSubclassOf(baseType) && !type.IsAbstract)
                .Select(type =>
                {
                    try
                    {
                        var entry = Activator.CreateInstance(type, context) as PluginEntry;
                        var plugin = new PluginInfo()
                        {
                            Assembly = assembly,
                            FileName = assembly.CodeBase,
                            Instance = entry,
                        };
                        loadedPlugins.Add(plugin);
                        return plugin;
                    }
                    catch
                    {
                        return null;
                    }
                }).OfType<PluginInfo>();
        }

        internal static void PluginOnLoad()
        {
            foreach (var plugin in loadedPlugins)
            {
                try
                {
                    plugin.Instance.OnLoad();
                }
                catch (Exception ex)
                {
                   // MessageBoxEx.Show("插件初始化失败。\r\n" + ex.Message, plugin.Instance.Name, MessageBoxButtons.OK, MessageBoxIcon.Error);
                }
            }
        }

        internal static void PluginOnUnLoad()
        {
            foreach (var plugin in loadedPlugins)
            {
                try
                {
                    plugin.Instance.OnUnload();
                }
                catch
                {
                }
            }
        }

        static List<PluginInfo> loadedPlugins = new List<PluginInfo>();
        static ReadOnlyCollection<PluginInfo> readonlyLoadedPlugins = new ReadOnlyCollection<PluginInfo>(loadedPlugins);
        internal static ReadOnlyCollection<PluginInfo> LoadedPlugins
        {
            get
            {
                return readonlyLoadedPlugins;
            }
        }
    }
}

```

`WzComparerR2.PluginBase/Properties/AssemblyInfo.cs`:

```cs
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// 有关程序集的常规信息通过以下
// 特性集控制。更改这些特性值可修改
// 与程序集关联的信息。
[assembly: AssemblyTitle("WzComparerR2.PluginBase")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Kagamia Studio")]
[assembly: AssemblyProduct("WzComparerR2.PluginBase")]
[assembly: AssemblyCopyright("Copyright © Kagamia Studio 2013-2021")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]
[assembly: InternalsVisibleTo("WzComparerR2")]

// 将 ComVisible 设置为 false 使此程序集中的类型
// 对 COM 组件不可见。如果需要从 COM 访问此程序集中的类型，
// 则将该类型上的 ComVisible 特性设置为 true。
[assembly: ComVisible(false)]

// 如果此项目向 COM 公开，则下列 GUID 用于类型库的 ID
[assembly: Guid("fb0b169f-e698-4b87-9096-1bdfb2b66901")]

// 程序集的版本信息由下面四个值组成:
//
//      主版本
//      次版本 
//      内部版本号
//      修订号
//
// 可以指定所有这些值，也可以使用“内部版本号”和“修订号”的默认值，
// 方法是按如下所示使用“*”:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("2.2.0.0")]
[assembly: AssemblyFileVersion("2.2.0.10725")]

```

`WzComparerR2.PluginBase/WzComparerR2.PluginBase.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net6.0-windows</TargetFramework>
    <Nullable>enable</Nullable>
    <UseWindowsForms>true</UseWindowsForms>
    <ImplicitUsings>enable</ImplicitUsings>
  </PropertyGroup>

  <ItemGroup>
    <Reference Include="WzComparerR2.Common">
      <HintPath>..\WzComparerR2.Common\bin\Release\net6.0-windows\WzComparerR2.Common.dll</HintPath>
    </Reference>
    <Reference Include="WzComparerR2.WzLib">
      <HintPath>..\WzComparerR2.WzLib\bin\Release\net6.0-windows\WzComparerR2.WzLib.dll</HintPath>
    </Reference>
  </ItemGroup>

</Project>

```

`WzComparerR2.PluginBase/WzNodeEventArgs.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using WzComparerR2.WzLib;

namespace WzComparerR2.PluginBase
{
    public class WzNodeEventArgs : EventArgs
    {
        public WzNodeEventArgs(Wz_Node node)
        {
            this.Node = node;
        }

        public Wz_Node Node { get; private set; }
    }
}

```

`WzComparerR2.PluginBase/WzStructureEventArgs.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using WzComparerR2.WzLib;

namespace WzComparerR2.PluginBase
{
    public class WzStructureEventArgs : EventArgs
    {
        public WzStructureEventArgs(Wz_Structure wz)
        {
            this.WzStructure = wz;
        }

        public Wz_Structure WzStructure { get; private set; }
    }
}

```

`WzComparerR2.WzLib/Properties/AssemblyInfo.cs`:

```cs
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// 有关程序集的常规信息通过以下
// 特性集控制。更改这些特性值可修改
// 与程序集关联的信息。
[assembly: AssemblyTitle("WzComparerR2.WzLib")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Kagamia Studio")]
[assembly: AssemblyProduct("WzComparerR2.WzLib")]
[assembly: AssemblyCopyright("Copyright © Kagamia Studio 2013-2021")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// 将 ComVisible 设置为 false 使此程序集中的类型
// 对 COM 组件不可见。如果需要从 COM 访问此程序集中的类型，
// 则将该类型上的 ComVisible 特性设置为 true。
[assembly: ComVisible(false)]

// 如果此项目向 COM 公开，则下列 GUID 用于类型库的 ID
[assembly: Guid("fcd87fcc-803e-4fbc-9626-c7bee8288feb")]

// 程序集的版本信息由下面四个值组成:
//
//      主版本
//      次版本 
//      内部版本号
//      修订号
//
// 可以指定所有这些值，也可以使用“内部版本号”和“修订号”的默认值，
// 方法是按如下所示使用“*”:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("2.2.0.0")]
[assembly: AssemblyFileVersion("2.2.0.10725")]

```

`WzComparerR2.WzLib/WzComparerR2.WzLib.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net6.0-windows</TargetFramework>
    <Nullable>enable</Nullable>
    <UseWindowsForms>true</UseWindowsForms>
    <ImplicitUsings>enable</ImplicitUsings>
    <AllowUnsafeBlocks>True</AllowUnsafeBlocks>
  </PropertyGroup>

</Project>

```

`WzComparerR2.WzLib/Wz_Capabilities.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace WzComparerR2.WzLib
{
    [Flags]
    public enum Wz_Capabilities
    {
        Default = 0,
        EncverMissing = 1,
    }
}

```

`WzComparerR2.WzLib/Wz_Crypto.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Security.Cryptography;
using System.Collections.Specialized;
using System.Text.RegularExpressions;

namespace WzComparerR2.WzLib
{
    public enum Wz_CryptoKeyType
    {
        Unknown = 0,
        BMS = 1,
        KMS = 2,
        GMS = 3
    }

    public class Wz_Crypto
    {
        public Wz_Crypto()
        {
            this.keys_bms = new Wz_CryptoKey(iv_bms);
            this.keys_kms = new Wz_CryptoKey(iv_kms);
            this.keys_gms = new Wz_CryptoKey(iv_gms);
            this.listwz = false;
            this.EncType = Wz_CryptoKeyType.Unknown;
            this.List = new StringCollection();
        }

        public void Reset()
        {
            this.encryption_detected = false;
            this.listwz = false;
            this.EncType = Wz_CryptoKeyType.Unknown;
            this.List.Clear();
        }

        public bool list_contains(string name)
        {
            bool contains = this.List.Contains(name);
            if (contains)
                this.List.Remove(name);
            return contains;
            //    foreach (string list_entry in this.list)
            //    {
            //        // if (list_entry.Contains(Name))
            //        if (list_entry == Name)
            //        {
            //            this.list.Remove(list_entry);
            //            return true;
            //        }
            //    }
            //    return false;
        }

        public void LoadListWz(string path)
        {
            path = Path.Combine(path, "List.wz");
            if (File.Exists(path))
            {
                this.listwz = true;
                using (FileStream list_file = new FileStream(path, FileMode.Open, FileAccess.Read, FileShare.Read))
                {
                    BinaryReader listwz = new BinaryReader(list_file);
                    int length = (int)list_file.Length;
                    int len = 0;
                    byte b = 0;
                    string folder = "";
                    list_file.Position += 4;
                    byte check_for_d = listwz.ReadByte();

                    if ((char)(check_for_d ^ this.keys_gms[0]) == 'd')
                    {
                        this.EncType = Wz_CryptoKeyType.GMS;
                    }
                    else if ((char)(check_for_d ^ this.keys_kms[0]) == 'd')
                    {
                        this.EncType = Wz_CryptoKeyType.KMS;
                    }

                    list_file.Position = 0;
                    while (list_file.Position < length)
                    {
                        len = listwz.ReadInt32() * 2;
                        for (int i = 0; i < len; i += 2)
                        {
                            b = (byte)(listwz.ReadByte() ^ this.keys[i]);
                            folder += (char)(b);
                            list_file.Position++;
                        }
                        list_file.Position += 2;
                        folder.Replace(".im/", ".img");
                        this.List.Add(folder);
                        folder = "";
                    }
                    this.List.Remove("dummy");
                }
            }
        }

        public void DetectEncryption(Wz_File f)
        {
            int old_off = (int)f.FileStream.Position;
            f.FileStream.Position = f.Header.DataStartPosition;
            if (f.ReadInt32() <= 0) //只有文件头 无法预判
            {
                return;
            }
            f.FileStream.Position++;
            int len = (int)(-f.BReader.ReadSByte());
            byte[] bytes = f.BReader.ReadBytes(len);

            for (int i = 0; i < len; i++)
            {
                bytes[i] ^= (byte)(0xAA + i);
            }

            StringBuilder sb = new StringBuilder();
            if (!this.encryption_detected)
            {
                //测试bms
                sb.Clear();
                for (int i = 0; i < len; i++)
                {
                    sb.Append((char)(keys_bms[i] ^ bytes[i]));
                }
                if (IsLegalNodeName(sb.ToString()))
                {
                    this.EncType = Wz_CryptoKeyType.BMS;
                    this.encryption_detected = true;
                    goto lbl_end;
                }

                //测试kms
                sb.Clear();
                for (int i = 0; i < len; i++)
                {
                    sb.Append((char)(keys_kms[i] ^ bytes[i]));
                }
                if (IsLegalNodeName(sb.ToString()))
                {
                    this.EncType = Wz_CryptoKeyType.KMS;
                    this.encryption_detected = true;
                    goto lbl_end;
                }

                //测试gms
                sb.Clear();
                for (int i = 0; i < len; i++)
                {
                    sb.Append((char)(keys_gms[i] ^ bytes[i]));
                }
                if (IsLegalNodeName(sb.ToString()))
                {
                    this.EncType = Wz_CryptoKeyType.GMS;
                    this.encryption_detected = true;
                    goto lbl_end;
                }
            }

        lbl_end:
            f.FileStream.Position = old_off;
        }

        private bool IsLegalNodeName(string nodeName)
        {
            // MSEA 225 has a node in Base.wz named "Base,Character,Effect,Etc,Item,Map,Mob,Morph,Npc,Quest,Reactor,Skill,Sound,String,TamingMob,UI"
            // It is so funny but wzlib have to be compatible with it.
            return nodeName.EndsWith(".img") || nodeName.EndsWith(".lua") || Regex.IsMatch(nodeName, @"^[A-Za-z0-9_,]+$");
        }

        static readonly byte[] iv_gms = { 0x4d, 0x23, 0xc7, 0x2b };
        static readonly byte[] iv_kms = { 0xb9, 0x7d, 0x63, 0xe9 };
        static readonly byte[] iv_bms = { 0x00, 0x00, 0x00, 0x00 };

        private Wz_CryptoKey keys_bms, keys_gms, keys_kms;
        private Wz_CryptoKeyType enc_type;

        public bool encryption_detected = false;
        public bool listwz = false;

        public Wz_CryptoKey keys { get; private set; }
        public StringCollection List { get; private set; }

        public Wz_CryptoKeyType EncType
        {
            get { return enc_type; }
            set
            {
                this.keys = this.GetKeys(value);
                enc_type = value;
            }
        }

        public Wz_CryptoKey GetKeys(Wz_CryptoKeyType keyType)
        {
            switch (keyType)
            {
                case Wz_CryptoKeyType.Unknown: return null;
                case Wz_CryptoKeyType.BMS: return this.keys_bms;
                case Wz_CryptoKeyType.KMS: return this.keys_kms;
                case Wz_CryptoKeyType.GMS: return this.keys_gms;
                default: throw new ArgumentOutOfRangeException(nameof(keyType));
            }
        }

        public class Wz_CryptoKey
        {
            public Wz_CryptoKey(byte[] iv)
            {
                this.iv = iv;
                if (iv == null || BitConverter.ToInt32(iv, 0) == 0)
                {
                    this.isEmptyIV = true;
                }
            }

            private byte[] keys;
            private byte[] iv;
            private bool isEmptyIV;

            public byte this[int index]
            {
                get
                {
                    if (isEmptyIV)
                    {
                        return 0;
                    }
                    if (keys == null || keys.Length <= index)
                    {
                        EnsureKeySize(index + 1);
                    }
                    return this.keys[index];
                }
            }

            public void EnsureKeySize(int size)
            {
                if (isEmptyIV)
                {
                    return;
                }
                if (this.keys != null && this.keys.Length >= size)
                {
                    return;
                }

                size = (int)Math.Ceiling(1.0 * size / 64) * 64;
                int startIndex = 0;

                if (this.keys == null)
                {
                    keys = new byte[size];
                }
                else
                {
                    startIndex = this.keys.Length;
                    Array.Resize(ref this.keys, size);
                }

                var aes = Aes.Create();
                aes.KeySize = 256;
                aes.BlockSize = 128;
                aes.Key = aesKey;
                aes.Mode = CipherMode.ECB;
                MemoryStream ms = new MemoryStream(keys, startIndex, keys.Length - startIndex, true);
                CryptoStream s = new CryptoStream(ms, aes.CreateEncryptor(), CryptoStreamMode.Write);

                for (int i = startIndex; i < size; i += 16)
                {
                    if (i == 0)
                    {
                        byte[] block = new byte[16];
                        for (int j = 0; j < block.Length; j++)
                        {
                            block[j] = iv[j % 4];
                        }
                        s.Write(block, 0, block.Length);
                    }
                    else
                    {
                        s.Write(keys, i - 16, 16);
                    }
                }

                s.Flush();
                ms.Close();
            }

            public unsafe void Decrypt(byte[] buffer, int startIndex, int length)
            {
                if (isEmptyIV)
                    return;

                this.EnsureKeySize(length);

                fixed (byte* pBuffer = buffer, pKeys = this.keys)
                {
                    int i = 0;
                    byte* pData = pBuffer + startIndex;

                    for (int i1 = length / 4 * 4; i < i1; i += 4, pData += 4)
                    {
                        *((int*)pData) ^= *(int*)(pKeys + i);
                    }

                    for (; i < length; i++, pData++)
                    {
                        *pData ^= *(pKeys + i);
                    }
                }
            }

            static readonly byte[] aesKey = {0x13, 0x00, 0x00, 0x00,
                                        0x08, 0x00, 0x00, 0x00,
                                        0x06, 0x00, 0x00, 0x00,
                                        0xB4, 0x00, 0x00, 0x00,
                                        0x1B, 0x00, 0x00, 0x00,
                                        0x0F, 0x00, 0x00, 0x00,
                                        0x33, 0x00, 0x00, 0x00,
                                        0x52, 0x00, 0x00, 0x00 };
        }
    }
}

```

`WzComparerR2.WzLib/Wz_Directory.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace WzComparerR2.WzLib
{
    public class Wz_Directory
    {
        public Wz_Directory(string name, int size, int cs32, uint hashOff, uint hashPos, Wz_File wz_f)
        {
            this.Name = name;
            this.WzFile = wz_f;
            this.Size = size;
            this.Checksum = cs32;
            this.HashedOffset = hashOff;
            this.HashedOffsetPosition = hashPos;
        }

        public string Name { get; set; }
        public Wz_File WzFile { get; set; }
        public int Size { get; set; }
        public int Checksum { get; set; }
        public uint HashedOffset { get; set; }
        public uint HashedOffsetPosition { get; set; }
        public long Offset { get; set; }
    }
}

```

`WzComparerR2.WzLib/Wz_File.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;

namespace WzComparerR2.WzLib
{
    public class Wz_File : IDisposable
    {
        public Wz_File(string fileName, Wz_Structure wz)
        {
            this.imageCount = 0;
            this.wzStructure = wz;
            this.fileStream = new FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
            this.bReader = new BinaryReader(this.FileStream);
            this.loaded = this.GetHeader(fileName);
            this.stringTable = new Dictionary<long, string>();
            this.directories = new List<Wz_Directory>();
        }

        private FileStream fileStream;
        private BinaryReader bReader;
        private Wz_Structure wzStructure;
        private Wz_Header header;
        private Wz_Node node;
        private int imageCount;
        private bool loaded;
        private bool isSubDir;
        private Wz_Type type;
        private List<Wz_File> mergedWzFiles;
        private Wz_File ownerWzFile;
        private readonly List<Wz_Directory> directories;

        public Encoding TextEncoding { get; set; }

        public readonly object ReadLock = new object();

        internal Dictionary<long, string> stringTable;
        internal byte[] tempBuffer;

        public FileStream FileStream
        {
            get { return fileStream; }
        }

        public BinaryReader BReader
        {
            get { return bReader; }
        }

        public Wz_Structure WzStructure
        {
            get { return wzStructure; }
            set { wzStructure = value; }
        }

        public Wz_Header Header
        {
            get { return header; }
            private set { header = value; }
        }

        public Wz_Node Node
        {
            get { return node; }
            set { node = value; }
        }

        public int ImageCount
        {
            get { return imageCount; }
        }

        public bool Loaded
        {
            get { return loaded; }
        }

        public bool IsSubDir
        {
            get { return this.isSubDir; }
        }

        public Wz_Type Type
        {
            get { return type; }
            set { type = value; }
        }

        public IEnumerable<Wz_File> MergedWzFiles
        {
            get { return this.mergedWzFiles ?? Enumerable.Empty<Wz_File>(); }
        }

        public Wz_File OwnerWzFile
        {
            get { return this.ownerWzFile; }
        }

        public void Close()
        {
            if (this.bReader != null)
                this.bReader.Close();
            if (this.fileStream != null)
                this.fileStream.Close();
        }

        void IDisposable.Dispose()
        {
            this.Close();
        }

        private bool GetHeader(string fileName)
        {
            this.fileStream.Position = 0;
            long filesize = this.FileStream.Length;
            if (filesize < 4) { goto __failed; }

            string signature = new string(this.BReader.ReadChars(4));
            if (signature != "PKG1") { goto __failed; }

            long dataSize = this.BReader.ReadInt64();
            int headerSize = this.BReader.ReadInt32();
            string copyright = new string(this.BReader.ReadChars(headerSize - (int)this.FileStream.Position));

            // encver detecting:
            // Since KMST1132, wz removed the 2 bytes encver, and use a fixed wzver '777'.
            // Here we try to read the first 2 bytes from data part and guess if it looks like an encver.
            bool encverMissing = false;
            int encver = -1;
            if (dataSize >= 2)
            {
                this.fileStream.Position = headerSize;
                encver = this.BReader.ReadUInt16();
                // encver always less than 256
                if (encver > 0xff)
                {
                    encverMissing = true;
                }
                else if (encver == 0x80)
                {
                    // there's an exceptional case that the first field of data part is a compressed int which determined property count,
                    // if the value greater than 127 and also to be a multiple of 256, the first 5 bytes will become to
                    //   80 00 xx xx xx
                    // so we additional check the int value, at most time the child node count in a wz won't greater than 65536.
                    if (dataSize >= 5)
                    {
                        this.fileStream.Position = headerSize;
                        int propCount = this.ReadInt32();
                        if (propCount > 0 && (propCount & 0xff) == 0 && propCount <= 0xffff)
                        {
                            encverMissing = true;
                        }
                    }
                }
            }
            else
            {
                // Obviously, if data part have only 1 byte, encver must be deleted.
                encverMissing = true;
            }

            int dataStartPos = headerSize + (encverMissing ? 0 : 2);
            this.Header = new Wz_Header(signature, copyright, fileName, headerSize, dataSize, filesize, dataStartPos);

            if (encverMissing)
            {
                // not sure if nexon will change this magic version, just hard coded.
                this.Header.SetWzVersion(777);
                this.Header.VersionChecked = true;
                this.Header.Capabilities |= Wz_Capabilities.EncverMissing;
            }
            else
            {
                this.Header.SetOrdinalVersionDetector(encver);
            }

            return true;

        __failed:
            this.header = new Wz_Header(null, null, fileName, 0, 0, filesize, 0);
            return false;
        }

        public int ReadInt32()
        {
            int s = this.BReader.ReadSByte();
            return (s == -128) ? this.BReader.ReadInt32() : s;
        }

        public long ReadInt64()
        {
            int s = this.BReader.ReadSByte();
            return (s == -128) ? this.BReader.ReadInt64() : s;
        }

        public float ReadSingle()
        {
            float fl = this.BReader.ReadSByte();
            return (fl == -128) ? this.BReader.ReadSingle() : fl;
        }

        public string ReadString(long offset)
        {
            return this.ReadString(offset, this.WzStructure.encryption.keys);
        }

        public string ReadString(long offset, Wz_CryptoKeyType keyType)
        {
            return this.ReadString(offset, this.WzStructure.encryption.GetKeys(keyType));
        }

        public string ReadString(long offset, Wz_Crypto.Wz_CryptoKey cryptoKey)
        {
            byte b = this.BReader.ReadByte();
            switch (b)
            {
                case 0x00:
                case 0x73:
                    return ReadString(cryptoKey);

                case 0x01:
                case 0x1B:
                    return ReadStringAt(offset + this.BReader.ReadInt32(), cryptoKey);

                case 0x04:
                    this.FileStream.Position += 8;
                    break;

                default:
                    throw new Exception("读取字符串错误 在:" + this.FileStream.Name + " " + this.FileStream.Position);
            }
            return string.Empty;
        }

        private string ReadStringAt(long offset, Wz_Crypto.Wz_CryptoKey cryptoKey)
        {
            long oldoffset = this.FileStream.Position;
            string str;
            if (!stringTable.TryGetValue(offset, out str))
            {
                this.FileStream.Position = offset;
                str = ReadString(cryptoKey);
                stringTable[offset] = str;
                this.FileStream.Position = oldoffset;
            }
            return str;
        }

        private unsafe string ReadString(Wz_Crypto.Wz_CryptoKey cryptoKey)
        {
            int size = this.BReader.ReadSByte();
            string result = null;
            if (size < 0)
            {
                byte mask = 0xAA;
                size = (size == -128) ? this.BReader.ReadInt32() : -size;

                var buffer = GetStringBuffer(size);
                this.fileStream.Read(buffer, 0, size);
                cryptoKey.Decrypt(buffer, 0, size);

                fixed (byte* pData = buffer)
                {
                    for (int i = 0; i < size; i++)
                    {
                        pData[i] ^= mask;
                        unchecked { mask++; }
                    }

                    var enc = this.TextEncoding ?? Encoding.Default;
                    result = enc.GetString(buffer, 0, size);
                }
            }
            else if (size > 0)
            {
                ushort mask = 0xAAAA;
                if (size == 127)
                {
                    size = this.BReader.ReadInt32();
                }

                var buffer = GetStringBuffer(size * 2);
                this.fileStream.Read(buffer, 0, size * 2);
                cryptoKey.Decrypt(buffer, 0, size * 2);

                fixed (byte* pData = buffer)
                {
                    ushort* pChar = (ushort*)pData;
                    for (int i = 0; i < size; i++)
                    {
                        pChar[i] ^= mask;
                        unchecked { mask++; }
                    }

                    result = new string((char*)pChar, 0, size);
                }
            }
            else
            {
                return string.Empty;
            }

            //memory optimize
            if (result.Length <= 4)
            {
                for (int i = 0; i < result.Length; i++)
                {
                    if (result[i] >= 0x80)
                    {
                        return result;
                    }
                }
                return string.Intern(result);
            }
            else
            {
                return result;
            }
        }

        /// <summary>
        /// 为字符串解密提供缓冲区。
        /// </summary>
        /// <param name="size"></param>
        /// <returns></returns>
        private byte[] GetStringBuffer(int size)
        {
            if (size <= 4096)
            {
                if (tempBuffer == null || tempBuffer.Length < size)
                {
                    Array.Resize(ref tempBuffer, size);
                }
                return tempBuffer;
            }
            else
            {
                return new byte[size];
            }
        }

        public uint CalcOffset(uint filePos, uint hashedOffset)
        {
            uint offset = (uint)(filePos - 0x3C) ^ 0xFFFFFFFF;
            int distance;

            offset *= this.Header.HashVersion;
            offset -= 0x581C3F6D;
            distance = (int)offset & 0x1F;
            offset = (offset << distance) | (offset >> (32 - distance));
            offset ^= hashedOffset;
            offset += 0x78;

            return offset;
        }

        public void GetDirTree(Wz_Node parent, bool useBaseWz = false, bool loadWzAsFolder = false)
        {
            List<string> dirs = new List<string>();
            string name = null;
            int size = 0;
            int cs32 = 0;
            uint pos = 0, hashOffset = 0;
            //int offs = 0;

            int count = ReadInt32();
            var cryptoKey = this.WzStructure.encryption.keys;

            for (int i = 0; i < count; i++)
            {
                switch ((int)this.BReader.ReadByte())
                {
                    case 0x02:
                        int stringOffAdd = this.Header.HasCapabilities(Wz_Capabilities.EncverMissing) ? 2 : 1;
                        name = this.ReadStringAt(this.Header.HeaderSize + stringOffAdd + this.BReader.ReadInt32(), cryptoKey);
                        goto case 0xffff;
                    case 0x04:
                        name = this.ReadString(cryptoKey);
                        goto case 0xffff;

                    case 0xffff:
                        size = this.ReadInt32();
                        cs32 = this.ReadInt32();
                        pos = (uint)this.bReader.BaseStream.Position;
                        hashOffset = this.bReader.ReadUInt32();

                        Wz_Image img = new Wz_Image(name, size, cs32, hashOffset, pos, this);
                        Wz_Node childNode = parent.Nodes.Add(name);
                        childNode.Value = img;
                        img.OwnerNode = childNode;

                        this.imageCount++;
                        break;

                    case 0x03:
                        name = this.ReadString(cryptoKey);
                        size = this.ReadInt32();
                        cs32 = this.ReadInt32();
                        pos = (uint)this.bReader.BaseStream.Position;
                        hashOffset = this.bReader.ReadUInt32();
                        this.directories.Add(new Wz_Directory(name, size, cs32, hashOffset, pos, this));
                        dirs.Add(name);
                        break;
                }
            }

            int dirCount = dirs.Count;
            bool willLoadBaseWz = useBaseWz ? parent.Text.Equals("base.wz", StringComparison.OrdinalIgnoreCase) : false;

            var baseFolder = Path.GetDirectoryName(this.header.FileName);

            if (willLoadBaseWz && this.WzStructure.AutoDetectExtFiles)
            {
                for (int i = 0; i < dirCount; i++)
                {
                    //检测文件名
                    var m = Regex.Match(dirs[i], @"^([A-Za-z]+)$");
                    if (m.Success)
                    {
                        string wzTypeName = m.Result("$1");

                        //检测扩展wz文件
                        for (int fileID = 2; ; fileID++)
                        {
                            string extDirName = wzTypeName + fileID;
                            string extWzFile = Path.Combine(baseFolder, extDirName + ".wz");
                            if (File.Exists(extWzFile))
                            {
                                if (!dirs.Take(dirCount).Any(dir => extDirName.Equals(dir, StringComparison.OrdinalIgnoreCase)))
                                {
                                    dirs.Add(extDirName);
                                }
                            }
                            else
                            {
                                break;
                            }
                        }
                        //检测KMST1058的wz文件
                        for (int fileID = 1; ; fileID++)
                        {
                            string extDirName = wzTypeName + fileID.ToString("D3");
                            string extWzFile = Path.Combine(baseFolder, extDirName + ".wz");
                            if (File.Exists(extWzFile))
                            {
                                if (!dirs.Take(dirCount).Any(dir => extDirName.Equals(dir, StringComparison.OrdinalIgnoreCase)))
                                {
                                    dirs.Add(extDirName);
                                }
                            }
                            else
                            {
                                break;
                            }
                        }
                    }
                }
            }

            for (int i = 0; i < dirs.Count; i++)
            {
                string dir = dirs[i];
                Wz_Node t = parent.Nodes.Add(dir);
                if (i < dirCount)
                {
                    GetDirTree(t, false);
                }

                if (t.Nodes.Count == 0)
                {
                    this.WzStructure.has_basewz |= willLoadBaseWz;

                    try
                    {
                        if (loadWzAsFolder)
                        {
                            string wzFolder = willLoadBaseWz ? Path.Combine(Path.GetDirectoryName(baseFolder), dir) : Path.Combine(baseFolder, dir);
                            if (Directory.Exists(wzFolder))
                            {
                                this.wzStructure.LoadWzFolder(wzFolder, ref t, false);
                                if (!willLoadBaseWz)
                                {
                                    var dirWzFile = t.GetValue<Wz_File>();
                                    dirWzFile.Type = Wz_Type.Unknown;
                                    dirWzFile.isSubDir = true;
                                }
                            }
                        }
                        else if (willLoadBaseWz)
                        {
                            string filePath = Path.Combine(baseFolder, dir + ".wz");
                            if (File.Exists(filePath))
                            {
                                this.WzStructure.LoadFile(filePath, t, false, loadWzAsFolder);
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                    }
                }
            }

            parent.Nodes.Trim();
        }

        private string getFullPath(Wz_Node parent, string name)
        {
            List<string> path = new List<string>(5);
            path.Add(name.ToLower());
            while (parent != null && !(parent.Value is Wz_File))
            {
                path.Insert(0, parent.Text.ToLower());
                parent = parent.ParentNode;
            }
            if (parent != null)
            {
                path.Insert(0, parent.Text.ToLower().Replace(".wz", ""));
            }
            return string.Join("/", path.ToArray());
        }

        public void DetectWzType()
        {
            this.type = Wz_Type.Unknown;
            if (this.node == null)
            {
                return;
            }

            if (this.node.Nodes["smap.img"] != null
                || this.node.Nodes["zmap.img"] != null)
            {
                this.type = Wz_Type.Base;
            }
            else if (this.node.Nodes["00002000.img"] != null
                || this.node.Nodes["Accessory"] != null
                || this.node.Nodes["Weapon"] != null)
            {
                this.type = Wz_Type.Character;
            }
            else if (this.node.Nodes["BasicEff.img"] != null
                || this.node.Nodes["SetItemInfoEff.img"] != null)
            {
                this.type = Wz_Type.Effect;
            }
            else if (this.node.Nodes["Commodity.img"] != null
                || this.node.Nodes["Curse.img"] != null)
            {
                this.type = Wz_Type.Etc;
            }
            else if (this.node.Nodes["Cash"] != null
                || this.node.Nodes["Consume"] != null)
            {
                this.type = Wz_Type.Item;
            }
            else if (this.node.Nodes["Back"] != null
                || this.node.Nodes["Obj"] != null
                || this.node.Nodes["Physics.img"] != null)
            {
                this.type = Wz_Type.Map;
            }
            else if (this.node.Nodes["PQuest.img"] != null
                || this.node.Nodes["QuestData"] != null)
            {
                this.type = Wz_Type.Quest;
            }
            else if (this.node.Nodes["Attacktype.img"] != null
                || this.node.Nodes["Recipe_9200.img"] != null)
            {
                this.type = Wz_Type.Skill;
            }
            else if (this.node.Nodes["Bgm00.img"] != null
                || this.node.Nodes["BgmUI.img"] != null)
            {
                this.type = Wz_Type.Sound;
            }
            else if (this.node.Nodes["MonsterBook.img"] != null
                || this.node.Nodes["EULA.img"] != null)
            {
                this.type = Wz_Type.String;
            }
            else if (this.node.Nodes["CashShop.img"] != null
                || this.node.Nodes["UIWindow.img"] != null)
            {
                this.type = Wz_Type.UI;
            }

            if (this.type == Wz_Type.Unknown) //用文件名来判断
            {
                string wzName = this.node.Text;

                Match m = Regex.Match(wzName, @"^([A-Za-z]+)_?(\d+)?(?:\.wz)?$");
                if (m.Success)
                {
                    wzName = m.Result("$1");
                }
                this.type = Enum.TryParse<Wz_Type>(wzName, true, out var result) ? result : Wz_Type.Unknown;
            }
        }

        public void DetectWzVersion()
        {
            IWzVersionVerifier wzVersionVerifier;

            switch (this.wzStructure?.WzVersionVerifyMode)
            {
                default:
                case WzVersionVerifyMode.Default:
                    wzVersionVerifier = new DefaultVersionVerifier();
                    break;

                case WzVersionVerifyMode.Fast:
                    wzVersionVerifier = new FastVersionVerifier();
                    break;
            }

            wzVersionVerifier.Verify(this);
        }

        public void MergeWzFile(Wz_File wz_File)
        {
            var children = wz_File.node.Nodes.ToList();
            wz_File.node.Nodes.Clear();
            foreach (var child in children)
            {
                this.node.Nodes.Add(child);
            }

            if (this.mergedWzFiles == null)
            {
                this.mergedWzFiles = new List<Wz_File>();
            }
            this.mergedWzFiles.Add(wz_File);

            wz_File.ownerWzFile = this;
        }


        public interface IWzVersionVerifier
        {
            bool Verify(Wz_File wzFile);
        }

        public abstract class WzVersionVerifier
        {
            protected IEnumerable<Wz_Image> EnumerableAllWzImage(Wz_Node parentNode)
            {
                foreach (var node in parentNode.Nodes)
                {
                    Wz_Image img = node.Value as Wz_Image;
                    if (img != null)
                    {
                        yield return img;
                    }

                    if (!(node.Value is Wz_File) && node.Nodes.Count > 0)
                    {
                        foreach (var imgChild in EnumerableAllWzImage(node))
                        {
                            yield return imgChild;
                        }
                    }
                }
            }

            protected bool FastCheckFirstByte(Wz_Image image, byte firstByte)
            {
                if (image.IsLuaImage)
                {
                    // for lua image, the first byte is always 01
                    return firstByte == 0x01;
                }
                else
                {
                    // first element is always a string
                    return firstByte == 0x73 || firstByte == 0x1b;
                }
            }

            protected void CalcOffset(Wz_File wzFile, IEnumerable<Wz_Image> imgList)
            {
                foreach (var img in imgList)
                {
                    img.Offset = wzFile.CalcOffset(img.HashedOffsetPosition, img.HashedOffset);
                }
            }

            protected bool DetectWithWzImage(Wz_File wzFile, Wz_Image testWzImg)
            {
                while (wzFile.header.TryGetNextVersion())
                {
                    uint offs = wzFile.CalcOffset(testWzImg.HashedOffsetPosition, testWzImg.HashedOffset);

                    if (offs < wzFile.header.DirEndPosition || offs + testWzImg.Size > wzFile.fileStream.Length)  //img offset out of file size
                    {
                        continue;
                    }

                    wzFile.fileStream.Position = offs;
                    var firstByte = (byte)wzFile.fileStream.ReadByte();
                    if (!FastCheckFirstByte(testWzImg, firstByte))
                    {
                        continue;
                    }

                    testWzImg.Offset = offs;
                    if (!testWzImg.TryExtract())
                    {
                        continue;
                    }

                    testWzImg.Unextract();
                    wzFile.header.VersionChecked = true;
                    break;
                }

                return wzFile.header.VersionChecked;
            }

            protected bool DetectWithAllWzDir(Wz_File wzFile)
            {
                while (wzFile.header.TryGetNextVersion())
                {
                    bool isSuccess = wzFile.directories.All(testDir =>
                    {
                        uint offs = wzFile.CalcOffset(testDir.HashedOffsetPosition, testDir.HashedOffset);

                        if (offs < wzFile.header.DataStartPosition || offs + 1 > wzFile.header.DirEndPosition) // dir offset out of file size.
                        {
                            return false;
                        }

                        wzFile.fileStream.Position = offs;
                        if (wzFile.fileStream.ReadByte() != 0) // for splitted wz format, dir data only contains one byte: 0x00
                        {
                            return false;
                        }

                        return true;
                    });

                    if (isSuccess)
                    {
                        wzFile.header.VersionChecked = true;
                        break;
                    }
                }

                return wzFile.header.VersionChecked;
            }

            protected bool FastDetectWithAllWzImages(Wz_File wzFile, IList<Wz_Image> imgList)
            {
                var imageSizes = new SizeRange[imgList.Count];
                while (wzFile.header.TryGetNextVersion())
                {
                    int count = 0;
                    bool isSuccess = imgList.All(img =>
                    {
                        uint offs = wzFile.CalcOffset(img.HashedOffsetPosition, img.HashedOffset);
                        if (offs < wzFile.header.DirEndPosition || offs + img.Size > wzFile.fileStream.Length)  //img offset out of file size
                        {
                            return false;
                        }

                        imageSizes[count++] = new SizeRange()
                        {
                            Start = offs,
                            End = offs + img.Size,
                        };
                        return true;
                    });

                    if (isSuccess)
                    {
                        // check if there's any image overlaps with another image.
                        Array.Sort(imageSizes, 0, count);
                        for (int i = 1; i < count; i++)
                        {
                            if (imageSizes[i - 1].End > imageSizes[i].Start)
                            {
                                isSuccess = false;
                                break;
                            }
                        }

                        if (isSuccess)
                        {
                            wzFile.header.VersionChecked = true;
                            break;
                        }
                    }
                }

                return wzFile.header.VersionChecked;
            }

            private struct SizeRange : IComparable<SizeRange>
            {
                public long Start;
                public long End;

                public int CompareTo(SizeRange sr)
                {
                    int result = this.Start.CompareTo(sr.Start);
                    if (result == 0)
                    {
                        result = this.End.CompareTo(sr.End);
                    }
                    return result;
                }
            }
        }

        public class DefaultVersionVerifier : WzVersionVerifier, IWzVersionVerifier
        {
            public bool Verify(Wz_File wzFile)
            {
                List<Wz_Image> imgList = EnumerableAllWzImage(wzFile.node).Where(_img => _img.WzFile == wzFile).ToList();

                if (wzFile.header.VersionChecked)
                {
                    this.CalcOffset(wzFile, imgList);
                }
                else
                {
                    // find the wzImage with minimum size.
                    Wz_Image minSizeImg = imgList.DefaultIfEmpty().Aggregate((_img1, _img2) => _img1.Size < _img2.Size ? _img1 : _img2);

                    if (minSizeImg == null && imgList.Count > 0)
                    {
                        minSizeImg = imgList[0];
                    }

                    if (minSizeImg != null)
                    {
                        this.DetectWithWzImage(wzFile, minSizeImg);
                    }
                    else if (wzFile.directories.Count > 0)
                    {
                        this.DetectWithAllWzDir(wzFile);
                    }

                    if (wzFile.header.VersionChecked)
                    {
                        this.CalcOffset(wzFile, imgList);
                    }
                }

                return wzFile.header.VersionChecked;
            }
        }

        public class FastVersionVerifier : WzVersionVerifier, IWzVersionVerifier
        {
            public bool Verify(Wz_File wzFile)
            {
                List<Wz_Image> imgList = EnumerableAllWzImage(wzFile.node).Where(_img => _img.WzFile == wzFile).ToList();

                if (wzFile.header.VersionChecked)
                {
                    this.CalcOffset(wzFile, imgList);
                }
                else
                {
                    if (imgList.Count > 0)
                    {
                        this.FastDetectWithAllWzImages(wzFile, imgList);
                    }
                    else if (wzFile.directories.Count > 0)
                    {
                        this.DetectWithAllWzDir(wzFile);
                    }

                    if (wzFile.header.VersionChecked)
                    {
                        this.CalcOffset(wzFile, imgList);
                    }
                }

                return wzFile.header.VersionChecked;
            }
        }
    }

    public enum WzVersionVerifyMode
    {
        Default = 0,
        Fast = 1,
    }
}

```

`WzComparerR2.WzLib/Wz_Header.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace WzComparerR2.WzLib
{
    public class Wz_Header
    {
        public Wz_Header(string signature, string copyright, string file_name, int head_size, long data_size, long file_size, long dataStartPosition)
        {
            this.Signature = signature;
            this.Copyright = copyright;
            this.FileName = file_name;
            this.HeaderSize = head_size;
            this.DataSize = data_size;
            this.FileSize = file_size;
            this.DataStartPosition = dataStartPosition;
            this.VersionChecked = false;
        }

        public string Signature { get; private set; }
        public string Copyright { get; private set; }
        public string FileName { get; private set; }

        public int HeaderSize { get; private set; }
        public long DataSize { get; private set; }
        public long FileSize { get; private set; }
        public long DataStartPosition { get; private set; }
        public long DirEndPosition { get; set; }

        public bool VersionChecked { get; set; }
        public Wz_Capabilities Capabilities { get; internal set; }

        public int WzVersion => this.versionDetector?.WzVersion ?? 0;
        public uint HashVersion => this.versionDetector?.HashVersion ?? 0;
        public bool TryGetNextVersion() => this.versionDetector?.TryGetNextVersion() ?? false;

        private IWzVersionDetector versionDetector;

        public void SetWzVersion(int wzVersion)
        {
            this.versionDetector = new FixedVersion(wzVersion);
        }

        public void SetOrdinalVersionDetector(int encryptedVersion)
        {
            this.versionDetector = new OrdinalVersionDetector(encryptedVersion);
        }

        public bool HasCapabilities(Wz_Capabilities cap)
        {
            return cap == (this.Capabilities & cap);
        }

        public static int CalcHashVersion(int wzVersion)
        {
            int sum = 0;
            string versionStr = wzVersion.ToString(System.Globalization.CultureInfo.InvariantCulture);
            for (int j = 0; j < versionStr.Length; j++)
            {
                sum <<= 5;
                sum += (int)versionStr[j] + 1;
            }
            
            return sum;
        }

        public interface IWzVersionDetector
        {
            bool TryGetNextVersion();
            int WzVersion { get; }
            uint HashVersion { get; }
        }

        public class FixedVersion : IWzVersionDetector
        {
            public FixedVersion(int wzVersion)
            {
                this.WzVersion = wzVersion;
                this.HashVersion = (uint)CalcHashVersion(wzVersion);
            }

            private bool hasReturned;


            public int WzVersion { get; private set; }

            public uint HashVersion { get; private set; }

            public bool TryGetNextVersion()
            {
                if (!hasReturned)
                {
                    hasReturned = true;
                    return true;
                }

                return false;
            }
        }

        public class OrdinalVersionDetector : IWzVersionDetector
        {
            public OrdinalVersionDetector(int encryptVersion)
            {
                this.EncryptedVersion = encryptVersion;
                this.versionTest = new List<int>();
                this.hasVersionTest = new List<uint>();
                this.startVersion = -1;
            }

            public int EncryptedVersion { get; private set; }

            private int startVersion;
            private List<int> versionTest;
            private List<uint> hasVersionTest;

            public int WzVersion
            {
                get
                {
                    int idx = this.versionTest.Count - 1;
                    return idx > -1 ? this.versionTest[idx] : 0;
                }
            }

            public uint HashVersion
            {
                get
                {
                    int idx = this.hasVersionTest.Count - 1;
                    return idx > -1 ? this.hasVersionTest[idx] : 0;
                }
            }

            public bool TryGetNextVersion()
            {
                for (int i = startVersion + 1; i < Int16.MaxValue; i++)
                {
                    int sum = CalcHashVersion(i);
                    int enc = 0xff
                        ^ ((sum >> 24) & 0xFF)
                        ^ ((sum >> 16) & 0xFF)
                        ^ ((sum >> 8) & 0xFF)
                        ^ ((sum) & 0xFF);

                    // if encver does not passed, try every version one by one
                    if (enc == this.EncryptedVersion)
                    {
                        this.versionTest.Add(i);
                        this.hasVersionTest.Add((uint)sum);
                        startVersion = i;
                        return true;
                    }
                }

                return false;
            }
        }
    }
}

```

`WzComparerR2.WzLib/Wz_Image.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Linq;
using System.Diagnostics;

namespace WzComparerR2.WzLib
{
    public class Wz_Image
    {
        public Wz_Image(string name, int size, int cs32, uint hashOff, uint hashPos, Wz_File wz_f)
        {
            this.Name = name;
            this.WzFile = wz_f;
            this.Size = size;
            this.Checksum = cs32;
            this.HashedOffset = hashOff;
            this.HashedOffsetPosition = hashPos;
            this.Node = new Wz_ImageNode(name, this);

            this.extr = false;
            this.chec = false;
            this.checEnc = false;
        }

        private bool extr;
        private bool chec;
        private bool checEnc;
        private Wz_CryptoKeyType encType;

        public string Name { get; set; }
        public Wz_File WzFile { get; set; }
        public int Size { get; set; }
        public int Checksum { get; set; }
        public uint HashedOffset { get; set; }
        public uint HashedOffsetPosition { get; set; }
        public long Offset { get; set; }
        
        public Wz_Node Node { get; private set; }

        public Wz_Node OwnerNode { get; set; }

        public bool IsChecksumChecked
        {
            get { return this.chec; }
            internal set { this.chec = value; }
        }
        public bool IsLuaImage
        {
            get { return this.Name.EndsWith(".lua"); }
        }

        public Wz_Crypto.Wz_CryptoKey EncKeys
        {
            get
            {
                var crypto = this.WzFile.WzStructure.encryption;
                if (this.checEnc && this.encType != default)
                {
                    return crypto.GetKeys(this.encType);
                }
                return crypto.keys;
            }
        }

        public bool TryExtract()
        {
            Exception ex;
            return TryExtract(out ex);
        }

        public bool TryExtract(out Exception e)
        {
            if (!this.extr)
            {
                bool disabledChec = this.WzFile?.WzStructure?.ImgCheckDisabled ?? false;
                if (!disabledChec && !this.chec)
                {
                    if (this.Checksum != CalcCheckSum())
                    {
                        e = new ArgumentException("checksum error");
                        return false;
                    }
                    this.chec = true;
                }
                if (!this.checEnc)
                {
                    if (!this.IsLuaImage)
                    {
                        try
                        {
                            this.TryDetectEnc();
                            if (!this.checEnc)
                            {
                                e = null;
                                return false;
                            }
                        }
                        catch (Exception ex)
                        {
                            e = ex;
                            this.Unextract();
                            return false;
                        }
                    }
                }

                try
                {
                    lock (this.WzFile.ReadLock)
                    {
                        this.WzFile.FileStream.Position = this.Offset;
                        if (!this.IsLuaImage)
                        {
                            ExtractImg(this.Offset, this.Node, 0);
                            this.WzFile.stringTable.Clear();
                        }
                        else
                        {
                            ExtractLua();
                        }
                        this.extr = true;
                    }
                }
                catch (Exception ex)
                {
                    e = ex;
                    this.Unextract();
                    return false;
                }
            }
            e = null;
            return true;
        }

        public void Unextract()
        {
            this.extr = false;
            this.Node.Nodes.Clear();
        }

        public unsafe int CalcCheckSum()
        {
            lock (this.WzFile.ReadLock)
            {
                this.WzFile.FileStream.Position = this.Offset;
                int cs = 0;
                byte[] buffer = new byte[4096];
                int count;
                int size = this.Size;
                while ((count = this.WzFile.FileStream.Read(buffer, 0, Math.Min(size, buffer.Length))) > 0)
                {
                    fixed (byte* pBuffer = buffer)
                    {
                        int* p = (int*)pBuffer;
                        int i, j = count / 4;
                        for (i = 0; i < j; i++)
                        {
                            int data = *(p + i);
                            cs += (data & 0xff) + (data >> 8 & 0xff) + (data >> 16 & 0xff) + (data >> 24 & 0xff);
                        }
                        for (i = i * 4; i < count; i++)
                        {
                            cs += buffer[i];
                        }
                    }

                    size -= count;
                }
                return cs;
            }
        }

        private void ExtractImg(long offset, Wz_Node parent, long eob)
        {
            int entries = 0;
            string tag = this.WzFile.ReadString(offset, this.EncKeys);
            switch (tag)
            {
                case "Property":
                    this.WzFile.FileStream.Position += 2;
                    entries = this.WzFile.ReadInt32();
                    for (int i = 0; i < entries; i++)
                    {
                        ExtractValue(offset, parent);
                    }
                    break;

                case "Shape2D#Vector2D":
                    parent.Value = new Wz_Vector(this.WzFile.ReadInt32(), this.WzFile.ReadInt32());
                    break;

                case "Canvas":
                    this.WzFile.FileStream.Position++;
                    if (this.WzFile.BReader.ReadByte() == 0x01)
                    {
                        this.WzFile.FileStream.Position += 2;
                        entries = this.WzFile.ReadInt32();
                        for (int i = 0; i < entries; i++)
                        {
                            ExtractValue(offset, parent);
                        }
                    }
                    int w = this.WzFile.ReadInt32();
                    int h = this.WzFile.ReadInt32();
                    int form = this.WzFile.ReadInt32() + this.WzFile.BReader.ReadByte();
                    this.WzFile.FileStream.Position += 4;
                    int bufsize = this.WzFile.BReader.ReadInt32();
                    parent.Value = new Wz_Png(w, h, bufsize - 1, form, (uint)this.WzFile.FileStream.Position + 1, this);
                    this.WzFile.FileStream.Position += bufsize;
                    break;

                case "Shape2D#Convex2D":
                    entries = this.WzFile.ReadInt32();
                    for (int i = 0; i < entries; i++)
                    {
                        ExtractImg(offset, parent, 0);
                    }
                    break;

                case "Sound_DX8":
                    this.WzFile.FileStream.Position++;
                    int len = this.WzFile.ReadInt32();
                    int ms = this.WzFile.ReadInt32();
                    int headerLen = (int)(eob - len - this.WzFile.FileStream.Position);
                    byte[] header = this.WzFile.BReader.ReadBytes(headerLen);
                    parent.Value = new Wz_Sound((uint)(eob - len), len, header, ms, this);
                    this.WzFile.FileStream.Position = eob;
                    break;

                case "UOL":
                    this.WzFile.FileStream.Position++;
                    parent.Value = new Wz_Uol(this.WzFile.ReadString(offset, this.EncKeys));
                    break;

                case "RawData": // introduced in GMS v243
                    this.WzFile.FileStream.Position++;
                    int rawDataLen = this.WzFile.ReadInt32();
                    uint rawDataOffset = (uint)this.WzFile.FileStream.Position;
                    parent.Value = new Wz_RawData(rawDataOffset, rawDataLen, this);
                    this.WzFile.FileStream.Position += rawDataLen;
                    break;

                default:
                    throw new Exception("unknown wz tag: " + tag);
            }
        }

        private void TryDetectEnc()
        {
            this.encType = default;
            this.checEnc = false;

            var wzsEncType = this.WzFile.WzStructure.encryption.EncType;
            if (wzsEncType != default)
            {
                if (this.IsIllegalTag(wzsEncType))
                {
                    this.encType = wzsEncType;
                    this.checEnc = true;
                    return;
                }
            }

            foreach (var enc in new[] {
                Wz_CryptoKeyType.BMS,
                Wz_CryptoKeyType.KMS,
                Wz_CryptoKeyType.GMS,
            })
            {
                if (this.IsIllegalTag(enc))
                {
                    this.encType = enc;
                    this.checEnc = true;
                    return;
                }
            }
        }

        private bool IsIllegalTag(Wz_CryptoKeyType keyType)
        {
            this.WzFile.FileStream.Position = this.Offset;
            this.WzFile.stringTable.Remove(Offset);
            switch (this.WzFile.ReadString(Offset, keyType))
            {
                case "Property":
                case "Shape2D#Vector2D":
                case "Canvas":
                case "Shape2D#Convex2D":
                case "Sound_DX8":
                case "UOL":
                    return true;
                default:
                    return false;
            }
        }

        private void ExtractValue(long offset, Wz_Node parent)
        {
            parent = parent.Nodes.Add(this.WzFile.ReadString(offset, this.EncKeys));
            byte flag = this.WzFile.BReader.ReadByte();
            switch (flag)
            {
                case 0x00:
                    parent.Value = null;
                    break;

                case 0x02:
                case 0x0B:
                    parent.Value = this.WzFile.BReader.ReadInt16();
                    break;

                case 0x03:
                case 0x13:
               // case 0x14:
                    parent.Value = this.WzFile.ReadInt32();
                    break;

                case 0x14:
                    parent.Value = this.WzFile.ReadInt64();
                    break;

                case 0x04:
                    parent.Value = this.WzFile.ReadSingle();
                    break;

                case 0x05:
                    parent.Value = this.WzFile.BReader.ReadDouble();
                    break;

                case 0x08:
                    parent.Value = this.WzFile.ReadString(offset, this.EncKeys);
                    break;

                case 0x09:
                    ExtractImg(offset, parent, this.WzFile.BReader.ReadInt32() + this.WzFile.FileStream.Position);
                    break;

                default:
                    throw new Exception("读取值错误." + flag + " at Offset: " + this.WzFile.FileStream.Position);
            }
        }

        private void ExtractLua()
        {
            while(this.WzFile.FileStream.Position < this.Offset + this.Size)
            {
                var flag = this.WzFile.BReader.ReadByte();

                switch (flag)
                {
                    case 0x01:
                        ExtractLuaValue(this.Node);
                        break;

                    default:
                        throw new Exception("读取Lua错误." + flag + " at Offset: " + this.WzFile.FileStream.Position);
                }
            }
        }

        private void ExtractLuaValue(Wz_Node parent)
        {
            int len = this.WzFile.ReadInt32();
            byte[] data = this.WzFile.BReader.ReadBytes(len);
            if (!this.checEnc)
            {
                TryDetectLuaEnc(data);
            }
            this.EncKeys.Decrypt(data, 0, data.Length);
            string luaCode = Encoding.UTF8.GetString(data);
            parent.Value = luaCode;
        }

        private void TryDetectLuaEnc(byte[] luaBinary)
        {
            byte[] tempBuffer = new byte[Math.Min(luaBinary.Length, 64)];
            char[] tempStr = new char[tempBuffer.Length];

            //测试各种加密方式 判断符合度最高的
            int maxCharCount = 0;
            var maxCharEnc = Wz_CryptoKeyType.Unknown;

            foreach (var enc in new[] {
                Wz_CryptoKeyType.BMS,
                Wz_CryptoKeyType.KMS,
                Wz_CryptoKeyType.GMS,
            })
            {
                Buffer.BlockCopy(luaBinary, 0, tempBuffer, 0, tempBuffer.Length);

                this.WzFile.WzStructure.encryption.GetKeys(enc).Decrypt(tempBuffer, 0, tempBuffer.Length);
                int count = Encoding.UTF8.GetChars(tempBuffer, 0, tempBuffer.Length, tempStr, 0);
                int asciiCount = tempStr.Take(count).Count(chr => 32 <= chr && chr <= 127);

                if (maxCharCount < asciiCount)
                {
                    maxCharEnc = enc;
                    maxCharCount = asciiCount;
                }
            }
            this.encType = maxCharEnc;
            this.checEnc = true;
        }
        
        internal class Wz_ImageNode : Wz_Node
        {
            public Wz_ImageNode(string nodeText, Wz_Image image) : base(nodeText)
            {
                this.Image = image;
            }

            public Wz_Image Image { get; private set; }
        }
    }
}

```

`WzComparerR2.WzLib/Wz_Node.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.IO;
using System.Xml;
using System.Reflection;
using System.Text.RegularExpressions;

namespace WzComparerR2.WzLib
{
    public class Wz_Node : ICloneable, IComparable, IComparable<Wz_Node>
    {
        public Wz_Node()
        {
            this.nodes = new WzNodeCollection(this);
        }

        public Wz_Node(string nodeText)
            : this()
        {
            this.text = nodeText;
        }

        //fields
        private object value;
        private string text;
        private WzNodeCollection nodes;
        private Wz_Node parentNode;

        //properties
        public object Value
        {
            get { return value; }
            set { this.value = value; }
        }

        public string Text
        {
            get { return this.text; }
            set { this.text = value; }
        }

        public string FullPath
        {
            get
            {
                Stack<string> path = new Stack<string>();
                Wz_Node node = this;
                do
                {
                    path.Push(node.text);
                    node = node.parentNode;
                } while (node != null);
                return string.Join("\\", path.ToArray());
            }
        }

        public string FullPathToFile
        {
            get
            {
                Stack<string> path = new Stack<string>();
                Wz_Node node = this;
                do
                {
                    if (node.value is Wz_File wzf && !wzf.IsSubDir)
                    {
                        if (node.text.EndsWith(".wz", StringComparison.OrdinalIgnoreCase))
                        {
                            path.Push(node.text.Substring(0, node.text.Length - 3));
                        }
                        else
                        {
                            path.Push(node.text);
                        }
                        break;
                    }

                    path.Push(node.text);

                    var img = node.GetValue<Wz_Image>();
                    if (img != null)
                    {
                        node = img.OwnerNode;
                    }

                    if (node != null)
                    {
                        node = node.parentNode;
                    }
                } while (node != null);
                return string.Join("\\", path.ToArray());
            }
        }

        public WzNodeCollection Nodes
        {
            get { return this.nodes; }
        }

        public Wz_Node ParentNode
        {
            get { return parentNode; }
            private set { parentNode = value; }
        }

        //methods
        public override string ToString()
        {
            return this.Text + " " + (this.value != null ? this.value.ToString() : "-") + " " + this.nodes.Count;
        }

        public Wz_Node FindNodeByPath(string fullPath)
        {
            return FindNodeByPath(fullPath, false);
        }

        public Wz_Node FindNodeByPath(string fullPath, bool extractImage)
        {
            string[] patten = fullPath.Split('\\');
            return FindNodeByPath(extractImage, patten);
        }

        public Wz_Node FindNodeByPath(bool extractImage, params string[] fullPath)
        {
            return FindNodeByPath(extractImage, false, fullPath);
        }

        public Wz_Node FindNodeByPath(bool extractImage, bool ignoreCase, params string[] fullPath)
        {
            Wz_Node node = this;

            Wz_Image img;

            //首次解压
            if (extractImage && (img = this.GetValue<Wz_Image>()) != null)
            {
                if (img.TryExtract())
                {
                    node = img.Node;
                }
            }

            foreach (string txt in fullPath)
            {
                if (ignoreCase)
                {
                    bool find = false;

                    foreach (Wz_Node subNode in node.nodes)
                    {
                        if (string.Equals(subNode.text, txt, StringComparison.OrdinalIgnoreCase))
                        {
                            find = true;
                            node = subNode;
                        }
                    }
                    if (!find)
                        node = null;
                }
                else
                {
                    node = node.nodes[txt];
                }

                if (node == null)
                    return null;

                if (extractImage)
                {
                    img = node.GetValue<Wz_Image>();
                    if (img != null && img.TryExtract()) //判断是否是img
                    {
                        node = img.Node;
                    }
                }
            }
            return node;
        }

        public T GetValue<T>(T defaultValue)
        {
            var typeT = typeof(T);
            if (typeof(Wz_Image) == typeT)
            {
                if (this is Wz_Image.Wz_ImageNode)
                {
                    return (T)(object)(((Wz_Image.Wz_ImageNode)this).Image);
                }
                else
                {
                    return (this.value is T) ? (T)this.value : default(T);
                }
            }
            if (this.value == null)
                return defaultValue;
            if (this.value is T)
                return (T)this.value;


            if (this.value is string s)
            {
                if (ObjectConverter.TryParse<T>(s, out T result, out bool hasTryParse))
                {
                    return result;
                }
                if (hasTryParse)
                {
                    return defaultValue;
                }
            }

            if (this.value is IConvertible iconvertible)
            {
                if (typeT.IsGenericType && typeT.GetGenericTypeDefinition() == typeof(Nullable<>))
                {
                    typeT = typeT.GetGenericArguments()[0];
                }

                try
                {
                    T result = (T)iconvertible.ToType(typeT, null);
                    return result;
                }
                catch
                {
                }
            }
            return defaultValue;
        }

        public T GetValue<T>()
        {
            return GetValue<T>(default(T));
        }

        //innerClass
        public class WzNodeCollection : IEnumerable<Wz_Node>
        {
            public WzNodeCollection(Wz_Node owner)

            {
                this.owner = owner;
                this.innerCollection = null;
            }

            private readonly Wz_Node owner;
            private InnerCollection innerCollection;

            public Wz_Node this[int index]
            {
                get { return this.innerCollection?[index]; }
            }

            public Wz_Node this[string key]
            {
                get { return this.innerCollection?[key]; }
            }

            public int Count
            {
                get { return this.innerCollection?.Count ?? 0; }
            }

            public Wz_Node Add(string nodeText)
            {
                this.EnsureInnerCollection();
                return this.innerCollection.Add(nodeText);
            }

            public void Add(Wz_Node item)
            {
                this.EnsureInnerCollection();
                this.innerCollection.Add(item);
            }

            public void Sort()
            {
                this.innerCollection?.Sort();
            }

            public void Sort<T>(Func<Wz_Node, T> getKeyFunc) where T : IComparable<T>
            {
                if (getKeyFunc == null)
                {
                    this.Sort();
                }
                else if (this.innerCollection != null)
                {
                    this.innerCollection.Sort(getKeyFunc);
                }
            }

            public void Trim()
            {
                this.innerCollection?.Trim();
            }

            public void Clear()
            {
                this.innerCollection?.Clear();
            }

            public IEnumerator<Wz_Node> GetEnumerator()
            {
                return this.innerCollection?.GetEnumerator() ?? System.Linq.Enumerable.Empty<Wz_Node>().GetEnumerator();
            }

            System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
            {
                return this.GetEnumerator();
            }

            private void EnsureInnerCollection()
            {
                if (this.innerCollection == null)
                {
                    this.innerCollection = new InnerCollection(this.owner);
                }
            }

            private class InnerCollection : KeyedCollection<string, Wz_Node>
            {
                public InnerCollection(Wz_Node owner)
                    : base(null, 12)
                {
                    this.parentNode = owner;
                }

                public Wz_Node Add(string nodeText)
                {
                    Wz_Node newNode = new Wz_Node(nodeText);
                    this.Add(newNode);
                    return newNode;
                }

                public new void Add(Wz_Node item)
                {
                    base.Add(item);
                    if (item.parentNode != null)
                    {
                        int index = item.parentNode.nodes.innerCollection.Items.IndexOf(item);
                        if (index > -1)
                        {
                            item.parentNode.nodes.innerCollection.RemoveItem(index);
                        }
                    }
                    item.parentNode = this.parentNode;
                }

                protected override void RemoveItem(int index)
                {
                    var item = this[index];
                    if (item != null)
                    {
                        item.parentNode = null;
                    }
                    base.RemoveItem(index);
                }

                private readonly Wz_Node parentNode;

                public void Sort()
                {
                    (base.Items as List<Wz_Node>)?.Sort();
                }

                public void Sort<T>(Func<Wz_Node, T> getKeyFunc) where T : IComparable<T>
                {
                    ListSorter.Sort(base.Items as List<Wz_Node>, getKeyFunc);
                }

                public void Trim()
                {
                    (base.Items as List<Wz_Node>)?.TrimExcess();
                }

                public new Wz_Node this[string key]
                {
                    get
                    {
                        if (key == null)
                        {
                            return null;
                        }
                        if (this.Dictionary != null)
                        {
                            Wz_Node node;
                            this.Dictionary.TryGetValue(key, out node);
                            return node;
                        }
                        else
                        {
                            List<Wz_Node> list = this.Items as List<Wz_Node>;
                            foreach (var node in list)
                            {
                                if (this.Comparer.Equals(this.GetKeyForItem(node), key))
                                {
                                    return node;
                                }
                            }
                            return null;
                        }
                    }
                }

                protected override string GetKeyForItem(Wz_Node item)
                {
                    return item.text;
                }
            }

            internal static class ListSorter
            {
                public static void Sort<T, TKey>(List<T> list, Func<T, TKey> getKeyFunc)
                {
                    T[] innerArray = list.GetType()
                        .GetField("_items", BindingFlags.Instance | BindingFlags.NonPublic)
                        .GetValue(list) as T[];

                    TKey[] keys = new TKey[list.Count];

                    for (int i = 0; i < keys.Length; i++)
                    {
                        keys[i] = getKeyFunc(innerArray[i]);
                    }

                    Array.Sort(keys, innerArray, 0, keys.Length);
                }
            }
        }

        public object Clone()
        {
            Wz_Node newNode = new Wz_Node(this.text);
            newNode.value = this.value;
            foreach (Wz_Node node in this.nodes)
            {
                Wz_Node newChild = node.Clone() as Wz_Node;
                newNode.nodes.Add(newChild);
            }
            return newNode;
        }

        int IComparable.CompareTo(object obj)
        {
            return ((IComparable<Wz_Node>)this).CompareTo(obj as Wz_Node);
        }

        int IComparable<Wz_Node>.CompareTo(Wz_Node other)
        {
            if (other != null)
            {
                return string.Compare(this.Text, other.Text, StringComparison.Ordinal);
            }
            else
            {
                return 1;
            }
        }
    }

    public static class Wz_NodeExtension
    {
        public static T GetValueEx<T>(this Wz_Node node, T defaultValue)
        {
            if (node == null)
                return defaultValue;
            return node.GetValue<T>(defaultValue);
        }

        public static T? GetValueEx<T>(this Wz_Node node) where T : struct
        {
            if (node == null)
                return null;
            return node.GetValue<T>();
        }

        public static Wz_Node ResolveUol(this Wz_Node node)
        {
            if (node == null)
                return null;
            Wz_Uol uol;
            while ((uol = node?.GetValueEx<Wz_Uol>(null)) != null)
            {
                node = uol.HandleUol(node);
            }
            return node;
        }

        /// <summary>
        /// 搜索node所属的wz_file，若搜索不到则返回null。
        /// </summary>
        /// <param Name="node">要搜索的wznode。</param>
        /// <returns></returns>
        public static Wz_File GetNodeWzFile(this Wz_Node node, bool returnClosestWzFile = false)
        {
            Wz_File wzfile = null;
            while (node != null)
            {
                if ((wzfile = node.Value as Wz_File) != null)
                {
                    if (wzfile.OwnerWzFile != null)
                    {
                        wzfile = wzfile.OwnerWzFile;
                        node = wzfile.Node;
                    }
                    if (!wzfile.IsSubDir || returnClosestWzFile)
                    {
                        break;
                    }
                }
                else if (node.Value is Wz_Image wzImg
                    || (wzImg = (node as Wz_Image.Wz_ImageNode)?.Image) != null)
                {
                    wzfile = GetImageWzFile(wzImg, returnClosestWzFile);
                    break;
                }
                node = node.ParentNode;
            }
            return wzfile;
        }

        public static Wz_File GetImageWzFile(this Wz_Image wzImg, bool returnClosestWzFile = false)
        {
            if (!returnClosestWzFile && wzImg.WzFile != null)
            {
                return GetNodeWzFile(wzImg.WzFile.Node, returnClosestWzFile);
            }

            return wzImg.WzFile;
        }

        public static int GetMergedVersion(this Wz_File wzFile)
        {
            if (wzFile.Header.WzVersion != 0)
            {
                return wzFile.Header.WzVersion;
            }
            foreach (var subFile in wzFile.MergedWzFiles)
            {
                if (subFile.Header.WzVersion != 0)
                {
                    return subFile.Header.WzVersion;
                }
            }
            return 0;
        }

        public static Wz_Image GetNodeWzImage(this Wz_Node node)
        {
            Wz_Image wzImg = null;
            while (node != null)
            {
                if ((wzImg = node.Value as Wz_Image) != null
                    || (wzImg = (node as Wz_Image.Wz_ImageNode)?.Image) != null)
                {
                    break;
                }
                node = node.ParentNode;
            }
            return wzImg;
        }

        public static void DumpAsXml(this Wz_Node node, XmlWriter writer)
        {
            object value = node.Value;

            if (value == null || value is Wz_Image)
            {
                writer.WriteStartElement("dir");
                writer.WriteAttributeString("name", node.Text);
            }
            else if (value is Wz_Png)
            {
                var png = (Wz_Png)value;
                writer.WriteStartElement("png");
                writer.WriteAttributeString("name", node.Text);
                using (var bmp = png.ExtractPng())
                {
                    using (var ms = new MemoryStream())
                    {
                        bmp.Save(ms, System.Drawing.Imaging.ImageFormat.Png);
                        byte[] data = ms.ToArray();
                        writer.WriteAttributeString("value", Convert.ToBase64String(data));
                    }
                }
            }
            else if (value is Wz_Uol)
            {
                var uol = (Wz_Uol)value;
                writer.WriteStartElement("uol");
                writer.WriteAttributeString("name", node.Text);
                writer.WriteAttributeString("value", uol.Uol);
            }
            else if (value is Wz_Vector)
            {
                var vector = (Wz_Vector)value;
                writer.WriteStartElement("vector");
                writer.WriteAttributeString("name", node.Text);
                writer.WriteAttributeString("value", $"{vector.X}, {vector.Y}");
            }
            else if (value is Wz_Sound)
            {
                var sound = (Wz_Sound)value;
                writer.WriteStartElement("sound");
                writer.WriteAttributeString("name", node.Text);
                byte[] data = sound.ExtractSound();
                if (data == null)
                {
                    data = new byte[sound.DataLength];
                    sound.WzFile.FileStream.Seek(sound.Offset, SeekOrigin.Begin);
                    sound.WzFile.FileStream.Read(data, 0, sound.DataLength);
                }
                writer.WriteAttributeString("value", Convert.ToBase64String(data));
            }
            else
            {
                var tag = value.GetType().Name.ToLower();
                writer.WriteStartElement(tag);
                writer.WriteAttributeString("name", node.Text);
                writer.WriteAttributeString("value", value.ToString());
            }

            //输出子节点
            foreach (var child in node.Nodes)
            {
                DumpAsXml(child, writer);
            }

            //结束标识
            writer.WriteEndElement();
        }

        public static void SortByImgID(this Wz_Node.WzNodeCollection nodes)
        {
            if (regexImgID == null)
            {
                regexImgID = new Regex(@"^(\d+)\.img$", RegexOptions.Compiled);
            }

            nodes.Sort(GetKey);
        }

        private static Regex regexImgID;

        private static SortKey GetKey(Wz_Node node)
        {
            var key = new SortKey();
            var m = regexImgID.Match(node.Text);
            if (m.Success)
            {
                key.HasID = Int32.TryParse(m.Result("$1"), out key.ImgID);
            }
            key.Text = node.Text;
            return key;
        }

        private struct SortKey : IComparable<SortKey>
        {
            public bool HasID;
            public int ImgID;
            public string Text;

            public int CompareTo(SortKey other)
            {
                if (this.HasID && other.HasID) return this.ImgID.CompareTo(other.ImgID);
                return StringComparer.Ordinal.Compare(this.Text, other.Text);
            }
        }
    }

    public static class ObjectConverter
    {
        private static readonly Dictionary<Type, Delegate> cache = new Dictionary<Type, Delegate>();
        private delegate bool TryParseFunc<T>(string s, out T value);

        public static bool TryParse<T>(string s, out T value, out bool hasTryParse)
        {
            var typeT = typeof(T);

            TryParseFunc<T> tryParseFunc = null;
            if (!cache.TryGetValue(typeT, out var dele))
            {
                bool isNullable = false;
                Type innerType;
                if (typeT.IsGenericType && typeT.GetGenericTypeDefinition() == typeof(Nullable<>))
                {
                    isNullable = true;
                    innerType = typeT.GetGenericArguments()[0];
                }
                else
                {
                    innerType = typeT;
                }

                var methodInfo = innerType.GetMethod("TryParse",
                    BindingFlags.Static | BindingFlags.Public,
                    null,
                    new[] { typeof(string), innerType.MakeByRefType() },
                    null);

                if (methodInfo != null && methodInfo.ReturnType == typeof(bool))
                {
                    if (isNullable)
                    {
                        dele = Delegate.CreateDelegate(typeof(TryParseFunc<>).MakeGenericType(innerType), methodInfo);
                        var proxyType = typeof(NullableTryParse<>).MakeGenericType(innerType);
                        var proxyInstance = Activator.CreateInstance(proxyType, dele);
                        var proxyParseFunc = proxyType.GetMethod("TryParse", BindingFlags.Public | BindingFlags.Instance);
                        cache[typeT] = tryParseFunc = (TryParseFunc<T>)Delegate.CreateDelegate(typeof(TryParseFunc<T>), proxyInstance, proxyParseFunc);
                    }
                    else
                    {
                        cache[typeT] = tryParseFunc = (TryParseFunc<T>)Delegate.CreateDelegate(typeof(TryParseFunc<T>), methodInfo);
                    }
                }
                else
                {
                    cache[typeT] = null;
                }
            }
            else
            {
                tryParseFunc = dele as TryParseFunc<T>;
            }

            if (tryParseFunc != null)
            {
                hasTryParse = true;
                return tryParseFunc(s, out value);
            }
            else
            {
                hasTryParse = false;
                value = default(T);
                return false;
            }
        }

        private class NullableTryParse<T> where T : struct
        {
            public NullableTryParse(TryParseFunc<T> func)
            {
                this.func = func;
            }

            private readonly TryParseFunc<T> func;

            public bool TryParse(string s, out T? value)
            {
                if (this.func(s, out var v))
                {
                    value = v;
                    return true;
                }
                else
                {
                    value = default(T?);
                    return false;
                }
            }
        }
    }
}
```

`WzComparerR2.WzLib/Wz_Png.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;
using System.IO;
using System.IO.Compression;
using System.Drawing.Imaging;
using System.Runtime.InteropServices;

namespace WzComparerR2.WzLib
{
    public class Wz_Png
    {
        public Wz_Png(int w, int h, int data_length, int form, uint offs, Wz_Image wz_i)
        {
            this.w = w;
            this.h = h;
            this.data_length = data_length;
            this.form = form;
            this.offs = offs;
            this.wz_i = wz_i;
        }

        private int w;
        private int h;
        private int data_length;
        private int form;
        private uint offs;
        private Wz_Image wz_i;

        /// <summary>
        /// 获取或设置图片的宽度。
        /// </summary>
        public int Width
        {
            get { return w; }
            set { w = value; }
        }

        /// <summary>
        /// 获取或设置图片的高度。
        /// </summary>
        public int Height
        {
            get { return h; }
            set { h = value; }
        }

        /// <summary>
        /// 获取或设置数据块的长度。
        /// </summary>
        public int DataLength
        {
            get { return data_length; }
            set { data_length = value; }
        }

        /// <summary>
        /// 获取或设置数据块对于文件的偏移。
        /// </summary>
        public uint Offset
        {
            get { return offs; }
            set { offs = value; }
        }

        /// <summary>
        /// 获取或设置图片的数据压缩方式。
        /// </summary>
        public int Form
        {
            get { return form; }
            set { form = value; }
        }

        /// <summary>
        /// 获取或设置图片所属的WzFile
        /// </summary>
        public Wz_File WzFile
        {
            get { return wz_i.WzFile; }
            set { wz_i.WzFile = value; }
        }

        /// <summary>
        /// 获取或设置图片所属的WzImage
        /// </summary>
        public Wz_Image WzImage
        {
            get { return wz_i; }
            set { wz_i = value; }
        }

        public byte[] GetRawData()
        {
            lock (this.WzFile.ReadLock)
            {
                DeflateStream zlib;
                byte[] plainData = null;

                this.WzFile.FileStream.Position = this.Offset;

                if (this.WzFile.BReader.ReadUInt16() == 0x9C78)
                {
                    byte[] buffer = this.WzFile.BReader.ReadBytes(this.data_length - 2);
                    MemoryStream dataStream = new MemoryStream(buffer);

                    zlib = new DeflateStream(dataStream, CompressionMode.Decompress);
                }
                else
                {
                    this.WzFile.FileStream.Position -= 2;
                    MemoryStream dataStream = new MemoryStream(this.DataLength);
                    int blocksize = 0;
                    int endPosition = (int)(this.DataLength + this.WzFile.FileStream.Position);

                    var encKeys = this.WzImage.EncKeys;

                    while (this.WzFile.FileStream.Position < endPosition)
                    {
                        blocksize = this.WzFile.BReader.ReadInt32();
                        byte[] dataBlock = this.WzFile.BReader.ReadBytes(blocksize);
                        encKeys.Decrypt(dataBlock, 0, dataBlock.Length);

                        dataStream.Write(dataBlock, 0, dataBlock.Length);
                    }
                    dataStream.Position = 2;
                    zlib = new DeflateStream(dataStream, CompressionMode.Decompress);
                }

                switch (this.Form)
                {
                    case 1:
                    case 257:
                    case 513:
                        plainData = new byte[this.w * this.h * 2];
                        ReadAvailableBytes(zlib, plainData, 0, plainData.Length);
                        break;

                    case 2:
                        plainData = new byte[this.w * this.h * 4];
                        ReadAvailableBytes(zlib, plainData, 0, plainData.Length);
                        break;

                    case 3:
                        plainData = new byte[((int)Math.Ceiling(this.w / 4.0)) * 4 * ((int)Math.Ceiling(this.h / 4.0)) * 4 / 8];
                        ReadAvailableBytes(zlib, plainData, 0, plainData.Length);
                        break;

                    case 517:
                        plainData = new byte[this.w * this.h / 128];
                        ReadAvailableBytes(zlib, plainData, 0, plainData.Length);
                        break;

                    case 1026:
                    case 2050:
                        plainData = new byte[this.w * this.h];
                        ReadAvailableBytes(zlib, plainData, 0, plainData.Length);
                        break;

                    default:
                        var msOut = new MemoryStream();
                        zlib.CopyTo(msOut);
                        plainData = msOut.ToArray();
                        break;
                }
                if (zlib != null)
                {
                    zlib.Close();
                }
                return plainData;
            }
        }

        public Bitmap ExtractPng()
        {
            byte[] pixel = this.GetRawData();
            if (pixel == null)
            {
                return null;
            }
            Bitmap pngDecoded = null;
            BitmapData bmpdata;
            byte[] argb;

            switch (this.form)
            {
                case 1: //16位argb4444
                    argb = GetPixelDataBgra4444(pixel, this.w, this.h);
                    pngDecoded = new Bitmap(this.w, this.h, PixelFormat.Format32bppArgb);
                    bmpdata = pngDecoded.LockBits(new Rectangle(Point.Empty, pngDecoded.Size), ImageLockMode.WriteOnly, PixelFormat.Format32bppArgb);
                    Marshal.Copy(argb, 0, bmpdata.Scan0, argb.Length);
                    pngDecoded.UnlockBits(bmpdata);
                    break;

                case 2: //32位argb8888
                    pngDecoded = new Bitmap(this.w, this.h, PixelFormat.Format32bppArgb);
                    bmpdata = pngDecoded.LockBits(new Rectangle(Point.Empty, pngDecoded.Size), ImageLockMode.WriteOnly, PixelFormat.Format32bppArgb);
                    Marshal.Copy(pixel, 0, bmpdata.Scan0, pixel.Length);
                    pngDecoded.UnlockBits(bmpdata);
                    break;

                case 3: //黑白缩略图
                    argb = GetPixelDataForm3(pixel, this.w, this.h);
                    pngDecoded = new Bitmap(this.w, this.h, PixelFormat.Format32bppArgb);
                    bmpdata = pngDecoded.LockBits(new Rectangle(Point.Empty, pngDecoded.Size), ImageLockMode.WriteOnly, PixelFormat.Format32bppArgb);
                    Marshal.Copy(argb, 0, bmpdata.Scan0, argb.Length);
                    pngDecoded.UnlockBits(bmpdata);
                    break;

                case 257: //16位argb1555
                    pngDecoded = new Bitmap(this.w, this.h, PixelFormat.Format16bppArgb1555);
                    bmpdata = pngDecoded.LockBits(new Rectangle(Point.Empty, pngDecoded.Size), ImageLockMode.WriteOnly, PixelFormat.Format16bppArgb1555);
                    CopyBmpDataWithStride(pixel, pngDecoded.Width * 2, bmpdata);
                    pngDecoded.UnlockBits(bmpdata);
                    break;

                case 513: //16位rgb565
                    pngDecoded = new Bitmap(this.w, this.h, PixelFormat.Format16bppRgb565);
                    bmpdata = pngDecoded.LockBits(new Rectangle(new Point(), pngDecoded.Size), ImageLockMode.WriteOnly, PixelFormat.Format16bppRgb565);
                    CopyBmpDataWithStride(pixel, pngDecoded.Width * 2, bmpdata);
                    pngDecoded.UnlockBits(bmpdata);
                    break;

                case 517: //16位rgb565缩略图
                    argb = GetPixelDataForm517(pixel, this.w, this.h);
                    pngDecoded = new Bitmap(this.w, this.h, PixelFormat.Format16bppRgb565);
                    bmpdata = pngDecoded.LockBits(new Rectangle(0, 0, this.w, this.h), ImageLockMode.WriteOnly, PixelFormat.Format16bppRgb565);
                    Marshal.Copy(argb, 0, bmpdata.Scan0, argb.Length);
                    pngDecoded.UnlockBits(bmpdata);
                    break;
                   /* pngDecoded = new Bitmap(this.w, this.h);
                    pngSize = this.w * this.h / 128;
                    plainData = new byte[pngSize];
                    zlib.Read(plainData, 0, pngSize);
                    byte iB = 0;
                    for (int i = 0; i < pngSize; i++)
                    {
                        for (byte j = 0; j < 8; j++)
                        {
                            iB = Convert.ToByte(((plainData[i] & (0x01 << (7 - j))) >> (7 - j)) * 0xFF);
                            for (int k = 0; k < 16; k++)
                            {
                                if (x == this.w) { x = 0; y++; }
                                pngDecoded.SetPixel(x, y, Color.FromArgb(0xFF, iB, iB, iB));
                                x++;
                            }
                        }
                    }
                    break;*/

                case 1026: //dxt3
                    argb = GetPixelDataDXT3(pixel, this.w, this.h);
                    pngDecoded = new Bitmap(this.w, this.h, PixelFormat.Format32bppArgb);
                    bmpdata = pngDecoded.LockBits(new Rectangle(new Point(), pngDecoded.Size), ImageLockMode.WriteOnly, PixelFormat.Format32bppArgb);
                    Marshal.Copy(argb, 0, bmpdata.Scan0, argb.Length);
                    pngDecoded.UnlockBits(bmpdata);
                    break;

                case 2050: //dxt5
                    argb = GetPixelDataDXT5(pixel, this.w, this.h);
                    pngDecoded = new Bitmap(this.w, this.h, PixelFormat.Format32bppArgb);
                    bmpdata = pngDecoded.LockBits(new Rectangle(new Point(), pngDecoded.Size), ImageLockMode.WriteOnly, PixelFormat.Format32bppArgb);
                    Marshal.Copy(argb, 0, bmpdata.Scan0, argb.Length);
                    pngDecoded.UnlockBits(bmpdata);
                    break;
            }

            return pngDecoded;
        }

        public static byte[] GetPixelDataBgra4444(byte[] rawData, int width, int height)
        {
            byte[] argb = new byte[width * height * 4];
            {
                int p;
                for (int i = 0; i < rawData.Length; i++)
                {
                    p = rawData[i] & 0x0F; p |= (p << 4); argb[i * 2] = (byte)p;
                    p = rawData[i] & 0xF0; p |= (p >> 4); argb[i * 2 + 1] = (byte)p;
                }
            }
            return argb;
        }

        public static byte[] GetPixelDataDXT3(byte[] rawData, int width, int height)
        {
            byte[] pixel = new byte[width * height * 4];

            Color[] colorTable = new Color[4];
            int[] colorIdxTable = new int[16];
            byte[] alphaTable = new byte[16];
            for (int y = 0; y < height; y += 4)
            {
                for (int x = 0; x < width; x += 4)
                {
                    int off = x * 4 + y * width;
                    ExpandAlphaTableDXT3(alphaTable, rawData, off);
                    ushort u0 = BitConverter.ToUInt16(rawData, off + 8);
                    ushort u1 = BitConverter.ToUInt16(rawData, off + 10);
                    ExpandColorTable(colorTable, u0, u1);
                    ExpandColorIndexTable(colorIdxTable, rawData, off + 12);

                    for (int j = 0; j < 4; j++)
                    {
                        for (int i = 0; i < 4; i++)
                        {
                            SetPixel(pixel,
                                x + i,
                                y + j,
                                width, 
                                colorTable[colorIdxTable[j * 4 + i]],
                                alphaTable[j * 4 + i]);
                        }
                    }
                }
            }

            return pixel;
        }

        public static byte[] GetPixelDataDXT5(byte[] rawData, int width, int height)
        {
            byte[] pixel = new byte[width * height * 4];

            Color[] colorTable = new Color[4];
            int[] colorIdxTable = new int[16];
            byte[] alphaTable = new byte[8];
            int[] alphaIdxTable = new int[16];
            for (int y = 0; y < height; y += 4)
            {
                for (int x = 0; x < width; x += 4)
                {
                    int off = x * 4 + y * width;
                    ExpandAlphaTableDXT5(alphaTable, rawData[off + 0], rawData[off + 1]);
                    ExpandAlphaIndexTableDXT5(alphaIdxTable, rawData, off + 2);
                    ushort u0 = BitConverter.ToUInt16(rawData, off + 8);
                    ushort u1 = BitConverter.ToUInt16(rawData, off + 10);
                    ExpandColorTable(colorTable, u0, u1);
                    ExpandColorIndexTable(colorIdxTable, rawData, off + 12);

                    for (int j = 0; j < 4; j++)
                    {
                        for (int i = 0; i < 4; i++)
                        {
                            SetPixel(pixel,
                                x + i,
                                y + j,
                                width,
                                colorTable[colorIdxTable[j * 4 + i]],
                                alphaTable[alphaIdxTable[j * 4 + i]]);
                        }
                    }
                }
            }

            return pixel;
        }

        public static unsafe byte[] GetPixelDataForm3(byte[] rawData, int width, int height)
        {
            byte[] pixel = new byte[width * height * 4];
            fixed (byte* pArray = pixel)
            {
                int* argb2 = (int*)pArray;
                int w = ((int)Math.Ceiling(width / 4.0));
                int h = ((int)Math.Ceiling(height / 4.0));
                for (int y = 0; y < h; y++)
                {
                    for (int x = 0; x < w; x++)
                    {
                        var index = (x + y * w) * 2; //原像素索引
                        var index2 = x * 4 + y * width * 4; //目标像素索引
                        var p = (rawData[index] & 0x0F) | ((rawData[index] & 0x0F) << 4)
                            | ((rawData[index] & 0xF0) | ((rawData[index] & 0xF0) >> 4)) << 8
                            | ((rawData[index + 1] & 0x0F) | ((rawData[index + 1] & 0x0F) << 4)) << 16
                            | ((rawData[index + 1] & 0xF0) | ((rawData[index + 1] & 0xF0) >> 4)) << 24;

                        for (int i = 0; i < 4; i++)
                        {
                            if (x * 4 + i < width)
                            {
                                argb2[index2 + i] = p;
                            }
                            else
                            {
                                break;
                            }
                        }
                    }
                    //复制行
                    var srcIndex = y * width * 4 * 4;
                    var dstIndex = srcIndex + width * 4;
                    for (int j = 1; j < 4; j++)
                    {
                        if (y * 4 + j < height)
                        {
                            Array.Copy(pixel, srcIndex, pixel, dstIndex, width * 4);
                            dstIndex += width * 4;
                        }
                        else
                        {
                            break;
                        }
                    }
                }
            }
            return pixel;
        }

        public static byte[] GetPixelDataForm517(byte[] rawData, int width, int height)
        {
            byte[] pixel = new byte[width * height * 2];
            int lineIndex = 0;
            for (int j0 = 0, j1 = height / 16; j0 < j1; j0++)
            {
                var dstIndex = lineIndex;
                for (int i0 = 0, i1 = width / 16; i0 < i1; i0++)
                {
                    int idx = (i0 + j0 * i1) * 2;
                    byte b0 = rawData[idx];
                    byte b1 = rawData[idx + 1];
                    for (int k = 0; k < 16; k++)
                    {
                        pixel[dstIndex++] = b0;
                        pixel[dstIndex++] = b1;
                    }
                }

                for (int k = 1; k < 16; k++)
                {
                    Array.Copy(pixel, lineIndex, pixel, dstIndex, width * 2);
                    dstIndex += width * 2;
                }

                lineIndex += width * 32;
            }
            return pixel;
        }

        private static void SetPixel(byte[] pixelData, int x, int y, int width, Color color, byte alpha)
        {
            int offset = (y * width + x) * 4;
            pixelData[offset + 0] = color.B;
            pixelData[offset + 1] = color.G;
            pixelData[offset + 2] = color.R;
            pixelData[offset + 3] = alpha;
        }

        #region DXT1 Color
        private static void ExpandColorTable(Color[] color, ushort c0, ushort c1)
        {
            color[0] = RGB565ToColor(c0);
            color[1] = RGB565ToColor(c1);
            if (c0 > c1)
            {
                color[2] = Color.FromArgb(0xff, (color[0].R * 2 + color[1].R + 1) / 3, (color[0].G * 2 + color[1].G + 1) / 3, (color[0].B * 2 + color[1].B + 1) / 3);
                color[3] = Color.FromArgb(0xff, (color[0].R + color[1].R * 2 + 1) / 3, (color[0].G + color[1].G * 2 + 1) / 3, (color[0].B + color[1].B * 2 + 1) / 3);
            }
            else
            {
                color[2] = Color.FromArgb(0xff, (color[0].R + color[1].R) / 2, (color[0].G + color[1].G) / 2, (color[0].B + color[1].B) / 2);
                color[3] = Color.FromArgb(0xff, Color.Black);
            }
        }

        private static void ExpandColorIndexTable(int[] colorIndex, byte[] rawData, int offset)
        {
            for (int i = 0; i < 16; i += 4, offset++)
            {
                colorIndex[i + 0] = (rawData[offset] & 0x03);
                colorIndex[i + 1] = (rawData[offset] & 0x0c) >> 2;
                colorIndex[i + 2] = (rawData[offset] & 0x30) >> 4;
                colorIndex[i + 3] = (rawData[offset] & 0xc0) >> 6;
            }
        }
        #endregion

        #region DXT3/DXT5 Alpha
        private static void ExpandAlphaTableDXT3(byte[] alpha, byte[] rawData, int offset)
        {
            for (int i = 0; i < 16; i += 2, offset++)
            {
                alpha[i + 0] = (byte)(rawData[offset] & 0x0f);
                alpha[i + 1] = (byte)((rawData[offset] & 0xf0) >> 4);
            }
            for (int i = 0; i < 16; i++)
            {
                alpha[i] = (byte)(alpha[i] | (alpha[i] << 4));
            }
        }

        private static void ExpandAlphaTableDXT5(byte[] alpha, byte a0, byte a1)
        {
            alpha[0] = a0;
            alpha[1] = a1;
            if (a0 > a1)
            {
                for(int i = 2; i < 8; i++)
                {
                    alpha[i] = (byte)(((8 - i) * a0 + (i - 1) * a1 + 3) / 7);
                }
            }
            else
            {
                for(int i = 2; i < 6; i++)
                {
                    alpha[i] = (byte)(((6 - i) * a0 + (i - 1) * a1 + 2) / 5);
                }
                alpha[6] = 0;
                alpha[7] = 255;
            }
        }

        private static void ExpandAlphaIndexTableDXT5(int[] alphaIndex, byte[] rawData, int offset)
        {
            for (int i = 0; i < 16; i += 8, offset += 3)
            {
                int flags = rawData[offset]
                    | (rawData[offset + 1] << 8)
                    | (rawData[offset + 2] << 16);
                for(int j = 0; j < 8; j++)
                {
                    int mask = 0x07 << (3 * j);
                    alphaIndex[i + j] = (flags & mask) >> (3 * j);
                }
            }
        }
        #endregion

        public static Color RGB565ToColor(ushort val)
        {
            const int rgb565_mask_r = 0xf800;
            const int rgb565_mask_g = 0x07e0;
            const int rgb565_mask_b = 0x001f;
            int r = (val & rgb565_mask_r) >> 11;
            int g = (val & rgb565_mask_g) >> 5;
            int b = (val & rgb565_mask_b);
            var c = Color.FromArgb(
                (r << 3) | (r >> 2),
                (g << 2) | (g >> 4),
                (b << 3) | (b >> 2));
            return c;
        }

        public static void CopyBmpDataWithStride(byte[] source, int stride, BitmapData bmpData)
        {
            if (bmpData.Stride == stride)
            {
                Marshal.Copy(source, 0, bmpData.Scan0, source.Length);
            }
            else
            {
                for (int y = 0; y < bmpData.Height; y++)
                {
                    Marshal.Copy(source, stride * y, bmpData.Scan0 + bmpData.Stride * y, stride);
                }
            }
        }

        private static int ReadAvailableBytes(Stream inputStream, byte[] array, int offset, int count)
        {
            // this is a wrapper function that to make sure always reading as much as requested from zlib stream;
            // https://github.com/Kagamia/WzComparerR2/issues/195
            int totalRead = 0;
            while (count > 0)
            {
                int bytesRead = inputStream.Read(array, offset, count);
                if (bytesRead == 0) break;
                totalRead += bytesRead;
                offset += bytesRead;
                count -= bytesRead;
            }
            return totalRead;
        }
    }
}

```

`WzComparerR2.WzLib/Wz_RawData.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace WzComparerR2.WzLib
{
    public class Wz_RawData
    {
        public Wz_RawData(uint offset, int length, Wz_Image wz_Image)
        {
            this.Offset = offset;
            this.Length = length;
            this.WzImage = wz_Image;
        }

        public uint Offset { get; set; }
        public int Length { get; set; }
        public Wz_Image WzImage { get; set; }
        public Wz_File WzFile => this.WzImage?.WzFile;
    }
}

```

`WzComparerR2.WzLib/Wz_Sound.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace WzComparerR2.WzLib
{
    public class Wz_Sound
    {
        public Wz_Sound(uint offset, int length, byte[] header, int ms, Wz_Image wz_i)
        {
            this.offset = offset;
            this.dataLength = length;
            this.header = header;
            this.ms = ms;
            this.wz_i = wz_i;
            TryDecryptHeader();
        }

        private uint offset;
        private byte[] header;
        private int dataLength;
        private int ms;

        private Wz_Image wz_i;

        /// <summary>
        /// 获取或设置数据块对于文件的偏移。
        /// </summary>
        public uint Offset
        {
            get { return offset; }
            set { offset = value; }
        }

        /// <summary>
        /// 获取或设置头部字节段。
        /// </summary>
        public byte[] Header
        {
            get { return header; }
            set { header = value; }
        }

        public int Frequency
        {
            get
            {
                if (header == null || header.Length < 0x3c)
                {
                    return 0;
                }
                return BitConverter.ToInt32(header, 0x38);
            }
        }

        /// <summary>
        /// 获取或设置数据块的长度。
        /// </summary>
        public int DataLength
        {
            get { return dataLength; }
            set { dataLength = value; }
        }

        /// <summary>
        /// 获取或设置Mp3的声音毫秒数。
        /// </summary>
        public int Ms
        {
            get { return ms; }
            set { ms = value; }
        }

        /// <summary>
        /// 获取或设置图片所属的WzFile。
        /// </summary>
        public Wz_File WzFile
        {
            get { return wz_i.WzFile; }
            set { wz_i.WzFile = value; }
        }

        /// <summary>
        /// 获取或设置图片所属的WzImage。
        /// </summary>
        public Wz_Image WzImage
        {
            get { return wz_i; }
            set { wz_i = value; }
        }

        public Wz_SoundType SoundType
        {
            get
            {
                Wz_SoundType soundType;
                if (this.header == null)
                {
                    soundType = Wz_SoundType.Mp3;
                }
                else
                {
                    switch (this.header.Length)
                    {
                        default:
                        case 0x52:
                            soundType = Wz_SoundType.Mp3;
                            break;

                        case 0x46:
                            {
                                if (this.Frequency == this.dataLength && this.Ms == 1000)
                                {
                                    soundType = Wz_SoundType.Binary;
                                }
                                else
                                {
                                    soundType = Wz_SoundType.WavRaw;
                                }
                            }
                            break;
                    }
                }

                return soundType;
            }
        }

        public byte[] ExtractSound()
        {
            switch (this.SoundType)
            {
                case Wz_SoundType.Mp3:
                    {
                        byte[] data = new byte[this.dataLength];
                        this.WzFile.FileStream.Seek(this.offset, System.IO.SeekOrigin.Begin);
                        this.WzFile.FileStream.Read(data, 0, this.dataLength);
                        return data;
                    }
                case Wz_SoundType.WavRaw:
                    {
                        byte[] data = new byte[this.dataLength + 44];
                        this.WzFile.FileStream.Seek(this.offset, System.IO.SeekOrigin.Begin);
                        this.WzFile.FileStream.Read(data, 44, this.dataLength);
                        byte[] wavHeader = new byte[44]{
                          0x52,0x49,0x46,0x46, //"RIFF"
                          0,0,0,0, //ChunkSize
                          0x57,0x41,0x56,0x45, //"WAVE"

                          0x66,0x6d,0x74,0x20, //"fmt "
                          0x10,0,0,0, //chunk1Size
                          0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // copy16字节

                          0x64,0x61,0x74,0x61, //"data"
                          0,0,0,0 //chunk2Size
                        };
                        Array.Copy(BitConverter.GetBytes(this.dataLength + 36), 0, wavHeader, 4, 4);
                        Array.Copy(this.header, 0x34, wavHeader, 20, 16);
                        Array.Copy(BitConverter.GetBytes(this.dataLength), 0, wavHeader, 40, 4);
                        Array.Copy(wavHeader, data, wavHeader.Length);
                        return data;
                    }
            }
            return null;
        }

        private void TryDecryptHeader()
        {
            if (this.header == null)
            {
                return;
            }
            if (this.header.Length > 51)
            {
                byte waveFormatLen = this.header[51];
                if (this.header.Length != 52 + waveFormatLen) //长度错误
                {
                    return;
                }
                int cbSize = BitConverter.ToUInt16(this.header, 52 + 16);
                if (cbSize + 18 != waveFormatLen)
                {
                    byte[] tempHeader = new byte[waveFormatLen];
                    Buffer.BlockCopy(this.header, 52, tempHeader, 0, tempHeader.Length);
                    var encKeys = this.WzImage.EncKeys;
                    encKeys.Decrypt(tempHeader, 0, tempHeader.Length); //解密
                    cbSize = BitConverter.ToUInt16(tempHeader, 16); //重新验证
                    if (cbSize + 18 == waveFormatLen)
                    {
                        Buffer.BlockCopy(tempHeader, 0, this.header, 52, tempHeader.Length);
                    }
                }
            }
        }
    }
}

```

`WzComparerR2.WzLib/Wz_SoundType.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace WzComparerR2.WzLib
{
    public enum Wz_SoundType
    {
        Mp3 = 0,
        WavRaw = 1,
        Binary = 2,
    }
}

```

`WzComparerR2.WzLib/Wz_Structure.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Linq;

namespace WzComparerR2.WzLib
{
    public class Wz_Structure
    {
        public Wz_Structure()
        {
            this.wz_files = new List<Wz_File>();
            this.encryption = new Wz_Crypto();
            this.img_number = 0;
            this.has_basewz = false;
            this.TextEncoding = Wz_Structure.DefaultEncoding;
            this.AutoDetectExtFiles = true;//Wz_Structure.DefaultAutoDetectExtFiles;
            this.ImgCheckDisabled = Wz_Structure.DefaultImgCheckDisabled;
            // this.WzVersionVerifyMode = Wz_Structure.DefaultWzVersionVerifyMode;
            this.WzVersionVerifyMode = WzVersionVerifyMode.Fast;
        }

        public List<Wz_File> wz_files;
        public Wz_Crypto encryption;
        public Wz_Node WzNode;
        public int img_number;
        public bool has_basewz;
        public bool sorted; //暂时弃用

        public Encoding TextEncoding { get; set; }
        public bool AutoDetectExtFiles { get; set; }
        public bool ImgCheckDisabled { get; set; }
        public WzVersionVerifyMode WzVersionVerifyMode {get;set;}

        public void Clear()
        {
            foreach (Wz_File f in this.wz_files)
            {
                f.Close();
            }
            this.wz_files.Clear();
            this.encryption.Reset();
            this.img_number = 0;
            this.has_basewz = false;
            this.WzNode = null;
            this.sorted = false;
        }

        public void calculate_img_count()
        {
            foreach (Wz_File f in this.wz_files)
            {
                this.img_number += f.ImageCount;
            }
        }

        public void Load(string fileName, bool useBaseWz = false)
        {
            //现在我们已经不需要list了
            this.WzNode = new Wz_Node(Path.GetFileName(fileName));
            if (Path.GetFileName(fileName).ToLower() == "list.wz")
            {
                this.encryption.LoadListWz(Path.GetDirectoryName(fileName));
                foreach (string list in this.encryption.List)
                {
                    WzNode.Nodes.Add(list);
                }
            }
            else
            {
                LoadFile(fileName, WzNode, useBaseWz);
            }
            calculate_img_count();
        }

        public Wz_File LoadFile(string fileName, Wz_Node node, bool useBaseWz = false, bool loadWzAsFolder = false)
        {
            Wz_File file = null;

            try
            {
                file = new Wz_File(fileName, this);
                if (!file.Loaded)
                {
                    throw new Exception("The file is not a valid wz file.");
                }
                this.wz_files.Add(file);
                file.TextEncoding = this.TextEncoding;
                if (!this.encryption.encryption_detected)
                {
                    this.encryption.DetectEncryption(file);
                }
                node.Value = file;
                file.Node = node;
                file.FileStream.Position = file.Header.DataStartPosition;
                file.GetDirTree(node, useBaseWz, loadWzAsFolder);
                file.Header.DirEndPosition = file.FileStream.Position;
                file.DetectWzType();
                file.DetectWzVersion();
                return file;
            }
            catch
            {
                if (file != null)
                {
                    file.Close();
                    this.wz_files.Remove(file);
                }
                throw;
            }
        }

        public void LoadImg(string fileName)
        {
            this.WzNode = new Wz_Node(Path.GetFileName(fileName));
            this.LoadImg(fileName, WzNode);
        }

        public void LoadImg(string fileName, Wz_Node node)
        {
            Wz_File file = null;

            try
            {
                file = new Wz_File(fileName, this);
                file.TextEncoding = this.TextEncoding;
                file.Node = node;
                var imgNode = new Wz_Node(node.Text);
                //跳过checksum检测
                var img = new Wz_Image(node.Text, (int)file.FileStream.Length, 0, 0, 0, file)
                {
                    OwnerNode = imgNode,
                    Offset = 0,
                    IsChecksumChecked = true
                };
                imgNode.Value = img;

                node.Nodes.Add(imgNode);
                node.Value = file;
                this.wz_files.Add(file);
            }
            catch
            {
                file?.Close();
                throw;
            }
        }

        public void LoadKMST1125DataWz(string fileName)
        {
            LoadWzFolder(Path.GetDirectoryName(fileName), ref this.WzNode, true);
            calculate_img_count();
        }

        public bool IsKMST1125WzFormat(string fileName)
        {
            if (!string.Equals(Path.GetExtension(fileName), ".wz", StringComparison.OrdinalIgnoreCase))
            {
                return false;
            }

            string iniFile = Path.ChangeExtension(fileName, ".ini");
            if (!File.Exists(iniFile))
            {
                return false;
            }

            // check if the file is an empty wzfile
            using (var file = new Wz_File(fileName, this))
            {
                if (!file.Loaded)
                {
                    return false;
                }
                var tempNode = new Wz_Node();
                if (!this.encryption.encryption_detected)
                {
                    this.encryption.DetectEncryption(file);
                }
                file.FileStream.Position = file.Header.DataStartPosition;
                file.GetDirTree(tempNode);
                return file.ImageCount == 0;
            }
        }

        public void LoadWzFolder(string folder, ref Wz_Node node, bool useBaseWz = false)
        {
            string baseName = Path.Combine(folder, Path.GetFileName(folder));
            string entryWzFileName = Path.ChangeExtension(baseName, ".wz");
            string iniFileName = Path.ChangeExtension(baseName, ".ini");
            Func<int, string> extraWzFileName = _index => Path.ChangeExtension($"{baseName}_{_index:D3}", ".wz");

            // load iniFile
            int? lastWzIndex = null;
            if (File.Exists(iniFileName))
            {
                var iniConf = File.ReadAllLines(iniFileName).Select(row =>
                {
                    string[] columns = row.Split('|');
                    string key = columns.Length > 0 ? columns[0] : null;
                    string value = columns.Length > 1 ? columns[1] : null;
                    return new KeyValuePair<string, string>(key, value);
                });
                if (int.TryParse(iniConf.FirstOrDefault(kv => kv.Key == "LastWzIndex").Value, out var indexFromIni))
                {
                    lastWzIndex = indexFromIni;
                }
            }

            // ini file missing or unexpected format
            if (lastWzIndex == null)
            {
                for (int i = 0; ; i++)
                {
                    string extraFile = extraWzFileName(i);
                    if (!File.Exists(extraFile))
                    {
                        break;
                    }
                    lastWzIndex = i;
                }
            }

            // load entry file
            if (node == null)
            {
                node = new Wz_Node(Path.GetFileName(entryWzFileName));
            }
            var entryWzf = this.LoadFile(entryWzFileName, node, useBaseWz, true);

            // load extra file
            if (lastWzIndex != null)
            {
                for (int i = 0, j = lastWzIndex.Value; i <= j; i++)
                {
                    string extraFile = extraWzFileName(i);
                    var tempNode = new Wz_Node(Path.GetFileName(extraFile));
                    var extraWzf = this.LoadFile(extraFile, tempNode, false, true);

                    /*
                     * there is a little hack here, we'll move all img to the entry file, and each img still refers to the original wzfile.
                     * before:
                     *   base.wz (Wz_File)
                     *   |- a.img (Wz_Image)
                     *   base_000.wz (Wz_File)
                     *   |- b.img (Wz_Image) { wz_f = base_000.wz }
                     *   
                     * after:
                     *   base.wz (Wz_File) { mergedFiles = [base_000.wz] }
                     *   |- a.img (Wz_Image)  { wz_f = base.wz }
                     *   |- b.img (Wz_Image)  { wz_f = base_000.wz }
                     *   
                     * this.wz_files references all opened files so they can be closed correctly.
                     */

                    entryWzf.MergeWzFile(extraWzf);
                }
            }
        }

        #region Global Settings
        public static Encoding DefaultEncoding
        {
            get { return _defaultEncoding ?? Encoding.Default; }
            set { _defaultEncoding = value; }
        }

        private static Encoding _defaultEncoding;

        public static bool DefaultAutoDetectExtFiles { get; set; }

        public static bool DefaultImgCheckDisabled { get; set; }

        public static WzVersionVerifyMode DefaultWzVersionVerifyMode { get; set; }
        #endregion
    }
}

```

`WzComparerR2.WzLib/Wz_Type.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace WzComparerR2.WzLib
{
    /// <summary>
    /// 标识Wz_File的内部类型。
    /// </summary>
    public enum Wz_Type
    {
        Unknown = 0,
        Base,
        Character,
        Effect,
        Etc,
        Item,
        Map,
        Mob,
        Morph,
        Npc,
        Quest,
        Reactor,
        Skill,
        Sound,
        String,
        TamingMob,
        UI,
    }
}

```

`WzComparerR2.WzLib/Wz_Uol.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace WzComparerR2.WzLib
{
    public class Wz_Uol
    {
        public Wz_Uol(string uol)
        {
            this.uol = uol;
        }

        private string uol;

        /// <summary>
        /// 获取或设置连接路径字符串。
        /// </summary>
        public string Uol
        {
            get { return uol; }
            set { uol = value; }
        }

        public Wz_Node HandleUol(Wz_Node currentNode)
        {
            if (currentNode == null || currentNode.ParentNode == null || string.IsNullOrEmpty(uol))
                return null;
            string[] dirs = this.uol.Split('/');
            currentNode = currentNode.ParentNode;

            bool outImg = false;

            for (int i = 0; i < dirs.Length; i++)
            {
                string dir = dirs[i];
                if (dir == "..")
                {
                    if (currentNode.ParentNode == null)
                    {
                        Wz_Image img = currentNode.GetValueEx<Wz_Image>(null);
                        if (img != null)
                        {
                            currentNode = img.OwnerNode.ParentNode;
                            outImg = true;
                        }
                        else
                        {
                            currentNode = null;
                        }
                    }
                    else
                    {
                        currentNode = currentNode.ParentNode;
                    }
                }
                else
                {
                    var dirNode = currentNode.FindNodeByPath(dir);

                    if (dirNode == null && outImg)
                    {
                        dirNode = currentNode.FindNodeByPath(true, dir + ".img");
                        if (dirNode.GetValueEx<Wz_Image>(null) != null)
                        {
                            outImg = false;
                        }
                    }

                    currentNode = dirNode;
                }
                if (currentNode == null)
                    return null;
            }
            return currentNode;
        }
    }
}

```

`WzComparerR2.WzLib/Wz_Vector.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;

namespace WzComparerR2.WzLib
{
    public class Wz_Vector
    {
        public Wz_Vector(int x, int y)
        {
            this.x = x;
            this.y = y;
        }

        private int x;
        private int y;

        /// <summary>
        /// 获取或设置向量的X值。
        /// </summary>
        public int X
        {
            get { return x; }
            set { x = value; }
        }

        /// <summary>
        /// 获取或设置向量的Y值。
        /// </summary>
        public int Y
        {
            get { return y; }
            set { y = value; }
        }

        public static implicit operator Point(Wz_Vector vector)
        {
            return vector == null ? new Point() : new Point(vector.x, vector.y);
        }
    }
}

```