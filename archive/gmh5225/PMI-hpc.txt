Project Path: arc_gmh5225_PMI-hpc__uul9ftp

Source Tree:

```txt
arc_gmh5225_PMI-hpc__uul9ftp
├── InstallTestDrv.reg
├── README.md
├── benchmarks
│   ├── README.md
│   ├── build.sh
│   ├── loop_cmpsb.s
│   ├── loop_cmpsw.s
│   ├── loop_lodsb.s
│   ├── loop_lodsw.s
│   ├── loop_movsb.s
│   ├── loop_movsw.s
│   ├── loop_scasb.s
│   ├── loop_scasw.s
│   ├── loop_stosb.s
│   ├── loop_stosw.s
│   ├── rep_cmpsb.s
│   ├── rep_cmpsw.s
│   ├── rep_lodsb.s
│   ├── rep_lodsw.s
│   ├── rep_movsb.s
│   ├── rep_movsw.s
│   ├── rep_scasb.s
│   ├── rep_scasw.s
│   ├── rep_stosb.s
│   └── rep_stosw.s
├── builddrv.bat
├── drv
│   ├── HPCTestDrv.c
│   └── sources
├── output
│   ├── hpcoutput-poll.csv
│   └── hpcoutput-sampl.csv
├── runtest.bat
├── testcode
│   └── test.c
└── tutorial
    ├── images
    │   ├── image1.png
    │   ├── image2.png
    │   ├── image3.png
    │   ├── image4.png
    │   ├── image5.png
    │   └── image6.png
    ├── test.c
    └── tutorial.md

```

`InstallTestDrv.reg`:

```reg
Windows Registry Editor Version 5.00
  
[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\HPCTestDrv]
"Type"=dword:00000001
"Start"=dword:00000003
"ErrorControl"=dword:00000001
"Group"="Base"
"ImagePath"="\\SystemRoot\\System32\\Drivers\\HPCTestDrv.sys"
"Description"="HPC - Sample Test Driver"
"DisplayName"="HPCTestDrv"
```

`README.md`:

```md
HPCTool 
==============================
Features:
------------------------------
- Monitors hardware performance counters 
- Features per-process filtering
- Features two modes:
	1. **POLLING** mode reads performance counter values at a desired state. We instrument source code using software trap (int 2e) to indicate the desired state.
	2. **SAMPLING** mode reads performance counter values at a performance monitoring interrupt (PMI), which is triggered by setting a threshold value on an  event. In our code, we set a threshold value on instruction retired event. 


Requirements: 
------------------------------
1. The HPCTool has been tested on 32 bit, Windows 7, both bare-metal and virtualized.
	- To use the HPCTool in a virtualized environment, verify that the virtual performance counters are enabled. 
		For example, in VMWare Fusion one needs to modify following settings:
		- Enable virtual CPU Performance counters (e.g., on VMware -> settings: VMware->Hardware)
		- In .vmx file add below lines (on VMware):
			- vpmc.enable = "TRUE"
			- vpmc.freezeMode="guest"
		
2. To build the kernel driver, install Windows Driver Kit version 7 available at [Microsoft](https://www.microsoft.com/en-us/download/confirmation.aspx?id=11800). You will need at least the "Full Development Environment" edition.

Building the HPCtool:
--------------------------------
1. Open [drv/HPCTestDrv.c](./drv/HPCTestDrv.c) and make following changes
	
	a. Set the mode of operation to "POLLING_MODE" OR "SAMPLING_MODE".
	
	```bash
		#define SAMPLING_MODE
	```
	b. Set threshold values for generating PMI. 
	 - In SAMPLING_MODE, set pmiThreshold as desired. 
	 - In POLLING_MODE,  set pmiThreshold = 0. 
	
	```bash
		#ifdef SAMPLING_MODE
			INT32 pmiThreshold = -50000;
		#else	//polling mode
			INT32 pmiThreshold = 0;
		#endif
	```

	c. Change TEST_APP to a process/application that has to be monitored.
	
	```bash
		#define TEST_APP "test.exe"
	```

	d. Modify LOG_FILE, to reflect your environment e.g. "C:\\Users\\Sanjeev\\Desktop\\hpcoutput.csv" 
	
	```bash
		#define LOG_FILE L"\\DosDevices\\C:\\Users\\Sanjeev\\Desktop\\hpcoutput.csv"
	```

	e. Set the event type of the performance counters EVENT0, EVENT1, EVENT2, EVENT3 to measure the events of interests. 
	 - By default only user space events are monitored for the following events: 
		- EVENT0: Number of branches retired,
		- EVENT1: Number of mis-predicted branches retired,
		- EVENT2: Number of last level cache references,
		- EVENT3: Number of last level cache misses. 
	
	```bash
		#define EVENT0	0x004100C4		//Branch instruction retired
		#define EVENT1	0x004100C5		//Mispredicted branch instructions
		#define EVENT2	0x00414F2E		//LLC cache reference
		#define EVENT3	0x0041412E		//LLC misses
	```

	 E.g., to monitor Branch Instruction retired (Event Num. = C4H, Umask Value = 00H), 
	 in user space:  we set EVENT0 = 0x4100C4
	 in kernel space: we set EVENT0 = 0x4200C4 

	 Refer to our [tutorial](./tutorial/tutorial.md) for further details on configuring each event. 
	
	 Refer to [Intel Manual](https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-3a-part-1-manual.pdf), Chapter 19 for more information event num and umask value for performance counter events.
2. Open **x86 Checked Build Environment** command prompt with **Administrator** privilege (right click -> Run as Administrator)
3. Change the current directory to the path containing the kernel driver source: 
	
	```bash
		cd PATH-TO-SRC-DIR 
		builddrv.bat
	```
	If the build is successful, HPCTestDrv.sys will be copied to Windows driver directory (e.g., C:\Windows\System32\drivers)



Preparing the instrumented binary: 
--------------------------------
1. The binary that will be measured needs to be instrumented in the source code as shown in the test example in testcode\test.c
	For C/C++ code, insert the following instrumentation trigger to generate the software trap before and after the section of code to be profiled:
	
	```bash
		__asm __volatile{ 
			mov eax, 19h 
			int 0x2e 
		}
	```
2. Compile the source code using C compiler and run HPC tool on the compiled binary.


Running the HPCTool:
--------------------------------
1. Disable the driver signing 
	In the privileged command prompt opened in step 2) type:

	```bash
		bcdedit.exe -set loadoptions DDISABLE_INTEGRITY_CHECKS
		bcdedit.exe -set TESTSIGNING ON
	```
2. Install the kernel driver - you need to do this just once
	
	Double click **InstallTestDrv.reg** and click to accept the registry of the kernel driver. **Restart** the system.

3. Create an empty file in the location specified in **LOG_FILE**

4. Open a command prompt with Administrator privileges and run the test program using the sample **runtest.bat** script. It starts the HPC driver, executes the test program and finally stops the driver. 

	```bash
		runtest.bat
	```

**Output:** HPC output is logged in the file specified as **LOG_FILE** at compile time. 


Output:
--------------------------------
The output comprises of collection of samples. 
- Each sample contains the measurement of 7 events -- 3 fixed and 4 programmable/configurable events.
- 3 Fixed events: No. of instructions retired, logical cycles, reference cycles
- 4 programmable events: No. of branches retired, mis-predicted branches retired, LLC cache references, LLC misses. 
- The four programmable events can be changed to address various profiling goals. However, changing the events measured requires re-compiling the kernel driver. 
- The data collected using the performance counters is written to a file in a comma separated value (CSV) format. The order of the fields is as follows:
	
	```bash	
		#instructions retired, #logical-cycles, #reference-cycles, #event0, #event1, #event2, #event3
	```
- In the sampling mode, a data point is generated every **pmiThreshold** instructions retired.
- In the polling mode there is only one data point collected after the second instrumentation trigger is invoked. 

Cite as:
--------------------------------
**If you use this tool, please cite as:**

*Das, S., Werner, J., Antonakakis, M., Polychronakis, M. and Monrose, F., 2019, May. SoK: The Challenges, Pitfalls, and Perils of Using Hardware Performance Counters for Security. To appear in Proceedings of the 40th IEEE Symposium on Security and Privacy (S&P).*
```

`benchmarks/README.md`:

```md

This package consists of 20 variants of the original **rep stosb** program that was used by [Weaver & McKee](https://github.com/deater/deterministic/blob/master/static/sample_code/). These benchmarks comprise all 10 string operations, which include one-byte instructions (lodsb, stosb, movsb, scasb, cmpsb) and two-byte instructions (lodsw, stosw, movsw, scasw, cmpsw). These instructions perform load, store, copy, scan, and comparison operations. Each of these variants executes one string operation 1 million times. 

## Requirements: 
- Runs on Linux OS. 
- AS - GNU assembler

## How to build:
- To build an individual program e.g., **rep_stosb.s**

```bash
  as -o $rep_stosb.o $rep_stosb.s
  ld -o $rep_stosb $rep_stosb.o
```
- Run **build.sh** to compile all the programs.
```

`benchmarks/build.sh`:

```sh
!/bin/bash

declare -a arr=("rep_lodsb" "rep_stosb" "rep_cmpsb" "rep_movsb" "rep_scasb" "loop_lodsb" "loop_stosb" "loop_cmpsb" "loop_movsb" "loop_scasb" "rep_lodsw" "rep_stosw" "rep_cmpsw" "rep_movsw" "rep_scasw" "loop_lodsw" "loop_stosw" "loop_cmpsw" "loop_movsw" "loop_scasw")

for i in "${arr[@]}"
do
	#compilation-commands
	as -o $i.o $i.s
	ld -o $i $i.o
done

```

`benchmarks/loop_cmpsb.s`:

```s
# Million loop
#
# See how the loop prefix affects retired instructions and branches for cmpsb

# For x86_64

	.globl _start
_start:
		xor	%rcx,%rcx	        # rcx = 0
		mov	$1000000,%rcx		# load counter using rcx
		mov	$buffer1,%rsi
		mov	$buffer,%rdi
	mov_loop:
		cmpsb
		loop mov_loop	        # executed 1 million times
	#================================
	# Exit
	#================================
exit:
		xor     %rdi,%rdi		# return 0
		mov	$60,%rax		    # SYSCALL_EXIT
		nop
		syscall	            	# exit

		.bss
		.lcomm buffer,1000000
		.lcomm buffer1,1000000

```

`benchmarks/loop_cmpsw.s`:

```s
# Million loop
#
# See how the loop prefix affects retired instructions and branches for cmpsw

# For x86_64

	.globl _start
_start:
		xor	%rcx,%rcx	        # rcx = 0
		mov	$1000000,%rcx		# load counter using rcx
		mov	$buffer1,%rsi
		mov	$buffer,%rdi
	mov_loop:
		cmpsw
		loop mov_loop	        # executed 1 million times
	#================================
	# Exit
	#================================
exit:
		xor     %rdi,%rdi		# return 0
		mov	$60,%rax		    # SYSCALL_EXIT
		nop
		syscall	             	# exit

		.bss
		.lcomm buffer,2000000
		.lcomm buffer1,2000000

```

`benchmarks/loop_lodsb.s`:

```s
# Million loop
#
# See how the loop prefix affects retired instructions and branches for lodsb

# For x86_64

	.globl _start
_start:
	xor	%rcx,%rcx		    # rcx = 0
	mov	$1000000,%rcx		# load counter using rcx
	mov	$buffer,%rsi        # source string
mov_loop:	
	lodsb
	loop mov_loop           # executed 1 million times
	#================================
	# Exit
	#================================
exit:
	xor     %rdi,%rdi		# return 0
	mov	$60,%rax		    # SYSCALL_EXIT
	nop
	syscall	             	# exit

.bss
.lcomm  buffer,1000000

```

`benchmarks/loop_lodsw.s`:

```s
# Million loop
#
# See how the loop prefix affects retired instructions and branches for lodsw

# For x86_64

	.globl _start
_start:
	xor	%rcx,%rcx		    # rcx = 0
	mov	$1000000,%rcx		# load counter using rcx
    mov $buffer,%rsi        # source string
mov_loop:
	lodsw
	loop mov_loop           # executed 1 million times
	#================================
	# Exit
	#================================
exit:
	xor %rdi,%rdi		# return 0
	mov	$60,%rax		# SYSCALL_EXIT
	nop
	syscall	        	# exit

.bss
.lcomm  buffer,2000000

```

`benchmarks/loop_movsb.s`:

```s
# Million loop
#
# See how the loop prefix affects retired instructions and branches for movsb

# For x86_64

	.globl _start
_start:
		xor	%rcx,%rcx		    # rcx = 0
		mov	$1000000,%rcx		# load counter using rcx
		mov	$buffer1,%rsi
		mov	$buffer,%rdi
moving_loop:
		movsb
	    loop moving_loop        # executed 1 million times
	#================================
	# Exit
	#================================
exit:
		xor %rdi,%rdi		# return 0
		mov	$60,%rax		# SYSCALL_EXIT
		nop
		syscall	            # exit

		.bss
		.lcomm buffer,1000000
		.lcomm buffer1,1000000

```

`benchmarks/loop_movsw.s`:

```s
# Million loop
#
# See how the loop prefix affects retired instructions and branches for movsw

# For x86_64

	.globl _start
_start:
		xor	%rcx,%rcx		    # rcx = 0
		mov	$1000000,%rcx		# load counter using rcx
		mov	$buffer1,%rsi
		mov	$buffer,%rdi
moving_loop:
		movsw
	    loop moving_loop        # executed 1 million times
	#================================
	# Exit
	#================================
exit:
		xor     %rdi,%rdi		# return 0
		mov	$60,%rax		    # SYSCALL_EXIT
		nop
		syscall	             	# exit

		.bss
		.lcomm buffer,2000000
		.lcomm buffer1,2000000

```

`benchmarks/loop_scasb.s`:

```s
# Million loop
#
# See how the loop prefix affects retired instructions and branches for scasb

# For x86_64

	.globl _start
_start:
	xor	%rcx,%rcx		    # rcx = 0
	mov	$1000000,%rcx		# load counter using rcx
	mov	$buffer,%rdi
mov_loop:
	scasb
	loop mov_loop           # executed 1 million times
	#================================
	# Exit
	#================================
exit:
	xor %rdi,%rdi		    # return 0
	mov	$60,%rax		    # SYSCALL_EXIT
	nop
	syscall	             	# exit

.bss
.lcomm 	buffer,1000000

```

`benchmarks/loop_scasw.s`:

```s
# Million loop
#
# See how the loop prefix affects retired instructions and branches for scasw

# For x86_64

	.globl _start
_start:
	xor	%rcx,%rcx		    # rcx = 0
	mov	$1000000,%rcx		# load counter using rcx
	mov	$buffer,%rdi
mov_loop:
	scasw
	loop mov_loop           # executed 1 million times
	#================================
	# Exit
	#================================
exit:
	xor     %rdi,%rdi		# return 0
	mov	$60,%rax		    # SYSCALL_EXIT
	nop
	syscall	             	# exit

.bss
.lcomm 	buffer,2000000

```

`benchmarks/loop_stosb.s`:

```s
# Million loop
#
# See how the loop prefix affects retired instructions and branches for stosb

# For x86_64

	.globl _start
_start:
		xor	%rcx,%rcx		    # rcx = 0
		mov	$1000000,%rcx	    # load counter using rcx
        mov	$buffer,%rdi        # destination string
moving_loop:
		stosb
	    loop moving_loop        # executed 1 million times
	#================================
	# Exit
	#================================
exit:
		xor %rdi,%rdi		    # return 0
		mov	$60,%rax		    # SYSCALL_EXIT
		nop
		syscall	                # exit

		.bss
		.lcomm buffer,1000000

```

`benchmarks/loop_stosw.s`:

```s
# Million loop
#
# See how the loop prefix affects retired instructions and branches for stosw

# For x86_64

	.globl _start
_start:
		xor	%rcx,%rcx		    # rcx = 0
		mov	$1000000,%rcx		# load counter using rcx
        mov	$buffer,%rdi        # destination string
moving_loop:
		stosw
	    loop moving_loop        # executed 1 million times
	#================================
	# Exit
	#================================
exit:
		xor %rdi,%rdi		# return 0
		mov	$60,%rax		# SYSCALL_EXIT
		nop
		syscall	            # exit

		.bss
		.lcomm buffer,2000000

```

`benchmarks/rep_cmpsb.s`:

```s
# Million reps
#
# See how the rep prefix affects retired instructions and branches for cmpsb

# For x86_64

	.globl _start
_start:
		xor	%rcx,%rcx		    # rcx = 0
		mov	$1000000,%rcx		# load counter using rcx
		mov	$buffer1,%rsi
		mov	$buffer,%rdi
	  	rep cmpsb               # executed 1 million times
	#================================
	# Exit
	#================================
exit:
		xor %rdi,%rdi		    # return 0
		mov	$60,%rax		    # SYSCALL_EXIT
		nop
		syscall	             	# exit

		.bss
		.lcomm buffer,1000000
		.lcomm buffer1,1000000

```

`benchmarks/rep_cmpsw.s`:

```s
# Million reps
#
# See how the rep prefix affects retired instructions and branches for cmpsw

# For x86_64

	.globl _start
_start:
		xor	%rcx,%rcx		    # rcx = 0
		mov	$1000000,%rcx		# load counter using rcx
		mov	$buffer1,%rsi
		mov	$buffer,%rdi
	  	rep cmpsw               # executed 1 million times
	#================================
	# Exit
	#================================
exit:
		xor %rdi,%rdi		# return 0
		mov	$60,%rax		# SYSCALL_EXIT
        nop
		syscall	            # exit

		.bss
		.lcomm buffer,2000000
		.lcomm buffer1,2000000

```

`benchmarks/rep_lodsb.s`:

```s
# Million reps
#
# See how the rep prefix affects retired instructions and branches for lodsb

# For x86_64

	.globl _start
_start:
	xor	%rcx,%rcx		    # rcx = 0
	mov	$1000000,%rcx		# load counter using rcx
    mov	$buffer,%rsi        # source string
	rep	lodsb               # executed 1 million times

	#================================
	# Exit
	#================================
exit:
	xor %rdi,%rdi		# return 0
	mov	$60,%rax		# SYSCALL_EXIT
	nop
	syscall	            # exit

.bss
.lcomm 	buffer,1000000

```

`benchmarks/rep_lodsw.s`:

```s
# Million reps
#
# See how the rep prefix affects retired instructions and branches for lodsw

# For x86_64

	.globl _start
_start:
	xor	%rcx,%rcx		    # rcx = 0
	mov	$1000000,%rcx		# load counter using rcx
	mov	$buffer,%rsi        # source string
	rep	lodsw               # executed 1 million times

	#================================
	# Exit
	#================================
exit:
	xor %rdi,%rdi		# return 0
	mov	$60,%rax		# SYSCALL_EXIT
	nop
	syscall	            # exit

.bss
.lcomm 	buffer,2000000

```

`benchmarks/rep_movsb.s`:

```s
# Million reps
#
# See how the rep prefix affects retired instructions and branches for movsb

# For x86_64

	.globl _start
_start:
		xor	%rcx,%rcx		    # rcx = 0
		mov	$1000000,%rcx	    # load counter using rcx
		mov	$buffer1,%rsi
		mov	$buffer,%rdi
		rep movsb               # executed 1 million times
	#================================
	# Exit
	#================================
exit:
		xor %rdi,%rdi	        # return 0
		mov	$60,%rax		    # SYSCALL_EXIT
		nop
		syscall	                # exit

		.bss
		.lcomm buffer,1000000
		.lcomm buffer1,1000000

```

`benchmarks/rep_movsw.s`:

```s
# Million reps
#
# See how the rep prefix affects retired instructions and branches for movsw

# For x86_64

	.globl _start
_start:
		xor	%rcx,%rcx		    # rcx = 0
		mov	$1000000,%rcx		# load counter using rcx
		mov	$buffer1,%rsi
		mov	$buffer,%rdi
		rep movsw               # executed 1 million times
	#================================
	# Exit
	#================================
exit:
		xor %rdi,%rdi		# return 0
		mov	$60,%rax		# SYSCALL_EXIT
		nop
		syscall	            # exit

		.bss
		.lcomm buffer,2000000
		.lcomm buffer1,2000000

```

`benchmarks/rep_scasb.s`:

```s
# Million reps
#
# See how the rep prefix affects retired instructions and branches for scasb

# For x86_64

	.globl _start
_start:
	xor	%rcx,%rcx		    # rcx = 0
	mov	$1000000,%rcx		# load counter using rcx
    mov	$buffer,%rdi        
	rep	scasb               # executed 1 million times

	#================================
	# Exit
	#================================
exit:
	xor %rdi,%rdi		    # return 0
	mov	$60,%rax		    # SYSCALL_EXIT
	nop				        
	syscall	             	# exit

.bss
.lcomm 	buffer,1000000

```

`benchmarks/rep_scasw.s`:

```s
# Million reps
#
# See how the rep prefix affects retired instructions and branches for scasw

# For x86_64

	.globl _start
_start:
	xor	%rcx,%rcx		    # rcx = 0
	mov	$1000000,%rcx		# load counter using rcx
	mov	$buffer,%rdi        
	rep	scasw               # executed 1 million times

	#================================
	# Exit
	#================================
exit:
	xor %rdi,%rdi		    # return 0
	mov	$60,%rax		    # SYSCALL_EXIT
	nop				        
	syscall	             	# exit

.bss
.lcomm 	buffer,2000000

```

`benchmarks/rep_stosb.s`:

```s
# Million reps
#
# See how the rep prefix affects retired instructions and branches for stosb

# For x86_64

 .globl _start
_start:
  xor  %rcx,%rcx        # rcx = 0
  mov  $1000000,%rcx    # load counter using rcx
  mov  $buffer,%rdi     # destination string
  rep  stosb	        # executed 1 million times

#================================
# Exit
#================================
exit:
  xor  %rdi,%rdi     # return 0
  mov  $60,%rax	     # SYSCALL_EXIT
  nop		        
  syscall	         # exit

.bss
.lcomm 	buffer,1000000

```

`benchmarks/rep_stosw.s`:

```s
# Million reps
#
# See how the rep prefix affects retired instructions and branches for stosw

# For x86_64

	.globl _start
_start:
	xor	%rcx,%rcx		    # rcx = 0
	mov	$1000000,%rcx		# load counter using rcx
	mov	$buffer,%rdi        # destination string
	rep	stosw               # executed 1 million times

	#================================
	# Exit
	#================================
exit:
	xor %rdi,%rdi		    # return 0
	mov	$60,%rax		    # SYSCALL_EXIT
	nop				        
	syscall	             	# exit

.bss
.lcomm 	buffer,2000000

```

`builddrv.bat`:

```bat
@echo on

:: build the driver and move it into win driver dir
cd drv
build
copy objchk_win7_x86\i386\HPCTestDrv.sys C:\Windows\System32\drivers
cd ..\
```

`drv/HPCTestDrv.c`:

```c

/*
* Copyright University of North Carolina, 2018
* Author: Sanjeev Das (sdas@cs.unc.edu)
*
* The context switch hooking part of the code is obtained from 
* https://github.com/SouhailHammou/Drivers/blob/master/SwapContextHook/swapcontext_hook.c
*
*/

#include <ntifs.h>
#include <wdm.h>
#include <Ntstrsafe.h>


/***************Configurable parameters***********************/

//a) Choose mode either as SAMPLING_MODE or POLLING_MODE
#define SAMPLING_MODE	// SAMPLING_MODE or POLLING_MODE

#ifdef SAMPLING_MODE
	//b) set threshold value for PMI
	INT32 pmiThreshold = -50000;
#else
	//polling mode
	//b) set threshold as 0
	INT32 pmiThreshold = 0;
#endif

//c) Test process/application that has to be monitored
#define TEST_APP "test.exe"

//d) change output file path
#define LOG_FILE L"\\DosDevices\\C:\\Users\\Sanjeev\\Desktop\\hpcoutput.csv"

//Configure HPC events to monitor userspace events
#define EVENT0	0x004100C4 		//Branch instruction retired
#define EVENT1	0x004100C5  	//Mispredicted branch instructions
#define EVENT2	0x00414F2E 		//LLC cache reference
#define EVENT3	0x0041412E 		//LLC misses

//maximum number of PMI that can be recorded, depends on how much memory can be used by Win kernel driver
#define MAXVAL 1000000

//buffer size required for writing/reading into the file
#define BUFFER_SIZE 500

/************************************************************/


/* Windows OS Function Prototypes for KMDF */
NTSTATUS MyDriverUnsupportedFunction(PDEVICE_OBJECT DeviceObject, PIRP Irp);
DRIVER_UNLOAD MyDriverUnload;
VOID MyDriverUnload(PDRIVER_OBJECT  DriverObject);
NTSTATUS DriverEntry(PDRIVER_OBJECT  pDriverObject, PUNICODE_STRING  pRegistryPath);
NTKERNELAPI void KiDispatchInterrupt(void);


typedef unsigned short	WORD;
typedef unsigned char	BYTE;
typedef unsigned long	ULONG;

#define SIOCTL_TYPE 40000
#define IOCTL_HELLO\
 CTL_CODE( SIOCTL_TYPE, 0x800, METHOD_BUFFERED, FILE_READ_DATA|FILE_WRITE_DATA)

/* Compile directives. */
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, MyDriverUnload)
#pragma alloc_text(PAGE, MyDriverUnsupportedFunction)

#pragma pack(1)
typedef struct _DESC {
  UINT16 offset00;
  UINT16 segsel;
  CHAR unused:5;
  CHAR zeros:3;
  CHAR type:5;
  CHAR DPL:2;
  CHAR P:1;
  UINT16 offset16;
} DESC, *PDESC;
#pragma pack()

#pragma pack(1)
typedef struct _IDTR {
  UINT16 bytes;
  UINT32 addr;
} IDTR;
#pragma pack()

PIO_STACK_LOCATION irpSp;

/* Global variable for storing old ISR address. */
UINT32 oldISRAddressPmi = NULL;
UINT32 oldISRAddressTrap = NULL;



//some flags used for logic
int IsHpcStoredAtContextSwitch = 0;
int IsTestAppRunning = 0; 
int IsCurrentProcessTestApp = 0; 	

int trapCount = 0;					// counts number of "int 2e" in source code 
int perfCounterId = 0; 				// identifies the counter of the 7 HPCs.
int hpcCount = 0; 					// no. of times record were taken

//64 bit is required for recording counter values: ecx.eax
UINT64 hpcData[7][MAXVAL+1];

//Used to store/restore values at context switch
UINT32  counter0LowVal = 0, counter0HighVal = 0, counter1LowVal = 0, counter1HighVal = 0, \
counter2LowVal = 0, counter2HighVal = 0, counter3LowVal = 0, counter3HighVal = 0, \
counter4LowVal = 0, counter4HighVal = 0, counter5LowVal = 0, counter5HighVal = 0, \
counter6LowVal = 0, counter6HighVal = 0;
 

void InitializeCounters();
void WriteMSR(int lowVal, int highVal, int addr);
INT64 ReadMSR(int addr);  
void RecordHPC(int addr);
void RecordFinalSample(int lowVal, int highVal);

/*
*	log HPC counter values in an output file;
*/
int LogHPCData(){
	UNICODE_STRING uniName;
	OBJECT_ATTRIBUTES objAttr;
	HANDLE handle;
	NTSTATUS ntStatus;
	IO_STATUS_BLOCK ioStatusBlock;
	CHAR buffer[BUFFER_SIZE];
	size_t cb;
	int i = 0;

	RtlInitUnicodeString(&uniName, LOG_FILE);
	InitializeObjectAttributes(&objAttr, &uniName,OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);

	// Do not try to perform any file operations at higher IRQL levels.
	if(KeGetCurrentIrql() != PASSIVE_LEVEL)
		return STATUS_INVALID_DEVICE_STATE;

	//creates an output file
	ntStatus = ZwCreateFile(&handle,GENERIC_WRITE,&objAttr, &ioStatusBlock, NULL,FILE_ATTRIBUTE_NORMAL, 0,FILE_OVERWRITE_IF,FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0);

	//write recorded HPC values into an output file
	if(NT_SUCCESS(ntStatus)){
		ntStatus = RtlStringCbPrintfA(buffer, sizeof(buffer),"ins,l_cycle,ref_cycle,event1,event2,event3,event4\r\n");
		if(NT_SUCCESS(ntStatus)) {
			ntStatus = RtlStringCbLengthA(buffer, sizeof(buffer), &cb);
			if(NT_SUCCESS(ntStatus)) {
				ntStatus = ZwWriteFile(handle, NULL, NULL, NULL, &ioStatusBlock, buffer, cb, NULL, NULL);
			}
		}
		for(i=0; i<hpcCount; i++){
			ntStatus = RtlStringCbPrintfA(buffer, sizeof(buffer),"%llu,%llu,%llu,%llu,%llu,%llu,%llu\r\n", hpcData[0][i],hpcData[1][i],hpcData[2][i],hpcData[3][i],hpcData[4][i],hpcData[5][i],hpcData[6][i]);
			if(NT_SUCCESS(ntStatus)) {
				ntStatus = RtlStringCbLengthA(buffer, sizeof(buffer), &cb);
				if(NT_SUCCESS(ntStatus)) {
					ntStatus = ZwWriteFile(handle, NULL, NULL, NULL, &ioStatusBlock, buffer, cb, NULL, NULL);
				}
			}
		}
		ZwClose(handle);
	}
	return 1;
 }

/*
 * Get the address of IDT table.
 */
IDTR GetIDTAddress() {
    IDTR idtrAddr;
  /* get address of the IDT table */
    __asm {
        cli;
		sidt idtrAddr;
		sti;
    }
  DbgPrint("Address of IDT table is: %x.\r\n", idtrAddr.addr);
  return idtrAddr;
}

/*
 * Get the address of the service descriptor.
 */
PDESC GetDescriptorAddress(UINT16 service) {
  /* allocate local variables */
  IDTR idtrAddr; 
  PDESC descAddr; 

  idtrAddr = GetIDTAddress();

  /* get the address of the interrupt entry we would like to hook */
  descAddr = idtrAddr.addr + service * 0x8;
  DbgPrint("Address of IDT Entry is: %x.\r\n", descAddr);

  return descAddr;
}

/*
 * Get the ISR address.
 */
UINT32 GetISRAddress(UINT16 service) {
  PDESC descAddr; 
  UINT32 isrAddr; 

  descAddr  = GetDescriptorAddress(service);

  /* calculate address of ISR from offset00 and offset16 */
  isrAddr = descAddr->offset16;
  isrAddr = isrAddr << 16;
  isrAddr += descAddr->offset00;
  DbgPrint("Address of the ISR is: %x.\r\n", isrAddr);

  /* store old ISR address in global variable, so we can use it later */
  if (service == 0xfe)
	oldISRAddressPmi = isrAddr;
  else
	oldISRAddressTrap = isrAddr;

  return isrAddr;
}

/*
 * Records HPC data
 */
void RecordHPCSample(INT64 combinedVal) {
	
	if(perfCounterId == 0){
		#ifdef SAMPLING_MODE
			hpcData[perfCounterId][hpcCount] = abs((INT32)pmiThreshold-combinedVal);
		#else
			hpcData[perfCounterId][hpcCount] = combinedVal;
		#endif
	}else{
		hpcData[perfCounterId][hpcCount] = combinedVal;	
	}
	perfCounterId++;
}

/*
 * Hook function for software interrupt only
 */
__declspec(naked) HookTrap() {
	__asm {
	//save the context of hardware interrupt
		pushfd
		pushad
		push fs
		push ds
		push es
	}

	trapCount++;
	if (trapCount == 2){
		perfCounterId = 0;
		RecordHPC(0x309);
		RecordHPC(0x30A);
		RecordHPC(0x30B);
		RecordHPC(0xC1);
		RecordHPC(0xC2);
		RecordHPC(0xC3);
		RecordHPC(0xC4);
		hpcCount++;
	}

	//zero out counters
	WriteMSR(0x00000000, 0x00000000, 0x309);
	WriteMSR(0x00000000, 0x00000000, 0x30A);
	WriteMSR(0x00000000, 0x00000000, 0x30B);
	WriteMSR(0x00000000, 0x00000000, 0xC1);
	WriteMSR(0x00000000, 0x00000000, 0xC2);
	WriteMSR(0x00000000, 0x00000000, 0xC3);
	WriteMSR(0x00000000, 0x00000000, 0xC4);

	__asm{
	//Retrieve the context of hardware interrupt
		pop es
		pop ds
		pop fs
		popad
		popfd
		jmp oldISRAddressTrap
	}
}

/*
 * Record HPC values at PMI
 */
__declspec(naked) HookPMI() {
	__asm {
	//save the context of hardware interrupt
		pushfd
		pushad
		push fs
		push ds
		push es
	}

	if(IsCurrentProcessTestApp==1 && hpcCount<=MAXVAL){
		perfCounterId = 0;
		RecordHPC(0x309);
		RecordHPC(0x30A);
		RecordHPC(0x30B);
		RecordHPC(0xC1);
		RecordHPC(0xC2);
		RecordHPC(0xC3);
		RecordHPC(0xC4);
		hpcCount++;
	}

	//set threshold for fixed_ctr0
	WriteMSR(pmiThreshold, 0x0000FFFF, 0x309);

	//Zero out remaining counters
	WriteMSR(0x00000000, 0x00000000, 0x30A);
	WriteMSR(0x00000000, 0x00000000, 0x30B);
	WriteMSR(0x00000000, 0x00000000, 0xC1);
	WriteMSR(0x00000000, 0x00000000, 0xC2);
	WriteMSR(0x00000000, 0x00000000, 0xC3);
	WriteMSR(0x00000000, 0x00000000, 0xC4);

	//Clear the overflow flag via IA32_PERF_GLOBAL_OVF_CTRL MSR
	WriteMSR(0x00000000, 0x00000001, 0x390);

	__asm{
		//Retrieve the context of hardware interrupt
		pop es
		pop ds
		pop fs
		popad
		popfd

		//jump to original OS handler
		jmp oldISRAddressPmi
	}
}

/*
 * Hook the interrupt descriptor by overwriting its ISR pointer.
 */
void HookISR(UINT16 service, UINT32 hookaddr) {
  UINT32 isrAddr; 
  UINT16 hookAddrLow;
  UINT16 hookAddrHigh;
  PDESC descAddr;

  /* check if the ISR was already hooked */
  isrAddr = GetISRAddress(service);
  if(isrAddr == hookaddr) {
    DbgPrint("The service %x already hooked.\r\n", service);
  } else {
    DbgPrint("Hooking interrupt %x: ISR %x --> %x.\r\n", service, isrAddr, hookaddr);
    descAddr  = GetDescriptorAddress(service);
    DbgPrint("Hook Address: %x\r\n", hookaddr);
    hookAddrLow = (UINT16)hookaddr;
    hookaddr = hookaddr >> 16;
    hookAddrHigh = (UINT16)hookaddr;
    DbgPrint("descAddr: %x\r\n", descAddr->offset00);
    DbgPrint("descAddr: %x\r\n", descAddr->offset16);

    __asm { cli }
    descAddr->offset00 = hookAddrLow;
    descAddr->offset16 = hookAddrHigh;
    __asm { sti }
  }
}

/*
	Find a relevant process and re/store performance counter values
*/
void SaveRestoreCounters(){
	PUCHAR pKTHREADCurr, pKTHREADNext;
	PUCHAR ProcessCurr, ProcessNext;
	PUCHAR ImageFileNameCurr, ImageFileNameNext;

	//check the exiting process and store HPC values if it is our test process
	//edi: points to the exiting thread
	//esi: points to the incoming thread

	__asm{
		// obtain exiting process
		mov pKTHREADCurr, edi
		mov ecx, CR3;
	}
	ProcessCurr = *(PUCHAR*)(pKTHREADCurr + 0x50);
	ImageFileNameCurr = (PUCHAR)ExAllocatePoolWithTag(NonPagedPool,16,'Hbf1');
	if(ImageFileNameCurr != NULL){
		/*Copy the image name to an allocated space*/
		strncpy((char*)ImageFileNameCurr,(char*)(ProcessCurr+0x16c), 16);

		//If the exiting process is a test process, we store the performance counter values
		if(!strcmp((char*)ImageFileNameCurr, TEST_APP)){

			__asm{
			//Store HPC values into memory
				mov ecx, 0x309
				rdmsr
				mov counter0LowVal, eax
				mov counter0HighVal, edx

				mov ecx, 0x30A
				rdmsr
				mov counter1LowVal, eax
				mov counter1HighVal, edx

				mov ecx, 0x30B
				rdmsr
				mov counter2LowVal, eax
				mov counter2HighVal, edx

				mov ecx, 0xC1
				rdmsr
				mov counter3LowVal, eax
				mov counter3HighVal, edx

				mov ecx, 0xC2
				rdmsr
				mov counter4LowVal, eax
				mov counter4HighVal, edx

				mov ecx, 0xC3
				rdmsr
				mov counter5LowVal, eax
				mov counter5HighVal, edx

				mov ecx, 0xC4
				rdmsr
				mov counter6LowVal, eax
				mov counter6HighVal, edx

				mov ecx, 1
				mov IsHpcStoredAtContextSwitch, ecx

			}
		}
	}else{
			goto TestRegistrycleanup;
	}

	//check the incoming process and restore HPC values if the process is our test process
	__asm{
		mov pKTHREADNext, esi
	}
	ProcessNext = *(PUCHAR*)(pKTHREADNext + 0x50);
	ImageFileNameNext = (PUCHAR)ExAllocatePoolWithTag(NonPagedPool,16, 'Hbf2');
	if(ImageFileNameNext != NULL){
		strncpy((char*)ImageFileNameNext,(char*)(ProcessNext+0x16c), 16);

		if(!strcmp((char*)ImageFileNameNext,TEST_APP)){
			if(IsTestAppRunning==0){
				//If the test process is going to run for the first time, start HPC monitoring
				IsTestAppRunning=1;
				InitializeCounters();
			}
			IsCurrentProcessTestApp = 1;	//indicates that the current process is a test process

			if (IsHpcStoredAtContextSwitch==1){
				IsHpcStoredAtContextSwitch=0;
				WriteMSR(counter0LowVal, counter0HighVal, 0x309);
				WriteMSR(counter1LowVal, counter1HighVal, 0x30A);
				WriteMSR(counter2LowVal, counter2HighVal, 0x30B);
				WriteMSR(counter3LowVal, counter3HighVal, 0xC1);
				WriteMSR(counter4LowVal, counter4HighVal, 0xC2);
				WriteMSR(counter5LowVal, counter5HighVal, 0xC3);
				WriteMSR(counter6LowVal, counter6HighVal, 0xC4);
			}

		}
		else
			IsCurrentProcessTestApp = 0;
	}
	else{
			goto TestRegistrycleanup;
	}

	//free runtime memory
	TestRegistrycleanup:
		if(ImageFileNameCurr != NULL)
			ExFreePoolWithTag(ImageFileNameCurr, 'Hbf1');
		if(ImageFileNameNext != NULL)
			ExFreePoolWithTag(ImageFileNameNext, 'Hbf2');

}

/*
	Re/store performance counter values at the context switches
*/
//__fastcall SwapContext(PKTHREAD CurrentThread,PKTHREAD NextThread)
__declspec(naked) void HooKCS(){
	SaveRestoreCounters();
	/*before jumping back execute the overwritten functions*/
	//807e3900        cmp     byte ptr [esi+39h],0
	//7404            je      nt!SwapContext+0xa (828bdaea)
	__asm{
			cmp byte ptr[esi+39h],0
			//je address , replaced in runtime
			_emit 0x0F
			_emit 0x84
		
			_emit 0xAA
			_emit 0xAA
			_emit 0xAA
			_emit 0xAA
			//jmp just after the patched bytes
			_emit 0xE9
			
			_emit 0xBB
			_emit 0xBB
			_emit 0xBB
			_emit 0xBB
	}
}

/*
	Read the leftover counter values of a process that were stored during context switch for the last PMI window
*/
void ReadFinalSample(){
 	__asm {

	//checkmaxval1:
	//don't exceed the maximum times that we can monitor; only required for offline analysis; limitation comes from how much data can a kernel driver hold
		mov ecx, hpcCount
		cmp ecx, MAXVAL
		jae terminateRead

	//restore values only when store has been done at context switch
		mov ecx, IsHpcStoredAtContextSwitch
		cmp ecx, 1
		jne terminateRead

	//readleftover:
		mov ecx, 0
		mov IsHpcStoredAtContextSwitch, ecx

		mov DWORD PTR [perfCounterId], 0

		mov eax, counter0LowVal
		mov edx, edx
		push edx
		push eax
		call RecordFinalSample

		mov eax, counter1LowVal
		mov edx, counter1HighVal
		push edx
		push eax
		call RecordFinalSample

		mov eax, counter2LowVal
		mov edx, counter2HighVal
		push edx
		push eax
		call RecordFinalSample

		mov eax, counter3LowVal
		mov edx, counter3HighVal
		push edx
		push eax
		call RecordFinalSample

		mov eax, counter4LowVal
		mov edx, counter4HighVal
		push edx
		push eax
		call RecordFinalSample

		mov eax, counter5LowVal
		mov edx, counter5HighVal
		push edx
		push eax
		call RecordFinalSample

		mov eax, counter6LowVal
		mov edx, counter6HighVal
		push edx
		push eax
		call RecordFinalSample

		inc DWORD PTR [hpcCount] 	//counts the no. of times reading were taken

	terminateRead:

	}
}

/*
* Write into MSR registers
*/
void WriteMSR(int lowVal, int highVal, int addr){
	__asm{
		mov eax, lowVal
		mov edx, highVal
		mov ecx, addr
		wrmsr
	}
}

/*
* Record HPC value, and store the HPC count into array
*/
void RecordHPC(int addr){
	INT64 combinedVal = 0;
	combinedVal = ReadMSR(addr);
	RecordHPCSample(combinedVal);
}

/*
* Extract 48-bit counter value
*/
INT64 Extract48BitVal(int lowVal, int highVal){
	INT64 combinedHPCVal = 0;
	combinedHPCVal = (0x0000ffff & highVal);
	combinedHPCVal <<= 32;
	combinedHPCVal = combinedHPCVal + lowVal;
	return combinedHPCVal;
}

/*
* Store HPC values for final sample into array
*/
void RecordFinalSample(int lowVal, int highVal){
	INT64 combinedVal = 0;
	combinedVal = Extract48BitVal(lowVal, highVal);
	RecordHPCSample(combinedVal);
}
	
/*
* Read MSR registers
*/
INT64 ReadMSR(int addr){
	int lowVal = 0, highVal = 0; 
	INT64 combinedVal = 0;
	
	__asm{
		mov ecx, addr
		rdmsr
		mov lowVal, eax
		mov highVal, edx
	}
	combinedVal = Extract48BitVal(lowVal, highVal);
	return combinedVal;
}

/*
* initializatizing HPCs
*/
void InitializeCounters(){
	#ifdef SAMPLING_MODE	
		WriteMSR(0x0000022A, 0x00000000, 0x38D);
		WriteMSR(pmiThreshold, 0x0000FFFF, 0x309);
	#else			// polling_mode
		WriteMSR(0x00000222, 0x00000000, 0x38D);
		WriteMSR(0x00000000, 0x00000000, 0x309);
	#endif
	
	//Configure programmable counters for different events
	WriteMSR(EVENT0, 0x00000000, 0x186);
	WriteMSR(EVENT1, 0x00000000, 0x187);
	WriteMSR(EVENT2, 0x00000000, 0x188);
	WriteMSR(EVENT3, 0x00000000, 0x189);

	//Zero out remaining counters
	WriteMSR(0x00000000, 0x00000000, 0x30A);
	WriteMSR(0x00000000, 0x00000000, 0x30B);

	WriteMSR(0x00000000, 0x00000000, 0xC1);
	WriteMSR(0x00000000, 0x00000000, 0xC2);
	WriteMSR(0x00000000, 0x00000000, 0xC3);
	WriteMSR(0x00000000, 0x00000000, 0xC4);

	WriteMSR(0x0000000F, 0x00000007, 0x38F); //Enable counter globally - IA32_PERF_GLOBAL_CTRL MSR

}

/*
 * DriverEntry: entry point for drivers.
 */
NTSTATUS DriverEntry(PDRIVER_OBJECT  pDriverObject, PUNICODE_STRING  pRegistryPath) {
    NTSTATUS NtStatus = STATUS_SUCCESS;
    unsigned int uiIndex = 0;
    PDEVICE_OBJECT pDeviceObject = NULL;
    UNICODE_STRING usDriverName, usDosDeviceName;

	//-----------
	char detourBytes[] = {0xe9,0xaa,0xbb,0xcc,0xdd,0x90};	//jmp loc_ddccbbaa; nop
	unsigned int savedCR0;
	KIRQL Irql;
	int i;

	/*KiDispatchInterrupt is exported*/
	//obtain address of SwapContext using KiDispatchInterrupt
	
	PUCHAR p = (PUCHAR)KiDispatchInterrupt;
	unsigned int relative = *(unsigned int*)(p + 0xDE);   
	PUCHAR SwapContext = (PUCHAR)((unsigned int)(p + 0xDD) + relative + 5); //pointer -> SwapContext
	PUCHAR det =  (PUCHAR)HooKCS; //detour to -> HookCS
	//-----------
    
	DbgPrint("DriverEntry Called \r\n");
    RtlInitUnicodeString(&usDriverName, L"\\Device\\MyDriver");
    RtlInitUnicodeString(&usDosDeviceName, L"\\DosDevices\\MyDriver");

    NtStatus = IoCreateDevice(pDriverObject, 0, &usDriverName, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &pDeviceObject);

    if(NtStatus == STATUS_SUCCESS) {
        /* MajorFunction: is a list of function pointers for entry points into the driver. */
        for(uiIndex = 0; uiIndex < IRP_MJ_MAXIMUM_FUNCTION; uiIndex++)
             pDriverObject->MajorFunction[uiIndex] = MyDriverUnsupportedFunction;

		 /* DriverUnload is required to be able to dynamically unload the driver. */
		pDriverObject->DriverUnload =  MyDriverUnload;
		pDeviceObject->Flags |= 0;
		pDeviceObject->Flags &= (~DO_DEVICE_INITIALIZING);

		/* Create a Symbolic Link to the device. MyDriver -> \Device\MyDriver */
        IoCreateSymbolicLink(&usDosDeviceName, &usDriverName);
	}

	//------------Hook context switching-------------
	DbgPrint("KiSwapContext at : %p\n",SwapContext);
	
	/*Implement the inline hook*/
	relative = (unsigned int)HooKCS - (unsigned int)SwapContext - 5; 	//offset of HooKCS relative to SwapContext

	*(unsigned int*)&detourBytes[1] = relative; //set loc_ddccbbaf = offset -> HooKCS
	
	/*Disable write protection*/
	__asm{
		push eax
		mov eax,CR0
		mov savedCR0,eax
		and eax,0xFFFEFFFF
		mov CR0,eax
		pop eax
	}
	
	/*Set the detour function jump addresses in runtime*/
	for(i=0;;i++){
		if(det[i] == 0xAA && det[i+1] == 0xAA && det[i+2] == 0xAA && det[i+3] == 0xAA)
			break;
	}
	/*set the relative address for the conditional jump ()*/
	//je      nt!SwapContext+0xa
	*(unsigned int*)&det[i] = (unsigned int)((SwapContext+0xa) - (det+i-2) - 6);
	 
	
	/*set the relative address for the jump back to SwapContext*/
	for(;;i++){
		if(det[i] == 0xBB && det[i+1] == 0xBB && det[i+2] == 0xBB && det[i+3] == 0xBB)
			break;
	}
	//jmp SwapContext+6
	*(unsigned int*)&det[i] = (unsigned int)((SwapContext + 6) - (det+i-1) - 5);
	
	/*Raise IRQL to patch safely*/
	Irql = KeRaiseIrqlToDpcLevel();
	
	/*implement the patch*/
	for(i=0;i<6;i++){
		SwapContext[i] = detourBytes[i]; 	//jmp loc_ddccbbaf; nop
	}
	KeLowerIrql(Irql);
	
	/*restore the write protection*/
	__asm{
		push eax
		mov eax,savedCR0
		mov CR0,eax
		pop eax
	}
	//------------------------------------

	#ifdef SAMPLING_MODE
		
		// We hook the default PMI handling by OS using interrupt descriptor table. "0xFE" is vector for PMI.
		HookISR(0xfe, (UINT32)HookPMI);
	#else
		//Hook the software interrupt
		HookISR(0x2e, (UINT32)HookTrap);	//Also tested with "0x03" interrupt
	#endif

	return NtStatus;
}

/*
  * MyDriverUnload: called when the driver is unloaded.
  */
VOID MyDriverUnload(PDRIVER_OBJECT  DriverObject) {
	UNICODE_STRING usDosDeviceName;
	NTSTATUS NtStatus = STATUS_SUCCESS;
	int i=0;

	//---------For Hooking Context Switch---
	unsigned int savedCR0;
	KIRQL Irql;
	PUCHAR p = (PUCHAR)KiDispatchInterrupt;
	unsigned int relative = *(unsigned int*)(p + 0xDE);
	PUCHAR KiSwapContext = (PUCHAR)((unsigned int)(p+0xDD) + relative + 5);
	//807e3900        cmp     byte ptr [esi+39h],0
	//7404            je      nt!SwapContext+0xa (828bdaea)
	char savedOps[] = {0x80,0x7e,0x39,0x00,0x74,0x04};		//cmp byte ptr [esi+0x39], 0; je loc_0000000a
	//------------------------------

	//log the leftover counter values of a process that were stored during context switch for the last PMI window
	#ifdef SAMPLING_MODE
		ReadFinalSample();
	#endif


	#ifdef SAMPLING_MODE
		if(oldISRAddressPmi != NULL) {
			HookISR(0xfe, (UINT32)oldISRAddressPmi);
		}
	#else
		if(oldISRAddressTrap != NULL) {
			HookISR(0x2e, (UINT32)oldISRAddressTrap);	//also tested with other interrupts such as "0x03"
		}
	#endif
	//------------------------------
	
	/*Restore write protection*/
	__asm{
		push eax
		mov eax,CR0
		mov savedCR0,eax
		and eax,0xFFFEFFFF
		mov CR0,eax
		pop eax
	}
	Irql = KeRaiseIrqlToDpcLevel();
	for(i=0;i<6;i++){
		KiSwapContext[i] = savedOps[i];
	}
	KeLowerIrql(Irql);
	__asm{
		push eax
		mov eax,savedCR0
		mov CR0,eax
		pop eax
	}
	//------------Un-hooking context switch ends-------------

	/* delete the driver */
    RtlInitUnicodeString(&usDosDeviceName, L"\\DosDevices\\MyDriver");
    IoDeleteSymbolicLink(&usDosDeviceName);
    IoDeleteDevice(DriverObject->DeviceObject);

	//logs HPC data into output file
	LogHPCData();

}

/*
 * MyDriverUnsupportedFunction: called when a major function is issued that isn't supported.
 */
NTSTATUS MyDriverUnsupportedFunction(PDEVICE_OBJECT DeviceObject, PIRP Irp) {
    NTSTATUS NtStatus = STATUS_NOT_SUPPORTED;
	DbgPrint("MyDriverUnsupportedFunction Called \r\n");
    return NtStatus;
}

```

`drv/sources`:

```
TARGETNAME=HPCTestDrv
TARGETTYPE=DRIVER
SOURCES=HPCTestDrv.c

```

`output/hpcoutput-poll.csv`:

```csv
CSV Schema (1 sample row):
Headers: ins, l_cycle, ref_cycle, event1, event2, event3, event4
Sample: "7890", "0", "65550", "1777", "145", "2302", "1917"

```

`output/hpcoutput-sampl.csv`:

```csv
CSV Schema (1 sample row):
Headers: ins, l_cycle, ref_cycle, event1, event2, event3, event4
Sample: "50039", "0", "190500", "9803", "477", "4240", "1512"
... [48 more rows omitted]

```

`runtest.bat`:

```bat
@echo on

sc start HPCTestDrv
timeout 1

testcode\test.exe
timeout 5

sc stop HPCTestDrv
timeout 1
```

`testcode/test.c`:

```c
#include <stdio.h>
#include <windows.h>


void main()
{
	//Instrument to generate trap
	__asm __volatile {
		mov eax, 19h 
		int 0x2e
	}

	printf("Hello World!\n");
	printf("Good bye cruel world.\n");
	
	//Instrument to generate trap
	__asm __volatile{ 
		mov eax, 19h; 
		int 0x2e 
	}
}	


```

`tutorial/test.c`:

```c
//--------Matrix multiplication--------
#include<stdio.h>
#include <windows.h>

int main()
{
  int first[10][10], second[10][10], multiply[10][10];
  int m, n, p, q, c, d, k, sum;
  sum = 0, m = n = p = q = 10;

  //Instrument to generate software interrupt
	__asm __volatile{ 
		mov eax, 19h 
		int 0x2e 
	}
  
  for (c = 0; c < m; c++)
    for (d = 0; d < n; d++) {
        first[c][d]=2;
        second[d][c]=2;
      }
    for (c = 0; c < m; c++) {
      for (d = 0; d < q; d++) {
        for (k = 0; k < p; k++) {
          sum = sum + first[c][k]*second[k][d];
        }
         multiply[c][d] = sum;
        sum = 0;
      }
    }
    printf("Product of entered matrices:-\n");
     for (c = 0; c < m; c++) {
      for (d = 0; d < q; d++)
        printf("%d\t", multiply[d][c]);			
      printf("\n");
    }
  
  //Instrument to generate software interrupt
	__asm __volatile{ 
		mov eax, 19h 
		int 0x2e 
	}

  return 0;
}
```

`tutorial/tutorial.md`:

```md
Tutorial on Hardware Performance Counters
===========

# Introduction
In this tutorial you will learn how to use hardware performance counters.

# Motivation
Let's suppose you wrote a program and it correctly achieved the specific goal (i.e., it computes the expected value). However, you noticed that its execution is far slower than one would expect. You’ve spent several agonizing hours looking over the source code, but you are unable to determine the root cause. To that end, you’ve decided you need to look more closely at the program’s runtime performance to see what the bottlenecks might be. 

```bash
  //--------Matrix multiplication------//
  int main()
  {
    int first[10][10], second[10][10], multiply[10][10];
    int m, n, p, q, c, d, k, sum;
    sum = 0, m = n = p = q = 10;

    for (c = 0; c < m; c++)
      for (d = 0; d < n; d++) {
          first[c][d]=2;
          second[d][c]=2;
        }
      for (c = 0; c < m; c++) {
        for (d = 0; d < q; d++) {
          for (k = 0; k < p; k++) {
            sum = sum + first[c][k]*second[k][d];
          }
          multiply[c][d] = sum;
          sum = 0;
        }
      }
      printf("Product of entered matrices:-\n");
      for (c = 0; c < m; c++) {
        for (d = 0; d < q; d++)
          printf("%d\t", multiply[d][c]);			
        printf("\n");
      }
    
    return 0;
  }
```

Luckily, you have taken some computer science courses before, and remembered that a basic metric for evaluating the performance of the program is instructions/cycle (IPC), i.e., how many instructions has been executed per CPU clock cycle. Thus, the task at hand is to obtain that measurement for your program. 

To obtain the no. of instructions and total cycles taken during execution, you can run it on the CPU simulator or use source/binary instrumentation technique. However, these tools do not provide an actual IPC measurement, as they are simulated environments. 

*So, how do you measure performance of program on a real hardware?*

Approach: Hardware performance counters (HPC) offer a solution.


# 1. Introduction to Hardware Performance Counter (HPC)

Modern processors (such as Intel, AMD) facilitates HPCs, which measure events related to -- instructions, memory and execution behavior on CPU pipeline. You can measure events -- such as instructions, cycles, cache (L1/L2) access, translation lookaside buffer access, main memory access -- during program execution. On Intel processor, this functional unit is named as Performance Monitoring Unit (PMU).

In this tutorial, we will use the code snippet from our HPC driver available at **[../drv/HPCTestDrv.c](../drv/HPCTestDrv.c)**

**Our objective: Obtain number of retired instructions and CPU cycles using HPCs to compute IPC** 

Intel processors provide 3 fixed counters, each of 48-bit, that measure the number of instructions, cycles per logical core and cycles per core, respectively. The measurements from these counters can allow us to compute the IPC. 

**Note:** Modern processor divides each physical core into two or more cores, a.k.a logical core, to maximize the utilization of the CPU pipeline, similar to the multithreading in software (called as **Hyperthreading** technology by Intel).

## I. How to obtain HPC data?

The basic idea is to configure HPCs before your program starts execution. Once your program terminates, you then read the counter data. 

### A. Configure HPC 
HPCs can be configured only in kernel mode. You can write a custom kernel driver in order to configure HPCs. HPCs can be configured by using model specific registers (MSRs). One can use specific Intel instructions, namely **wrmsr** and **rdmsr** to write and read MSRs, respectively. We can also use a wrapper in the usermode, which can initialize and unload the kernel driver. 

In this tutorial we will refer to kernel functions WriteMSR and ReadMSR that are defined below:

```bash
  /*
  * Write into MSR registers
  */
  void WriteMSR(int lowVal, int highVal, int addr){
    __asm{
      mov eax, lowVal
      mov edx, highVal
      mov ecx, addr
      wrmsr
    }
  }

  WriteMSR(0x0000022A, 0x00000000, 0x38D);
```

```bash
  /*
  * Read MSR registers
  */
  INT64 ReadMSR(int addr){
    int lowVal = 0, highVal = 0; 
    INT64 combinedVal = 0;
    
    __asm{
      mov ecx, addr
      rdmsr
      mov lowVal, eax
      mov highVal, edx
    }
    combinedVal = Extract48BitVal(lowVal, highVal);
    return combinedVal;
  }

  INT64 combinedVal = ReadMSR(addr);
```
The **rdmsr** and **wrmsr** assembly instructions use the value in the register ecx to specify which MSR to access. Since the MSRs are 64-bit long we need to use two 32 bit registers (namely eax and edx) to load/store the lower and higher bits of the MSR.

HPCs can be configured in three steps (as per Chapter 18 of Intel SDM):

#### 1. Configure fixed counters via IA32_FIXED_CTR_CTRL MSR (0x38D)
  - Assign ‘1’ to bits 1, 5 & 9 to enable 3 fixed counters (CTR0, CTR1, CTR2) to count events in usermode only, otherwise ‘0’

<p><img src="./images/image5.png" alt="sample" height="50%" width="50%" align="middle"></p> 

```bash
  WriteMSR(0x0000022A, 0x00000000, 0x38D);
```

#### 2. Enable all fixed counters via IA32_PERF_GLOBAL_CTRL MSR (0x38F)
  - Set bits corresponding to fixed counter to ‘1’, otherwise ‘0’. 

<p><img src="./images/image3.png" alt="sample" height="50%" width="50%" align="middle"></p> 

```bash
  WriteMSR(0x0000000F, 0x00000007, 0x38F);
```

#### 3. Zero out the counters to clear any previous values 
  - You need to zero out the counters during configuration to collect accurate measurement. To zero out a counter write a value 0 to its address.

```bash
  WriteMSR(0x00000000, 0x00000000, 0x309);
```

### B. Read HPC data
- Once the program terminates the execution, you need to obtain counter data.

- To read the performance counter values we use the kernel function ReadMSR. It reads the value of MSR specified by the address.
  - Fixed counter addresses (addr) -- 0x309, 0x30A, 0x30B
  - Execute **rdmsr** instruction.
  - 48-bit counter data is collected in edx:eax registers (higher 16-bits in edx and lower 32-bits in eax register).  

```bash
  INT64 combinedVal = ReadMSR(addr);
```

Finally, you can calculate instructions/cycles (IPC) of your program by using HPC data as follows:  

```bash
  1. Execute wrapper program 
    - Configures the HPC counters at the driver startup
  2. Run your program (e.g., matrix multiplication)
  3. Stop the wrapper program
    - Stops the HPC driver and outputs the HPC data
```

## II. Tutorial 1 :computer:
- The test program (i.e., matrix multiplication) is shown in [./test.c](./test.c), which is instrumented with “int 2e”. Compile it using C compiler.
- Configure and build HPC driver in **POLLING** mode by following the steps in [README.md](../README.md). 
- Estimate IPC for your test program using the count of instructions and cycles. 

### Findings :bulb:
- For my program, IPC = 0.781, with no. of instructions = 7348872, logical cycles = 9402846, core cycles = 8634600. 
- What is the IPC measurement in your case? Why is IPC low in my program? Generally, modern processors have high IPC > 1.

### Discussion :thought_balloon:
- How can we get more information about our program to find the reason for low performance? Can we monitor other parameters too?
- Why is logical cycle and core cycle values different, though our VM has only one logical core? 
- Does each run have same counter values?
- Why each run has different counter values for the same test program?
- Is the counter data only related to our test program?
- What are the sources of noise?
- How can we obtain counter data per-process?


# 2. Programmable Monitoring Counters (PMCs)
In the previous section, we learned how to monitor instructions and CPU cycles using HPCs. Instruction per cycle metric gives an idea of how our program performs on the hardware during execution. Still, we  want to learn more about the execution behavior. For example, we need to know if the program exhibits memory accesses, cache misses, branch mispredictions in an abnormal way. Those are costly operations and understanding their behavior can yield deeper insights on the root cause of program's poor performance.

**Our objective: Understand how to measure cache, memory, branch related events during execution.**

*Approach:* Performance Monitoring Unit (PMU) in Intel CPU allows monitoring of events related to CPU microarchitecture -- such as branch, caches, memory, translation lookaside buffers. There are 100s of such events. In addition to 3 fixed counters that we used in the previous part, PMU provides 4 programmable counters (PMCs) to monitor 4 additional events. The events that have to be monitored are selected using MSRs. A comprehensive list of the performance monitoring events is listed in the [Chapter 19 of Intel's Software Developer's Manual (SDM)]((https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-3a-part-1-manual.pdf)). Next we will use PMCs to monitor these events.

## I. How to obtain PMC data?

Similar to fixed performance counters, we configure PMCs by using MSRs. 

### A. Configure PMC
  - Follow the steps below to configure PMCs:

#### 1. Configure PMCs via IA32_PERFEVTSELx MSRs
  - Event and its unit mask can be obtained from Chapter 19 of Intel SDM
  - Set bit 16 to ‘1’ to count only in usermode
  - Set bit 22 to ‘1’ to enable the counter
  - Set other bits to ‘0’
  - Use ecx to assign the address of IA32_PERFEVTSELx  MSR
    - Addresses are: 0x186, 0x187, 0x188, 0x189 (see Chapter 35 of Intel SDM)
  
<p><img src="./images/image6.png" alt="sample" height="50%" width="50%" align="middle"></p> 

  Here we aim to monitor following events -- branch misprediction, cache miss (L3 cache), no. of load and no. of store operations.

```bash
  //Configure HPC events to monitor userspace events
  #define EVENT0	0x004100C5    //Number of mispredicted branch instructions
  #define EVENT1	0x004101C2    //Number of L3 cache miss
  #define EVENT2	0x004181D0    //Number of load operations
  #define EVENT3	0x004182D0    //Number of store operations
    
  WriteMSR(EVENT0, 0x00000000, 0x186);
  WriteMSR(EVENT1, 0x00000000, 0x187);
  WriteMSR(EVENT2, 0x00000000, 0x188);
  WriteMSR(EVENT3, 0x00000000, 0x189);
```

#### 2. Zero out the counter values
  - Address of PMCs: 0xC1, 0xC2, 0xC3, 0xC4

```bash
  WriteMSR(0x00000000, 0x00000000, 0xC1);
  WriteMSR(0x00000000, 0x00000000, 0xC2);
  WriteMSR(0x00000000, 0x00000000, 0xC3);
  WriteMSR(0x00000000, 0x00000000, 0xC4);
```

#### 3. Enable all PMCs via IA32_PERF_GLOBAL_CTRL MSR (0x38F)
  - Set bits corresponding to PMCs to ‘1’, otherwise ‘0’. 
  - Use ecx register to write address of MSR (0x38F).

<p><img src="./images/image3.png" alt="sample" height="50%" width="50%" align="middle"></p> 

```bash
  WriteMSR(0x0000000F, 0x00000007, 0x38F);
```

### B. Read PMC data
  - After the program completes the execution, you need to obtain PMC data.
  - Follow the steps below:
    - Use ecx register to set the address for the corresponding fixed counter
      - PMC addresses (addr) -- 0xC1, 0xC2, 0xC3, 0xC4
    - Execute **rdmsr** instruction.
    - 48-bit counter data is collected in **edx:eax** register 

```bash
  INT64 combinedVal = ReadMSR(addr); 
```

You can run your program as stated below:  
```bash
  1. Execute wrapper program 
    - Configures the HPC counters at the driver initialization
  2. Run your program (e.g., matrix multiplication)
  3. Stop the wrapper program
    - Stops the HPC driver and outputs the HPC data
```

## II. Tutorial 2 :computer:
In this tutorial, we aim to obtain PMC counter data, in addition to the fixed counter data. As discussed above, we will use PMC counters to monitor 4 events -- branch misprediction, L3 cache miss, no. of loads and no. of stores. 
- Configure and build your HPC driver in **POLLING** mode (follow steps in [README.md](../README.md)).
- Run the test program, i.e., matrix multiplication.
- Observe the events. 

### Findings :bulb:
- For my program, the counter values are as follows:
  - Inst. = 9233128, logical cycles = 10451837, core cycles = 9527850 
  - Branch miss = 50525, L3 cache miss = 167232, 
  - Loads = 2736803, Stores = 1437746

- Hey, we obtained PMC data, let's discuss some of the parameters from our result. 
  - IPC (inst./logical cycles) = **0.883**
  - Branch miss rate (Branch miss/ Inst.) = 0.547%
  - L3 cache miss rate (L3 cache miss/Inst.) = **1.811%**
  - Loads/Inst. = **29.641%**
  - Stores/Inst. = 15.571%
  - Loads/Stores = **1.9035**

So, what do the highlighted numbers reveal? 
- IPC - overall execution seems a slower.
- Loads and store values show that there are more memory operations. 
- More load operations have been executed than the store operations. 

### Assignment :notebook:
We have several other events related to memory load operation: 
- mem_load_retired.l1_hit, mem_load_retired.l2_hit, mem_load_retired.l3_hit
- mem_load_retired.l1_miss, mem_load_retired.l2_miss, mem_load_retired.l3_miss
- mem_load_retired.fb_hit 

**Which event will you choose for evaluating the performance? :pensive:** 

### Discussion :thought_balloon:
We understood that our program has slower executions. There are many memory operations executed. 
1. Is the L3 cache miss value normal? 
2. Here, we lack the information about which part of the program has a low performance? 

# 3. Programmable Monitoring Interrupt (PMI)
So far we learned how to monitor and measure events using fixed and programmable counters. Using these counters, we can gain various information about the overall execution behavior of the program on CPU. However, as discussed above, by learning the overall program behavior, we cannot precisely determine which part of the program has a low performance. In order to gain this knowledge, we must be able to sample the events for each window (of certain length) during the program execution. In other words, we must be able to record the HPC data for each window during execution.   

**How to monitor events at a fine-grained level using HPCs?**
  - Well, PMU has a solution -- Performance Monitoring Interrupt (PMI). PMU allows fixed and programmable counters to generate PMI for a preset threshold value. So, we can generate a PMI for a window size, which is determined by a threshold limit preset on that counter. For example, we can monitor events for each 512,000 retired instructions during the execution. This will help us to understand which window has a slow performance, i.e., higher memory access or branch misses or memory operations.

## I. How to obtain HPC data using PMI?
  - First, we need to set a threshold limit on a counter to generate a PMI. At each PMI, we need to reset the threshold values to continue generating PMI. 

### A. PMI Configuration
  - Follow the steps below to configure PMI:

#### 1. Configure counter for PMI 
  - Enable PMI on CTR0 via IA32_FIXED_CTR_CTRL MSR (0x38D) 
  - Assign ‘1’ to bit 3 to enable PMI on fixed counter CTR0
  - Assign ‘1’ to bits 1, 5 & 9 to enable 3 fixed counters (CTR0, CTR1, CTR2) to count events in usermode only, otherwise ‘0’

<p><img src="./images/image5.png" alt="sample" height="50%" width="50%" align="middle"></p> 

```bash
  WriteMSR(0x0000022A, 0x00000000, 0x38D);
```
#### 2. Configure programmable counters as stated in Section [1-I.A](#a-configure-hpc)

#### 3. Set a threshold value for a counter 
  - Select fixed counter0 (CTR0) to generate PMI, for every 512,000 instructions retired
  - Set threshold value = - 512000 on CTR0 as:

```bash
  INT32 pmiThreshold = -512000;

  WriteMSR(pmiThreshold, 0x0000FFFF, 0x309);
``` 
#### 4. Zero out the counters 

#### 5. Enable the counters via IA32_PERF_GLOBAL_CTRL MSR (0x38F)
  - Set bits corresponding to the counters to ‘1’, otherwise ‘0’. 

<p><img src="./images/image3.png" alt="sample" height="50%" width="50%" align="middle"></p> 

```bash
    WriteMSR(0x0000000F, 0x00000007, 0x38F);
```

### B. Read and reset MSRs at PMI
  - Follow the steps below to collect data and reset MSRs:

#### 1. Read counter data 
- Read the values of the fixed and programmable counters:
  - Fixed counters MSRs -- 0x309, 0x30A, 0x30B
  - Programmable counter MSRs -- 0xC1, 0xC2, 0xC3, 0xC4

```bash
  INT64 combinedVal = ReadMSR(addr);
```

#### 2. Reset the threshold value and zero out counters as done in Section [3-I.A.3](#3-set-a-threshold-value-for-a-counter) and [3-I.A.4](#4-zero-out-the-counters)
  - Clear the overflow flag via IA32_PERF_GLOBAL_OVF_CTRL MSR (0x390)
  - Clear overflow on CTR0 to continue monitoring -- set bit 32 to ‘1’

<p><img src="./images/image4.png" alt="sample" height="50%" width="50%" align="middle"></p> 

```bash
  WriteMSR(0x00000000, 0x00000001, 0x390);
```

## II. Tutorial 3 :computer:
- In this tutorial, we aim to obtain PMC counter data, in addition to the fixed counter data. As discussed above, we will use PMC counters to monitor 4 events -- branch misprediction, L3 cache miss, no. of loads and no. of stores. 
  - Configure and build your HPC driver in the **SAMPLING** mode by following the instruction in [README.md](../README.md).
  - Run the test program (i.e., matrix multiplication).
  - Observe the events.
  - Plot the graph.

### Findings :bulb:
- I plotted the graph for the parameters we observed in Tutorial 3. My test program shows following graph. 

<p><img src="./images/image1.png" alt="sample" height="50%" width="50%" align="middle"></p> 

Can we understand the performance behavior from these graphs?
- From the graphs, it is not evident the exact window where the performance is low. Because this example (matrix multiplication) does not have terribly bad performance. However, using this example, we learnt how to use the HPCs. :smile:

### Assignment :notebook:
- Can we observe the behavior for other events?

### Discussion :thought_balloon:
- How can we obtain counter data per-process?
  - We monitor context switch to save the HPC values for a process.

## III. Frequently Asked Questions :question:

1. Can we generate PMI on multiple counters? 
  - Yes we can generate PMI for more than one counter. We can follow the configuration steps similar to PMI Configuration.

2. How to check which counter triggered the PMI? Is it necessary to check?
  - We can read IA32_PERF_GLOBAL_STATUS MSR to check which counter triggered the PMI. When the counter reaches the preset threshold value, overflow occurs and the corresponding bit in this MSR is set to ‘1’. At each PMI, we can check this MSR so that we can perform different operations for different counter overflows.

**Check overflow status at each PMI**
- via IA32_PERF_GLOBAL_STATUS MSR (0x38E)
- when overflow occurs corresponding counter bit is 1 

<p><img src="./images/image2.png" alt="sample" height="50%" width="50%" align="middle"></p> 

```bash
  INT64 combinedVal = ReadMSR(addr);
```

## Recommended Readings: :books:
- Intel Software Developer's Manual Chapter 18: Performance Monitoring  (https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-3a-part-1-manual.pdf).
- Intel Software Developer's Manual Chapter 19: Performance-Monitoring Events (https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-3a-part-1-manual.pdf).
- Intel Software Developer's Manual Chapter 35: Model-Specific Registers (MSRs) (https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-3a-part-1-manual.pdf).
- Tutorial - Linux kernel profiling with perf [https://perf.wiki.kernel.org/index.php/Tutorial](https://perf.wiki.kernel.org/index.php/Tutorial)
- Computer Architecture: A Quantitative Approach. David Patterson, John L. Hennessy

Cite as: :star:
--------------------------------
**If you use this tool, please cite as:**

*Das, S., Werner, J., Antonakakis, M., Polychronakis, M. and Monrose, F., 2019, May. SoK: The Challenges, Pitfalls, and Perils of Using Hardware Performance Counters for Security. To appear in Proceedings of the 40th IEEE Symposium on Security and Privacy (S&P).*

```